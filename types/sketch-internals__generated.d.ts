/****** OVERRIDES ********/

// block alias
declare type Block = any
declare type BCVoidBlock = Block
declare type CHStringAttributesCompareBlock = Block
declare type CHStringWordEnumeratorBlock = Block
declare type BCDictionaryFilterBlock = Block
declare type CGContextDrawBlock = Block
declare type BCTimerBlock = Block
declare type BCConcurrentMapCompletionBlock = Block
declare type BCSumBlock = Block
declare type BCMapTableFilterBlock = Block
declare type MSDocumentIteratorBlock = Block
declare type ECTestComparisonBlock = Block
declare type MSPreviewGeneratorBlock = Block
declare type MSLayerFilterBlock = Block
declare type MSSelectionModifierBlock = Block
declare type MSLayerIteratorBlock = Block
declare type MSLayerIteratorTestBlock = Block
declare type MSRenameSharedObjectBlock = Block
declare type BCMagnifierCompletionBlock = Block
declare type FBCurveIntersectionBlock = Block
declare type BCCacheCreateObjectBlock = Block
declare type ProgressBlock = Block
declare type MSLayerEnumeratorBlock = Block
declare type MSLayerSimpleEnumeratorBlock = Block
declare type MSUndoActionBlock = Block
declare type imageGenerationBlock = Block
declare type MSColorFinderCompletionBlock = Block
declare type MSWebExporterCompletionBlock = Block
declare type MSFlashViewControllerBlock = Block
declare type MSFlashControllerHelpBlock = Block
declare type MSColorConvertibleHandler = Block
declare type MSDataApplierBlock = Block
declare type MSManifestImageProviderBlock = Block
declare type MSAveragingRenderMonitorUpdateBlock = Block
declare type MSAttributeConverterBlock = Block
declare type MSActionFakeActionBlock = Block
declare type NSComparator = Block
declare type MSDocumentPreviewImageHandler = Block
declare type MSAnimationBlock = Block
declare type MSColorInspectorSetupBlock = Block
declare type MSCreateSymbolCompletionBlock = Block
declare type MSExportManagerSliceCompletionBlock = Block
declare type MSFontFamilyPickerCompletionBlock = Block
declare type MSInsertTextEventHandlerCompletionBlock = Block
declare type NSItemProviderLoadHandler = Block
declare type NSItemProviderCompletionHandler = Block
declare type MSBezierPathModifierBlock = Block
declare type MSPasteboardItemWritingBlock = Block
declare type MSPreviewImageHandler = Block
declare type dispatch_block_t = Block
declare type MSSaveAsTemplateSheetCompletionBlock = Block
declare type NSProgressPublishingHandler = Block
declare type NSUserScriptTaskCompletionHandler = Block
declare type NSUserUnixTaskCompletionHandler = Block
declare type NSUserAppleScriptTaskCompletionHandler = Block
declare type NSUserAutomatorTaskCompletionHandler = Block
declare type GradientInterpolationFunction = Block
declare type BCOutlineViewControllerPostRefreshBlock = Block
declare type FMDBExecuteStatementsCallbackBlock = Block
declare type CGPDFOperatorCallback = Block
declare type ArgumentBlock = Block
declare type BITCustomCrashReportUIHandler = Block
declare type BITCrashManagerPostCrashSignalCallback = Block
declare type BITLogHandler = Block
declare type MSNetworkTimeCompletionBlock = Block
declare type SCKDownloadOperationHandler = Block
declare type MSTextSectionParagraphEnumerator = Block
declare type MSTextSectionStringEnumerator = Block
declare type MSForeignObjectCollectionFilter = Block
declare type MSRenderMonitorHook = Block
declare type MSLineShapeCreatorBlock = Block
declare type MSCommandPreparation = Block
declare type MSDataPropertyEnumerator = Block
declare type MSDescendantEnumerator = Block
declare type MSToolCompletionHandler = Block

// C types
declare type CGPath = any
declare type NSFetchRequest = any
declare type NSManagedObjectModel = any
declare type NSAttributeType = number
declare type NSEntityDescription = any

// CORE SERVICES TYPES
declare type DescType = any
declare type OSType = any
declare type SInt32 = number
declare type AEEventClass = any
declare type AEEventID = any
declare type AEReturnID = any
declare type AETransactionID = any
declare type pid_t = any
declare type AEDesc = any
declare type AEKeyword = any
declare type AppleEvent = any
declare type SRefCon = any
declare type OSErr = any
declare type OSStatus = any

// JAVASCRIPT CORE TYPES
declare type JSValueRef = any
declare type JSContextRef = any
declare type JSObjectRef = JSValueRef
declare type JSGlobalContextRef = JSContextRef
declare type JSPropertyAttributes = any
declare type JSClassRef = any
declare type MOObjCOwnershipRule = any
declare type ffi_type = any

// CORE DATA TYPES
declare type NSManagedObjectContext = any

// Webkit
declare interface IWebUIDelegate {}
declare interface IWebResourceLoadDelegate {}
declare interface IWebFrameLoadDelegate {}
declare interface IWKExtensionDelegate {}

declare type IBAction = any
declare type Protocol = any

declare type FBFloat = CGFloat
declare type FBPoint = NSPoint
declare type FBSize = NSSize
declare type FBRect = NSRect
declare type FBBezierPath = NSBezierPath

declare type CFTimeInterval = number
declare type CVTimeStamp = number
declare type CFTypeRef = any

declare type dispatch_group_t = any
declare type dispatch_queue_t = any
declare type uuid_t = any
declare type au_asid_t = any
declare type uid_t = any
declare type gid_t = any
declare type int16_t = any
declare type size_t = any

// METAL TYPES
declare type MTLPixelFormat = number
declare type MTLClearColor = {
  red: number
  green: number
  blue: number
  alpha: number
}

declare type mach_port_t = number
declare type sockaddr_ = number

declare type compression_algorithm = any
declare type dispatch_data_t = any

declare type CKShare = any
declare type CKContainer = any
declare type CKShareMetadata = any

declare type SecIdentityRef = any
declare type SecTrustRef = any
declare type SSLProtocol = any

declare type CIFilter = any
declare type CIContext = any

declare type IconRef = any
declare type QTMovie = any

declare type _CGLPixelFormatObject = any
declare type GLint = any
declare type GLuint = any
declare type GLenum = any
declare type GLsizei = any
declare type _CGLPBufferObject = any
declare type _CGLContextObject = any
declare type GLbitfield = any

declare type SCNetworkReachabilityRef = any

// TODO: find why this is not auto generated
type NSTypesetterGlyphInfo = any
interface IMSSliceLayerWatcher {}
interface IMSAllRenderers extends IMSLayerRenderer, IMSPathRenderer, IMSFillRenderer, IMSBackgroundBlurRenderer, IMSShadowRenderer, IMSGridRenderer {}
interface INSCollectionViewElement {}
interface INSAccessibilityTable {}
interface INSTextAttachmentContainer {}
interface INSTextLayoutOrientationProvider {}
interface IECIODelegate {}
interface ISCKDiff {}
interface IMSLayer {}
interface NSOpenGLLayer extends CALayer {}
interface NSOpenGLLayerAllocator<InitializedType = NSOpenGLLayer> extends CALayerAllocator<NSOpenGLLayer> {}

/****** AUTO GENERATED ********/

interface CAAnimationAllocator<InitializedType = CAAnimation> extends NSObjectAllocator<CAAnimation> {}
interface CAAnimation extends NSObject {
  shouldArchiveValueForKey(key: NSString | string): boolean;

  timingFunction(): CAMediaTimingFunction;
  setTimingFunction(timingFunction: CAMediaTimingFunction): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  removedOnCompletion(): boolean;
  setRemovedOnCompletion(removedOnCompletion: boolean): void;
}
declare const CAAnimation: {
  alloc(): CAAnimationAllocator;  animation(): CAAnimation;
  defaultValueForKey(key: NSString | string): any;

}

interface CAPropertyAnimationAllocator<InitializedType = CAPropertyAnimation> extends CAAnimationAllocator<CAPropertyAnimation> {}
interface CAPropertyAnimation extends CAAnimation {

  keyPath(): NSString;
  setKeyPath(keyPath: NSString | string): void;
  additive(): boolean;
  setAdditive(additive: boolean): void;
  cumulative(): boolean;
  setCumulative(cumulative: boolean): void;
  valueFunction(): CAValueFunction;
  setValueFunction(valueFunction: CAValueFunction): void;
}
declare const CAPropertyAnimation: {
  alloc(): CAPropertyAnimationAllocator;  animationWithKeyPath(path: NSString | string | null): CAPropertyAnimation;

}

interface CABasicAnimationAllocator<InitializedType = CABasicAnimation> extends CAPropertyAnimationAllocator<CABasicAnimation> {}
interface CABasicAnimation extends CAPropertyAnimation {

  fromValue(): any;
  setFromValue(fromValue: any): void;
  toValue(): any;
  setToValue(toValue: any): void;
  byValue(): any;
  setByValue(byValue: any): void;
}
declare const CABasicAnimation: {
  alloc(): CABasicAnimationAllocator;
}

interface CAKeyframeAnimationAllocator<InitializedType = CAKeyframeAnimation> extends CAPropertyAnimationAllocator<CAKeyframeAnimation> {}
interface CAKeyframeAnimation extends CAPropertyAnimation {

  values(): NSArray<any>;
  setValues(values: NSArray<any> | any[]): void;
  path(): CGPathRef;
  setPath(path: CGPathRef): void;
  keyTimes(): NSArray<any>;
  setKeyTimes(keyTimes: NSArray<any> | any[]): void;
  timingFunctions(): NSArray<any>;
  setTimingFunctions(timingFunctions: NSArray<any> | any[]): void;
  calculationMode(): NSString;
  setCalculationMode(calculationMode: NSString | string): void;
  tensionValues(): NSArray<any>;
  setTensionValues(tensionValues: NSArray<any> | any[]): void;
  continuityValues(): NSArray<any>;
  setContinuityValues(continuityValues: NSArray<any> | any[]): void;
  biasValues(): NSArray<any>;
  setBiasValues(biasValues: NSArray<any> | any[]): void;
  rotationMode(): NSString;
  setRotationMode(rotationMode: NSString | string): void;
}
declare const CAKeyframeAnimation: {
  alloc(): CAKeyframeAnimationAllocator;
}

interface CASpringAnimationAllocator<InitializedType = CASpringAnimation> extends CABasicAnimationAllocator<CASpringAnimation> {}
interface CASpringAnimation extends CABasicAnimation {

  mass(): CGFloat;
  setMass(mass: CGFloat): void;
  stiffness(): CGFloat;
  setStiffness(stiffness: CGFloat): void;
  damping(): CGFloat;
  setDamping(damping: CGFloat): void;
  initialVelocity(): CGFloat;
  setInitialVelocity(initialVelocity: CGFloat): void;
  settlingDuration(): CFTimeInterval;
}
declare const CASpringAnimation: {
  alloc(): CASpringAnimationAllocator;
}

interface CATransitionAllocator<InitializedType = CATransition> extends CAAnimationAllocator<CATransition> {}
interface CATransition extends CAAnimation {

  type(): NSString;
  setType(type: NSString | string): void;
  subtype(): NSString;
  setSubtype(subtype: NSString | string): void;
  startProgress(): number;
  setStartProgress(startProgress: number): void;
  endProgress(): number;
  setEndProgress(endProgress: number): void;
  filter(): any;
  setFilter(filter: any): void;
}
declare const CATransition: {
  alloc(): CATransitionAllocator;
}

interface CAAnimationGroupAllocator<InitializedType = CAAnimationGroup> extends CAAnimationAllocator<CAAnimationGroup> {}
interface CAAnimationGroup extends CAAnimation {

  animations(): NSArray<any>;
  setAnimations(animations: NSArray<any> | any[]): void;
}
declare const CAAnimationGroup: {
  alloc(): CAAnimationGroupAllocator;
}

interface ICAAnimationDelegate {
  animationDidStart(anim: CAAnimation): void;
  animationDidStop_finished(anim: CAAnimation, flag: boolean): void;
}

interface CALayerAllocator<InitializedType = CALayer> extends NSObjectAllocator<CALayer> {
  init(): InitializedType;
  initWithLayer(layer: any): InitializedType;
}
interface CALayer extends NSObject, INSSecureCoding, ICAMediaTiming {
  addConstraint(c: CAConstraint): void;
  presentationLayer(): CALayer;
  modelLayer(): CALayer;
  shouldArchiveValueForKey(key: NSString | string): boolean;
  affineTransform(): CGAffineTransform;
  setAffineTransform(m: CGAffineTransform): void;
  contentsAreFlipped(): boolean;
  removeFromSuperlayer(): void;
  addSublayer(layer: CALayer): void;
  insertSublayer_atIndex(layer: CALayer, idx: number): void;
  insertSublayer_below(layer: CALayer, sibling: CALayer | null): void;
  insertSublayer_above(layer: CALayer, sibling: CALayer | null): void;
  replaceSublayer_with(layer: CALayer, layer2: CALayer): void;
  convertPoint_fromLayer(p: CGPoint, l: CALayer | null): CGPoint;
  convertPoint_toLayer(p: CGPoint, l: CALayer | null): CGPoint;
  convertRect_fromLayer(r: CGRect, l: CALayer | null): CGRect;
  convertRect_toLayer(r: CGRect, l: CALayer | null): CGRect;
  convertTime_fromLayer(t: CFTimeInterval, l: CALayer | null): CFTimeInterval;
  convertTime_toLayer(t: CFTimeInterval, l: CALayer | null): CFTimeInterval;
  hitTest(p: CGPoint): CALayer;
  containsPoint(p: CGPoint): boolean;
  display(): void;
  setNeedsDisplay(): void;
  setNeedsDisplayInRect(r: CGRect): void;
  needsDisplay(): boolean;
  displayIfNeeded(): void;
  drawInContext(ctx: CGContextRef): void;
  renderInContext(ctx: CGContextRef): void;
  preferredFrameSize(): CGSize;
  setNeedsLayout(): void;
  needsLayout(): boolean;
  layoutIfNeeded(): void;
  layoutSublayers(): void;
  resizeSublayersWithOldSize(size: CGSize): void;
  resizeWithOldSuperlayerSize(size: CGSize): void;
  actionForKey(event: NSString | string): any;
  addAnimation_forKey(anim: CAAnimation, key: NSString | string | null): void;
  removeAllAnimations(): void;
  removeAnimationForKey(key: NSString | string): void;
  animationKeys(): NSArray<any>;
  animationForKey(key: NSString | string): CAAnimation;
  scrollPoint(p: CGPoint): void;
  scrollRectToVisible(r: CGRect): void;

  constraints(): NSArray<any>;
  setConstraints(constraints: NSArray<any> | any[]): void;
  bounds(): CGRect;
  setBounds(bounds: CGRect): void;
  position(): CGPoint;
  setPosition(position: CGPoint): void;
  zPosition(): CGFloat;
  setZPosition(zPosition: CGFloat): void;
  anchorPoint(): CGPoint;
  setAnchorPoint(anchorPoint: CGPoint): void;
  anchorPointZ(): CGFloat;
  setAnchorPointZ(anchorPointZ: CGFloat): void;
  transform(): CATransform3D;
  setTransform(transform: CATransform3D): void;
  frame(): CGRect;
  setFrame(frame: CGRect): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  doubleSided(): boolean;
  setDoubleSided(doubleSided: boolean): void;
  geometryFlipped(): boolean;
  setGeometryFlipped(geometryFlipped: boolean): void;
  superlayer(): CALayer;
  sublayers(): NSArray<any>;
  setSublayers(sublayers: NSArray<any> | any[]): void;
  sublayerTransform(): CATransform3D;
  setSublayerTransform(sublayerTransform: CATransform3D): void;
  mask(): CALayer;
  setMask(mask: CALayer): void;
  masksToBounds(): boolean;
  setMasksToBounds(masksToBounds: boolean): void;
  contents(): any;
  setContents(contents: any): void;
  contentsRect(): CGRect;
  setContentsRect(contentsRect: CGRect): void;
  contentsGravity(): NSString;
  setContentsGravity(contentsGravity: NSString | string): void;
  contentsCenter(): CGRect;
  setContentsCenter(contentsCenter: CGRect): void;
  minificationFilter(): NSString;
  setMinificationFilter(minificationFilter: NSString | string): void;
  magnificationFilter(): NSString;
  setMagnificationFilter(magnificationFilter: NSString | string): void;
  minificationFilterBias(): number;
  setMinificationFilterBias(minificationFilterBias: number): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
  needsDisplayOnBoundsChange(): boolean;
  setNeedsDisplayOnBoundsChange(needsDisplayOnBoundsChange: boolean): void;
  edgeAntialiasingMask(): CAEdgeAntialiasingMask;
  setEdgeAntialiasingMask(edgeAntialiasingMask: CAEdgeAntialiasingMask): void;
  backgroundColor(): CGColorRef;
  setBackgroundColor(backgroundColor: CGColorRef): void;
  cornerRadius(): CGFloat;
  setCornerRadius(cornerRadius: CGFloat): void;
  borderWidth(): CGFloat;
  setBorderWidth(borderWidth: CGFloat): void;
  borderColor(): CGColorRef;
  setBorderColor(borderColor: CGColorRef): void;
  opacity(): number;
  setOpacity(opacity: number): void;
  compositingFilter(): any;
  setCompositingFilter(compositingFilter: any): void;
  filters(): NSArray<any>;
  setFilters(filters: NSArray<any> | any[]): void;
  backgroundFilters(): NSArray<any>;
  setBackgroundFilters(backgroundFilters: NSArray<any> | any[]): void;
  shouldRasterize(): boolean;
  setShouldRasterize(shouldRasterize: boolean): void;
  rasterizationScale(): CGFloat;
  setRasterizationScale(rasterizationScale: CGFloat): void;
  shadowColor(): CGColorRef;
  setShadowColor(shadowColor: CGColorRef): void;
  shadowOpacity(): number;
  setShadowOpacity(shadowOpacity: number): void;
  shadowOffset(): CGSize;
  setShadowOffset(shadowOffset: CGSize): void;
  shadowRadius(): CGFloat;
  setShadowRadius(shadowRadius: CGFloat): void;
  shadowPath(): CGPathRef;
  setShadowPath(shadowPath: CGPathRef): void;
  autoresizingMask(): CAAutoresizingMask;
  setAutoresizingMask(autoresizingMask: CAAutoresizingMask): void;
  layoutManager(): any;
  setLayoutManager(layoutManager: any): void;
  actions(): NSDictionary<any, any>;
  setActions(actions: NSDictionary<any, any> | {[key: string]: any}): void;
  name(): NSString;
  setName(name: NSString | string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  style(): NSDictionary<any, any>;
  setStyle(style: NSDictionary<any, any> | {[key: string]: any}): void;
  visibleRect(): CGRect;
}
declare const CALayer: {
  alloc(): CALayerAllocator;  layer(): CALayer;
  defaultValueForKey(key: NSString | string): any;
  needsDisplayForKey(key: NSString | string): boolean;
  defaultActionForKey(event: NSString | string): any;
  layerWithRemoteClientId(client_id: number): CALayer;

}

interface CAConstraintLayoutManagerAllocator<InitializedType = CAConstraintLayoutManager> extends NSObjectAllocator<CAConstraintLayoutManager> {}
interface CAConstraintLayoutManager extends NSObject, ICALayoutManager {
}
declare const CAConstraintLayoutManager: {
  alloc(): CAConstraintLayoutManagerAllocator;  layoutManager(): CAConstraintLayoutManager;

}

interface CAConstraintAllocator<InitializedType = CAConstraint> extends NSObjectAllocator<CAConstraint> {
  initWithAttribute_relativeTo_attribute_scale_offset(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute, m: CGFloat, c: CGFloat): InitializedType;
}
interface CAConstraint extends NSObject, INSSecureCoding {

  attribute(): CAConstraintAttribute;
  sourceName(): NSString;
  sourceAttribute(): CAConstraintAttribute;
  scale(): CGFloat;
  offset(): CGFloat;
}
declare const CAConstraint: {
  alloc(): CAConstraintAllocator;  constraintWithAttribute_relativeTo_attribute_scale_offset(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute, m: CGFloat, c: CGFloat): CAConstraint;
  constraintWithAttribute_relativeTo_attribute_offset(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute, c: CGFloat): CAConstraint;
  constraintWithAttribute_relativeTo_attribute(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute): CAConstraint;

}

declare enum CAConstraintAttribute {
  kCAConstraintMinX,
  kCAConstraintMidX,
  kCAConstraintMaxX,
  kCAConstraintWidth,
  kCAConstraintMinY,
  kCAConstraintMidY,
  kCAConstraintMaxY,
  kCAConstraintHeight,
}

interface CAEmitterCellAllocator<InitializedType = CAEmitterCell> extends NSObjectAllocator<CAEmitterCell> {}
interface CAEmitterCell extends NSObject, INSSecureCoding, ICAMediaTiming {
  shouldArchiveValueForKey(key: NSString | string): boolean;

  name(): NSString;
  setName(name: NSString | string): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  birthRate(): number;
  setBirthRate(birthRate: number): void;
  lifetime(): number;
  setLifetime(lifetime: number): void;
  lifetimeRange(): number;
  setLifetimeRange(lifetimeRange: number): void;
  emissionLatitude(): CGFloat;
  setEmissionLatitude(emissionLatitude: CGFloat): void;
  emissionLongitude(): CGFloat;
  setEmissionLongitude(emissionLongitude: CGFloat): void;
  emissionRange(): CGFloat;
  setEmissionRange(emissionRange: CGFloat): void;
  velocity(): CGFloat;
  setVelocity(velocity: CGFloat): void;
  velocityRange(): CGFloat;
  setVelocityRange(velocityRange: CGFloat): void;
  xAcceleration(): CGFloat;
  setXAcceleration(xAcceleration: CGFloat): void;
  yAcceleration(): CGFloat;
  setYAcceleration(yAcceleration: CGFloat): void;
  zAcceleration(): CGFloat;
  setZAcceleration(zAcceleration: CGFloat): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  scaleRange(): CGFloat;
  setScaleRange(scaleRange: CGFloat): void;
  scaleSpeed(): CGFloat;
  setScaleSpeed(scaleSpeed: CGFloat): void;
  spin(): CGFloat;
  setSpin(spin: CGFloat): void;
  spinRange(): CGFloat;
  setSpinRange(spinRange: CGFloat): void;
  color(): CGColorRef;
  setColor(color: CGColorRef): void;
  redRange(): number;
  setRedRange(redRange: number): void;
  greenRange(): number;
  setGreenRange(greenRange: number): void;
  blueRange(): number;
  setBlueRange(blueRange: number): void;
  alphaRange(): number;
  setAlphaRange(alphaRange: number): void;
  redSpeed(): number;
  setRedSpeed(redSpeed: number): void;
  greenSpeed(): number;
  setGreenSpeed(greenSpeed: number): void;
  blueSpeed(): number;
  setBlueSpeed(blueSpeed: number): void;
  alphaSpeed(): number;
  setAlphaSpeed(alphaSpeed: number): void;
  contents(): any;
  setContents(contents: any): void;
  contentsRect(): CGRect;
  setContentsRect(contentsRect: CGRect): void;
  contentsScale(): CGFloat;
  setContentsScale(contentsScale: CGFloat): void;
  minificationFilter(): NSString;
  setMinificationFilter(minificationFilter: NSString | string): void;
  magnificationFilter(): NSString;
  setMagnificationFilter(magnificationFilter: NSString | string): void;
  minificationFilterBias(): number;
  setMinificationFilterBias(minificationFilterBias: number): void;
  emitterCells(): NSArray<any>;
  setEmitterCells(emitterCells: NSArray<any> | any[]): void;
  style(): NSDictionary<any, any>;
  setStyle(style: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const CAEmitterCell: {
  alloc(): CAEmitterCellAllocator;  emitterCell(): CAEmitterCell;
  defaultValueForKey(key: NSString | string): any;

}

interface CAEmitterLayerAllocator<InitializedType = CAEmitterLayer> extends CALayerAllocator<CAEmitterLayer> {}
interface CAEmitterLayer extends CALayer {

  emitterCells(): NSArray<any>;
  setEmitterCells(emitterCells: NSArray<any> | any[]): void;
  birthRate(): number;
  setBirthRate(birthRate: number): void;
  lifetime(): number;
  setLifetime(lifetime: number): void;
  emitterPosition(): CGPoint;
  setEmitterPosition(emitterPosition: CGPoint): void;
  emitterZPosition(): CGFloat;
  setEmitterZPosition(emitterZPosition: CGFloat): void;
  emitterSize(): CGSize;
  setEmitterSize(emitterSize: CGSize): void;
  emitterDepth(): CGFloat;
  setEmitterDepth(emitterDepth: CGFloat): void;
  emitterShape(): NSString;
  setEmitterShape(emitterShape: NSString | string): void;
  emitterMode(): NSString;
  setEmitterMode(emitterMode: NSString | string): void;
  renderMode(): NSString;
  setRenderMode(renderMode: NSString | string): void;
  preservesDepth(): boolean;
  setPreservesDepth(preservesDepth: boolean): void;
  velocity(): number;
  setVelocity(velocity: number): void;
  scale(): number;
  setScale(scale: number): void;
  spin(): number;
  setSpin(spin: number): void;
  seed(): number;
  setSeed(seed: number): void;
}
declare const CAEmitterLayer: {
  alloc(): CAEmitterLayerAllocator;
}

interface CAGradientLayerAllocator<InitializedType = CAGradientLayer> extends CALayerAllocator<CAGradientLayer> {}
interface CAGradientLayer extends CALayer {

  colors(): NSArray<any>;
  setColors(colors: NSArray<any> | any[]): void;
  locations(): NSArray<any>;
  setLocations(locations: NSArray<any> | any[]): void;
  startPoint(): CGPoint;
  setStartPoint(startPoint: CGPoint): void;
  endPoint(): CGPoint;
  setEndPoint(endPoint: CGPoint): void;
  type(): NSString;
  setType(type: NSString | string): void;
}
declare const CAGradientLayer: {
  alloc(): CAGradientLayerAllocator;
}

interface NSNullAllocator<InitializedType = NSNull> extends NSObjectAllocator<NSNull> {}
interface NSNull extends NSObject, INSCopying, INSSecureCoding {
}
declare const NSNull: {
  alloc(): NSNullAllocator;  null(): NSNull;

}

interface ICALayoutManager {
  preferredSizeOfLayer(layer: CALayer): CGSize;
  invalidateLayoutOfLayer(layer: CALayer): void;
  layoutSublayersOfLayer(layer: CALayer): void;
}

interface ICAAction {
  runActionForKey_object_arguments(event: NSString | string, anObject: any, dict: NSDictionary<any, any> | {[key: string]: any} | null): void;
}

interface ICALayerDelegate {
  displayLayer(layer: CALayer): void;
  drawLayer_inContext(layer: CALayer, ctx: CGContextRef): void;
  layoutSublayersOfLayer(layer: CALayer): void;
  actionForLayer_forKey(layer: CALayer, event: NSString | string): any;
}

declare enum CAAutoresizingMask {
  kCALayerNotSizable = 0,
  kCALayerMinXMargin = 1 << 0,
  kCALayerWidthSizable = 1 << 1,
  kCALayerMaxXMargin = 1 << 2,
  kCALayerMinYMargin = 1 << 3,
  kCALayerHeightSizable = 1 << 4,
  kCALayerMaxYMargin = 1 << 5,
}

declare enum CAEdgeAntialiasingMask {
  kCALayerLeftEdge = 1 << 0,
  kCALayerRightEdge = 1 << 1,
  kCALayerBottomEdge = 1 << 2,
  kCALayerTopEdge = 1 << 3,
}

declare enum CACornerMask {
  kCALayerMinXMinYCorner = 1 << 0,
  kCALayerMaxXMinYCorner = 1 << 1,
  kCALayerMinXMaxYCorner = 1 << 2,
  kCALayerMaxXMaxYCorner = 1 << 3,
}

interface ICAMediaTiming {

  beginTime(): CFTimeInterval;
  setBeginTime(beginTime: CFTimeInterval): void;
  duration(): CFTimeInterval;
  setDuration(duration: CFTimeInterval): void;
  speed(): number;
  setSpeed(speed: number): void;
  timeOffset(): CFTimeInterval;
  setTimeOffset(timeOffset: CFTimeInterval): void;
  repeatCount(): number;
  setRepeatCount(repeatCount: number): void;
  repeatDuration(): CFTimeInterval;
  setRepeatDuration(repeatDuration: CFTimeInterval): void;
  autoreverses(): boolean;
  setAutoreverses(autoreverses: boolean): void;
  fillMode(): NSString;
  setFillMode(fillMode: NSString | string): void;
}

interface CAMediaTimingFunctionAllocator<InitializedType = CAMediaTimingFunction> extends NSObjectAllocator<CAMediaTimingFunction> {
  initWithControlPoints___(c1x: number, c1y: number, c2x: number, c2y: number): InitializedType;
}
interface CAMediaTimingFunction extends NSObject, INSSecureCoding {
  getControlPointAtIndex_values(idx: size_t, ptr: [number, number]): void;
}
declare const CAMediaTimingFunction: {
  alloc(): CAMediaTimingFunctionAllocator;  functionWithName(name: NSString | string): CAMediaTimingFunction;
  functionWithControlPoints___(c1x: number, c1y: number, c2x: number, c2y: number): CAMediaTimingFunction;

}

interface CAMetalLayerAllocator<InitializedType = CAMetalLayer> extends CALayerAllocator<CAMetalLayer> {}
interface CAMetalLayer extends CALayer {
  nextDrawable(): any;

  device(): any;
  setDevice(device: any): void;
  pixelFormat(): MTLPixelFormat;
  setPixelFormat(pixelFormat: MTLPixelFormat): void;
  framebufferOnly(): boolean;
  setFramebufferOnly(framebufferOnly: boolean): void;
  drawableSize(): CGSize;
  setDrawableSize(drawableSize: CGSize): void;
  presentsWithTransaction(): boolean;
  setPresentsWithTransaction(presentsWithTransaction: boolean): void;
  colorspace(): CGColorSpaceRef;
  setColorspace(colorspace: CGColorSpaceRef): void;
  wantsExtendedDynamicRangeContent(): boolean;
  setWantsExtendedDynamicRangeContent(wantsExtendedDynamicRangeContent: boolean): void;
}
declare const CAMetalLayer: {
  alloc(): CAMetalLayerAllocator;
}

interface CARemoteLayerClientAllocator<InitializedType = CARemoteLayerClient> extends NSObjectAllocator<CARemoteLayerClient> {
  initWithServerPort(port: mach_port_t): InitializedType;
}
interface CARemoteLayerClient extends NSObject {
  invalidate(): void;

  clientId(): number;
  layer(): CALayer;
  setLayer(layer: CALayer): void;
}
declare const CARemoteLayerClient: {
  alloc(): CARemoteLayerClientAllocator;
}

interface CARemoteLayerServerAllocator<InitializedType = CARemoteLayerServer> extends NSObjectAllocator<CARemoteLayerServer> {}
interface CARemoteLayerServer extends NSObject {

  serverPort(): mach_port_t;
}
declare const CARemoteLayerServer: {
  alloc(): CARemoteLayerServerAllocator;  sharedServer(): CARemoteLayerServer;

}

interface CARendererAllocator<InitializedType = CARenderer> extends NSObjectAllocator<CARenderer> {}
interface CARenderer extends NSObject {
  beginFrameAtTime_timeStamp(t: CFTimeInterval, ts: CVTimeStamp | null): void;
  updateBounds(): CGRect;
  addUpdateRect(r: CGRect): void;
  render(): void;
  nextFrameTime(): CFTimeInterval;
  endFrame(): void;

  layer(): CALayer;
  setLayer(layer: CALayer): void;
  bounds(): CGRect;
  setBounds(bounds: CGRect): void;
}
declare const CARenderer: {
  alloc(): CARendererAllocator;  rendererWithCGLContext_options(ctx: void, dict: NSDictionary<any, any> | {[key: string]: any} | null): CARenderer;

}

interface CAReplicatorLayerAllocator<InitializedType = CAReplicatorLayer> extends CALayerAllocator<CAReplicatorLayer> {}
interface CAReplicatorLayer extends CALayer {

  instanceCount(): NSInteger;
  setInstanceCount(instanceCount: NSInteger): void;
  preservesDepth(): boolean;
  setPreservesDepth(preservesDepth: boolean): void;
  instanceDelay(): CFTimeInterval;
  setInstanceDelay(instanceDelay: CFTimeInterval): void;
  instanceTransform(): CATransform3D;
  setInstanceTransform(instanceTransform: CATransform3D): void;
  instanceColor(): CGColorRef;
  setInstanceColor(instanceColor: CGColorRef): void;
  instanceRedOffset(): number;
  setInstanceRedOffset(instanceRedOffset: number): void;
  instanceGreenOffset(): number;
  setInstanceGreenOffset(instanceGreenOffset: number): void;
  instanceBlueOffset(): number;
  setInstanceBlueOffset(instanceBlueOffset: number): void;
  instanceAlphaOffset(): number;
  setInstanceAlphaOffset(instanceAlphaOffset: number): void;
}
declare const CAReplicatorLayer: {
  alloc(): CAReplicatorLayerAllocator;
}

interface CAScrollLayerAllocator<InitializedType = CAScrollLayer> extends CALayerAllocator<CAScrollLayer> {}
interface CAScrollLayer extends CALayer {
  scrollToPoint(p: CGPoint): void;
  scrollToRect(r: CGRect): void;

  scrollMode(): NSString;
  setScrollMode(scrollMode: NSString | string): void;
}
declare const CAScrollLayer: {
  alloc(): CAScrollLayerAllocator;
}

interface CAShapeLayerAllocator<InitializedType = CAShapeLayer> extends CALayerAllocator<CAShapeLayer> {}
interface CAShapeLayer extends CALayer {

  path(): CGPathRef;
  setPath(path: CGPathRef): void;
  fillColor(): CGColorRef;
  setFillColor(fillColor: CGColorRef): void;
  fillRule(): NSString;
  setFillRule(fillRule: NSString | string): void;
  strokeColor(): CGColorRef;
  setStrokeColor(strokeColor: CGColorRef): void;
  strokeStart(): CGFloat;
  setStrokeStart(strokeStart: CGFloat): void;
  strokeEnd(): CGFloat;
  setStrokeEnd(strokeEnd: CGFloat): void;
  lineWidth(): CGFloat;
  setLineWidth(lineWidth: CGFloat): void;
  miterLimit(): CGFloat;
  setMiterLimit(miterLimit: CGFloat): void;
  lineCap(): NSString;
  setLineCap(lineCap: NSString | string): void;
  lineJoin(): NSString;
  setLineJoin(lineJoin: NSString | string): void;
  lineDashPhase(): CGFloat;
  setLineDashPhase(lineDashPhase: CGFloat): void;
  lineDashPattern(): NSArray<any>;
  setLineDashPattern(lineDashPattern: NSArray<any> | any[]): void;
}
declare const CAShapeLayer: {
  alloc(): CAShapeLayerAllocator;
}

interface CATextLayerAllocator<InitializedType = CATextLayer> extends CALayerAllocator<CATextLayer> {}
interface CATextLayer extends CALayer {

  string(): any;
  setString(string: any): void;
  font(): CFTypeRef;
  setFont(font: CFTypeRef): void;
  fontSize(): CGFloat;
  setFontSize(fontSize: CGFloat): void;
  foregroundColor(): CGColorRef;
  setForegroundColor(foregroundColor: CGColorRef): void;
  wrapped(): boolean;
  setWrapped(wrapped: boolean): void;
  truncationMode(): NSString;
  setTruncationMode(truncationMode: NSString | string): void;
  alignmentMode(): NSString;
  setAlignmentMode(alignmentMode: NSString | string): void;
  allowsFontSubpixelQuantization(): boolean;
  setAllowsFontSubpixelQuantization(allowsFontSubpixelQuantization: boolean): void;
}
declare const CATextLayer: {
  alloc(): CATextLayerAllocator;
}

interface CATiledLayerAllocator<InitializedType = CATiledLayer> extends CALayerAllocator<CATiledLayer> {}
interface CATiledLayer extends CALayer {

  levelsOfDetail(): size_t;
  setLevelsOfDetail(levelsOfDetail: size_t): void;
  levelsOfDetailBias(): size_t;
  setLevelsOfDetailBias(levelsOfDetailBias: size_t): void;
  tileSize(): CGSize;
  setTileSize(tileSize: CGSize): void;
}
declare const CATiledLayer: {
  alloc(): CATiledLayerAllocator;  fadeDuration(): CFTimeInterval;

}

interface CATransactionAllocator<InitializedType = CATransaction> extends NSObjectAllocator<CATransaction> {}
interface CATransaction extends NSObject {
}
declare const CATransaction: {
  alloc(): CATransactionAllocator;  begin(): void;
  commit(): void;
  flush(): void;
  lock(): void;
  unlock(): void;
  animationDuration(): CFTimeInterval;
  setAnimationDuration(dur: CFTimeInterval): void;
  animationTimingFunction(): CAMediaTimingFunction;
  setAnimationTimingFunction(functionName: CAMediaTimingFunction | null): void;
  disableActions(): boolean;
  setDisableActions(flag: boolean): void;
  setCompletionBlock(block: Block | null): void;
  valueForKey(key: NSString | string): any;
  setValue_forKey(anObject: any | null, key: NSString | string): void;
  disableAnimationsInBlock(block: BCVoidBlock): void;

}

interface NSValueAllocator<InitializedType = NSValue> extends NSObjectAllocator<NSValue> {
  initWithBytes_objCType(value: void, type: string): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSValue extends NSObject, INSCopying, INSSecureCoding {
  getValue_size(value: void, size: NSUInteger): void;
  isEqualToValue(value: NSValue): boolean;
  getValue(value: void): void;

  CATransform3DValue(): CATransform3D;
  pointValue(): NSPoint;
  sizeValue(): NSSize;
  rectValue(): NSRect;
  edgeInsetsValue(): NSEdgeInsets;
  rangeValue(): NSRange;
  objCType(): string;
  nonretainedObjectValue(): any;
  pointerValue(): void;
  CGVectorValue(): CGVector;
}
declare const NSValue: {
  alloc(): NSValueAllocator;  valueWithCATransform3D(t: CATransform3D): NSValue;
  valueWithPoint(point: NSPoint): NSValue;
  valueWithSize(size: NSSize): NSValue;
  valueWithRect(rect: NSRect): NSValue;
  valueWithEdgeInsets(insets: NSEdgeInsets): NSValue;
  valueWithRange(range: NSRange): NSValue;
  valueWithBytes_objCType(value: void, type: string): NSValue;
  value_withObjCType(value: void, type: string): NSValue;
  valueWithNonretainedObject(anObject: any | null): NSValue;
  valueWithPointer(pointer: void | null): NSValue;
  valueWithCGVector(vector: CGVector): NSValue;

}

declare type CATransform3D = {
  m11: CGFloat
  m12: CGFloat
  m13: CGFloat
  m14: CGFloat
  m21: CGFloat
  m22: CGFloat
  m23: CGFloat
  m24: CGFloat
  m31: CGFloat
  m32: CGFloat
  m33: CGFloat
  m34: CGFloat
  m41: CGFloat
  m42: CGFloat
  m43: CGFloat
  m44: CGFloat
}

interface CATransformLayerAllocator<InitializedType = CATransformLayer> extends CALayerAllocator<CATransformLayer> {}
interface CATransformLayer extends CALayer {
}
declare const CATransformLayer: {
  alloc(): CATransformLayerAllocator;
}

interface CAValueFunctionAllocator<InitializedType = CAValueFunction> extends NSObjectAllocator<CAValueFunction> {}
interface CAValueFunction extends NSObject, INSSecureCoding {

  name(): NSString;
}
declare const CAValueFunction: {
  alloc(): CAValueFunctionAllocator;  functionWithName(name: NSString | string): CAValueFunction;

}

declare type CGAffineTransform = {
  a: CGFloat
  b: CGFloat
  c: CGFloat
  d: CGFloat
  tx: CGFloat
  ty: CGFloat
}

declare type CGFloat = number

declare type CGColorRef = any

declare enum CGColorConversionInfoTransformType {
  kCGColorConversionTransformFromSpace = 0,
  kCGColorConversionTransformToSpace,
  kCGColorConversionTransformApplySpace,
}

declare type CGColorSpaceRef = any

declare enum CGColorRenderingIntent {
  kCGRenderingIntentDefault,
  kCGRenderingIntentAbsoluteColorimetric,
  kCGRenderingIntentRelativeColorimetric,
  kCGRenderingIntentPerceptual,
  kCGRenderingIntentSaturation,
}

declare enum CGColorSpaceModel {
  kCGColorSpaceModelUnknown = -1,
  kCGColorSpaceModelMonochrome,
  kCGColorSpaceModelRGB,
  kCGColorSpaceModelCMYK,
  kCGColorSpaceModelLab,
  kCGColorSpaceModelDeviceN,
  kCGColorSpaceModelIndexed,
  kCGColorSpaceModelPattern,
}

declare type CGContextRef = any

declare enum CGPathDrawingMode {
  kCGPathFill,
  kCGPathEOFill,
  kCGPathStroke,
  kCGPathFillStroke,
  kCGPathEOFillStroke,
}

declare enum CGTextDrawingMode {
  kCGTextFill,
  kCGTextStroke,
  kCGTextFillStroke,
  kCGTextInvisible,
  kCGTextFillClip,
  kCGTextStrokeClip,
  kCGTextFillStrokeClip,
  kCGTextClip,
}

declare enum CGTextEncoding {
  kCGEncodingFontSpecific,
  kCGEncodingMacRoman,
}

declare enum CGInterpolationQuality {
  kCGInterpolationDefault = 0,
  kCGInterpolationNone = 1,
  kCGInterpolationLow = 2,
  kCGInterpolationMedium = 4,
  kCGInterpolationHigh = 3,
}

declare enum CGBlendMode {
  kCGBlendModeNormal,
  kCGBlendModeMultiply,
  kCGBlendModeScreen,
  kCGBlendModeOverlay,
  kCGBlendModeDarken,
  kCGBlendModeLighten,
  kCGBlendModeColorDodge,
  kCGBlendModeColorBurn,
  kCGBlendModeSoftLight,
  kCGBlendModeHardLight,
  kCGBlendModeDifference,
  kCGBlendModeExclusion,
  kCGBlendModeHue,
  kCGBlendModeSaturation,
  kCGBlendModeColor,
  kCGBlendModeLuminosity,
  kCGBlendModeClear,
  kCGBlendModeCopy,
  kCGBlendModeSourceIn,
  kCGBlendModeSourceOut,
  kCGBlendModeSourceAtop,
  kCGBlendModeDestinationOver,
  kCGBlendModeDestinationIn,
  kCGBlendModeDestinationOut,
  kCGBlendModeDestinationAtop,
  kCGBlendModeXOR,
  kCGBlendModePlusDarker,
  kCGBlendModePlusLighter,
}

declare type CGDirectDisplayID = number

declare type CGOpenGLDisplayMask = number

declare type CGRefreshRate = number

declare type CGGammaValue = number

declare type CGDisplayCount = number

declare type CGDisplayFadeReservationToken = number

declare type CGDisplayBlendFraction = number

declare type CGDisplayFadeInterval = number

declare type CGDisplayReservationInterval = number

declare enum CGDisplayStreamUpdateRectType {
  kCGDisplayStreamUpdateRefreshedRects,
  kCGDisplayStreamUpdateMovedRects,
  kCGDisplayStreamUpdateDirtyRects,
  kCGDisplayStreamUpdateReducedDirtyRects,
}

declare enum CGDisplayStreamFrameStatus {
  kCGDisplayStreamFrameStatusFrameComplete,
  kCGDisplayStreamFrameStatusFrameIdle,
  kCGDisplayStreamFrameStatusFrameBlank,
  kCGDisplayStreamFrameStatusStopped,
}

declare enum CGError {
  kCGErrorSuccess = 0,
  kCGErrorFailure = 1000,
  kCGErrorIllegalArgument = 1001,
  kCGErrorInvalidConnection = 1002,
  kCGErrorInvalidContext = 1003,
  kCGErrorCannotComplete = 1004,
  kCGErrorNotImplemented = 1006,
  kCGErrorRangeCheck = 1007,
  kCGErrorTypeCheck = 1008,
  kCGErrorInvalidOperation = 1010,
  kCGErrorNoneAvailable = 1011,
}

declare type CGEventRef = any

declare type CGEventTimestamp = number

declare type CGEventMask = number

declare type CGEventSourceKeyboardType = number

declare enum CGMouseButton {
  kCGMouseButtonLeft = 0,
  kCGMouseButtonRight = 1,
  kCGMouseButtonCenter = 2,
}

declare enum CGScrollEventUnit {
  kCGScrollEventUnitPixel = 0,
  kCGScrollEventUnitLine = 1,
}

declare enum CGMomentumScrollPhase {
  kCGMomentumScrollPhaseNone = 0,
  kCGMomentumScrollPhaseBegin = 1,
  kCGMomentumScrollPhaseContinue = 2,
  kCGMomentumScrollPhaseEnd = 3,
}

declare enum CGScrollPhase {
  kCGScrollPhaseBegan = 1,
  kCGScrollPhaseChanged = 2,
  kCGScrollPhaseEnded = 4,
  kCGScrollPhaseCancelled = 8,
  kCGScrollPhaseMayBegin = 128,
}

declare enum CGGesturePhase {
  kCGGesturePhaseNone = 0,
  kCGGesturePhaseBegan = 1,
  kCGGesturePhaseChanged = 2,
  kCGGesturePhaseEnded = 4,
  kCGGesturePhaseCancelled = 8,
  kCGGesturePhaseMayBegin = 128,
}

declare enum CGEventType {
  kCGEventNull,
  kCGEventLeftMouseDown,
  kCGEventLeftMouseUp,
  kCGEventRightMouseDown,
  kCGEventRightMouseUp,
  kCGEventMouseMoved,
  kCGEventLeftMouseDragged,
  kCGEventRightMouseDragged,
  kCGEventKeyDown,
  kCGEventKeyUp,
  kCGEventFlagsChanged,
  kCGEventScrollWheel,
  kCGEventTabletPointer,
  kCGEventTabletProximity,
  kCGEventOtherMouseDown,
  kCGEventOtherMouseUp,
  kCGEventOtherMouseDragged,
  kCGEventTapDisabledByTimeout = 0xFFFFFFFE,
  kCGEventTapDisabledByUserInput = 0xFFFFFFFF,
}

declare enum CGEventField {
  kCGMouseEventNumber = 0,
  kCGMouseEventClickState = 1,
  kCGMouseEventPressure = 2,
  kCGMouseEventButtonNumber = 3,
  kCGMouseEventDeltaX = 4,
  kCGMouseEventDeltaY = 5,
  kCGMouseEventInstantMouser = 6,
  kCGMouseEventSubtype = 7,
  kCGKeyboardEventAutorepeat = 8,
  kCGKeyboardEventKeycode = 9,
  kCGKeyboardEventKeyboardType = 10,
  kCGScrollWheelEventDeltaAxis1 = 11,
  kCGScrollWheelEventDeltaAxis2 = 12,
  kCGScrollWheelEventDeltaAxis3 = 13,
  kCGScrollWheelEventFixedPtDeltaAxis1 = 93,
  kCGScrollWheelEventFixedPtDeltaAxis2 = 94,
  kCGScrollWheelEventFixedPtDeltaAxis3 = 95,
  kCGScrollWheelEventPointDeltaAxis1 = 96,
  kCGScrollWheelEventPointDeltaAxis2 = 97,
  kCGScrollWheelEventPointDeltaAxis3 = 98,
  kCGScrollWheelEventScrollPhase = 99,
  kCGScrollWheelEventScrollCount = 100,
  kCGScrollWheelEventMomentumPhase = 123,
  kCGScrollWheelEventInstantMouser = 14,
  kCGTabletEventPointX = 15,
  kCGTabletEventPointY = 16,
  kCGTabletEventPointZ = 17,
  kCGTabletEventPointButtons = 18,
  kCGTabletEventPointPressure = 19,
  kCGTabletEventTiltX = 20,
  kCGTabletEventTiltY = 21,
  kCGTabletEventRotation = 22,
  kCGTabletEventTangentialPressure = 23,
  kCGTabletEventDeviceID = 24,
  kCGTabletEventVendor1 = 25,
  kCGTabletEventVendor2 = 26,
  kCGTabletEventVendor3 = 27,
  kCGTabletProximityEventVendorID = 28,
  kCGTabletProximityEventTabletID = 29,
  kCGTabletProximityEventPointerID = 30,
  kCGTabletProximityEventDeviceID = 31,
  kCGTabletProximityEventSystemTabletID = 32,
  kCGTabletProximityEventVendorPointerType = 33,
  kCGTabletProximityEventVendorPointerSerialNumber = 34,
  kCGTabletProximityEventVendorUniqueID = 35,
  kCGTabletProximityEventCapabilityMask = 36,
  kCGTabletProximityEventPointerType = 37,
  kCGTabletProximityEventEnterProximity = 38,
  kCGEventTargetProcessSerialNumber = 39,
  kCGEventTargetUnixProcessID = 40,
  kCGEventSourceUnixProcessID = 41,
  kCGEventSourceUserData = 42,
  kCGEventSourceUserID = 43,
  kCGEventSourceGroupID = 44,
  kCGEventSourceStateID = 45,
  kCGScrollWheelEventIsContinuous = 88,
  kCGMouseEventWindowUnderMousePointer = 91,
  kCGMouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
}

declare enum CGEventMouseSubtype {
  kCGEventMouseSubtypeDefault = 0,
  kCGEventMouseSubtypeTabletPoint = 1,
  kCGEventMouseSubtypeTabletProximity = 2,
}

declare enum CGEventTapLocation {
  kCGHIDEventTap = 0,
  kCGSessionEventTap,
  kCGAnnotatedSessionEventTap,
}

declare enum CGEventTapPlacement {
  kCGHeadInsertEventTap = 0,
  kCGTailAppendEventTap,
}

declare enum CGEventTapOptions {
  kCGEventTapOptionDefault = 0x00000000,
  kCGEventTapOptionListenOnly = 0x00000001,
}

declare enum CGEventSourceStateID {
  kCGEventSourceStatePrivate = -1,
  kCGEventSourceStateCombinedSessionState = 0,
  kCGEventSourceStateHIDSystemState = 1,
}

declare type CGFontIndex = number

declare type CGGlyph = CGFontIndex

declare enum CGFontPostScriptFormat {
  kCGFontPostScriptFormatType1 = 1,
  kCGFontPostScriptFormatType3 = 3,
  kCGFontPostScriptFormatType42 = 42,
}

declare type CGPoint = {
  x: CGFloat
  y: CGFloat
}

declare type CGSize = {
  width: CGFloat
  height: CGFloat
}

declare type CGVector = {
  dx: CGFloat
  dy: CGFloat
}

declare type CGRect = {
  origin: CGPoint
  size: CGSize
}

declare enum CGRectEdge {
  CGRectMinXEdge,
  CGRectMinYEdge,
  CGRectMaxXEdge,
  CGRectMaxYEdge,
}

declare type CGGradientRef = any

declare type CGImageRef = any

declare enum CGImageAlphaInfo {
  kCGImageAlphaNone,
  kCGImageAlphaPremultipliedLast,
  kCGImageAlphaPremultipliedFirst,
  kCGImageAlphaLast,
  kCGImageAlphaFirst,
  kCGImageAlphaNoneSkipLast,
  kCGImageAlphaNoneSkipFirst,
  kCGImageAlphaOnly,
}

declare enum CGImageByteOrderInfo {
  kCGImageByteOrderMask = 0x7000,
  kCGImageByteOrderDefault,
  kCGImageByteOrder16Little,
  kCGImageByteOrder32Little,
  kCGImageByteOrder16Big,
  kCGImageByteOrder32Big,
}

declare type CGPDFArrayRef = any

declare type CGPDFContentStreamRef = any

declare type CGPDFDictionaryRef = any

declare type CGPDFBoolean = string

declare type CGPDFInteger = number

declare type CGPDFReal = CGFloat

declare type CGPDFObjectRef = any

declare enum CGPDFObjectType {
  kCGPDFObjectTypeNull = 1,
  kCGPDFObjectTypeBoolean,
  kCGPDFObjectTypeInteger,
  kCGPDFObjectTypeReal,
  kCGPDFObjectTypeName,
  kCGPDFObjectTypeString,
  kCGPDFObjectTypeArray,
  kCGPDFObjectTypeDictionary,
  kCGPDFObjectTypeStream,
}

declare type CGPDFPageRef = any

declare enum CGPDFBox {
  kCGPDFMediaBox = 0,
  kCGPDFCropBox = 1,
  kCGPDFBleedBox = 2,
  kCGPDFTrimBox = 3,
  kCGPDFArtBox = 4,
}

declare type CGPDFStreamRef = any

declare enum CGPDFDataFormat {
  CGPDFDataFormatRaw,
  CGPDFDataFormatJPEGEncoded,
  CGPDFDataFormatJPEG2000,
}

declare type CGPDFStringRef = any

declare type CGMutablePathRef = CGPath

declare type CGPathRef = CGPath

declare enum CGLineJoin {
  kCGLineJoinMiter,
  kCGLineJoinRound,
  kCGLineJoinBevel,
}

declare enum CGLineCap {
  kCGLineCapButt,
  kCGLineCapRound,
  kCGLineCapSquare,
}

declare enum CGPathElementType {
  kCGPathElementMoveToPoint,
  kCGPathElementAddLineToPoint,
  kCGPathElementAddQuadCurveToPoint,
  kCGPathElementAddCurveToPoint,
  kCGPathElementCloseSubpath,
}

declare enum CGPatternTiling {
  kCGPatternTilingNoDistortion,
  kCGPatternTilingConstantSpacingMinimalDistortion,
  kCGPatternTilingConstantSpacing,
}

declare type CGButtonCount = number

declare type CGWheelCount = number

declare type CGCharCode = number

declare type CGKeyCode = number

declare type CGRectCount = number

declare enum CGEventSuppressionState {
  kCGEventSuppressionStateSuppressionInterval = 0,
  kCGEventSuppressionStateRemoteMouseDrag,
  kCGNumberOfEventSuppressionStates,
}

declare type CGWindowID = number

declare enum CGWindowSharingType {
  kCGWindowSharingNone = 0,
  kCGWindowSharingReadOnly = 1,
  kCGWindowSharingReadWrite = 2,
}

declare enum CGWindowBackingType {
  kCGBackingStoreRetained = 0,
  kCGBackingStoreNonretained = 1,
  kCGBackingStoreBuffered = 2,
}

declare type CGWindowLevel = number

declare enum CGWindowLevelKey {
  kCGBaseWindowLevelKey = 0,
  kCGMinimumWindowLevelKey,
  kCGDesktopWindowLevelKey,
  kCGBackstopMenuLevelKey,
  kCGNormalWindowLevelKey,
  kCGFloatingWindowLevelKey,
  kCGTornOffMenuWindowLevelKey,
  kCGDockWindowLevelKey,
  kCGMainMenuWindowLevelKey,
  kCGStatusWindowLevelKey,
  kCGModalPanelWindowLevelKey,
  kCGPopUpMenuWindowLevelKey,
  kCGDraggingWindowLevelKey,
  kCGScreenSaverWindowLevelKey,
  kCGMaximumWindowLevelKey,
  kCGOverlayWindowLevelKey,
  kCGHelpWindowLevelKey,
  kCGUtilityWindowLevelKey,
  kCGDesktopIconWindowLevelKey,
  kCGCursorWindowLevelKey,
  kCGAssistiveTechHighWindowLevelKey,
  kCGNumberOfWindowLevelKeys,
}

interface NSAffineTransformAllocator<InitializedType = NSAffineTransform> extends NSObjectAllocator<NSAffineTransform> {
  initWithTransform(transform: NSAffineTransform): InitializedType;
  init(): InitializedType;
}
interface NSAffineTransform extends NSObject, INSCopying, INSSecureCoding {
  translateXBy_yBy(deltaX: CGFloat, deltaY: CGFloat): void;
  rotateByDegrees(angle: CGFloat): void;
  rotateByRadians(angle: CGFloat): void;
  scaleBy(scale: CGFloat): void;
  scaleXBy_yBy(scaleX: CGFloat, scaleY: CGFloat): void;
  invert(): void;
  appendTransform(transform: NSAffineTransform): void;
  prependTransform(transform: NSAffineTransform): void;
  transformPoint(aPoint: NSPoint): NSPoint;
  transformSize(aSize: NSSize): NSSize;
  transformBezierPath(path: NSBezierPath): NSBezierPath;
  set(): void;
  concat(): void;
  translateByOffset(offset: NSPoint): void;
  transactionWithBlock(block: BCVoidBlock): void;
  rotateWithDegrees_aroundPoint(degrees: CGFloat, point: NSPoint): void;
  invertedTransform(): NSAffineTransform;
  CGAffineTransform(): CGAffineTransform;

  transformStruct(): NSAffineTransformStruct;
  setTransformStruct(transformStruct: NSAffineTransformStruct): void;
  determinant(): CGFloat;
  includesFlip(): boolean;
}
declare const NSAffineTransform: {
  alloc(): NSAffineTransformAllocator;  transform(): NSAffineTransform;
  transformByTranslatingXBy_yBy(x: CGFloat, y: CGFloat): NSAffineTransform;
  transformByScaling(scale: CGFloat): NSAffineTransform;
  transformWithOffset(offset: NSPoint): NSAffineTransform;
  rotationTransformWithDegrees_aroundPoint(degrees: CGFloat, point: NSPoint): NSAffineTransform;
  transformFromStruct_aroundPoint(transformStruct: CHTransformStruct, p: NSPoint): NSAffineTransform;
  transformFromStruct_aroundPoint_inPlace(transformStruct: CHTransformStruct, p: NSPoint, transformInPlace: boolean): NSAffineTransform;
  transformWithCGAffineTransform_ms(t: CGAffineTransform): NSAffineTransform;

}

declare type NSAffineTransformStruct = {
  m11: CGFloat
  m12: CGFloat
  m21: CGFloat
  m22: CGFloat
  tX: CGFloat
  tY: CGFloat
}

interface NSAppleEventDescriptorAllocator<InitializedType = NSAppleEventDescriptor> extends NSObjectAllocator<NSAppleEventDescriptor> {
  initWithAEDescNoCopy(aeDesc: AEDesc): InitializedType;
  initWithDescriptorType_bytes_length(descriptorType: DescType, bytes: void | null, byteCount: NSUInteger): InitializedType;
  initWithDescriptorType_data(descriptorType: DescType, data: NSData | null): InitializedType;
  initWithEventClass_eventID_targetDescriptor_returnID_transactionID(eventClass: AEEventClass, eventID: AEEventID, targetDescriptor: NSAppleEventDescriptor | null, returnID: AEReturnID, transactionID: AETransactionID): InitializedType;
  initListDescriptor(): InitializedType;
  initRecordDescriptor(): InitializedType;
}
interface NSAppleEventDescriptor extends NSObject, INSCopying, INSSecureCoding {
  setParamDescriptor_forKeyword(descriptor: NSAppleEventDescriptor, keyword: AEKeyword): void;
  paramDescriptorForKeyword(keyword: AEKeyword): NSAppleEventDescriptor;
  removeParamDescriptorWithKeyword(keyword: AEKeyword): void;
  setAttributeDescriptor_forKeyword(descriptor: NSAppleEventDescriptor, keyword: AEKeyword): void;
  attributeDescriptorForKeyword(keyword: AEKeyword): NSAppleEventDescriptor;
  sendEventWithOptions_timeout_error(sendOptions: NSAppleEventSendOptions, timeoutInSeconds: NSTimeInterval, error: NSError): NSAppleEventDescriptor;
  insertDescriptor_atIndex(descriptor: NSAppleEventDescriptor, index: NSInteger): void;
  descriptorAtIndex(index: NSInteger): NSAppleEventDescriptor;
  removeDescriptorAtIndex(index: NSInteger): void;
  setDescriptor_forKeyword(descriptor: NSAppleEventDescriptor, keyword: AEKeyword): void;
  descriptorForKeyword(keyword: AEKeyword): NSAppleEventDescriptor;
  removeDescriptorWithKeyword(keyword: AEKeyword): void;
  keywordForDescriptorAtIndex(index: NSInteger): AEKeyword;
  coerceToDescriptorType(descriptorType: DescType): NSAppleEventDescriptor;

  aeDesc(): AEDesc;
  descriptorType(): DescType;
  data(): NSData;
  booleanValue(): Boolean;
  enumCodeValue(): OSType;
  int32Value(): SInt32;
  doubleValue(): number;
  typeCodeValue(): OSType;
  stringValue(): NSString;
  dateValue(): NSDate;
  fileURLValue(): NSURL;
  eventClass(): AEEventClass;
  eventID(): AEEventID;
  returnID(): AEReturnID;
  transactionID(): AETransactionID;
  isRecordDescriptor(): boolean;
  numberOfItems(): NSInteger;
}
declare const NSAppleEventDescriptor: {
  alloc(): NSAppleEventDescriptorAllocator;  nullDescriptor(): NSAppleEventDescriptor;
  descriptorWithDescriptorType_bytes_length(descriptorType: DescType, bytes: void | null, byteCount: NSUInteger): NSAppleEventDescriptor;
  descriptorWithDescriptorType_data(descriptorType: DescType, data: NSData | null): NSAppleEventDescriptor;
  descriptorWithBoolean(boolean: Boolean): NSAppleEventDescriptor;
  descriptorWithEnumCode(enumerator: OSType): NSAppleEventDescriptor;
  descriptorWithInt32(signedInt: SInt32): NSAppleEventDescriptor;
  descriptorWithDouble(doubleValue: number): NSAppleEventDescriptor;
  descriptorWithTypeCode(typeCode: OSType): NSAppleEventDescriptor;
  descriptorWithString(string: NSString | string): NSAppleEventDescriptor;
  descriptorWithDate(date: NSDate): NSAppleEventDescriptor;
  descriptorWithFileURL(fileURL: NSURL): NSAppleEventDescriptor;
  appleEventWithEventClass_eventID_targetDescriptor_returnID_transactionID(eventClass: AEEventClass, eventID: AEEventID, targetDescriptor: NSAppleEventDescriptor | null, returnID: AEReturnID, transactionID: AETransactionID): NSAppleEventDescriptor;
  listDescriptor(): NSAppleEventDescriptor;
  recordDescriptor(): NSAppleEventDescriptor;
  currentProcessDescriptor(): NSAppleEventDescriptor;
  descriptorWithProcessIdentifier(processIdentifier: pid_t): NSAppleEventDescriptor;
  descriptorWithBundleIdentifier(bundleIdentifier: NSString | string): NSAppleEventDescriptor;
  descriptorWithApplicationURL(applicationURL: NSURL): NSAppleEventDescriptor;

}

declare enum NSAppleEventSendOptions {
  NSAppleEventSendNoReply = 0x00000001,
  NSAppleEventSendQueueReply = 0x00000002,
  NSAppleEventSendWaitForReply = 0x00000003,
  NSAppleEventSendNeverInteract = 0x00000010,
  NSAppleEventSendCanInteract = 0x00000020,
  NSAppleEventSendAlwaysInteract = 0x00000030,
  NSAppleEventSendCanSwitchLayer = 0x00000040,
  NSAppleEventSendDontRecord = 0x00001000,
  NSAppleEventSendDontExecute = 0x00002000,
  NSAppleEventSendDontAnnotate = 0x00010000,
  NSAppleEventSendDefaultOptions,
}

interface NSAppleEventManagerAllocator<InitializedType = NSAppleEventManager> extends NSObjectAllocator<NSAppleEventManager> {}
interface NSAppleEventManager extends NSObject {
  setEventHandler_andSelector_forEventClass_andEventID(handler: any, handleEventSelector: string, eventClass: AEEventClass, eventID: AEEventID): void;
  removeEventHandlerForEventClass_andEventID(eventClass: AEEventClass, eventID: AEEventID): void;
  dispatchRawAppleEvent_withRawReply_handlerRefCon(theAppleEvent: AppleEvent, theReply: AppleEvent, handlerRefCon: SRefCon): OSErr;
  suspendCurrentAppleEvent(): NSAppleEventManagerSuspensionID;
  appleEventForSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): NSAppleEventDescriptor;
  replyAppleEventForSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): NSAppleEventDescriptor;
  setCurrentAppleEventAndReplyEventWithSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): void;
  resumeWithSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): void;

  currentAppleEvent(): NSAppleEventDescriptor;
  currentReplyAppleEvent(): NSAppleEventDescriptor;
}
declare const NSAppleEventManager: {
  alloc(): NSAppleEventManagerAllocator;  sharedAppleEventManager(): NSAppleEventManager;

}

declare type NSAppleEventManagerSuspensionID = any

interface NSAppleScriptAllocator<InitializedType = NSAppleScript> extends NSObjectAllocator<NSAppleScript> {
  initWithContentsOfURL_error(url: NSURL, errorInfo: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithSource(source: NSString | string): InitializedType;
}
interface NSAppleScript extends NSObject, INSCopying {
  compileAndReturnError(errorInfo: NSDictionary<any, any> | {[key: string]: any}): boolean;
  executeAndReturnError(errorInfo: NSDictionary<any, any> | {[key: string]: any}): NSAppleEventDescriptor;
  executeAppleEvent_error(event: NSAppleEventDescriptor, errorInfo: NSDictionary<any, any> | {[key: string]: any}): NSAppleEventDescriptor;

  source(): NSString;
  compiled(): boolean;
  richTextSource(): NSAttributedString;
}
declare const NSAppleScript: {
  alloc(): NSAppleScriptAllocator;
}

interface NSArchiverAllocator<InitializedType = NSArchiver> extends NSCoderAllocator<NSArchiver> {
  initForWritingWithMutableData(mdata: NSMutableData): InitializedType;
}
interface NSArchiver extends NSCoder {
  encodeRootObject(rootObject: any): void;
  encodeConditionalObject(object: any | null): void;
  encodeClassName_intoClassName(trueName: NSString | string, inArchiveName: NSString | string): void;
  classNameEncodedForTrueClassName(trueName: NSString | string): NSString;
  replaceObject_withObject(object: any, newObject: any): void;

  archiverData(): NSMutableData;
}
declare const NSArchiver: {
  alloc(): NSArchiverAllocator;  archivedDataWithRootObject(rootObject: any): NSData;
  archiveRootObject_toFile(rootObject: any, path: NSString | string): boolean;

}

interface NSUnarchiverAllocator<InitializedType = NSUnarchiver> extends NSCoderAllocator<NSUnarchiver> {
  initForReadingWithData(data: NSData): InitializedType;
}
interface NSUnarchiver extends NSCoder {
  decodeClassName_asClassName(inArchiveName: NSString | string, trueName: NSString | string): void;
  classNameDecodedForArchiveClassName(inArchiveName: NSString | string): NSString;
  replaceObject_withObject(object: any, newObject: any): void;

  atEnd(): boolean;
  systemVersion(): number;
}
declare const NSUnarchiver: {
  alloc(): NSUnarchiverAllocator;  unarchiveObjectWithData(data: NSData): any;
  unarchiveObjectWithFile(path: NSString | string): any;

}

interface NSObjectAllocator<InitializedType = NSObject> {
  initWithUnarchiver_migratingFrom_toVersion(unarchiver: MSBaseUnarchiver, fromVersion: NSInteger, toVersion: NSInteger): InitializedType;
}
interface NSObject {

  description(): NSString;
  inverseForRelationshipKey(relationshipKey: NSString | string): NSString;
  attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo(error: NSError, recoveryOptionIndex: NSUInteger, delegate: any | null, didRecoverSelector: string | null, contextInfo: void | null): void;
  attemptRecoveryFromError_optionIndex(error: NSError, recoveryOptionIndex: NSUInteger): boolean;
  fileManager_shouldProceedAfterError(fm: NSFileManager, errorInfo: NSDictionary<any, any> | {[key: string]: any}): boolean;
  fileManager_willProcessPath(fm: NSFileManager, path: NSString | string): void;
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  validateValue_forKey_error(ioValue: any, inKey: NSString | string, outError: NSError): boolean;
  mutableArrayValueForKey(key: NSString | string): NSMutableArray<any>;
  mutableOrderedSetValueForKey(key: NSString | string): NSMutableOrderedSet<any>;
  mutableSetValueForKey(key: NSString | string): NSMutableSet<any>;
  valueForKeyPath(keyPath: NSString | string): any;
  setValue_forKeyPath(value: any | null, keyPath: NSString | string): void;
  validateValue_forKeyPath_error(ioValue: any, inKeyPath: NSString | string, outError: NSError): boolean;
  mutableArrayValueForKeyPath(keyPath: NSString | string): NSMutableArray<any>;
  mutableOrderedSetValueForKeyPath(keyPath: NSString | string): NSMutableOrderedSet<any>;
  mutableSetValueForKeyPath(keyPath: NSString | string): NSMutableSet<any>;
  valueForUndefinedKey(key: NSString | string): any;
  setValue_forUndefinedKey(value: any | null, key: NSString | string): void;
  setNilValueForKey(key: NSString | string): void;
  dictionaryWithValuesForKeys(keys: NSArray<any> | any[]): NSDictionary<any, any>;
  setValuesForKeysWithDictionary(keyedValues: NSDictionary<any, any> | {[key: string]: any}): void;
  storedValueForKey(key: NSString | string): any;
  takeStoredValue_forKey(value: any | null, key: NSString | string): void;
  takeValue_forKey(value: any | null, key: NSString | string): void;
  takeValue_forKeyPath(value: any | null, keyPath: NSString | string): void;
  handleQueryWithUnboundKey(key: NSString | string): any;
  handleTakeValue_forUnboundKey(value: any | null, key: NSString | string): void;
  unableToSetNilForKey(key: NSString | string): void;
  valuesForKeys(keys: NSArray<any> | any[]): NSDictionary<any, any>;
  takeValuesFromDictionary(properties: NSDictionary<any, any> | {[key: string]: any}): void;
  observeValueForKeyPath_ofObject_change_context(keyPath: NSString | string | null, object: any | null, change: NSDictionary<any, any> | {[key: string]: any} | null, context: void | null): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  willChangeValueForKey(key: NSString | string): void;
  didChangeValueForKey(key: NSString | string): void;
  willChange_valuesAtIndexes_forKey(changeKind: NSKeyValueChange, indexes: NSIndexSet, key: NSString | string): void;
  didChange_valuesAtIndexes_forKey(changeKind: NSKeyValueChange, indexes: NSIndexSet, key: NSString | string): void;
  willChangeValueForKey_withSetMutation_usingObjects(key: NSString | string, mutationKind: NSKeyValueSetMutationKind, objects: NSSet<any>): void;
  didChangeValueForKey_withSetMutation_usingObjects(key: NSString | string, mutationKind: NSKeyValueSetMutationKind, objects: NSSet<any>): void;
  replacementObjectForKeyedArchiver(archiver: NSKeyedArchiver): any;
  replacementObjectForCoder(aCoder: NSCoder): any;
  awakeAfterUsingCoder_NS_REPLACES_RECEIVER(aDecoder: NSCoder): any;
  scriptingValueForSpecifier(objectSpecifier: NSScriptObjectSpecifier): any;
  copyScriptingValue_forKey_withProperties(value: any, key: NSString | string, properties: NSDictionary<any, any> | {[key: string]: any}): any;
  newScriptingObjectOfClass_forValueForKey_withContentsValue_properties(objectClass: any, key: NSString | string, contentsValue: any | null, properties: NSDictionary<any, any> | {[key: string]: any}): any;
  replacementObjectForPortCoder(coder: NSPortCoder): any;
  performSelector_withObject_afterDelay_inModes(aSelector: string, anArgument: any | null, delay: NSTimeInterval, modes: NSArray<any> | any[]): void;
  performSelector_withObject_afterDelay(aSelector: string, anArgument: any | null, delay: NSTimeInterval): void;
  valueAtIndex_inPropertyWithKey(index: NSUInteger, key: NSString | string): any;
  valueWithName_inPropertyWithKey(name: NSString | string, key: NSString | string): any;
  valueWithUniqueID_inPropertyWithKey(uniqueID: any, key: NSString | string): any;
  insertValue_atIndex_inPropertyWithKey(value: any, index: NSUInteger, key: NSString | string): void;
  removeValueAtIndex_fromPropertyWithKey(index: NSUInteger, key: NSString | string): void;
  replaceValueAtIndex_inPropertyWithKey_withValue(index: NSUInteger, key: NSString | string, value: any): void;
  insertValue_inPropertyWithKey(value: any, key: NSString | string): void;
  coerceValue_forKey(value: any | null, key: NSString | string): any;
  indicesOfObjectsByEvaluatingObjectSpecifier(specifier: NSScriptObjectSpecifier): NSArray<any>;
  isEqualTo(object: any | null): boolean;
  isLessThanOrEqualTo(object: any | null): boolean;
  isLessThan(object: any | null): boolean;
  isGreaterThanOrEqualTo(object: any | null): boolean;
  isGreaterThan(object: any | null): boolean;
  isNotEqualTo(object: any | null): boolean;
  doesContain(object: any): boolean;
  isLike(object: NSString | string): boolean;
  isCaseInsensitiveLike(object: NSString | string): boolean;
  scriptingIsEqualTo(object: any): boolean;
  scriptingIsLessThanOrEqualTo(object: any): boolean;
  scriptingIsLessThan(object: any): boolean;
  scriptingIsGreaterThanOrEqualTo(object: any): boolean;
  scriptingIsGreaterThan(object: any): boolean;
  scriptingBeginsWith(object: any): boolean;
  scriptingEndsWith(object: any): boolean;
  scriptingContains(object: any): boolean;
  performSelectorOnMainThread_withObject_waitUntilDone_modes(aSelector: string, arg: any | null, wait: boolean, array: NSArray<any> | any[] | null): void;
  performSelectorOnMainThread_withObject_waitUntilDone(aSelector: string, arg: any | null, wait: boolean): void;
  performSelector_onThread_withObject_waitUntilDone_modes(aSelector: string, thr: NSThread, arg: any | null, wait: boolean, array: NSArray<any> | any[] | null): void;
  performSelector_onThread_withObject_waitUntilDone(aSelector: string, thr: NSThread, arg: any | null, wait: boolean): void;
  performSelectorInBackground_withObject(aSelector: string, arg: any | null): void;
  URL_resourceDataDidBecomeAvailable(sender: NSURL, newBytes: NSData): void;
  URLResourceDidFinishLoading(sender: NSURL): void;
  URLResourceDidCancelLoading(sender: NSURL): void;
  URL_resourceDidFailLoadingWithReason(sender: NSURL, reason: NSString | string): void;
  accessibilityIsIgnored(): boolean;
  accessibilityHitTest(point: NSPoint): any;
  accessibilityIndexOfChild(child: any): NSUInteger;
  accessibilityArrayAttributeCount(attribute: NSAccessibilityAttributeName): NSUInteger;
  accessibilityArrayAttributeValues_index_maxCount(attribute: NSAccessibilityAttributeName, index: NSUInteger, maxCount: NSUInteger): NSArray<any>;
  application_delegateHandlesKey(sender: NSApplication, key: NSString | string): boolean;
  changeColor(sender: any | null): void;
  controlTextDidBeginEditing(obj: NSNotification): void;
  controlTextDidEndEditing(obj: NSNotification): void;
  controlTextDidChange(obj: NSNotification): void;
  namesOfPromisedFilesDroppedAtDestination(dropDestination: NSURL): NSArray<any>;
  draggingSourceOperationMaskForLocal(flag: boolean): NSDragOperation;
  draggedImage_beganAt(image: NSImage, screenPoint: NSPoint): void;
  draggedImage_endedAt_operation(image: NSImage, screenPoint: NSPoint, operation: NSDragOperation): void;
  draggedImage_movedTo(image: NSImage, screenPoint: NSPoint): void;
  ignoreModifierKeysWhileDragging(): boolean;
  draggedImage_endedAt_deposited_DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER(image: NSImage, screenPoint: NSPoint, flag: boolean): void;
  fontManager_willIncludeFont(sender: any, fontName: NSString | string): boolean;
  changeFont(sender: any | null): void;
  validModesForFontPanel(fontPanel: NSFontPanel): NSFontPanelModeMask;
  valueClassForBinding(binding: NSBindingName): any;
  bind_toObject_withKeyPath_options(binding: NSBindingName, observable: any, keyPath: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null): void;
  unbind(binding: NSBindingName): void;
  infoForBinding(binding: NSBindingName): NSDictionary<any, any>;
  optionDescriptionsForBinding(binding: NSBindingName): NSArray<any>;
  objectDidBeginEditing(editor: any): void;
  objectDidEndEditing(editor: any): void;
  discardEditing(): void;
  commitEditing(): boolean;
  commitEditingWithDelegate_didCommitSelector_contextInfo(delegate: any | null, didCommitSelector: string | null, contextInfo: void | null): void;
  commitEditingAndReturnError(error: NSError): boolean;
  validateMenuItem(menuItem: NSMenuItem): boolean;
  awakeFromNib(): void;
  prepareForInterfaceBuilder(): void;
  pasteboard_provideDataForType(sender: NSPasteboard, type: NSPasteboardType): void;
  pasteboardChangedOwner(sender: NSPasteboard): void;
  panel_isValidFilename(sender: any, filename: NSString | string): boolean;
  panel_directoryDidChange(sender: any, path: NSString | string): void;
  panel_compareFilename_with_caseSensitive(sender: any, name1: NSString | string, name2: NSString | string, caseSensitive: boolean): NSComparisonResult;
  panel_shouldShowFilename(sender: any, filename: NSString | string): boolean;
  tableView_writeRows_toPasteboard(tableView: NSTableView, rows: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  textStorageWillProcessEditing(notification: NSNotification): void;
  textStorageDidProcessEditing(notification: NSNotification): void;
  validateToolbarItem(item: NSToolbarItem): boolean;
  layer_shouldInheritContentsScale_fromWindow(layer: CALayer, newScale: CGFloat, window: NSWindow): boolean;
  view_stringForToolTip_point_userData(view: NSView, tag: NSToolTipTag, point: NSPoint, data: void | null): NSString;
  changeKey_inBlock(aKey: NSString | string, block: BCVoidBlock): void;
  executeAsBlock(): void;
  runningOSVersion_bc_minorVersion(majorVersion: NSInteger, minorVersion: NSInteger): boolean;
  runningSierra_bc(): boolean;
  mutableCopyDeep(): any;
  outlineView_shouldShowDisclosureTriangleForItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_handleKeyEvent(outlineView: NSOutlineView, anEvent: NSEvent): boolean;
  outlineView_deleteItem(outlineView: NSOutlineView, anItem: any): void;
  tableView_handleKeyEvent(tableView: NSTableView, anEvent: NSEvent): boolean;
  tableViewPoofEffect(tv: NSTableView): boolean;
  coderSafeVersion_bc(): NSObject;
  addObserver_forKeyPaths_options_context(anObserver: NSObject, keyPaths: NSArray<any> | any[], options: NSKeyValueObservingOptions, context: void): void;
  removeObserver_forKeyPaths(anObserver: NSObject, keyPaths: NSArray<any> | any[]): void;
  setCOSJSTargetFunction(jsFunction: MOJavaScriptObject | Function): void;
  coscript_hadError_onLineNumber_atSourceURL(coscript: any, error: NSString | string, lineNumber: NSInteger, url: any): void;
  finalizeForMochaScript(): void;
  objectForIndexedSubscript(idx: NSUInteger): any;
  setObject_forIndexedSubscript(obj: any, idx: NSUInteger): void;
  //   objectForKeyedSubscript(key: NSString | string): any;
  //   setObject_forKeyedSubscript(obj: any, key: NSString | string): void;
  shutdown(): void;
  JSValueForObject(object: any): JSValueRef;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  immutableModelObject(): any;
  copyWithOptions(options: MSModelCopyOptions): any;
  hasDefaultValues(): boolean;
  propertiesAreEqual(object: any): boolean;
  parentObject(): any;
  setParentObject(parentObject: MSModelObjectCommon): void;
  breakConnectionWith(parent: MSModelObjectCommon): void;
  mapTreeWithLeafTransformBlock(block: Block): any;
  safeCastToClass(classToCastTo: any): any;
  drawContentForButton_inRect(button: MSPresetPickerPresetButton, rect: NSRect): void;
  removePresetForButton(menuItem: NSMenuItem): void;
  shouldShowMenuForButton(button: MSPresetPickerPresetButton): boolean;
  removePresetWithTag(tag: NSInteger): void;

  classForArchiver(): any;
  classDescription(): NSClassDescription;
  attributeKeys(): NSArray<any>;
  toOneRelationshipKeys(): NSArray<any>;
  toManyRelationshipKeys(): NSArray<any>;
  observationInfo(): void;
  setObservationInfo(observationInfo: void): void;
  classForKeyedArchiver(): any;
  classForCoder(): any;
  autoContentAccessingProxy(): any;
  scriptingProperties(): NSDictionary<any, any>;
  setScriptingProperties(scriptingProperties: NSDictionary<any, any> | {[key: string]: any}): void;
  classForPortCoder(): any;
  classCode(): number;
  className(): NSString;
  objectSpecifier(): NSScriptObjectSpecifier;
  accessibilityFocusedUIElement(): any;
  accessibilityNotifiesWhenDestroyed(): boolean;
  exposedBindings(): NSArray<any>;
}
declare const NSObject: {
  alloc(): NSObjectAllocator;  useStoredAccessor(): boolean;
  keyPathsForValuesAffectingValueForKey(key: NSString | string): NSSet<any>;
  automaticallyNotifiesObserversForKey(key: NSString | string): boolean;
  setKeys_triggerChangeNotificationsForDependentKey(keys: NSArray<any> | any[], dependentKey: NSString | string): void;
  classFallbacksForKeyedArchiver(): NSArray<any>;
  classForKeyedUnarchiver(): any;
  version(): NSInteger;
  setVersion(aVersion: NSInteger): void;
  cancelPreviousPerformRequestsWithTarget_selector_object(aTarget: any, aSelector: string, anArgument: any | null): void;
  cancelPreviousPerformRequestsWithTarget(aTarget: any): void;
  exposeBinding(binding: NSBindingName): void;
  setDefaultPlaceholder_forMarker_withBinding(placeholder: any | null, marker: any | null, binding: NSBindingName): void;
  defaultPlaceholderForMarker_withBinding(marker: any | null, binding: NSBindingName): any;
  mo_swizzleAdditions(): void;
  mo_mocha(): MOClassDescription;
  isSelectorExcludedFromMochaScript(selector: string): boolean;
  selectorForMochaPropertyName(propertyName: NSString | string): string;

  accessInstanceVariablesDirectly(): boolean;

}

interface NSArrayAllocator<ObjectType, InitializedType = NSArray<ObjectType>> extends NSObjectAllocator<NSArray<ObjectType>> {
  init(): InitializedType;
  initWithObjects_count(objects: ObjectType[], cnt: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithObjects(firstObj: ObjectType, ...args: any[]): InitializedType;
  initWithArray(array: NSArray<any> | any[]): InitializedType;
  initWithArray_copyItems(array: NSArray<any> | any[], flag: boolean): InitializedType;
  initWithContentsOfURL_error(url: NSURL, error: NSError): InitializedType;
  initWithContentsOfFile(path: NSString | string): InitializedType;
  initWithContentsOfURL(url: NSURL): InitializedType;
}
interface NSArray<ObjectType> extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {

  [key: number]: ObjectType | Function;
  [key: string]: ObjectType | Function;
  objectAtIndex(index: NSUInteger): ObjectType;
  arrayByAddingObject(anObject: ObjectType): NSArray<any>;
  arrayByAddingObjectsFromArray(otherArray: NSArray<any> | any[]): NSArray<any>;
  componentsJoinedByString(separator: NSString | string): NSString;
  containsObject(anObject: ObjectType): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  descriptionWithLocale_indent(locale: any | null, level: NSUInteger): NSString;
  firstObjectCommonWithArray(otherArray: NSArray<any> | any[]): ObjectType;
  indexOfObject(anObject: ObjectType): NSUInteger;
  indexOfObject_inRange(anObject: ObjectType, range: NSRange): NSUInteger;
  indexOfObjectIdenticalTo(anObject: ObjectType): NSUInteger;
  indexOfObjectIdenticalTo_inRange(anObject: ObjectType, range: NSRange): NSUInteger;
  isEqualToArray(otherArray: NSArray<any> | any[]): boolean;
  objectEnumerator(): NSEnumerator<any>;
  reverseObjectEnumerator(): NSEnumerator<any>;
  sortedArrayUsingSelector(comparator: string): NSArray<any>;
  subarrayWithRange(range: NSRange): NSArray<any>;
  writeToURL_error(url: NSURL, error: NSError): boolean;
  makeObjectsPerformSelector(aSelector: string): void;
  makeObjectsPerformSelector_withObject(aSelector: string, argument: any | null): void;
  objectsAtIndexes(indexes: NSIndexSet): NSArray<any>;
  objectAtIndexedSubscript(idx: NSUInteger): ObjectType;
  enumerateObjectsUsingBlock(block: Block): void;
  enumerateObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateObjectsAtIndexes_options_usingBlock(s: NSIndexSet, opts: NSEnumerationOptions, block: Block): void;
  indexOfObjectPassingTest(predicate: Block): NSUInteger;
  indexOfObjectWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexOfObjectAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexesOfObjectsPassingTest(predicate: Block): NSIndexSet;
  indexesOfObjectsWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexesOfObjectsAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  sortedArrayUsingComparator(cmptr: NSComparator): NSArray<any>;
  sortedArrayWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): NSArray<any>;
  indexOfObject_inSortedRange_options_usingComparator(obj: ObjectType, r: NSRange, opts: NSBinarySearchingOptions, cmp: NSComparator): NSUInteger;
  getObjects(objects: ObjectType[]): void;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  addObserver_toObjectsAtIndexes_forKeyPath_options_context(observer: NSObject, indexes: NSIndexSet, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_fromObjectsAtIndexes_forKeyPath_context(observer: NSObject, indexes: NSIndexSet, keyPath: NSString | string, context: void | null): void;
  removeObserver_fromObjectsAtIndexes_forKeyPath(observer: NSObject, indexes: NSIndexSet, keyPath: NSString | string): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  pathsMatchingExtensions(filterTypes: NSArray<any> | any[]): NSArray<any>;
  filteredArrayUsingPredicate(predicate: NSPredicate): NSArray<any>;
  sortedArrayUsingDescriptors(sortDescriptors: NSArray<any> | any[]): NSArray<any>;
  front(): NSArray<any>;
  tail(): NSArray<any>;
  arrayByRemovingLastObject(): NSArray<any>;
  enumerateTailUsingBlock(block: Block): void;
  reversedArray(): NSArray<any>;
  map(block: Block): NSArray<any>;
  flatMap(block: Block): NSArray<any>;
  mapWithIndex(block: Block): NSArray<any>;
  enumerate(block: Block): void;
  enumerateWithIndex(block: Block): void;
  filter(block: Block): NSArray<any>;
  containsObjectPassingTest(predicate: Block): boolean;
  firstObjectPassingTest(predicate: Block): ObjectType;
  indexOfFirstObjectPassingTest(predicate: Block): NSUInteger;
  filterWithIndex(block: Block): NSArray<any>;
  filteredByObjectsOfClass(aClass: any): NSArray<any>;
  containsObjectOfClass(aClass: any): boolean;
  containsOnlyObjectsOfClass(aClass: any): boolean;
  firstObjectOfClass(aClass: any): any;
  sum(block: BCSumBlock): CGFloat;
  arrayByRemovingNull(): NSArray<any>;
  copyDeep(): any;
  sortedArray(): NSArray<any>;
  sortedArrayUsingKey(key: NSString | string): NSArray<any>;
  sortedArrayUsingKey_selector(key: NSString | string, action: string): NSArray<any>;
  shuffledArray(): NSArray<any>;
  arrayByRemovingObject(anObject: any): NSArray<any>;
  arrayByRemovingObjects(objects: NSArray<any> | any[]): NSArray<any>;
  arrayByAddingObjects(firstObj: any, ...args: any[]): NSArray<any>;
  dictionaryByIndexingObjectForKey(aKey: NSString | string): NSDictionary<any, any>;
  isValidIndex(anIndex: NSUInteger): boolean;
  objectAtIndexOrNil(index: NSUInteger): ObjectType;
  subArrayToIndex(anIndex: NSUInteger): NSArray<any>;
  uniqueObjects(): NSArray<any>;
  rotateTwoDimensionalArray(): NSArray<any>;
  indexOfSubArray(array: NSArray<any> | any[]): NSUInteger;
  mapWithMaxConcurrencyCount_usingBlock_completionBlock(maxConcurrentCount: NSInteger, block: Block, completionBlock: BCConcurrentMapCompletionBlock): void;
  mo_objectForIndexedSubscript(idx: NSUInteger): any;
  cloudObjectsOfType_parentObject(type: any, parent: SCKObject | null): NSArray<any>;
  sck_flatMap(transform: Block): NSArray<any>;
  smk_map(mappingBlock: Block): NSArray<any>;
  length(): NSUInteger;

  count(): NSUInteger;
  description(): NSString;
  firstObject(): ObjectType;
  lastObject(): ObjectType;
  sortedArrayHint(): NSData;
}
declare const NSArray: {
  alloc<ObjectType>(): NSArrayAllocator<ObjectType>;  array<ObjectType>(): NSArray<ObjectType>;
  arrayWithObject<ObjectType>(anObject: ObjectType): NSArray<ObjectType>;
  arrayWithObjects_count<ObjectType>(objects: ObjectType[], cnt: NSUInteger): NSArray<ObjectType>;
  arrayWithObjects<ObjectType>(firstObj: ObjectType, ...args: any[]): NSArray<ObjectType>;
  arrayWithArray<ObjectType>(array: NSArray<any> | any[]): NSArray<ObjectType>;
  arrayWithContentsOfURL_error(url: NSURL, error: NSError): NSArray<any>;
  arrayWithContentsOfFile(path: NSString | string): NSArray<any>;
  arrayWithContentsOfURL(url: NSURL): NSArray<any>;
  arrayWithCapacity_fill(count: NSUInteger, block: Block): any;
  arrayByMergingArrays(array: NSArray<any> | any[]): NSArray<any>;

}

interface NSMutableArrayAllocator<ObjectType, InitializedType = NSMutableArray<ObjectType>> extends NSArrayAllocator<ObjectType, NSMutableArray<ObjectType>> {
  initWithCapacity(numItems: NSUInteger): InitializedType;
}
interface NSMutableArray<ObjectType> extends NSArray<ObjectType> {
  addObject(anObject: ObjectType): void;
  insertObject_atIndex(anObject: ObjectType, index: NSUInteger): void;
  removeLastObject(): void;
  removeObjectAtIndex(index: NSUInteger): void;
  replaceObjectAtIndex_withObject(index: NSUInteger, anObject: ObjectType): void;
  addObjectsFromArray(otherArray: NSArray<any> | any[]): void;
  exchangeObjectAtIndex_withObjectAtIndex(idx1: NSUInteger, idx2: NSUInteger): void;
  removeAllObjects(): void;
  removeObject_inRange(anObject: ObjectType, range: NSRange): void;
  removeObject(anObject: ObjectType): void;
  removeObjectIdenticalTo_inRange(anObject: ObjectType, range: NSRange): void;
  removeObjectIdenticalTo(anObject: ObjectType): void;
  removeObjectsFromIndices_numIndices(indices: NSUInteger, cnt: NSUInteger): void;
  removeObjectsInArray(otherArray: NSArray<any> | any[]): void;
  removeObjectsInRange(range: NSRange): void;
  replaceObjectsInRange_withObjectsFromArray_range(range: NSRange, otherArray: NSArray<any> | any[], otherRange: NSRange): void;
  replaceObjectsInRange_withObjectsFromArray(range: NSRange, otherArray: NSArray<any> | any[]): void;
  setArray(otherArray: NSArray<any> | any[]): void;
  sortUsingSelector(comparator: string): void;
  insertObjects_atIndexes(objects: NSArray<any> | any[], indexes: NSIndexSet): void;
  removeObjectsAtIndexes(indexes: NSIndexSet): void;
  replaceObjectsAtIndexes_withObjects(indexes: NSIndexSet, objects: NSArray<any> | any[]): void;
  setObject_atIndexedSubscript(obj: ObjectType, idx: NSUInteger): void;
  sortUsingComparator(cmptr: NSComparator): void;
  sortWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): void;
  filterUsingPredicate(predicate: NSPredicate): void;
  sortUsingDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  removeObjectsPassingTest(predicate: Block): void;
  addObjectIfNotNil(obj: any): void;
  removeFirstObject(): void;
  replaceObject_withObject(obj1: any, obj2: any): void;
  mo_setObject_forIndexedSubscript(obj: any, idx: NSUInteger): void;
  indexOfAttributeWithName(name: NSString | string): NSUInteger;
  addAttributeForID(identifier: NSString | string): void;
  addAttributeWithName_stringValue(name: NSString | string, value: NSString | string): void;
  addAttributeWithName_pixelValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_numberValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageFractionalValue(name: NSString | string, value: CGFloat): void;
  removeAttributeWithName(name: NSString | string): void;
}
declare const NSMutableArray: {
  alloc<ObjectType>(): NSMutableArrayAllocator<ObjectType>;  arrayWithCapacity<ObjectType>(numItems: NSUInteger): NSMutableArray<ObjectType>;
  arrayWithContentsOfFile(path: NSString | string): NSMutableArray<any>;
  arrayWithContentsOfURL(url: NSURL): NSMutableArray<any>;
  arrayWithCapacity_fill(count: NSUInteger, block: Block): any;

}

declare enum NSBinarySearchingOptions {
  NSBinarySearchingFirstEqual,
  NSBinarySearchingLastEqual,
  NSBinarySearchingInsertionIndex,
}

interface NSAttributedStringAllocator<InitializedType = NSAttributedString> extends NSObjectAllocator<NSAttributedString> {
  initWithString(str: NSString | string): InitializedType;
  initWithString_attributes(str: NSString | string, attrs: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
  initWithAttributedString(attrStr: NSAttributedString): InitializedType;
  initWithURL_options_documentAttributes_error(url: NSURL, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): InitializedType;
  initWithData_options_documentAttributes_error(data: NSData, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): InitializedType;
  initWithRTF_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithRTFD_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithHTML_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithHTML_baseURL_documentAttributes(data: NSData, base: NSURL, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithDocFormat_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithHTML_options_documentAttributes(data: NSData, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithRTFDFileWrapper_documentAttributes(wrapper: NSFileWrapper, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithURL_documentAttributes(url: NSURL, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithPath_documentAttributes(path: NSString | string, dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface NSAttributedString extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding {
  attributesAtIndex_effectiveRange(location: NSUInteger, range: NSRangePointer | null): NSDictionary<any, any>;
  attribute_atIndex_effectiveRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null): any;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  attributesAtIndex_longestEffectiveRange_inRange(location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): NSDictionary<any, any>;
  attribute_atIndex_longestEffectiveRange_inRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): any;
  isEqualToAttributedString(other: NSAttributedString): boolean;
  enumerateAttributesInRange_options_usingBlock(enumerationRange: NSRange, opts: NSAttributedStringEnumerationOptions, block: Block): void;
  enumerateAttribute_inRange_options_usingBlock(attrName: NSAttributedStringKey, enumerationRange: NSRange, opts: NSAttributedStringEnumerationOptions, block: Block): void;
  dataFromRange_documentAttributes_error(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSData;
  fileWrapperFromRange_documentAttributes_error(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSFileWrapper;
  RTFFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  RTFDFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  RTFDFileWrapperFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSFileWrapper;
  docFormatFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  fontAttributesInRange(range: NSRange): NSDictionary<any, any>;
  rulerAttributesInRange(range: NSRange): NSDictionary<any, any>;
  containsAttachmentsInRange(range: NSRange): boolean;
  lineBreakBeforeIndex_withinRange(location: NSUInteger, aRange: NSRange): NSUInteger;
  lineBreakByHyphenatingBeforeIndex_withinRange(location: NSUInteger, aRange: NSRange): NSUInteger;
  doubleClickAtIndex(location: NSUInteger): NSRange;
  nextWordFromIndex_forward(location: NSUInteger, isForward: boolean): NSUInteger;
  rangeOfTextBlock_atIndex(block: NSTextBlock, location: NSUInteger): NSRange;
  rangeOfTextTable_atIndex(table: NSTextTable, location: NSUInteger): NSRange;
  rangeOfTextList_atIndex(list: NSTextList, location: NSUInteger): NSRange;
  itemNumberInTextList_atIndex(list: NSTextList, location: NSUInteger): NSInteger;
  URLAtIndex_effectiveRange(location: NSUInteger, effectiveRange: NSRangePointer): NSURL;
  size(): NSSize;
  drawAtPoint(point: NSPoint): void;
  drawInRect(rect: NSRect): void;
  drawWithRect_options_context(rect: NSRect, options: NSStringDrawingOptions, context: NSStringDrawingContext | null): void;
  boundingRectWithSize_options_context(size: NSSize, options: NSStringDrawingOptions, context: NSStringDrawingContext | null): NSRect;
  drawWithRect_options(rect: NSRect, options: NSStringDrawingOptions): void;
  boundingRectWithSize_options(size: NSSize, options: NSStringDrawingOptions): NSRect;
  heightWithFont_maxWidth(myFont: NSFont, myWidth: CGFloat): CGFloat;
  attributedStringWithHighlightColor(highlightColor: NSColor): NSAttributedString;
  attributeOrNil_atIndex(attrName: NSString | string, location: NSUInteger): any;
  attributesMatch(other: NSAttributedString): boolean;
  attributesMatch_comparison(other: NSAttributedString, compareBlock: CHStringAttributesCompareBlock): boolean;
  standardAttributedStringWithDocumentColorSpace(colorSpace: NSColorSpace): NSAttributedString;

  string(): NSString;
  length(): NSUInteger;
  containsAttachments(): boolean;
}
declare const NSAttributedString: {
  alloc(): NSAttributedStringAllocator;  textFileTypes(): NSArray<any>;
  textPasteboardTypes(): NSArray<any>;
  textUnfilteredFileTypes(): NSArray<any>;
  textUnfilteredPasteboardTypes(): NSArray<any>;
  attributedStringWithAttachment(attachment: NSTextAttachment): NSAttributedString;
  attributedStringWithString_attributes(aString: NSString | string, attributes: NSDictionary<any, any> | {[key: string]: any}): NSAttributedString;
  attributedStringWithString_font(aString: NSString | string, font: NSFont): NSAttributedString;

  textTypes(): NSArray<any>;
  textUnfilteredTypes(): NSArray<any>;

}

interface NSMutableAttributedStringAllocator<InitializedType = NSMutableAttributedString> extends NSAttributedStringAllocator<NSMutableAttributedString> {}
interface NSMutableAttributedString extends NSAttributedString {
  replaceCharactersInRange_withString(range: NSRange, str: NSString | string): void;
  setAttributes_range(attrs: NSDictionary<any, any> | {[key: string]: any} | null, range: NSRange): void;
  addAttribute_value_range(name: NSAttributedStringKey, value: any, range: NSRange): void;
  addAttributes_range(attrs: NSDictionary<any, any> | {[key: string]: any}, range: NSRange): void;
  removeAttribute_range(name: NSAttributedStringKey, range: NSRange): void;
  replaceCharactersInRange_withAttributedString(range: NSRange, attrString: NSAttributedString): void;
  insertAttributedString_atIndex(attrString: NSAttributedString, loc: NSUInteger): void;
  appendAttributedString(attrString: NSAttributedString): void;
  deleteCharactersInRange(range: NSRange): void;
  setAttributedString(attrString: NSAttributedString): void;
  beginEditing(): void;
  endEditing(): void;
  fixAttributesInRange(range: NSRange): void;
  fixFontAttributeInRange(range: NSRange): void;
  fixParagraphStyleAttributeInRange(range: NSRange): void;
  fixAttachmentAttributeInRange(range: NSRange): void;
  readFromURL_options_documentAttributes_error(url: NSURL, opts: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  readFromData_options_documentAttributes_error(data: NSData, opts: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  superscriptRange(range: NSRange): void;
  subscriptRange(range: NSRange): void;
  unscriptRange(range: NSRange): void;
  applyFontTraits_range(traitMask: NSFontTraitMask, range: NSRange): void;
  setAlignment_range(alignment: NSTextAlignment, range: NSRange): void;
  setBaseWritingDirection_range(writingDirection: NSWritingDirection, range: NSRange): void;
  readFromURL_options_documentAttributes(url: NSURL, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}): boolean;
  readFromData_options_documentAttributes(data: NSData, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}): boolean;
  updateAttachmentsFromPath(path: NSString | string): void;
  appendString_attributes(string: NSString | string, attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  currentListStyle(): NSTextList;
  updateListStyle(newList: NSTextList): void;
  updateListFrom_toList(oldList: NSTextList, newList: NSTextList): void;
  removeUnsupportedAttributes(): void;

  mutableString(): NSMutableString;
}
declare const NSMutableAttributedString: {
  alloc(): NSMutableAttributedStringAllocator;
}

declare type NSAttributedStringKey = NSString

declare enum NSAttributedStringEnumerationOptions {
  NSAttributedStringEnumerationReverse,
  NSAttributedStringEnumerationLongestEffectiveRangeNotRequired,
}

interface NSAutoreleasePoolAllocator<InitializedType = NSAutoreleasePool> extends NSObjectAllocator<NSAutoreleasePool> {}
interface NSAutoreleasePool extends NSObject {
  addObject(anObject: any): void;
  drain(): void;
}
declare const NSAutoreleasePool: {
  alloc(): NSAutoreleasePoolAllocator;  showPools(): void;

}

interface NSBackgroundActivitySchedulerAllocator<InitializedType = NSBackgroundActivityScheduler> extends NSObjectAllocator<NSBackgroundActivityScheduler> {
  initWithIdentifier(identifier: NSString | string): InitializedType;
}
interface NSBackgroundActivityScheduler extends NSObject {
  scheduleWithBlock(block: Block): void;
  invalidate(): void;

  identifier(): NSString;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  repeats(): boolean;
  setRepeats(repeats: boolean): void;
  interval(): NSTimeInterval;
  setInterval(interval: NSTimeInterval): void;
  tolerance(): NSTimeInterval;
  setTolerance(tolerance: NSTimeInterval): void;
  shouldDefer(): boolean;
}
declare const NSBackgroundActivityScheduler: {
  alloc(): NSBackgroundActivitySchedulerAllocator;
}

declare enum NSBackgroundActivityResult {
  NSBackgroundActivityResultFinished = 1,
  NSBackgroundActivityResultDeferred = 2,
}

interface NSBundleAllocator<InitializedType = NSBundle> extends NSObjectAllocator<NSBundle> {
  initWithPath(path: NSString | string): InitializedType;
  initWithURL(url: NSURL): InitializedType;
}
interface NSBundle extends NSObject {
  load(): boolean;
  unload(): boolean;
  preflightAndReturnError(error: NSError): boolean;
  loadAndReturnError(error: NSError): boolean;
  URLForAuxiliaryExecutable(executableName: NSString | string): NSURL;
  pathForAuxiliaryExecutable(executableName: NSString | string): NSString;
  URLForResource_withExtension(name: NSString | string | null, ext: NSString | string | null): NSURL;
  URLForResource_withExtension_subdirectory(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null): NSURL;
  URLForResource_withExtension_subdirectory_localization(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSURL;
  URLsForResourcesWithExtension_subdirectory(ext: NSString | string | null, subpath: NSString | string | null): NSArray<any>;
  URLsForResourcesWithExtension_subdirectory_localization(ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSArray<any>;
  pathForResource_ofType_inDirectory(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null): NSString;
  pathsForResourcesOfType_inDirectory(ext: NSString | string | null, subpath: NSString | string | null): NSArray<any>;
  pathForResource_ofType(name: NSString | string | null, ext: NSString | string | null): NSString;
  pathForResource_ofType_inDirectory_forLocalization(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSString;
  pathsForResourcesOfType_inDirectory_forLocalization(ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSArray<any>;
  objectForInfoDictionaryKey(key: NSString | string): any;
  classNamed(className: NSString | string): any;
  setPreservationPriority_forTags(priority: number, tags: NSSet<any>): void;
  preservationPriorityForTag(tag: NSString | string): number;
  contextHelpForKey(key: NSHelpManagerContextHelpKey): NSAttributedString;
  imageForResource(name: NSImageName): NSImage;
  pathForImageResource(name: NSImageName): NSString;
  URLForImageResource(name: NSImageName): NSURL;
  loadNibNamed_owner_topLevelObjects(nibName: NSNibName, owner: any | null, topLevelObjects: NSArray<any> | any[]): boolean;
  loadNibFile_externalNameTable_withZone(fileName: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, zone: NSZone): boolean;
  pathForSoundResource(name: NSSoundName): NSString;
  bundleName(): NSString;
  bundleVersion(): NSString;
  bundleBuild(): NSString;
  bundleFullVersion(): NSString;
  bundleCopyright(): NSString;

  loaded(): boolean;
  bundleURL(): NSURL;
  resourceURL(): NSURL;
  executableURL(): NSURL;
  privateFrameworksURL(): NSURL;
  sharedFrameworksURL(): NSURL;
  sharedSupportURL(): NSURL;
  builtInPlugInsURL(): NSURL;
  appStoreReceiptURL(): NSURL;
  bundlePath(): NSString;
  resourcePath(): NSString;
  executablePath(): NSString;
  privateFrameworksPath(): NSString;
  sharedFrameworksPath(): NSString;
  sharedSupportPath(): NSString;
  builtInPlugInsPath(): NSString;
  bundleIdentifier(): NSString;
  infoDictionary(): NSDictionary<any, any>;
  localizedInfoDictionary(): NSDictionary<any, any>;
  principalClass(): any;
  preferredLocalizations(): NSArray<any>;
  localizations(): NSArray<any>;
  developmentLocalization(): NSString;
  executableArchitectures(): NSArray<any>;
}
declare const NSBundle: {
  alloc(): NSBundleAllocator;  bundleWithPath(path: NSString | string): NSBundle;
  bundleWithURL(url: NSURL): NSBundle;
  bundleForClass(aClass: any): NSBundle;
  bundleWithIdentifier(identifier: NSString | string): NSBundle;
  URLForResource_withExtension_subdirectory_inBundleWithURL(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null, bundleURL: NSURL): NSURL;
  URLsForResourcesWithExtension_subdirectory_inBundleWithURL(ext: NSString | string | null, subpath: NSString | string | null, bundleURL: NSURL): NSArray<any>;
  preferredLocalizationsFromArray(localizationsArray: NSArray<any> | any[]): NSArray<any>;
  preferredLocalizationsFromArray_forPreferences(localizationsArray: NSArray<any> | any[], preferencesArray: NSArray<any> | any[] | null): NSArray<any>;
  loadNibNamed_owner(nibName: NSString | string, owner: any): boolean;

  mainBundle(): NSBundle;
  allBundles(): NSArray<any>;
  allFrameworks(): NSArray<any>;

}

interface NSStringAllocator<InitializedType = NSString> extends NSObjectAllocator<NSString> {
  init(): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCharactersNoCopy_length_freeWhenDone(characters: unichar, length: NSUInteger, freeBuffer: boolean): InitializedType;
  initWithCharacters_length(characters: unichar, length: NSUInteger): InitializedType;
  initWithUTF8String(nullTerminatedCString: string): InitializedType;
  initWithString(aString: NSString | string): InitializedType;
  initWithFormat(format: NSString | string, ...args: any[]): InitializedType;
  initWithFormat_arguments(format: NSString | string, ...argList: any[]): InitializedType;
  initWithFormat_locale(format: NSString | string, locale: any | null, ...args: any[]): InitializedType;
  initWithFormat_locale_arguments(format: NSString | string, locale: any | null, ...argList: any[]): InitializedType;
  initWithData_encoding(data: NSData, encoding: NSStringEncoding): InitializedType;
  initWithBytes_length_encoding(bytes: void, len: NSUInteger, encoding: NSStringEncoding): InitializedType;
  initWithBytesNoCopy_length_encoding_freeWhenDone(bytes: void, len: NSUInteger, encoding: NSStringEncoding, freeBuffer: boolean): InitializedType;
  initWithCString_encoding(nullTerminatedCString: string, encoding: NSStringEncoding): InitializedType;
  initWithContentsOfURL_encoding_error(url: NSURL, enc: NSStringEncoding, error: NSError): InitializedType;
  initWithContentsOfFile_encoding_error(path: NSString | string, enc: NSStringEncoding, error: NSError): InitializedType;
  initWithContentsOfURL_usedEncoding_error(url: NSURL, enc: NSStringEncoding | null, error: NSError): InitializedType;
  initWithContentsOfFile_usedEncoding_error(path: NSString | string, enc: NSStringEncoding | null, error: NSError): InitializedType;
  initWithContentsOfFile(path: NSString | string): InitializedType;
  initWithContentsOfURL(url: NSURL): InitializedType;
  initWithCStringNoCopy_length_freeWhenDone(bytes: string, length: NSUInteger, freeBuffer: boolean): InitializedType;
  initWithCString_length(bytes: string, length: NSUInteger): InitializedType;
  initWithCString(bytes: string): InitializedType;
}
interface NSString extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding {
  variantFittingPresentationWidth(width: NSInteger): NSString;
  linguisticTagsInRange_scheme_options_orthography_tokenRanges(range: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock(range: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, block: Block): void;
  stringByAppendingPathComponent(str: NSString | string): NSString;
  stringByAppendingPathExtension(str: NSString | string): NSString;
  stringsByAppendingPaths(paths: NSArray<any> | any[]): NSArray<any>;
  completePathIntoString_caseSensitive_matchesIntoArray_filterTypes(outputName: NSString | string, flag: boolean, outputArray: NSArray<any> | any[], filterTypes: NSArray<any> | any[] | null): NSUInteger;
  getFileSystemRepresentation_maxLength(cname: string, max: NSUInteger): boolean;
  characterAtIndex(index: NSUInteger): unichar;
  substringFromIndex(from: NSUInteger): NSString;
  substringToIndex(to: NSUInteger): NSString;
  substringWithRange(range: NSRange): NSString;
  getCharacters_range(buffer: unichar, range: NSRange): void;
  compare(string: NSString | string): NSComparisonResult;
  compare_options(string: NSString | string, mask: NSStringCompareOptions): NSComparisonResult;
  compare_options_range(string: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToCompare: NSRange): NSComparisonResult;
  compare_options_range_locale(string: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToCompare: NSRange, locale: any | null): NSComparisonResult;
  caseInsensitiveCompare(string: NSString | string): NSComparisonResult;
  localizedCompare(string: NSString | string): NSComparisonResult;
  localizedCaseInsensitiveCompare(string: NSString | string): NSComparisonResult;
  localizedStandardCompare(string: NSString | string): NSComparisonResult;
  isEqualToString(aString: NSString | string): boolean;
  hasPrefix(str: NSString | string): boolean;
  hasSuffix(str: NSString | string): boolean;
  commonPrefixWithString_options(str: NSString | string, mask: NSStringCompareOptions): NSString;
  containsString(str: NSString | string): boolean;
  localizedCaseInsensitiveContainsString(str: NSString | string): boolean;
  localizedStandardContainsString(str: NSString | string): boolean;
  localizedStandardRangeOfString(str: NSString | string): NSRange;
  rangeOfString(searchString: NSString | string): NSRange;
  rangeOfString_options(searchString: NSString | string, mask: NSStringCompareOptions): NSRange;
  rangeOfString_options_range(searchString: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToSearch: NSRange): NSRange;
  rangeOfString_options_range_locale(searchString: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToSearch: NSRange, locale: NSLocale | null): NSRange;
  rangeOfCharacterFromSet(searchSet: NSCharacterSet): NSRange;
  rangeOfCharacterFromSet_options(searchSet: NSCharacterSet, mask: NSStringCompareOptions): NSRange;
  rangeOfCharacterFromSet_options_range(searchSet: NSCharacterSet, mask: NSStringCompareOptions, rangeOfReceiverToSearch: NSRange): NSRange;
  rangeOfComposedCharacterSequenceAtIndex(index: NSUInteger): NSRange;
  rangeOfComposedCharacterSequencesForRange(range: NSRange): NSRange;
  stringByAppendingString(aString: NSString | string): NSString;
  stringByAppendingFormat(format: NSString | string, ...args: any[]): NSString;
  uppercaseStringWithLocale(locale: NSLocale | null): NSString;
  lowercaseStringWithLocale(locale: NSLocale | null): NSString;
  capitalizedStringWithLocale(locale: NSLocale | null): NSString;
  getLineStart_end_contentsEnd_forRange(startPtr: NSUInteger | null, lineEndPtr: NSUInteger | null, contentsEndPtr: NSUInteger | null, range: NSRange): void;
  lineRangeForRange(range: NSRange): NSRange;
  getParagraphStart_end_contentsEnd_forRange(startPtr: NSUInteger | null, parEndPtr: NSUInteger | null, contentsEndPtr: NSUInteger | null, range: NSRange): void;
  paragraphRangeForRange(range: NSRange): NSRange;
  enumerateSubstringsInRange_options_usingBlock(range: NSRange, opts: NSStringEnumerationOptions, block: Block): void;
  enumerateLinesUsingBlock(block: Block): void;
  dataUsingEncoding_allowLossyConversion(encoding: NSStringEncoding, lossy: boolean): NSData;
  dataUsingEncoding(encoding: NSStringEncoding): NSData;
  canBeConvertedToEncoding(encoding: NSStringEncoding): boolean;
  cStringUsingEncoding(encoding: NSStringEncoding): string;
  getCString_maxLength_encoding(buffer: string, maxBufferCount: NSUInteger, encoding: NSStringEncoding): boolean;
  getBytes_maxLength_usedLength_encoding_options_range_remainingRange(buffer: void | null, maxBufferCount: NSUInteger, usedBufferCount: NSUInteger | null, encoding: NSStringEncoding, options: NSStringEncodingConversionOptions, range: NSRange, leftover: NSRangePointer | null): boolean;
  maximumLengthOfBytesUsingEncoding(enc: NSStringEncoding): NSUInteger;
  lengthOfBytesUsingEncoding(enc: NSStringEncoding): NSUInteger;
  componentsSeparatedByString(separator: NSString | string): NSArray<any>;
  componentsSeparatedByCharactersInSet(separator: NSCharacterSet): NSArray<any>;
  stringByTrimmingCharactersInSet(set: NSCharacterSet): NSString;
  stringByPaddingToLength_withString_startingAtIndex(newLength: NSUInteger, padString: NSString | string, padIndex: NSUInteger): NSString;
  stringByFoldingWithOptions_locale(options: NSStringCompareOptions, locale: NSLocale | null): NSString;
  stringByReplacingOccurrencesOfString_withString_options_range(target: NSString | string, replacement: NSString | string, options: NSStringCompareOptions, searchRange: NSRange): NSString;
  stringByReplacingOccurrencesOfString_withString(target: NSString | string, replacement: NSString | string): NSString;
  stringByReplacingCharactersInRange_withString(range: NSRange, replacement: NSString | string): NSString;
  stringByApplyingTransform_reverse(transform: NSStringTransform, reverse: boolean): NSString;
  writeToURL_atomically_encoding_error(url: NSURL, useAuxiliaryFile: boolean, enc: NSStringEncoding, error: NSError): boolean;
  writeToFile_atomically_encoding_error(path: NSString | string, useAuxiliaryFile: boolean, enc: NSStringEncoding, error: NSError): boolean;
  propertyList(): any;
  propertyListFromStringsFileFormat(): NSDictionary<any, any>;
  cString(): string;
  lossyCString(): string;
  cStringLength(): NSUInteger;
  getCString(bytes: string): void;
  getCString_maxLength(bytes: string, maxLength: NSUInteger): void;
  getCString_maxLength_range_remainingRange(bytes: string, maxLength: NSUInteger, aRange: NSRange, leftoverRange: NSRangePointer | null): void;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  getCharacters(buffer: unichar): void;
  stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet): NSString;
  stringByAddingPercentEscapesUsingEncoding(enc: NSStringEncoding): NSString;
  stringByReplacingPercentEscapesUsingEncoding(enc: NSStringEncoding): NSString;
  sizeWithAttributes(attrs: NSDictionary<any, any> | {[key: string]: any} | null): NSSize;
  drawAtPoint_withAttributes(point: NSPoint, attrs: NSDictionary<any, any> | {[key: string]: any} | null): void;
  drawInRect_withAttributes(rect: NSRect, attrs: NSDictionary<any, any> | {[key: string]: any} | null): void;
  drawWithRect_options_attributes_context(rect: NSRect, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null, context: NSStringDrawingContext | null): void;
  boundingRectWithSize_options_attributes_context(size: NSSize, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null, context: NSStringDrawingContext | null): NSRect;
  drawWithRect_options_attributes(rect: NSRect, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null): void;
  boundingRectWithSize_options_attributes(size: NSSize, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null): NSRect;
  stringByDeletingPrefix(prefix: NSString | string): NSString;
  stringByDeletingSuffix(suffix: NSString | string): NSString;
  stringByStrippingStrings(strings: NSArray<any> | any[]): NSString;
  stringByAppendingPathComponents(components: NSArray<any> | any[]): NSString;
  startsWith(str: NSString | string): boolean;
  endsWith(str: NSString | string): boolean;
  endsWith_options(str: NSString | string, options: NSStringCompareOptions): boolean;
  containsSubstring(sub: NSString | string): boolean;
  containsCharacter(c: unichar): boolean;
  stringWithFirstCharacterLowercase(): NSString;
  trimmedString(): NSString;
  splitByBaseAndNumber(): NSDictionary<any, any>;
  uniqueStringComparedToStrings_includeCopySuffix(strings: NSSet<any>, shouldAppendCopySuffix: boolean): NSString;
  words(): NSArray<any>;
  safeSubstringToIndex_ms(index: NSUInteger): NSString;
  safeSubstringFromIndex_ms(index: NSUInteger): NSString;
  safeSubstringWithRange_ms(range: NSRange): NSString;
  parent(): NSString;
  child(childName: NSString | string): NSString;
  extension(): NSString;
  withoutExtension(): NSString;
  withExtension(extension: NSString | string): NSString;
  expandTilde(): NSString;
  hasExtension(extension: NSString | string): boolean;
  isValidEmailAddress(): boolean;
  stringBySplittingMixedCaps(): NSString;
  componentsSeparatedByMixedCaps(): NSArray<any>;
  lastLines(count: NSUInteger): NSString;
  firstLines(count: NSUInteger): NSString;
  matchesString_divergingAfter_atIndex_divergentChar_expectedChar(string: NSString | string | null, prefix: NSString | string, index: NSUInteger, divergentChar: string, expectedChar: string): boolean;
  matchesString_divergingAtLine_after_diverged_expected(string: NSString | string | null, divergingLine: NSUInteger, after: NSString | string, diverged: NSString | string, expected: NSString | string): boolean;
  matchesString_divergingAtLine1_andLine2_diverged_expected(string: NSString | string | null, line1: NSUInteger, line2: NSUInteger, diverged: NSString | string, expected: NSString | string): boolean;
  matchesString_divergingAtLine1_andLine2_diverged_expected_window(string: NSString | string | null, line1: NSUInteger, line2: NSUInteger, diverged: NSString | string, expected: NSString | string, window: NSInteger): boolean;
  drawAtPoint_withFont(aPoint: NSPoint, font: NSFont): void;
  drawCenteredAtPoint_withFont_color(aPoint: NSPoint, font: NSFont, color: NSColor): void;
  sizeWithFont(aFont: NSFont): NSSize;
  heightWithFont_maxWidth(myFont: NSFont, myWidth: CGFloat): CGFloat;
  fontSizeToFitStringWithAttributes_inSize_maximumFontSize(attributes: CHStringAttributes, aSize: NSSize, maxSize: NSInteger): NSInteger;
  fontSizeToFitStringWithAttributes_inSize(attributes: CHStringAttributes, aSize: NSSize): NSInteger;
  fontSizeToFitStringWithAttributes_inWidth(attributes: CHStringAttributes, width: NSInteger): NSInteger;
  fontSizeToFitStringWithAttributes_inHeight(attributes: CHStringAttributes, height: NSInteger): NSInteger;
  fitStringAttributes_inSize(attributes: CHStringAttributes, aSize: NSSize): void;
  fitStringAttributes_inWidth(attributes: CHStringAttributes, width: NSInteger): void;
  fitStringAttributes_inHeight(attributes: CHStringAttributes, height: NSInteger): void;
  colorValue(): NSColor;
  sRGBColorFromHexColor(): NSColor;
  enumerateWordRanges(block: CHStringWordEnumeratorBlock): void;
  wordRanges(): NSArray<any>;
  numberValueInContextOfSize_onAxis(size: NSRect, axis: BCAxis): NSNumber;
  stringBySanitizingForNumberFormatter(formatter: NSNumberFormatter | null): NSString;
  stringByCalculatingMath(): NSString;
  numberValueUsingMath(): NSNumber;
  containsMathSymbols(): boolean;
  mathPrefix(): NSString;
  numberValueByUsingNumberFormatter(): NSNumber;
  uniqueSlugUsingEarlierSlugs(earlierSlugs: NSMutableDictionary<any, any> | {[key: string]: any} | null): NSString;
  svgURL(): NSString;

  pathComponents(): NSArray<any>;
  absolutePath(): boolean;
  lastPathComponent(): NSString;
  stringByDeletingLastPathComponent(): NSString;
  pathExtension(): NSString;
  stringByDeletingPathExtension(): NSString;
  stringByAbbreviatingWithTildeInPath(): NSString;
  stringByExpandingTildeInPath(): NSString;
  stringByStandardizingPath(): NSString;
  stringByResolvingSymlinksInPath(): NSString;
  fileSystemRepresentation(): string;
  length(): NSUInteger;
  doubleValue(): number;
  floatValue(): number;
  intValue(): number;
  integerValue(): NSInteger;
  longLongValue(): number;
  boolValue(): boolean;
  uppercaseString(): NSString;
  lowercaseString(): NSString;
  capitalizedString(): NSString;
  localizedUppercaseString(): NSString;
  localizedLowercaseString(): NSString;
  localizedCapitalizedString(): NSString;
  UTF8String(): string;
  fastestEncoding(): NSStringEncoding;
  smallestEncoding(): NSStringEncoding;
  decomposedStringWithCanonicalMapping(): NSString;
  precomposedStringWithCanonicalMapping(): NSString;
  decomposedStringWithCompatibilityMapping(): NSString;
  precomposedStringWithCompatibilityMapping(): NSString;
  description(): NSString;
  hash(): NSUInteger;
  stringByRemovingPercentEncoding(): NSString;
  slug(): NSString;
}
declare const NSString: {
  alloc(): NSStringAllocator;  pathWithComponents(components: NSArray<any> | any[]): NSString;
  localizedNameOfStringEncoding(encoding: NSStringEncoding): NSString;
  string(): NSString;
  stringWithString(string: NSString | string): NSString;
  stringWithCharacters_length(characters: unichar, length: NSUInteger): NSString;
  stringWithUTF8String(nullTerminatedCString: string): NSString;
  stringWithFormat(format: NSString | string, ...args: any[]): NSString;
  localizedStringWithFormat(format: NSString | string, ...args: any[]): NSString;
  stringWithCString_encoding(cString: string, enc: NSStringEncoding): NSString;
  stringWithContentsOfURL_encoding_error(url: NSURL, enc: NSStringEncoding, error: NSError): NSString;
  stringWithContentsOfFile_encoding_error(path: NSString | string, enc: NSStringEncoding, error: NSError): NSString;
  stringWithContentsOfURL_usedEncoding_error(url: NSURL, enc: NSStringEncoding | null, error: NSError): NSString;
  stringWithContentsOfFile_usedEncoding_error(path: NSString | string, enc: NSStringEncoding | null, error: NSError): NSString;
  stringEncodingForData_encodingOptions_convertedString_usedLossyConversion(data: NSData, opts: NSDictionary<any, any> | {[key: string]: any} | null, string: NSString | string, usedLossyConversion: boolean | null): NSStringEncoding;
  stringWithContentsOfFile(path: NSString | string): any;
  stringWithContentsOfURL(url: NSURL): any;
  stringWithCString_length(bytes: string, length: NSUInteger): any;
  stringWithCString(bytes: string): any;
  stringRepresentationForSeconds(numberOfSeconds: NSUInteger): NSString;
  stringWithPrefix_number(front: NSString | string, number: NSInteger): NSString;
  stringWithUUID(): any;
  nativeDecimalSeparator(): NSString;
  mathStringWithOperand1_operator_operand2(operand1: CGFloat, operator: NSString | string, operand2: CGFloat): NSString;
  svgStringWithPixelValue(value: CGFloat): NSString;
  svgStringWithNumberValue(value: CGFloat): NSString;
  svgStringWithPercentageValue(value: CGFloat): NSString;
  svgStringWithPercentageFractionalValue(value: CGFloat): NSString;
  stringWithInt_suffix(anInt: NSInteger, suffix: NSString | string): NSString;

  availableStringEncodings(): NSStringEncoding;
  defaultCStringEncoding(): NSStringEncoding;

}

interface NSBundleResourceRequestAllocator<InitializedType = NSBundleResourceRequest> extends NSObjectAllocator<NSBundleResourceRequest> {
  initWithTags(tags: NSSet<any>): InitializedType;
  initWithTags_bundle(tags: NSSet<any>, bundle: NSBundle): InitializedType;
}
interface NSBundleResourceRequest extends NSObject, INSProgressReporting {
  beginAccessingResourcesWithCompletionHandler(completionHandler: Block): void;
  conditionallyBeginAccessingResourcesWithCompletionHandler(completionHandler: Block): void;
  endAccessingResources(): void;

  loadingPriority(): number;
  setLoadingPriority(loadingPriority: number): void;
  tags(): NSSet<any>;
  bundle(): NSBundle;
  progress(): NSProgress;
}
declare const NSBundleResourceRequest: {
  alloc(): NSBundleResourceRequestAllocator;
}

interface NSByteCountFormatterAllocator<InitializedType = NSByteCountFormatter> extends NSFormatterAllocator<NSByteCountFormatter> {}
interface NSByteCountFormatter extends NSFormatter {
  stringFromByteCount(byteCount: number): NSString;

  allowedUnits(): NSByteCountFormatterUnits;
  setAllowedUnits(allowedUnits: NSByteCountFormatterUnits): void;
  countStyle(): NSByteCountFormatterCountStyle;
  setCountStyle(countStyle: NSByteCountFormatterCountStyle): void;
  allowsNonnumericFormatting(): boolean;
  setAllowsNonnumericFormatting(allowsNonnumericFormatting: boolean): void;
  includesUnit(): boolean;
  setIncludesUnit(includesUnit: boolean): void;
  includesCount(): boolean;
  setIncludesCount(includesCount: boolean): void;
  includesActualByteCount(): boolean;
  setIncludesActualByteCount(includesActualByteCount: boolean): void;
  adaptive(): boolean;
  setAdaptive(adaptive: boolean): void;
  zeroPadsFractionDigits(): boolean;
  setZeroPadsFractionDigits(zeroPadsFractionDigits: boolean): void;
  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
}
declare const NSByteCountFormatter: {
  alloc(): NSByteCountFormatterAllocator;  stringFromByteCount_countStyle(byteCount: number, countStyle: NSByteCountFormatterCountStyle): NSString;

}

declare enum NSByteCountFormatterUnits {
  NSByteCountFormatterUseDefault = 0,
  NSByteCountFormatterUseBytes = 1 << 0,
  NSByteCountFormatterUseKB = 1 << 1,
  NSByteCountFormatterUseMB = 1 << 2,
  NSByteCountFormatterUseGB = 1 << 3,
  NSByteCountFormatterUseTB = 1 << 4,
  NSByteCountFormatterUsePB = 1 << 5,
  NSByteCountFormatterUseEB = 1 << 6,
  NSByteCountFormatterUseZB = 1 << 7,
  NSByteCountFormatterUseYBOrHigher = 0x0FF << 8,
  NSByteCountFormatterUseAll = 0x0FFFF,
}

declare enum NSByteCountFormatterCountStyle {
  NSByteCountFormatterCountStyleFile = 0,
  NSByteCountFormatterCountStyleMemory = 1,
  NSByteCountFormatterCountStyleDecimal = 2,
  NSByteCountFormatterCountStyleBinary = 3,
}

declare type NSSwappedFloat = {
  v: number
}

declare type NSSwappedDouble = {
  v: number
}

declare type NSCache = any

interface INSCacheDelegate {
  cache_willEvictObject(cache: NSCache, obj: any): void;
}

interface NSCalendarAllocator<InitializedType = NSCalendar> extends NSObjectAllocator<NSCalendar> {
  initWithCalendarIdentifier(ident: NSCalendarIdentifier): InitializedType;
}
interface NSCalendar extends NSObject, INSCopying, INSSecureCoding {
  minimumRangeOfUnit(unit: NSCalendarUnit): NSRange;
  maximumRangeOfUnit(unit: NSCalendarUnit): NSRange;
  rangeOfUnit_inUnit_forDate(smaller: NSCalendarUnit, larger: NSCalendarUnit, date: NSDate): NSRange;
  ordinalityOfUnit_inUnit_forDate(smaller: NSCalendarUnit, larger: NSCalendarUnit, date: NSDate): NSUInteger;
  rangeOfUnit_startDate_interval_forDate(unit: NSCalendarUnit, datep: NSDate, tip: NSTimeInterval | null, date: NSDate): boolean;
  dateFromComponents(comps: NSDateComponents): NSDate;
  components_fromDate(unitFlags: NSCalendarUnit, date: NSDate): NSDateComponents;
  dateByAddingComponents_toDate_options(comps: NSDateComponents, date: NSDate, opts: NSCalendarOptions): NSDate;
  components_fromDate_toDate_options(unitFlags: NSCalendarUnit, startingDate: NSDate, resultDate: NSDate, opts: NSCalendarOptions): NSDateComponents;
  getEra_year_month_day_fromDate(eraValuePointer: NSInteger, yearValuePointer: NSInteger, monthValuePointer: NSInteger, dayValuePointer: NSInteger, date: NSDate): void;
  getEra_yearForWeekOfYear_weekOfYear_weekday_fromDate(eraValuePointer: NSInteger, yearValuePointer: NSInteger, weekValuePointer: NSInteger, weekdayValuePointer: NSInteger, date: NSDate): void;
  getHour_minute_second_nanosecond_fromDate(hourValuePointer: NSInteger, minuteValuePointer: NSInteger, secondValuePointer: NSInteger, nanosecondValuePointer: NSInteger, date: NSDate): void;
  component_fromDate(unit: NSCalendarUnit, date: NSDate): NSInteger;
  dateWithEra_year_month_day_hour_minute_second_nanosecond(eraValue: NSInteger, yearValue: NSInteger, monthValue: NSInteger, dayValue: NSInteger, hourValue: NSInteger, minuteValue: NSInteger, secondValue: NSInteger, nanosecondValue: NSInteger): NSDate;
  dateWithEra_yearForWeekOfYear_weekOfYear_weekday_hour_minute_second_nanosecond(eraValue: NSInteger, yearValue: NSInteger, weekValue: NSInteger, weekdayValue: NSInteger, hourValue: NSInteger, minuteValue: NSInteger, secondValue: NSInteger, nanosecondValue: NSInteger): NSDate;
  startOfDayForDate(date: NSDate): NSDate;
  componentsInTimeZone_fromDate(timezone: NSTimeZone, date: NSDate): NSDateComponents;
  compareDate_toDate_toUnitGranularity(date1: NSDate, date2: NSDate, unit: NSCalendarUnit): NSComparisonResult;
  isDate_equalToDate_toUnitGranularity(date1: NSDate, date2: NSDate, unit: NSCalendarUnit): boolean;
  isDate_inSameDayAsDate(date1: NSDate, date2: NSDate): boolean;
  isDateInToday(date: NSDate): boolean;
  isDateInYesterday(date: NSDate): boolean;
  isDateInTomorrow(date: NSDate): boolean;
  isDateInWeekend(date: NSDate): boolean;
  rangeOfWeekendStartDate_interval_containingDate(datep: NSDate, tip: NSTimeInterval, date: NSDate): boolean;
  nextWeekendStartDate_interval_options_afterDate(datep: NSDate, tip: NSTimeInterval, options: NSCalendarOptions, date: NSDate): boolean;
  components_fromDateComponents_toDateComponents_options(unitFlags: NSCalendarUnit, startingDateComp: NSDateComponents, resultDateComp: NSDateComponents, options: NSCalendarOptions): NSDateComponents;
  dateByAddingUnit_value_toDate_options(unit: NSCalendarUnit, value: NSInteger, date: NSDate, options: NSCalendarOptions): NSDate;
  enumerateDatesStartingAfterDate_matchingComponents_options_usingBlock(start: NSDate, comps: NSDateComponents, opts: NSCalendarOptions, block: Block): void;
  nextDateAfterDate_matchingComponents_options(date: NSDate, comps: NSDateComponents, options: NSCalendarOptions): NSDate;
  nextDateAfterDate_matchingUnit_value_options(date: NSDate, unit: NSCalendarUnit, value: NSInteger, options: NSCalendarOptions): NSDate;
  nextDateAfterDate_matchingHour_minute_second_options(date: NSDate, hourValue: NSInteger, minuteValue: NSInteger, secondValue: NSInteger, options: NSCalendarOptions): NSDate;
  dateBySettingUnit_value_ofDate_options(unit: NSCalendarUnit, v: NSInteger, date: NSDate, opts: NSCalendarOptions): NSDate;
  dateBySettingHour_minute_second_ofDate_options(h: NSInteger, m: NSInteger, s: NSInteger, date: NSDate, opts: NSCalendarOptions): NSDate;
  date_matchesComponents(date: NSDate, components: NSDateComponents): boolean;

  calendarIdentifier(): NSCalendarIdentifier;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  firstWeekday(): NSUInteger;
  setFirstWeekday(firstWeekday: NSUInteger): void;
  minimumDaysInFirstWeek(): NSUInteger;
  setMinimumDaysInFirstWeek(minimumDaysInFirstWeek: NSUInteger): void;
  eraSymbols(): NSArray<any>;
  longEraSymbols(): NSArray<any>;
  monthSymbols(): NSArray<any>;
  shortMonthSymbols(): NSArray<any>;
  veryShortMonthSymbols(): NSArray<any>;
  standaloneMonthSymbols(): NSArray<any>;
  shortStandaloneMonthSymbols(): NSArray<any>;
  veryShortStandaloneMonthSymbols(): NSArray<any>;
  weekdaySymbols(): NSArray<any>;
  shortWeekdaySymbols(): NSArray<any>;
  veryShortWeekdaySymbols(): NSArray<any>;
  standaloneWeekdaySymbols(): NSArray<any>;
  shortStandaloneWeekdaySymbols(): NSArray<any>;
  veryShortStandaloneWeekdaySymbols(): NSArray<any>;
  quarterSymbols(): NSArray<any>;
  shortQuarterSymbols(): NSArray<any>;
  standaloneQuarterSymbols(): NSArray<any>;
  shortStandaloneQuarterSymbols(): NSArray<any>;
  AMSymbol(): NSString;
  PMSymbol(): NSString;
}
declare const NSCalendar: {
  alloc(): NSCalendarAllocator;  calendarWithIdentifier(calendarIdentifierConstant: NSCalendarIdentifier): NSCalendar;

  currentCalendar(): NSCalendar;
  autoupdatingCurrentCalendar(): NSCalendar;

}

interface NSDateComponentsAllocator<InitializedType = NSDateComponents> extends NSObjectAllocator<NSDateComponents> {}
interface NSDateComponents extends NSObject, INSCopying, INSSecureCoding {
  setValue_forComponent(value: NSInteger, unit: NSCalendarUnit): void;
  valueForComponent(unit: NSCalendarUnit): NSInteger;
  isValidDateInCalendar(calendar: NSCalendar): boolean;

  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  era(): NSInteger;
  setEra(era: NSInteger): void;
  year(): NSInteger;
  setYear(year: NSInteger): void;
  month(): NSInteger;
  setMonth(month: NSInteger): void;
  day(): NSInteger;
  setDay(day: NSInteger): void;
  hour(): NSInteger;
  setHour(hour: NSInteger): void;
  minute(): NSInteger;
  setMinute(minute: NSInteger): void;
  second(): NSInteger;
  setSecond(second: NSInteger): void;
  nanosecond(): NSInteger;
  setNanosecond(nanosecond: NSInteger): void;
  weekday(): NSInteger;
  setWeekday(weekday: NSInteger): void;
  weekdayOrdinal(): NSInteger;
  setWeekdayOrdinal(weekdayOrdinal: NSInteger): void;
  quarter(): NSInteger;
  setQuarter(quarter: NSInteger): void;
  weekOfMonth(): NSInteger;
  setWeekOfMonth(weekOfMonth: NSInteger): void;
  weekOfYear(): NSInteger;
  setWeekOfYear(weekOfYear: NSInteger): void;
  yearForWeekOfYear(): NSInteger;
  setYearForWeekOfYear(yearForWeekOfYear: NSInteger): void;
  leapMonth(): boolean;
  setLeapMonth(leapMonth: boolean): void;
  date(): NSDate;
  validDate(): boolean;
}
declare const NSDateComponents: {
  alloc(): NSDateComponentsAllocator;
}

declare type NSCalendarIdentifier = NSString

declare enum NSCalendarUnit {
  NSCalendarUnitEra,
  NSCalendarUnitYear,
  NSCalendarUnitMonth,
  NSCalendarUnitDay,
  NSCalendarUnitHour,
  NSCalendarUnitMinute,
  NSCalendarUnitSecond,
  NSCalendarUnitWeekday,
  NSCalendarUnitWeekdayOrdinal,
  NSCalendarUnitQuarter,
  NSCalendarUnitWeekOfMonth,
  NSCalendarUnitWeekOfYear,
  NSCalendarUnitYearForWeekOfYear,
  NSCalendarUnitNanosecond,
  NSCalendarUnitCalendar,
  NSCalendarUnitTimeZone,
  NSEraCalendarUnit,
  NSYearCalendarUnit,
  NSMonthCalendarUnit,
  NSDayCalendarUnit,
  NSHourCalendarUnit,
  NSMinuteCalendarUnit,
  NSSecondCalendarUnit,
  NSWeekCalendarUnit,
  NSWeekdayCalendarUnit,
  NSWeekdayOrdinalCalendarUnit,
  NSQuarterCalendarUnit,
  NSWeekOfMonthCalendarUnit,
  NSWeekOfYearCalendarUnit,
  NSYearForWeekOfYearCalendarUnit,
  NSCalendarCalendarUnit,
  NSTimeZoneCalendarUnit,
}

declare enum NSCalendarOptions {
  NSCalendarWrapComponents,
  NSCalendarMatchStrictly,
  NSCalendarSearchBackwards,
  NSCalendarMatchPreviousTimePreservingSmallerUnits,
  NSCalendarMatchNextTimePreservingSmallerUnits,
  NSCalendarMatchNextTime,
  NSCalendarMatchFirst,
  NSCalendarMatchLast,
}

interface NSCalendarDateAllocator<InitializedType = NSCalendarDate> extends NSDateAllocator<NSCalendarDate> {}
interface NSCalendarDate extends NSDate {
}
declare const NSCalendarDate: {
  alloc(): NSCalendarDateAllocator;
}

interface NSDateAllocator<InitializedType = NSDate> extends NSObjectAllocator<NSDate> {
  init(): InitializedType;
  initWithTimeIntervalSinceReferenceDate(ti: NSTimeInterval): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithTimeIntervalSinceNow(secs: NSTimeInterval): InitializedType;
  initWithTimeIntervalSince1970(secs: NSTimeInterval): InitializedType;
  initWithTimeInterval_sinceDate(secsToBeAdded: NSTimeInterval, date: NSDate): InitializedType;
}
interface NSDate extends NSObject, INSCopying, INSSecureCoding {
  timeIntervalSinceDate(anotherDate: NSDate): NSTimeInterval;
  addTimeInterval(seconds: NSTimeInterval): any;
  dateByAddingTimeInterval(ti: NSTimeInterval): NSDate;
  earlierDate(anotherDate: NSDate): NSDate;
  laterDate(anotherDate: NSDate): NSDate;
  compare(other: NSDate): NSComparisonResult;
  isEqualToDate(otherDate: NSDate): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  iso8601(): NSString;
  NTPRepresentation_bc(): number;

  timeIntervalSinceNow(): NSTimeInterval;
  timeIntervalSince1970(): NSTimeInterval;
  description(): NSString;
}
declare const NSDate: {
  alloc(): NSDateAllocator;  date(): NSDate;
  dateWithTimeIntervalSinceNow(secs: NSTimeInterval): NSDate;
  dateWithTimeIntervalSinceReferenceDate(ti: NSTimeInterval): NSDate;
  dateWithTimeIntervalSince1970(secs: NSTimeInterval): NSDate;
  dateWithTimeInterval_sinceDate(secsToBeAdded: NSTimeInterval, date: NSDate): NSDate;
  iso8601DateFormatter(): NSDateFormatter;
  dateWithNTPRepresentation_bc(ntp: number): NSDate;

  timeIntervalSinceReferenceDate(): NSTimeInterval;
  distantFuture(): NSDate;
  distantPast(): NSDate;

}

interface NSCharacterSetAllocator<InitializedType = NSCharacterSet> extends NSObjectAllocator<NSCharacterSet> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSCharacterSet extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding {
  characterIsMember(aCharacter: unichar): boolean;
  longCharacterIsMember(theLongChar: string): boolean;
  isSupersetOfSet(theOtherSet: NSCharacterSet): boolean;
  hasMemberInPlane(thePlane: number): boolean;

  bitmapRepresentation(): NSData;
  invertedSet(): NSCharacterSet;
}
declare const NSCharacterSet: {
  alloc(): NSCharacterSetAllocator;  characterSetWithRange(aRange: NSRange): NSCharacterSet;
  characterSetWithCharactersInString(aString: NSString | string): NSCharacterSet;
  characterSetWithBitmapRepresentation(data: NSData): NSCharacterSet;
  characterSetWithContentsOfFile(fName: NSString | string): NSCharacterSet;

  controlCharacterSet(): NSCharacterSet;
  whitespaceCharacterSet(): NSCharacterSet;
  whitespaceAndNewlineCharacterSet(): NSCharacterSet;
  decimalDigitCharacterSet(): NSCharacterSet;
  letterCharacterSet(): NSCharacterSet;
  lowercaseLetterCharacterSet(): NSCharacterSet;
  uppercaseLetterCharacterSet(): NSCharacterSet;
  nonBaseCharacterSet(): NSCharacterSet;
  alphanumericCharacterSet(): NSCharacterSet;
  decomposableCharacterSet(): NSCharacterSet;
  illegalCharacterSet(): NSCharacterSet;
  punctuationCharacterSet(): NSCharacterSet;
  capitalizedLetterCharacterSet(): NSCharacterSet;
  symbolCharacterSet(): NSCharacterSet;
  newlineCharacterSet(): NSCharacterSet;
  URLUserAllowedCharacterSet(): NSCharacterSet;
  URLPasswordAllowedCharacterSet(): NSCharacterSet;
  URLHostAllowedCharacterSet(): NSCharacterSet;
  URLPathAllowedCharacterSet(): NSCharacterSet;
  URLQueryAllowedCharacterSet(): NSCharacterSet;
  URLFragmentAllowedCharacterSet(): NSCharacterSet;

}

interface NSMutableCharacterSetAllocator<InitializedType = NSMutableCharacterSet> extends NSCharacterSetAllocator<NSMutableCharacterSet> {}
interface NSMutableCharacterSet extends NSCharacterSet, INSCopying, INSMutableCopying, INSSecureCoding {
  addCharactersInRange(aRange: NSRange): void;
  removeCharactersInRange(aRange: NSRange): void;
  addCharactersInString(aString: NSString | string): void;
  removeCharactersInString(aString: NSString | string): void;
  formUnionWithCharacterSet(otherSet: NSCharacterSet): void;
  formIntersectionWithCharacterSet(otherSet: NSCharacterSet): void;
  invert(): void;
}
declare const NSMutableCharacterSet: {
  alloc(): NSMutableCharacterSetAllocator;  controlCharacterSet(): NSMutableCharacterSet;
  whitespaceCharacterSet(): NSMutableCharacterSet;
  whitespaceAndNewlineCharacterSet(): NSMutableCharacterSet;
  decimalDigitCharacterSet(): NSMutableCharacterSet;
  letterCharacterSet(): NSMutableCharacterSet;
  lowercaseLetterCharacterSet(): NSMutableCharacterSet;
  uppercaseLetterCharacterSet(): NSMutableCharacterSet;
  nonBaseCharacterSet(): NSMutableCharacterSet;
  alphanumericCharacterSet(): NSMutableCharacterSet;
  decomposableCharacterSet(): NSMutableCharacterSet;
  illegalCharacterSet(): NSMutableCharacterSet;
  punctuationCharacterSet(): NSMutableCharacterSet;
  capitalizedLetterCharacterSet(): NSMutableCharacterSet;
  symbolCharacterSet(): NSMutableCharacterSet;
  newlineCharacterSet(): NSMutableCharacterSet;
  characterSetWithRange(aRange: NSRange): NSMutableCharacterSet;
  characterSetWithCharactersInString(aString: NSString | string): NSMutableCharacterSet;
  characterSetWithBitmapRepresentation(data: NSData): NSMutableCharacterSet;
  characterSetWithContentsOfFile(fName: NSString | string): NSMutableCharacterSet;

}

interface NSClassDescriptionAllocator<InitializedType = NSClassDescription> extends NSObjectAllocator<NSClassDescription> {}
interface NSClassDescription extends NSObject {
  inverseForRelationshipKey(relationshipKey: NSString | string): NSString;

  attributeKeys(): NSArray<any>;
  toOneRelationshipKeys(): NSArray<any>;
  toManyRelationshipKeys(): NSArray<any>;
}
declare const NSClassDescription: {
  alloc(): NSClassDescriptionAllocator;  registerClassDescription_forClass(description: NSClassDescription, aClass: any): void;
  invalidateClassDescriptionCache(): void;
  classDescriptionForClass(aClass: any): NSClassDescription;

}

interface NSCoderAllocator<InitializedType = NSCoder> extends NSObjectAllocator<NSCoder> {}
interface NSCoder extends NSObject {
  encodeValueOfObjCType_at(type: string, addr: void): void;
  encodeDataObject(data: NSData): void;
  decodeDataObject(): NSData;
  decodeValueOfObjCType_at_size(type: string, data: void, size: NSUInteger): void;
  versionForClassName(className: NSString | string): NSInteger;
  encodeObject(object: any | null): void;
  encodeRootObject(rootObject: any): void;
  encodeBycopyObject(anObject: any | null): void;
  encodeByrefObject(anObject: any | null): void;
  encodeConditionalObject(object: any | null): void;
  encodeValuesOfObjCTypes(types: string, ...args: any[]): void;
  encodeArrayOfObjCType_count_at(type: string, count: NSUInteger, array: void): void;
  encodeBytes_length(byteaddr: void | null, length: NSUInteger): void;
  decodeObject(): any;
  decodeValuesOfObjCTypes(types: string, ...args: any[]): void;
  decodeArrayOfObjCType_count_at(itemType: string, count: NSUInteger, array: void): void;
  decodeBytesWithReturnedLength(lengthp: NSUInteger): void;
  encodePropertyList(aPropertyList: any): void;
  decodePropertyList(): any;
  encodeObject_forKey(object: any | null, key: NSString | string): void;
  encodeConditionalObject_forKey(object: any | null, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeInt_forKey(value: number, key: NSString | string): void;
  encodeInt32_forKey(value: number, key: NSString | string): void;
  encodeInt64_forKey(value: number, key: NSString | string): void;
  encodeFloat_forKey(value: number, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBytes_length_forKey(bytes: number | null, length: NSUInteger, key: NSString | string): void;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeBoolForKey(key: NSString | string): boolean;
  decodeIntForKey(key: NSString | string): number;
  decodeInt32ForKey(key: NSString | string): number;
  decodeInt64ForKey(key: NSString | string): number;
  decodeFloatForKey(key: NSString | string): number;
  decodeDoubleForKey(key: NSString | string): number;
  decodeBytesForKey_returnedLength(key: NSString | string, lengthp: NSUInteger | null): number;
  encodeInteger_forKey(value: NSInteger, key: NSString | string): void;
  decodeIntegerForKey(key: NSString | string): NSInteger;
  decodeObjectOfClass_forKey(aClass: any, key: NSString | string): any;
  decodeObjectOfClasses_forKey(classes: NSSet<any> | null, key: NSString | string): any;
  decodePropertyListForKey(key: NSString | string): any;
  failWithError(error: NSError): void;
  encodeNXObject(object: any): void;
  decodeNXObject(): any;
  decodeValueOfObjCType_at(type: string, data: void): void;
  encodePoint(point: NSPoint): void;
  decodePoint(): NSPoint;
  encodeSize(size: NSSize): void;
  decodeSize(): NSSize;
  encodeRect(rect: NSRect): void;
  decodeRect(): NSRect;
  encodePoint_forKey(point: NSPoint, key: NSString | string): void;
  encodeSize_forKey(size: NSSize, key: NSString | string): void;
  encodeRect_forKey(rect: NSRect, key: NSString | string): void;
  decodePointForKey(key: NSString | string): NSPoint;
  decodeSizeForKey(key: NSString | string): NSSize;
  decodeRectForKey(key: NSString | string): NSRect;
  decodeNXColor(): NSColor;

  systemVersion(): number;
  allowsKeyedCoding(): boolean;
  requiresSecureCoding(): boolean;
  allowedClasses(): NSSet<any>;
  decodingFailurePolicy(): NSDecodingFailurePolicy;
  error(): NSError;
}
declare const NSCoder: {
  alloc(): NSCoderAllocator;
}

declare enum NSDecodingFailurePolicy {
  NSDecodingFailurePolicyRaiseException,
  NSDecodingFailurePolicySetErrorAndReturn,
}

interface NSComparisonPredicateAllocator<InitializedType = NSComparisonPredicate> extends NSPredicateAllocator<NSComparisonPredicate> {
  initWithLeftExpression_rightExpression_modifier_type_options(lhs: NSExpression, rhs: NSExpression, modifier: NSComparisonPredicateModifier, type: NSPredicateOperatorType, options: NSComparisonPredicateOptions): InitializedType;
  initWithLeftExpression_rightExpression_customSelector(lhs: NSExpression, rhs: NSExpression, selector: string): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
}
interface NSComparisonPredicate extends NSPredicate {

  predicateOperatorType(): NSPredicateOperatorType;
  comparisonPredicateModifier(): NSComparisonPredicateModifier;
  leftExpression(): NSExpression;
  rightExpression(): NSExpression;
  customSelector(): string;
  options(): NSComparisonPredicateOptions;
}
declare const NSComparisonPredicate: {
  alloc(): NSComparisonPredicateAllocator;  predicateWithLeftExpression_rightExpression_modifier_type_options(lhs: NSExpression, rhs: NSExpression, modifier: NSComparisonPredicateModifier, type: NSPredicateOperatorType, options: NSComparisonPredicateOptions): NSComparisonPredicate;
  predicateWithLeftExpression_rightExpression_customSelector(lhs: NSExpression, rhs: NSExpression, selector: string): NSComparisonPredicate;

}

declare enum NSComparisonPredicateOptions {
  NSCaseInsensitivePredicateOption = 0x01,
  NSDiacriticInsensitivePredicateOption = 0x02,
  NSNormalizedPredicateOption = 0x04,
}

declare enum NSComparisonPredicateModifier {
  NSDirectPredicateModifier = 0,
  NSAllPredicateModifier,
  NSAnyPredicateModifier,
}

declare enum NSPredicateOperatorType {
  NSLessThanPredicateOperatorType = 0,
  NSLessThanOrEqualToPredicateOperatorType,
  NSGreaterThanPredicateOperatorType,
  NSGreaterThanOrEqualToPredicateOperatorType,
  NSEqualToPredicateOperatorType,
  NSNotEqualToPredicateOperatorType,
  NSMatchesPredicateOperatorType,
  NSLikePredicateOperatorType,
  NSBeginsWithPredicateOperatorType,
  NSEndsWithPredicateOperatorType,
  NSInPredicateOperatorType,
  NSCustomSelectorPredicateOperatorType,
  NSContainsPredicateOperatorType = 99,
  NSBetweenPredicateOperatorType,
}

interface NSCompoundPredicateAllocator<InitializedType = NSCompoundPredicate> extends NSPredicateAllocator<NSCompoundPredicate> {
  initWithType_subpredicates(type: NSCompoundPredicateType, subpredicates: NSArray<any> | any[]): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
}
interface NSCompoundPredicate extends NSPredicate {

  compoundPredicateType(): NSCompoundPredicateType;
  subpredicates(): NSArray<any>;
}
declare const NSCompoundPredicate: {
  alloc(): NSCompoundPredicateAllocator;
}

declare enum NSCompoundPredicateType {
  NSNotPredicateType = 0,
  NSAndPredicateType,
  NSOrPredicateType,
}

interface NSConnectionAllocator<InitializedType = NSConnection> extends NSObjectAllocator<NSConnection> {
  initWithReceivePort_sendPort(receivePort: NSPort | null, sendPort: NSPort | null): InitializedType;
}
interface NSConnection extends NSObject {
  invalidate(): void;
  addRequestMode(rmode: NSString | string): void;
  removeRequestMode(rmode: NSString | string): void;
  registerName(name: NSString | string | null): boolean;
  registerName_withNameServer(name: NSString | string | null, server: NSPortNameServer): boolean;
  enableMultipleThreads(): void;
  addRunLoop(runloop: NSRunLoop): void;
  removeRunLoop(runloop: NSRunLoop): void;
  runInNewThread(): void;
  dispatchWithComponents(components: NSArray<any> | any[]): void;

  statistics(): NSDictionary<any, any>;
  requestTimeout(): NSTimeInterval;
  setRequestTimeout(requestTimeout: NSTimeInterval): void;
  replyTimeout(): NSTimeInterval;
  setReplyTimeout(replyTimeout: NSTimeInterval): void;
  rootObject(): any;
  setRootObject(rootObject: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  independentConversationQueueing(): boolean;
  setIndependentConversationQueueing(independentConversationQueueing: boolean): void;
  valid(): boolean;
  rootProxy(): NSDistantObject;
  requestModes(): NSArray<any>;
  sendPort(): NSPort;
  receivePort(): NSPort;
  multipleThreadsEnabled(): boolean;
  remoteObjects(): NSArray<any>;
  localObjects(): NSArray<any>;
}
declare const NSConnection: {
  alloc(): NSConnectionAllocator;  allConnections(): NSArray<any>;
  defaultConnection(): NSConnection;
  connectionWithRegisteredName_host(name: NSString | string, hostName: NSString | string | null): NSConnection;
  connectionWithRegisteredName_host_usingNameServer(name: NSString | string, hostName: NSString | string | null, server: NSPortNameServer): NSConnection;
  rootProxyForConnectionWithRegisteredName_host(name: NSString | string, hostName: NSString | string | null): NSDistantObject;
  rootProxyForConnectionWithRegisteredName_host_usingNameServer(name: NSString | string, hostName: NSString | string | null, server: NSPortNameServer): NSDistantObject;
  serviceConnectionWithName_rootObject_usingNameServer(name: NSString | string, root: any, server: NSPortNameServer): NSConnection;
  serviceConnectionWithName_rootObject(name: NSString | string, root: any): NSConnection;
  connectionWithReceivePort_sendPort(receivePort: NSPort | null, sendPort: NSPort | null): NSConnection;
  currentConversation(): any;

}

interface NSDistantObjectRequestAllocator<InitializedType = NSDistantObjectRequest> extends NSObjectAllocator<NSDistantObjectRequest> {}
interface NSDistantObjectRequest extends NSObject {
  replyWithException(exception: NSException | Error | null): void;

  invocation(): NSInvocation;
  connection(): NSConnection;
  conversation(): any;
}
declare const NSDistantObjectRequest: {
  alloc(): NSDistantObjectRequestAllocator;
}

interface INSConnectionDelegate {
  makeNewConnection_sender(conn: NSConnection, ancestor: NSConnection): boolean;
  connection_shouldMakeNewConnection(ancestor: NSConnection, conn: NSConnection): boolean;
  authenticationDataForComponents(components: NSArray<any> | any[]): NSData;
  authenticateComponents_withData(components: NSArray<any> | any[], signature: NSData): boolean;
  createConversationForConnection(conn: NSConnection): any;
  connection_handleRequest(connection: NSConnection, doreq: NSDistantObjectRequest): boolean;
}

interface NSDataAllocator<InitializedType = NSData> extends NSObjectAllocator<NSData> {
  initWithBytes_length(bytes: void | null, length: NSUInteger): InitializedType;
  initWithBytesNoCopy_length(bytes: void, length: NSUInteger): InitializedType;
  initWithBytesNoCopy_length_freeWhenDone(bytes: void, length: NSUInteger, b: boolean): InitializedType;
  initWithBytesNoCopy_length_deallocator(bytes: void, length: NSUInteger, deallocator: Block | null): InitializedType;
  initWithContentsOfFile_options_error(path: NSString | string, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): InitializedType;
  initWithContentsOfURL_options_error(url: NSURL, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): InitializedType;
  initWithContentsOfFile(path: NSString | string): InitializedType;
  initWithContentsOfURL(url: NSURL): InitializedType;
  initWithData(data: NSData): InitializedType;
  initWithBase64EncodedString_options(base64String: NSString | string, options: NSDataBase64DecodingOptions): InitializedType;
  initWithBase64EncodedData_options(base64Data: NSData, options: NSDataBase64DecodingOptions): InitializedType;
  initWithContentsOfMappedFile(path: NSString | string): InitializedType;
  initWithBase64Encoding(base64String: NSString | string): InitializedType;
}
interface NSData extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding {
  getBytes_length(buffer: void, length: NSUInteger): void;
  getBytes_range(buffer: void, range: NSRange): void;
  isEqualToData(other: NSData): boolean;
  subdataWithRange(range: NSRange): NSData;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  writeToFile_options_error(path: NSString | string, writeOptionsMask: NSDataWritingOptions, errorPtr: NSError): boolean;
  writeToURL_options_error(url: NSURL, writeOptionsMask: NSDataWritingOptions, errorPtr: NSError): boolean;
  rangeOfData_options_range(dataToFind: NSData, mask: NSDataSearchOptions, searchRange: NSRange): NSRange;
  enumerateByteRangesUsingBlock(block: Block): void;
  base64EncodedStringWithOptions(options: NSDataBase64EncodingOptions): NSString;
  base64EncodedDataWithOptions(options: NSDataBase64EncodingOptions): NSData;
  getBytes(buffer: void): void;
  base64Encoding(): NSString;
  sha1(): NSData;
  sha1AsString(): NSString;
  dataByCompressingWithAlgorithm_bc(algorithm: compression_algorithm): NSData;
  dataByDecompressing_bc(): NSData;
  hexString(): NSString;
  base64Encoding_xcd(): NSString;

  length(): NSUInteger;
  bytes(): void;
  description(): NSString;
}
declare const NSData: {
  alloc(): NSDataAllocator;  data(): NSData;
  dataWithBytes_length(bytes: void | null, length: NSUInteger): NSData;
  dataWithBytesNoCopy_length(bytes: void, length: NSUInteger): NSData;
  dataWithBytesNoCopy_length_freeWhenDone(bytes: void, length: NSUInteger, b: boolean): NSData;
  dataWithContentsOfFile_options_error(path: NSString | string, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): NSData;
  dataWithContentsOfURL_options_error(url: NSURL, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): NSData;
  dataWithContentsOfFile(path: NSString | string): NSData;
  dataWithContentsOfURL(url: NSURL): NSData;
  dataWithData(data: NSData): NSData;
  dataWithContentsOfMappedFile(path: NSString | string): any;
  dataWithBase64Encoding_xcd(base64String: NSString | string): any;

}

interface NSMutableDataAllocator<InitializedType = NSMutableData> extends NSDataAllocator<NSMutableData> {
  initWithCapacity(capacity: NSUInteger): InitializedType;
  initWithLength(length: NSUInteger): InitializedType;
}
interface NSMutableData extends NSData {
  appendBytes_length(bytes: void, length: NSUInteger): void;
  appendData(other: NSData): void;
  increaseLengthBy(extraLength: NSUInteger): void;
  replaceBytesInRange_withBytes(range: NSRange, bytes: void): void;
  resetBytesInRange(range: NSRange): void;
  setData(data: NSData): void;
  replaceBytesInRange_withBytes_length(range: NSRange, replacementBytes: void | null, replacementLength: NSUInteger): void;

  mutableBytes(): void;
  length(): NSUInteger;
  setLength(length: NSUInteger): void;
}
declare const NSMutableData: {
  alloc(): NSMutableDataAllocator;  dataWithCapacity(aNumItems: NSUInteger): NSMutableData;
  dataWithLength(length: NSUInteger): NSMutableData;

}

interface NSPurgeableDataAllocator<InitializedType = NSPurgeableData> extends NSMutableDataAllocator<NSPurgeableData> {}
interface NSPurgeableData extends NSMutableData, INSDiscardableContent {
}
declare const NSPurgeableData: {
  alloc(): NSPurgeableDataAllocator;
}

declare enum NSDataReadingOptions {
  NSDataReadingMappedIfSafe = 1 << 0,
  NSDataReadingUncached = 1 << 1,
  NSDataReadingMappedAlways = 1 << 3,
  NSDataReadingMapped,
  NSMappedRead,
  NSUncachedRead,
}

declare enum NSDataWritingOptions {
  NSDataWritingAtomic = 1 << 0,
  NSDataWritingWithoutOverwriting = 1 << 1,
  NSDataWritingFileProtectionNone = 0x10000000,
  NSDataWritingFileProtectionComplete = 0x20000000,
  NSDataWritingFileProtectionCompleteUnlessOpen = 0x30000000,
  NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication = 0x40000000,
  NSDataWritingFileProtectionMask = 0xf0000000,
  NSAtomicWrite,
}

declare enum NSDataSearchOptions {
  NSDataSearchBackwards = 1 << 0,
  NSDataSearchAnchored = 1 << 1,
}

declare enum NSDataBase64EncodingOptions {
  NSDataBase64Encoding64CharacterLineLength = 1 << 0,
  NSDataBase64Encoding76CharacterLineLength = 1 << 1,
  NSDataBase64EncodingEndLineWithCarriageReturn = 1 << 4,
  NSDataBase64EncodingEndLineWithLineFeed = 1 << 5,
}

declare enum NSDataBase64DecodingOptions {
  NSDataBase64DecodingIgnoreUnknownCharacters = 1 << 0,
}

declare type NSTimeInterval = number

interface NSDateComponentsFormatterAllocator<InitializedType = NSDateComponentsFormatter> extends NSFormatterAllocator<NSDateComponentsFormatter> {}
interface NSDateComponentsFormatter extends NSFormatter {
  stringForObjectValue(obj: any | null): NSString;
  stringFromDateComponents(components: NSDateComponents): NSString;
  stringFromDate_toDate(startDate: NSDate, endDate: NSDate): NSString;
  stringFromTimeInterval(ti: NSTimeInterval): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  unitsStyle(): NSDateComponentsFormatterUnitsStyle;
  setUnitsStyle(unitsStyle: NSDateComponentsFormatterUnitsStyle): void;
  allowedUnits(): NSCalendarUnit;
  setAllowedUnits(allowedUnits: NSCalendarUnit): void;
  zeroFormattingBehavior(): NSDateComponentsFormatterZeroFormattingBehavior;
  setZeroFormattingBehavior(zeroFormattingBehavior: NSDateComponentsFormatterZeroFormattingBehavior): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  referenceDate(): NSDate;
  setReferenceDate(referenceDate: NSDate): void;
  allowsFractionalUnits(): boolean;
  setAllowsFractionalUnits(allowsFractionalUnits: boolean): void;
  maximumUnitCount(): NSInteger;
  setMaximumUnitCount(maximumUnitCount: NSInteger): void;
  collapsesLargestUnit(): boolean;
  setCollapsesLargestUnit(collapsesLargestUnit: boolean): void;
  includesApproximationPhrase(): boolean;
  setIncludesApproximationPhrase(includesApproximationPhrase: boolean): void;
  includesTimeRemainingPhrase(): boolean;
  setIncludesTimeRemainingPhrase(includesTimeRemainingPhrase: boolean): void;
  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
}
declare const NSDateComponentsFormatter: {
  alloc(): NSDateComponentsFormatterAllocator;  localizedStringFromDateComponents_unitsStyle(components: NSDateComponents, unitsStyle: NSDateComponentsFormatterUnitsStyle): NSString;

}

declare enum NSDateComponentsFormatterUnitsStyle {
  NSDateComponentsFormatterUnitsStylePositional = 0,
  NSDateComponentsFormatterUnitsStyleAbbreviated,
  NSDateComponentsFormatterUnitsStyleShort,
  NSDateComponentsFormatterUnitsStyleFull,
  NSDateComponentsFormatterUnitsStyleSpellOut,
  NSDateComponentsFormatterUnitsStyleBrief,
}

declare enum NSDateComponentsFormatterZeroFormattingBehavior {
  NSDateComponentsFormatterZeroFormattingBehaviorNone,
  NSDateComponentsFormatterZeroFormattingBehaviorDefault,
  NSDateComponentsFormatterZeroFormattingBehaviorDropLeading,
  NSDateComponentsFormatterZeroFormattingBehaviorDropMiddle,
  NSDateComponentsFormatterZeroFormattingBehaviorDropTrailing,
  NSDateComponentsFormatterZeroFormattingBehaviorDropAll,
  NSDateComponentsFormatterZeroFormattingBehaviorPad,
}

interface NSDateFormatterAllocator<InitializedType = NSDateFormatter> extends NSFormatterAllocator<NSDateFormatter> {}
interface NSDateFormatter extends NSFormatter {
  getObjectValue_forString_range_error(obj: any, string: NSString | string, rangep: NSRange, error: NSError): boolean;
  stringFromDate(date: NSDate): NSString;
  dateFromString(string: NSString | string): NSDate;
  setLocalizedDateFormatFromTemplate(dateFormatTemplate: NSString | string): void;

  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
  dateFormat(): NSString;
  setDateFormat(dateFormat: NSString | string): void;
  dateStyle(): NSDateFormatterStyle;
  setDateStyle(dateStyle: NSDateFormatterStyle): void;
  timeStyle(): NSDateFormatterStyle;
  setTimeStyle(timeStyle: NSDateFormatterStyle): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  generatesCalendarDates(): boolean;
  setGeneratesCalendarDates(generatesCalendarDates: boolean): void;
  formatterBehavior(): NSDateFormatterBehavior;
  setFormatterBehavior(formatterBehavior: NSDateFormatterBehavior): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  lenient(): boolean;
  setLenient(lenient: boolean): void;
  twoDigitStartDate(): NSDate;
  setTwoDigitStartDate(twoDigitStartDate: NSDate): void;
  defaultDate(): NSDate;
  setDefaultDate(defaultDate: NSDate): void;
  eraSymbols(): NSArray<any>;
  setEraSymbols(eraSymbols: NSArray<any> | any[]): void;
  monthSymbols(): NSArray<any>;
  setMonthSymbols(monthSymbols: NSArray<any> | any[]): void;
  shortMonthSymbols(): NSArray<any>;
  setShortMonthSymbols(shortMonthSymbols: NSArray<any> | any[]): void;
  weekdaySymbols(): NSArray<any>;
  setWeekdaySymbols(weekdaySymbols: NSArray<any> | any[]): void;
  shortWeekdaySymbols(): NSArray<any>;
  setShortWeekdaySymbols(shortWeekdaySymbols: NSArray<any> | any[]): void;
  AMSymbol(): NSString;
  setAMSymbol(AMSymbol: NSString | string): void;
  PMSymbol(): NSString;
  setPMSymbol(PMSymbol: NSString | string): void;
  longEraSymbols(): NSArray<any>;
  setLongEraSymbols(longEraSymbols: NSArray<any> | any[]): void;
  veryShortMonthSymbols(): NSArray<any>;
  setVeryShortMonthSymbols(veryShortMonthSymbols: NSArray<any> | any[]): void;
  standaloneMonthSymbols(): NSArray<any>;
  setStandaloneMonthSymbols(standaloneMonthSymbols: NSArray<any> | any[]): void;
  shortStandaloneMonthSymbols(): NSArray<any>;
  setShortStandaloneMonthSymbols(shortStandaloneMonthSymbols: NSArray<any> | any[]): void;
  veryShortStandaloneMonthSymbols(): NSArray<any>;
  setVeryShortStandaloneMonthSymbols(veryShortStandaloneMonthSymbols: NSArray<any> | any[]): void;
  veryShortWeekdaySymbols(): NSArray<any>;
  setVeryShortWeekdaySymbols(veryShortWeekdaySymbols: NSArray<any> | any[]): void;
  standaloneWeekdaySymbols(): NSArray<any>;
  setStandaloneWeekdaySymbols(standaloneWeekdaySymbols: NSArray<any> | any[]): void;
  shortStandaloneWeekdaySymbols(): NSArray<any>;
  setShortStandaloneWeekdaySymbols(shortStandaloneWeekdaySymbols: NSArray<any> | any[]): void;
  veryShortStandaloneWeekdaySymbols(): NSArray<any>;
  setVeryShortStandaloneWeekdaySymbols(veryShortStandaloneWeekdaySymbols: NSArray<any> | any[]): void;
  quarterSymbols(): NSArray<any>;
  setQuarterSymbols(quarterSymbols: NSArray<any> | any[]): void;
  shortQuarterSymbols(): NSArray<any>;
  setShortQuarterSymbols(shortQuarterSymbols: NSArray<any> | any[]): void;
  standaloneQuarterSymbols(): NSArray<any>;
  setStandaloneQuarterSymbols(standaloneQuarterSymbols: NSArray<any> | any[]): void;
  shortStandaloneQuarterSymbols(): NSArray<any>;
  setShortStandaloneQuarterSymbols(shortStandaloneQuarterSymbols: NSArray<any> | any[]): void;
  gregorianStartDate(): NSDate;
  setGregorianStartDate(gregorianStartDate: NSDate): void;
  doesRelativeDateFormatting(): boolean;
  setDoesRelativeDateFormatting(doesRelativeDateFormatting: boolean): void;
}
declare const NSDateFormatter: {
  alloc(): NSDateFormatterAllocator;  localizedStringFromDate_dateStyle_timeStyle(date: NSDate, dstyle: NSDateFormatterStyle, tstyle: NSDateFormatterStyle): NSString;
  dateFormatFromTemplate_options_locale(tmplate: NSString | string, opts: NSUInteger, locale: NSLocale | null): NSString;

  defaultFormatterBehavior(): NSDateFormatterBehavior;
  setDefaultFormatterBehavior(defaultFormatterBehavior: NSDateFormatterBehavior): void;

}

declare enum NSDateFormatterStyle {
  NSDateFormatterNoStyle = 0,
  NSDateFormatterShortStyle = 1,
  NSDateFormatterMediumStyle = 2,
  NSDateFormatterLongStyle = 3,
  NSDateFormatterFullStyle = 4,
}

declare enum NSDateFormatterBehavior {
  NSDateFormatterBehaviorDefault = 0,
  NSDateFormatterBehavior10_0 = 1000,
}

interface NSDateIntervalAllocator<InitializedType = NSDateInterval> extends NSObjectAllocator<NSDateInterval> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithStartDate_duration(startDate: NSDate, duration: NSTimeInterval): InitializedType;
  initWithStartDate_endDate(startDate: NSDate, endDate: NSDate): InitializedType;
}
interface NSDateInterval extends NSObject, INSCopying, INSSecureCoding {
  compare(dateInterval: NSDateInterval): NSComparisonResult;
  isEqualToDateInterval(dateInterval: NSDateInterval): boolean;
  intersectsDateInterval(dateInterval: NSDateInterval): boolean;
  intersectionWithDateInterval(dateInterval: NSDateInterval): NSDateInterval;
  containsDate(date: NSDate): boolean;

  startDate(): NSDate;
  endDate(): NSDate;
  duration(): NSTimeInterval;
}
declare const NSDateInterval: {
  alloc(): NSDateIntervalAllocator;
}

interface NSDateIntervalFormatterAllocator<InitializedType = NSDateIntervalFormatter> extends NSFormatterAllocator<NSDateIntervalFormatter> {}
interface NSDateIntervalFormatter extends NSFormatter {
  stringFromDate_toDate(fromDate: NSDate, toDate: NSDate): NSString;
  stringFromDateInterval(dateInterval: NSDateInterval): NSString;

  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  dateTemplate(): NSString;
  setDateTemplate(dateTemplate: NSString | string): void;
  dateStyle(): NSDateIntervalFormatterStyle;
  setDateStyle(dateStyle: NSDateIntervalFormatterStyle): void;
  timeStyle(): NSDateIntervalFormatterStyle;
  setTimeStyle(timeStyle: NSDateIntervalFormatterStyle): void;
}
declare const NSDateIntervalFormatter: {
  alloc(): NSDateIntervalFormatterAllocator;
}

declare enum NSDateIntervalFormatterStyle {
  NSDateIntervalFormatterNoStyle = 0,
  NSDateIntervalFormatterShortStyle = 1,
  NSDateIntervalFormatterMediumStyle = 2,
  NSDateIntervalFormatterLongStyle = 3,
  NSDateIntervalFormatterFullStyle = 4,
}

declare type NSDecimal = any

declare enum NSRoundingMode {
  NSRoundPlain,
  NSRoundDown,
  NSRoundUp,
  NSRoundBankers,
}

declare enum NSCalculationError {
  NSCalculationNoError = 0,
  NSCalculationLossOfPrecision,
  NSCalculationUnderflow,
  NSCalculationOverflow,
  NSCalculationDivideByZero,
}

interface NSDecimalNumberAllocator<InitializedType = NSDecimalNumber> extends NSNumberAllocator<NSDecimalNumber> {
  initWithMantissa_exponent_isNegative(mantissa: number, exponent: number, flag: boolean): InitializedType;
  initWithDecimal(dcm: NSDecimal): InitializedType;
  initWithString(numberValue: NSString | string | null): InitializedType;
  initWithString_locale(numberValue: NSString | string | null, locale: any | null): InitializedType;
}
interface NSDecimalNumber extends NSNumber {
  descriptionWithLocale(locale: any | null): NSString;
  decimalNumberByAdding(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberByAdding_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberBySubtracting(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberBySubtracting_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberByMultiplyingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberByMultiplyingBy_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberByDividingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberByDividingBy_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberByRaisingToPower(power: NSUInteger): NSDecimalNumber;
  decimalNumberByRaisingToPower_withBehavior(power: NSUInteger, behavior: any | null): NSDecimalNumber;
  decimalNumberByMultiplyingByPowerOf10(power: number): NSDecimalNumber;
  decimalNumberByMultiplyingByPowerOf10_withBehavior(power: number, behavior: any | null): NSDecimalNumber;
  decimalNumberByRoundingAccordingToBehavior(behavior: any | null): NSDecimalNumber;
  compare(decimalNumber: NSNumber | number): NSComparisonResult;

  decimalValue(): NSDecimal;
  objCType(): string;
  doubleValue(): number;
}
declare const NSDecimalNumber: {
  alloc(): NSDecimalNumberAllocator;  decimalNumberWithMantissa_exponent_isNegative(mantissa: number, exponent: number, flag: boolean): NSDecimalNumber;
  decimalNumberWithDecimal(dcm: NSDecimal): NSDecimalNumber;
  decimalNumberWithString(numberValue: NSString | string | null): NSDecimalNumber;
  decimalNumberWithString_locale(numberValue: NSString | string | null, locale: any | null): NSDecimalNumber;

  zero(): NSDecimalNumber;
  one(): NSDecimalNumber;
  minimumDecimalNumber(): NSDecimalNumber;
  maximumDecimalNumber(): NSDecimalNumber;
  notANumber(): NSDecimalNumber;
  defaultBehavior(): any;
  setDefaultBehavior(defaultBehavior: any): void;

}

interface NSDecimalNumberHandlerAllocator<InitializedType = NSDecimalNumberHandler> extends NSObjectAllocator<NSDecimalNumberHandler> {
  initWithRoundingMode_scale_raiseOnExactness_raiseOnOverflow_raiseOnUnderflow_raiseOnDivideByZero(roundingMode: NSRoundingMode, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSDecimalNumberHandler extends NSObject, INSDecimalNumberBehaviors, INSCoding {
}
declare const NSDecimalNumberHandler: {
  alloc(): NSDecimalNumberHandlerAllocator;  decimalNumberHandlerWithRoundingMode_scale_raiseOnExactness_raiseOnOverflow_raiseOnUnderflow_raiseOnDivideByZero(roundingMode: NSRoundingMode, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): NSDecimalNumberHandler;

  defaultDecimalNumberHandler(): NSDecimalNumberHandler;

}

interface NSNumberAllocator<InitializedType = NSNumber> extends NSValueAllocator<NSNumber> {
  initWithChar(value: string): InitializedType;
  initWithUnsignedChar(value: string): InitializedType;
  initWithShort(value: number): InitializedType;
  initWithUnsignedShort(value: number): InitializedType;
  initWithInt(value: number): InitializedType;
  initWithUnsignedInt(value: number): InitializedType;
  initWithLong(value: number): InitializedType;
  initWithUnsignedLong(value: number): InitializedType;
  initWithLongLong(value: number): InitializedType;
  initWithUnsignedLongLong(value: number): InitializedType;
  initWithFloat(value: number): InitializedType;
  initWithDouble(value: number): InitializedType;
  initWithBool(value: boolean): InitializedType;
  initWithInteger(value: NSInteger): InitializedType;
  initWithUnsignedInteger(value: NSUInteger): InitializedType;
}
interface NSNumber extends NSValue {
  compare(otherNumber: NSNumber | number): NSComparisonResult;
  isEqualToNumber(number: NSNumber | number): boolean;
  descriptionWithLocale(locale: any | null): NSString;

  decimalValue(): NSDecimal;
  charValue(): string;
  unsignedCharValue(): string;
  shortValue(): number;
  unsignedShortValue(): number;
  intValue(): number;
  unsignedIntValue(): number;
  longValue(): number;
  unsignedLongValue(): number;
  longLongValue(): number;
  unsignedLongLongValue(): number;
  floatValue(): number;
  doubleValue(): number;
  boolValue(): boolean;
  integerValue(): NSInteger;
  unsignedIntegerValue(): NSUInteger;
  stringValue(): NSString;
}
declare const NSNumber: {
  alloc(): NSNumberAllocator;  numberWithChar(value: string): NSNumber;
  numberWithUnsignedChar(value: string): NSNumber;
  numberWithShort(value: number): NSNumber;
  numberWithUnsignedShort(value: number): NSNumber;
  numberWithInt(value: number): NSNumber;
  numberWithUnsignedInt(value: number): NSNumber;
  numberWithLong(value: number): NSNumber;
  numberWithUnsignedLong(value: number): NSNumber;
  numberWithLongLong(value: number): NSNumber;
  numberWithUnsignedLongLong(value: number): NSNumber;
  numberWithFloat(value: number): NSNumber;
  numberWithDouble(value: number): NSNumber;
  numberWithBool(value: boolean): NSNumber;
  numberWithInteger(value: NSInteger): NSNumber;
  numberWithUnsignedInteger(value: NSUInteger): NSNumber;

}

interface NSScannerAllocator<InitializedType = NSScanner> extends NSObjectAllocator<NSScanner> {
  initWithString(string: NSString | string): InitializedType;
}
interface NSScanner extends NSObject, INSCopying {
  scanDecimal(dcm: NSDecimal | null): boolean;
  scanInt(result: number | null): boolean;
  scanInteger(result: NSInteger | null): boolean;
  scanLongLong(result: number | null): boolean;
  scanUnsignedLongLong(result: number | null): boolean;
  scanFloat(result: number | null): boolean;
  scanDouble(result: number | null): boolean;
  scanHexInt(result: number | null): boolean;
  scanHexLongLong(result: number | null): boolean;
  scanHexFloat(result: number | null): boolean;
  scanHexDouble(result: number | null): boolean;
  scanString_intoString(string: NSString | string, result: NSString | string): boolean;
  scanCharactersFromSet_intoString(set: NSCharacterSet, result: NSString | string): boolean;
  scanUpToString_intoString(string: NSString | string, result: NSString | string): boolean;
  scanUpToCharactersFromSet_intoString(set: NSCharacterSet, result: NSString | string): boolean;

  string(): NSString;
  scanLocation(): NSUInteger;
  setScanLocation(scanLocation: NSUInteger): void;
  charactersToBeSkipped(): NSCharacterSet;
  setCharactersToBeSkipped(charactersToBeSkipped: NSCharacterSet): void;
  caseSensitive(): boolean;
  setCaseSensitive(caseSensitive: boolean): void;
  locale(): any;
  setLocale(locale: any): void;
  atEnd(): boolean;
}
declare const NSScanner: {
  alloc(): NSScannerAllocator;  scannerWithString(string: NSString | string): NSScanner;
  localizedScannerWithString(string: NSString | string): any;

}

interface INSDecimalNumberBehaviors {
  roundingMode(): NSRoundingMode;
  scale(): number;
  exceptionDuringOperation_error_leftOperand_rightOperand(operation: string, error: NSCalculationError, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;
}

interface NSDictionaryAllocator<KeyType, ObjectType, InitializedType = NSDictionary<KeyType, ObjectType>> extends NSObjectAllocator<NSDictionary<KeyType, ObjectType>> {
  init(): InitializedType;
  initWithObjects_forKeys_count(objects: ObjectType[], keys: KeyType[], cnt: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithContentsOfFile(path: NSString | string): InitializedType;
  initWithContentsOfURL(url: NSURL): InitializedType;
  initWithObjectsAndKeys(firstObject: any, ...args: any[]): InitializedType;
  initWithDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithDictionary_copyItems(otherDictionary: NSDictionary<any, any> | {[key: string]: any}, flag: boolean): InitializedType;
  initWithObjects_forKeys(objects: NSArray<any> | any[], keys: NSArray<any> | any[]): InitializedType;
  initWithContentsOfURL_error(url: NSURL, error: NSError): InitializedType;
}
interface NSDictionary<KeyType, ObjectType> extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {

  [key: string]: ObjectType | Function;
  objectForKey(aKey: KeyType): ObjectType;
  keyEnumerator(): NSEnumerator<any>;
  allKeysForObject(anObject: ObjectType): NSArray<any>;
  descriptionWithLocale(locale: any | null): NSString;
  descriptionWithLocale_indent(locale: any | null, level: NSUInteger): NSString;
  isEqualToDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): boolean;
  objectEnumerator(): NSEnumerator<any>;
  objectsForKeys_notFoundMarker(keys: NSArray<any> | any[], marker: ObjectType): NSArray<any>;
  writeToURL_error(url: NSURL, error: NSError): boolean;
  keysSortedByValueUsingSelector(comparator: string): NSArray<any>;
  getObjects_andKeys_count(objects: ObjectType[], keys: KeyType[], count: NSUInteger): void;
  objectForKeyedSubscript(key: KeyType): ObjectType;
  enumerateKeysAndObjectsUsingBlock(block: Block): void;
  enumerateKeysAndObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  keysSortedByValueUsingComparator(cmptr: NSComparator): NSArray<any>;
  keysSortedByValueWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): NSArray<any>;
  keysOfEntriesPassingTest(predicate: Block): NSSet<any>;
  keysOfEntriesWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSSet<any>;
  getObjects_andKeys(objects: ObjectType[], keys: KeyType[]): void;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  fileSize(): number;
  fileModificationDate(): NSDate;
  fileType(): NSString;
  filePosixPermissions(): NSUInteger;
  fileOwnerAccountName(): NSString;
  fileGroupOwnerAccountName(): NSString;
  fileSystemNumber(): NSInteger;
  fileSystemFileNumber(): NSUInteger;
  fileExtensionHidden(): boolean;
  fileHFSCreatorCode(): OSType;
  fileHFSTypeCode(): OSType;
  fileIsImmutable(): boolean;
  fileIsAppendOnly(): boolean;
  fileCreationDate(): NSDate;
  fileOwnerAccountID(): NSNumber;
  fileGroupOwnerAccountID(): NSNumber;
  valueForKey(key: NSString | string): ObjectType;
  stringForKey_bc(aKey: any): NSString;
  arrayForKey_bc(aKey: any): NSArray<any>;
  dictionaryForKey_bc(aKey: any): NSDictionary<any, any>;
  numberForKey_bc(aKey: any): NSNumber;
  boolForKey_bc(aKey: any): boolean;
  urlForKey_bc(key: any): NSURL;
  dictionaryByAddingOrRemovingObject_forKey(object: any, key: any): NSDictionary<KeyType, ObjectType>;
  mutableCopyDeep(): any;
  dictionaryByAddingDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  filter(block: BCDictionaryFilterBlock): NSDictionary<any, any>;
  dictionaryByReplacing_usingBlock(key: any, block: Block): NSDictionary<any, any>;
  dictionaryByMappingKeys_bc(map: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  dictionaryByReverseMappingKeys_bc(map: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  mo_objectForKeyedSubscript(key: any): any;
  valueForKey_intoBool(key: NSString | string, valueOut: boolean): any;
  valueForKey_intoDouble(key: NSString | string, valueOut: number): any;
  pointForKey(key: NSString | string): CGPoint;
  sizeForKey(key: NSString | string): CGSize;
  rectForKey(key: NSString | string): CGRect;
  dictionaryWithoutKey(key: NSString | string): NSDictionary<any, any>;
  objectForKey_ofType(aKey: any, type: any): any;
  dateForKey(key: NSString | string): NSDate;
  urlForKey(key: NSString | string): NSURL;
  uuidForKey(key: NSString | string): NSUUID;
  boolForKey(key: NSString | string): boolean;
  cloudObjectForKey_ofType_parentObject(key: NSString | string, type: any, parent: SCKObject | null): SCKObject;
  cloudObjectArrayForKey_ofType_parentObject(key: NSString | string, type: any, parent: SCKObject | null): NSArray<any>;
  sizeForWidthKey_heightKey(widthKey: any, heightKey: any): CGSize;
  pointForXKey_yKey(xKey: any, yKey: any): CGPoint;
  rectForXKey_yKey_widthKey_heightKey(xKey: any, yKey: any, widthKey: any, heightKey: any): CGRect;
  prepareStringAttributesForEncoding(): NSDictionary<any, any>;
  prepareStringAttributesAfterDecoding(): NSDictionary<any, any>;
  dictionaryByMappingFontToFontDescriptors(): NSDictionary<any, any>;
  dictionaryByMappingFontDescriptorsToFont(): NSDictionary<any, any>;
  dictionaryByRefreshingFontDescriptors(): NSDictionary<any, any>;
  dictionaryByMappingComponentsDictionaryToMSImmutableColor(): NSDictionary<any, any>;
  dictionaryByConvertingNSColorsToMSImmutableColorsInColorSpace(colorSpace: NSColorSpace): NSDictionary<any, any>;
  dictionaryByConvertingMSImmutableColorsToNSColorsInColorSpace(colorSpace: NSColorSpace): NSDictionary<any, any>;
  dictionaryByTranslatingNSColorsToMSImmutableColorsInColorSpace(colorSpace: NSColorSpace): NSDictionary<any, any>;

  count(): NSUInteger;
  allKeys(): NSArray<any>;
  allValues(): NSArray<any>;
  description(): NSString;
  descriptionInStringsFileFormat(): NSString;
}
declare const NSDictionary: {
  alloc<KeyType, ObjectType>(): NSDictionaryAllocator<KeyType, ObjectType>;  dictionaryWithContentsOfFile(path: NSString | string): NSDictionary<any, any>;
  dictionaryWithContentsOfURL(url: NSURL): NSDictionary<any, any>;
  dictionary<KeyType, ObjectType>(): NSDictionary<KeyType, ObjectType>;
  dictionaryWithObject_forKey<KeyType, ObjectType>(object: ObjectType, key: KeyType): NSDictionary<KeyType, ObjectType>;
  dictionaryWithObjects_forKeys_count<KeyType, ObjectType>(objects: ObjectType[], keys: KeyType[], cnt: NSUInteger): NSDictionary<KeyType, ObjectType>;
  dictionaryWithObjectsAndKeys<KeyType, ObjectType>(firstObject: any, ...args: any[]): NSDictionary<KeyType, ObjectType>;
  dictionaryWithDictionary<KeyType, ObjectType>(dict: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<KeyType, ObjectType>;
  dictionaryWithObjects_forKeys<KeyType, ObjectType>(objects: NSArray<any> | any[], keys: NSArray<any> | any[]): NSDictionary<KeyType, ObjectType>;
  dictionaryWithContentsOfURL_error(url: NSURL, error: NSError): NSDictionary<any, any>;
  sharedKeySetForKeys(keys: NSArray<any> | any[]): any;

}

interface NSMutableDictionaryAllocator<KeyType, ObjectType, InitializedType = NSMutableDictionary<KeyType, ObjectType>> extends NSDictionaryAllocator<KeyType, ObjectType, NSMutableDictionary<KeyType, ObjectType>> {
  initWithCapacity(numItems: NSUInteger): InitializedType;
}
interface NSMutableDictionary<KeyType, ObjectType> extends NSDictionary<KeyType, ObjectType> {
  removeObjectForKey(aKey: KeyType): void;
  setObject_forKey(anObject: ObjectType, aKey: KeyType): void;
  addEntriesFromDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  removeAllObjects(): void;
  removeObjectsForKeys(keyArray: NSArray<any> | any[]): void;
  setDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  setObject_forKeyedSubscript(obj: ObjectType | null, key: KeyType): void;
  setValue_forKey(value: ObjectType | null, key: NSString | string): void;
  objectForKey_orBySettingMissingObject(aKey: NSString | string, anObject: any): any;
  addObject_forKey(anObject: any, aKey: any): void;
  mo_setObject_forKeyedSubscript(obj: any, key: any): void;
  setPoint_forKey(point: CGPoint, key: NSString | string): void;
  setSize_forKey(size: CGSize, key: NSString | string): void;
  setRect_forKey(rect: CGRect, key: NSString | string): void;
  mergeEntriesFromDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  setDate_forKey(date: NSDate | null, key: NSString | string): void;

  visible(): boolean;
  setVisible(visible: boolean): void;
  locked(): boolean;
  setLocked(locked: boolean): void;
  selected(): boolean;
  setSelected(selected: boolean): void;
  hovered(): boolean;
  setHovered(hovered: boolean): void;
  isFlow(): boolean;
  setIsFlow(isFlow: boolean): void;
  isSlice(): boolean;
  setIsSlice(isSlice: boolean): void;
  exportFileName(): NSString;
}
declare const NSMutableDictionary: {
  alloc<KeyType, ObjectType>(): NSMutableDictionaryAllocator<KeyType, ObjectType>;  dictionaryWithCapacity<KeyType, ObjectType>(numItems: NSUInteger): NSMutableDictionary<KeyType, ObjectType>;
  dictionaryWithContentsOfFile(path: NSString | string): NSMutableDictionary<any, any>;
  dictionaryWithContentsOfURL(url: NSURL): NSMutableDictionary<any, any>;
  dictionaryWithSharedKeySet(keyset: any): NSMutableDictionary<any, any>;

}

interface NSDistantObjectAllocator<InitializedType = NSDistantObject> extends NSProxyAllocator<NSDistantObject> {
  initWithTarget_connection(target: any, connection: NSConnection): InitializedType;
  initWithLocal_connection(target: any, connection: NSConnection): InitializedType;
  initWithCoder(inCoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSDistantObject extends NSProxy, INSCoding {
  setProtocolForProxy(proto: Protocol | null): void;

  connectionForProxy(): NSConnection;
}
declare const NSDistantObject: {
  alloc(): NSDistantObjectAllocator;  proxyWithTarget_connection(target: any, connection: NSConnection): any;
  proxyWithLocal_connection(target: any, connection: NSConnection): any;

}

interface NSDistributedLockAllocator<InitializedType = NSDistributedLock> extends NSObjectAllocator<NSDistributedLock> {
  initWithPath(path: NSString | string): InitializedType;
}
interface NSDistributedLock extends NSObject {
  tryLock(): boolean;
  unlock(): void;
  breakLock(): void;

  lockDate(): NSDate;
}
declare const NSDistributedLock: {
  alloc(): NSDistributedLockAllocator;  lockWithPath(path: NSString | string): NSDistributedLock;

}

interface NSDistributedNotificationCenterAllocator<InitializedType = NSDistributedNotificationCenter> extends NSNotificationCenterAllocator<NSDistributedNotificationCenter> {}
interface NSDistributedNotificationCenter extends NSNotificationCenter {
  addObserver_selector_name_object_suspensionBehavior(observer: any, selector: string, name: NSNotificationName | null, object: NSString | string | null, suspensionBehavior: NSNotificationSuspensionBehavior): void;
  postNotificationName_object_userInfo_deliverImmediately(name: NSNotificationName, object: NSString | string | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null, deliverImmediately: boolean): void;
  postNotificationName_object_userInfo_options(name: NSNotificationName, object: NSString | string | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null, options: NSDistributedNotificationOptions): void;
  addObserver_selector_name_object(observer: any, aSelector: string, aName: NSNotificationName | null, anObject: NSString | string | null): void;
  postNotificationName_object(aName: NSNotificationName, anObject: NSString | string | null): void;
  postNotificationName_object_userInfo(aName: NSNotificationName, anObject: NSString | string | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): void;
  removeObserver_name_object(observer: any, aName: NSNotificationName | null, anObject: NSString | string | null): void;

  suspended(): boolean;
  setSuspended(suspended: boolean): void;
}
declare const NSDistributedNotificationCenter: {
  alloc(): NSDistributedNotificationCenterAllocator;  notificationCenterForType(notificationCenterType: NSDistributedNotificationCenterType): NSDistributedNotificationCenter;
  defaultCenter(): NSDistributedNotificationCenter;

}

declare type NSDistributedNotificationCenterType = NSString

declare enum NSNotificationSuspensionBehavior {
  NSNotificationSuspensionBehaviorDrop = 1,
  NSNotificationSuspensionBehaviorCoalesce = 2,
  NSNotificationSuspensionBehaviorHold = 3,
  NSNotificationSuspensionBehaviorDeliverImmediately = 4,
}

declare enum NSDistributedNotificationOptions {
  NSDistributedNotificationDeliverImmediately,
  NSDistributedNotificationPostToAllSessions,
}

interface NSEnergyFormatterAllocator<InitializedType = NSEnergyFormatter> extends NSFormatterAllocator<NSEnergyFormatter> {}
interface NSEnergyFormatter extends NSFormatter {
  stringFromValue_unit(value: number, unit: NSEnergyFormatterUnit): NSString;
  stringFromJoules(numberInJoules: number): NSString;
  unitStringFromValue_unit(value: number, unit: NSEnergyFormatterUnit): NSString;
  unitStringFromJoules_usedUnit(numberInJoules: number, unitp: NSEnergyFormatterUnit | null): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  forFoodEnergyUse(): boolean;
  setForFoodEnergyUse(forFoodEnergyUse: boolean): void;
}
declare const NSEnergyFormatter: {
  alloc(): NSEnergyFormatterAllocator;
}

declare enum NSEnergyFormatterUnit {
  NSEnergyFormatterUnitJoule = 11,
  NSEnergyFormatterUnitKilojoule = 14,
  NSEnergyFormatterUnitCalorie,
  NSEnergyFormatterUnitKilocalorie,
}

interface NSEnumeratorAllocator<ObjectType, InitializedType = NSEnumerator<ObjectType>> extends NSObjectAllocator<NSEnumerator<ObjectType>> {}
interface NSEnumerator<ObjectType> extends NSObject, INSFastEnumeration {
  nextObject(): ObjectType;

  allObjects(): NSArray<any>;
}
declare const NSEnumerator: {
  alloc<ObjectType>(): NSEnumeratorAllocator<ObjectType>;
}

interface INSFastEnumeration {
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
}

declare type NSFastEnumerationState = {
  state: number
  itemsPtr: any
  mutationsPtr: number
  extra: [number, number, number, number, number]
}

interface NSErrorAllocator<InitializedType = NSError> extends NSObjectAllocator<NSError> {
  initWithDomain_code_userInfo(domain: NSErrorDomain, code: NSInteger, dict: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface NSError extends NSObject, INSCopying, INSSecureCoding {

  domain(): NSErrorDomain;
  code(): NSInteger;
  userInfo(): NSDictionary<any, any>;
  localizedDescription(): NSString;
  localizedFailureReason(): NSString;
  localizedRecoverySuggestion(): NSString;
  localizedRecoveryOptions(): NSArray<any>;
  recoveryAttempter(): any;
  helpAnchor(): NSString;
  isCloudError(): boolean;
  isCloudUnauthorized(): boolean;
  isCloudForbidden(): boolean;
  isUrlCancelled(): boolean;
}
declare const NSError: {
  alloc(): NSErrorAllocator;  errorWithDomain_code_userInfo(domain: NSErrorDomain, code: NSInteger, dict: NSDictionary<any, any> | {[key: string]: any} | null): NSError;
  setUserInfoValueProviderForDomain_provider(errorDomain: NSErrorDomain, provider: Block): void;
  errorFromAPIResponse_data(response: NSURLResponse | null, data: NSData | null): NSError;

}

declare type NSErrorDomain = NSString

declare type NSErrorUserInfoKey = NSString

interface NSExceptionAllocator<InitializedType = NSException> extends NSObjectAllocator<NSException> {
  initWithName_reason_userInfo(aName: NSExceptionName, aReason: NSString | string | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSException extends NSObject, INSCopying, INSCoding {
  raise(): void;

  name(): NSExceptionName;
  reason(): NSString;
  userInfo(): NSDictionary<any, any>;
  callStackReturnAddresses(): NSArray<any>;
  callStackSymbols(): NSArray<any>;
}
declare const NSException: {
  alloc(): NSExceptionAllocator;  exceptionWithName_reason_userInfo(name: NSExceptionName, reason: NSString | string | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null): NSException;
  raise_format(name: NSExceptionName, format: NSString | string, ...args: any[]): void;
  raise_format_arguments(name: NSExceptionName, format: NSString | string, ...argList: any[]): void;

}

interface NSAssertionHandlerAllocator<InitializedType = NSAssertionHandler> extends NSObjectAllocator<NSAssertionHandler> {}
interface NSAssertionHandler extends NSObject {
  handleFailureInMethod_object_file_lineNumber_description(selector: string, object: any, fileName: NSString | string, line: NSInteger, format: NSString | string | null, ...args: any[]): void;
  handleFailureInFunction_file_lineNumber_description(functionName: NSString | string, fileName: NSString | string, line: NSInteger, format: NSString | string | null, ...args: any[]): void;
}
declare const NSAssertionHandler: {
  alloc(): NSAssertionHandlerAllocator;
  currentHandler(): NSAssertionHandler;

}

interface NSExpressionAllocator<InitializedType = NSExpression> extends NSObjectAllocator<NSExpression> {
  initWithExpressionType(type: NSExpressionType): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
}
interface NSExpression extends NSObject, INSSecureCoding, INSCopying {
  expressionValueWithObject_context(object: any | null, context: NSMutableDictionary<any, any> | {[key: string]: any} | null): any;
  allowEvaluation(): void;

  expressionType(): NSExpressionType;
  constantValue(): any;
  keyPath(): NSString;
  function(): NSString;
  variable(): NSString;
  operand(): NSExpression;
  arguments(): NSArray<any>;
  collection(): any;
  predicate(): NSPredicate;
  leftExpression(): NSExpression;
  rightExpression(): NSExpression;
  trueExpression(): NSExpression;
  falseExpression(): NSExpression;
}
declare const NSExpression: {
  alloc(): NSExpressionAllocator;  expressionWithFormat_argumentArray(expressionFormat: NSString | string, arguments: NSArray<any> | any[]): NSExpression;
  expressionWithFormat(expressionFormat: NSString | string, ...args: any[]): NSExpression;
  expressionWithFormat_arguments(expressionFormat: NSString | string, ...argList: any[]): NSExpression;
  expressionForConstantValue(obj: any | null): NSExpression;
  expressionForEvaluatedObject(): NSExpression;
  expressionForVariable(string: NSString | string): NSExpression;
  expressionForKeyPath(keyPath: NSString | string): NSExpression;
  expressionForFunction_arguments(name: NSString | string, parameters: NSArray<any> | any[]): NSExpression;
  expressionForAggregate(subexpressions: NSArray<any> | any[]): NSExpression;
  expressionForUnionSet_with(left: NSExpression, right: NSExpression): NSExpression;
  expressionForIntersectSet_with(left: NSExpression, right: NSExpression): NSExpression;
  expressionForMinusSet_with(left: NSExpression, right: NSExpression): NSExpression;
  expressionForSubquery_usingIteratorVariable_predicate(expression: NSExpression, variable: NSString | string, predicate: NSPredicate): NSExpression;
  expressionForFunction_selectorName_arguments(target: NSExpression, name: NSString | string, parameters: NSArray<any> | any[] | null): NSExpression;
  expressionForAnyKey(): NSExpression;
  expressionForBlock_arguments(block: Block, arguments: NSArray<any> | any[] | null): NSExpression;
  expressionForConditional_trueExpression_falseExpression(predicate: NSPredicate, trueExpression: NSExpression, falseExpression: NSExpression): NSExpression;

}

declare enum NSExpressionType {
  NSConstantValueExpressionType = 0,
  NSEvaluatedObjectExpressionType,
  NSVariableExpressionType,
  NSKeyPathExpressionType,
  NSFunctionExpressionType,
  NSUnionSetExpressionType,
  NSIntersectSetExpressionType,
  NSMinusSetExpressionType,
  NSSubqueryExpressionType = 13,
  NSAggregateExpressionType = 14,
  NSAnyKeyExpressionType = 15,
  NSBlockExpressionType = 19,
  NSConditionalExpressionType = 20,
}

interface NSExtensionContextAllocator<InitializedType = NSExtensionContext> extends NSObjectAllocator<NSExtensionContext> {}
interface NSExtensionContext extends NSObject {
  completeRequestReturningItems_completionHandler(items: NSArray<any> | any[] | null, completionHandler: Block): void;
  cancelRequestWithError(error: NSError): void;
  openURL_completionHandler(URL: NSURL, completionHandler: Block): void;

  inputItems(): NSArray<any>;
}
declare const NSExtensionContext: {
  alloc(): NSExtensionContextAllocator;
}

interface NSExtensionItemAllocator<InitializedType = NSExtensionItem> extends NSObjectAllocator<NSExtensionItem> {}
interface NSExtensionItem extends NSObject, INSCopying, INSSecureCoding {

  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  attributedContentText(): NSAttributedString;
  setAttributedContentText(attributedContentText: NSAttributedString): void;
  attachments(): NSArray<any>;
  setAttachments(attachments: NSArray<any> | any[]): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const NSExtensionItem: {
  alloc(): NSExtensionItemAllocator;
}

interface INSExtensionRequestHandling {
  beginRequestWithExtensionContext(context: NSExtensionContext): void;
}

interface NSFileAccessIntentAllocator<InitializedType = NSFileAccessIntent> extends NSObjectAllocator<NSFileAccessIntent> {}
interface NSFileAccessIntent extends NSObject {

  URL(): NSURL;
}
declare const NSFileAccessIntent: {
  alloc(): NSFileAccessIntentAllocator;  readingIntentWithURL_options(url: NSURL, options: NSFileCoordinatorReadingOptions): NSFileAccessIntent;
  writingIntentWithURL_options(url: NSURL, options: NSFileCoordinatorWritingOptions): NSFileAccessIntent;

}

interface NSFileCoordinatorAllocator<InitializedType = NSFileCoordinator> extends NSObjectAllocator<NSFileCoordinator> {
  initWithFilePresenter(filePresenterOrNil: any | null): InitializedType;
}
interface NSFileCoordinator extends NSObject {
  coordinateAccessWithIntents_queue_byAccessor(intents: NSArray<any> | any[], queue: NSOperationQueue, accessor: Block): void;
  coordinateReadingItemAtURL_options_error_byAccessor(url: NSURL, options: NSFileCoordinatorReadingOptions, outError: NSError, reader: Block): void;
  coordinateWritingItemAtURL_options_error_byAccessor(url: NSURL, options: NSFileCoordinatorWritingOptions, outError: NSError, writer: Block): void;
  coordinateReadingItemAtURL_options_writingItemAtURL_options_error_byAccessor(readingURL: NSURL, readingOptions: NSFileCoordinatorReadingOptions, writingURL: NSURL, writingOptions: NSFileCoordinatorWritingOptions, outError: NSError, readerWriter: Block): void;
  coordinateWritingItemAtURL_options_writingItemAtURL_options_error_byAccessor(url1: NSURL, options1: NSFileCoordinatorWritingOptions, url2: NSURL, options2: NSFileCoordinatorWritingOptions, outError: NSError, writer: Block): void;
  prepareForReadingItemsAtURLs_options_writingItemsAtURLs_options_error_byAccessor(readingURLs: NSArray<any> | any[], readingOptions: NSFileCoordinatorReadingOptions, writingURLs: NSArray<any> | any[], writingOptions: NSFileCoordinatorWritingOptions, outError: NSError, batchAccessor: Block): void;
  itemAtURL_willMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  itemAtURL_didMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  itemAtURL_didChangeUbiquityAttributes(url: NSURL, attributes: NSSet<any>): void;
  cancel(): void;

  purposeIdentifier(): NSString;
  setPurposeIdentifier(purposeIdentifier: NSString | string): void;
}
declare const NSFileCoordinator: {
  alloc(): NSFileCoordinatorAllocator;  addFilePresenter(filePresenter: any): void;
  removeFilePresenter(filePresenter: any): void;

  filePresenters(): NSArray<any>;

}

declare enum NSFileCoordinatorReadingOptions {
  NSFileCoordinatorReadingWithoutChanges = 1 << 0,
  NSFileCoordinatorReadingResolvesSymbolicLink = 1 << 1,
  NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly = 1 << 2,
  NSFileCoordinatorReadingForUploading = 1 << 3,
}

declare enum NSFileCoordinatorWritingOptions {
  NSFileCoordinatorWritingForDeleting = 1 << 0,
  NSFileCoordinatorWritingForMoving = 1 << 1,
  NSFileCoordinatorWritingForMerging = 1 << 2,
  NSFileCoordinatorWritingForReplacing = 1 << 3,
  NSFileCoordinatorWritingContentIndependentMetadataOnly = 1 << 4,
}

interface NSFileHandleAllocator<InitializedType = NSFileHandle> extends NSObjectAllocator<NSFileHandle> {
  initWithFileDescriptor_closeOnDealloc(fd: number, closeopt: boolean): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithFileDescriptor(fd: number): InitializedType;
}
interface NSFileHandle extends NSObject, INSSecureCoding {
  readDataToEndOfFile(): NSData;
  readDataOfLength(length: NSUInteger): NSData;
  writeData(data: NSData): void;
  seekToEndOfFile(): number;
  seekToFileOffset(offset: number): void;
  truncateFileAtOffset(offset: number): void;
  synchronizeFile(): void;
  closeFile(): void;
  readInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  readInBackgroundAndNotify(): void;
  readToEndOfFileInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  readToEndOfFileInBackgroundAndNotify(): void;
  acceptConnectionInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  acceptConnectionInBackgroundAndNotify(): void;
  waitForDataInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  waitForDataInBackgroundAndNotify(): void;

  availableData(): NSData;
  offsetInFile(): number;
  fileDescriptor(): number;
}
declare const NSFileHandle: {
  alloc(): NSFileHandleAllocator;  fileHandleForReadingAtPath(path: NSString | string): NSFileHandle;
  fileHandleForWritingAtPath(path: NSString | string): NSFileHandle;
  fileHandleForUpdatingAtPath(path: NSString | string): NSFileHandle;
  fileHandleForReadingFromURL_error(url: NSURL, error: NSError): NSFileHandle;
  fileHandleForWritingToURL_error(url: NSURL, error: NSError): NSFileHandle;
  fileHandleForUpdatingURL_error(url: NSURL, error: NSError): NSFileHandle;

  fileHandleWithStandardInput(): NSFileHandle;
  fileHandleWithStandardOutput(): NSFileHandle;
  fileHandleWithStandardError(): NSFileHandle;
  fileHandleWithNullDevice(): NSFileHandle;

}

interface NSPipeAllocator<InitializedType = NSPipe> extends NSObjectAllocator<NSPipe> {}
interface NSPipe extends NSObject {

  fileHandleForReading(): NSFileHandle;
  fileHandleForWriting(): NSFileHandle;
}
declare const NSPipe: {
  alloc(): NSPipeAllocator;  pipe(): NSPipe;

}

interface NSFileManagerAllocator<InitializedType = NSFileManager> extends NSObjectAllocator<NSFileManager> {}
interface NSFileManager extends NSObject {
  mountedVolumeURLsIncludingResourceValuesForKeys_options(propertyKeys: NSArray<any> | any[] | null, options: NSVolumeEnumerationOptions): NSArray<any>;
  unmountVolumeAtURL_options_completionHandler(url: NSURL, mask: NSFileManagerUnmountOptions, completionHandler: Block): void;
  contentsOfDirectoryAtURL_includingPropertiesForKeys_options_error(url: NSURL, keys: NSArray<any> | any[] | null, mask: NSDirectoryEnumerationOptions, error: NSError): NSArray<any>;
  URLsForDirectory_inDomains(directory: NSSearchPathDirectory, domainMask: NSSearchPathDomainMask): NSArray<any>;
  URLForDirectory_inDomain_appropriateForURL_create_error(directory: NSSearchPathDirectory, domain: NSSearchPathDomainMask, url: NSURL | null, shouldCreate: boolean, error: NSError): NSURL;
  getRelationship_ofDirectoryAtURL_toItemAtURL_error(outRelationship: NSURLRelationship, directoryURL: NSURL, otherURL: NSURL, error: NSError): boolean;
  getRelationship_ofDirectory_inDomain_toItemAtURL_error(outRelationship: NSURLRelationship, directory: NSSearchPathDirectory, domainMask: NSSearchPathDomainMask, url: NSURL, error: NSError): boolean;
  createDirectoryAtURL_withIntermediateDirectories_attributes_error(url: NSURL, createIntermediates: boolean, attributes: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): boolean;
  createSymbolicLinkAtURL_withDestinationURL_error(url: NSURL, destURL: NSURL, error: NSError): boolean;
  setAttributes_ofItemAtPath_error(attributes: NSDictionary<any, any> | {[key: string]: any}, path: NSString | string, error: NSError): boolean;
  createDirectoryAtPath_withIntermediateDirectories_attributes_error(path: NSString | string, createIntermediates: boolean, attributes: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): boolean;
  contentsOfDirectoryAtPath_error(path: NSString | string, error: NSError): NSArray<any>;
  subpathsOfDirectoryAtPath_error(path: NSString | string, error: NSError): NSArray<any>;
  attributesOfItemAtPath_error(path: NSString | string, error: NSError): NSDictionary<any, any>;
  attributesOfFileSystemForPath_error(path: NSString | string, error: NSError): NSDictionary<any, any>;
  createSymbolicLinkAtPath_withDestinationPath_error(path: NSString | string, destPath: NSString | string, error: NSError): boolean;
  destinationOfSymbolicLinkAtPath_error(path: NSString | string, error: NSError): NSString;
  copyItemAtPath_toPath_error(srcPath: NSString | string, dstPath: NSString | string, error: NSError): boolean;
  moveItemAtPath_toPath_error(srcPath: NSString | string, dstPath: NSString | string, error: NSError): boolean;
  linkItemAtPath_toPath_error(srcPath: NSString | string, dstPath: NSString | string, error: NSError): boolean;
  removeItemAtPath_error(path: NSString | string, error: NSError): boolean;
  copyItemAtURL_toURL_error(srcURL: NSURL, dstURL: NSURL, error: NSError): boolean;
  moveItemAtURL_toURL_error(srcURL: NSURL, dstURL: NSURL, error: NSError): boolean;
  linkItemAtURL_toURL_error(srcURL: NSURL, dstURL: NSURL, error: NSError): boolean;
  removeItemAtURL_error(URL: NSURL, error: NSError): boolean;
  trashItemAtURL_resultingItemURL_error(url: NSURL, outResultingURL: NSURL, error: NSError): boolean;
  fileAttributesAtPath_traverseLink(path: NSString | string, yorn: boolean): NSDictionary<any, any>;
  changeFileAttributes_atPath(attributes: NSDictionary<any, any> | {[key: string]: any}, path: NSString | string): boolean;
  directoryContentsAtPath(path: NSString | string): NSArray<any>;
  fileSystemAttributesAtPath(path: NSString | string): NSDictionary<any, any>;
  pathContentOfSymbolicLinkAtPath(path: NSString | string): NSString;
  createSymbolicLinkAtPath_pathContent(path: NSString | string, otherpath: NSString | string): boolean;
  createDirectoryAtPath_attributes(path: NSString | string, attributes: NSDictionary<any, any> | {[key: string]: any}): boolean;
  linkPath_toPath_handler(src: NSString | string, dest: NSString | string, handler: any | null): boolean;
  copyPath_toPath_handler(src: NSString | string, dest: NSString | string, handler: any | null): boolean;
  movePath_toPath_handler(src: NSString | string, dest: NSString | string, handler: any | null): boolean;
  removeFileAtPath_handler(path: NSString | string, handler: any | null): boolean;
  changeCurrentDirectoryPath(path: NSString | string): boolean;
  fileExistsAtPath(path: NSString | string): boolean;
  fileExistsAtPath_isDirectory(path: NSString | string, isDirectory: boolean | null): boolean;
  isReadableFileAtPath(path: NSString | string): boolean;
  isWritableFileAtPath(path: NSString | string): boolean;
  isExecutableFileAtPath(path: NSString | string): boolean;
  isDeletableFileAtPath(path: NSString | string): boolean;
  contentsEqualAtPath_andPath(path1: NSString | string, path2: NSString | string): boolean;
  displayNameAtPath(path: NSString | string): NSString;
  componentsToDisplayForPath(path: NSString | string): NSArray<any>;
  enumeratorAtPath(path: NSString | string): NSDirectoryEnumerator<any>;
  enumeratorAtURL_includingPropertiesForKeys_options_errorHandler(url: NSURL, keys: NSArray<any> | any[] | null, mask: NSDirectoryEnumerationOptions, handler: Block | null): NSDirectoryEnumerator<any>;
  subpathsAtPath(path: NSString | string): NSArray<any>;
  contentsAtPath(path: NSString | string): NSData;
  createFileAtPath_contents_attributes(path: NSString | string, data: NSData | null, attr: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  fileSystemRepresentationWithPath(path: NSString | string): string;
  stringWithFileSystemRepresentation_length(str: string, len: NSUInteger): NSString;
  replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(originalItemURL: NSURL, newItemURL: NSURL, backupItemName: NSString | string | null, options: NSFileManagerItemReplacementOptions, resultingURL: NSURL, error: NSError): boolean;
  setUbiquitous_itemAtURL_destinationURL_error(flag: boolean, url: NSURL, destinationURL: NSURL, error: NSError): boolean;
  isUbiquitousItemAtURL(url: NSURL): boolean;
  startDownloadingUbiquitousItemAtURL_error(url: NSURL, error: NSError): boolean;
  evictUbiquitousItemAtURL_error(url: NSURL, error: NSError): boolean;
  URLForUbiquityContainerIdentifier(containerIdentifier: NSString | string | null): NSURL;
  URLForPublishingUbiquitousItemAtURL_expirationDate_error(url: NSURL, outDate: NSDate, error: NSError): NSURL;
  getFileProviderServicesForItemAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  containerURLForSecurityApplicationGroupIdentifier(groupIdentifier: NSString | string): NSURL;
  homeDirectoryForUser(userName: NSString | string): NSURL;
  visibleSubpathsOfDirectory(path: NSString | string): NSArray<any>;
  createDirectoryIfNecessary(directory: NSString | string): boolean;
  fileExistsAtURL(url: NSURL): boolean;
  shallowSubpathsOfDirectoryAtURL(url: NSURL): NSArray<any>;
  shallowSubpathURLsOfDirectoryAtURL(url: NSURL): NSArray<any>;
  shallowFilenamesOfDirectoryAtURL_withURLResourceValues_forURLResourceKey(url: NSURL, urlResourceValues: NSSet<any>, resourceKey: NSURLResourceKey): NSArray<any>;
  isFolderAtPath(path: NSString | string): boolean;
  isFolderAtURL(url: NSURL): boolean;
  uniqueURL(url: NSURL): NSURL;
  temporaryFolderURL(): NSURL;
  temporaryFolderURLWithName(name: NSString | string): NSURL;
  temporaryFileURLWithName_extension(name: NSString | string, extension: NSString | string): NSURL;
  temporaryFileURLToReplaceURL(url: NSURL): NSURL;
  temporaryFileURLWithExtension(extension: NSString | string): NSURL;
  _temporaryFilesRootForURL(url: NSURL): NSURL;
  visibleSubpathsOfDirectoryWithoutGoingIntoPackages(path: NSString | string): NSArray<any>;
  visibleSubpathsOfDirectoryAtURLWithoutGoingIntoPackages(url: NSURL): NSArray<any>;

  delegate(): any;
  setDelegate(delegate: any): void;
  currentDirectoryPath(): NSString;
  ubiquityIdentityToken(): any;
  homeDirectoryForCurrentUser(): NSURL;
  temporaryDirectory(): NSURL;
}
declare const NSFileManager: {
  alloc(): NSFileManagerAllocator;  _setTemporaryFilesRootToURL(rootURL: NSURL): void;

  defaultManager(): NSFileManager;

}

interface NSDirectoryEnumeratorAllocator<ObjectType, InitializedType = NSDirectoryEnumerator<ObjectType>> extends NSEnumeratorAllocator<ObjectType, NSDirectoryEnumerator<ObjectType>> {}
interface NSDirectoryEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
  skipDescendents(): void;
  skipDescendants(): void;

  fileAttributes(): NSDictionary<any, any>;
  directoryAttributes(): NSDictionary<any, any>;
  level(): NSUInteger;
}
declare const NSDirectoryEnumerator: {
  alloc<ObjectType>(): NSDirectoryEnumeratorAllocator<ObjectType>;
}

interface NSFileProviderServiceAllocator<InitializedType = NSFileProviderService> extends NSObjectAllocator<NSFileProviderService> {}
interface NSFileProviderService extends NSObject {
  getFileProviderConnectionWithCompletionHandler(completionHandler: Block): void;

  name(): NSFileProviderServiceName;
}
declare const NSFileProviderService: {
  alloc(): NSFileProviderServiceAllocator;
}

interface INSFileManagerDelegate {
  fileManager_shouldCopyItemAtPath_toPath(fileManager: NSFileManager, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldCopyItemAtURL_toURL(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldProceedAfterError_copyingItemAtPath_toPath(fileManager: NSFileManager, error: NSError, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldProceedAfterError_copyingItemAtURL_toURL(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldMoveItemAtPath_toPath(fileManager: NSFileManager, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldMoveItemAtURL_toURL(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldProceedAfterError_movingItemAtPath_toPath(fileManager: NSFileManager, error: NSError, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldProceedAfterError_movingItemAtURL_toURL(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldLinkItemAtPath_toPath(fileManager: NSFileManager, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldLinkItemAtURL_toURL(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldProceedAfterError_linkingItemAtPath_toPath(fileManager: NSFileManager, error: NSError, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldProceedAfterError_linkingItemAtURL_toURL(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldRemoveItemAtPath(fileManager: NSFileManager, path: NSString | string): boolean;
  fileManager_shouldRemoveItemAtURL(fileManager: NSFileManager, URL: NSURL): boolean;
  fileManager_shouldProceedAfterError_removingItemAtPath(fileManager: NSFileManager, error: NSError, path: NSString | string): boolean;
  fileManager_shouldProceedAfterError_removingItemAtURL(fileManager: NSFileManager, error: NSError, URL: NSURL): boolean;
}

declare type NSFileAttributeKey = NSString

declare type NSFileAttributeType = NSString

declare type NSFileProtectionType = NSString

declare type NSFileProviderServiceName = NSString

declare enum NSVolumeEnumerationOptions {
  NSVolumeEnumerationSkipHiddenVolumes = 1 << 1,
  NSVolumeEnumerationProduceFileReferenceURLs = 1 << 2,
}

declare enum NSDirectoryEnumerationOptions {
  NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1 << 0,
  NSDirectoryEnumerationSkipsPackageDescendants = 1 << 1,
  NSDirectoryEnumerationSkipsHiddenFiles = 1 << 2,
}

declare enum NSFileManagerItemReplacementOptions {
  NSFileManagerItemReplacementUsingNewMetadataOnly = 1 << 0,
  NSFileManagerItemReplacementWithoutDeletingBackupItem = 1 << 1,
}

declare enum NSURLRelationship {
  NSURLRelationshipContains,
  NSURLRelationshipSame,
  NSURLRelationshipOther,
}

declare enum NSFileManagerUnmountOptions {
  NSFileManagerUnmountAllPartitionsAndEjectDisk = 1 << 0,
  NSFileManagerUnmountWithoutUI = 1 << 1,
}

interface INSFilePresenter extends NSObject {
  relinquishPresentedItemToReader(reader: Block): void;
  relinquishPresentedItemToWriter(writer: Block): void;
  savePresentedItemChangesWithCompletionHandler(completionHandler: Block): void;
  accommodatePresentedItemDeletionWithCompletionHandler(completionHandler: Block): void;
  presentedItemDidMoveToURL(newURL: NSURL): void;
  presentedItemDidChange(): void;
  presentedItemDidChangeUbiquityAttributes(attributes: NSSet<any>): void;
  presentedItemDidGainVersion(version: NSFileVersion): void;
  presentedItemDidLoseVersion(version: NSFileVersion): void;
  presentedItemDidResolveConflictVersion(version: NSFileVersion): void;
  accommodatePresentedSubitemDeletionAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  presentedSubitemDidAppearAtURL(url: NSURL): void;
  presentedSubitemAtURL_didMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  presentedSubitemDidChangeAtURL(url: NSURL): void;
  presentedSubitemAtURL_didGainVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didLoseVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didResolveConflictVersion(url: NSURL, version: NSFileVersion): void;

  presentedItemURL(): NSURL;
  presentedItemOperationQueue(): NSOperationQueue;
  primaryPresentedItemURL(): NSURL;
  observedPresentedItemUbiquityAttributes(): NSSet<any>;
}

interface NSFileVersionAllocator<InitializedType = NSFileVersion> extends NSObjectAllocator<NSFileVersion> {}
interface NSFileVersion extends NSObject {
  replaceItemAtURL_options_error(url: NSURL, options: NSFileVersionReplacingOptions, error: NSError): NSURL;
  removeAndReturnError(outError: NSError): boolean;

  URL(): NSURL;
  localizedName(): NSString;
  localizedNameOfSavingComputer(): NSString;
  originatorNameComponents(): NSPersonNameComponents;
  modificationDate(): NSDate;
  persistentIdentifier(): any;
  conflict(): boolean;
  resolved(): boolean;
  setResolved(resolved: boolean): void;
  discardable(): boolean;
  setDiscardable(discardable: boolean): void;
  hasLocalContents(): boolean;
  hasThumbnail(): boolean;
}
declare const NSFileVersion: {
  alloc(): NSFileVersionAllocator;  currentVersionOfItemAtURL(url: NSURL): NSFileVersion;
  otherVersionsOfItemAtURL(url: NSURL): NSArray<any>;
  unresolvedConflictVersionsOfItemAtURL(url: NSURL): NSArray<any>;
  getNonlocalVersionsOfItemAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  versionOfItemAtURL_forPersistentIdentifier(url: NSURL, persistentIdentifier: any): NSFileVersion;
  addVersionOfItemAtURL_withContentsOfURL_options_error(url: NSURL, contentsURL: NSURL, options: NSFileVersionAddingOptions, outError: NSError): NSFileVersion;
  temporaryDirectoryURLForNewVersionOfItemAtURL(url: NSURL): NSURL;
  removeOtherVersionsOfItemAtURL_error(url: NSURL, outError: NSError): boolean;

}

declare enum NSFileVersionAddingOptions {
  NSFileVersionAddingByMoving = 1 << 0,
}

declare enum NSFileVersionReplacingOptions {
  NSFileVersionReplacingByMoving = 1 << 0,
}

interface NSFileWrapperAllocator<InitializedType = NSFileWrapper> extends NSObjectAllocator<NSFileWrapper> {
  initWithURL_options_error(url: NSURL, options: NSFileWrapperReadingOptions, outError: NSError): InitializedType;
  initDirectoryWithFileWrappers(childrenByPreferredName: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initRegularFileWithContents(contents: NSData): InitializedType;
  initSymbolicLinkWithDestinationURL(url: NSURL): InitializedType;
  initWithSerializedRepresentation(serializeRepresentation: NSData): InitializedType;
  initWithCoder(inCoder: NSCoder): InitializedType;
  initWithPath(path: NSString | string): InitializedType;
  initSymbolicLinkWithDestination(path: NSString | string): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSFileWrapper extends NSObject, INSCoding {
  matchesContentsOfURL(url: NSURL): boolean;
  readFromURL_options_error(url: NSURL, options: NSFileWrapperReadingOptions, outError: NSError): boolean;
  writeToURL_options_originalContentsURL_error(url: NSURL, options: NSFileWrapperWritingOptions, originalContentsURL: NSURL | null, outError: NSError): boolean;
  addFileWrapper(child: NSFileWrapper): NSString;
  addRegularFileWithContents_preferredFilename(data: NSData, fileName: NSString | string): NSString;
  removeFileWrapper(child: NSFileWrapper): void;
  keyForFileWrapper(child: NSFileWrapper): NSString;
  needsToBeUpdatedFromPath(path: NSString | string): boolean;
  updateFromPath(path: NSString | string): boolean;
  writeToFile_atomically_updateFilenames(path: NSString | string, atomicFlag: boolean, updateFilenamesFlag: boolean): boolean;
  addFileWithPath(path: NSString | string): NSString;
  addSymbolicLinkWithDestination_preferredFilename(path: NSString | string, filename: NSString | string): NSString;
  symbolicLinkDestination(): NSString;

  directory(): boolean;
  regularFile(): boolean;
  symbolicLink(): boolean;
  preferredFilename(): NSString;
  setPreferredFilename(preferredFilename: NSString | string): void;
  filename(): NSString;
  setFilename(filename: NSString | string): void;
  fileAttributes(): NSDictionary<any, any>;
  setFileAttributes(fileAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  serializedRepresentation(): NSData;
  fileWrappers(): NSDictionary<any, any>;
  regularFileContents(): NSData;
  symbolicLinkDestinationURL(): NSURL;
  icon(): NSImage;
  setIcon(icon: NSImage): void;
}
declare const NSFileWrapper: {
  alloc(): NSFileWrapperAllocator;
}

declare enum NSFileWrapperReadingOptions {
  NSFileWrapperReadingImmediate = 1 << 0,
  NSFileWrapperReadingWithoutMapping = 1 << 1,
}

declare enum NSFileWrapperWritingOptions {
  NSFileWrapperWritingAtomic = 1 << 0,
  NSFileWrapperWritingWithNameUpdating = 1 << 1,
}

interface NSFormatterAllocator<InitializedType = NSFormatter> extends NSObjectAllocator<NSFormatter> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSFormatter extends NSObject, INSCopying, INSCoding {
  stringForObjectValue(obj: any | null): NSString;
  attributedStringForObjectValue_withDefaultAttributes(obj: any, attrs: NSDictionary<any, any> | {[key: string]: any} | null): NSAttributedString;
  editingStringForObjectValue(obj: any): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;
  isPartialStringValid_newEditingString_errorDescription(partialString: NSString | string, newString: NSString | string, error: NSString | string): boolean;
  isPartialStringValid_proposedSelectedRange_originalString_originalSelectedRange_errorDescription(partialStringPtr: NSString | string, proposedSelRangePtr: NSRangePointer | null, origString: NSString | string, origSelRange: NSRange, error: NSString | string): boolean;
}
declare const NSFormatter: {
  alloc(): NSFormatterAllocator;
}

declare enum NSFormattingContext {
  NSFormattingContextUnknown = 0,
  NSFormattingContextDynamic = 1,
  NSFormattingContextStandalone = 2,
  NSFormattingContextListItem = 3,
  NSFormattingContextBeginningOfSentence = 4,
  NSFormattingContextMiddleOfSentence = 5,
}

declare enum NSFormattingUnitStyle {
  NSFormattingUnitStyleShort = 1,
  NSFormattingUnitStyleMedium,
  NSFormattingUnitStyleLong,
}

interface NSGarbageCollectorAllocator<InitializedType = NSGarbageCollector> extends NSObjectAllocator<NSGarbageCollector> {}
interface NSGarbageCollector extends NSObject {
  isCollecting(): boolean;
  disable(): void;
  enable(): void;
  isEnabled(): boolean;
  collectIfNeeded(): void;
  collectExhaustively(): void;
  disableCollectorForPointer(ptr: void): void;
  enableCollectorForPointer(ptr: void): void;
  zone(): NSZone;
}
declare const NSGarbageCollector: {
  alloc(): NSGarbageCollectorAllocator;  defaultCollector(): any;

}

declare type NSPoint = CGPoint

declare type NSSize = CGSize

declare type NSRect = CGRect

declare type NSEdgeInsets = {
  top: CGFloat
  left: CGFloat
  bottom: CGFloat
  right: CGFloat
}

declare type NSPointPointer = NSPoint

declare type NSPointArray = NSPoint

declare type NSSizePointer = NSSize

declare type NSSizeArray = NSSize

declare type NSRectPointer = NSRect

declare type NSRectArray = NSRect

declare enum NSRectEdge {
  NSRectEdgeMinX = 0,
  NSRectEdgeMinY = 1,
  NSRectEdgeMaxX = 2,
  NSRectEdgeMaxY = 3,
  NSMinXEdge,
  NSMinYEdge,
  NSMaxXEdge,
  NSMaxYEdge,
}

declare enum NSAlignmentOptions {
  NSAlignMinXInward = 1 << 0,
  NSAlignMinYInward = 1 << 1,
  NSAlignMaxXInward = 1 << 2,
  NSAlignMaxYInward = 1 << 3,
  NSAlignWidthInward = 1 << 4,
  NSAlignHeightInward = 1 << 5,
  NSAlignMinXOutward = 1 << 8,
  NSAlignMinYOutward = 1 << 9,
  NSAlignMaxXOutward = 1 << 10,
  NSAlignMaxYOutward = 1 << 11,
  NSAlignWidthOutward = 1 << 12,
  NSAlignHeightOutward = 1 << 13,
  NSAlignMinXNearest = 1 << 16,
  NSAlignMinYNearest = 1 << 17,
  NSAlignMaxXNearest = 1 << 18,
  NSAlignMaxYNearest = 1 << 19,
  NSAlignWidthNearest = 1 << 20,
  NSAlignHeightNearest = 1 << 21,
  NSAlignRectFlipped = 1 << 63,
  NSAlignAllEdgesInward,
  NSAlignAllEdgesOutward,
  NSAlignAllEdgesNearest,
}

interface NSHTTPCookieAllocator<InitializedType = NSHTTPCookie> extends NSObjectAllocator<NSHTTPCookie> {
  initWithProperties(properties: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface NSHTTPCookie extends NSObject {

  properties(): NSDictionary<any, any>;
  version(): NSUInteger;
  name(): NSString;
  value(): NSString;
  expiresDate(): NSDate;
  sessionOnly(): boolean;
  domain(): NSString;
  path(): NSString;
  secure(): boolean;
  HTTPOnly(): boolean;
  comment(): NSString;
  commentURL(): NSURL;
  portList(): NSArray<any>;
}
declare const NSHTTPCookie: {
  alloc(): NSHTTPCookieAllocator;  cookieWithProperties(properties: NSDictionary<any, any> | {[key: string]: any}): NSHTTPCookie;
  requestHeaderFieldsWithCookies(cookies: NSArray<any> | any[]): NSDictionary<any, any>;
  cookiesWithResponseHeaderFields_forURL(headerFields: NSDictionary<any, any> | {[key: string]: any}, URL: NSURL): NSArray<any>;

}

declare type NSHTTPCookiePropertyKey = NSString

interface NSHTTPCookieStorageAllocator<InitializedType = NSHTTPCookieStorage> extends NSObjectAllocator<NSHTTPCookieStorage> {}
interface NSHTTPCookieStorage extends NSObject {
  setCookie(cookie: NSHTTPCookie): void;
  deleteCookie(cookie: NSHTTPCookie): void;
  removeCookiesSinceDate(date: NSDate): void;
  cookiesForURL(URL: NSURL): NSArray<any>;
  setCookies_forURL_mainDocumentURL(cookies: NSArray<any> | any[], URL: NSURL | null, mainDocumentURL: NSURL | null): void;
  sortedCookiesUsingDescriptors(sortOrder: NSArray<any> | any[]): NSArray<any>;
  storeCookies_forTask(cookies: NSArray<any> | any[], task: NSURLSessionTask): void;
  getCookiesForTask_completionHandler(task: NSURLSessionTask, completionHandler: Block): void;

  cookies(): NSArray<any>;
  cookieAcceptPolicy(): NSHTTPCookieAcceptPolicy;
  setCookieAcceptPolicy(cookieAcceptPolicy: NSHTTPCookieAcceptPolicy): void;
}
declare const NSHTTPCookieStorage: {
  alloc(): NSHTTPCookieStorageAllocator;  sharedCookieStorageForGroupContainerIdentifier(identifier: NSString | string): NSHTTPCookieStorage;

  sharedHTTPCookieStorage(): NSHTTPCookieStorage;

}

declare enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways,
  NSHTTPCookieAcceptPolicyNever,
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
}

interface NSHashTableAllocator<ObjectType, InitializedType = NSHashTable<ObjectType>> extends NSObjectAllocator<NSHashTable<ObjectType>> {
  initWithOptions_capacity(options: NSPointerFunctionsOptions, initialCapacity: NSUInteger): InitializedType;
  initWithPointerFunctions_capacity(functions: NSPointerFunctions, initialCapacity: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSHashTable<ObjectType> extends NSObject, INSCopying, INSCoding, INSFastEnumeration {
  member(object: ObjectType | null): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  addObject(object: ObjectType | null): void;
  removeObject(object: ObjectType | null): void;
  removeAllObjects(): void;
  containsObject(anObject: ObjectType | null): boolean;
  intersectsHashTable(other: NSHashTable<any>): boolean;
  isEqualToHashTable(other: NSHashTable<any>): boolean;
  isSubsetOfHashTable(other: NSHashTable<any>): boolean;
  intersectHashTable(other: NSHashTable<any>): void;
  unionHashTable(other: NSHashTable<any>): void;
  minusHashTable(other: NSHashTable<any>): void;

  pointerFunctions(): NSPointerFunctions;
  count(): NSUInteger;
  allObjects(): NSArray<any>;
  anyObject(): ObjectType;
  setRepresentation(): NSSet<any>;
}
declare const NSHashTable: {
  alloc<ObjectType>(): NSHashTableAllocator<ObjectType>;  hashTableWithOptions(options: NSPointerFunctionsOptions): NSHashTable<any>;
  hashTableWithWeakObjects(): any;
  weakObjectsHashTable(): NSHashTable<any>;

}

declare type NSHashEnumerator = {
  _pi: NSUInteger
  _si: NSUInteger
  _bs: void
}

declare type NSHashTableCallBacks = any

declare type NSHashTableOptions = NSUInteger

interface NSHostAllocator<InitializedType = NSHost> extends NSObjectAllocator<NSHost> {}
interface NSHost extends NSObject {
  isEqualToHost(aHost: NSHost): boolean;

  name(): NSString;
  names(): NSArray<any>;
  address(): NSString;
  addresses(): NSArray<any>;
  localizedName(): NSString;
}
declare const NSHost: {
  alloc(): NSHostAllocator;  currentHost(): NSHost;
  hostWithName(name: NSString | string | null): NSHost;
  hostWithAddress(address: NSString | string): NSHost;
  setHostCacheEnabled(flag: boolean): void;
  isHostCacheEnabled(): boolean;
  flushHostCache(): void;

}

interface NSISO8601DateFormatterAllocator<InitializedType = NSISO8601DateFormatter> extends NSFormatterAllocator<NSISO8601DateFormatter> {
  init(): InitializedType;
}
interface NSISO8601DateFormatter extends NSFormatter, INSSecureCoding {
  stringFromDate(date: NSDate): NSString;
  dateFromString(string: NSString | string): NSDate;

  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  formatOptions(): NSISO8601DateFormatOptions;
  setFormatOptions(formatOptions: NSISO8601DateFormatOptions): void;
}
declare const NSISO8601DateFormatter: {
  alloc(): NSISO8601DateFormatterAllocator;  stringFromDate_timeZone_formatOptions(date: NSDate, timeZone: NSTimeZone, formatOptions: NSISO8601DateFormatOptions): NSString;

}

declare enum NSISO8601DateFormatOptions {
  NSISO8601DateFormatWithYear,
  NSISO8601DateFormatWithMonth,
  NSISO8601DateFormatWithWeekOfYear,
  NSISO8601DateFormatWithDay,
  NSISO8601DateFormatWithTime,
  NSISO8601DateFormatWithTimeZone,
  NSISO8601DateFormatWithSpaceBetweenDateAndTime,
  NSISO8601DateFormatWithDashSeparatorInDate,
  NSISO8601DateFormatWithColonSeparatorInTime,
  NSISO8601DateFormatWithColonSeparatorInTimeZone,
  NSISO8601DateFormatWithFractionalSeconds,
  NSISO8601DateFormatWithFullDate,
  NSISO8601DateFormatWithFullTime,
  NSISO8601DateFormatWithInternetDateTime,
}

interface NSIndexPathAllocator<InitializedType = NSIndexPath> extends NSObjectAllocator<NSIndexPath> {
  initWithIndexes_length(indexes: NSUInteger[], length: NSUInteger): InitializedType;
  initWithIndex(index: NSUInteger): InitializedType;
}
interface NSIndexPath extends NSObject, INSCopying, INSSecureCoding {
  indexPathByAddingIndex(index: NSUInteger): NSIndexPath;
  indexPathByRemovingLastIndex(): NSIndexPath;
  indexAtPosition(position: NSUInteger): NSUInteger;
  getIndexes_range(indexes: NSUInteger, positionRange: NSRange): void;
  compare(otherObject: NSIndexPath): NSComparisonResult;
  getIndexes(indexes: NSUInteger): void;
  indexPathWithComponent(component: MSVectorComponent): NSIndexPath;

  length(): NSUInteger;
  item(): NSInteger;
  section(): NSInteger;
  component(): MSVectorComponent;
  point(): NSUInteger;
  shape(): NSUInteger;
  handle(): MSPointType;
}
declare const NSIndexPath: {
  alloc(): NSIndexPathAllocator;  indexPathWithIndex(index: NSUInteger): NSIndexPath;
  indexPathWithIndexes_length(indexes: NSUInteger[], length: NSUInteger): NSIndexPath;
  indexPathForItem_inSection(item: NSInteger, section: NSInteger): NSIndexPath;
  indexPathForComponent_point_ofShape(component: MSVectorComponent, point: NSUInteger, shape: NSUInteger): NSIndexPath;
  indexPathForPoint_ofShape(point: NSUInteger, shape: NSUInteger): NSIndexPath;

}

interface NSIndexSetAllocator<InitializedType = NSIndexSet> extends NSObjectAllocator<NSIndexSet> {
  initWithIndexesInRange(range: NSRange): InitializedType;
  initWithIndexSet(indexSet: NSIndexSet): InitializedType;
  initWithIndex(value: NSUInteger): InitializedType;
}
interface NSIndexSet extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding {
  isEqualToIndexSet(indexSet: NSIndexSet): boolean;
  indexGreaterThanIndex(value: NSUInteger): NSUInteger;
  indexLessThanIndex(value: NSUInteger): NSUInteger;
  indexGreaterThanOrEqualToIndex(value: NSUInteger): NSUInteger;
  indexLessThanOrEqualToIndex(value: NSUInteger): NSUInteger;
  getIndexes_maxCount_inIndexRange(indexBuffer: NSUInteger, bufferSize: NSUInteger, range: NSRangePointer | null): NSUInteger;
  countOfIndexesInRange(range: NSRange): NSUInteger;
  containsIndex(value: NSUInteger): boolean;
  containsIndexesInRange(range: NSRange): boolean;
  containsIndexes(indexSet: NSIndexSet): boolean;
  intersectsIndexesInRange(range: NSRange): boolean;
  enumerateIndexesUsingBlock(block: Block): void;
  enumerateIndexesWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateIndexesInRange_options_usingBlock(range: NSRange, opts: NSEnumerationOptions, block: Block): void;
  indexPassingTest(predicate: Block): NSUInteger;
  indexWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexInRange_options_passingTest(range: NSRange, opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexesPassingTest(predicate: Block): NSIndexSet;
  indexesWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexesInRange_options_passingTest(range: NSRange, opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  enumerateRangesUsingBlock(block: Block): void;
  enumerateRangesWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateRangesInRange_options_usingBlock(range: NSRange, opts: NSEnumerationOptions, block: Block): void;

  count(): NSUInteger;
  firstIndex(): NSUInteger;
  lastIndex(): NSUInteger;
}
declare const NSIndexSet: {
  alloc(): NSIndexSetAllocator;  indexSet(): NSIndexSet;
  indexSetWithIndex(value: NSUInteger): NSIndexSet;
  indexSetWithIndexesInRange(range: NSRange): NSIndexSet;

}

interface NSMutableIndexSetAllocator<InitializedType = NSMutableIndexSet> extends NSIndexSetAllocator<NSMutableIndexSet> {}
interface NSMutableIndexSet extends NSIndexSet {
  addIndexes(indexSet: NSIndexSet): void;
  removeIndexes(indexSet: NSIndexSet): void;
  removeAllIndexes(): void;
  addIndex(value: NSUInteger): void;
  removeIndex(value: NSUInteger): void;
  addIndexesInRange(range: NSRange): void;
  removeIndexesInRange(range: NSRange): void;
  shiftIndexesStartingAtIndex_by(index: NSUInteger, delta: NSInteger): void;
}
declare const NSMutableIndexSet: {
  alloc(): NSMutableIndexSetAllocator;
}

interface NSInvocationAllocator<InitializedType = NSInvocation> extends NSObjectAllocator<NSInvocation> {}
interface NSInvocation extends NSObject {
  retainArguments(): void;
  getReturnValue(retLoc: void): void;
  setReturnValue(retLoc: void): void;
  getArgument_atIndex(argumentLocation: void, idx: NSInteger): void;
  setArgument_atIndex(argumentLocation: void, idx: NSInteger): void;
  invoke(): void;
  invokeWithTarget(target: any): void;

  methodSignature(): NSMethodSignature;
  argumentsRetained(): boolean;
  target(): any;
  setTarget(target: any): void;
  selector(): string;
  setSelector(selector: string): void;
}
declare const NSInvocation: {
  alloc(): NSInvocationAllocator;  invocationWithMethodSignature(sig: NSMethodSignature): NSInvocation;

}

interface NSItemProviderAllocator<InitializedType = NSItemProvider> extends NSObjectAllocator<NSItemProvider> {
  init(): InitializedType;
  initWithObject(object: any): InitializedType;
  initWithItem_typeIdentifier(item: any | null, typeIdentifier: NSString | string | null): InitializedType;
  initWithContentsOfURL(fileURL: NSURL): InitializedType;
}
interface NSItemProvider extends NSObject, INSCopying {
  registerDataRepresentationForTypeIdentifier_visibility_loadHandler(typeIdentifier: NSString | string, visibility: NSItemProviderRepresentationVisibility, loadHandler: Block): void;
  registerFileRepresentationForTypeIdentifier_fileOptions_visibility_loadHandler(typeIdentifier: NSString | string, fileOptions: NSItemProviderFileOptions, visibility: NSItemProviderRepresentationVisibility, loadHandler: Block): void;
  registeredTypeIdentifiersWithFileOptions(fileOptions: NSItemProviderFileOptions): NSArray<any>;
  hasItemConformingToTypeIdentifier(typeIdentifier: NSString | string): boolean;
  hasRepresentationConformingToTypeIdentifier_fileOptions(typeIdentifier: NSString | string, fileOptions: NSItemProviderFileOptions): boolean;
  loadDataRepresentationForTypeIdentifier_completionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;
  loadFileRepresentationForTypeIdentifier_completionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;
  loadInPlaceFileRepresentationForTypeIdentifier_completionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;
  registerObject_visibility(object: any, visibility: NSItemProviderRepresentationVisibility): void;
  registerObjectOfClass_visibility_loadHandler(aClass: any, visibility: NSItemProviderRepresentationVisibility, loadHandler: Block): void;
  canLoadObjectOfClass(aClass: any): boolean;
  loadObjectOfClass_completionHandler(aClass: any, completionHandler: Block): NSProgress;
  registerItemForTypeIdentifier_loadHandler(typeIdentifier: NSString | string, loadHandler: NSItemProviderLoadHandler): void;
  loadItemForTypeIdentifier_options_completionHandler(typeIdentifier: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null, completionHandler: NSItemProviderCompletionHandler | null): void;
  loadPreviewImageWithOptions_completionHandler(options: NSDictionary<any, any> | {[key: string]: any}, completionHandler: NSItemProviderCompletionHandler): void;
  registerCloudKitShareWithPreparationHandler(preparationHandler: Block): void;
  registerCloudKitShare_container(share: CKShare, container: CKContainer): void;

  registeredTypeIdentifiers(): NSArray<any>;
  suggestedName(): NSString;
  setSuggestedName(suggestedName: NSString | string): void;
  previewImageHandler(): NSItemProviderLoadHandler;
  setPreviewImageHandler(previewImageHandler: NSItemProviderLoadHandler): void;
  sourceFrame(): NSRect;
  containerFrame(): NSRect;
  preferredPresentationSize(): NSSize;
}
declare const NSItemProvider: {
  alloc(): NSItemProviderAllocator;
}

interface INSItemProviderWriting {
  itemProviderVisibilityForRepresentationWithTypeIdentifier(typeIdentifier: NSString | string): NSItemProviderRepresentationVisibility;
  loadDataWithTypeIdentifier_forItemProviderCompletionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;

  writableTypeIdentifiersForItemProvider(): NSArray<any>;
}

interface INSItemProviderReading {
}

declare enum NSItemProviderRepresentationVisibility {
  NSItemProviderRepresentationVisibilityAll = 0,
  NSItemProviderRepresentationVisibilityTeam = 1,
  NSItemProviderRepresentationVisibilityGroup = 2,
  NSItemProviderRepresentationVisibilityOwnProcess = 3,
}

declare enum NSItemProviderFileOptions {
  NSItemProviderFileOptionOpenInPlace = 1,
}

declare enum NSItemProviderErrorCode {
  NSItemProviderUnknownError = -1,
  NSItemProviderItemUnavailableError = -1000,
  NSItemProviderUnexpectedValueClassError = -1100,
  NSItemProviderUnavailableCoercionError = -1200,
}

interface NSJSONSerializationAllocator<InitializedType = NSJSONSerialization> extends NSObjectAllocator<NSJSONSerialization> {}
interface NSJSONSerialization extends NSObject {
}
declare const NSJSONSerialization: {
  alloc(): NSJSONSerializationAllocator;  isValidJSONObject(obj: any): boolean;
  dataWithJSONObject_options_error(obj: any, opt: NSJSONWritingOptions, error: NSError): NSData;
  JSONObjectWithData_options_error(data: NSData, opt: NSJSONReadingOptions, error: NSError): any;
  writeJSONObject_toStream_options_error(obj: any, stream: NSOutputStream, opt: NSJSONWritingOptions, error: NSError): NSInteger;
  JSONObjectWithStream_options_error(stream: NSInputStream, opt: NSJSONReadingOptions, error: NSError): any;

}

declare enum NSJSONReadingOptions {
  NSJSONReadingMutableContainers,
  NSJSONReadingMutableLeaves,
  NSJSONReadingAllowFragments,
}

declare enum NSJSONWritingOptions {
  NSJSONWritingPrettyPrinted,
  NSJSONWritingSortedKeys,
}

interface NSOrderedSetAllocator<ObjectType, InitializedType = NSOrderedSet<ObjectType>> extends NSObjectAllocator<NSOrderedSet<ObjectType>> {
  init(): InitializedType;
  initWithObjects_count(objects: ObjectType[], cnt: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithObject(object: ObjectType): InitializedType;
  initWithObjects(firstObj: ObjectType, ...args: any[]): InitializedType;
  initWithOrderedSet(set: NSOrderedSet<any>): InitializedType;
  initWithOrderedSet_copyItems(set: NSOrderedSet<any>, flag: boolean): InitializedType;
  initWithOrderedSet_range_copyItems(set: NSOrderedSet<any>, range: NSRange, flag: boolean): InitializedType;
  initWithArray(array: NSArray<any> | any[]): InitializedType;
  initWithArray_copyItems(set: NSArray<any> | any[], flag: boolean): InitializedType;
  initWithArray_range_copyItems(set: NSArray<any> | any[], range: NSRange, flag: boolean): InitializedType;
  initWithSet(set: NSSet<any>): InitializedType;
  initWithSet_copyItems(set: NSSet<any>, flag: boolean): InitializedType;
}
interface NSOrderedSet<ObjectType> extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  objectAtIndex(idx: NSUInteger): ObjectType;
  indexOfObject(object: ObjectType): NSUInteger;
  getObjects_range(objects: ObjectType[], range: NSRange): void;
  objectsAtIndexes(indexes: NSIndexSet): NSArray<any>;
  isEqualToOrderedSet(other: NSOrderedSet<any>): boolean;
  containsObject(object: ObjectType): boolean;
  intersectsOrderedSet(other: NSOrderedSet<any>): boolean;
  intersectsSet(set: NSSet<any>): boolean;
  isSubsetOfOrderedSet(other: NSOrderedSet<any>): boolean;
  isSubsetOfSet(set: NSSet<any>): boolean;
  objectAtIndexedSubscript(idx: NSUInteger): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  reverseObjectEnumerator(): NSEnumerator<any>;
  enumerateObjectsUsingBlock(block: Block): void;
  enumerateObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateObjectsAtIndexes_options_usingBlock(s: NSIndexSet, opts: NSEnumerationOptions, block: Block): void;
  indexOfObjectPassingTest(predicate: Block): NSUInteger;
  indexOfObjectWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexOfObjectAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexesOfObjectsPassingTest(predicate: Block): NSIndexSet;
  indexesOfObjectsWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexesOfObjectsAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexOfObject_inSortedRange_options_usingComparator(object: ObjectType, range: NSRange, opts: NSBinarySearchingOptions, cmp: NSComparator): NSUInteger;
  sortedArrayUsingComparator(cmptr: NSComparator): NSArray<any>;
  sortedArrayWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): NSArray<any>;
  descriptionWithLocale(locale: any | null): NSString;
  descriptionWithLocale_indent(locale: any | null, level: NSUInteger): NSString;
  filteredOrderedSetUsingPredicate(p: NSPredicate): NSOrderedSet<any>;
  sortedArrayUsingDescriptors(sortDescriptors: NSArray<any> | any[]): NSArray<any>;
  mo_objectForIndexedSubscript(idx: NSUInteger): any;
  smk_map(mappingBlock: Block): NSOrderedSet<any>;

  count(): NSUInteger;
  firstObject(): ObjectType;
  lastObject(): ObjectType;
  reversedOrderedSet(): NSOrderedSet<any>;
  array(): NSArray<any>;
  set(): NSSet<any>;
  description(): NSString;
}
declare const NSOrderedSet: {
  alloc<ObjectType>(): NSOrderedSetAllocator<ObjectType>;  orderedSet<ObjectType>(): NSOrderedSet<ObjectType>;
  orderedSetWithObject<ObjectType>(object: ObjectType): NSOrderedSet<ObjectType>;
  orderedSetWithObjects_count<ObjectType>(objects: ObjectType[], cnt: NSUInteger): NSOrderedSet<ObjectType>;
  orderedSetWithObjects<ObjectType>(firstObj: ObjectType, ...args: any[]): NSOrderedSet<ObjectType>;
  orderedSetWithOrderedSet<ObjectType>(set: NSOrderedSet<any>): NSOrderedSet<ObjectType>;
  orderedSetWithOrderedSet_range_copyItems<ObjectType>(set: NSOrderedSet<any>, range: NSRange, flag: boolean): NSOrderedSet<ObjectType>;
  orderedSetWithArray<ObjectType>(array: NSArray<any> | any[]): NSOrderedSet<ObjectType>;
  orderedSetWithArray_range_copyItems<ObjectType>(array: NSArray<any> | any[], range: NSRange, flag: boolean): NSOrderedSet<ObjectType>;
  orderedSetWithSet<ObjectType>(set: NSSet<any>): NSOrderedSet<ObjectType>;
  orderedSetWithSet_copyItems<ObjectType>(set: NSSet<any>, flag: boolean): NSOrderedSet<ObjectType>;

}

interface NSSetAllocator<ObjectType, InitializedType = NSSet<ObjectType>> extends NSObjectAllocator<NSSet<ObjectType>> {
  init(): InitializedType;
  initWithObjects_count(objects: ObjectType[], cnt: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithObjects(firstObj: ObjectType, ...args: any[]): InitializedType;
  initWithSet(set: NSSet<any>): InitializedType;
  initWithSet_copyItems(set: NSSet<any>, flag: boolean): InitializedType;
  initWithArray(array: NSArray<any> | any[]): InitializedType;
}
interface NSSet<ObjectType> extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  filteredSetUsingPredicate(predicate: NSPredicate): NSSet<any>;
  member(object: ObjectType): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  anyObject(): ObjectType;
  containsObject(anObject: ObjectType): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  intersectsSet(otherSet: NSSet<any>): boolean;
  isEqualToSet(otherSet: NSSet<any>): boolean;
  isSubsetOfSet(otherSet: NSSet<any>): boolean;
  makeObjectsPerformSelector(aSelector: string): void;
  makeObjectsPerformSelector_withObject(aSelector: string, argument: any | null): void;
  setByAddingObject(anObject: ObjectType): NSSet<any>;
  setByAddingObjectsFromSet(other: NSSet<any>): NSSet<any>;
  setByAddingObjectsFromArray(other: NSArray<any> | any[]): NSSet<any>;
  enumerateObjectsUsingBlock(block: Block): void;
  enumerateObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  objectsPassingTest(predicate: Block): NSSet<any>;
  objectsWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSSet<any>;
  sortedArrayUsingDescriptors(sortDescriptors: NSArray<any> | any[]): NSArray<any>;
  enumerateIndexPathsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  each(block: Block): void;
  map(block: Block): NSSet<ObjectType>;
  containsObjectPassingTest(predicate: Block): boolean;
  isEquivalentToArray_bc(array: NSArray<any> | any[]): boolean;
  sortedArrayUsingKey(key: NSString | string): NSArray<any>;
  setMinusSet(otherSet: NSSet<any>): NSSet<any>;
  sck_flatMap(transform: Block): NSSet<any>;
  sortedOffsets_ms(): NSArray<any>;
  offsetsInBezierInterval_ms(): NSSet<any>;
  sortedOffsetsInBezierInterval_ms(): NSArray<any>;
  firstOffsetInBezierInterval_ms(): NSNumber;
  lastOffsetInBezierInterval_ms(): NSNumber;

  count(): NSUInteger;
  allObjects(): NSArray<any>;
  description(): NSString;
}
declare const NSSet: {
  alloc<ObjectType>(): NSSetAllocator<ObjectType>;  set<ObjectType>(): NSSet<ObjectType>;
  setWithObject<ObjectType>(object: ObjectType): NSSet<ObjectType>;
  setWithObjects_count<ObjectType>(objects: ObjectType[], cnt: NSUInteger): NSSet<ObjectType>;
  setWithObjects<ObjectType>(firstObj: ObjectType, ...args: any[]): NSSet<ObjectType>;
  setWithSet<ObjectType>(set: NSSet<any>): NSSet<ObjectType>;
  setWithArray<ObjectType>(array: NSArray<any> | any[]): NSSet<ObjectType>;
  setWithCollectionViewIndexPath<ObjectType>(indexPath: NSIndexPath): NSSet<ObjectType>;
  setWithCollectionViewIndexPaths<ObjectType>(indexPaths: NSArray<any> | any[]): NSSet<ObjectType>;

}

declare type NSKeyValueOperator = NSString

declare type NSKeyValueChangeKey = NSString

declare enum NSKeyValueObservingOptions {
  NSKeyValueObservingOptionNew = 0x01,
  NSKeyValueObservingOptionOld = 0x02,
  NSKeyValueObservingOptionInitial = 0x04,
  NSKeyValueObservingOptionPrior = 0x08,
}

declare enum NSKeyValueChange {
  NSKeyValueChangeSetting = 1,
  NSKeyValueChangeInsertion = 2,
  NSKeyValueChangeRemoval = 3,
  NSKeyValueChangeReplacement = 4,
}

declare enum NSKeyValueSetMutationKind {
  NSKeyValueUnionSetMutation = 1,
  NSKeyValueMinusSetMutation = 2,
  NSKeyValueIntersectSetMutation = 3,
  NSKeyValueSetSetMutation = 4,
}

interface NSKeyedArchiverAllocator<InitializedType = NSKeyedArchiver> extends NSCoderAllocator<NSKeyedArchiver> {
  init(): InitializedType;
  initForWritingWithMutableData(data: NSMutableData): InitializedType;
}
interface NSKeyedArchiver extends NSCoder {
  finishEncoding(): void;
  setClassName_forClass(codedName: NSString | string | null, cls: any): void;
  classNameForClass(cls: any): NSString;
  encodeObject_forKey(object: any | null, key: NSString | string): void;
  encodeConditionalObject_forKey(object: any | null, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeInt_forKey(value: number, key: NSString | string): void;
  encodeInt32_forKey(value: number, key: NSString | string): void;
  encodeInt64_forKey(value: number, key: NSString | string): void;
  encodeFloat_forKey(value: number, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBytes_length_forKey(bytes: number | null, length: NSUInteger, key: NSString | string): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  outputFormat(): NSPropertyListFormat;
  setOutputFormat(outputFormat: NSPropertyListFormat): void;
  encodedData(): NSData;
  requiresSecureCoding(): boolean;
  setRequiresSecureCoding(requiresSecureCoding: boolean): void;
}
declare const NSKeyedArchiver: {
  alloc(): NSKeyedArchiverAllocator;  archivedDataWithRootObject(rootObject: any): NSData;
  archiveRootObject_toFile(rootObject: any, path: NSString | string): boolean;

}

interface NSKeyedUnarchiverAllocator<InitializedType = NSKeyedUnarchiver> extends NSCoderAllocator<NSKeyedUnarchiver> {
  initForReadingWithData(data: NSData): InitializedType;
}
interface NSKeyedUnarchiver extends NSCoder {
  finishDecoding(): void;
  setClass_forClassName(cls: any | null, codedName: NSString | string): void;
  classForClassName(codedName: NSString | string): any;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeBoolForKey(key: NSString | string): boolean;
  decodeIntForKey(key: NSString | string): number;
  decodeInt32ForKey(key: NSString | string): number;
  decodeInt64ForKey(key: NSString | string): number;
  decodeFloatForKey(key: NSString | string): number;
  decodeDoubleForKey(key: NSString | string): number;
  decodeBytesForKey_returnedLength(key: NSString | string, lengthp: NSUInteger | null): number;

  delegate(): any;
  setDelegate(delegate: any): void;
  requiresSecureCoding(): boolean;
  setRequiresSecureCoding(requiresSecureCoding: boolean): void;
  decodingFailurePolicy(): NSDecodingFailurePolicy;
  setDecodingFailurePolicy(decodingFailurePolicy: NSDecodingFailurePolicy): void;
}
declare const NSKeyedUnarchiver: {
  alloc(): NSKeyedUnarchiverAllocator;  unarchiveObjectWithData(data: NSData): any;
  unarchiveObjectWithFile(path: NSString | string): any;

}

interface INSKeyedArchiverDelegate {
  archiver_willEncodeObject(archiver: NSKeyedArchiver, object: any): any;
  archiver_didEncodeObject(archiver: NSKeyedArchiver, object: any | null): void;
  archiver_willReplaceObject_withObject(archiver: NSKeyedArchiver, object: any | null, newObject: any | null): void;
  archiverWillFinish(archiver: NSKeyedArchiver): void;
  archiverDidFinish(archiver: NSKeyedArchiver): void;
}

interface INSKeyedUnarchiverDelegate {
  unarchiver_cannotDecodeObjectOfClassName_originalClasses(unarchiver: NSKeyedUnarchiver, name: NSString | string, classNames: NSArray<any> | any[]): any;
  unarchiver_willReplaceObject_withObject(unarchiver: NSKeyedUnarchiver, object: any, newObject: any): void;
  unarchiverWillFinish(unarchiver: NSKeyedUnarchiver): void;
  unarchiverDidFinish(unarchiver: NSKeyedUnarchiver): void;
}

interface NSLengthFormatterAllocator<InitializedType = NSLengthFormatter> extends NSFormatterAllocator<NSLengthFormatter> {}
interface NSLengthFormatter extends NSFormatter {
  stringFromValue_unit(value: number, unit: NSLengthFormatterUnit): NSString;
  stringFromMeters(numberInMeters: number): NSString;
  unitStringFromValue_unit(value: number, unit: NSLengthFormatterUnit): NSString;
  unitStringFromMeters_usedUnit(numberInMeters: number, unitp: NSLengthFormatterUnit | null): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  forPersonHeightUse(): boolean;
  setForPersonHeightUse(forPersonHeightUse: boolean): void;
}
declare const NSLengthFormatter: {
  alloc(): NSLengthFormatterAllocator;
}

declare enum NSLengthFormatterUnit {
  NSLengthFormatterUnitMillimeter = 8,
  NSLengthFormatterUnitCentimeter = 9,
  NSLengthFormatterUnitMeter = 11,
  NSLengthFormatterUnitKilometer = 14,
  NSLengthFormatterUnitInch,
  NSLengthFormatterUnitFoot,
  NSLengthFormatterUnitYard,
  NSLengthFormatterUnitMile,
}

interface NSLinguisticTaggerAllocator<InitializedType = NSLinguisticTagger> extends NSObjectAllocator<NSLinguisticTagger> {
  initWithTagSchemes_options(tagSchemes: NSArray<any> | any[], opts: NSUInteger): InitializedType;
}
interface NSLinguisticTagger extends NSObject {
  setOrthography_range(orthography: NSOrthography | null, range: NSRange): void;
  orthographyAtIndex_effectiveRange(charIndex: NSUInteger, effectiveRange: NSRangePointer | null): NSOrthography;
  stringEditedInRange_changeInLength(newRange: NSRange, delta: NSInteger): void;
  tokenRangeAtIndex_unit(charIndex: NSUInteger, unit: NSLinguisticTaggerUnit): NSRange;
  sentenceRangeForRange(range: NSRange): NSRange;
  enumerateTagsInRange_unit_scheme_options_usingBlock(range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, block: Block): void;
  tagAtIndex_unit_scheme_tokenRange(charIndex: NSUInteger, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, tokenRange: NSRangePointer | null): NSLinguisticTag;
  tagsInRange_unit_scheme_options_tokenRanges(range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  enumerateTagsInRange_scheme_options_usingBlock(range: NSRange, tagScheme: NSLinguisticTagScheme, opts: NSLinguisticTaggerOptions, block: Block): void;
  tagAtIndex_scheme_tokenRange_sentenceRange(charIndex: NSUInteger, scheme: NSLinguisticTagScheme, tokenRange: NSRangePointer | null, sentenceRange: NSRangePointer | null): NSLinguisticTag;
  tagsInRange_scheme_options_tokenRanges(range: NSRange, tagScheme: NSString | string, opts: NSLinguisticTaggerOptions, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  possibleTagsAtIndex_scheme_tokenRange_sentenceRange_scores(charIndex: NSUInteger, tagScheme: NSString | string, tokenRange: NSRangePointer | null, sentenceRange: NSRangePointer | null, scores: NSArray<any> | any[]): NSArray<any>;

  tagSchemes(): NSArray<any>;
  string(): NSString;
  setString(string: NSString | string): void;
  dominantLanguage(): NSString;
}
declare const NSLinguisticTagger: {
  alloc(): NSLinguisticTaggerAllocator;  availableTagSchemesForUnit_language(unit: NSLinguisticTaggerUnit, language: NSString | string): NSArray<any>;
  availableTagSchemesForLanguage(language: NSString | string): NSArray<any>;
  dominantLanguageForString(string: NSString | string): NSString;
  tagForString_atIndex_unit_scheme_orthography_tokenRange(string: NSString | string, charIndex: NSUInteger, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, orthography: NSOrthography | null, tokenRange: NSRangePointer | null): NSLinguisticTag;
  tagsForString_range_unit_scheme_options_orthography_tokenRanges(string: NSString | string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  enumerateTagsForString_range_unit_scheme_options_orthography_usingBlock(string: NSString | string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, block: Block): void;

}

declare type NSLinguisticTagScheme = NSString

declare type NSLinguisticTag = NSString

declare enum NSLinguisticTaggerUnit {
  NSLinguisticTaggerUnitWord,
  NSLinguisticTaggerUnitSentence,
  NSLinguisticTaggerUnitParagraph,
  NSLinguisticTaggerUnitDocument,
}

declare enum NSLinguisticTaggerOptions {
  NSLinguisticTaggerOmitWords = 1 << 0,
  NSLinguisticTaggerOmitPunctuation = 1 << 1,
  NSLinguisticTaggerOmitWhitespace = 1 << 2,
  NSLinguisticTaggerOmitOther = 1 << 3,
  NSLinguisticTaggerJoinNames = 1 << 4,
}

interface NSLocaleAllocator<InitializedType = NSLocale> extends NSObjectAllocator<NSLocale> {
  initWithLocaleIdentifier(string: NSString | string): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSLocale extends NSObject, INSCopying, INSSecureCoding {
  objectForKey(key: NSLocaleKey): any;
  displayNameForKey_value(key: NSLocaleKey, value: any): NSString;
  localizedStringForLocaleIdentifier(localeIdentifier: NSString | string): NSString;
  localizedStringForLanguageCode(languageCode: NSString | string): NSString;
  localizedStringForCountryCode(countryCode: NSString | string): NSString;
  localizedStringForScriptCode(scriptCode: NSString | string): NSString;
  localizedStringForVariantCode(variantCode: NSString | string): NSString;
  localizedStringForCalendarIdentifier(calendarIdentifier: NSString | string): NSString;
  localizedStringForCollationIdentifier(collationIdentifier: NSString | string): NSString;
  localizedStringForCurrencyCode(currencyCode: NSString | string): NSString;
  localizedStringForCollatorIdentifier(collatorIdentifier: NSString | string): NSString;

  localeIdentifier(): NSString;
  languageCode(): NSString;
  countryCode(): NSString;
  scriptCode(): NSString;
  variantCode(): NSString;
  exemplarCharacterSet(): NSCharacterSet;
  calendarIdentifier(): NSString;
  collationIdentifier(): NSString;
  usesMetricSystem(): boolean;
  decimalSeparator(): NSString;
  groupingSeparator(): NSString;
  currencySymbol(): NSString;
  currencyCode(): NSString;
  collatorIdentifier(): NSString;
  quotationBeginDelimiter(): NSString;
  quotationEndDelimiter(): NSString;
  alternateQuotationBeginDelimiter(): NSString;
  alternateQuotationEndDelimiter(): NSString;
}
declare const NSLocale: {
  alloc(): NSLocaleAllocator;  localeWithLocaleIdentifier(ident: NSString | string): NSLocale;
  componentsFromLocaleIdentifier(string: NSString | string): NSDictionary<any, any>;
  localeIdentifierFromComponents(dict: NSDictionary<any, any> | {[key: string]: any}): NSString;
  canonicalLocaleIdentifierFromString(string: NSString | string): NSString;
  canonicalLanguageIdentifierFromString(string: NSString | string): NSString;
  localeIdentifierFromWindowsLocaleCode(lcid: number): NSString;
  windowsLocaleCodeFromLocaleIdentifier(localeIdentifier: NSString | string): number;
  characterDirectionForLanguage(isoLangCode: NSString | string): NSLocaleLanguageDirection;
  lineDirectionForLanguage(isoLangCode: NSString | string): NSLocaleLanguageDirection;

  autoupdatingCurrentLocale(): NSLocale;
  currentLocale(): NSLocale;
  systemLocale(): NSLocale;
  availableLocaleIdentifiers(): NSArray<any>;
  ISOLanguageCodes(): NSArray<any>;
  ISOCountryCodes(): NSArray<any>;
  ISOCurrencyCodes(): NSArray<any>;
  commonISOCurrencyCodes(): NSArray<any>;
  preferredLanguages(): NSArray<any>;

}

declare type NSLocaleKey = NSString

declare enum NSLocaleLanguageDirection {
  NSLocaleLanguageDirectionUnknown,
  NSLocaleLanguageDirectionLeftToRight,
  NSLocaleLanguageDirectionRightToLeft,
  NSLocaleLanguageDirectionTopToBottom,
  NSLocaleLanguageDirectionBottomToTop,
}

interface NSLockAllocator<InitializedType = NSLock> extends NSObjectAllocator<NSLock> {}
interface NSLock extends NSObject, INSLocking {
  tryLock(): boolean;
  lockBeforeDate(limit: NSDate): boolean;

  name(): NSString;
  setName(name: NSString | string): void;
}
declare const NSLock: {
  alloc(): NSLockAllocator;
}

interface NSConditionLockAllocator<InitializedType = NSConditionLock> extends NSObjectAllocator<NSConditionLock> {
  initWithCondition(condition: NSInteger): InitializedType;
}
interface NSConditionLock extends NSObject, INSLocking {
  lockWhenCondition(condition: NSInteger): void;
  tryLock(): boolean;
  tryLockWhenCondition(condition: NSInteger): boolean;
  unlockWithCondition(condition: NSInteger): void;
  lockBeforeDate(limit: NSDate): boolean;
  lockWhenCondition_beforeDate(condition: NSInteger, limit: NSDate): boolean;

  condition(): NSInteger;
  name(): NSString;
  setName(name: NSString | string): void;
}
declare const NSConditionLock: {
  alloc(): NSConditionLockAllocator;
}

interface NSRecursiveLockAllocator<InitializedType = NSRecursiveLock> extends NSObjectAllocator<NSRecursiveLock> {}
interface NSRecursiveLock extends NSObject, INSLocking {
  tryLock(): boolean;
  lockBeforeDate(limit: NSDate): boolean;

  name(): NSString;
  setName(name: NSString | string): void;
}
declare const NSRecursiveLock: {
  alloc(): NSRecursiveLockAllocator;
}

interface NSConditionAllocator<InitializedType = NSCondition> extends NSObjectAllocator<NSCondition> {}
interface NSCondition extends NSObject, INSLocking {
  wait(): void;
  waitUntilDate(limit: NSDate): boolean;
  signal(): void;
  broadcast(): void;

  name(): NSString;
  setName(name: NSString | string): void;
}
declare const NSCondition: {
  alloc(): NSConditionAllocator;
}

interface INSLocking {
  lock(): void;
  unlock(): void;
}

interface NSMapTableAllocator<KeyType, ObjectType, InitializedType = NSMapTable<KeyType, ObjectType>> extends NSObjectAllocator<NSMapTable<KeyType, ObjectType>> {
  initWithKeyOptions_valueOptions_capacity(keyOptions: NSPointerFunctionsOptions, valueOptions: NSPointerFunctionsOptions, initialCapacity: NSUInteger): InitializedType;
  initWithKeyPointerFunctions_valuePointerFunctions_capacity(keyFunctions: NSPointerFunctions, valueFunctions: NSPointerFunctions, initialCapacity: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSMapTable<KeyType, ObjectType> extends NSObject, INSCopying, INSCoding, INSFastEnumeration {
  objectForKey(aKey: KeyType | null): ObjectType;
  removeObjectForKey(aKey: KeyType | null): void;
  setObject_forKey(anObject: ObjectType | null, aKey: KeyType | null): void;
  keyEnumerator(): NSEnumerator<any>;
  objectEnumerator(): NSEnumerator<any>;
  removeAllObjects(): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
  enumerateKeysAndObjectsUsingBlock(block: Block): void;
  enumerateKeysUsingBlock(block: Block): void;
  enumerateObjectsUsingBlock(block: Block): void;
  objectForKeyedSubscript(key: any): any;
  setObject_forKeyedSubscript(obj: any, key: any): void;
  filter(block: BCMapTableFilterBlock): NSMapTable<any, any>;

  keyPointerFunctions(): NSPointerFunctions;
  valuePointerFunctions(): NSPointerFunctions;
  count(): NSUInteger;
}
declare const NSMapTable: {
  alloc<KeyType, ObjectType>(): NSMapTableAllocator<KeyType, ObjectType>;  mapTableWithKeyOptions_valueOptions(keyOptions: NSPointerFunctionsOptions, valueOptions: NSPointerFunctionsOptions): NSMapTable<any, any>;
  mapTableWithStrongToStrongObjects(): any;
  mapTableWithWeakToStrongObjects(): any;
  mapTableWithStrongToWeakObjects(): any;
  mapTableWithWeakToWeakObjects(): any;
  strongToStrongObjectsMapTable(): NSMapTable<any, any>;
  weakToStrongObjectsMapTable(): NSMapTable<any, any>;
  strongToWeakObjectsMapTable(): NSMapTable<any, any>;
  weakToWeakObjectsMapTable(): NSMapTable<any, any>;

}

declare type NSMapEnumerator = {
  _pi: NSUInteger
  _si: NSUInteger
  _bs: void
}

declare type NSMapTableKeyCallBacks = any

declare type NSMapTableValueCallBacks = any

declare type NSMapTableOptions = NSUInteger

interface NSMassFormatterAllocator<InitializedType = NSMassFormatter> extends NSFormatterAllocator<NSMassFormatter> {}
interface NSMassFormatter extends NSFormatter {
  stringFromValue_unit(value: number, unit: NSMassFormatterUnit): NSString;
  stringFromKilograms(numberInKilograms: number): NSString;
  unitStringFromValue_unit(value: number, unit: NSMassFormatterUnit): NSString;
  unitStringFromKilograms_usedUnit(numberInKilograms: number, unitp: NSMassFormatterUnit | null): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  forPersonMassUse(): boolean;
  setForPersonMassUse(forPersonMassUse: boolean): void;
}
declare const NSMassFormatter: {
  alloc(): NSMassFormatterAllocator;
}

declare enum NSMassFormatterUnit {
  NSMassFormatterUnitGram = 11,
  NSMassFormatterUnitKilogram = 14,
  NSMassFormatterUnitOunce,
  NSMassFormatterUnitPound,
  NSMassFormatterUnitStone,
}

interface NSMeasurementAllocator<UnitType, InitializedType = NSMeasurement<UnitType>> extends NSObjectAllocator<NSMeasurement<UnitType>> {
  initWithDoubleValue_unit(doubleValue: number, unit: UnitType): InitializedType;
}
interface NSMeasurement<UnitType> extends NSObject, INSCopying, INSSecureCoding {
  canBeConvertedToUnit(unit: NSUnit): boolean;
  measurementByConvertingToUnit(unit: NSUnit): NSMeasurement<any>;
  measurementByAddingMeasurement(measurement: NSMeasurement<any>): NSMeasurement<any>;
  measurementBySubtractingMeasurement(measurement: NSMeasurement<any>): NSMeasurement<any>;

  unit(): UnitType;
  doubleValue(): number;
}
declare const NSMeasurement: {
  alloc<UnitType>(): NSMeasurementAllocator<UnitType>;
}

interface NSMeasurementFormatterAllocator<InitializedType = NSMeasurementFormatter> extends NSFormatterAllocator<NSMeasurementFormatter> {}
interface NSMeasurementFormatter extends NSFormatter, INSSecureCoding {
  stringFromMeasurement(measurement: NSMeasurement<any>): NSString;
  stringFromUnit(unit: NSUnit): NSString;

  unitOptions(): NSMeasurementFormatterUnitOptions;
  setUnitOptions(unitOptions: NSMeasurementFormatterUnitOptions): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
}
declare const NSMeasurementFormatter: {
  alloc(): NSMeasurementFormatterAllocator;
}

declare enum NSMeasurementFormatterUnitOptions {
  NSMeasurementFormatterUnitOptionsProvidedUnit,
  NSMeasurementFormatterUnitOptionsNaturalScale,
  NSMeasurementFormatterUnitOptionsTemperatureWithoutUnit,
}

interface NSMetadataQueryAllocator<InitializedType = NSMetadataQuery> extends NSObjectAllocator<NSMetadataQuery> {}
interface NSMetadataQuery extends NSObject {
  startQuery(): boolean;
  stopQuery(): void;
  disableUpdates(): void;
  enableUpdates(): void;
  resultAtIndex(idx: NSUInteger): any;
  enumerateResultsUsingBlock(block: Block): void;
  enumerateResultsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  indexOfResult(result: any): NSUInteger;
  valueOfAttribute_forResultAtIndex(attrName: NSString | string, idx: NSUInteger): any;

  delegate(): any;
  setDelegate(delegate: any): void;
  predicate(): NSPredicate;
  setPredicate(predicate: NSPredicate): void;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  valueListAttributes(): NSArray<any>;
  setValueListAttributes(valueListAttributes: NSArray<any> | any[]): void;
  groupingAttributes(): NSArray<any>;
  setGroupingAttributes(groupingAttributes: NSArray<any> | any[]): void;
  notificationBatchingInterval(): NSTimeInterval;
  setNotificationBatchingInterval(notificationBatchingInterval: NSTimeInterval): void;
  searchScopes(): NSArray<any>;
  setSearchScopes(searchScopes: NSArray<any> | any[]): void;
  searchItems(): NSArray<any>;
  setSearchItems(searchItems: NSArray<any> | any[]): void;
  operationQueue(): NSOperationQueue;
  setOperationQueue(operationQueue: NSOperationQueue): void;
  started(): boolean;
  gathering(): boolean;
  stopped(): boolean;
  resultCount(): NSUInteger;
  results(): NSArray<any>;
  valueLists(): NSDictionary<any, any>;
  groupedResults(): NSArray<any>;
}
declare const NSMetadataQuery: {
  alloc(): NSMetadataQueryAllocator;
}

interface NSMetadataItemAllocator<InitializedType = NSMetadataItem> extends NSObjectAllocator<NSMetadataItem> {
  initWithURL(url: NSURL): InitializedType;
}
interface NSMetadataItem extends NSObject {
  valueForAttribute(key: NSString | string): any;
  valuesForAttributes(keys: NSArray<any> | any[]): NSDictionary<any, any>;

  attributes(): NSArray<any>;
}
declare const NSMetadataItem: {
  alloc(): NSMetadataItemAllocator;
}

interface NSMetadataQueryAttributeValueTupleAllocator<InitializedType = NSMetadataQueryAttributeValueTuple> extends NSObjectAllocator<NSMetadataQueryAttributeValueTuple> {}
interface NSMetadataQueryAttributeValueTuple extends NSObject {

  attribute(): NSString;
  value(): any;
  count(): NSUInteger;
}
declare const NSMetadataQueryAttributeValueTuple: {
  alloc(): NSMetadataQueryAttributeValueTupleAllocator;
}

interface NSMetadataQueryResultGroupAllocator<InitializedType = NSMetadataQueryResultGroup> extends NSObjectAllocator<NSMetadataQueryResultGroup> {}
interface NSMetadataQueryResultGroup extends NSObject {
  resultAtIndex(idx: NSUInteger): any;

  attribute(): NSString;
  value(): any;
  subgroups(): NSArray<any>;
  resultCount(): NSUInteger;
  results(): NSArray<any>;
}
declare const NSMetadataQueryResultGroup: {
  alloc(): NSMetadataQueryResultGroupAllocator;
}

interface INSMetadataQueryDelegate {
  metadataQuery_replacementObjectForResultObject(query: NSMetadataQuery, result: NSMetadataItem): any;
  metadataQuery_replacementValueForAttribute_value(query: NSMetadataQuery, attrName: NSString | string, attrValue: any): any;
}

interface NSMethodSignatureAllocator<InitializedType = NSMethodSignature> extends NSObjectAllocator<NSMethodSignature> {}
interface NSMethodSignature extends NSObject {
  getArgumentTypeAtIndex(idx: NSUInteger): string;
  isOneway(): boolean;

  numberOfArguments(): NSUInteger;
  frameLength(): NSUInteger;
  methodReturnType(): string;
  methodReturnLength(): NSUInteger;
}
declare const NSMethodSignature: {
  alloc(): NSMethodSignatureAllocator;  signatureWithObjCTypes(types: string): NSMethodSignature;

}

interface NSNetServiceAllocator<InitializedType = NSNetService> extends NSObjectAllocator<NSNetService> {
  initWithDomain_type_name_port(domain: NSString | string, type: NSString | string, name: NSString | string, port: number): InitializedType;
  initWithDomain_type_name(domain: NSString | string, type: NSString | string, name: NSString | string): InitializedType;
}
interface NSNetService extends NSObject {
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  publish(): void;
  publishWithOptions(options: NSNetServiceOptions): void;
  resolve(): void;
  stop(): void;
  resolveWithTimeout(timeout: NSTimeInterval): void;
  getInputStream_outputStream(inputStream: NSInputStream, outputStream: NSOutputStream): boolean;
  setTXTRecordData(recordData: NSData | null): boolean;
  TXTRecordData(): NSData;
  startMonitoring(): void;
  stopMonitoring(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  includesPeerToPeer(): boolean;
  setIncludesPeerToPeer(includesPeerToPeer: boolean): void;
  name(): NSString;
  type(): NSString;
  domain(): NSString;
  hostName(): NSString;
  addresses(): NSArray<any>;
  port(): NSInteger;
  addressStrings(): NSArray<any>;
}
declare const NSNetService: {
  alloc(): NSNetServiceAllocator;  dictionaryFromTXTRecordData(txtData: NSData): NSDictionary<any, any>;
  dataFromTXTRecordDictionary(txtDictionary: NSDictionary<any, any> | {[key: string]: any}): NSData;
  addressStringWithData(data: NSData): NSString;

}

interface NSNetServiceBrowserAllocator<InitializedType = NSNetServiceBrowser> extends NSObjectAllocator<NSNetServiceBrowser> {
  init(): InitializedType;
}
interface NSNetServiceBrowser extends NSObject {
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  searchForBrowsableDomains(): void;
  searchForRegistrationDomains(): void;
  searchForServicesOfType_inDomain(type: NSString | string, domainString: NSString | string): void;
  stop(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  includesPeerToPeer(): boolean;
  setIncludesPeerToPeer(includesPeerToPeer: boolean): void;
}
declare const NSNetServiceBrowser: {
  alloc(): NSNetServiceBrowserAllocator;
}

interface INSNetServiceDelegate {
  netServiceWillPublish(sender: NSNetService): void;
  netServiceDidPublish(sender: NSNetService): void;
  netService_didNotPublish(sender: NSNetService, errorDict: NSDictionary<any, any> | {[key: string]: any}): void;
  netServiceWillResolve(sender: NSNetService): void;
  netServiceDidResolveAddress(sender: NSNetService): void;
  netService_didNotResolve(sender: NSNetService, errorDict: NSDictionary<any, any> | {[key: string]: any}): void;
  netServiceDidStop(sender: NSNetService): void;
  netService_didUpdateTXTRecordData(sender: NSNetService, data: NSData): void;
  netService_didAcceptConnectionWithInputStream_outputStream(sender: NSNetService, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

interface INSNetServiceBrowserDelegate {
  netServiceBrowserWillSearch(browser: NSNetServiceBrowser): void;
  netServiceBrowserDidStopSearch(browser: NSNetServiceBrowser): void;
  netServiceBrowser_didNotSearch(browser: NSNetServiceBrowser, errorDict: NSDictionary<any, any> | {[key: string]: any}): void;
  netServiceBrowser_didFindDomain_moreComing(browser: NSNetServiceBrowser, domainString: NSString | string, moreComing: boolean): void;
  netServiceBrowser_didFindService_moreComing(browser: NSNetServiceBrowser, service: NSNetService, moreComing: boolean): void;
  netServiceBrowser_didRemoveDomain_moreComing(browser: NSNetServiceBrowser, domainString: NSString | string, moreComing: boolean): void;
  netServiceBrowser_didRemoveService_moreComing(browser: NSNetServiceBrowser, service: NSNetService, moreComing: boolean): void;
}

declare enum NSNetServicesError {
  NSNetServicesUnknownError = -72000,
  NSNetServicesCollisionError = -72001,
  NSNetServicesNotFoundError = -72002,
  NSNetServicesActivityInProgress = -72003,
  NSNetServicesBadArgumentError = -72004,
  NSNetServicesCancelledError = -72005,
  NSNetServicesInvalidError = -72006,
  NSNetServicesTimeoutError = -72007,
}

declare enum NSNetServiceOptions {
  NSNetServiceNoAutoRename = 1 << 0,
  NSNetServiceListenForConnections = 1 << 1,
}

interface NSNotificationAllocator<InitializedType = NSNotification> extends NSObjectAllocator<NSNotification> {
  initWithName_object_userInfo(name: NSNotificationName, object: any | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  init(): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSNotification extends NSObject, INSCopying, INSCoding {

  name(): NSNotificationName;
  object(): any;
  userInfo(): NSDictionary<any, any>;
}
declare const NSNotification: {
  alloc(): NSNotificationAllocator;  notificationWithName_object(aName: NSNotificationName, anObject: any | null): NSNotification;
  notificationWithName_object_userInfo(aName: NSNotificationName, anObject: any | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): NSNotification;

}

interface NSNotificationCenterAllocator<InitializedType = NSNotificationCenter> extends NSObjectAllocator<NSNotificationCenter> {}
interface NSNotificationCenter extends NSObject {
  addObserver_selector_name_object(observer: any, aSelector: string, aName: NSNotificationName | null, anObject: any | null): void;
  postNotification(notification: NSNotification): void;
  postNotificationName_object(aName: NSNotificationName, anObject: any | null): void;
  postNotificationName_object_userInfo(aName: NSNotificationName, anObject: any | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): void;
  removeObserver(observer: any): void;
  removeObserver_name_object(observer: any, aName: NSNotificationName | null, anObject: any | null): void;
  addObserverForName_object_queue_usingBlock(name: NSNotificationName | null, obj: any | null, queue: NSOperationQueue | null, block: Block): any;
}
declare const NSNotificationCenter: {
  alloc(): NSNotificationCenterAllocator;
  defaultCenter(): NSNotificationCenter;

}

declare type NSNotificationName = NSString

interface NSNotificationQueueAllocator<InitializedType = NSNotificationQueue> extends NSObjectAllocator<NSNotificationQueue> {
  initWithNotificationCenter(notificationCenter: NSNotificationCenter): InitializedType;
}
interface NSNotificationQueue extends NSObject {
  enqueueNotification_postingStyle(notification: NSNotification, postingStyle: NSPostingStyle): void;
  enqueueNotification_postingStyle_coalesceMask_forModes(notification: NSNotification, postingStyle: NSPostingStyle, coalesceMask: NSNotificationCoalescing, modes: NSArray<any> | any[] | null): void;
  dequeueNotificationsMatching_coalesceMask(notification: NSNotification, coalesceMask: NSUInteger): void;
}
declare const NSNotificationQueue: {
  alloc(): NSNotificationQueueAllocator;
  defaultQueue(): NSNotificationQueue;

}

declare enum NSPostingStyle {
  NSPostWhenIdle = 1,
  NSPostASAP = 2,
  NSPostNow = 3,
}

declare enum NSNotificationCoalescing {
  NSNotificationNoCoalescing = 0,
  NSNotificationCoalescingOnName = 1,
  NSNotificationCoalescingOnSender = 2,
}

interface NSNumberFormatterAllocator<InitializedType = NSNumberFormatter> extends NSFormatterAllocator<NSNumberFormatter> {}
interface NSNumberFormatter extends NSFormatter {
  getObjectValue_forString_range_error(obj: any, string: NSString | string, rangep: NSRange, error: NSError): boolean;
  stringFromNumber(number: NSNumber | number): NSString;
  numberFromString(string: NSString | string): NSNumber;

  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
  numberStyle(): NSNumberFormatterStyle;
  setNumberStyle(numberStyle: NSNumberFormatterStyle): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  generatesDecimalNumbers(): boolean;
  setGeneratesDecimalNumbers(generatesDecimalNumbers: boolean): void;
  formatterBehavior(): NSNumberFormatterBehavior;
  setFormatterBehavior(formatterBehavior: NSNumberFormatterBehavior): void;
  negativeFormat(): NSString;
  setNegativeFormat(negativeFormat: NSString | string): void;
  textAttributesForNegativeValues(): NSDictionary<any, any>;
  setTextAttributesForNegativeValues(textAttributesForNegativeValues: NSDictionary<any, any> | {[key: string]: any}): void;
  positiveFormat(): NSString;
  setPositiveFormat(positiveFormat: NSString | string): void;
  textAttributesForPositiveValues(): NSDictionary<any, any>;
  setTextAttributesForPositiveValues(textAttributesForPositiveValues: NSDictionary<any, any> | {[key: string]: any}): void;
  allowsFloats(): boolean;
  setAllowsFloats(allowsFloats: boolean): void;
  decimalSeparator(): NSString;
  setDecimalSeparator(decimalSeparator: NSString | string): void;
  alwaysShowsDecimalSeparator(): boolean;
  setAlwaysShowsDecimalSeparator(alwaysShowsDecimalSeparator: boolean): void;
  currencyDecimalSeparator(): NSString;
  setCurrencyDecimalSeparator(currencyDecimalSeparator: NSString | string): void;
  usesGroupingSeparator(): boolean;
  setUsesGroupingSeparator(usesGroupingSeparator: boolean): void;
  groupingSeparator(): NSString;
  setGroupingSeparator(groupingSeparator: NSString | string): void;
  zeroSymbol(): NSString;
  setZeroSymbol(zeroSymbol: NSString | string): void;
  textAttributesForZero(): NSDictionary<any, any>;
  setTextAttributesForZero(textAttributesForZero: NSDictionary<any, any> | {[key: string]: any}): void;
  nilSymbol(): NSString;
  setNilSymbol(nilSymbol: NSString | string): void;
  textAttributesForNil(): NSDictionary<any, any>;
  setTextAttributesForNil(textAttributesForNil: NSDictionary<any, any> | {[key: string]: any}): void;
  notANumberSymbol(): NSString;
  setNotANumberSymbol(notANumberSymbol: NSString | string): void;
  textAttributesForNotANumber(): NSDictionary<any, any>;
  setTextAttributesForNotANumber(textAttributesForNotANumber: NSDictionary<any, any> | {[key: string]: any}): void;
  positiveInfinitySymbol(): NSString;
  setPositiveInfinitySymbol(positiveInfinitySymbol: NSString | string): void;
  textAttributesForPositiveInfinity(): NSDictionary<any, any>;
  setTextAttributesForPositiveInfinity(textAttributesForPositiveInfinity: NSDictionary<any, any> | {[key: string]: any}): void;
  negativeInfinitySymbol(): NSString;
  setNegativeInfinitySymbol(negativeInfinitySymbol: NSString | string): void;
  textAttributesForNegativeInfinity(): NSDictionary<any, any>;
  setTextAttributesForNegativeInfinity(textAttributesForNegativeInfinity: NSDictionary<any, any> | {[key: string]: any}): void;
  positivePrefix(): NSString;
  setPositivePrefix(positivePrefix: NSString | string): void;
  positiveSuffix(): NSString;
  setPositiveSuffix(positiveSuffix: NSString | string): void;
  negativePrefix(): NSString;
  setNegativePrefix(negativePrefix: NSString | string): void;
  negativeSuffix(): NSString;
  setNegativeSuffix(negativeSuffix: NSString | string): void;
  currencyCode(): NSString;
  setCurrencyCode(currencyCode: NSString | string): void;
  currencySymbol(): NSString;
  setCurrencySymbol(currencySymbol: NSString | string): void;
  internationalCurrencySymbol(): NSString;
  setInternationalCurrencySymbol(internationalCurrencySymbol: NSString | string): void;
  percentSymbol(): NSString;
  setPercentSymbol(percentSymbol: NSString | string): void;
  perMillSymbol(): NSString;
  setPerMillSymbol(perMillSymbol: NSString | string): void;
  minusSign(): NSString;
  setMinusSign(minusSign: NSString | string): void;
  plusSign(): NSString;
  setPlusSign(plusSign: NSString | string): void;
  exponentSymbol(): NSString;
  setExponentSymbol(exponentSymbol: NSString | string): void;
  groupingSize(): NSUInteger;
  setGroupingSize(groupingSize: NSUInteger): void;
  secondaryGroupingSize(): NSUInteger;
  setSecondaryGroupingSize(secondaryGroupingSize: NSUInteger): void;
  multiplier(): NSNumber;
  setMultiplier(multiplier: NSNumber | number): void;
  formatWidth(): NSUInteger;
  setFormatWidth(formatWidth: NSUInteger): void;
  paddingCharacter(): NSString;
  setPaddingCharacter(paddingCharacter: NSString | string): void;
  paddingPosition(): NSNumberFormatterPadPosition;
  setPaddingPosition(paddingPosition: NSNumberFormatterPadPosition): void;
  roundingMode(): NSNumberFormatterRoundingMode;
  setRoundingMode(roundingMode: NSNumberFormatterRoundingMode): void;
  roundingIncrement(): NSNumber;
  setRoundingIncrement(roundingIncrement: NSNumber | number): void;
  minimumIntegerDigits(): NSUInteger;
  setMinimumIntegerDigits(minimumIntegerDigits: NSUInteger): void;
  maximumIntegerDigits(): NSUInteger;
  setMaximumIntegerDigits(maximumIntegerDigits: NSUInteger): void;
  minimumFractionDigits(): NSUInteger;
  setMinimumFractionDigits(minimumFractionDigits: NSUInteger): void;
  maximumFractionDigits(): NSUInteger;
  setMaximumFractionDigits(maximumFractionDigits: NSUInteger): void;
  minimum(): NSNumber;
  setMinimum(minimum: NSNumber | number): void;
  maximum(): NSNumber;
  setMaximum(maximum: NSNumber | number): void;
  currencyGroupingSeparator(): NSString;
  setCurrencyGroupingSeparator(currencyGroupingSeparator: NSString | string): void;
  lenient(): boolean;
  setLenient(lenient: boolean): void;
  usesSignificantDigits(): boolean;
  setUsesSignificantDigits(usesSignificantDigits: boolean): void;
  minimumSignificantDigits(): NSUInteger;
  setMinimumSignificantDigits(minimumSignificantDigits: NSUInteger): void;
  maximumSignificantDigits(): NSUInteger;
  setMaximumSignificantDigits(maximumSignificantDigits: NSUInteger): void;
  partialStringValidationEnabled(): boolean;
  setPartialStringValidationEnabled(partialStringValidationEnabled: boolean): void;
  hasThousandSeparators(): boolean;
  setHasThousandSeparators(hasThousandSeparators: boolean): void;
  thousandSeparator(): NSString;
  setThousandSeparator(thousandSeparator: NSString | string): void;
  localizesFormat(): boolean;
  setLocalizesFormat(localizesFormat: boolean): void;
  format(): NSString;
  setFormat(format: NSString | string): void;
  attributedStringForZero(): NSAttributedString;
  setAttributedStringForZero(attributedStringForZero: NSAttributedString): void;
  attributedStringForNil(): NSAttributedString;
  setAttributedStringForNil(attributedStringForNil: NSAttributedString): void;
  attributedStringForNotANumber(): NSAttributedString;
  setAttributedStringForNotANumber(attributedStringForNotANumber: NSAttributedString): void;
  roundingBehavior(): NSDecimalNumberHandler;
  setRoundingBehavior(roundingBehavior: NSDecimalNumberHandler): void;
}
declare const NSNumberFormatter: {
  alloc(): NSNumberFormatterAllocator;  localizedStringFromNumber_numberStyle(num: NSNumber | number, nstyle: NSNumberFormatterStyle): NSString;
  defaultFormatterBehavior(): NSNumberFormatterBehavior;
  setDefaultFormatterBehavior(behavior: NSNumberFormatterBehavior): void;

}

declare enum NSNumberFormatterBehavior {
  NSNumberFormatterBehaviorDefault = 0,
  NSNumberFormatterBehavior10_0 = 1000,
}

declare enum NSNumberFormatterStyle {
  NSNumberFormatterNoStyle,
  NSNumberFormatterDecimalStyle,
  NSNumberFormatterCurrencyStyle,
  NSNumberFormatterPercentStyle,
  NSNumberFormatterScientificStyle,
  NSNumberFormatterSpellOutStyle,
  NSNumberFormatterOrdinalStyle,
  NSNumberFormatterCurrencyISOCodeStyle,
  NSNumberFormatterCurrencyPluralStyle,
  NSNumberFormatterCurrencyAccountingStyle,
}

declare enum NSNumberFormatterPadPosition {
  NSNumberFormatterPadBeforePrefix,
  NSNumberFormatterPadAfterPrefix,
  NSNumberFormatterPadBeforeSuffix,
  NSNumberFormatterPadAfterSuffix,
}

declare enum NSNumberFormatterRoundingMode {
  NSNumberFormatterRoundCeiling,
  NSNumberFormatterRoundFloor,
  NSNumberFormatterRoundDown,
  NSNumberFormatterRoundUp,
  NSNumberFormatterRoundHalfEven,
  NSNumberFormatterRoundHalfDown,
  NSNumberFormatterRoundHalfUp,
}

declare type NSInteger = number

declare type NSUInteger = number

declare type NSExceptionName = NSString

declare type NSRunLoopMode = NSString

declare enum NSComparisonResult {
  NSOrderedAscending = -1,
  NSOrderedSame,
  NSOrderedDescending,
}

declare enum NSEnumerationOptions {
  NSEnumerationConcurrent,
  NSEnumerationReverse,
}

declare enum NSSortOptions {
  NSSortConcurrent,
  NSSortStable,
}

declare enum NSQualityOfService {
  NSQualityOfServiceUserInteractive = 0x21,
  NSQualityOfServiceUserInitiated = 0x19,
  NSQualityOfServiceUtility = 0x11,
  NSQualityOfServiceBackground = 0x09,
  NSQualityOfServiceDefault = -1,
}

interface INSCopying {
  copyWithZone(zone: NSZone | null): any;
}

interface INSMutableCopying {
  mutableCopyWithZone(zone: NSZone | null): any;
}

interface INSCoding {
  encodeWithCoder(aCoder: NSCoder): void;
}

interface INSSecureCoding {
}

interface INSDiscardableContent {
  beginContentAccess(): boolean;
  endContentAccess(): void;
  discardContentIfPossible(): void;
  isContentDiscarded(): boolean;
}

interface NSOperationAllocator<InitializedType = NSOperation> extends NSObjectAllocator<NSOperation> {}
interface NSOperation extends NSObject {
  start(): void;
  main(): void;
  cancel(): void;
  addDependency(op: NSOperation): void;
  removeDependency(op: NSOperation): void;
  waitUntilFinished(): void;

  cancelled(): boolean;
  executing(): boolean;
  finished(): boolean;
  concurrent(): boolean;
  asynchronous(): boolean;
  ready(): boolean;
  dependencies(): NSArray<any>;
  queuePriority(): NSOperationQueuePriority;
  setQueuePriority(queuePriority: NSOperationQueuePriority): void;
  threadPriority(): number;
  setThreadPriority(threadPriority: number): void;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  name(): NSString;
  setName(name: NSString | string): void;
}
declare const NSOperation: {
  alloc(): NSOperationAllocator;
}

interface NSBlockOperationAllocator<InitializedType = NSBlockOperation> extends NSOperationAllocator<NSBlockOperation> {}
interface NSBlockOperation extends NSOperation {
  addExecutionBlock(block: Block): void;

  executionBlocks(): NSArray<any>;
}
declare const NSBlockOperation: {
  alloc(): NSBlockOperationAllocator;  blockOperationWithBlock(block: Block): NSBlockOperation;

}

interface NSInvocationOperationAllocator<InitializedType = NSInvocationOperation> extends NSOperationAllocator<NSInvocationOperation> {
  initWithTarget_selector_object(target: any, sel: string, arg: any | null): InitializedType;
  initWithInvocation(inv: NSInvocation): InitializedType;
}
interface NSInvocationOperation extends NSOperation {

  invocation(): NSInvocation;
  result(): any;
}
declare const NSInvocationOperation: {
  alloc(): NSInvocationOperationAllocator;
}

interface NSOperationQueueAllocator<InitializedType = NSOperationQueue> extends NSObjectAllocator<NSOperationQueue> {}
interface NSOperationQueue extends NSObject {
  addOperation(op: NSOperation): void;
  addOperations_waitUntilFinished(ops: NSArray<any> | any[], wait: boolean): void;
  addOperationWithBlock(block: Block): void;
  cancelAllOperations(): void;
  waitUntilAllOperationsAreFinished(): void;

  operations(): NSArray<any>;
  operationCount(): NSUInteger;
  maxConcurrentOperationCount(): NSInteger;
  setMaxConcurrentOperationCount(maxConcurrentOperationCount: NSInteger): void;
  suspended(): boolean;
  setSuspended(suspended: boolean): void;
  name(): NSString;
  setName(name: NSString | string): void;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  underlyingQueue(): dispatch_queue_t;
  setUnderlyingQueue(underlyingQueue: dispatch_queue_t): void;
}
declare const NSOperationQueue: {
  alloc(): NSOperationQueueAllocator;
  currentQueue(): NSOperationQueue;
  mainQueue(): NSOperationQueue;

}

declare enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow = -8,
  NSOperationQueuePriorityLow = -4,
  NSOperationQueuePriorityNormal = 0,
  NSOperationQueuePriorityHigh = 4,
  NSOperationQueuePriorityVeryHigh = 8,
}

interface NSMutableOrderedSetAllocator<ObjectType, InitializedType = NSMutableOrderedSet<ObjectType>> extends NSOrderedSetAllocator<ObjectType, NSMutableOrderedSet<ObjectType>> {
  initWithCapacity(numItems: NSUInteger): InitializedType;
}
interface NSMutableOrderedSet<ObjectType> extends NSOrderedSet<ObjectType> {
  insertObject_atIndex(object: ObjectType, idx: NSUInteger): void;
  removeObjectAtIndex(idx: NSUInteger): void;
  replaceObjectAtIndex_withObject(idx: NSUInteger, object: ObjectType): void;
  addObject(object: ObjectType): void;
  addObjects_count(objects: ObjectType[], count: NSUInteger): void;
  addObjectsFromArray(array: NSArray<any> | any[]): void;
  exchangeObjectAtIndex_withObjectAtIndex(idx1: NSUInteger, idx2: NSUInteger): void;
  moveObjectsAtIndexes_toIndex(indexes: NSIndexSet, idx: NSUInteger): void;
  insertObjects_atIndexes(objects: NSArray<any> | any[], indexes: NSIndexSet): void;
  setObject_atIndex(obj: ObjectType, idx: NSUInteger): void;
  setObject_atIndexedSubscript(obj: ObjectType, idx: NSUInteger): void;
  replaceObjectsInRange_withObjects_count(range: NSRange, objects: ObjectType[], count: NSUInteger): void;
  replaceObjectsAtIndexes_withObjects(indexes: NSIndexSet, objects: NSArray<any> | any[]): void;
  removeObjectsInRange(range: NSRange): void;
  removeObjectsAtIndexes(indexes: NSIndexSet): void;
  removeAllObjects(): void;
  removeObject(object: ObjectType): void;
  removeObjectsInArray(array: NSArray<any> | any[]): void;
  intersectOrderedSet(other: NSOrderedSet<any>): void;
  minusOrderedSet(other: NSOrderedSet<any>): void;
  unionOrderedSet(other: NSOrderedSet<any>): void;
  intersectSet(other: NSSet<any>): void;
  minusSet(other: NSSet<any>): void;
  unionSet(other: NSSet<any>): void;
  sortUsingComparator(cmptr: NSComparator): void;
  sortWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): void;
  sortRange_options_usingComparator(range: NSRange, opts: NSSortOptions, cmptr: NSComparator): void;
  filterUsingPredicate(p: NSPredicate): void;
  sortUsingDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  mo_setObject_forIndexedSubscript(obj: any, idx: NSUInteger): void;
}
declare const NSMutableOrderedSet: {
  alloc<ObjectType>(): NSMutableOrderedSetAllocator<ObjectType>;  orderedSetWithCapacity<ObjectType>(numItems: NSUInteger): NSMutableOrderedSet<ObjectType>;

}

interface NSOrthographyAllocator<InitializedType = NSOrthography> extends NSObjectAllocator<NSOrthography> {
  initWithDominantScript_languageMap(script: NSString | string, map: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSOrthography extends NSObject, INSCopying, INSSecureCoding {
  languagesForScript(script: NSString | string): NSArray<any>;
  dominantLanguageForScript(script: NSString | string): NSString;

  dominantScript(): NSString;
  languageMap(): NSDictionary<any, any>;
  dominantLanguage(): NSString;
  allScripts(): NSArray<any>;
  allLanguages(): NSArray<any>;
}
declare const NSOrthography: {
  alloc(): NSOrthographyAllocator;  defaultOrthographyForLanguage(language: NSString | string): NSOrthography;
  orthographyWithDominantScript_languageMap(script: NSString | string, map: NSDictionary<any, any> | {[key: string]: any}): NSOrthography;

}

declare enum NSSearchPathDirectory {
  NSApplicationDirectory = 1,
  NSDemoApplicationDirectory,
  NSDeveloperApplicationDirectory,
  NSAdminApplicationDirectory,
  NSLibraryDirectory,
  NSDeveloperDirectory,
  NSUserDirectory,
  NSDocumentationDirectory,
  NSDocumentDirectory,
  NSCoreServiceDirectory,
  NSAutosavedInformationDirectory = 11,
  NSDesktopDirectory = 12,
  NSCachesDirectory = 13,
  NSApplicationSupportDirectory = 14,
  NSDownloadsDirectory = 15,
  NSInputMethodsDirectory = 16,
  NSMoviesDirectory = 17,
  NSMusicDirectory = 18,
  NSPicturesDirectory = 19,
  NSPrinterDescriptionDirectory = 20,
  NSSharedPublicDirectory = 21,
  NSPreferencePanesDirectory = 22,
  NSApplicationScriptsDirectory = 23,
  NSItemReplacementDirectory = 99,
  NSAllApplicationsDirectory = 100,
  NSAllLibrariesDirectory = 101,
  NSTrashDirectory = 102,
}

declare enum NSSearchPathDomainMask {
  NSUserDomainMask = 1,
  NSLocalDomainMask = 2,
  NSNetworkDomainMask = 4,
  NSSystemDomainMask = 8,
  NSAllDomainsMask = 0x0ffff,
}

interface NSPersonNameComponentsAllocator<InitializedType = NSPersonNameComponents> extends NSObjectAllocator<NSPersonNameComponents> {}
interface NSPersonNameComponents extends NSObject, INSCopying, INSSecureCoding {

  namePrefix(): NSString;
  setNamePrefix(namePrefix: NSString | string): void;
  givenName(): NSString;
  setGivenName(givenName: NSString | string): void;
  middleName(): NSString;
  setMiddleName(middleName: NSString | string): void;
  familyName(): NSString;
  setFamilyName(familyName: NSString | string): void;
  nameSuffix(): NSString;
  setNameSuffix(nameSuffix: NSString | string): void;
  nickname(): NSString;
  setNickname(nickname: NSString | string): void;
  phoneticRepresentation(): NSPersonNameComponents;
  setPhoneticRepresentation(phoneticRepresentation: NSPersonNameComponents): void;
}
declare const NSPersonNameComponents: {
  alloc(): NSPersonNameComponentsAllocator;
}

interface NSPersonNameComponentsFormatterAllocator<InitializedType = NSPersonNameComponentsFormatter> extends NSFormatterAllocator<NSPersonNameComponentsFormatter> {}
interface NSPersonNameComponentsFormatter extends NSFormatter {
  stringFromPersonNameComponents(components: NSPersonNameComponents): NSString;
  annotatedStringFromPersonNameComponents(components: NSPersonNameComponents): NSAttributedString;
  personNameComponentsFromString(string: NSString | string): NSPersonNameComponents;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  style(): NSPersonNameComponentsFormatterStyle;
  setStyle(style: NSPersonNameComponentsFormatterStyle): void;
  phonetic(): boolean;
  setPhonetic(phonetic: boolean): void;
}
declare const NSPersonNameComponentsFormatter: {
  alloc(): NSPersonNameComponentsFormatterAllocator;  localizedStringFromPersonNameComponents_style_options(components: NSPersonNameComponents, nameFormatStyle: NSPersonNameComponentsFormatterStyle, nameOptions: NSPersonNameComponentsFormatterOptions): NSString;

}

declare enum NSPersonNameComponentsFormatterStyle {
  NSPersonNameComponentsFormatterStyleDefault = 0,
  NSPersonNameComponentsFormatterStyleShort,
  NSPersonNameComponentsFormatterStyleMedium,
  NSPersonNameComponentsFormatterStyleLong,
  NSPersonNameComponentsFormatterStyleAbbreviated,
}

declare enum NSPersonNameComponentsFormatterOptions {
  NSPersonNameComponentsFormatterPhonetic,
}

interface NSPointerArrayAllocator<InitializedType = NSPointerArray> extends NSObjectAllocator<NSPointerArray> {
  initWithOptions(options: NSPointerFunctionsOptions): InitializedType;
  initWithPointerFunctions(functions: NSPointerFunctions): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSPointerArray extends NSObject, INSFastEnumeration, INSCopying, INSCoding {
  pointerAtIndex(index: NSUInteger): void;
  addPointer(pointer: void | null): void;
  removePointerAtIndex(index: NSUInteger): void;
  insertPointer_atIndex(item: void | null, index: NSUInteger): void;
  replacePointerAtIndex_withPointer(index: NSUInteger, item: void | null): void;
  compact(): void;

  pointerFunctions(): NSPointerFunctions;
  count(): NSUInteger;
  setCount(count: NSUInteger): void;
  allObjects(): NSArray<any>;
}
declare const NSPointerArray: {
  alloc(): NSPointerArrayAllocator;  pointerArrayWithOptions(options: NSPointerFunctionsOptions): NSPointerArray;
  pointerArrayWithPointerFunctions(functions: NSPointerFunctions): NSPointerArray;
  pointerArrayWithStrongObjects(): any;
  pointerArrayWithWeakObjects(): any;
  strongObjectsPointerArray(): NSPointerArray;
  weakObjectsPointerArray(): NSPointerArray;

}

interface NSPointerFunctionsAllocator<InitializedType = NSPointerFunctions> extends NSObjectAllocator<NSPointerFunctions> {
  initWithOptions(options: NSPointerFunctionsOptions): InitializedType;
}
interface NSPointerFunctions extends NSObject, INSCopying {

  usesStrongWriteBarrier(): boolean;
  setUsesStrongWriteBarrier(usesStrongWriteBarrier: boolean): void;
  usesWeakReadAndWriteBarriers(): boolean;
  setUsesWeakReadAndWriteBarriers(usesWeakReadAndWriteBarriers: boolean): void;
}
declare const NSPointerFunctions: {
  alloc(): NSPointerFunctionsAllocator;  pointerFunctionsWithOptions(options: NSPointerFunctionsOptions): NSPointerFunctions;

}

declare enum NSPointerFunctionsOptions {
  NSPointerFunctionsStrongMemory = (0 << 0),
  NSPointerFunctionsZeroingWeakMemory = (1 << 0),
  NSPointerFunctionsMallocMemory = (3 << 0),
  NSPointerFunctionsMachVirtualMemory = (4 << 0),
  NSPointerFunctionsWeakMemory = (5 << 0),
  NSPointerFunctionsObjectPersonality = (0 << 8),
  NSPointerFunctionsOpaquePersonality = (1 << 8),
  NSPointerFunctionsObjectPointerPersonality = (2 << 8),
  NSPointerFunctionsCStringPersonality = (3 << 8),
  NSPointerFunctionsStructPersonality = (4 << 8),
  NSPointerFunctionsIntegerPersonality = (5 << 8),
  NSPointerFunctionsCopyIn = (1 << 16),
}

interface NSPortAllocator<InitializedType = NSPort> extends NSObjectAllocator<NSPort> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSPort extends NSObject, INSCopying, INSCoding {
  invalidate(): void;
  setDelegate(anObject: any | null): void;
  delegate(): any;
  scheduleInRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  sendBeforeDate_components_from_reserved(limitDate: NSDate, components: NSMutableArray<any> | any[] | null, receivePort: NSPort | null, headerSpaceReserved: NSUInteger): boolean;
  sendBeforeDate_msgid_components_from_reserved(limitDate: NSDate, msgID: NSUInteger, components: NSMutableArray<any> | any[] | null, receivePort: NSPort | null, headerSpaceReserved: NSUInteger): boolean;
  addConnection_toRunLoop_forMode(conn: NSConnection, runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeConnection_fromRunLoop_forMode(conn: NSConnection, runLoop: NSRunLoop, mode: NSRunLoopMode): void;

  valid(): boolean;
  reservedSpaceLength(): NSUInteger;
}
declare const NSPort: {
  alloc(): NSPortAllocator;  port(): NSPort;

}

interface NSMachPortAllocator<InitializedType = NSMachPort> extends NSPortAllocator<NSMachPort> {
  initWithMachPort(machPort: number): InitializedType;
  initWithMachPort_options(machPort: number, f: NSMachPortOptions): InitializedType;
}
interface NSMachPort extends NSPort {
  setDelegate(anObject: any | null): void;
  delegate(): any;
  scheduleInRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;

  machPort(): number;
}
declare const NSMachPort: {
  alloc(): NSMachPortAllocator;  portWithMachPort(machPort: number): NSPort;
  portWithMachPort_options(machPort: number, f: NSMachPortOptions): NSPort;

}

interface NSMessagePortAllocator<InitializedType = NSMessagePort> extends NSPortAllocator<NSMessagePort> {}
interface NSMessagePort extends NSPort {
}
declare const NSMessagePort: {
  alloc(): NSMessagePortAllocator;
}

interface NSSocketPortAllocator<InitializedType = NSSocketPort> extends NSPortAllocator<NSSocketPort> {
  init(): InitializedType;
  initWithTCPPort(port: number): InitializedType;
  initWithProtocolFamily_socketType_protocol_address(family: number, type: number, protocol: number, address: NSData): InitializedType;
  initWithProtocolFamily_socketType_protocol_socket(family: number, type: number, protocol: number, sock: NSSocketNativeHandle): InitializedType;
  initRemoteWithTCPPort_host(port: number, hostName: NSString | string | null): InitializedType;
  initRemoteWithProtocolFamily_socketType_protocol_address(family: number, type: number, protocol: number, address: NSData): InitializedType;
}
interface NSSocketPort extends NSPort {

  protocolFamily(): number;
  socketType(): number;
  protocol(): number;
  address(): NSData;
  socket(): NSSocketNativeHandle;
}
declare const NSSocketPort: {
  alloc(): NSSocketPortAllocator;
}

interface INSPortDelegate {
  handlePortMessage(message: NSPortMessage): void;
}

interface INSMachPortDelegate {
  handleMachMessage(msg: void): void;
}

declare type NSSocketNativeHandle = number

declare enum NSMachPortOptions {
  NSMachPortDeallocateNone = 0,
  NSMachPortDeallocateSendRight,
  NSMachPortDeallocateReceiveRight,
}

interface NSPortCoderAllocator<InitializedType = NSPortCoder> extends NSCoderAllocator<NSPortCoder> {
  initWithReceivePort_sendPort_components(rcvPort: NSPort | null, sndPort: NSPort | null, comps: NSArray<any> | any[] | null): InitializedType;
}
interface NSPortCoder extends NSCoder {
  isBycopy(): boolean;
  isByref(): boolean;
  encodePortObject(aport: NSPort): void;
  decodePortObject(): NSPort;
  connection(): NSConnection;
  dispatch(): void;
}
declare const NSPortCoder: {
  alloc(): NSPortCoderAllocator;  portCoderWithReceivePort_sendPort_components(rcvPort: NSPort | null, sndPort: NSPort | null, comps: NSArray<any> | any[] | null): any;

}

interface NSPortMessageAllocator<InitializedType = NSPortMessage> extends NSObjectAllocator<NSPortMessage> {
  initWithSendPort_receivePort_components(sendPort: NSPort | null, replyPort: NSPort | null, components: NSArray<any> | any[] | null): InitializedType;
}
interface NSPortMessage extends NSObject {
  sendBeforeDate(date: NSDate): boolean;

  components(): NSArray<any>;
  receivePort(): NSPort;
  sendPort(): NSPort;
  msgid(): number;
  setMsgid(msgid: number): void;
}
declare const NSPortMessage: {
  alloc(): NSPortMessageAllocator;
}

interface NSPortNameServerAllocator<InitializedType = NSPortNameServer> extends NSObjectAllocator<NSPortNameServer> {}
interface NSPortNameServer extends NSObject {
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
  registerPort_name(port: NSPort, name: NSString | string): boolean;
  removePortForName(name: NSString | string): boolean;
}
declare const NSPortNameServer: {
  alloc(): NSPortNameServerAllocator;  systemDefaultPortNameServer(): NSPortNameServer;

}

interface NSMachBootstrapServerAllocator<InitializedType = NSMachBootstrapServer> extends NSPortNameServerAllocator<NSMachBootstrapServer> {}
interface NSMachBootstrapServer extends NSPortNameServer {
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
  registerPort_name(port: NSPort, name: NSString | string): boolean;
  servicePortWithName(name: NSString | string): NSPort;
}
declare const NSMachBootstrapServer: {
  alloc(): NSMachBootstrapServerAllocator;  sharedInstance(): any;

}

interface NSMessagePortNameServerAllocator<InitializedType = NSMessagePortNameServer> extends NSPortNameServerAllocator<NSMessagePortNameServer> {}
interface NSMessagePortNameServer extends NSPortNameServer {
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
}
declare const NSMessagePortNameServer: {
  alloc(): NSMessagePortNameServerAllocator;  sharedInstance(): any;

}

interface NSSocketPortNameServerAllocator<InitializedType = NSSocketPortNameServer> extends NSPortNameServerAllocator<NSSocketPortNameServer> {}
interface NSSocketPortNameServer extends NSPortNameServer {
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
  registerPort_name(port: NSPort, name: NSString | string): boolean;
  removePortForName(name: NSString | string): boolean;
  portForName_host_nameServerPortNumber(name: NSString | string, host: NSString | string | null, portNumber: number): NSPort;
  registerPort_name_nameServerPortNumber(port: NSPort, name: NSString | string, portNumber: number): boolean;

  defaultNameServerPortNumber(): number;
  setDefaultNameServerPortNumber(defaultNameServerPortNumber: number): void;
}
declare const NSSocketPortNameServer: {
  alloc(): NSSocketPortNameServerAllocator;  sharedInstance(): any;

}

interface NSPredicateAllocator<InitializedType = NSPredicate> extends NSObjectAllocator<NSPredicate> {}
interface NSPredicate extends NSObject, INSSecureCoding, INSCopying {
  predicateWithSubstitutionVariables(variables: NSDictionary<any, any> | {[key: string]: any}): NSPredicate;
  evaluateWithObject(object: any | null): boolean;
  evaluateWithObject_substitutionVariables(object: any | null, bindings: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  allowEvaluation(): void;

  predicateFormat(): NSString;
}
declare const NSPredicate: {
  alloc(): NSPredicateAllocator;  predicateWithFormat_argumentArray(predicateFormat: NSString | string, arguments: NSArray<any> | any[] | null): NSPredicate;
  predicateWithFormat(predicateFormat: NSString | string, ...args: any[]): NSPredicate;
  predicateWithFormat_arguments(predicateFormat: NSString | string, ...argList: any[]): NSPredicate;
  predicateFromMetadataQueryString(queryString: NSString | string): NSPredicate;
  predicateWithValue(value: boolean): NSPredicate;
  predicateWithBlock(block: Block): NSPredicate;

}

interface NSMutableSetAllocator<ObjectType, InitializedType = NSMutableSet<ObjectType>> extends NSSetAllocator<ObjectType, NSMutableSet<ObjectType>> {
  initWithCapacity(numItems: NSUInteger): InitializedType;
}
interface NSMutableSet<ObjectType> extends NSSet<ObjectType> {
  filterUsingPredicate(predicate: NSPredicate): void;
  addObject(object: ObjectType): void;
  removeObject(object: ObjectType): void;
  addObjectsFromArray(array: NSArray<any> | any[]): void;
  intersectSet(otherSet: NSSet<any>): void;
  minusSet(otherSet: NSSet<any>): void;
  removeAllObjects(): void;
  unionSet(otherSet: NSSet<any>): void;
  setSet(otherSet: NSSet<any>): void;
  addObjectIfNotNil(anObject: any): void;
}
declare const NSMutableSet: {
  alloc<ObjectType>(): NSMutableSetAllocator<ObjectType>;  setWithCapacity<ObjectType>(numItems: NSUInteger): NSMutableSet<ObjectType>;

}

interface NSProcessInfoAllocator<InitializedType = NSProcessInfo> extends NSObjectAllocator<NSProcessInfo> {}
interface NSProcessInfo extends NSObject {
  operatingSystem(): NSUInteger;
  operatingSystemName(): NSString;
  isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
  disableSuddenTermination(): void;
  enableSuddenTermination(): void;
  disableAutomaticTermination(reason: NSString | string): void;
  enableAutomaticTermination(reason: NSString | string): void;
  beginActivityWithOptions_reason(options: NSActivityOptions, reason: NSString | string): any;
  endActivity(activity: any): void;
  performActivityWithOptions_reason_usingBlock(options: NSActivityOptions, reason: NSString | string, block: Block): void;
  performExpiringActivityWithReason_usingBlock(reason: NSString | string, block: Block): void;

  environment(): NSDictionary<any, any>;
  arguments(): NSArray<any>;
  hostName(): NSString;
  processName(): NSString;
  setProcessName(processName: NSString | string): void;
  processIdentifier(): number;
  globallyUniqueString(): NSString;
  operatingSystemVersionString(): NSString;
  operatingSystemVersion(): NSOperatingSystemVersion;
  processorCount(): NSUInteger;
  activeProcessorCount(): NSUInteger;
  physicalMemory(): number;
  systemUptime(): NSTimeInterval;
  automaticTerminationSupportEnabled(): boolean;
  setAutomaticTerminationSupportEnabled(automaticTerminationSupportEnabled: boolean): void;
  userName(): NSString;
  fullUserName(): NSString;
  thermalState(): NSProcessInfoThermalState;
  lowPowerModeEnabled(): boolean;
}
declare const NSProcessInfo: {
  alloc(): NSProcessInfoAllocator;
  processInfo(): NSProcessInfo;

}

declare type NSOperatingSystemVersion = {
  majorVersion: NSInteger
  minorVersion: NSInteger
  patchVersion: NSInteger
}

declare enum NSActivityOptions {
  NSActivityIdleDisplaySleepDisabled,
  NSActivityIdleSystemSleepDisabled,
  NSActivitySuddenTerminationDisabled,
  NSActivityAutomaticTerminationDisabled,
  NSActivityUserInitiated,
  NSActivityUserInitiatedAllowingIdleSystemSleep,
  NSActivityBackground = 0x000000FF,
  NSActivityLatencyCritical = 0xFF00000000,
}

declare enum NSProcessInfoThermalState {
  NSProcessInfoThermalStateNominal,
  NSProcessInfoThermalStateFair,
  NSProcessInfoThermalStateSerious,
  NSProcessInfoThermalStateCritical,
}

interface NSProgressAllocator<InitializedType = NSProgress> extends NSObjectAllocator<NSProgress> {
  initWithParent_userInfo(parentProgressOrNil: NSProgress | null, userInfoOrNil: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface NSProgress extends NSObject {
  becomeCurrentWithPendingUnitCount(unitCount: number): void;
  performAsCurrentWithPendingUnitCount_usingBlock(unitCount: number, work: Block): void;
  resignCurrent(): void;
  addChild_withPendingUnitCount(child: NSProgress, inUnitCount: number): void;
  setUserInfoObject_forKey(objectOrNil: any | null, key: NSProgressUserInfoKey): void;
  cancel(): void;
  pause(): void;
  resume(): void;
  publish(): void;
  unpublish(): void;

  totalUnitCount(): number;
  setTotalUnitCount(totalUnitCount: number): void;
  completedUnitCount(): number;
  setCompletedUnitCount(completedUnitCount: number): void;
  localizedDescription(): NSString;
  setLocalizedDescription(localizedDescription: NSString | string): void;
  localizedAdditionalDescription(): NSString;
  setLocalizedAdditionalDescription(localizedAdditionalDescription: NSString | string): void;
  cancellable(): boolean;
  setCancellable(cancellable: boolean): void;
  pausable(): boolean;
  setPausable(pausable: boolean): void;
  cancelled(): boolean;
  paused(): boolean;
  indeterminate(): boolean;
  fractionCompleted(): number;
  finished(): boolean;
  userInfo(): NSDictionary<any, any>;
  kind(): NSProgressKind;
  setKind(kind: NSProgressKind): void;
  estimatedTimeRemaining(): NSNumber;
  setEstimatedTimeRemaining(estimatedTimeRemaining: NSNumber | number): void;
  throughput(): NSNumber;
  setThroughput(throughput: NSNumber | number): void;
  fileOperationKind(): NSProgressFileOperationKind;
  setFileOperationKind(fileOperationKind: NSProgressFileOperationKind): void;
  fileURL(): NSURL;
  setFileURL(fileURL: NSURL): void;
  fileTotalCount(): NSNumber;
  setFileTotalCount(fileTotalCount: NSNumber | number): void;
  fileCompletedCount(): NSNumber;
  setFileCompletedCount(fileCompletedCount: NSNumber | number): void;
  old(): boolean;
}
declare const NSProgress: {
  alloc(): NSProgressAllocator;  currentProgress(): NSProgress;
  progressWithTotalUnitCount(unitCount: number): NSProgress;
  discreteProgressWithTotalUnitCount(unitCount: number): NSProgress;
  progressWithTotalUnitCount_parent_pendingUnitCount(unitCount: number, parent: NSProgress, portionOfParentTotalUnitCount: number): NSProgress;
  addSubscriberForFileURL_withPublishingHandler(url: NSURL, publishingHandler: NSProgressPublishingHandler): any;
  removeSubscriber(subscriber: any): void;

}

interface INSProgressReporting {

  progress(): NSProgress;
}

declare type NSProgressKind = NSString

declare type NSProgressUserInfoKey = NSString

declare type NSProgressFileOperationKind = NSString

interface NSPropertyListSerializationAllocator<InitializedType = NSPropertyListSerialization> extends NSObjectAllocator<NSPropertyListSerialization> {}
interface NSPropertyListSerialization extends NSObject {
}
declare const NSPropertyListSerialization: {
  alloc(): NSPropertyListSerializationAllocator;  propertyList_isValidForFormat(plist: any, format: NSPropertyListFormat): boolean;
  dataWithPropertyList_format_options_error(plist: any, format: NSPropertyListFormat, opt: NSPropertyListWriteOptions, error: NSError): NSData;
  writePropertyList_toStream_format_options_error(plist: any, stream: NSOutputStream, format: NSPropertyListFormat, opt: NSPropertyListWriteOptions, error: NSError): NSInteger;
  propertyListWithData_options_format_error(data: NSData, opt: NSPropertyListReadOptions, format: NSPropertyListFormat | null, error: NSError): any;
  propertyListWithStream_options_format_error(stream: NSInputStream, opt: NSPropertyListReadOptions, format: NSPropertyListFormat | null, error: NSError): any;
  dataFromPropertyList_format_errorDescription(plist: any, format: NSPropertyListFormat, errorString: NSString | string): NSData;
  propertyListFromData_mutabilityOption_format_errorDescription(data: NSData, opt: NSPropertyListMutabilityOptions, format: NSPropertyListFormat | null, errorString: NSString | string): any;

}

declare type NSPropertyListReadOptions = NSPropertyListMutabilityOptions

declare type NSPropertyListWriteOptions = NSUInteger

declare enum NSPropertyListMutabilityOptions {
  NSPropertyListImmutable,
  NSPropertyListMutableContainers,
  NSPropertyListMutableContainersAndLeaves,
}

declare enum NSPropertyListFormat {
  NSPropertyListOpenStepFormat,
  NSPropertyListXMLFormat_v1_0,
  NSPropertyListBinaryFormat_v1_0,
}

interface NSProtocolCheckerAllocator<InitializedType = NSProtocolChecker> extends NSProxyAllocator<NSProtocolChecker> {
  initWithTarget_protocol(anObject: NSObject, aProtocol: Protocol): InitializedType;
}
interface NSProtocolChecker extends NSProxy {

  protocol(): Protocol;
  target(): NSObject;
}
declare const NSProtocolChecker: {
  alloc(): NSProtocolCheckerAllocator;  protocolCheckerWithTarget_protocol(anObject: NSObject, aProtocol: Protocol): NSProtocolChecker;

}

interface NSProxyAllocator<InitializedType = NSProxy> {}
interface NSProxy {
  forwardInvocation(invocation: NSInvocation): void;
  methodSignatureForSelector(sel: string): NSMethodSignature;
  dealloc(): void;
  finalize(): void;

  description(): NSString;
  debugDescription(): NSString;
}
declare const NSProxy: {
  alloc(): NSProxyAllocator;  alloc(): any;
  class(): any;
  respondsToSelector(aSelector: string): boolean;

}

declare type NSRange = {
  location: NSUInteger
  length: NSUInteger
}

declare type NSRangePointer = NSRange

interface NSRegularExpressionAllocator<InitializedType = NSRegularExpression> extends NSObjectAllocator<NSRegularExpression> {
  initWithPattern_options_error(pattern: NSString | string, options: NSRegularExpressionOptions, error: NSError): InitializedType;
}
interface NSRegularExpression extends NSObject, INSCopying, INSSecureCoding {
  enumerateMatchesInString_options_range_usingBlock(string: NSString | string, options: NSMatchingOptions, range: NSRange, block: Block): void;
  matchesInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSArray<any>;
  numberOfMatchesInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSUInteger;
  firstMatchInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSTextCheckingResult;
  rangeOfFirstMatchInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSRange;
  stringByReplacingMatchesInString_options_range_withTemplate(string: NSString | string, options: NSMatchingOptions, range: NSRange, templ: NSString | string): NSString;
  replaceMatchesInString_options_range_withTemplate(string: NSMutableString, options: NSMatchingOptions, range: NSRange, templ: NSString | string): NSUInteger;
  replacementStringForResult_inString_offset_template(result: NSTextCheckingResult, string: NSString | string, offset: NSInteger, templ: NSString | string): NSString;

  pattern(): NSString;
  options(): NSRegularExpressionOptions;
  numberOfCaptureGroups(): NSUInteger;
}
declare const NSRegularExpression: {
  alloc(): NSRegularExpressionAllocator;  regularExpressionWithPattern_options_error(pattern: NSString | string, options: NSRegularExpressionOptions, error: NSError): NSRegularExpression;
  escapedPatternForString(string: NSString | string): NSString;
  escapedTemplateForString(string: NSString | string): NSString;

}

interface NSDataDetectorAllocator<InitializedType = NSDataDetector> extends NSRegularExpressionAllocator<NSDataDetector> {
  initWithTypes_error(checkingTypes: NSTextCheckingTypes, error: NSError): InitializedType;
}
interface NSDataDetector extends NSRegularExpression {

  checkingTypes(): NSTextCheckingTypes;
}
declare const NSDataDetector: {
  alloc(): NSDataDetectorAllocator;  dataDetectorWithTypes_error(checkingTypes: NSTextCheckingTypes, error: NSError): NSDataDetector;

}

declare enum NSRegularExpressionOptions {
  NSRegularExpressionCaseInsensitive = 1 << 0,
  NSRegularExpressionAllowCommentsAndWhitespace = 1 << 1,
  NSRegularExpressionIgnoreMetacharacters = 1 << 2,
  NSRegularExpressionDotMatchesLineSeparators = 1 << 3,
  NSRegularExpressionAnchorsMatchLines = 1 << 4,
  NSRegularExpressionUseUnixLineSeparators = 1 << 5,
  NSRegularExpressionUseUnicodeWordBoundaries = 1 << 6,
}

declare enum NSMatchingOptions {
  NSMatchingReportProgress = 1 << 0,
  NSMatchingReportCompletion = 1 << 1,
  NSMatchingAnchored = 1 << 2,
  NSMatchingWithTransparentBounds = 1 << 3,
  NSMatchingWithoutAnchoringBounds = 1 << 4,
}

declare enum NSMatchingFlags {
  NSMatchingProgress = 1 << 0,
  NSMatchingCompleted = 1 << 1,
  NSMatchingHitEnd = 1 << 2,
  NSMatchingRequiredEnd = 1 << 3,
  NSMatchingInternalError = 1 << 4,
}

interface NSRunLoopAllocator<InitializedType = NSRunLoop> extends NSObjectAllocator<NSRunLoop> {}
interface NSRunLoop extends NSObject {
  addTimer_forMode(timer: NSTimer, mode: NSRunLoopMode): void;
  addPort_forMode(aPort: NSPort, mode: NSRunLoopMode): void;
  removePort_forMode(aPort: NSPort, mode: NSRunLoopMode): void;
  limitDateForMode(mode: NSRunLoopMode): NSDate;
  acceptInputForMode_beforeDate(mode: NSRunLoopMode, limitDate: NSDate): void;
  run(): void;
  runUntilDate(limitDate: NSDate): void;
  runMode_beforeDate(mode: NSRunLoopMode, limitDate: NSDate): boolean;
  configureAsServer(): void;
  performInModes_block(modes: NSArray<any> | any[], block: Block): void;
  performBlock(block: Block): void;
  performSelector_target_argument_order_modes(aSelector: string, target: any, arg: any | null, order: NSUInteger, modes: NSArray<any> | any[]): void;
  cancelPerformSelector_target_argument(aSelector: string, target: any, arg: any | null): void;
  cancelPerformSelectorsWithTarget(target: any): void;

  currentMode(): NSRunLoopMode;
}
declare const NSRunLoop: {
  alloc(): NSRunLoopAllocator;
  currentRunLoop(): NSRunLoop;
  mainRunLoop(): NSRunLoop;

}

interface NSScriptClassDescriptionAllocator<InitializedType = NSScriptClassDescription> extends NSClassDescriptionAllocator<NSScriptClassDescription> {
  initWithSuiteName_className_dictionary(suiteName: NSString | string, className: NSString | string, classDeclaration: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface NSScriptClassDescription extends NSClassDescription {
  matchesAppleEventCode(appleEventCode: number): boolean;
  supportsCommand(commandDescription: NSScriptCommandDescription): boolean;
  selectorForCommand(commandDescription: NSScriptCommandDescription): string;
  typeForKey(key: NSString | string): NSString;
  classDescriptionForKey(key: NSString | string): NSScriptClassDescription;
  appleEventCodeForKey(key: NSString | string): number;
  keyWithAppleEventCode(appleEventCode: number): NSString;
  isLocationRequiredToCreateForKey(toManyRelationshipKey: NSString | string): boolean;
  hasPropertyForKey(key: NSString | string): boolean;
  hasOrderedToManyRelationshipForKey(key: NSString | string): boolean;
  hasReadablePropertyForKey(key: NSString | string): boolean;
  hasWritablePropertyForKey(key: NSString | string): boolean;
  isReadOnlyKey(key: NSString | string): boolean;

  suiteName(): NSString;
  className(): NSString;
  implementationClassName(): NSString;
  superclassDescription(): NSScriptClassDescription;
  appleEventCode(): number;
  defaultSubcontainerAttributeKey(): NSString;
}
declare const NSScriptClassDescription: {
  alloc(): NSScriptClassDescriptionAllocator;  classDescriptionForClass(aClass: any): NSScriptClassDescription;

}

interface NSScriptCoercionHandlerAllocator<InitializedType = NSScriptCoercionHandler> extends NSObjectAllocator<NSScriptCoercionHandler> {}
interface NSScriptCoercionHandler extends NSObject {
  coerceValue_toClass(value: any, toClass: any): any;
  registerCoercer_selector_toConvertFromClass_toClass(coercer: any, selector: string, fromClass: any, toClass: any): void;
}
declare const NSScriptCoercionHandler: {
  alloc(): NSScriptCoercionHandlerAllocator;  sharedCoercionHandler(): NSScriptCoercionHandler;

}

interface NSScriptCommandAllocator<InitializedType = NSScriptCommand> extends NSObjectAllocator<NSScriptCommand> {
  initWithCommandDescription(commandDef: NSScriptCommandDescription): InitializedType;
  initWithCoder(inCoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSScriptCommand extends NSObject, INSCoding {
  performDefaultImplementation(): any;
  executeCommand(): any;
  suspendExecution(): void;
  resumeExecutionWithResult(result: any | null): void;

  commandDescription(): NSScriptCommandDescription;
  directParameter(): any;
  setDirectParameter(directParameter: any): void;
  receiversSpecifier(): NSScriptObjectSpecifier;
  setReceiversSpecifier(receiversSpecifier: NSScriptObjectSpecifier): void;
  evaluatedReceivers(): any;
  arguments(): NSDictionary<any, any>;
  setArguments(arguments: NSDictionary<any, any> | {[key: string]: any}): void;
  evaluatedArguments(): NSDictionary<any, any>;
  wellFormed(): boolean;
  scriptErrorNumber(): NSInteger;
  setScriptErrorNumber(scriptErrorNumber: NSInteger): void;
  scriptErrorOffendingObjectDescriptor(): NSAppleEventDescriptor;
  setScriptErrorOffendingObjectDescriptor(scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptor): void;
  scriptErrorExpectedTypeDescriptor(): NSAppleEventDescriptor;
  setScriptErrorExpectedTypeDescriptor(scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptor): void;
  scriptErrorString(): NSString;
  setScriptErrorString(scriptErrorString: NSString | string): void;
  appleEvent(): NSAppleEventDescriptor;
}
declare const NSScriptCommand: {
  alloc(): NSScriptCommandAllocator;  currentCommand(): NSScriptCommand;

}

interface NSScriptCommandDescriptionAllocator<InitializedType = NSScriptCommandDescription> extends NSObjectAllocator<NSScriptCommandDescription> {
  initWithSuiteName_commandName_dictionary(suiteName: NSString | string, commandName: NSString | string, commandDeclaration: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
  initWithCoder(inCoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSScriptCommandDescription extends NSObject, INSCoding {
  typeForArgumentWithName(argumentName: NSString | string): NSString;
  appleEventCodeForArgumentWithName(argumentName: NSString | string): number;
  isOptionalArgumentWithName(argumentName: NSString | string): boolean;
  createCommandInstance(): NSScriptCommand;
  createCommandInstanceWithZone(zone: NSZone | null): NSScriptCommand;

  suiteName(): NSString;
  commandName(): NSString;
  appleEventClassCode(): number;
  appleEventCode(): number;
  commandClassName(): NSString;
  returnType(): NSString;
  appleEventCodeForReturnType(): number;
  argumentNames(): NSArray<any>;
}
declare const NSScriptCommandDescription: {
  alloc(): NSScriptCommandDescriptionAllocator;
}

interface NSScriptExecutionContextAllocator<InitializedType = NSScriptExecutionContext> extends NSObjectAllocator<NSScriptExecutionContext> {}
interface NSScriptExecutionContext extends NSObject {

  topLevelObject(): any;
  setTopLevelObject(topLevelObject: any): void;
  objectBeingTested(): any;
  setObjectBeingTested(objectBeingTested: any): void;
  rangeContainerObject(): any;
  setRangeContainerObject(rangeContainerObject: any): void;
}
declare const NSScriptExecutionContext: {
  alloc(): NSScriptExecutionContextAllocator;  sharedScriptExecutionContext(): NSScriptExecutionContext;

}

interface NSScriptObjectSpecifierAllocator<InitializedType = NSScriptObjectSpecifier> extends NSObjectAllocator<NSScriptObjectSpecifier> {
  initWithContainerSpecifier_key(container: NSScriptObjectSpecifier, property: NSString | string): InitializedType;
  initWithContainerClassDescription_containerSpecifier_key(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string): InitializedType;
  initWithCoder(inCoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSScriptObjectSpecifier extends NSObject, INSCoding {
  indicesOfObjectsByEvaluatingWithContainer_count(container: any, count: NSInteger): NSInteger;
  objectsByEvaluatingWithContainers(containers: any): any;

  childSpecifier(): NSScriptObjectSpecifier;
  setChildSpecifier(childSpecifier: NSScriptObjectSpecifier): void;
  containerSpecifier(): NSScriptObjectSpecifier;
  setContainerSpecifier(containerSpecifier: NSScriptObjectSpecifier): void;
  containerIsObjectBeingTested(): boolean;
  setContainerIsObjectBeingTested(containerIsObjectBeingTested: boolean): void;
  containerIsRangeContainerObject(): boolean;
  setContainerIsRangeContainerObject(containerIsRangeContainerObject: boolean): void;
  key(): NSString;
  setKey(key: NSString | string): void;
  containerClassDescription(): NSScriptClassDescription;
  setContainerClassDescription(containerClassDescription: NSScriptClassDescription): void;
  keyClassDescription(): NSScriptClassDescription;
  objectsByEvaluatingSpecifier(): any;
  evaluationErrorNumber(): NSInteger;
  setEvaluationErrorNumber(evaluationErrorNumber: NSInteger): void;
  evaluationErrorSpecifier(): NSScriptObjectSpecifier;
  descriptor(): NSAppleEventDescriptor;
}
declare const NSScriptObjectSpecifier: {
  alloc(): NSScriptObjectSpecifierAllocator;  objectSpecifierWithDescriptor(descriptor: NSAppleEventDescriptor): NSScriptObjectSpecifier;

}

interface NSIndexSpecifierAllocator<InitializedType = NSIndexSpecifier> extends NSScriptObjectSpecifierAllocator<NSIndexSpecifier> {
  initWithContainerClassDescription_containerSpecifier_key_index(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, index: NSInteger): InitializedType;
}
interface NSIndexSpecifier extends NSScriptObjectSpecifier {

  index(): NSInteger;
  setIndex(index: NSInteger): void;
}
declare const NSIndexSpecifier: {
  alloc(): NSIndexSpecifierAllocator;
}

interface NSMiddleSpecifierAllocator<InitializedType = NSMiddleSpecifier> extends NSScriptObjectSpecifierAllocator<NSMiddleSpecifier> {}
interface NSMiddleSpecifier extends NSScriptObjectSpecifier {
}
declare const NSMiddleSpecifier: {
  alloc(): NSMiddleSpecifierAllocator;
}

interface NSNameSpecifierAllocator<InitializedType = NSNameSpecifier> extends NSScriptObjectSpecifierAllocator<NSNameSpecifier> {
  initWithContainerClassDescription_containerSpecifier_key_name(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, name: NSString | string): InitializedType;
}
interface NSNameSpecifier extends NSScriptObjectSpecifier {

  name(): NSString;
  setName(name: NSString | string): void;
}
declare const NSNameSpecifier: {
  alloc(): NSNameSpecifierAllocator;
}

interface NSPositionalSpecifierAllocator<InitializedType = NSPositionalSpecifier> extends NSObjectAllocator<NSPositionalSpecifier> {
  initWithPosition_objectSpecifier(position: NSInsertionPosition, specifier: NSScriptObjectSpecifier): InitializedType;
}
interface NSPositionalSpecifier extends NSObject {
  setInsertionClassDescription(classDescription: NSScriptClassDescription): void;
  evaluate(): void;

  position(): NSInsertionPosition;
  objectSpecifier(): NSScriptObjectSpecifier;
  insertionContainer(): any;
  insertionKey(): NSString;
  insertionIndex(): NSInteger;
  insertionReplaces(): boolean;
}
declare const NSPositionalSpecifier: {
  alloc(): NSPositionalSpecifierAllocator;
}

interface NSPropertySpecifierAllocator<InitializedType = NSPropertySpecifier> extends NSScriptObjectSpecifierAllocator<NSPropertySpecifier> {}
interface NSPropertySpecifier extends NSScriptObjectSpecifier {
}
declare const NSPropertySpecifier: {
  alloc(): NSPropertySpecifierAllocator;
}

interface NSRandomSpecifierAllocator<InitializedType = NSRandomSpecifier> extends NSScriptObjectSpecifierAllocator<NSRandomSpecifier> {}
interface NSRandomSpecifier extends NSScriptObjectSpecifier {
}
declare const NSRandomSpecifier: {
  alloc(): NSRandomSpecifierAllocator;
}

interface NSRangeSpecifierAllocator<InitializedType = NSRangeSpecifier> extends NSScriptObjectSpecifierAllocator<NSRangeSpecifier> {
  initWithContainerClassDescription_containerSpecifier_key_startSpecifier_endSpecifier(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, startSpec: NSScriptObjectSpecifier | null, endSpec: NSScriptObjectSpecifier | null): InitializedType;
}
interface NSRangeSpecifier extends NSScriptObjectSpecifier {

  startSpecifier(): NSScriptObjectSpecifier;
  setStartSpecifier(startSpecifier: NSScriptObjectSpecifier): void;
  endSpecifier(): NSScriptObjectSpecifier;
  setEndSpecifier(endSpecifier: NSScriptObjectSpecifier): void;
}
declare const NSRangeSpecifier: {
  alloc(): NSRangeSpecifierAllocator;
}

interface NSRelativeSpecifierAllocator<InitializedType = NSRelativeSpecifier> extends NSScriptObjectSpecifierAllocator<NSRelativeSpecifier> {
  initWithContainerClassDescription_containerSpecifier_key_relativePosition_baseSpecifier(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, relPos: NSRelativePosition, baseSpecifier: NSScriptObjectSpecifier | null): InitializedType;
}
interface NSRelativeSpecifier extends NSScriptObjectSpecifier {

  relativePosition(): NSRelativePosition;
  setRelativePosition(relativePosition: NSRelativePosition): void;
  baseSpecifier(): NSScriptObjectSpecifier;
  setBaseSpecifier(baseSpecifier: NSScriptObjectSpecifier): void;
}
declare const NSRelativeSpecifier: {
  alloc(): NSRelativeSpecifierAllocator;
}

interface NSUniqueIDSpecifierAllocator<InitializedType = NSUniqueIDSpecifier> extends NSScriptObjectSpecifierAllocator<NSUniqueIDSpecifier> {
  initWithContainerClassDescription_containerSpecifier_key_uniqueID(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, uniqueID: any): InitializedType;
}
interface NSUniqueIDSpecifier extends NSScriptObjectSpecifier {

  uniqueID(): any;
  setUniqueID(uniqueID: any): void;
}
declare const NSUniqueIDSpecifier: {
  alloc(): NSUniqueIDSpecifierAllocator;
}

interface NSWhoseSpecifierAllocator<InitializedType = NSWhoseSpecifier> extends NSScriptObjectSpecifierAllocator<NSWhoseSpecifier> {
  initWithContainerClassDescription_containerSpecifier_key_test(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, test: NSScriptWhoseTest): InitializedType;
}
interface NSWhoseSpecifier extends NSScriptObjectSpecifier {

  test(): NSScriptWhoseTest;
  setTest(test: NSScriptWhoseTest): void;
  startSubelementIdentifier(): NSWhoseSubelementIdentifier;
  setStartSubelementIdentifier(startSubelementIdentifier: NSWhoseSubelementIdentifier): void;
  startSubelementIndex(): NSInteger;
  setStartSubelementIndex(startSubelementIndex: NSInteger): void;
  endSubelementIdentifier(): NSWhoseSubelementIdentifier;
  setEndSubelementIdentifier(endSubelementIdentifier: NSWhoseSubelementIdentifier): void;
  endSubelementIndex(): NSInteger;
  setEndSubelementIndex(endSubelementIndex: NSInteger): void;
}
declare const NSWhoseSpecifier: {
  alloc(): NSWhoseSpecifierAllocator;
}

declare enum NSInsertionPosition {
  NSPositionAfter,
  NSPositionBefore,
  NSPositionBeginning,
  NSPositionEnd,
  NSPositionReplace,
}

declare enum NSRelativePosition {
  NSRelativeAfter = 0,
  NSRelativeBefore,
}

declare enum NSWhoseSubelementIdentifier {
  NSIndexSubelement = 0,
  NSEverySubelement = 1,
  NSMiddleSubelement = 2,
  NSRandomSubelement = 3,
  NSNoSubelement = 4,
}

interface NSCloneCommandAllocator<InitializedType = NSCloneCommand> extends NSScriptCommandAllocator<NSCloneCommand> {}
interface NSCloneCommand extends NSScriptCommand {
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}
declare const NSCloneCommand: {
  alloc(): NSCloneCommandAllocator;
}

interface NSCloseCommandAllocator<InitializedType = NSCloseCommand> extends NSScriptCommandAllocator<NSCloseCommand> {}
interface NSCloseCommand extends NSScriptCommand {

  saveOptions(): NSSaveOptions;
}
declare const NSCloseCommand: {
  alloc(): NSCloseCommandAllocator;
}

interface NSCountCommandAllocator<InitializedType = NSCountCommand> extends NSScriptCommandAllocator<NSCountCommand> {}
interface NSCountCommand extends NSScriptCommand {
}
declare const NSCountCommand: {
  alloc(): NSCountCommandAllocator;
}

interface NSCreateCommandAllocator<InitializedType = NSCreateCommand> extends NSScriptCommandAllocator<NSCreateCommand> {}
interface NSCreateCommand extends NSScriptCommand {

  createClassDescription(): NSScriptClassDescription;
  resolvedKeyDictionary(): NSDictionary<any, any>;
}
declare const NSCreateCommand: {
  alloc(): NSCreateCommandAllocator;
}

interface NSDeleteCommandAllocator<InitializedType = NSDeleteCommand> extends NSScriptCommandAllocator<NSDeleteCommand> {}
interface NSDeleteCommand extends NSScriptCommand {
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}
declare const NSDeleteCommand: {
  alloc(): NSDeleteCommandAllocator;
}

interface NSExistsCommandAllocator<InitializedType = NSExistsCommand> extends NSScriptCommandAllocator<NSExistsCommand> {}
interface NSExistsCommand extends NSScriptCommand {
}
declare const NSExistsCommand: {
  alloc(): NSExistsCommandAllocator;
}

interface NSGetCommandAllocator<InitializedType = NSGetCommand> extends NSScriptCommandAllocator<NSGetCommand> {}
interface NSGetCommand extends NSScriptCommand {
}
declare const NSGetCommand: {
  alloc(): NSGetCommandAllocator;
}

interface NSMoveCommandAllocator<InitializedType = NSMoveCommand> extends NSScriptCommandAllocator<NSMoveCommand> {}
interface NSMoveCommand extends NSScriptCommand {
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}
declare const NSMoveCommand: {
  alloc(): NSMoveCommandAllocator;
}

interface NSQuitCommandAllocator<InitializedType = NSQuitCommand> extends NSScriptCommandAllocator<NSQuitCommand> {}
interface NSQuitCommand extends NSScriptCommand {

  saveOptions(): NSSaveOptions;
}
declare const NSQuitCommand: {
  alloc(): NSQuitCommandAllocator;
}

interface NSSetCommandAllocator<InitializedType = NSSetCommand> extends NSScriptCommandAllocator<NSSetCommand> {}
interface NSSetCommand extends NSScriptCommand {
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}
declare const NSSetCommand: {
  alloc(): NSSetCommandAllocator;
}

declare enum NSSaveOptions {
  NSSaveOptionsYes = 0,
  NSSaveOptionsNo,
  NSSaveOptionsAsk,
}

interface NSScriptSuiteRegistryAllocator<InitializedType = NSScriptSuiteRegistry> extends NSObjectAllocator<NSScriptSuiteRegistry> {}
interface NSScriptSuiteRegistry extends NSObject {
  loadSuitesFromBundle(bundle: NSBundle): void;
  loadSuiteWithDictionary_fromBundle(suiteDeclaration: NSDictionary<any, any> | {[key: string]: any}, bundle: NSBundle): void;
  registerClassDescription(classDescription: NSScriptClassDescription): void;
  registerCommandDescription(commandDescription: NSScriptCommandDescription): void;
  appleEventCodeForSuite(suiteName: NSString | string): number;
  bundleForSuite(suiteName: NSString | string): NSBundle;
  classDescriptionsInSuite(suiteName: NSString | string): NSDictionary<any, any>;
  commandDescriptionsInSuite(suiteName: NSString | string): NSDictionary<any, any>;
  suiteForAppleEventCode(appleEventCode: number): NSString;
  classDescriptionWithAppleEventCode(appleEventCode: number): NSScriptClassDescription;
  commandDescriptionWithAppleEventClass_andAppleEventCode(appleEventClassCode: number, appleEventIDCode: number): NSScriptCommandDescription;
  aeteResource(languageName: NSString | string): NSData;

  suiteNames(): NSArray<any>;
}
declare const NSScriptSuiteRegistry: {
  alloc(): NSScriptSuiteRegistryAllocator;  sharedScriptSuiteRegistry(): NSScriptSuiteRegistry;
  setSharedScriptSuiteRegistry(registry: NSScriptSuiteRegistry): void;

}

interface NSScriptWhoseTestAllocator<InitializedType = NSScriptWhoseTest> extends NSObjectAllocator<NSScriptWhoseTest> {
  init(): InitializedType;
  initWithCoder(inCoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSScriptWhoseTest extends NSObject, INSCoding {
  isTrue(): boolean;
}
declare const NSScriptWhoseTest: {
  alloc(): NSScriptWhoseTestAllocator;
}

interface NSLogicalTestAllocator<InitializedType = NSLogicalTest> extends NSScriptWhoseTestAllocator<NSLogicalTest> {
  initAndTestWithTests(subTests: NSArray<any> | any[]): InitializedType;
  initOrTestWithTests(subTests: NSArray<any> | any[]): InitializedType;
  initNotTestWithTest(subTest: NSScriptWhoseTest): InitializedType;
}
interface NSLogicalTest extends NSScriptWhoseTest {
}
declare const NSLogicalTest: {
  alloc(): NSLogicalTestAllocator;
}

interface NSSpecifierTestAllocator<InitializedType = NSSpecifierTest> extends NSScriptWhoseTestAllocator<NSSpecifierTest> {
  initWithObjectSpecifier_comparisonOperator_testObject(obj1: NSScriptObjectSpecifier | null, compOp: NSTestComparisonOperation, obj2: any | null): InitializedType;
}
interface NSSpecifierTest extends NSScriptWhoseTest {
}
declare const NSSpecifierTest: {
  alloc(): NSSpecifierTestAllocator;
}

declare enum NSTestComparisonOperation {
  NSEqualToComparison = 0,
  NSLessThanOrEqualToComparison,
  NSLessThanComparison,
  NSGreaterThanOrEqualToComparison,
  NSGreaterThanComparison,
  NSBeginsWithComparison,
  NSEndsWithComparison,
  NSContainsComparison,
}

interface NSCountedSetAllocator<ObjectType, InitializedType = NSCountedSet<ObjectType>> extends NSMutableSetAllocator<ObjectType, NSCountedSet<ObjectType>> {}
interface NSCountedSet<ObjectType> extends NSMutableSet<ObjectType> {
  countForObject(object: ObjectType): NSUInteger;
  objectEnumerator(): NSEnumerator<any>;
  addObject(object: ObjectType): void;
  removeObject(object: ObjectType): void;
}
declare const NSCountedSet: {
  alloc<ObjectType>(): NSCountedSetAllocator<ObjectType>;
}

interface NSSortDescriptorAllocator<InitializedType = NSSortDescriptor> extends NSObjectAllocator<NSSortDescriptor> {
  initWithKey_ascending(key: NSString | string | null, ascending: boolean): InitializedType;
  initWithKey_ascending_selector(key: NSString | string | null, ascending: boolean, selector: string | null): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithKey_ascending_comparator(key: NSString | string | null, ascending: boolean, cmptr: NSComparator): InitializedType;
}
interface NSSortDescriptor extends NSObject, INSSecureCoding, INSCopying {
  allowEvaluation(): void;
  compareObject_toObject(object1: any, object2: any): NSComparisonResult;

  key(): NSString;
  ascending(): boolean;
  selector(): string;
  comparator(): NSComparator;
  reversedSortDescriptor(): any;
}
declare const NSSortDescriptor: {
  alloc(): NSSortDescriptorAllocator;  sortDescriptorWithKey_ascending(key: NSString | string | null, ascending: boolean): NSSortDescriptor;
  sortDescriptorWithKey_ascending_selector(key: NSString | string | null, ascending: boolean, selector: string | null): NSSortDescriptor;
  sortDescriptorWithKey_ascending_comparator(key: NSString | string | null, ascending: boolean, cmptr: NSComparator): NSSortDescriptor;
  localizedCaseInsensitiveSortDescriptorWithKey_ascending(key: NSString | string | null, ascending: boolean): NSSortDescriptor;

}

interface NSSpellServerAllocator<InitializedType = NSSpellServer> extends NSObjectAllocator<NSSpellServer> {}
interface NSSpellServer extends NSObject {
  registerLanguage_byVendor(language: NSString | string | null, vendor: NSString | string | null): boolean;
  isWordInUserDictionaries_caseSensitive(word: NSString | string, flag: boolean): boolean;
  run(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const NSSpellServer: {
  alloc(): NSSpellServerAllocator;
}

interface INSSpellServerDelegate {
  spellServer_findMisspelledWordInString_language_wordCount_countOnly(sender: NSSpellServer, stringToCheck: NSString | string, language: NSString | string, wordCount: NSInteger, countOnly: boolean): NSRange;
  spellServer_suggestGuessesForWord_inLanguage(sender: NSSpellServer, word: NSString | string, language: NSString | string): NSArray<any>;
  spellServer_didLearnWord_inLanguage(sender: NSSpellServer, word: NSString | string, language: NSString | string): void;
  spellServer_didForgetWord_inLanguage(sender: NSSpellServer, word: NSString | string, language: NSString | string): void;
  spellServer_suggestCompletionsForPartialWordRange_inString_language(sender: NSSpellServer, range: NSRange, string: NSString | string, language: NSString | string): NSArray<any>;
  spellServer_checkGrammarInString_language_details(sender: NSSpellServer, stringToCheck: NSString | string, language: NSString | string | null, details: NSArray<any> | any[]): NSRange;
  spellServer_checkString_offset_types_options_orthography_wordCount(sender: NSSpellServer, stringToCheck: NSString | string, offset: NSUInteger, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, orthography: NSOrthography | null, wordCount: NSInteger): NSArray<any>;
  spellServer_recordResponse_toCorrection_forWord_language(sender: NSSpellServer, response: NSUInteger, correction: NSString | string, word: NSString | string, language: NSString | string): void;
}

interface NSStreamAllocator<InitializedType = NSStream> extends NSObjectAllocator<NSStream> {}
interface NSStream extends NSObject {
  open(): void;
  close(): void;
  propertyForKey(key: NSStreamPropertyKey): any;
  setProperty_forKey(property: any | null, key: NSStreamPropertyKey): boolean;
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  streamStatus(): NSStreamStatus;
  streamError(): NSError;
}
declare const NSStream: {
  alloc(): NSStreamAllocator;  getStreamsToHostWithName_port_inputStream_outputStream(hostname: NSString | string, port: NSInteger, inputStream: NSInputStream, outputStream: NSOutputStream): void;
  getStreamsToHost_port_inputStream_outputStream(host: NSHost, port: NSInteger, inputStream: NSInputStream, outputStream: NSOutputStream): void;
  getBoundStreamsWithBufferSize_inputStream_outputStream(bufferSize: NSUInteger, inputStream: NSInputStream, outputStream: NSOutputStream): void;

}

interface NSInputStreamAllocator<InitializedType = NSInputStream> extends NSStreamAllocator<NSInputStream> {
  initWithData(data: NSData): InitializedType;
  initWithURL(url: NSURL): InitializedType;
  initWithFileAtPath(path: NSString | string): InitializedType;
}
interface NSInputStream extends NSStream {
  read_maxLength(buffer: number, len: NSUInteger): NSInteger;
  getBuffer_length(buffer: number, len: NSUInteger): boolean;

  hasBytesAvailable(): boolean;
}
declare const NSInputStream: {
  alloc(): NSInputStreamAllocator;  inputStreamWithData(data: NSData): NSInputStream;
  inputStreamWithFileAtPath(path: NSString | string): NSInputStream;
  inputStreamWithURL(url: NSURL): NSInputStream;

}

interface NSOutputStreamAllocator<InitializedType = NSOutputStream> extends NSStreamAllocator<NSOutputStream> {
  initToMemory(): InitializedType;
  initToBuffer_capacity(buffer: number, capacity: NSUInteger): InitializedType;
  initWithURL_append(url: NSURL, shouldAppend: boolean): InitializedType;
  initToFileAtPath_append(path: NSString | string, shouldAppend: boolean): InitializedType;
}
interface NSOutputStream extends NSStream {
  write_maxLength(buffer: number, len: NSUInteger): NSInteger;

  hasSpaceAvailable(): boolean;
}
declare const NSOutputStream: {
  alloc(): NSOutputStreamAllocator;  outputStreamToMemory(): NSOutputStream;
  outputStreamToBuffer_capacity(buffer: number, capacity: NSUInteger): NSOutputStream;
  outputStreamToFileAtPath_append(path: NSString | string, shouldAppend: boolean): NSOutputStream;
  outputStreamWithURL_append(url: NSURL, shouldAppend: boolean): NSOutputStream;

}

interface INSStreamDelegate {
  stream_handleEvent(aStream: NSStream, eventCode: NSStreamEvent): void;
}

declare type NSStreamPropertyKey = NSString

declare type NSStreamSocketSecurityLevel = NSString

declare type NSStreamSOCKSProxyConfiguration = NSString

declare type NSStreamSOCKSProxyVersion = NSString

declare type NSStreamNetworkServiceTypeValue = NSString

declare enum NSStreamStatus {
  NSStreamStatusNotOpen = 0,
  NSStreamStatusOpening = 1,
  NSStreamStatusOpen = 2,
  NSStreamStatusReading = 3,
  NSStreamStatusWriting = 4,
  NSStreamStatusAtEnd = 5,
  NSStreamStatusClosed = 6,
  NSStreamStatusError = 7,
}

declare enum NSStreamEvent {
  NSStreamEventNone = 0,
  NSStreamEventOpenCompleted = 1 << 0,
  NSStreamEventHasBytesAvailable = 1 << 1,
  NSStreamEventHasSpaceAvailable = 1 << 2,
  NSStreamEventErrorOccurred = 1 << 3,
  NSStreamEventEndEncountered = 1 << 4,
}

interface NSMutableStringAllocator<InitializedType = NSMutableString> extends NSStringAllocator<NSMutableString> {
  initWithCapacity(capacity: NSUInteger): InitializedType;
}
interface NSMutableString extends NSString {
  replaceCharactersInRange_withString(range: NSRange, aString: NSString | string): void;
  insertString_atIndex(aString: NSString | string, loc: NSUInteger): void;
  deleteCharactersInRange(range: NSRange): void;
  appendString(aString: NSString | string): void;
  appendFormat(format: NSString | string, ...args: any[]): void;
  setString(aString: NSString | string): void;
  replaceOccurrencesOfString_withString_options_range(target: NSString | string, replacement: NSString | string, options: NSStringCompareOptions, searchRange: NSRange): NSUInteger;
  applyTransform_reverse_range_updatedRange(transform: NSStringTransform, reverse: boolean, range: NSRange, resultingRange: NSRangePointer | null): boolean;
}
declare const NSMutableString: {
  alloc(): NSMutableStringAllocator;  stringWithCapacity(capacity: NSUInteger): NSMutableString;

}

interface NSSimpleCStringAllocator<InitializedType = NSSimpleCString> extends NSStringAllocator<NSSimpleCString> {}
interface NSSimpleCString extends NSString {
}
declare const NSSimpleCString: {
  alloc(): NSSimpleCStringAllocator;
}

interface NSConstantStringAllocator<InitializedType = NSConstantString> extends NSSimpleCStringAllocator<NSConstantString> {}
interface NSConstantString extends NSSimpleCString {
}
declare const NSConstantString: {
  alloc(): NSConstantStringAllocator;
}

declare type unichar = number

declare type NSStringEncoding = NSUInteger

declare type NSStringTransform = NSString

declare type NSStringEncodingDetectionOptionsKey = NSString

declare enum NSStringCompareOptions {
  NSCaseInsensitiveSearch = 1,
  NSLiteralSearch = 2,
  NSBackwardsSearch = 4,
  NSAnchoredSearch = 8,
  NSNumericSearch = 64,
  NSDiacriticInsensitiveSearch = 128,
  NSWidthInsensitiveSearch = 256,
  NSForcedOrderingSearch = 512,
  NSRegularExpressionSearch = 1024,
}

declare enum NSStringEncodingConversionOptions {
  NSStringEncodingConversionAllowLossy = 1,
  NSStringEncodingConversionExternalRepresentation = 2,
}

declare enum NSStringEnumerationOptions {
  NSStringEnumerationByLines = 0,
  NSStringEnumerationByParagraphs = 1,
  NSStringEnumerationByComposedCharacterSequences = 2,
  NSStringEnumerationByWords = 3,
  NSStringEnumerationBySentences = 4,
  NSStringEnumerationReverse = 1 << 8,
  NSStringEnumerationSubstringNotRequired = 1 << 9,
  NSStringEnumerationLocalized = 1 << 10,
}

interface NSTaskAllocator<InitializedType = NSTask> extends NSObjectAllocator<NSTask> {
  init(): InitializedType;
}
interface NSTask extends NSObject {
  launchAndReturnError(error: NSError): boolean;
  interrupt(): void;
  terminate(): void;
  suspend(): boolean;
  resume(): boolean;
  waitUntilExit(): void;
  launch(): void;

  executableURL(): NSURL;
  setExecutableURL(executableURL: NSURL): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  environment(): NSDictionary<any, any>;
  setEnvironment(environment: NSDictionary<any, any> | {[key: string]: any}): void;
  currentDirectoryURL(): NSURL;
  setCurrentDirectoryURL(currentDirectoryURL: NSURL): void;
  standardInput(): any;
  setStandardInput(standardInput: any): void;
  standardOutput(): any;
  setStandardOutput(standardOutput: any): void;
  standardError(): any;
  setStandardError(standardError: any): void;
  processIdentifier(): number;
  running(): boolean;
  terminationStatus(): number;
  terminationReason(): NSTaskTerminationReason;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  launchPath(): NSString;
  setLaunchPath(launchPath: NSString | string): void;
  currentDirectoryPath(): NSString;
  setCurrentDirectoryPath(currentDirectoryPath: NSString | string): void;
}
declare const NSTask: {
  alloc(): NSTaskAllocator;  launchedTaskWithExecutableURL_arguments_error_terminationHandler(url: NSURL, arguments: NSArray<any> | any[], error: NSError, terminationHandler: Block): NSTask;
  launchedTaskWithLaunchPath_arguments(path: NSString | string, arguments: NSArray<any> | any[]): NSTask;

}

declare enum NSTaskTerminationReason {
  NSTaskTerminationReasonExit = 1,
  NSTaskTerminationReasonUncaughtSignal = 2,
}

interface NSTextCheckingResultAllocator<InitializedType = NSTextCheckingResult> extends NSObjectAllocator<NSTextCheckingResult> {}
interface NSTextCheckingResult extends NSObject, INSCopying, INSSecureCoding {
  rangeAtIndex(idx: NSUInteger): NSRange;
  rangeWithName(name: NSString | string): NSRange;
  resultByAdjustingRangesWithOffset(offset: NSInteger): NSTextCheckingResult;

  resultType(): NSTextCheckingType;
  range(): NSRange;
  orthography(): NSOrthography;
  grammarDetails(): NSArray<any>;
  date(): NSDate;
  timeZone(): NSTimeZone;
  duration(): NSTimeInterval;
  components(): NSDictionary<any, any>;
  URL(): NSURL;
  replacementString(): NSString;
  alternativeStrings(): NSArray<any>;
  regularExpression(): NSRegularExpression;
  phoneNumber(): NSString;
  numberOfRanges(): NSUInteger;
  addressComponents(): NSDictionary<any, any>;
}
declare const NSTextCheckingResult: {
  alloc(): NSTextCheckingResultAllocator;  orthographyCheckingResultWithRange_orthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
  spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
  grammarCheckingResultWithRange_details(range: NSRange, details: NSArray<any> | any[]): NSTextCheckingResult;
  dateCheckingResultWithRange_date(range: NSRange, date: NSDate): NSTextCheckingResult;
  dateCheckingResultWithRange_date_timeZone_duration(range: NSRange, date: NSDate, timeZone: NSTimeZone, duration: NSTimeInterval): NSTextCheckingResult;
  addressCheckingResultWithRange_components(range: NSRange, components: NSDictionary<any, any> | {[key: string]: any}): NSTextCheckingResult;
  linkCheckingResultWithRange_URL(range: NSRange, url: NSURL): NSTextCheckingResult;
  quoteCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  dashCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  replacementCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  correctionCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  correctionCheckingResultWithRange_replacementString_alternativeStrings(range: NSRange, replacementString: NSString | string, alternativeStrings: NSArray<any> | any[]): NSTextCheckingResult;
  regularExpressionCheckingResultWithRanges_count_regularExpression(ranges: NSRangePointer, count: NSUInteger, regularExpression: NSRegularExpression): NSTextCheckingResult;
  phoneNumberCheckingResultWithRange_phoneNumber(range: NSRange, phoneNumber: NSString | string): NSTextCheckingResult;
  transitInformationCheckingResultWithRange_components(range: NSRange, components: NSDictionary<any, any> | {[key: string]: any}): NSTextCheckingResult;

}

declare type NSTextCheckingTypes = number

declare type NSTextCheckingKey = NSString

declare enum NSTextCheckingType {
  NSTextCheckingTypeOrthography = 1 << 0,
  NSTextCheckingTypeSpelling = 1 << 1,
  NSTextCheckingTypeGrammar = 1 << 2,
  NSTextCheckingTypeDate = 1 << 3,
  NSTextCheckingTypeAddress = 1 << 4,
  NSTextCheckingTypeLink = 1 << 5,
  NSTextCheckingTypeQuote = 1 << 6,
  NSTextCheckingTypeDash = 1 << 7,
  NSTextCheckingTypeReplacement = 1 << 8,
  NSTextCheckingTypeCorrection = 1 << 9,
  NSTextCheckingTypeRegularExpression = 1 << 10,
  NSTextCheckingTypePhoneNumber = 1 << 11,
  NSTextCheckingTypeTransitInformation = 1 << 12,
}

interface NSThreadAllocator<InitializedType = NSThread> extends NSObjectAllocator<NSThread> {
  init(): InitializedType;
  initWithTarget_selector_object(target: any, selector: string, argument: any | null): InitializedType;
  initWithBlock(block: Block): InitializedType;
}
interface NSThread extends NSObject {
  cancel(): void;
  start(): void;
  main(): void;

  threadDictionary(): NSMutableDictionary<any, any>;
  threadPriority(): number;
  setThreadPriority(threadPriority: number): void;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  name(): NSString;
  setName(name: NSString | string): void;
  stackSize(): NSUInteger;
  setStackSize(stackSize: NSUInteger): void;
  executing(): boolean;
  finished(): boolean;
  cancelled(): boolean;
}
declare const NSThread: {
  alloc(): NSThreadAllocator;  detachNewThreadWithBlock(block: Block): void;
  detachNewThreadSelector_toTarget_withObject(selector: string, target: any, argument: any | null): void;
  isMultiThreaded(): boolean;
  sleepUntilDate(date: NSDate): void;
  sleepForTimeInterval(ti: NSTimeInterval): void;
  exit(): void;
  threadPriority(): number;
  setThreadPriority(p: number): boolean;

  currentThread(): NSThread;
  callStackReturnAddresses(): NSArray<any>;
  callStackSymbols(): NSArray<any>;
  isMainThread(): boolean;
  mainThread(): NSThread;

}

interface NSTimeZoneAllocator<InitializedType = NSTimeZone> extends NSObjectAllocator<NSTimeZone> {
  initWithName(tzName: NSString | string): InitializedType;
  initWithName_data(tzName: NSString | string, aData: NSData | null): InitializedType;
}
interface NSTimeZone extends NSObject, INSCopying, INSSecureCoding {
  secondsFromGMTForDate(aDate: NSDate): NSInteger;
  abbreviationForDate(aDate: NSDate): NSString;
  isDaylightSavingTimeForDate(aDate: NSDate): boolean;
  daylightSavingTimeOffsetForDate(aDate: NSDate): NSTimeInterval;
  nextDaylightSavingTimeTransitionAfterDate(aDate: NSDate): NSDate;
  isEqualToTimeZone(aTimeZone: NSTimeZone): boolean;
  localizedName_locale(style: NSTimeZoneNameStyle, locale: NSLocale | null): NSString;

  name(): NSString;
  data(): NSData;
  secondsFromGMT(): NSInteger;
  abbreviation(): NSString;
  daylightSavingTime(): boolean;
  daylightSavingTimeOffset(): NSTimeInterval;
  nextDaylightSavingTimeTransition(): NSDate;
  description(): NSString;
}
declare const NSTimeZone: {
  alloc(): NSTimeZoneAllocator;  resetSystemTimeZone(): void;
  abbreviationDictionary(): NSDictionary<any, any>;
  timeZoneWithName(tzName: NSString | string): NSTimeZone;
  timeZoneWithName_data(tzName: NSString | string, aData: NSData | null): NSTimeZone;
  timeZoneForSecondsFromGMT(seconds: NSInteger): NSTimeZone;
  timeZoneWithAbbreviation(abbreviation: NSString | string): NSTimeZone;

  systemTimeZone(): NSTimeZone;
  defaultTimeZone(): NSTimeZone;
  setDefaultTimeZone(defaultTimeZone: NSTimeZone): void;
  localTimeZone(): NSTimeZone;
  knownTimeZoneNames(): NSArray<any>;
  abbreviationDictionary(): NSDictionary<any, any>;
  setAbbreviationDictionary(abbreviationDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  timeZoneDataVersion(): NSString;

}

declare enum NSTimeZoneNameStyle {
  NSTimeZoneNameStyleStandard,
  NSTimeZoneNameStyleShortStandard,
  NSTimeZoneNameStyleDaylightSaving,
  NSTimeZoneNameStyleShortDaylightSaving,
  NSTimeZoneNameStyleGeneric,
  NSTimeZoneNameStyleShortGeneric,
}

interface NSTimerAllocator<InitializedType = NSTimer> extends NSObjectAllocator<NSTimer> {
  initWithFireDate_interval_repeats_block(date: NSDate, interval: NSTimeInterval, repeats: boolean, block: Block): InitializedType;
  initWithFireDate_interval_target_selector_userInfo_repeats(date: NSDate, ti: NSTimeInterval, t: any, s: string, ui: any | null, rep: boolean): InitializedType;
}
interface NSTimer extends NSObject {
  fire(): void;
  invalidate(): void;

  fireDate(): NSDate;
  setFireDate(fireDate: NSDate): void;
  timeInterval(): NSTimeInterval;
  tolerance(): NSTimeInterval;
  setTolerance(tolerance: NSTimeInterval): void;
  valid(): boolean;
  userInfo(): any;
}
declare const NSTimer: {
  alloc(): NSTimerAllocator;  timerWithTimeInterval_invocation_repeats(ti: NSTimeInterval, invocation: NSInvocation, yesOrNo: boolean): NSTimer;
  scheduledTimerWithTimeInterval_invocation_repeats(ti: NSTimeInterval, invocation: NSInvocation, yesOrNo: boolean): NSTimer;
  timerWithTimeInterval_target_selector_userInfo_repeats(ti: NSTimeInterval, aTarget: any, aSelector: string, userInfo: any | null, yesOrNo: boolean): NSTimer;
  scheduledTimerWithTimeInterval_target_selector_userInfo_repeats(ti: NSTimeInterval, aTarget: any, aSelector: string, userInfo: any | null, yesOrNo: boolean): NSTimer;
  timerWithTimeInterval_repeats_block(interval: NSTimeInterval, repeats: boolean, block: Block): NSTimer;
  scheduledTimerWithTimeInterval_repeats_block(interval: NSTimeInterval, repeats: boolean, block: Block): NSTimer;
  scheduledTimerWithTimeInterval_repeats_block_ch(interval: NSTimeInterval, repeats: boolean, block: BCTimerBlock): NSTimer;

}

interface NSURLAllocator<InitializedType = NSURL> extends NSObjectAllocator<NSURL> {
  initWithScheme_host_path(scheme: NSString | string, host: NSString | string | null, path: NSString | string): InitializedType;
  initFileURLWithPath_isDirectory_relativeToURL(path: NSString | string, isDir: boolean, baseURL: NSURL | null): InitializedType;
  initFileURLWithPath_relativeToURL(path: NSString | string, baseURL: NSURL | null): InitializedType;
  initFileURLWithPath_isDirectory(path: NSString | string, isDir: boolean): InitializedType;
  initFileURLWithPath(path: NSString | string): InitializedType;
  initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): InitializedType;
  initWithString(URLString: NSString | string): InitializedType;
  initWithString_relativeToURL(URLString: NSString | string, baseURL: NSURL | null): InitializedType;
  initWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): InitializedType;
  initAbsoluteURLWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): InitializedType;
  initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(bookmarkData: NSData, options: NSURLBookmarkResolutionOptions, relativeURL: NSURL | null, isStale: boolean, error: NSError): InitializedType;
}
interface NSURL extends NSObject, INSSecureCoding, INSCopying {
  getFileSystemRepresentation_maxLength(buffer: string, maxBufferLength: NSUInteger): boolean;
  checkResourceIsReachableAndReturnError_NS_SWIFT_NOTHROW(error: NSError): boolean;
  isFileReferenceURL(): boolean;
  fileReferenceURL(): NSURL;
  getResourceValue_forKey_error(value: any, key: NSURLResourceKey, error: NSError): boolean;
  resourceValuesForKeys_error(keys: NSArray<any> | any[], error: NSError): NSDictionary<any, any>;
  setResourceValue_forKey_error(value: any | null, key: NSURLResourceKey, error: NSError): boolean;
  setResourceValues_error(keyedValues: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  removeCachedResourceValueForKey(key: NSURLResourceKey): void;
  removeAllCachedResourceValues(): void;
  setTemporaryResourceValue_forKey(value: any | null, key: NSURLResourceKey): void;
  bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error(options: NSURLBookmarkCreationOptions, keys: NSArray<any> | any[] | null, relativeURL: NSURL | null, error: NSError): NSData;
  startAccessingSecurityScopedResource(): boolean;
  stopAccessingSecurityScopedResource(): void;
  getPromisedItemResourceValue_forKey_error(value: any, key: NSURLResourceKey, error: NSError): boolean;
  promisedItemResourceValuesForKeys_error(keys: NSArray<any> | any[], error: NSError): NSDictionary<any, any>;
  checkPromisedItemIsReachableAndReturnError_NS_SWIFT_NOTHROW(error: NSError): boolean;
  URLByAppendingPathComponent(pathComponent: NSString | string): NSURL;
  URLByAppendingPathComponent_isDirectory(pathComponent: NSString | string, isDirectory: boolean): NSURL;
  URLByAppendingPathExtension(pathExtension: NSString | string): NSURL;
  resourceDataUsingCache(shouldUseCache: boolean): NSData;
  loadResourceDataNotifyingClient_usingCache(client: any, shouldUseCache: boolean): void;
  propertyForKey(propertyKey: NSString | string): any;
  setResourceData(data: NSData): boolean;
  setProperty_forKey(property: any, propertyKey: NSString | string): boolean;
  URLHandleUsingCache(shouldUseCache: boolean): NSURLHandle;
  writeToPasteboard(pasteBoard: NSPasteboard): void;
  URLByStrippingInvisiblePeriod_bc(): NSURL;
  URLByAppendingNameWithSeparators_defaultName(name: NSString | string, defaultName: NSString | string): NSURL;
  hasExtension(extension: NSString | string): boolean;
  withExtension(extension: NSString | string): NSURL;
  URLByResolvingSymlinksAndAliases(): NSURL;
  isEqualToFileURL_bc(otherURL: NSURL): boolean;
  appendingCloudDeeplinkComponentsToArtboard(artboard: SCKArtboard | null): NSURL;
  appendingCloudDeeplinkComponentsInPageToArtboard(artboard: SCKArtboard | null): NSURL;
  appendingCloudAuthentication(authentication: any | null): NSURL;

  dataRepresentation(): NSData;
  absoluteString(): NSString;
  relativeString(): NSString;
  baseURL(): NSURL;
  absoluteURL(): NSURL;
  scheme(): NSString;
  resourceSpecifier(): NSString;
  host(): NSString;
  port(): NSNumber;
  user(): NSString;
  password(): NSString;
  path(): NSString;
  fragment(): NSString;
  parameterString(): NSString;
  query(): NSString;
  relativePath(): NSString;
  hasDirectoryPath(): boolean;
  fileSystemRepresentation(): string;
  fileURL(): boolean;
  standardizedURL(): NSURL;
  filePathURL(): NSURL;
  pathComponents(): NSArray<any>;
  lastPathComponent(): NSString;
  pathExtension(): NSString;
  URLByDeletingLastPathComponent(): NSURL;
  URLByDeletingPathExtension(): NSURL;
  URLByStandardizingPath(): NSURL;
  URLByResolvingSymlinksInPath(): NSURL;
  isInTrash_bc(): boolean;
  isCloudShare(): boolean;
  cloudShareURL(): NSURL;
  cloudShareShortID(): NSString;
  cloudPageSlug(): NSString;
  cloudArtboardSlug(): NSString;
  cloudAPIName(): NSString;
  cloudAPIEnvironment(): SCKAPIEnvironment;
  isExportRequest(): boolean;
  exportRootLayerID(): NSString;
  exportRect(): CGRect;
  exportScale(): CGFloat;
  constrainedExportSize(): CGSize;
  exportImageType(): NSString;
  mirrorCacheKey(): NSString;
}
declare const NSURL: {
  alloc(): NSURLAllocator;  fileURLWithPath_isDirectory_relativeToURL(path: NSString | string, isDir: boolean, baseURL: NSURL | null): NSURL;
  fileURLWithPath_relativeToURL(path: NSString | string, baseURL: NSURL | null): NSURL;
  fileURLWithPath_isDirectory(path: NSString | string, isDir: boolean): NSURL;
  fileURLWithPath(path: NSString | string): NSURL;
  fileURLWithFileSystemRepresentation_isDirectory_relativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): NSURL;
  URLWithString(URLString: NSString | string): NSURL;
  URLWithString_relativeToURL(URLString: NSString | string, baseURL: NSURL | null): NSURL;
  URLWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): NSURL;
  absoluteURLWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): NSURL;
  URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(bookmarkData: NSData, options: NSURLBookmarkResolutionOptions, relativeURL: NSURL | null, isStale: boolean, error: NSError): NSURL;
  resourceValuesForKeys_fromBookmarkData(keys: NSArray<any> | any[], bookmarkData: NSData): NSDictionary<any, any>;
  writeBookmarkData_toURL_options_error(bookmarkData: NSData, bookmarkFileURL: NSURL, options: NSURLBookmarkFileCreationOptions, error: NSError): boolean;
  bookmarkDataWithContentsOfURL_error(bookmarkFileURL: NSURL, error: NSError): NSData;
  URLByResolvingAliasFileAtURL_options_error(url: NSURL, options: NSURLBookmarkResolutionOptions, error: NSError): NSURL;
  fileURLWithPathComponents(components: NSArray<any> | any[]): NSURL;
  URLFromPasteboard(pasteBoard: NSPasteboard): NSURL;

}

interface NSURLQueryItemAllocator<InitializedType = NSURLQueryItem> extends NSObjectAllocator<NSURLQueryItem> {
  initWithName_value(name: NSString | string, value: NSString | string | null): InitializedType;
}
interface NSURLQueryItem extends NSObject, INSSecureCoding, INSCopying {

  name(): NSString;
  value(): NSString;
}
declare const NSURLQueryItem: {
  alloc(): NSURLQueryItemAllocator;  queryItemWithName_value(name: NSString | string, value: NSString | string | null): NSURLQueryItem;

}

interface NSURLComponentsAllocator<InitializedType = NSURLComponents> extends NSObjectAllocator<NSURLComponents> {
  init(): InitializedType;
  initWithURL_resolvingAgainstBaseURL(url: NSURL, resolve: boolean): InitializedType;
  initWithString(URLString: NSString | string): InitializedType;
}
interface NSURLComponents extends NSObject, INSCopying {
  URLRelativeToURL(baseURL: NSURL | null): NSURL;

  URL(): NSURL;
  string(): NSString;
  scheme(): NSString;
  setScheme(scheme: NSString | string): void;
  user(): NSString;
  setUser(user: NSString | string): void;
  password(): NSString;
  setPassword(password: NSString | string): void;
  host(): NSString;
  setHost(host: NSString | string): void;
  port(): NSNumber;
  setPort(port: NSNumber | number): void;
  path(): NSString;
  setPath(path: NSString | string): void;
  query(): NSString;
  setQuery(query: NSString | string): void;
  fragment(): NSString;
  setFragment(fragment: NSString | string): void;
  percentEncodedUser(): NSString;
  setPercentEncodedUser(percentEncodedUser: NSString | string): void;
  percentEncodedPassword(): NSString;
  setPercentEncodedPassword(percentEncodedPassword: NSString | string): void;
  percentEncodedHost(): NSString;
  setPercentEncodedHost(percentEncodedHost: NSString | string): void;
  percentEncodedPath(): NSString;
  setPercentEncodedPath(percentEncodedPath: NSString | string): void;
  percentEncodedQuery(): NSString;
  setPercentEncodedQuery(percentEncodedQuery: NSString | string): void;
  percentEncodedFragment(): NSString;
  setPercentEncodedFragment(percentEncodedFragment: NSString | string): void;
  rangeOfScheme(): NSRange;
  rangeOfUser(): NSRange;
  rangeOfPassword(): NSRange;
  rangeOfHost(): NSRange;
  rangeOfPort(): NSRange;
  rangeOfPath(): NSRange;
  rangeOfQuery(): NSRange;
  rangeOfFragment(): NSRange;
  queryItems(): NSArray<any>;
  setQueryItems(queryItems: NSArray<any> | any[]): void;
  percentEncodedQueryItems(): NSArray<any>;
  setPercentEncodedQueryItems(percentEncodedQueryItems: NSArray<any> | any[]): void;
}
declare const NSURLComponents: {
  alloc(): NSURLComponentsAllocator;  componentsWithURL_resolvingAgainstBaseURL(url: NSURL, resolve: boolean): NSURLComponents;
  componentsWithString(URLString: NSString | string): NSURLComponents;

}

interface NSFileSecurityAllocator<InitializedType = NSFileSecurity> extends NSObjectAllocator<NSFileSecurity> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSFileSecurity extends NSObject, INSCopying, INSSecureCoding {
}
declare const NSFileSecurity: {
  alloc(): NSFileSecurityAllocator;
}

declare type NSURLResourceKey = NSString

declare type NSURLFileResourceType = NSString

declare type NSURLThumbnailDictionaryItem = NSString

declare type NSURLFileProtectionType = NSString

declare type NSURLUbiquitousItemDownloadingStatus = NSString

declare type NSURLUbiquitousSharedItemRole = NSString

declare type NSURLUbiquitousSharedItemPermissions = NSString

declare type NSURLBookmarkFileCreationOptions = NSUInteger

declare enum NSURLBookmarkCreationOptions {
  NSURLBookmarkCreationPreferFileIDResolution,
  NSURLBookmarkCreationMinimalBookmark,
  NSURLBookmarkCreationSuitableForBookmarkFile,
  NSURLBookmarkCreationWithSecurityScope,
  NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess,
}

declare enum NSURLBookmarkResolutionOptions {
  NSURLBookmarkResolutionWithoutUI,
  NSURLBookmarkResolutionWithoutMounting,
  NSURLBookmarkResolutionWithSecurityScope,
}

interface NSURLAuthenticationChallengeAllocator<InitializedType = NSURLAuthenticationChallenge> extends NSObjectAllocator<NSURLAuthenticationChallenge> {
  initWithProtectionSpace_proposedCredential_previousFailureCount_failureResponse_error_sender(space: NSURLProtectionSpace, credential: NSURLCredential | null, previousFailureCount: NSInteger, response: NSURLResponse | null, error: NSError | null, sender: any): InitializedType;
  initWithAuthenticationChallenge_sender(challenge: NSURLAuthenticationChallenge, sender: any): InitializedType;
}
interface NSURLAuthenticationChallenge extends NSObject, INSSecureCoding {

  protectionSpace(): NSURLProtectionSpace;
  proposedCredential(): NSURLCredential;
  previousFailureCount(): NSInteger;
  failureResponse(): NSURLResponse;
  error(): NSError;
  sender(): any;
}
declare const NSURLAuthenticationChallenge: {
  alloc(): NSURLAuthenticationChallengeAllocator;
}

interface INSURLAuthenticationChallengeSender {
  useCredential_forAuthenticationChallenge(credential: NSURLCredential, challenge: NSURLAuthenticationChallenge): void;
  continueWithoutCredentialForAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
  cancelAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
  performDefaultHandlingForAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
  rejectProtectionSpaceAndContinueWithChallenge(challenge: NSURLAuthenticationChallenge): void;
}

interface NSCachedURLResponseAllocator<InitializedType = NSCachedURLResponse> extends NSObjectAllocator<NSCachedURLResponse> {
  initWithResponse_data(response: NSURLResponse, data: NSData): InitializedType;
  initWithResponse_data_userInfo_storagePolicy(response: NSURLResponse, data: NSData, userInfo: NSDictionary<any, any> | {[key: string]: any} | null, storagePolicy: NSURLCacheStoragePolicy): InitializedType;
}
interface NSCachedURLResponse extends NSObject, INSSecureCoding, INSCopying {

  response(): NSURLResponse;
  data(): NSData;
  userInfo(): NSDictionary<any, any>;
  storagePolicy(): NSURLCacheStoragePolicy;
}
declare const NSCachedURLResponse: {
  alloc(): NSCachedURLResponseAllocator;
}

interface NSURLCacheAllocator<InitializedType = NSURLCache> extends NSObjectAllocator<NSURLCache> {
  initWithMemoryCapacity_diskCapacity_diskPath(memoryCapacity: NSUInteger, diskCapacity: NSUInteger, path: NSString | string | null): InitializedType;
}
interface NSURLCache extends NSObject {
  cachedResponseForRequest(request: NSURLRequest): NSCachedURLResponse;
  storeCachedResponse_forRequest(cachedResponse: NSCachedURLResponse, request: NSURLRequest): void;
  removeCachedResponseForRequest(request: NSURLRequest): void;
  removeAllCachedResponses(): void;
  removeCachedResponsesSinceDate(date: NSDate): void;
  storeCachedResponse_forDataTask(cachedResponse: NSCachedURLResponse, dataTask: NSURLSessionDataTask): void;
  getCachedResponseForDataTask_completionHandler(dataTask: NSURLSessionDataTask, completionHandler: Block): void;
  removeCachedResponseForDataTask(dataTask: NSURLSessionDataTask): void;

  memoryCapacity(): NSUInteger;
  setMemoryCapacity(memoryCapacity: NSUInteger): void;
  diskCapacity(): NSUInteger;
  setDiskCapacity(diskCapacity: NSUInteger): void;
  currentMemoryUsage(): NSUInteger;
  currentDiskUsage(): NSUInteger;
}
declare const NSURLCache: {
  alloc(): NSURLCacheAllocator;
  sharedURLCache(): NSURLCache;
  setSharedURLCache(sharedURLCache: NSURLCache): void;

}

declare enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed,
  NSURLCacheStorageAllowedInMemoryOnly,
  NSURLCacheStorageNotAllowed,
}

interface NSURLConnectionAllocator<InitializedType = NSURLConnection> extends NSObjectAllocator<NSURLConnection> {
  initWithRequest_delegate_startImmediately(request: NSURLRequest, delegate: any | null, startImmediately: boolean): InitializedType;
  initWithRequest_delegate___WATCHOS_PROHIBITED(request: NSURLRequest, delegate: any | null): InitializedType;
}
interface NSURLConnection extends NSObject {
  start(): void;
  cancel(): void;
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  unscheduleFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  setDelegateQueue(queue: NSOperationQueue | null): void;

  originalRequest(): NSURLRequest;
  currentRequest(): NSURLRequest;
}
declare const NSURLConnection: {
  alloc(): NSURLConnectionAllocator;  connectionWithRequest_delegate___WATCHOS_PROHIBITED(request: NSURLRequest, delegate: any | null): NSURLConnection;
  canHandleRequest(request: NSURLRequest): boolean;
  sendSynchronousRequest_returningResponse_error___WATCHOS_PROHIBITED(request: NSURLRequest, response: NSURLResponse, error: NSError): NSData;
  sendAsynchronousRequest_queue_completionHandler___WATCHOS_PROHIBITED(request: NSURLRequest, queue: NSOperationQueue, handler: Block): void;

}

interface INSURLConnectionDelegate {
  connection_didFailWithError(connection: NSURLConnection, error: NSError): void;
  connectionShouldUseCredentialStorage(connection: NSURLConnection): boolean;
  connection_willSendRequestForAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_canAuthenticateAgainstProtectionSpace(connection: NSURLConnection, protectionSpace: NSURLProtectionSpace): boolean;
  connection_didReceiveAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_didCancelAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
}

interface INSURLConnectionDataDelegate {
  connection_willSendRequest_redirectResponse(connection: NSURLConnection, request: NSURLRequest, response: NSURLResponse | null): NSURLRequest;
  connection_didReceiveResponse(connection: NSURLConnection, response: NSURLResponse): void;
  connection_didReceiveData(connection: NSURLConnection, data: NSData): void;
  connection_needNewBodyStream(connection: NSURLConnection, request: NSURLRequest): NSInputStream;
  connection_didSendBodyData_totalBytesWritten_totalBytesExpectedToWrite(connection: NSURLConnection, bytesWritten: NSInteger, totalBytesWritten: NSInteger, totalBytesExpectedToWrite: NSInteger): void;
  connection_willCacheResponse(connection: NSURLConnection, cachedResponse: NSCachedURLResponse): NSCachedURLResponse;
  connectionDidFinishLoading(connection: NSURLConnection): void;
}

interface INSURLConnectionDownloadDelegate {
  connection_didWriteData_totalBytesWritten_expectedTotalBytes(connection: NSURLConnection, bytesWritten: number, totalBytesWritten: number, expectedTotalBytes: number): void;
  connectionDidResumeDownloading_totalBytesWritten_expectedTotalBytes(connection: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
  connectionDidFinishDownloading_destinationURL(connection: NSURLConnection, destinationURL: NSURL): void;
}

interface NSURLCredentialAllocator<InitializedType = NSURLCredential> extends NSObjectAllocator<NSURLCredential> {
  initWithUser_password_persistence(user: NSString | string, password: NSString | string, persistence: NSURLCredentialPersistence): InitializedType;
  initWithIdentity_certificates_persistence(identity: SecIdentityRef, certArray: NSArray<any> | any[] | null, persistence: NSURLCredentialPersistence): InitializedType;
  initWithTrust(trust: SecTrustRef): InitializedType;
}
interface NSURLCredential extends NSObject, INSSecureCoding, INSCopying {

  persistence(): NSURLCredentialPersistence;
  user(): NSString;
  password(): NSString;
  hasPassword(): boolean;
  identity(): SecIdentityRef;
  certificates(): NSArray<any>;
}
declare const NSURLCredential: {
  alloc(): NSURLCredentialAllocator;  credentialWithUser_password_persistence(user: NSString | string, password: NSString | string, persistence: NSURLCredentialPersistence): NSURLCredential;
  credentialWithIdentity_certificates_persistence(identity: SecIdentityRef, certArray: NSArray<any> | any[] | null, persistence: NSURLCredentialPersistence): NSURLCredential;
  credentialForTrust(trust: SecTrustRef): NSURLCredential;

}

declare enum NSURLCredentialPersistence {
  NSURLCredentialPersistenceNone,
  NSURLCredentialPersistenceForSession,
  NSURLCredentialPersistencePermanent,
  NSURLCredentialPersistenceSynchronizable,
}

interface NSURLCredentialStorageAllocator<InitializedType = NSURLCredentialStorage> extends NSObjectAllocator<NSURLCredentialStorage> {}
interface NSURLCredentialStorage extends NSObject {
  credentialsForProtectionSpace(space: NSURLProtectionSpace): NSDictionary<any, any>;
  setCredential_forProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
  removeCredential_forProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
  removeCredential_forProtectionSpace_options(credential: NSURLCredential, space: NSURLProtectionSpace, options: NSDictionary<any, any> | {[key: string]: any} | null): void;
  defaultCredentialForProtectionSpace(space: NSURLProtectionSpace): NSURLCredential;
  setDefaultCredential_forProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
  getCredentialsForProtectionSpace_task_completionHandler(protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: Block): void;
  setCredential_forProtectionSpace_task(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;
  removeCredential_forProtectionSpace_options_task(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, options: NSDictionary<any, any> | {[key: string]: any} | null, task: NSURLSessionTask): void;
  getDefaultCredentialForProtectionSpace_task_completionHandler(space: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: Block): void;
  setDefaultCredential_forProtectionSpace_task(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;

  allCredentials(): NSDictionary<any, any>;
}
declare const NSURLCredentialStorage: {
  alloc(): NSURLCredentialStorageAllocator;
  sharedCredentialStorage(): NSURLCredentialStorage;

}

interface NSURLDownloadAllocator<InitializedType = NSURLDownload> extends NSObjectAllocator<NSURLDownload> {
  initWithRequest_delegate(request: NSURLRequest, delegate: any | null): InitializedType;
  initWithResumeData_delegate_path(resumeData: NSData, delegate: any | null, path: NSString | string): InitializedType;
}
interface NSURLDownload extends NSObject {
  cancel(): void;
  setDestination_allowOverwrite(path: NSString | string, allowOverwrite: boolean): void;

  request(): NSURLRequest;
  resumeData(): NSData;
  deletesFileUponFailure(): boolean;
  setDeletesFileUponFailure(deletesFileUponFailure: boolean): void;
}
declare const NSURLDownload: {
  alloc(): NSURLDownloadAllocator;  canResumeDownloadDecodedWithEncodingMIMEType(MIMEType: NSString | string): boolean;

}

interface INSURLDownloadDelegate {
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
}

interface NSURLHandleAllocator<InitializedType = NSURLHandle> {}
interface NSURLHandle {
  status(): NSURLHandleStatus;
  failureReason(): NSString;
  addClient(client: any): void;
  removeClient(client: any): void;
  loadInBackground(): void;
  cancelLoadInBackground(): void;
  resourceData(): NSData;
  availableResourceData(): NSData;
  expectedResourceDataSize(): number;
  flushCachedData(): void;
  backgroundLoadDidFailWithReason(reason: NSString | string): void;
  didLoadBytes_loadComplete(newBytes: NSData, yorn: boolean): void;
  propertyForKey(propertyKey: NSString | string): any;
  propertyForKeyIfAvailable(propertyKey: NSString | string): any;
  writeProperty_forKey(propertyValue: any, propertyKey: NSString | string): boolean;
  writeData(data: NSData): boolean;
  loadInForeground(): NSData;
  beginLoadInBackground(): void;
  endLoadInBackground(): void;
}
declare const NSURLHandle: {
  alloc(): NSURLHandleAllocator;  registerURLHandleClass(anURLHandleSubclass: any): void;
  URLHandleClassForURL(anURL: NSURL): any;
  canInitWithURL(anURL: NSURL): boolean;
  cachedHandleForURL(anURL: NSURL): NSURLHandle;

}

interface INSURLHandleClient {
  URLHandle_resourceDataDidBecomeAvailable(sender: NSURLHandle, newBytes: NSData): void;
  URLHandleResourceDidBeginLoading(sender: NSURLHandle): void;
  URLHandleResourceDidFinishLoading(sender: NSURLHandle): void;
  URLHandleResourceDidCancelLoading(sender: NSURLHandle): void;
  URLHandle_resourceDidFailLoadingWithReason(sender: NSURLHandle, reason: NSString | string): void;
}

declare enum NSURLHandleStatus {
  NSURLHandleNotLoaded = 0,
  NSURLHandleLoadSucceeded,
  NSURLHandleLoadInProgress,
  NSURLHandleLoadFailed,
}

interface NSURLProtectionSpaceAllocator<InitializedType = NSURLProtectionSpace> extends NSObjectAllocator<NSURLProtectionSpace> {
  initWithHost_port_protocol_realm_authenticationMethod(host: NSString | string, port: NSInteger, protocol: NSString | string | null, realm: NSString | string | null, authenticationMethod: NSString | string | null): InitializedType;
  initWithProxyHost_port_type_realm_authenticationMethod(host: NSString | string, port: NSInteger, type: NSString | string | null, realm: NSString | string | null, authenticationMethod: NSString | string | null): InitializedType;
}
interface NSURLProtectionSpace extends NSObject, INSSecureCoding, INSCopying {

  realm(): NSString;
  receivesCredentialSecurely(): boolean;
  isProxy(): boolean;
  host(): NSString;
  port(): NSInteger;
  proxyType(): NSString;
  protocol(): NSString;
  authenticationMethod(): NSString;
  distinguishedNames(): NSArray<any>;
  serverTrust(): SecTrustRef;
}
declare const NSURLProtectionSpace: {
  alloc(): NSURLProtectionSpaceAllocator;
}

interface NSURLProtocolAllocator<InitializedType = NSURLProtocol> extends NSObjectAllocator<NSURLProtocol> {
  initWithRequest_cachedResponse_client(request: NSURLRequest, cachedResponse: NSCachedURLResponse | null, client: any | null): InitializedType;
  initWithTask_cachedResponse_client(task: NSURLSessionTask, cachedResponse: NSCachedURLResponse | null, client: any | null): InitializedType;
}
interface NSURLProtocol extends NSObject {
  startLoading(): void;
  stopLoading(): void;

  client(): any;
  request(): NSURLRequest;
  cachedResponse(): NSCachedURLResponse;
  task(): NSURLSessionTask;
}
declare const NSURLProtocol: {
  alloc(): NSURLProtocolAllocator;  canInitWithRequest(request: NSURLRequest): boolean;
  canonicalRequestForRequest(request: NSURLRequest): NSURLRequest;
  requestIsCacheEquivalent_toRequest(a: NSURLRequest, b: NSURLRequest): boolean;
  propertyForKey_inRequest(key: NSString | string, request: NSURLRequest): any;
  setProperty_forKey_inRequest(value: any, key: NSString | string, request: NSMutableURLRequest): void;
  removePropertyForKey_inRequest(key: NSString | string, request: NSMutableURLRequest): void;
  registerClass(protocolClass: any): boolean;
  unregisterClass(protocolClass: any): void;
  canInitWithTask(task: NSURLSessionTask): boolean;

}

interface INSURLProtocolClient {
  URLProtocol_wasRedirectedToRequest_redirectResponse(protocol: NSURLProtocol, request: NSURLRequest, redirectResponse: NSURLResponse): void;
  URLProtocol_cachedResponseIsValid(protocol: NSURLProtocol, cachedResponse: NSCachedURLResponse): void;
  URLProtocol_didReceiveResponse_cacheStoragePolicy(protocol: NSURLProtocol, response: NSURLResponse, policy: NSURLCacheStoragePolicy): void;
  URLProtocol_didLoadData(protocol: NSURLProtocol, data: NSData): void;
  URLProtocolDidFinishLoading(protocol: NSURLProtocol): void;
  URLProtocol_didFailWithError(protocol: NSURLProtocol, error: NSError): void;
  URLProtocol_didReceiveAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
  URLProtocol_didCancelAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
}

interface NSURLRequestAllocator<InitializedType = NSURLRequest> extends NSObjectAllocator<NSURLRequest> {
  initWithURL(URL: NSURL): InitializedType;
  initWithURL_cachePolicy_timeoutInterval(URL: NSURL, cachePolicy: NSURLRequestCachePolicy, timeoutInterval: NSTimeInterval): InitializedType;
}
interface NSURLRequest extends NSObject, INSSecureCoding, INSCopying, INSMutableCopying {
  valueForHTTPHeaderField(field: NSString | string): NSString;

  URL(): NSURL;
  cachePolicy(): NSURLRequestCachePolicy;
  timeoutInterval(): NSTimeInterval;
  mainDocumentURL(): NSURL;
  networkServiceType(): NSURLRequestNetworkServiceType;
  allowsCellularAccess(): boolean;
  HTTPMethod(): NSString;
  allHTTPHeaderFields(): NSDictionary<any, any>;
  HTTPBody(): NSData;
  HTTPBodyStream(): NSInputStream;
  HTTPShouldHandleCookies(): boolean;
  HTTPShouldUsePipelining(): boolean;
}
declare const NSURLRequest: {
  alloc(): NSURLRequestAllocator;  requestWithURL(URL: NSURL): NSURLRequest;
  requestWithURL_cachePolicy_timeoutInterval(URL: NSURL, cachePolicy: NSURLRequestCachePolicy, timeoutInterval: NSTimeInterval): NSURLRequest;

  supportsSecureCoding(): boolean;

}

interface NSMutableURLRequestAllocator<InitializedType = NSMutableURLRequest> extends NSURLRequestAllocator<NSMutableURLRequest> {}
interface NSMutableURLRequest extends NSURLRequest {
  setValue_forHTTPHeaderField(value: NSString | string | null, field: NSString | string): void;
  addValue_forHTTPHeaderField(value: NSString | string, field: NSString | string): void;

  URL(): NSURL;
  setURL(URL: NSURL): void;
  cachePolicy(): NSURLRequestCachePolicy;
  setCachePolicy(cachePolicy: NSURLRequestCachePolicy): void;
  timeoutInterval(): NSTimeInterval;
  setTimeoutInterval(timeoutInterval: NSTimeInterval): void;
  mainDocumentURL(): NSURL;
  setMainDocumentURL(mainDocumentURL: NSURL): void;
  networkServiceType(): NSURLRequestNetworkServiceType;
  setNetworkServiceType(networkServiceType: NSURLRequestNetworkServiceType): void;
  allowsCellularAccess(): boolean;
  setAllowsCellularAccess(allowsCellularAccess: boolean): void;
  HTTPMethod(): NSString;
  setHTTPMethod(HTTPMethod: NSString | string): void;
  allHTTPHeaderFields(): NSDictionary<any, any>;
  setAllHTTPHeaderFields(allHTTPHeaderFields: NSDictionary<any, any> | {[key: string]: any}): void;
  HTTPBody(): NSData;
  setHTTPBody(HTTPBody: NSData): void;
  HTTPBodyStream(): NSInputStream;
  setHTTPBodyStream(HTTPBodyStream: NSInputStream): void;
  HTTPShouldHandleCookies(): boolean;
  setHTTPShouldHandleCookies(HTTPShouldHandleCookies: boolean): void;
  HTTPShouldUsePipelining(): boolean;
  setHTTPShouldUsePipelining(HTTPShouldUsePipelining: boolean): void;
}
declare const NSMutableURLRequest: {
  alloc(): NSMutableURLRequestAllocator;
}

declare enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy = 0,
  NSURLRequestReloadIgnoringLocalCacheData = 1,
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4,
  NSURLRequestReloadIgnoringCacheData,
  NSURLRequestReturnCacheDataElseLoad = 2,
  NSURLRequestReturnCacheDataDontLoad = 3,
  NSURLRequestReloadRevalidatingCacheData = 5,
}

declare enum NSURLRequestNetworkServiceType {
  NSURLNetworkServiceTypeDefault = 0,
  NSURLNetworkServiceTypeVoIP = 1,
  NSURLNetworkServiceTypeVideo = 2,
  NSURLNetworkServiceTypeBackground = 3,
  NSURLNetworkServiceTypeVoice = 4,
  NSURLNetworkServiceTypeCallSignaling = 11,
}

interface NSURLResponseAllocator<InitializedType = NSURLResponse> extends NSObjectAllocator<NSURLResponse> {
  initWithURL_MIMEType_expectedContentLength_textEncodingName(URL: NSURL, MIMEType: NSString | string | null, length: NSInteger, name: NSString | string | null): InitializedType;
}
interface NSURLResponse extends NSObject, INSSecureCoding, INSCopying {

  URL(): NSURL;
  MIMEType(): NSString;
  expectedContentLength(): number;
  textEncodingName(): NSString;
  suggestedFilename(): NSString;
}
declare const NSURLResponse: {
  alloc(): NSURLResponseAllocator;
}

interface NSHTTPURLResponseAllocator<InitializedType = NSHTTPURLResponse> extends NSURLResponseAllocator<NSHTTPURLResponse> {
  initWithURL_statusCode_HTTPVersion_headerFields(url: NSURL, statusCode: NSInteger, HTTPVersion: NSString | string | null, headerFields: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface NSHTTPURLResponse extends NSURLResponse {

  statusCode(): NSInteger;
  allHeaderFields(): NSDictionary<any, any>;
}
declare const NSHTTPURLResponse: {
  alloc(): NSHTTPURLResponseAllocator;  localizedStringForStatusCode(statusCode: NSInteger): NSString;

}

interface NSURLSessionAllocator<InitializedType = NSURLSession> extends NSObjectAllocator<NSURLSession> {}
interface NSURLSession extends NSObject {
  finishTasksAndInvalidate(): void;
  invalidateAndCancel(): void;
  resetWithCompletionHandler(completionHandler: Block): void;
  flushWithCompletionHandler(completionHandler: Block): void;
  getTasksWithCompletionHandler(completionHandler: Block): void;
  getAllTasksWithCompletionHandler(completionHandler: Block): void;
  dataTaskWithRequest(request: NSURLRequest): NSURLSessionDataTask;
  dataTaskWithURL(url: NSURL): NSURLSessionDataTask;
  uploadTaskWithRequest_fromFile(request: NSURLRequest, fileURL: NSURL): NSURLSessionUploadTask;
  uploadTaskWithRequest_fromData(request: NSURLRequest, bodyData: NSData): NSURLSessionUploadTask;
  uploadTaskWithStreamedRequest(request: NSURLRequest): NSURLSessionUploadTask;
  downloadTaskWithRequest(request: NSURLRequest): NSURLSessionDownloadTask;
  downloadTaskWithURL(url: NSURL): NSURLSessionDownloadTask;
  downloadTaskWithResumeData(resumeData: NSData): NSURLSessionDownloadTask;
  streamTaskWithHostName_port(hostname: NSString | string, port: NSInteger): NSURLSessionStreamTask;
  streamTaskWithNetService___WATCHOS_PROHIBITED(service: NSNetService): NSURLSessionStreamTask;
  dataTaskWithRequest_completionHandler(request: NSURLRequest, completionHandler: Block): NSURLSessionDataTask;
  dataTaskWithURL_completionHandler(url: NSURL, completionHandler: Block): NSURLSessionDataTask;
  uploadTaskWithRequest_fromFile_completionHandler(request: NSURLRequest, fileURL: NSURL, completionHandler: Block): NSURLSessionUploadTask;
  uploadTaskWithRequest_fromData_completionHandler(request: NSURLRequest, bodyData: NSData | null, completionHandler: Block): NSURLSessionUploadTask;
  downloadTaskWithRequest_completionHandler(request: NSURLRequest, completionHandler: Block): NSURLSessionDownloadTask;
  downloadTaskWithURL_completionHandler(url: NSURL, completionHandler: Block): NSURLSessionDownloadTask;
  downloadTaskWithResumeData_completionHandler(resumeData: NSData, completionHandler: Block): NSURLSessionDownloadTask;

  delegateQueue(): NSOperationQueue;
  delegate(): any;
  configuration(): NSURLSessionConfiguration;
  sessionDescription(): NSString;
  setSessionDescription(sessionDescription: NSString | string): void;
}
declare const NSURLSession: {
  alloc(): NSURLSessionAllocator;  sessionWithConfiguration(configuration: NSURLSessionConfiguration): NSURLSession;
  sessionWithConfiguration_delegate_delegateQueue(configuration: NSURLSessionConfiguration, delegate: any | null, queue: NSOperationQueue | null): NSURLSession;

  sharedSession(): NSURLSession;

}

interface NSURLSessionTaskAllocator<InitializedType = NSURLSessionTask> extends NSObjectAllocator<NSURLSessionTask> {}
interface NSURLSessionTask extends NSObject, INSCopying, INSProgressReporting {
  cancel(): void;
  suspend(): void;
  resume(): void;

  taskIdentifier(): NSUInteger;
  originalRequest(): NSURLRequest;
  currentRequest(): NSURLRequest;
  response(): NSURLResponse;
  progress(): NSProgress;
  earliestBeginDate(): NSDate;
  setEarliestBeginDate(earliestBeginDate: NSDate): void;
  countOfBytesClientExpectsToSend(): number;
  setCountOfBytesClientExpectsToSend(countOfBytesClientExpectsToSend: number): void;
  countOfBytesClientExpectsToReceive(): number;
  setCountOfBytesClientExpectsToReceive(countOfBytesClientExpectsToReceive: number): void;
  countOfBytesReceived(): number;
  countOfBytesSent(): number;
  countOfBytesExpectedToSend(): number;
  countOfBytesExpectedToReceive(): number;
  taskDescription(): NSString;
  setTaskDescription(taskDescription: NSString | string): void;
  state(): NSURLSessionTaskState;
  error(): NSError;
  priority(): number;
  setPriority(priority: number): void;
}
declare const NSURLSessionTask: {
  alloc(): NSURLSessionTaskAllocator;
}

interface NSURLSessionDataTaskAllocator<InitializedType = NSURLSessionDataTask> extends NSURLSessionTaskAllocator<NSURLSessionDataTask> {}
interface NSURLSessionDataTask extends NSURLSessionTask {
}
declare const NSURLSessionDataTask: {
  alloc(): NSURLSessionDataTaskAllocator;
}

interface NSURLSessionUploadTaskAllocator<InitializedType = NSURLSessionUploadTask> extends NSURLSessionDataTaskAllocator<NSURLSessionUploadTask> {}
interface NSURLSessionUploadTask extends NSURLSessionDataTask {
}
declare const NSURLSessionUploadTask: {
  alloc(): NSURLSessionUploadTaskAllocator;
}

interface NSURLSessionDownloadTaskAllocator<InitializedType = NSURLSessionDownloadTask> extends NSURLSessionTaskAllocator<NSURLSessionDownloadTask> {}
interface NSURLSessionDownloadTask extends NSURLSessionTask {
  cancelByProducingResumeData(completionHandler: Block): void;
}
declare const NSURLSessionDownloadTask: {
  alloc(): NSURLSessionDownloadTaskAllocator;
}

interface NSURLSessionStreamTaskAllocator<InitializedType = NSURLSessionStreamTask> extends NSURLSessionTaskAllocator<NSURLSessionStreamTask> {}
interface NSURLSessionStreamTask extends NSURLSessionTask {
  readDataOfMinLength_maxLength_timeout_completionHandler(minBytes: NSUInteger, maxBytes: NSUInteger, timeout: NSTimeInterval, completionHandler: Block): void;
  writeData_timeout_completionHandler(data: NSData, timeout: NSTimeInterval, completionHandler: Block): void;
  captureStreams(): void;
  closeWrite(): void;
  closeRead(): void;
  startSecureConnection(): void;
  stopSecureConnection(): void;
}
declare const NSURLSessionStreamTask: {
  alloc(): NSURLSessionStreamTaskAllocator;
}

interface NSURLSessionConfigurationAllocator<InitializedType = NSURLSessionConfiguration> extends NSObjectAllocator<NSURLSessionConfiguration> {}
interface NSURLSessionConfiguration extends NSObject, INSCopying {

  identifier(): NSString;
  requestCachePolicy(): NSURLRequestCachePolicy;
  setRequestCachePolicy(requestCachePolicy: NSURLRequestCachePolicy): void;
  timeoutIntervalForRequest(): NSTimeInterval;
  setTimeoutIntervalForRequest(timeoutIntervalForRequest: NSTimeInterval): void;
  timeoutIntervalForResource(): NSTimeInterval;
  setTimeoutIntervalForResource(timeoutIntervalForResource: NSTimeInterval): void;
  networkServiceType(): NSURLRequestNetworkServiceType;
  setNetworkServiceType(networkServiceType: NSURLRequestNetworkServiceType): void;
  allowsCellularAccess(): boolean;
  setAllowsCellularAccess(allowsCellularAccess: boolean): void;
  waitsForConnectivity(): boolean;
  setWaitsForConnectivity(waitsForConnectivity: boolean): void;
  discretionary(): boolean;
  setDiscretionary(discretionary: boolean): void;
  sharedContainerIdentifier(): NSString;
  setSharedContainerIdentifier(sharedContainerIdentifier: NSString | string): void;
  sessionSendsLaunchEvents(): boolean;
  setSessionSendsLaunchEvents(sessionSendsLaunchEvents: boolean): void;
  connectionProxyDictionary(): NSDictionary<any, any>;
  setConnectionProxyDictionary(connectionProxyDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  TLSMinimumSupportedProtocol(): SSLProtocol;
  setTLSMinimumSupportedProtocol(TLSMinimumSupportedProtocol: SSLProtocol): void;
  TLSMaximumSupportedProtocol(): SSLProtocol;
  setTLSMaximumSupportedProtocol(TLSMaximumSupportedProtocol: SSLProtocol): void;
  HTTPShouldUsePipelining(): boolean;
  setHTTPShouldUsePipelining(HTTPShouldUsePipelining: boolean): void;
  HTTPShouldSetCookies(): boolean;
  setHTTPShouldSetCookies(HTTPShouldSetCookies: boolean): void;
  HTTPCookieAcceptPolicy(): NSHTTPCookieAcceptPolicy;
  setHTTPCookieAcceptPolicy(HTTPCookieAcceptPolicy: NSHTTPCookieAcceptPolicy): void;
  HTTPAdditionalHeaders(): NSDictionary<any, any>;
  setHTTPAdditionalHeaders(HTTPAdditionalHeaders: NSDictionary<any, any> | {[key: string]: any}): void;
  HTTPMaximumConnectionsPerHost(): NSInteger;
  setHTTPMaximumConnectionsPerHost(HTTPMaximumConnectionsPerHost: NSInteger): void;
  HTTPCookieStorage(): NSHTTPCookieStorage;
  setHTTPCookieStorage(HTTPCookieStorage: NSHTTPCookieStorage): void;
  URLCredentialStorage(): NSURLCredentialStorage;
  setURLCredentialStorage(URLCredentialStorage: NSURLCredentialStorage): void;
  URLCache(): NSURLCache;
  setURLCache(URLCache: NSURLCache): void;
  shouldUseExtendedBackgroundIdleMode(): boolean;
  setShouldUseExtendedBackgroundIdleMode(shouldUseExtendedBackgroundIdleMode: boolean): void;
  protocolClasses(): NSArray<any>;
  setProtocolClasses(protocolClasses: NSArray<any> | any[]): void;
  multipathServiceType(): NSURLSessionMultipathServiceType;
  setMultipathServiceType(multipathServiceType: NSURLSessionMultipathServiceType): void;
}
declare const NSURLSessionConfiguration: {
  alloc(): NSURLSessionConfigurationAllocator;  backgroundSessionConfigurationWithIdentifier(identifier: NSString | string): NSURLSessionConfiguration;
  backgroundSessionConfiguration(identifier: NSString | string): NSURLSessionConfiguration;

  defaultSessionConfiguration(): NSURLSessionConfiguration;
  ephemeralSessionConfiguration(): NSURLSessionConfiguration;

}

interface NSURLSessionTaskTransactionMetricsAllocator<InitializedType = NSURLSessionTaskTransactionMetrics> extends NSObjectAllocator<NSURLSessionTaskTransactionMetrics> {}
interface NSURLSessionTaskTransactionMetrics extends NSObject {

  request(): NSURLRequest;
  response(): NSURLResponse;
  fetchStartDate(): NSDate;
  domainLookupStartDate(): NSDate;
  domainLookupEndDate(): NSDate;
  connectStartDate(): NSDate;
  secureConnectionStartDate(): NSDate;
  secureConnectionEndDate(): NSDate;
  connectEndDate(): NSDate;
  requestStartDate(): NSDate;
  requestEndDate(): NSDate;
  responseStartDate(): NSDate;
  responseEndDate(): NSDate;
  networkProtocolName(): NSString;
  proxyConnection(): boolean;
  reusedConnection(): boolean;
  resourceFetchType(): NSURLSessionTaskMetricsResourceFetchType;
}
declare const NSURLSessionTaskTransactionMetrics: {
  alloc(): NSURLSessionTaskTransactionMetricsAllocator;
}

interface NSURLSessionTaskMetricsAllocator<InitializedType = NSURLSessionTaskMetrics> extends NSObjectAllocator<NSURLSessionTaskMetrics> {}
interface NSURLSessionTaskMetrics extends NSObject {

  transactionMetrics(): NSArray<any>;
  taskInterval(): NSDateInterval;
  redirectCount(): NSUInteger;
}
declare const NSURLSessionTaskMetrics: {
  alloc(): NSURLSessionTaskMetricsAllocator;
}

interface INSURLSessionDelegate {
  URLSession_didBecomeInvalidWithError(session: NSURLSession, error: NSError | null): void;
  URLSession_didReceiveChallenge_completionHandler(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession): void;
}

interface INSURLSessionTaskDelegate {
  URLSession_task_willBeginDelayedRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: Block): void;
  URLSession_taskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;
  URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: Block): void;
  URLSession_task_didReceiveChallenge_completionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSession_task_needNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: Block): void;
  URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  URLSession_task_didFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;
  URLSession_task_didCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;
}

interface INSURLSessionDataDelegate {
  URLSession_dataTask_didReceiveResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: Block): void;
  URLSession_dataTask_didBecomeDownloadTask(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;
  URLSession_dataTask_didBecomeStreamTask(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): void;
  URLSession_dataTask_didReceiveData(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;
  URLSession_dataTask_willCacheResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: Block): void;
}

interface INSURLSessionDownloadDelegate {
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
}

interface INSURLSessionStreamDelegate {
  URLSession_readClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;
  URLSession_writeClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;
  URLSession_betterRouteDiscoveredForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;
  URLSession_streamTask_didBecomeInputStream_outputStream(session: NSURLSession, streamTask: NSURLSessionStreamTask, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

declare enum NSURLSessionTaskState {
  NSURLSessionTaskStateRunning = 0,
  NSURLSessionTaskStateSuspended = 1,
  NSURLSessionTaskStateCanceling = 2,
  NSURLSessionTaskStateCompleted = 3,
}

declare enum NSURLSessionMultipathServiceType {
  NSURLSessionMultipathServiceTypeNone = 0,
  NSURLSessionMultipathServiceTypeHandover = 1,
  NSURLSessionMultipathServiceTypeInteractive = 2,
  NSURLSessionMultipathServiceTypeAggregate = 3,
}

declare enum NSURLSessionDelayedRequestDisposition {
  NSURLSessionDelayedRequestContinueLoading = 0,
  NSURLSessionDelayedRequestUseNewRequest = 1,
  NSURLSessionDelayedRequestCancel = 2,
}

declare enum NSURLSessionAuthChallengeDisposition {
  NSURLSessionAuthChallengeUseCredential = 0,
  NSURLSessionAuthChallengePerformDefaultHandling = 1,
  NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2,
  NSURLSessionAuthChallengeRejectProtectionSpace = 3,
}

declare enum NSURLSessionResponseDisposition {
  NSURLSessionResponseCancel = 0,
  NSURLSessionResponseAllow = 1,
  NSURLSessionResponseBecomeDownload = 2,
  NSURLSessionResponseBecomeStream = 3,
}

declare enum NSURLSessionTaskMetricsResourceFetchType {
  NSURLSessionTaskMetricsResourceFetchTypeUnknown,
  NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad,
  NSURLSessionTaskMetricsResourceFetchTypeServerPush,
  NSURLSessionTaskMetricsResourceFetchTypeLocalCache,
}

interface NSUUIDAllocator<InitializedType = NSUUID> extends NSObjectAllocator<NSUUID> {
  init(): InitializedType;
  initWithUUIDString(string: NSString | string): InitializedType;
  initWithUUIDBytes(bytes: uuid_t): InitializedType;
}
interface NSUUID extends NSObject, INSCopying, INSSecureCoding {
  getUUIDBytes(uuid: uuid_t): void;

  UUIDString(): NSString;
}
declare const NSUUID: {
  alloc(): NSUUIDAllocator;  UUID(): NSUUID;

}

interface NSUbiquitousKeyValueStoreAllocator<InitializedType = NSUbiquitousKeyValueStore> extends NSObjectAllocator<NSUbiquitousKeyValueStore> {}
interface NSUbiquitousKeyValueStore extends NSObject {
  objectForKey(aKey: NSString | string): any;
  setObject_forKey(anObject: any | null, aKey: NSString | string): void;
  removeObjectForKey(aKey: NSString | string): void;
  stringForKey(aKey: NSString | string): NSString;
  arrayForKey(aKey: NSString | string): NSArray<any>;
  dictionaryForKey(aKey: NSString | string): NSDictionary<any, any>;
  dataForKey(aKey: NSString | string): NSData;
  longLongForKey(aKey: NSString | string): number;
  doubleForKey(aKey: NSString | string): number;
  boolForKey(aKey: NSString | string): boolean;
  setString_forKey(aString: NSString | string | null, aKey: NSString | string): void;
  setData_forKey(aData: NSData | null, aKey: NSString | string): void;
  setArray_forKey(anArray: NSArray<any> | any[] | null, aKey: NSString | string): void;
  setDictionary_forKey(aDictionary: NSDictionary<any, any> | {[key: string]: any} | null, aKey: NSString | string): void;
  setLongLong_forKey(value: number, aKey: NSString | string): void;
  setDouble_forKey(value: number, aKey: NSString | string): void;
  setBool_forKey(value: boolean, aKey: NSString | string): void;
  synchronize(): boolean;

  dictionaryRepresentation(): NSDictionary<any, any>;
}
declare const NSUbiquitousKeyValueStore: {
  alloc(): NSUbiquitousKeyValueStoreAllocator;
  defaultStore(): NSUbiquitousKeyValueStore;

}

interface NSUndoManagerAllocator<InitializedType = NSUndoManager> extends NSObjectAllocator<NSUndoManager> {}
interface NSUndoManager extends NSObject {
  beginUndoGrouping(): void;
  endUndoGrouping(): void;
  disableUndoRegistration(): void;
  enableUndoRegistration(): void;
  undo(): void;
  redo(): void;
  undoNestedGroup(): void;
  removeAllActions(): void;
  removeAllActionsWithTarget(target: any): void;
  registerUndoWithTarget_selector_object(target: any, selector: string, anObject: any | null): void;
  prepareWithInvocationTarget(target: any): any;
  registerUndoWithTarget_handler(target: any, undoHandler: Block): void;
  setActionIsDiscardable(discardable: boolean): void;
  setActionName(actionName: NSString | string): void;
  undoMenuTitleForUndoActionName(actionName: NSString | string): NSString;
  redoMenuTitleForUndoActionName(actionName: NSString | string): NSString;
  setActionName_sender(actionName: NSString | string, senderID: NSString | string): void;

  groupingLevel(): NSInteger;
  undoRegistrationEnabled(): boolean;
  groupsByEvent(): boolean;
  setGroupsByEvent(groupsByEvent: boolean): void;
  levelsOfUndo(): NSUInteger;
  setLevelsOfUndo(levelsOfUndo: NSUInteger): void;
  runLoopModes(): NSArray<any>;
  setRunLoopModes(runLoopModes: NSArray<any> | any[]): void;
  canUndo(): boolean;
  canRedo(): boolean;
  undoing(): boolean;
  redoing(): boolean;
  undoActionIsDiscardable(): boolean;
  redoActionIsDiscardable(): boolean;
  undoActionName(): NSString;
  redoActionName(): NSString;
  undoMenuItemTitle(): NSString;
  redoMenuItemTitle(): NSString;
}
declare const NSUndoManager: {
  alloc(): NSUndoManagerAllocator;
}

interface NSUnitConverterAllocator<InitializedType = NSUnitConverter> extends NSObjectAllocator<NSUnitConverter> {}
interface NSUnitConverter extends NSObject {
  baseUnitValueFromValue(value: number): number;
  valueFromBaseUnitValue(baseUnitValue: number): number;
}
declare const NSUnitConverter: {
  alloc(): NSUnitConverterAllocator;
}

interface NSUnitConverterLinearAllocator<InitializedType = NSUnitConverterLinear> extends NSUnitConverterAllocator<NSUnitConverterLinear> {
  initWithCoefficient(coefficient: number): InitializedType;
  initWithCoefficient_constant(coefficient: number, constant: number): InitializedType;
}
interface NSUnitConverterLinear extends NSUnitConverter, INSSecureCoding {

  coefficient(): number;
  constant(): number;
}
declare const NSUnitConverterLinear: {
  alloc(): NSUnitConverterLinearAllocator;
}

interface NSUnitAllocator<InitializedType = NSUnit> extends NSObjectAllocator<NSUnit> {
  initWithSymbol(symbol: NSString | string): InitializedType;
}
interface NSUnit extends NSObject, INSCopying, INSSecureCoding {

  symbol(): NSString;
}
declare const NSUnit: {
  alloc(): NSUnitAllocator;
}

interface NSDimensionAllocator<InitializedType = NSDimension> extends NSUnitAllocator<NSDimension> {
  initWithSymbol_converter(symbol: NSString | string, converter: NSUnitConverter): InitializedType;
}
interface NSDimension extends NSUnit, INSSecureCoding {

  converter(): NSUnitConverter;
}
declare const NSDimension: {
  alloc(): NSDimensionAllocator;  baseUnit(): NSDimension;

}

interface NSUnitAccelerationAllocator<InitializedType = NSUnitAcceleration> extends NSDimensionAllocator<NSUnitAcceleration> {}
interface NSUnitAcceleration extends NSDimension, INSSecureCoding {
}
declare const NSUnitAcceleration: {
  alloc(): NSUnitAccelerationAllocator;
  metersPerSecondSquared(): NSUnitAcceleration;
  gravity(): NSUnitAcceleration;

}

interface NSUnitAngleAllocator<InitializedType = NSUnitAngle> extends NSDimensionAllocator<NSUnitAngle> {}
interface NSUnitAngle extends NSDimension, INSSecureCoding {
}
declare const NSUnitAngle: {
  alloc(): NSUnitAngleAllocator;
  degrees(): NSUnitAngle;
  arcMinutes(): NSUnitAngle;
  arcSeconds(): NSUnitAngle;
  radians(): NSUnitAngle;
  gradians(): NSUnitAngle;
  revolutions(): NSUnitAngle;

}

interface NSUnitAreaAllocator<InitializedType = NSUnitArea> extends NSDimensionAllocator<NSUnitArea> {}
interface NSUnitArea extends NSDimension, INSSecureCoding {
}
declare const NSUnitArea: {
  alloc(): NSUnitAreaAllocator;
  squareMegameters(): NSUnitArea;
  squareKilometers(): NSUnitArea;
  squareMeters(): NSUnitArea;
  squareCentimeters(): NSUnitArea;
  squareMillimeters(): NSUnitArea;
  squareMicrometers(): NSUnitArea;
  squareNanometers(): NSUnitArea;
  squareInches(): NSUnitArea;
  squareFeet(): NSUnitArea;
  squareYards(): NSUnitArea;
  squareMiles(): NSUnitArea;
  acres(): NSUnitArea;
  ares(): NSUnitArea;
  hectares(): NSUnitArea;

}

interface NSUnitConcentrationMassAllocator<InitializedType = NSUnitConcentrationMass> extends NSDimensionAllocator<NSUnitConcentrationMass> {}
interface NSUnitConcentrationMass extends NSDimension, INSSecureCoding {
}
declare const NSUnitConcentrationMass: {
  alloc(): NSUnitConcentrationMassAllocator;  millimolesPerLiterWithGramsPerMole(gramsPerMole: number): NSUnitConcentrationMass;

  gramsPerLiter(): NSUnitConcentrationMass;
  milligramsPerDeciliter(): NSUnitConcentrationMass;

}

interface NSUnitDispersionAllocator<InitializedType = NSUnitDispersion> extends NSDimensionAllocator<NSUnitDispersion> {}
interface NSUnitDispersion extends NSDimension, INSSecureCoding {
}
declare const NSUnitDispersion: {
  alloc(): NSUnitDispersionAllocator;
  partsPerMillion(): NSUnitDispersion;

}

interface NSUnitDurationAllocator<InitializedType = NSUnitDuration> extends NSDimensionAllocator<NSUnitDuration> {}
interface NSUnitDuration extends NSDimension, INSSecureCoding {
}
declare const NSUnitDuration: {
  alloc(): NSUnitDurationAllocator;
  seconds(): NSUnitDuration;
  minutes(): NSUnitDuration;
  hours(): NSUnitDuration;

}

interface NSUnitElectricChargeAllocator<InitializedType = NSUnitElectricCharge> extends NSDimensionAllocator<NSUnitElectricCharge> {}
interface NSUnitElectricCharge extends NSDimension, INSSecureCoding {
}
declare const NSUnitElectricCharge: {
  alloc(): NSUnitElectricChargeAllocator;
  coulombs(): NSUnitElectricCharge;
  megaampereHours(): NSUnitElectricCharge;
  kiloampereHours(): NSUnitElectricCharge;
  ampereHours(): NSUnitElectricCharge;
  milliampereHours(): NSUnitElectricCharge;
  microampereHours(): NSUnitElectricCharge;

}

interface NSUnitElectricCurrentAllocator<InitializedType = NSUnitElectricCurrent> extends NSDimensionAllocator<NSUnitElectricCurrent> {}
interface NSUnitElectricCurrent extends NSDimension, INSSecureCoding {
}
declare const NSUnitElectricCurrent: {
  alloc(): NSUnitElectricCurrentAllocator;
  megaamperes(): NSUnitElectricCurrent;
  kiloamperes(): NSUnitElectricCurrent;
  amperes(): NSUnitElectricCurrent;
  milliamperes(): NSUnitElectricCurrent;
  microamperes(): NSUnitElectricCurrent;

}

interface NSUnitElectricPotentialDifferenceAllocator<InitializedType = NSUnitElectricPotentialDifference> extends NSDimensionAllocator<NSUnitElectricPotentialDifference> {}
interface NSUnitElectricPotentialDifference extends NSDimension, INSSecureCoding {
}
declare const NSUnitElectricPotentialDifference: {
  alloc(): NSUnitElectricPotentialDifferenceAllocator;
  megavolts(): NSUnitElectricPotentialDifference;
  kilovolts(): NSUnitElectricPotentialDifference;
  volts(): NSUnitElectricPotentialDifference;
  millivolts(): NSUnitElectricPotentialDifference;
  microvolts(): NSUnitElectricPotentialDifference;

}

interface NSUnitElectricResistanceAllocator<InitializedType = NSUnitElectricResistance> extends NSDimensionAllocator<NSUnitElectricResistance> {}
interface NSUnitElectricResistance extends NSDimension, INSSecureCoding {
}
declare const NSUnitElectricResistance: {
  alloc(): NSUnitElectricResistanceAllocator;
  megaohms(): NSUnitElectricResistance;
  kiloohms(): NSUnitElectricResistance;
  ohms(): NSUnitElectricResistance;
  milliohms(): NSUnitElectricResistance;
  microohms(): NSUnitElectricResistance;

}

interface NSUnitEnergyAllocator<InitializedType = NSUnitEnergy> extends NSDimensionAllocator<NSUnitEnergy> {}
interface NSUnitEnergy extends NSDimension, INSSecureCoding {
}
declare const NSUnitEnergy: {
  alloc(): NSUnitEnergyAllocator;
  kilojoules(): NSUnitEnergy;
  joules(): NSUnitEnergy;
  kilocalories(): NSUnitEnergy;
  calories(): NSUnitEnergy;
  kilowattHours(): NSUnitEnergy;

}

interface NSUnitFrequencyAllocator<InitializedType = NSUnitFrequency> extends NSDimensionAllocator<NSUnitFrequency> {}
interface NSUnitFrequency extends NSDimension, INSSecureCoding {
}
declare const NSUnitFrequency: {
  alloc(): NSUnitFrequencyAllocator;
  terahertz(): NSUnitFrequency;
  gigahertz(): NSUnitFrequency;
  megahertz(): NSUnitFrequency;
  kilohertz(): NSUnitFrequency;
  hertz(): NSUnitFrequency;
  millihertz(): NSUnitFrequency;
  microhertz(): NSUnitFrequency;
  nanohertz(): NSUnitFrequency;

}

interface NSUnitFuelEfficiencyAllocator<InitializedType = NSUnitFuelEfficiency> extends NSDimensionAllocator<NSUnitFuelEfficiency> {}
interface NSUnitFuelEfficiency extends NSDimension, INSSecureCoding {
}
declare const NSUnitFuelEfficiency: {
  alloc(): NSUnitFuelEfficiencyAllocator;
  litersPer100Kilometers(): NSUnitFuelEfficiency;
  milesPerImperialGallon(): NSUnitFuelEfficiency;
  milesPerGallon(): NSUnitFuelEfficiency;

}

interface NSUnitLengthAllocator<InitializedType = NSUnitLength> extends NSDimensionAllocator<NSUnitLength> {}
interface NSUnitLength extends NSDimension, INSSecureCoding {
}
declare const NSUnitLength: {
  alloc(): NSUnitLengthAllocator;
  megameters(): NSUnitLength;
  kilometers(): NSUnitLength;
  hectometers(): NSUnitLength;
  decameters(): NSUnitLength;
  meters(): NSUnitLength;
  decimeters(): NSUnitLength;
  centimeters(): NSUnitLength;
  millimeters(): NSUnitLength;
  micrometers(): NSUnitLength;
  nanometers(): NSUnitLength;
  picometers(): NSUnitLength;
  inches(): NSUnitLength;
  feet(): NSUnitLength;
  yards(): NSUnitLength;
  miles(): NSUnitLength;
  scandinavianMiles(): NSUnitLength;
  lightyears(): NSUnitLength;
  nauticalMiles(): NSUnitLength;
  fathoms(): NSUnitLength;
  furlongs(): NSUnitLength;
  astronomicalUnits(): NSUnitLength;
  parsecs(): NSUnitLength;

}

interface NSUnitIlluminanceAllocator<InitializedType = NSUnitIlluminance> extends NSDimensionAllocator<NSUnitIlluminance> {}
interface NSUnitIlluminance extends NSDimension, INSSecureCoding {
}
declare const NSUnitIlluminance: {
  alloc(): NSUnitIlluminanceAllocator;
  lux(): NSUnitIlluminance;

}

interface NSUnitMassAllocator<InitializedType = NSUnitMass> extends NSDimensionAllocator<NSUnitMass> {}
interface NSUnitMass extends NSDimension, INSSecureCoding {
}
declare const NSUnitMass: {
  alloc(): NSUnitMassAllocator;
  kilograms(): NSUnitMass;
  grams(): NSUnitMass;
  decigrams(): NSUnitMass;
  centigrams(): NSUnitMass;
  milligrams(): NSUnitMass;
  micrograms(): NSUnitMass;
  nanograms(): NSUnitMass;
  picograms(): NSUnitMass;
  ounces(): NSUnitMass;
  poundsMass(): NSUnitMass;
  stones(): NSUnitMass;
  metricTons(): NSUnitMass;
  shortTons(): NSUnitMass;
  carats(): NSUnitMass;
  ouncesTroy(): NSUnitMass;
  slugs(): NSUnitMass;

}

interface NSUnitPowerAllocator<InitializedType = NSUnitPower> extends NSDimensionAllocator<NSUnitPower> {}
interface NSUnitPower extends NSDimension, INSSecureCoding {
}
declare const NSUnitPower: {
  alloc(): NSUnitPowerAllocator;
  terawatts(): NSUnitPower;
  gigawatts(): NSUnitPower;
  megawatts(): NSUnitPower;
  kilowatts(): NSUnitPower;
  watts(): NSUnitPower;
  milliwatts(): NSUnitPower;
  microwatts(): NSUnitPower;
  nanowatts(): NSUnitPower;
  picowatts(): NSUnitPower;
  femtowatts(): NSUnitPower;
  horsepower(): NSUnitPower;

}

interface NSUnitPressureAllocator<InitializedType = NSUnitPressure> extends NSDimensionAllocator<NSUnitPressure> {}
interface NSUnitPressure extends NSDimension, INSSecureCoding {
}
declare const NSUnitPressure: {
  alloc(): NSUnitPressureAllocator;
  newtonsPerMetersSquared(): NSUnitPressure;
  gigapascals(): NSUnitPressure;
  megapascals(): NSUnitPressure;
  kilopascals(): NSUnitPressure;
  hectopascals(): NSUnitPressure;
  inchesOfMercury(): NSUnitPressure;
  bars(): NSUnitPressure;
  millibars(): NSUnitPressure;
  millimetersOfMercury(): NSUnitPressure;
  poundsForcePerSquareInch(): NSUnitPressure;

}

interface NSUnitSpeedAllocator<InitializedType = NSUnitSpeed> extends NSDimensionAllocator<NSUnitSpeed> {}
interface NSUnitSpeed extends NSDimension, INSSecureCoding {
}
declare const NSUnitSpeed: {
  alloc(): NSUnitSpeedAllocator;
  metersPerSecond(): NSUnitSpeed;
  kilometersPerHour(): NSUnitSpeed;
  milesPerHour(): NSUnitSpeed;
  knots(): NSUnitSpeed;

}

interface NSUnitTemperatureAllocator<InitializedType = NSUnitTemperature> extends NSDimensionAllocator<NSUnitTemperature> {}
interface NSUnitTemperature extends NSDimension, INSSecureCoding {
}
declare const NSUnitTemperature: {
  alloc(): NSUnitTemperatureAllocator;
  kelvin(): NSUnitTemperature;
  celsius(): NSUnitTemperature;
  fahrenheit(): NSUnitTemperature;

}

interface NSUnitVolumeAllocator<InitializedType = NSUnitVolume> extends NSDimensionAllocator<NSUnitVolume> {}
interface NSUnitVolume extends NSDimension, INSSecureCoding {
}
declare const NSUnitVolume: {
  alloc(): NSUnitVolumeAllocator;
  megaliters(): NSUnitVolume;
  kiloliters(): NSUnitVolume;
  liters(): NSUnitVolume;
  deciliters(): NSUnitVolume;
  centiliters(): NSUnitVolume;
  milliliters(): NSUnitVolume;
  cubicKilometers(): NSUnitVolume;
  cubicMeters(): NSUnitVolume;
  cubicDecimeters(): NSUnitVolume;
  cubicCentimeters(): NSUnitVolume;
  cubicMillimeters(): NSUnitVolume;
  cubicInches(): NSUnitVolume;
  cubicFeet(): NSUnitVolume;
  cubicYards(): NSUnitVolume;
  cubicMiles(): NSUnitVolume;
  acreFeet(): NSUnitVolume;
  bushels(): NSUnitVolume;
  teaspoons(): NSUnitVolume;
  tablespoons(): NSUnitVolume;
  fluidOunces(): NSUnitVolume;
  cups(): NSUnitVolume;
  pints(): NSUnitVolume;
  quarts(): NSUnitVolume;
  gallons(): NSUnitVolume;
  imperialTeaspoons(): NSUnitVolume;
  imperialTablespoons(): NSUnitVolume;
  imperialFluidOunces(): NSUnitVolume;
  imperialPints(): NSUnitVolume;
  imperialQuarts(): NSUnitVolume;
  imperialGallons(): NSUnitVolume;
  metricCups(): NSUnitVolume;

}

interface NSUserActivityAllocator<InitializedType = NSUserActivity> extends NSObjectAllocator<NSUserActivity> {
  initWithActivityType(activityType: NSString | string): InitializedType;
  init(): InitializedType;
}
interface NSUserActivity extends NSObject {
  addUserInfoEntriesFromDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  becomeCurrent(): void;
  resignCurrent(): void;
  invalidate(): void;
  getContinuationStreamsWithCompletionHandler(completionHandler: Block): void;

  activityType(): NSString;
  title(): NSString;
  setTitle(title: NSString | string): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  requiredUserInfoKeys(): NSSet<any>;
  setRequiredUserInfoKeys(requiredUserInfoKeys: NSSet<any>): void;
  needsSave(): boolean;
  setNeedsSave(needsSave: boolean): void;
  webpageURL(): NSURL;
  setWebpageURL(webpageURL: NSURL): void;
  referrerURL(): NSURL;
  setReferrerURL(referrerURL: NSURL): void;
  expirationDate(): NSDate;
  setExpirationDate(expirationDate: NSDate): void;
  keywords(): NSSet<any>;
  setKeywords(keywords: NSSet<any>): void;
  supportsContinuationStreams(): boolean;
  setSupportsContinuationStreams(supportsContinuationStreams: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  eligibleForHandoff(): boolean;
  setEligibleForHandoff(eligibleForHandoff: boolean): void;
  eligibleForSearch(): boolean;
  setEligibleForSearch(eligibleForSearch: boolean): void;
  eligibleForPublicIndexing(): boolean;
  setEligibleForPublicIndexing(eligibleForPublicIndexing: boolean): void;
}
declare const NSUserActivity: {
  alloc(): NSUserActivityAllocator;
}

interface INSUserActivityDelegate {
  userActivityWillSave(userActivity: NSUserActivity): void;
  userActivityWasContinued(userActivity: NSUserActivity): void;
  userActivity_didReceiveInputStream_outputStream(userActivity: NSUserActivity, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

interface NSUserDefaultsAllocator<InitializedType = NSUserDefaults> extends NSObjectAllocator<NSUserDefaults> {
  init(): InitializedType;
  initWithSuiteName(suitename: NSString | string | null): InitializedType;
  initWithUser(username: NSString | string): InitializedType;
}
interface NSUserDefaults extends NSObject {
  objectForKey(defaultName: NSString | string): any;
  setObject_forKey(value: any | null, defaultName: NSString | string): void;
  removeObjectForKey(defaultName: NSString | string): void;
  stringForKey(defaultName: NSString | string): NSString;
  arrayForKey(defaultName: NSString | string): NSArray<any>;
  dictionaryForKey(defaultName: NSString | string): NSDictionary<any, any>;
  dataForKey(defaultName: NSString | string): NSData;
  stringArrayForKey(defaultName: NSString | string): NSArray<any>;
  integerForKey(defaultName: NSString | string): NSInteger;
  floatForKey(defaultName: NSString | string): number;
  doubleForKey(defaultName: NSString | string): number;
  boolForKey(defaultName: NSString | string): boolean;
  URLForKey(defaultName: NSString | string): NSURL;
  setInteger_forKey(value: NSInteger, defaultName: NSString | string): void;
  setFloat_forKey(value: number, defaultName: NSString | string): void;
  setDouble_forKey(value: number, defaultName: NSString | string): void;
  setBool_forKey(value: boolean, defaultName: NSString | string): void;
  setURL_forKey(url: NSURL | null, defaultName: NSString | string): void;
  registerDefaults(registrationDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  addSuiteNamed(suiteName: NSString | string): void;
  removeSuiteNamed(suiteName: NSString | string): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
  volatileDomainForName(domainName: NSString | string): NSDictionary<any, any>;
  setVolatileDomain_forName(domain: NSDictionary<any, any> | {[key: string]: any}, domainName: NSString | string): void;
  removeVolatileDomainForName(domainName: NSString | string): void;
  persistentDomainNames(): NSArray<any>;
  persistentDomainForName(domainName: NSString | string): NSDictionary<any, any>;
  setPersistentDomain_forName(domain: NSDictionary<any, any> | {[key: string]: any}, domainName: NSString | string): void;
  removePersistentDomainForName(domainName: NSString | string): void;
  synchronize(): boolean;
  objectIsForcedForKey(key: NSString | string): boolean;
  objectIsForcedForKey_inDomain(key: NSString | string, domain: NSString | string): boolean;
  setColor_forKey(color: NSColor, key: NSString | string): void;
  colorForKey(key: NSString | string): NSColor;

  volatileDomainNames(): NSArray<any>;
}
declare const NSUserDefaults: {
  alloc(): NSUserDefaultsAllocator;  resetStandardUserDefaults(): void;

  standardUserDefaults(): NSUserDefaults;

}

interface NSUserNotificationAllocator<InitializedType = NSUserNotification> extends NSObjectAllocator<NSUserNotification> {
  init(): InitializedType;
}
interface NSUserNotification extends NSObject, INSCopying {

  title(): NSString;
  setTitle(title: NSString | string): void;
  subtitle(): NSString;
  setSubtitle(subtitle: NSString | string): void;
  informativeText(): NSString;
  setInformativeText(informativeText: NSString | string): void;
  actionButtonTitle(): NSString;
  setActionButtonTitle(actionButtonTitle: NSString | string): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  deliveryDate(): NSDate;
  setDeliveryDate(deliveryDate: NSDate): void;
  deliveryTimeZone(): NSTimeZone;
  setDeliveryTimeZone(deliveryTimeZone: NSTimeZone): void;
  deliveryRepeatInterval(): NSDateComponents;
  setDeliveryRepeatInterval(deliveryRepeatInterval: NSDateComponents): void;
  actualDeliveryDate(): NSDate;
  presented(): boolean;
  remote(): boolean;
  soundName(): NSString;
  setSoundName(soundName: NSString | string): void;
  hasActionButton(): boolean;
  setHasActionButton(hasActionButton: boolean): void;
  activationType(): NSUserNotificationActivationType;
  otherButtonTitle(): NSString;
  setOtherButtonTitle(otherButtonTitle: NSString | string): void;
  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  contentImage(): NSImage;
  setContentImage(contentImage: NSImage): void;
  hasReplyButton(): boolean;
  setHasReplyButton(hasReplyButton: boolean): void;
  responsePlaceholder(): NSString;
  setResponsePlaceholder(responsePlaceholder: NSString | string): void;
  response(): NSAttributedString;
  additionalActions(): NSArray<any>;
  setAdditionalActions(additionalActions: NSArray<any> | any[]): void;
  additionalActivationAction(): NSUserNotificationAction;
}
declare const NSUserNotification: {
  alloc(): NSUserNotificationAllocator;
}

interface NSUserNotificationActionAllocator<InitializedType = NSUserNotificationAction> extends NSObjectAllocator<NSUserNotificationAction> {}
interface NSUserNotificationAction extends NSObject, INSCopying {

  identifier(): NSString;
  title(): NSString;
}
declare const NSUserNotificationAction: {
  alloc(): NSUserNotificationActionAllocator;  actionWithIdentifier_title(identifier: NSString | string | null, title: NSString | string | null): NSUserNotificationAction;

}

interface NSUserNotificationCenterAllocator<InitializedType = NSUserNotificationCenter> extends NSObjectAllocator<NSUserNotificationCenter> {}
interface NSUserNotificationCenter extends NSObject {
  scheduleNotification(notification: NSUserNotification): void;
  removeScheduledNotification(notification: NSUserNotification): void;
  deliverNotification(notification: NSUserNotification): void;
  removeDeliveredNotification(notification: NSUserNotification): void;
  removeAllDeliveredNotifications(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  scheduledNotifications(): NSArray<any>;
  setScheduledNotifications(scheduledNotifications: NSArray<any> | any[]): void;
  deliveredNotifications(): NSArray<any>;
}
declare const NSUserNotificationCenter: {
  alloc(): NSUserNotificationCenterAllocator;
  defaultUserNotificationCenter(): NSUserNotificationCenter;

}

interface INSUserNotificationCenterDelegate {
  userNotificationCenter_didDeliverNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_didActivateNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_shouldPresentNotification(center: NSUserNotificationCenter, notification: NSUserNotification): boolean;
}

declare enum NSUserNotificationActivationType {
  NSUserNotificationActivationTypeNone = 0,
  NSUserNotificationActivationTypeContentsClicked = 1,
  NSUserNotificationActivationTypeActionButtonClicked = 2,
  NSUserNotificationActivationTypeReplied = 3,
  NSUserNotificationActivationTypeAdditionalActionClicked = 4,
}

interface NSUserScriptTaskAllocator<InitializedType = NSUserScriptTask> extends NSObjectAllocator<NSUserScriptTask> {
  initWithURL_error(url: NSURL, error: NSError): InitializedType;
}
interface NSUserScriptTask extends NSObject {
  executeWithCompletionHandler(handler: NSUserScriptTaskCompletionHandler | null): void;

  scriptURL(): NSURL;
}
declare const NSUserScriptTask: {
  alloc(): NSUserScriptTaskAllocator;
}

interface NSUserUnixTaskAllocator<InitializedType = NSUserUnixTask> extends NSUserScriptTaskAllocator<NSUserUnixTask> {}
interface NSUserUnixTask extends NSUserScriptTask {
  executeWithArguments_completionHandler(arguments: NSArray<any> | any[] | null, handler: NSUserUnixTaskCompletionHandler | null): void;

  standardInput(): NSFileHandle;
  setStandardInput(standardInput: NSFileHandle): void;
  standardOutput(): NSFileHandle;
  setStandardOutput(standardOutput: NSFileHandle): void;
  standardError(): NSFileHandle;
  setStandardError(standardError: NSFileHandle): void;
}
declare const NSUserUnixTask: {
  alloc(): NSUserUnixTaskAllocator;
}

interface NSUserAppleScriptTaskAllocator<InitializedType = NSUserAppleScriptTask> extends NSUserScriptTaskAllocator<NSUserAppleScriptTask> {}
interface NSUserAppleScriptTask extends NSUserScriptTask {
  executeWithAppleEvent_completionHandler(event: NSAppleEventDescriptor | null, handler: NSUserAppleScriptTaskCompletionHandler | null): void;
}
declare const NSUserAppleScriptTask: {
  alloc(): NSUserAppleScriptTaskAllocator;
}

interface NSUserAutomatorTaskAllocator<InitializedType = NSUserAutomatorTask> extends NSUserScriptTaskAllocator<NSUserAutomatorTask> {}
interface NSUserAutomatorTask extends NSUserScriptTask {
  executeWithInput_completionHandler(input: any | null, handler: NSUserAutomatorTaskCompletionHandler | null): void;

  variables(): NSDictionary<any, any>;
  setVariables(variables: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const NSUserAutomatorTask: {
  alloc(): NSUserAutomatorTaskAllocator;
}

interface NSValueTransformerAllocator<InitializedType = NSValueTransformer> extends NSObjectAllocator<NSValueTransformer> {}
interface NSValueTransformer extends NSObject {
  transformedValue(value: any | null): any;
  reverseTransformedValue(value: any | null): any;
}
declare const NSValueTransformer: {
  alloc(): NSValueTransformerAllocator;  setValueTransformer_forName(transformer: NSValueTransformer | null, name: NSValueTransformerName): void;
  valueTransformerForName(name: NSValueTransformerName): NSValueTransformer;
  valueTransformerNames(): NSArray<any>;
  transformedValueClass(): any;
  allowsReverseTransformation(): boolean;

}

declare type NSValueTransformerName = NSString

interface NSXMLDTDAllocator<InitializedType = NSXMLDTD> extends NSXMLNodeAllocator<NSXMLDTD> {
  initWithContentsOfURL_options_error(url: NSURL, mask: NSXMLNodeOptions, error: NSError): InitializedType;
  initWithData_options_error(data: NSData, mask: NSXMLNodeOptions, error: NSError): InitializedType;
}
interface NSXMLDTD extends NSXMLNode {
  insertChild_atIndex(child: NSXMLNode, index: NSUInteger): void;
  insertChildren_atIndex(children: NSArray<any> | any[], index: NSUInteger): void;
  removeChildAtIndex(index: NSUInteger): void;
  setChildren(children: NSArray<any> | any[] | null): void;
  addChild(child: NSXMLNode): void;
  replaceChildAtIndex_withNode(index: NSUInteger, node: NSXMLNode): void;
  entityDeclarationForName(name: NSString | string): NSXMLDTDNode;
  notationDeclarationForName(name: NSString | string): NSXMLDTDNode;
  elementDeclarationForName(name: NSString | string): NSXMLDTDNode;
  attributeDeclarationForName_elementName(name: NSString | string, elementName: NSString | string): NSXMLDTDNode;

  publicID(): NSString;
  setPublicID(publicID: NSString | string): void;
  systemID(): NSString;
  setSystemID(systemID: NSString | string): void;
}
declare const NSXMLDTD: {
  alloc(): NSXMLDTDAllocator;  predefinedEntityDeclarationForName(name: NSString | string): NSXMLDTDNode;

}

interface NSXMLDTDNodeAllocator<InitializedType = NSXMLDTDNode> extends NSXMLNodeAllocator<NSXMLDTDNode> {
  initWithXMLString(string: NSString | string): InitializedType;
}
interface NSXMLDTDNode extends NSXMLNode {

  DTDKind(): NSXMLDTDNodeKind;
  setDTDKind(DTDKind: NSXMLDTDNodeKind): void;
  external(): boolean;
  publicID(): NSString;
  setPublicID(publicID: NSString | string): void;
  systemID(): NSString;
  setSystemID(systemID: NSString | string): void;
  notationName(): NSString;
  setNotationName(notationName: NSString | string): void;
}
declare const NSXMLDTDNode: {
  alloc(): NSXMLDTDNodeAllocator;
}

declare enum NSXMLDTDNodeKind {
  NSXMLEntityGeneralKind = 1,
  NSXMLEntityParsedKind,
  NSXMLEntityUnparsedKind,
  NSXMLEntityParameterKind,
  NSXMLEntityPredefined,
  NSXMLAttributeCDATAKind,
  NSXMLAttributeIDKind,
  NSXMLAttributeIDRefKind,
  NSXMLAttributeIDRefsKind,
  NSXMLAttributeEntityKind,
  NSXMLAttributeEntitiesKind,
  NSXMLAttributeNMTokenKind,
  NSXMLAttributeNMTokensKind,
  NSXMLAttributeEnumerationKind,
  NSXMLAttributeNotationKind,
  NSXMLElementDeclarationUndefinedKind,
  NSXMLElementDeclarationEmptyKind,
  NSXMLElementDeclarationAnyKind,
  NSXMLElementDeclarationMixedKind,
  NSXMLElementDeclarationElementKind,
}

interface NSXMLDocumentAllocator<InitializedType = NSXMLDocument> extends NSXMLNodeAllocator<NSXMLDocument> {
  initWithXMLString_options_error(string: NSString | string, mask: NSXMLNodeOptions, error: NSError): InitializedType;
  initWithContentsOfURL_options_error(url: NSURL, mask: NSXMLNodeOptions, error: NSError): InitializedType;
  initWithData_options_error(data: NSData, mask: NSXMLNodeOptions, error: NSError): InitializedType;
  initWithRootElement(element: NSXMLElement | null): InitializedType;
}
interface NSXMLDocument extends NSXMLNode {
  setRootElement(root: NSXMLElement): void;
  rootElement(): NSXMLElement;
  insertChild_atIndex(child: NSXMLNode, index: NSUInteger): void;
  insertChildren_atIndex(children: NSArray<any> | any[], index: NSUInteger): void;
  removeChildAtIndex(index: NSUInteger): void;
  setChildren(children: NSArray<any> | any[] | null): void;
  addChild(child: NSXMLNode): void;
  replaceChildAtIndex_withNode(index: NSUInteger, node: NSXMLNode): void;
  XMLDataWithOptions(options: NSXMLNodeOptions): NSData;
  objectByApplyingXSLT_arguments_error(xslt: NSData, arguments: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): any;
  objectByApplyingXSLTString_arguments_error(xslt: NSString | string, arguments: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): any;
  objectByApplyingXSLTAtURL_arguments_error(xsltURL: NSURL, argument: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): any;
  validateAndReturnError(error: NSError): boolean;
  createSVGForBezierPath(bezierPath: NSBezierPath): any;
  bezierPathElement(path: NSBezierPath): NSXMLNode;
  data(): NSData;

  characterEncoding(): NSString;
  setCharacterEncoding(characterEncoding: NSString | string): void;
  version(): NSString;
  setVersion(version: NSString | string): void;
  standalone(): boolean;
  setStandalone(standalone: boolean): void;
  documentContentKind(): NSXMLDocumentContentKind;
  setDocumentContentKind(documentContentKind: NSXMLDocumentContentKind): void;
  MIMEType(): NSString;
  setMIMEType(MIMEType: NSString | string): void;
  DTD(): NSXMLDTD;
  setDTD(DTD: NSXMLDTD): void;
  XMLData(): NSData;
}
declare const NSXMLDocument: {
  alloc(): NSXMLDocumentAllocator;  replacementClassForClass(cls: any): any;
  SVGDocumentWithBezierPath(bezierPath: NSBezierPath): any;

}

declare enum NSXMLDocumentContentKind {
  NSXMLDocumentXMLKind = 0,
  NSXMLDocumentXHTMLKind,
  NSXMLDocumentHTMLKind,
  NSXMLDocumentTextKind,
}

interface NSXMLElementAllocator<InitializedType = NSXMLElement> extends NSXMLNodeAllocator<NSXMLElement> {
  initWithName(name: NSString | string): InitializedType;
  initWithName_URI(name: NSString | string, URI: NSString | string | null): InitializedType;
  initWithName_stringValue(name: NSString | string, string: NSString | string | null): InitializedType;
  initWithXMLString_error(string: NSString | string, error: NSError): InitializedType;
}
interface NSXMLElement extends NSXMLNode {
  elementsForName(name: NSString | string): NSArray<any>;
  elementsForLocalName_URI(localName: NSString | string, URI: NSString | string | null): NSArray<any>;
  addAttribute(attribute: NSXMLNode): void;
  removeAttributeForName(name: NSString | string): void;
  setAttributesWithDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  attributeForName(name: NSString | string): NSXMLNode;
  attributeForLocalName_URI(localName: NSString | string, URI: NSString | string | null): NSXMLNode;
  addNamespace(aNamespace: NSXMLNode): void;
  removeNamespaceForPrefix(name: NSString | string): void;
  namespaceForPrefix(name: NSString | string): NSXMLNode;
  resolveNamespaceForName(name: NSString | string): NSXMLNode;
  resolvePrefixForNamespaceURI(namespaceURI: NSString | string): NSString;
  insertChild_atIndex(child: NSXMLNode, index: NSUInteger): void;
  insertChildren_atIndex(children: NSArray<any> | any[], index: NSUInteger): void;
  removeChildAtIndex(index: NSUInteger): void;
  setChildren(children: NSArray<any> | any[] | null): void;
  addChild(child: NSXMLNode): void;
  replaceChildAtIndex_withNode(index: NSUInteger, node: NSXMLNode): void;
  normalizeAdjacentTextNodesPreservingCDATA(preserve: boolean): void;
  setAttributesAsDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  gotAttributeWithName(name: NSString | string): boolean;
  doubleValueFromAttributeWithName(name: NSString | string): number;
  doubleValueFromAttributeWithName_scale(name: NSString | string, scale: CGFloat): number;
  doubleValueFromAttributeWithName_orDefault(name: NSString | string, def: number): number;
  doubleValueFromPercentageAttributeWithName(name: NSString | string): number;
  doubleValueFromPercentageAttributeWithName_orDefault(name: NSString | string, def: number): number;
  doubleValueFromAttributeWithName_alternate(name: NSString | string, alternate: NSString | string): number;
  doubleValueFromPercentageAttributeWithName_alternate(name: NSString | string, alternate: NSString | string): number;
  numberFromAttributeWithName(name: NSString | string): NSNumber;
  numberFromAttributeWithName_scale(name: NSString | string, scale: CGFloat): NSNumber;
  numbersFromAttributeWithName(name: NSString | string): NSArray<any>;
  numbersFromAttributeWithName_scale(name: NSString | string, scale: CGFloat): NSArray<any>;
  intValueFromAttributeWithName(name: NSString | string): NSInteger;
  rectValueFromAttributeWithName(name: NSString | string): NSRect;
  rectValue(): NSRect;
  rectValueWithXScale_yScale(xScale: CGFloat, yScale: CGFloat): NSRect;
  colorFromAttributeWithName(name: NSString | string): MSImmutableColor;
  stringFromAttributeWithName(name: NSString | string): NSString;
  stringFromAttributeWithName_orDefault(name: NSString | string, def: NSString | string): NSString;
  stringForHREFLink(): NSString;
  nodeOrParentNodeWithName(name: NSString | string): NSXMLNode;
  attributesWithStyleMergedDefaults(defaults: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  simplifyAttributesIgnoringElements_attributes(elementsToIgnore: NSArray<any> | any[], attributesToIgnore: NSArray<any> | any[]): NSArray<any>;
  urlLink(): NSString;
  localLink(): NSString;
  cssClassNamesWithBase(base: NSString | string): NSArray<any>;
  addAttributeWithName_stringValue(name: NSString | string, value: NSString | string): void;
  addAttributeWithName_pixelValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_numberValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageFractionalValue(name: NSString | string, value: CGFloat): void;

  attributes(): NSArray<any>;
  setAttributes(attributes: NSArray<any> | any[]): void;
  namespaces(): NSArray<any>;
  setNamespaces(namespaces: NSArray<any> | any[]): void;
}
declare const NSXMLElement: {
  alloc(): NSXMLElementAllocator;
}

interface NSXMLNodeAllocator<InitializedType = NSXMLNode> extends NSObjectAllocator<NSXMLNode> {
  init(): InitializedType;
  initWithKind(kind: NSXMLNodeKind): InitializedType;
  initWithKind_options(kind: NSXMLNodeKind, options: NSXMLNodeOptions): InitializedType;
}
interface NSXMLNode extends NSObject, INSCopying {
  setStringValue_resolvingEntities(string: NSString | string, resolve: boolean): void;
  childAtIndex(index: NSUInteger): NSXMLNode;
  detach(): void;
  XMLStringWithOptions(options: NSXMLNodeOptions): NSString;
  canonicalXMLStringPreservingComments(comments: boolean): NSString;
  nodesForXPath_error(xpath: NSString | string, error: NSError): NSArray<any>;
  objectsForXQuery_constants_error(xquery: NSString | string, constants: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): NSArray<any>;
  objectsForXQuery_error(xquery: NSString | string, error: NSError): NSArray<any>;
  doubleValueFromAttributeWithName(name: NSString | string): number;
  doubleValue(): number;
  doubleValueWithScale(scale: CGFloat): number;
  numberValue(): NSNumber;
  numberValueWithScale(scale: CGFloat): NSNumber;
  numberValues(): NSArray<any>;
  numberValuesWithScale(scale: CGFloat): NSArray<any>;
  integerValue(): NSInteger;
  rectValue(): NSRect;
  simplifyAttributesIgnoringElements_attributes(elementsToIgnore: NSArray<any> | any[], attributesToIgnore: NSArray<any> | any[]): NSArray<any>;
  cssClassNamesWithBase(base: NSString | string): NSArray<any>;

  kind(): NSXMLNodeKind;
  name(): NSString;
  setName(name: NSString | string): void;
  objectValue(): any;
  setObjectValue(objectValue: any): void;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  index(): NSUInteger;
  level(): NSUInteger;
  rootDocument(): NSXMLDocument;
  parent(): NSXMLNode;
  childCount(): NSUInteger;
  children(): NSArray<any>;
  previousSibling(): NSXMLNode;
  nextSibling(): NSXMLNode;
  previousNode(): NSXMLNode;
  nextNode(): NSXMLNode;
  XPath(): NSString;
  localName(): NSString;
  prefix(): NSString;
  URI(): NSString;
  setURI(URI: NSString | string): void;
  description(): NSString;
  XMLString(): NSString;
}
declare const NSXMLNode: {
  alloc(): NSXMLNodeAllocator;  document(): any;
  documentWithRootElement(element: NSXMLElement): any;
  elementWithName(name: NSString | string): any;
  elementWithName_URI(name: NSString | string, URI: NSString | string): any;
  elementWithName_stringValue(name: NSString | string, string: NSString | string): any;
  elementWithName_children_attributes(name: NSString | string, children: NSArray<any> | any[] | null, attributes: NSArray<any> | any[] | null): any;
  attributeWithName_stringValue(name: NSString | string, stringValue: NSString | string): any;
  attributeWithName_URI_stringValue(name: NSString | string, URI: NSString | string, stringValue: NSString | string): any;
  namespaceWithName_stringValue(name: NSString | string, stringValue: NSString | string): any;
  processingInstructionWithName_stringValue(name: NSString | string, stringValue: NSString | string): any;
  commentWithStringValue(stringValue: NSString | string): any;
  textWithStringValue(stringValue: NSString | string): any;
  DTDNodeWithXMLString(string: NSString | string): any;
  localNameForName(name: NSString | string): NSString;
  prefixForName(name: NSString | string): NSString;
  predefinedNamespaceForPrefix(name: NSString | string): NSXMLNode;
  doubleFromString_scale(string: NSString | string, scale: CGFloat): number;
  numberFromString_scale(string: NSString | string, scale: CGFloat): NSNumber;
  numbersFromString_scale(string: NSString | string, scale: CGFloat): NSArray<any>;
  attributeWithName_pixelValue(name: NSString | string, value: CGFloat): any;
  attributeWithName_numberValue(name: NSString | string, value: CGFloat): any;
  attributeWithName_percentageValue(name: NSString | string, value: CGFloat): any;
  attributeWithName_percentageFractionalValue(name: NSString | string, value: CGFloat): any;

}

declare enum NSXMLNodeKind {
  NSXMLInvalidKind = 0,
  NSXMLDocumentKind,
  NSXMLElementKind,
  NSXMLAttributeKind,
  NSXMLNamespaceKind,
  NSXMLProcessingInstructionKind,
  NSXMLCommentKind,
  NSXMLTextKind,
  NSXMLDTDKind,
  NSXMLEntityDeclarationKind,
  NSXMLAttributeDeclarationKind,
  NSXMLElementDeclarationKind,
  NSXMLNotationDeclarationKind,
}

declare enum NSXMLNodeOptions {
  NSXMLNodeOptionsNone = 0,
  NSXMLNodeIsCDATA = 1 << 0,
  NSXMLNodeExpandEmptyElement = 1 << 1,
  NSXMLNodeCompactEmptyElement = 1 << 2,
  NSXMLNodeUseSingleQuotes = 1 << 3,
  NSXMLNodeUseDoubleQuotes = 1 << 4,
  NSXMLNodeNeverEscapeContents = 1 << 5,
  NSXMLDocumentTidyHTML = 1 << 9,
  NSXMLDocumentTidyXML = 1 << 10,
  NSXMLDocumentValidate = 1 << 13,
  NSXMLNodeLoadExternalEntitiesAlways = 1 << 14,
  NSXMLNodeLoadExternalEntitiesSameOriginOnly = 1 << 15,
  NSXMLNodeLoadExternalEntitiesNever = 1 << 19,
  NSXMLDocumentXInclude = 1 << 16,
  NSXMLNodePrettyPrint = 1 << 17,
  NSXMLDocumentIncludeContentTypeDeclaration = 1 << 18,
  NSXMLNodePreserveNamespaceOrder = 1 << 20,
  NSXMLNodePreserveAttributeOrder = 1 << 21,
  NSXMLNodePreserveEntities = 1 << 22,
  NSXMLNodePreservePrefixes = 1 << 23,
  NSXMLNodePreserveCDATA = 1 << 24,
  NSXMLNodePreserveWhitespace = 1 << 25,
  NSXMLNodePreserveDTD = 1 << 26,
  NSXMLNodePreserveCharacterReferences = 1 << 27,
  NSXMLNodePromoteSignificantWhitespace = 1 << 28,
  NSXMLNodePreserveEmptyElements,
  NSXMLNodePreserveQuotes,
  NSXMLNodePreserveAll,
}

interface NSXMLParserAllocator<InitializedType = NSXMLParser> extends NSObjectAllocator<NSXMLParser> {
  initWithContentsOfURL(url: NSURL): InitializedType;
  initWithData(data: NSData): InitializedType;
  initWithStream(stream: NSInputStream): InitializedType;
}
interface NSXMLParser extends NSObject {
  parse(): boolean;
  abortParsing(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  shouldProcessNamespaces(): boolean;
  setShouldProcessNamespaces(shouldProcessNamespaces: boolean): void;
  shouldReportNamespacePrefixes(): boolean;
  setShouldReportNamespacePrefixes(shouldReportNamespacePrefixes: boolean): void;
  externalEntityResolvingPolicy(): NSXMLParserExternalEntityResolvingPolicy;
  setExternalEntityResolvingPolicy(externalEntityResolvingPolicy: NSXMLParserExternalEntityResolvingPolicy): void;
  allowedExternalEntityURLs(): NSSet<any>;
  setAllowedExternalEntityURLs(allowedExternalEntityURLs: NSSet<any>): void;
  parserError(): NSError;
  shouldResolveExternalEntities(): boolean;
  setShouldResolveExternalEntities(shouldResolveExternalEntities: boolean): void;
  publicID(): NSString;
  systemID(): NSString;
  lineNumber(): NSInteger;
  columnNumber(): NSInteger;
}
declare const NSXMLParser: {
  alloc(): NSXMLParserAllocator;
}

interface INSXMLParserDelegate {
  parserDidStartDocument(parser: NSXMLParser): void;
  parserDidEndDocument(parser: NSXMLParser): void;
  parser_foundNotationDeclarationWithName_publicID_systemID(parser: NSXMLParser, name: NSString | string, publicID: NSString | string | null, systemID: NSString | string | null): void;
  parser_foundUnparsedEntityDeclarationWithName_publicID_systemID_notationName(parser: NSXMLParser, name: NSString | string, publicID: NSString | string | null, systemID: NSString | string | null, notationName: NSString | string | null): void;
  parser_foundAttributeDeclarationWithName_forElement_type_defaultValue(parser: NSXMLParser, attributeName: NSString | string, elementName: NSString | string, type: NSString | string | null, defaultValue: NSString | string | null): void;
  parser_foundElementDeclarationWithName_model(parser: NSXMLParser, elementName: NSString | string, model: NSString | string): void;
  parser_foundInternalEntityDeclarationWithName_value(parser: NSXMLParser, name: NSString | string, value: NSString | string | null): void;
  parser_foundExternalEntityDeclarationWithName_publicID_systemID(parser: NSXMLParser, name: NSString | string, publicID: NSString | string | null, systemID: NSString | string | null): void;
  parser_didStartElement_namespaceURI_qualifiedName_attributes(parser: NSXMLParser, elementName: NSString | string, namespaceURI: NSString | string | null, qName: NSString | string | null, attributeDict: NSDictionary<any, any> | {[key: string]: any}): void;
  parser_didEndElement_namespaceURI_qualifiedName(parser: NSXMLParser, elementName: NSString | string, namespaceURI: NSString | string | null, qName: NSString | string | null): void;
  parser_didStartMappingPrefix_toURI(parser: NSXMLParser, prefix: NSString | string, namespaceURI: NSString | string): void;
  parser_didEndMappingPrefix(parser: NSXMLParser, prefix: NSString | string): void;
  parser_foundCharacters(parser: NSXMLParser, string: NSString | string): void;
  parser_foundIgnorableWhitespace(parser: NSXMLParser, whitespaceString: NSString | string): void;
  parser_foundProcessingInstructionWithTarget_data(parser: NSXMLParser, target: NSString | string, data: NSString | string | null): void;
  parser_foundComment(parser: NSXMLParser, comment: NSString | string): void;
  parser_foundCDATA(parser: NSXMLParser, CDATABlock: NSData): void;
  parser_resolveExternalEntityName_systemID(parser: NSXMLParser, name: NSString | string, systemID: NSString | string | null): NSData;
  parser_parseErrorOccurred(parser: NSXMLParser, parseError: NSError): void;
  parser_validationErrorOccurred(parser: NSXMLParser, validationError: NSError): void;
}

declare enum NSXMLParserExternalEntityResolvingPolicy {
  NSXMLParserResolveExternalEntitiesNever = 0,
  NSXMLParserResolveExternalEntitiesNoNetwork,
  NSXMLParserResolveExternalEntitiesSameOriginOnly,
  NSXMLParserResolveExternalEntitiesAlways,
}

declare enum NSXMLParserError {
  NSXMLParserInternalError = 1,
  NSXMLParserOutOfMemoryError = 2,
  NSXMLParserDocumentStartError = 3,
  NSXMLParserEmptyDocumentError = 4,
  NSXMLParserPrematureDocumentEndError = 5,
  NSXMLParserInvalidHexCharacterRefError = 6,
  NSXMLParserInvalidDecimalCharacterRefError = 7,
  NSXMLParserInvalidCharacterRefError = 8,
  NSXMLParserInvalidCharacterError = 9,
  NSXMLParserCharacterRefAtEOFError = 10,
  NSXMLParserCharacterRefInPrologError = 11,
  NSXMLParserCharacterRefInEpilogError = 12,
  NSXMLParserCharacterRefInDTDError = 13,
  NSXMLParserEntityRefAtEOFError = 14,
  NSXMLParserEntityRefInPrologError = 15,
  NSXMLParserEntityRefInEpilogError = 16,
  NSXMLParserEntityRefInDTDError = 17,
  NSXMLParserParsedEntityRefAtEOFError = 18,
  NSXMLParserParsedEntityRefInPrologError = 19,
  NSXMLParserParsedEntityRefInEpilogError = 20,
  NSXMLParserParsedEntityRefInInternalSubsetError = 21,
  NSXMLParserEntityReferenceWithoutNameError = 22,
  NSXMLParserEntityReferenceMissingSemiError = 23,
  NSXMLParserParsedEntityRefNoNameError = 24,
  NSXMLParserParsedEntityRefMissingSemiError = 25,
  NSXMLParserUndeclaredEntityError = 26,
  NSXMLParserUnparsedEntityError = 28,
  NSXMLParserEntityIsExternalError = 29,
  NSXMLParserEntityIsParameterError = 30,
  NSXMLParserUnknownEncodingError = 31,
  NSXMLParserEncodingNotSupportedError = 32,
  NSXMLParserStringNotStartedError = 33,
  NSXMLParserStringNotClosedError = 34,
  NSXMLParserNamespaceDeclarationError = 35,
  NSXMLParserEntityNotStartedError = 36,
  NSXMLParserEntityNotFinishedError = 37,
  NSXMLParserLessThanSymbolInAttributeError = 38,
  NSXMLParserAttributeNotStartedError = 39,
  NSXMLParserAttributeNotFinishedError = 40,
  NSXMLParserAttributeHasNoValueError = 41,
  NSXMLParserAttributeRedefinedError = 42,
  NSXMLParserLiteralNotStartedError = 43,
  NSXMLParserLiteralNotFinishedError = 44,
  NSXMLParserCommentNotFinishedError = 45,
  NSXMLParserProcessingInstructionNotStartedError = 46,
  NSXMLParserProcessingInstructionNotFinishedError = 47,
  NSXMLParserNotationNotStartedError = 48,
  NSXMLParserNotationNotFinishedError = 49,
  NSXMLParserAttributeListNotStartedError = 50,
  NSXMLParserAttributeListNotFinishedError = 51,
  NSXMLParserMixedContentDeclNotStartedError = 52,
  NSXMLParserMixedContentDeclNotFinishedError = 53,
  NSXMLParserElementContentDeclNotStartedError = 54,
  NSXMLParserElementContentDeclNotFinishedError = 55,
  NSXMLParserXMLDeclNotStartedError = 56,
  NSXMLParserXMLDeclNotFinishedError = 57,
  NSXMLParserConditionalSectionNotStartedError = 58,
  NSXMLParserConditionalSectionNotFinishedError = 59,
  NSXMLParserExternalSubsetNotFinishedError = 60,
  NSXMLParserDOCTYPEDeclNotFinishedError = 61,
  NSXMLParserMisplacedCDATAEndStringError = 62,
  NSXMLParserCDATANotFinishedError = 63,
  NSXMLParserMisplacedXMLDeclarationError = 64,
  NSXMLParserSpaceRequiredError = 65,
  NSXMLParserSeparatorRequiredError = 66,
  NSXMLParserNMTOKENRequiredError = 67,
  NSXMLParserNAMERequiredError = 68,
  NSXMLParserPCDATARequiredError = 69,
  NSXMLParserURIRequiredError = 70,
  NSXMLParserPublicIdentifierRequiredError = 71,
  NSXMLParserLTRequiredError = 72,
  NSXMLParserGTRequiredError = 73,
  NSXMLParserLTSlashRequiredError = 74,
  NSXMLParserEqualExpectedError = 75,
  NSXMLParserTagNameMismatchError = 76,
  NSXMLParserUnfinishedTagError = 77,
  NSXMLParserStandaloneValueError = 78,
  NSXMLParserInvalidEncodingNameError = 79,
  NSXMLParserCommentContainsDoubleHyphenError = 80,
  NSXMLParserInvalidEncodingError = 81,
  NSXMLParserExternalStandaloneEntityError = 82,
  NSXMLParserInvalidConditionalSectionError = 83,
  NSXMLParserEntityValueRequiredError = 84,
  NSXMLParserNotWellBalancedError = 85,
  NSXMLParserExtraContentError = 86,
  NSXMLParserInvalidCharacterInEntityError = 87,
  NSXMLParserParsedEntityRefInInternalError = 88,
  NSXMLParserEntityRefLoopError = 89,
  NSXMLParserEntityBoundaryError = 90,
  NSXMLParserInvalidURIError = 91,
  NSXMLParserURIFragmentError = 92,
  NSXMLParserNoDTDError = 94,
  NSXMLParserDelegateAbortedParseError = 512,
}

interface NSXPCListenerAllocator<InitializedType = NSXPCListener> extends NSObjectAllocator<NSXPCListener> {}
interface NSXPCListener extends NSObject {
  resume(): void;
  suspend(): void;
  invalidate(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  endpoint(): NSXPCListenerEndpoint;
}
declare const NSXPCListener: {
  alloc(): NSXPCListenerAllocator;  serviceListener(): NSXPCListener;
  anonymousListener(): NSXPCListener;

}

interface NSXPCInterfaceAllocator<InitializedType = NSXPCInterface> extends NSObjectAllocator<NSXPCInterface> {}
interface NSXPCInterface extends NSObject {
  setClasses_forSelector_argumentIndex_ofReply(classes: NSSet<any>, sel: string, arg: NSUInteger, ofReply: boolean): void;
  classesForSelector_argumentIndex_ofReply(sel: string, arg: NSUInteger, ofReply: boolean): NSSet<any>;
  setInterface_forSelector_argumentIndex_ofReply(ifc: NSXPCInterface, sel: string, arg: NSUInteger, ofReply: boolean): void;
  interfaceForSelector_argumentIndex_ofReply(sel: string, arg: NSUInteger, ofReply: boolean): NSXPCInterface;

  protocol(): Protocol;
  setProtocol(protocol: Protocol): void;
}
declare const NSXPCInterface: {
  alloc(): NSXPCInterfaceAllocator;  interfaceWithProtocol(protocol: Protocol): NSXPCInterface;

}

interface NSXPCListenerEndpointAllocator<InitializedType = NSXPCListenerEndpoint> extends NSObjectAllocator<NSXPCListenerEndpoint> {}
interface NSXPCListenerEndpoint extends NSObject, INSSecureCoding {
}
declare const NSXPCListenerEndpoint: {
  alloc(): NSXPCListenerEndpointAllocator;
}

declare enum NSXPCConnectionOptions {
  NSXPCConnectionPrivileged,
}

declare type NSZone = any

interface NSATSTypesetterAllocator<InitializedType = NSATSTypesetter> extends NSTypesetterAllocator<NSATSTypesetter> {}
interface NSATSTypesetter extends NSTypesetter {
  lineFragmentRectForProposedRect_remainingRect(proposedRect: NSRect, remainingRect: NSRectPointer): NSRect;
  substituteFontForFont(originalFont: NSFont): NSFont;
  textTabForGlyphLocation_writingDirection_maxLocation(glyphLocation: CGFloat, direction: NSWritingDirection, maxLocation: CGFloat): NSTextTab;
  setParagraphGlyphRange_separatorGlyphRange(paragraphRange: NSRange, paragraphSeparatorRange: NSRange): void;
  layoutParagraphAtPoint(lineFragmentOrigin: NSPoint): NSUInteger;
  lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  setHardInvalidation_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  getLineFragmentRect_usedRect_forParagraphSeparatorGlyphRange_atProposedOrigin(lineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, paragraphSeparatorGlyphRange: NSRange, lineOrigin: NSPoint): void;
  willSetLineFragmentRect_forGlyphRange_usedRect_baselineOffset(lineRect: NSRect, glyphRange: NSRange, usedRect: NSRect, baselineOffset: CGFloat): void;
  shouldBreakLineByWordBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  shouldBreakLineByHyphenatingBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  hyphenationFactorForGlyphAtIndex(glyphIndex: NSUInteger): number;
  hyphenCharacterForGlyphAtIndex(glyphIndex: NSUInteger): string;
  boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(glyphIndex: NSUInteger, textContainer: NSTextContainer, proposedRect: NSRect, glyphPosition: NSPoint, charIndex: NSUInteger): NSRect;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits(glyphsRange: NSRange, glyphBuffer: NSGlyph, charIndexBuffer: NSUInteger, inscribeBuffer: NSGlyphInscription, elasticBuffer: boolean): NSUInteger;

  usesFontLeading(): boolean;
  setUsesFontLeading(usesFontLeading: boolean): void;
  typesetterBehavior(): NSTypesetterBehavior;
  setTypesetterBehavior(typesetterBehavior: NSTypesetterBehavior): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  lineFragmentPadding(): CGFloat;
  setLineFragmentPadding(lineFragmentPadding: CGFloat): void;
  bidiProcessingEnabled(): boolean;
  setBidiProcessingEnabled(bidiProcessingEnabled: boolean): void;
  attributedString(): NSAttributedString;
  setAttributedString(attributedString: NSAttributedString): void;
  paragraphGlyphRange(): NSRange;
  paragraphSeparatorGlyphRange(): NSRange;
  layoutManager(): NSLayoutManager;
  currentTextContainer(): NSTextContainer;
}
declare const NSATSTypesetter: {
  alloc(): NSATSTypesetterAllocator;
  sharedTypesetter(): NSATSTypesetter;

}

interface NSWorkspaceAllocator<InitializedType = NSWorkspace> extends NSObjectAllocator<NSWorkspace> {}
interface NSWorkspace extends NSObject {
  openFile(fullPath: NSString | string): boolean;
  openFile_withApplication(fullPath: NSString | string, appName: NSString | string | null): boolean;
  openFile_withApplication_andDeactivate(fullPath: NSString | string, appName: NSString | string | null, flag: boolean): boolean;
  openURL(url: NSURL): boolean;
  launchApplication(appName: NSString | string): boolean;
  launchApplicationAtURL_options_configuration_error(url: NSURL, options: NSWorkspaceLaunchOptions, configuration: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSRunningApplication;
  openURL_options_configuration_error(url: NSURL, options: NSWorkspaceLaunchOptions, configuration: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSRunningApplication;
  openURLs_withApplicationAtURL_options_configuration_error(urls: NSArray<any> | any[], applicationURL: NSURL, options: NSWorkspaceLaunchOptions, configuration: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSRunningApplication;
  launchApplication_showIcon_autolaunch(appName: NSString | string, showIcon: boolean, autolaunch: boolean): boolean;
  fullPathForApplication(appName: NSString | string): NSString;
  selectFile_inFileViewerRootedAtPath(fullPath: NSString | string | null, rootFullPath: NSString | string): boolean;
  activateFileViewerSelectingURLs(fileURLs: NSArray<any> | any[]): void;
  showSearchResultsForQueryString(queryString: NSString | string): boolean;
  noteFileSystemChanged(path: NSString | string): void;
  getInfoForFile_application_type(fullPath: NSString | string, appName: NSString | string, type: NSString | string): boolean;
  isFilePackageAtPath(fullPath: NSString | string): boolean;
  iconForFile(fullPath: NSString | string): NSImage;
  iconForFiles(fullPaths: NSArray<any> | any[]): NSImage;
  iconForFileType(fileType: NSString | string): NSImage;
  setIcon_forFile_options(image: NSImage | null, fullPath: NSString | string, options: NSWorkspaceIconCreationOptions): boolean;
  recycleURLs_completionHandler(URLs: NSArray<any> | any[], handler: Block): void;
  duplicateURLs_completionHandler(URLs: NSArray<any> | any[], handler: Block): void;
  getFileSystemInfoForPath_isRemovable_isWritable_isUnmountable_description_type(fullPath: NSString | string, removableFlag: boolean | null, writableFlag: boolean | null, unmountableFlag: boolean | null, description: NSString | string, fileSystemType: NSString | string): boolean;
  unmountAndEjectDeviceAtPath(path: NSString | string): boolean;
  unmountAndEjectDeviceAtURL_error(url: NSURL, error: NSError): boolean;
  extendPowerOffBy(requested: NSInteger): NSInteger;
  hideOtherApplications(): void;
  URLForApplicationWithBundleIdentifier(bundleIdentifier: NSString | string): NSURL;
  URLForApplicationToOpenURL(url: NSURL): NSURL;
  absolutePathForAppBundleWithIdentifier(bundleIdentifier: NSString | string): NSString;
  launchAppWithBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifier(bundleIdentifier: NSString | string, options: NSWorkspaceLaunchOptions, descriptor: NSAppleEventDescriptor | null, identifier: NSNumber | number): boolean;
  openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers(urls: NSArray<any> | any[], bundleIdentifier: NSString | string | null, options: NSWorkspaceLaunchOptions, descriptor: NSAppleEventDescriptor | null, identifiers: NSArray<any> | any[]): boolean;
  typeOfFile_error(absoluteFilePath: NSString | string, outError: NSError): NSString;
  localizedDescriptionForType(typeName: NSString | string): NSString;
  preferredFilenameExtensionForType(typeName: NSString | string): NSString;
  filenameExtension_isValidForType(filenameExtension: NSString | string, typeName: NSString | string): boolean;
  type_conformsToType(firstTypeName: NSString | string, secondTypeName: NSString | string): boolean;
  setDesktopImageURL_forScreen_options_error(url: NSURL, screen: NSScreen, options: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  desktopImageURLForScreen(screen: NSScreen): NSURL;
  desktopImageOptionsForScreen(screen: NSScreen): NSDictionary<any, any>;
  openTempFile(fullPath: NSString | string): boolean;
  findApplications(): void;
  noteUserDefaultsChanged(): void;
  slideImage_from_to(image: NSImage, fromPoint: NSPoint, toPoint: NSPoint): void;
  checkForRemovableMedia(): void;
  noteFileSystemChanged(): void;
  fileSystemChanged(): boolean;
  userDefaultsChanged(): boolean;
  mountNewRemovableMedia(): NSArray<any>;
  activeApplication(): NSDictionary<any, any>;
  mountedLocalVolumePaths(): NSArray<any>;
  mountedRemovableMedia(): NSArray<any>;
  launchedApplications(): NSArray<any>;
  openFile_fromImage_at_inView(fullPath: NSString | string, image: NSImage | null, point: NSPoint, view: NSView | null): boolean;
  performFileOperation_source_destination_files_tag(operation: NSWorkspaceFileOperationName, source: NSString | string, destination: NSString | string, files: NSArray<any> | any[], tag: NSInteger | null): boolean;
  applicationSupportDirectory(): NSString;
  setApplicationSupportDirectory(path: NSString | string): void;
  applicationSupportDirectoryWithSubDirectory_createIfNeeded(directoryName: NSString | string, create: boolean): NSString;
  sharedApplicationSupportDirectory(): NSString;
  openCloudURLByAuthenticating(url: NSURL): void;

  accessibilityDisplayShouldIncreaseContrast(): boolean;
  accessibilityDisplayShouldDifferentiateWithoutColor(): boolean;
  accessibilityDisplayShouldReduceTransparency(): boolean;
  accessibilityDisplayShouldReduceMotion(): boolean;
  accessibilityDisplayShouldInvertColors(): boolean;
  voiceOverEnabled(): boolean;
  switchControlEnabled(): boolean;
  runningApplications(): NSArray<any>;
  notificationCenter(): NSNotificationCenter;
  fileLabels(): NSArray<any>;
  fileLabelColors(): NSArray<any>;
  frontmostApplication(): NSRunningApplication;
  menuBarOwningApplication(): NSRunningApplication;
}
declare const NSWorkspace: {
  alloc(): NSWorkspaceAllocator;
  sharedWorkspace(): NSWorkspace;

}

declare type NSAccessibilityAttributeName = NSString

declare type NSAccessibilityParameterizedAttributeName = NSString

declare type NSAccessibilityAnnotationAttributeKey = NSString

declare type NSAccessibilityFontAttributeKey = NSString

declare type NSAccessibilityOrientationValue = NSString

declare type NSAccessibilitySortDirectionValue = NSString

declare type NSAccessibilityRulerMarkerTypeValue = NSString

declare type NSAccessibilityRulerUnitValue = NSString

declare type NSAccessibilityActionName = NSString

declare type NSAccessibilityNotificationName = NSString

declare type NSAccessibilityRole = NSString

declare type NSAccessibilitySubrole = NSString

declare type NSAccessibilityNotificationUserInfoKey = NSString

declare type NSAccessibilityLoadingToken = any

declare enum NSAccessibilityAnnotationPosition {
  NSAccessibilityAnnotationPositionFullRange,
  NSAccessibilityAnnotationPositionStart,
  NSAccessibilityAnnotationPositionEnd,
}

declare enum NSAccessibilityOrientation {
  NSAccessibilityOrientationUnknown = 0,
  NSAccessibilityOrientationVertical = 1,
  NSAccessibilityOrientationHorizontal = 2,
}

declare enum NSAccessibilitySortDirection {
  NSAccessibilitySortDirectionUnknown = 0,
  NSAccessibilitySortDirectionAscending = 1,
  NSAccessibilitySortDirectionDescending = 2,
}

declare enum NSAccessibilityRulerMarkerType {
  NSAccessibilityRulerMarkerTypeUnknown = 0,
  NSAccessibilityRulerMarkerTypeTabStopLeft = 1,
  NSAccessibilityRulerMarkerTypeTabStopRight = 2,
  NSAccessibilityRulerMarkerTypeTabStopCenter = 3,
  NSAccessibilityRulerMarkerTypeTabStopDecimal = 4,
  NSAccessibilityRulerMarkerTypeIndentHead = 5,
  NSAccessibilityRulerMarkerTypeIndentTail = 6,
  NSAccessibilityRulerMarkerTypeIndentFirstLine = 7,
}

declare enum NSAccessibilityUnits {
  NSAccessibilityUnitsUnknown = 0,
  NSAccessibilityUnitsInches = 1,
  NSAccessibilityUnitsCentimeters = 2,
  NSAccessibilityUnitsPoints = 3,
  NSAccessibilityUnitsPicas = 4,
}

declare enum NSAccessibilityPriorityLevel {
  NSAccessibilityPriorityLow = 10,
  NSAccessibilityPriorityMedium = 50,
  NSAccessibilityPriorityHigh = 90,
}

interface NSAccessibilityCustomActionAllocator<InitializedType = NSAccessibilityCustomAction> extends NSObjectAllocator<NSAccessibilityCustomAction> {
  initWithName_handler(name: NSString | string, handler: Block): InitializedType;
  initWithName_target_selector(name: NSString | string, target: any, selector: string): InitializedType;
}
interface NSAccessibilityCustomAction extends NSObject {

  name(): NSString;
  setName(name: NSString | string): void;
  target(): any;
  setTarget(target: any): void;
  selector(): string;
  setSelector(selector: string): void;
}
declare const NSAccessibilityCustomAction: {
  alloc(): NSAccessibilityCustomActionAllocator;
}

interface NSAccessibilityCustomRotorAllocator<InitializedType = NSAccessibilityCustomRotor> extends NSObjectAllocator<NSAccessibilityCustomRotor> {
  initWithLabel_itemSearchDelegate(label: NSString | string, itemSearchDelegate: any): InitializedType;
  initWithRotorType_itemSearchDelegate(rotorType: NSAccessibilityCustomRotorType, itemSearchDelegate: any): InitializedType;
}
interface NSAccessibilityCustomRotor extends NSObject {

  type(): NSAccessibilityCustomRotorType;
  setType(type: NSAccessibilityCustomRotorType): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  itemSearchDelegate(): any;
  setItemSearchDelegate(itemSearchDelegate: any): void;
  itemLoadingDelegate(): any;
  setItemLoadingDelegate(itemLoadingDelegate: any): void;
}
declare const NSAccessibilityCustomRotor: {
  alloc(): NSAccessibilityCustomRotorAllocator;
}

interface NSAccessibilityCustomRotorSearchParametersAllocator<InitializedType = NSAccessibilityCustomRotorSearchParameters> extends NSObjectAllocator<NSAccessibilityCustomRotorSearchParameters> {}
interface NSAccessibilityCustomRotorSearchParameters extends NSObject {

  currentItem(): NSAccessibilityCustomRotorItemResult;
  setCurrentItem(currentItem: NSAccessibilityCustomRotorItemResult): void;
  searchDirection(): NSAccessibilityCustomRotorSearchDirection;
  setSearchDirection(searchDirection: NSAccessibilityCustomRotorSearchDirection): void;
  filterString(): NSString;
  setFilterString(filterString: NSString | string): void;
}
declare const NSAccessibilityCustomRotorSearchParameters: {
  alloc(): NSAccessibilityCustomRotorSearchParametersAllocator;
}

interface NSAccessibilityCustomRotorItemResultAllocator<InitializedType = NSAccessibilityCustomRotorItemResult> extends NSObjectAllocator<NSAccessibilityCustomRotorItemResult> {
  initWithTargetElement(targetElement: any): InitializedType;
  initWithItemLoadingToken_customLabel(itemLoadingToken: NSAccessibilityLoadingToken, customLabel: NSString | string): InitializedType;
}
interface NSAccessibilityCustomRotorItemResult extends NSObject {

  targetElement(): any;
  itemLoadingToken(): NSAccessibilityLoadingToken;
  targetRange(): NSRange;
  setTargetRange(targetRange: NSRange): void;
  customLabel(): NSString;
  setCustomLabel(customLabel: NSString | string): void;
}
declare const NSAccessibilityCustomRotorItemResult: {
  alloc(): NSAccessibilityCustomRotorItemResultAllocator;
}

interface INSAccessibilityCustomRotorItemSearchDelegate {
  rotor_resultForSearchParameters(rotor: NSAccessibilityCustomRotor, searchParameters: NSAccessibilityCustomRotorSearchParameters): NSAccessibilityCustomRotorItemResult;
}

declare enum NSAccessibilityCustomRotorSearchDirection {
  NSAccessibilityCustomRotorSearchDirectionPrevious,
  NSAccessibilityCustomRotorSearchDirectionNext,
}

declare enum NSAccessibilityCustomRotorType {
  NSAccessibilityCustomRotorTypeCustom = 0,
  NSAccessibilityCustomRotorTypeAny = 1,
  NSAccessibilityCustomRotorTypeAnnotation,
  NSAccessibilityCustomRotorTypeBoldText,
  NSAccessibilityCustomRotorTypeHeading,
  NSAccessibilityCustomRotorTypeHeadingLevel1,
  NSAccessibilityCustomRotorTypeHeadingLevel2,
  NSAccessibilityCustomRotorTypeHeadingLevel3,
  NSAccessibilityCustomRotorTypeHeadingLevel4,
  NSAccessibilityCustomRotorTypeHeadingLevel5,
  NSAccessibilityCustomRotorTypeHeadingLevel6,
  NSAccessibilityCustomRotorTypeImage,
  NSAccessibilityCustomRotorTypeItalicText,
  NSAccessibilityCustomRotorTypeLandmark,
  NSAccessibilityCustomRotorTypeLink,
  NSAccessibilityCustomRotorTypeList,
  NSAccessibilityCustomRotorTypeMisspelledWord,
  NSAccessibilityCustomRotorTypeTable,
  NSAccessibilityCustomRotorTypeTextField,
  NSAccessibilityCustomRotorTypeUnderlinedText,
  NSAccessibilityCustomRotorTypeVisitedLink,
}

interface NSAccessibilityElementAllocator<InitializedType = NSAccessibilityElement> extends NSObjectAllocator<NSAccessibilityElement> {}
interface NSAccessibilityElement extends NSObject, INSAccessibility {
  accessibilityAddChildElement(childElement: NSAccessibilityElement): void;

  accessibilityFrameInParentSpace(): NSRect;
  setAccessibilityFrameInParentSpace(accessibilityFrameInParentSpace: NSRect): void;
}
declare const NSAccessibilityElement: {
  alloc(): NSAccessibilityElementAllocator;  accessibilityElementWithRole_frame_label_parent(role: NSAccessibilityRole, frame: NSRect, label: NSString | string | null, parent: any | null): any;

}

interface INSAccessibilityElement {
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
}

interface INSAccessibilityGroup {
}

interface INSAccessibilityButton {
  accessibilityLabel(): NSString;
  accessibilityPerformPress(): boolean;
}

interface INSAccessibilitySwitch {
  accessibilityValue(): NSString;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
}

interface INSAccessibilityRadioButton {
  accessibilityValue(): NSNumber;
}

interface INSAccessibilityCheckBox {
  accessibilityValue(): NSNumber;
}

interface INSAccessibilityStaticText {
  accessibilityValue(): NSString;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityVisibleCharacterRange(): NSRange;
}

interface INSAccessibilityNavigableStaticText {
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityRangeForLine(lineNumber: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
}

interface INSAccessibilityProgressIndicator {
  //   accessibilityValue(): NSNumber;
}

interface INSAccessibilityStepper {
  accessibilityLabel(): NSString;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityValue(): any;
}

interface INSAccessibilitySlider {
  accessibilityLabel(): NSString;
  accessibilityValue(): any;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
}

interface INSAccessibilityImage {
  accessibilityLabel(): NSString;
}

interface INSAccessibilityContainsTransientUI {
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  isAccessibilityAlternateUIVisible(): boolean;
}

interface INSAccessibilityOutline {
}

interface INSAccessibilityList {
}

interface INSAccessibilityRow {
  accessibilityIndex(): NSInteger;
  accessibilityDisclosureLevel(): NSInteger;
}

interface INSAccessibilityLayoutArea {
  accessibilityLabel(): NSString;
  accessibilityChildren(): NSArray<any>;
  accessibilitySelectedChildren(): NSArray<any>;

  accessibilityFocusedUIElement(): any;
}

interface INSAccessibilityLayoutItem {
  setAccessibilityFrame(frame: NSRect): void;
}

interface INSAccessibilityElementLoading {
  accessibilityElementWithToken(token: NSAccessibilityLoadingToken): any;
  accessibilityRangeInTargetElementWithToken(token: NSAccessibilityLoadingToken): NSRange;
}

interface INSAccessibility {
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

interface NSActionCellAllocator<InitializedType = NSActionCell> extends NSCellAllocator<NSActionCell> {}
interface NSActionCell extends NSCell {

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
}
declare const NSActionCell: {
  alloc(): NSActionCellAllocator;
}

interface NSAlertAllocator<InitializedType = NSAlert> extends NSObjectAllocator<NSAlert> {}
interface NSAlert extends NSObject {
  addButtonWithTitle(title: NSString | string): NSButton;
  layout(): void;
  runModal(): NSModalResponse;
  beginSheetModalForWindow_completionHandler(sheetWindow: NSWindow, handler: Block): void;
  beginSheetModalForWindow_modalDelegate_didEndSelector_contextInfo(window: NSWindow, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;

  messageText(): NSString;
  setMessageText(messageText: NSString | string): void;
  informativeText(): NSString;
  setInformativeText(informativeText: NSString | string): void;
  icon(): NSImage;
  setIcon(icon: NSImage): void;
  buttons(): NSArray<any>;
  showsHelp(): boolean;
  setShowsHelp(showsHelp: boolean): void;
  helpAnchor(): NSHelpAnchorName;
  setHelpAnchor(helpAnchor: NSHelpAnchorName): void;
  alertStyle(): NSAlertStyle;
  setAlertStyle(alertStyle: NSAlertStyle): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  showsSuppressionButton(): boolean;
  setShowsSuppressionButton(showsSuppressionButton: boolean): void;
  suppressionButton(): NSButton;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  window(): NSWindow;
}
declare const NSAlert: {
  alloc(): NSAlertAllocator;  alertWithError(error: NSError): NSAlert;
  alertWithMessageText_defaultButton_alternateButton_otherButton_informativeTextWithFormat(message: NSString | string | null, defaultButton: NSString | string | null, alternateButton: NSString | string | null, otherButton: NSString | string | null, format: NSString | string, ...args: any[]): NSAlert;
  runModalWithMessage_info(message: NSString | string, info: NSString | string): NSModalResponse;
  runSheetWithMessage_info(message: NSString | string, info: NSString | string): void;
  runModalWithMessage_info_buttons(message: NSString | string, info: NSString | string, buttons: NSArray<any> | any[]): NSModalResponse;
  runModalSessionWithMessage_info_buttons(message: NSString | string, info: NSString | string, buttons: NSArray<any> | any[]): NSModalResponse;
  alertWithMessage_info_buttons(message: NSString | string, info: NSString | string, buttons: NSArray<any> | any[]): NSAlert;
  runConfirmationSheetWithLocalizedStrings_completionBlock(dialogPrefix: NSString | string, block: BCVoidBlock): void;
  runConfirmationSheetWithLocalizedStrings_withSuppressionButton_completionBlock(dialogPrefix: NSString | string, showSuppressionButton: boolean, block: BCVoidBlock): void;
  runConfirmationSheetWithLocalizedStrings_format_withSuppressionButton_completionBlock(dialogPrefix: NSString | string, format: NSString | string, showSuppressionButton: boolean, block: BCVoidBlock): void;

}

interface INSAlertDelegate {
  alertShowHelp(alert: NSAlert): boolean;
}

declare enum NSAlertStyle {
  NSAlertStyleWarning = 0,
  NSAlertStyleInformational = 1,
  NSAlertStyleCritical = 2,
}

interface NSAlignmentFeedbackFilterAllocator<InitializedType = NSAlignmentFeedbackFilter> extends NSObjectAllocator<NSAlignmentFeedbackFilter> {}
interface NSAlignmentFeedbackFilter extends NSObject {
  updateWithEvent(event: NSEvent): void;
  updateWithPanRecognizer(panRecognizer: NSPanGestureRecognizer): void;
  alignmentFeedbackTokenForMovementInView_previousPoint_alignedPoint_defaultPoint(view: NSView | null, previousPoint: NSPoint, alignedPoint: NSPoint, defaultPoint: NSPoint): any;
  alignmentFeedbackTokenForHorizontalMovementInView_previousX_alignedX_defaultX(view: NSView | null, previousX: CGFloat, alignedX: CGFloat, defaultX: CGFloat): any;
  alignmentFeedbackTokenForVerticalMovementInView_previousY_alignedY_defaultY(view: NSView | null, previousY: CGFloat, alignedY: CGFloat, defaultY: CGFloat): any;
  performFeedback_performanceTime(alignmentFeedbackTokens: NSArray<any> | any[], performanceTime: NSHapticFeedbackPerformanceTime): void;
}
declare const NSAlignmentFeedbackFilter: {
  alloc(): NSAlignmentFeedbackFilterAllocator;
  inputEventMask(): NSEventMask;

}

interface INSAlignmentFeedbackToken {
}

interface NSAnimationAllocator<InitializedType = NSAnimation> extends NSObjectAllocator<NSAnimation> {
  initWithDuration_animationCurve(duration: NSTimeInterval, animationCurve: NSAnimationCurve): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSAnimation extends NSObject, INSCopying, INSCoding {
  startAnimation(): void;
  stopAnimation(): void;
  addProgressMark(progressMark: NSAnimationProgress): void;
  removeProgressMark(progressMark: NSAnimationProgress): void;
  startWhenAnimation_reachesProgress(animation: NSAnimation, startProgress: NSAnimationProgress): void;
  stopWhenAnimation_reachesProgress(animation: NSAnimation, stopProgress: NSAnimationProgress): void;
  clearStartAnimation(): void;
  clearStopAnimation(): void;

  animating(): boolean;
  currentProgress(): NSAnimationProgress;
  setCurrentProgress(currentProgress: NSAnimationProgress): void;
  duration(): NSTimeInterval;
  setDuration(duration: NSTimeInterval): void;
  animationBlockingMode(): NSAnimationBlockingMode;
  setAnimationBlockingMode(animationBlockingMode: NSAnimationBlockingMode): void;
  frameRate(): number;
  setFrameRate(frameRate: number): void;
  animationCurve(): NSAnimationCurve;
  setAnimationCurve(animationCurve: NSAnimationCurve): void;
  currentValue(): number;
  delegate(): any;
  setDelegate(delegate: any): void;
  progressMarks(): NSArray<any>;
  setProgressMarks(progressMarks: NSArray<any> | any[]): void;
  runLoopModesForAnimating(): NSArray<any>;
}
declare const NSAnimation: {
  alloc(): NSAnimationAllocator;
}

interface NSViewAnimationAllocator<InitializedType = NSViewAnimation> extends NSAnimationAllocator<NSViewAnimation> {
  initWithViewAnimations(viewAnimations: NSArray<any> | any[]): InitializedType;
}
interface NSViewAnimation extends NSAnimation {

  viewAnimations(): NSArray<any>;
  setViewAnimations(viewAnimations: NSArray<any> | any[]): void;
}
declare const NSViewAnimation: {
  alloc(): NSViewAnimationAllocator;
}

interface INSAnimationDelegate {
  animationShouldStart(animation: NSAnimation): boolean;
  animationDidStop(animation: NSAnimation): void;
  animationDidEnd(animation: NSAnimation): void;
  animation_valueForProgress(animation: NSAnimation, progress: NSAnimationProgress): number;
  animation_didReachProgressMark(animation: NSAnimation, progress: NSAnimationProgress): void;
}

interface INSAnimatablePropertyContainer {
  animator(): INSAnimatablePropertyContainer;
  animationForKey(key: NSAnimatablePropertyKey): any;

  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
}

declare type NSAnimationProgress = number

declare type NSViewAnimationKey = NSString

declare type NSViewAnimationEffectName = NSString

declare type NSAnimatablePropertyKey = NSString

declare enum NSAnimationCurve {
  NSAnimationEaseInOut,
  NSAnimationEaseIn,
  NSAnimationEaseOut,
  NSAnimationLinear,
}

declare enum NSAnimationBlockingMode {
  NSAnimationBlocking,
  NSAnimationNonblocking,
  NSAnimationNonblockingThreaded,
}

interface NSAnimationContextAllocator<InitializedType = NSAnimationContext> extends NSObjectAllocator<NSAnimationContext> {}
interface NSAnimationContext extends NSObject {

  duration(): NSTimeInterval;
  setDuration(duration: NSTimeInterval): void;
  timingFunction(): CAMediaTimingFunction;
  setTimingFunction(timingFunction: CAMediaTimingFunction): void;
  allowsImplicitAnimation(): boolean;
  setAllowsImplicitAnimation(allowsImplicitAnimation: boolean): void;
}
declare const NSAnimationContext: {
  alloc(): NSAnimationContextAllocator;  runAnimationGroup_completionHandler(changes: Block, completionHandler: Block | null): void;
  beginGrouping(): void;
  endGrouping(): void;

  currentContext(): NSAnimationContext;

}

interface NSAppearanceAllocator<InitializedType = NSAppearance> extends NSObjectAllocator<NSAppearance> {
  initWithAppearanceNamed_bundle(name: NSAppearanceName, bundle: NSBundle | null): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSAppearance extends NSObject, INSCoding {

  name(): NSAppearanceName;
  allowsVibrancy(): boolean;
  isDark_bc(): boolean;
}
declare const NSAppearance: {
  alloc(): NSAppearanceAllocator;  appearanceNamed(name: NSAppearanceName): NSAppearance;
  sketchDefaultDarkAppearance(): NSAppearance;

  currentAppearance(): NSAppearance;
  setCurrentAppearance(currentAppearance: NSAppearance): void;

}

interface INSAppearanceCustomization {

  appearance(): NSAppearance;
  setAppearance(appearance: NSAppearance): void;
  effectiveAppearance(): NSAppearance;
}

declare type NSAppearanceName = NSString

interface NSApplicationAllocator<InitializedType = NSApplication> extends NSResponderAllocator<NSApplication> {}
interface NSApplication extends NSResponder, INSUserInterfaceValidations, INSAccessibilityElement, INSAccessibility {
  hide(sender: any | null): void;
  unhide(sender: any | null): void;
  unhideWithoutActivation(): void;
  windowWithWindowNumber(windowNum: NSInteger): NSWindow;
  deactivate(): void;
  activateIgnoringOtherApps(flag: boolean): void;
  hideOtherApplications(sender: any | null): void;
  unhideAllApplications(sender: any | null): void;
  finishLaunching(): void;
  run(): void;
  runModalForWindow(window: NSWindow): NSModalResponse;
  stop(sender: any | null): void;
  stopModal(): void;
  stopModalWithCode(returnCode: NSModalResponse): void;
  abortModal(): void;
  beginModalSessionForWindow(window: NSWindow): NSModalSession;
  runModalSession(session: NSModalSession): NSModalResponse;
  endModalSession(session: NSModalSession): void;
  terminate(sender: any | null): void;
  requestUserAttention(requestType: NSRequestUserAttentionType): NSInteger;
  cancelUserAttentionRequest(request: NSInteger): void;
  enumerateWindowsWithOptions_usingBlock(options: NSWindowListOptions, block: Block): void;
  preventWindowOrdering(): void;
  setWindowsNeedUpdate(needUpdate: boolean): void;
  updateWindows(): void;
  activationPolicy(): NSApplicationActivationPolicy;
  setActivationPolicy(activationPolicy: NSApplicationActivationPolicy): boolean;
  reportException(exception: NSException | Error): void;
  replyToApplicationShouldTerminate(shouldTerminate: boolean): void;
  replyToOpenOrPrint(reply: NSApplicationDelegateReply): void;
  orderFrontCharacterPalette(sender: any | null): void;
  sendEvent(event: NSEvent): void;
  postEvent_atStart(event: NSEvent, flag: boolean): void;
  nextEventMatchingMask_untilDate_inMode_dequeue(mask: NSUInteger, expiration: NSDate | null, mode: NSRunLoopMode, deqFlag: boolean): NSEvent;
  discardEventsMatchingMask_beforeEvent(mask: NSUInteger, lastEvent: NSEvent | null): void;
  sendAction_to_from(action: string, target: any | null, sender: any | null): boolean;
  targetForAction(action: string): any;
  targetForAction_to_from(action: string, target: any | null, sender: any | null): any;
  tryToPerform_with(action: string, object: any | null): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  arrangeInFront(sender: any | null): void;
  removeWindowsItem(win: NSWindow): void;
  addWindowsItem_title_filename(win: NSWindow, string: NSString | string, isFilename: boolean): void;
  changeWindowsItem_title_filename(win: NSWindow, string: NSString | string, isFilename: boolean): void;
  updateWindowsItem(win: NSWindow): void;
  miniaturizeAll(sender: any | null): void;
  registerServicesMenuSendTypes_returnTypes(sendTypes: NSArray<any> | any[], returnTypes: NSArray<any> | any[]): void;
  orderFrontStandardAboutPanel(sender: any | null): void;
  orderFrontStandardAboutPanelWithOptions(optionsDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  disableRelaunchOnLogin(): void;
  enableRelaunchOnLogin(): void;
  registerForRemoteNotificationTypes(types: NSRemoteNotificationType): void;
  unregisterForRemoteNotifications(): void;
  runModalForWindow_relativeToWindow(window: NSWindow, docWindow: NSWindow): NSInteger;
  beginModalSessionForWindow_relativeToWindow(window: NSWindow, docWindow: NSWindow): NSModalSession;
  application_printFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(sheet: NSWindow, docWindow: NSWindow, modalDelegate: any | null, didEndSelector: string | null, contextInfo: void): void;
  endSheet(sheet: NSWindow): void;
  endSheet_returnCode(sheet: NSWindow, returnCode: NSInteger): void;
  makeWindowsPerform_inOrder(selector: string, flag: boolean): NSWindow;
  orderFrontColorPanel(sender: any | null): void;
  activateContextHelpMode(sender: any | null): void;
  showHelp(sender: any | null): void;
  runPageLayout(sender: any | null): void;
  toggleTouchBarCustomizationPalette(sender: any | null): IBAction;
  registerUserInterfaceItemSearchHandler(handler: any): void;
  unregisterUserInterfaceItemSearchHandler(handler: any): void;
  searchString_inUserInterfaceItemString_searchRange_foundRange(searchString: NSString | string, stringToSearch: NSString | string, searchRange: NSRange, foundRange: NSRange | null): boolean;
  restoreWindowWithIdentifier_state_completionHandler(identifier: NSUserInterfaceItemIdentifier, state: NSCoder, completionHandler: Block): boolean;
  extendStateRestoration(): void;
  completeStateRestoration(): void;
  applicationName(): NSString;
  applicationVersion(): NSString;
  applicationBuild(): NSString;
  isActiveApplication(): boolean;
  open(pathToFile: NSString | string): any;

  delegate(): any;
  setDelegate(delegate: any): void;
  mainWindow(): NSWindow;
  keyWindow(): NSWindow;
  active(): boolean;
  hidden(): boolean;
  running(): boolean;
  modalWindow(): NSWindow;
  windows(): NSArray<any>;
  mainMenu(): NSMenu;
  setMainMenu(mainMenu: NSMenu): void;
  helpMenu(): NSMenu;
  setHelpMenu(helpMenu: NSMenu): void;
  applicationIconImage(): NSImage;
  setApplicationIconImage(applicationIconImage: NSImage): void;
  dockTile(): NSDockTile;
  presentationOptions(): NSApplicationPresentationOptions;
  setPresentationOptions(presentationOptions: NSApplicationPresentationOptions): void;
  currentSystemPresentationOptions(): NSApplicationPresentationOptions;
  occlusionState(): NSApplicationOcclusionState;
  currentEvent(): NSEvent;
  windowsMenu(): NSMenu;
  setWindowsMenu(windowsMenu: NSMenu): void;
  fullKeyboardAccessEnabled(): boolean;
  servicesMenu(): NSMenu;
  setServicesMenu(servicesMenu: NSMenu): void;
  servicesProvider(): any;
  setServicesProvider(servicesProvider: any): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  enabledRemoteNotificationTypes(): NSRemoteNotificationType;
  context(): NSGraphicsContext;
  orderedDocuments(): NSArray<any>;
  orderedWindows(): NSArray<any>;
  automaticCustomizeTouchBarMenuItemEnabled(): boolean;
  setAutomaticCustomizeTouchBarMenuItemEnabled(automaticCustomizeTouchBarMenuItemEnabled: boolean): void;
}
declare const NSApplication: {
  alloc(): NSApplicationAllocator;  detachDrawingThread_toTarget_withObject(selector: string, target: any, argument: any | null): void;

  sharedApplication(): NSApplication;

}

interface INSApplicationDelegate {
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
}

interface INSServicesMenuRequestor {
  writeSelectionToPasteboard_types(pboard: NSPasteboard, types: NSArray<any> | any[]): boolean;
  readSelectionFromPasteboard(pboard: NSPasteboard): boolean;
}

declare type NSAppKitVersion = number

declare type NSModalResponse = NSInteger

declare type NSModalSession = any

declare type NSAboutPanelOptionKey = NSString

declare type NSServiceProviderName = NSString

declare enum NSApplicationPresentationOptions {
  NSApplicationPresentationDefault = 0,
  NSApplicationPresentationAutoHideDock,
  NSApplicationPresentationHideDock,
  NSApplicationPresentationAutoHideMenuBar,
  NSApplicationPresentationHideMenuBar,
  NSApplicationPresentationDisableAppleMenu,
  NSApplicationPresentationDisableProcessSwitching,
  NSApplicationPresentationDisableForceQuit,
  NSApplicationPresentationDisableSessionTermination,
  NSApplicationPresentationDisableHideApplication,
  NSApplicationPresentationDisableMenuBarTransparency,
  NSApplicationPresentationFullScreen,
  NSApplicationPresentationAutoHideToolbar,
  NSApplicationPresentationDisableCursorLocationAssistance,
}

declare enum NSApplicationOcclusionState {
  NSApplicationOcclusionStateVisible = 1 << 1,
}

declare enum NSWindowListOptions {
  NSWindowListOrderedFrontToBack,
}

declare enum NSRequestUserAttentionType {
  NSCriticalRequest = 0,
  NSInformationalRequest = 10,
}

declare enum NSApplicationDelegateReply {
  NSApplicationDelegateReplySuccess = 0,
  NSApplicationDelegateReplyCancel = 1,
  NSApplicationDelegateReplyFailure = 2,
}

declare enum NSApplicationTerminateReply {
  NSTerminateCancel = 0,
  NSTerminateNow = 1,
  NSTerminateLater = 2,
}

declare enum NSApplicationPrintReply {
  NSPrintingCancelled = 0,
  NSPrintingSuccess = 1,
  NSPrintingFailure = 3,
  NSPrintingReplyLater = 2,
}

declare enum NSRemoteNotificationType {
  NSRemoteNotificationTypeNone = 0,
  NSRemoteNotificationTypeBadge = 1 << 0,
  NSRemoteNotificationTypeSound = 1 << 1,
  NSRemoteNotificationTypeAlert = 1 << 2,
}

interface NSArrayControllerAllocator<InitializedType = NSArrayController> extends NSObjectControllerAllocator<NSArrayController> {}
interface NSArrayController extends NSObjectController {
  rearrangeObjects(): void;
  didChangeArrangementCriteria(): void;
  arrangeObjects(objects: NSArray<any> | any[]): NSArray<any>;
  setSelectionIndexes(indexes: NSIndexSet): boolean;
  setSelectionIndex(index: NSUInteger): boolean;
  addSelectionIndexes(indexes: NSIndexSet): boolean;
  removeSelectionIndexes(indexes: NSIndexSet): boolean;
  setSelectedObjects(objects: NSArray<any> | any[]): boolean;
  addSelectedObjects(objects: NSArray<any> | any[]): boolean;
  removeSelectedObjects(objects: NSArray<any> | any[]): boolean;
  add(sender: any | null): IBAction;
  remove(sender: any | null): IBAction;
  insert(sender: any | null): IBAction;
  selectNext(sender: any | null): IBAction;
  selectPrevious(sender: any | null): IBAction;
  addObject(object: any): void;
  addObjects(objects: NSArray<any> | any[]): void;
  insertObject_atArrangedObjectIndex(object: any, index: NSUInteger): void;
  insertObjects_atArrangedObjectIndexes(objects: NSArray<any> | any[], indexes: NSIndexSet): void;
  removeObjectAtArrangedObjectIndex(index: NSUInteger): void;
  removeObjectsAtArrangedObjectIndexes(indexes: NSIndexSet): void;
  removeObject(object: any): void;
  removeObjects(objects: NSArray<any> | any[]): void;

  automaticallyRearrangesObjects(): boolean;
  setAutomaticallyRearrangesObjects(automaticallyRearrangesObjects: boolean): void;
  automaticRearrangementKeyPaths(): NSArray<any>;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  filterPredicate(): NSPredicate;
  setFilterPredicate(filterPredicate: NSPredicate): void;
  clearsFilterPredicateOnInsertion(): boolean;
  setClearsFilterPredicateOnInsertion(clearsFilterPredicateOnInsertion: boolean): void;
  arrangedObjects(): any;
  avoidsEmptySelection(): boolean;
  setAvoidsEmptySelection(avoidsEmptySelection: boolean): void;
  preservesSelection(): boolean;
  setPreservesSelection(preservesSelection: boolean): void;
  selectsInsertedObjects(): boolean;
  setSelectsInsertedObjects(selectsInsertedObjects: boolean): void;
  alwaysUsesMultipleValuesMarker(): boolean;
  setAlwaysUsesMultipleValuesMarker(alwaysUsesMultipleValuesMarker: boolean): void;
  selectionIndexes(): NSIndexSet;
  selectionIndex(): NSUInteger;
  selectedObjects(): NSArray<any>;
  canInsert(): boolean;
  canSelectNext(): boolean;
  canSelectPrevious(): boolean;
}
declare const NSArrayController: {
  alloc(): NSArrayControllerAllocator;
}

declare type NSTextEffectStyle = NSString

declare type NSAttributedStringDocumentType = NSString

declare type NSTextLayoutSectionKey = NSString

declare type NSAttributedStringDocumentAttributeKey = NSString

declare type NSAttributedStringDocumentReadingOptionKey = NSString

declare enum NSUnderlineStyle {
  NSUnderlineStyleNone = 0x00,
  NSUnderlineStyleSingle = 0x01,
  NSUnderlineStyleThick = 0x02,
  NSUnderlineStyleDouble = 0x09,
  NSUnderlinePatternSolid = 0x0000,
  NSUnderlinePatternDot = 0x0100,
  NSUnderlinePatternDash = 0x0200,
  NSUnderlinePatternDashDot = 0x0300,
  NSUnderlinePatternDashDotDot = 0x0400,
  NSUnderlineByWord = 0x8000,
}

declare enum NSWritingDirectionFormatType {
  NSWritingDirectionEmbedding,
  NSWritingDirectionOverride,
}

declare enum NSSpellingState {
  NSSpellingStateSpellingFlag,
  NSSpellingStateGrammarFlag,
}

interface NSBezierPathAllocator<InitializedType = NSBezierPath> extends NSObjectAllocator<NSBezierPath> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSBezierPath extends NSObject, INSCopying, INSCoding {
  moveToPoint(point: NSPoint): void;
  lineToPoint(point: NSPoint): void;
  curveToPoint_controlPoint1_controlPoint2(endPoint: NSPoint, controlPoint1: NSPoint, controlPoint2: NSPoint): void;
  closePath(): void;
  removeAllPoints(): void;
  relativeMoveToPoint(point: NSPoint): void;
  relativeLineToPoint(point: NSPoint): void;
  relativeCurveToPoint_controlPoint1_controlPoint2(endPoint: NSPoint, controlPoint1: NSPoint, controlPoint2: NSPoint): void;
  getLineDash_count_phase(pattern: CGFloat | null, count: NSInteger | null, phase: CGFloat | null): void;
  setLineDash_count_phase(pattern: CGFloat | null, count: NSInteger, phase: CGFloat): void;
  stroke(): void;
  fill(): void;
  addClip(): void;
  setClip(): void;
  transformUsingAffineTransform(transform: NSAffineTransform): void;
  elementAtIndex_associatedPoints(index: NSInteger, points: NSPointArray | null): NSBezierPathElement;
  elementAtIndex(index: NSInteger): NSBezierPathElement;
  setAssociatedPoints_atIndex(points: NSPointArray | null, index: NSInteger): void;
  appendBezierPath(path: NSBezierPath): void;
  appendBezierPathWithRect(rect: NSRect): void;
  appendBezierPathWithPoints_count(points: NSPointArray, count: NSInteger): void;
  appendBezierPathWithOvalInRect(rect: NSRect): void;
  appendBezierPathWithArcWithCenter_radius_startAngle_endAngle_clockwise(center: NSPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: boolean): void;
  appendBezierPathWithArcWithCenter_radius_startAngle_endAngle(center: NSPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat): void;
  appendBezierPathWithArcFromPoint_toPoint_radius(point1: NSPoint, point2: NSPoint, radius: CGFloat): void;
  appendBezierPathWithCGGlyph_inFont(glyph: CGGlyph, font: NSFont): void;
  appendBezierPathWithCGGlyphs_count_inFont(glyphs: CGGlyph, count: NSInteger, font: NSFont): void;
  appendBezierPathWithRoundedRect_xRadius_yRadius(rect: NSRect, xRadius: CGFloat, yRadius: CGFloat): void;
  containsPoint(point: NSPoint): boolean;
  cachesBezierPath(): boolean;
  setCachesBezierPath(flag: boolean): void;
  appendBezierPathWithGlyph_inFont(glyph: NSGlyph, font: NSFont): void;
  appendBezierPathWithGlyphs_count_inFont(glyphs: NSGlyph, count: NSInteger, font: NSFont): void;
  appendBezierPathWithPackedGlyphs(packedGlyphs: string): void;
  strokeOutside(): void;
  strokeInside(): void;
  outlinePath(): NSBezierPath;
  drawInnerShadow(shadow: NSShadow): void;
  bezierPathByGrowingBy(offset: CGFloat): NSBezierPath;
  bezierPathWithOuterPathOfSize(amount: CGFloat): NSBezierPath;
  safeBounds(): NSRect;
  isClosed(): boolean;
  clipInBlock(block: BCVoidBlock): void;
  writeDebugFileNamed(name: NSString | string): void;
  bezierPathByMakingClockwiseIfNecessary(): NSBezierPath;
  bezierPathByMakingAntiClockwiseIfNecessary(): NSBezierPath;
  subPathsOrderedBySizeAfterOutlining(): NSArray<any>;
  bezierPathByCurveFitting(): NSBezierPath;
  booleanOp_withPath(op: MSBooleanOperation, otherPath: NSBezierPath): NSBezierPath;
  booleanUnionWith(otherPath: NSBezierPath): NSBezierPath;
  booleanIntersectWith(otherPath: NSBezierPath): NSBezierPath;
  booleanSubtractWith(otherPath: NSBezierPath): NSBezierPath;
  booleanExclusiveOrWith(otherPath: NSBezierPath): NSBezierPath;
  bezierPathBySubtractingPaths(paths: NSArray<any> | any[]): NSBezierPath;
  debugScale_ms(): CGFloat;
  appendSquareAtPoint_ms_size_scale(point: NSPoint, size: CGFloat, scale: CGFloat): void;
  appendCircleAtPoint_ms_radius_scale(point: NSPoint, radius: CGFloat, scale: CGFloat): void;
  appendArrowAtPoint_ms_tangent_size_scale(point: NSPoint, tangent: MSLine, size: CGFloat, scale: CGFloat): void;
  enumerator(): any;
  reverseEnumerator(): any;
  itemAtIndex(index: NSInteger): any;
  lastItem(): any;
  appendBezierPathItem(item: any): void;
  bezierCurves(): NSArray<any>;
  customIsEqual(other: NSBezierPath): boolean;
  animatedGIFRepresentation_ms(): NSData;
  JSONRepresetation_ms(): any;
  JSONDescription_ms(): NSString;
  lastPoint(): NSPoint;
  firstPoint(): NSPoint;
  slopeOnPathAtLength(length: CGFloat): CGFloat;
  pointOnPathAtLength(length: CGFloat): NSPoint;
  pointOnPathAtLength_slope(length: CGFloat, slope: CGFloat): NSPoint;
  bezierPathByTrimmingFromLength(trimLength: CGFloat): NSBezierPath;
  bezierPathByTrimmingFromLength_withMaximumError(trimLength: CGFloat, maxError: CGFloat): NSBezierPath;
  bezierPathByTrimmingToLength(trimLength: CGFloat): NSBezierPath;
  bezierPathByTrimmingToLength_withMaximumError(trimLength: CGFloat, maxError: CGFloat): NSBezierPath;
  bezierPathFromIndex_toIndex(from: NSUInteger, to: NSUInteger): NSBezierPath;
  length(): CGFloat;
  lengthWithMaximumError(maxError: CGFloat): CGFloat;
  appendBezierPathByRemovingMoveToPoint(path: NSBezierPath): void;
  isEqualToBezierPath(bezierPath: NSBezierPath): boolean;
  pointAtIndex(index: NSInteger): NSPoint;
  subDivideAtPoint(aPoint: NSPoint): NSArray<any>;
  bezierPathByApplyingModifierBlock(block: MSBezierPathModifierBlock): NSBezierPath;
  drawDebugWithZoom___unused(zoom: CGFloat): void;
  scaleBy(zoom: CGFloat): NSBezierPath;
  simplify(): NSBezierPath;
  simplifyWithMargin(margin: NSInteger): NSBezierPath;
  subPaths(): NSArray<any>;
  setDashPattern(dashPattern: NSArray<any> | any[]): void;
  debugWriteToFileNamed(name: NSString | string): void;
  containsRect(rect: NSRect): boolean;
  outlinePathWithWidth(width: CGFloat): NSBezierPath;
  outlinePathWithWidth_containsPoint(width: CGFloat, point: NSPoint): boolean;
  insetPathBy(size: CGFloat): NSBezierPath;
  outerPathWithRect(rect: NSRect): NSBezierPath;
  bezierPathWithLineWidth(lineWidth: CGFloat): NSBezierPath;
  bezierPathWithSquareLineCapStyle(): NSBezierPath;
  fillNonZero(): void;
  strokeWithWidth(lineWidth: CGFloat): void;
  addSVGArcWithAngle_radius_from_to_largeArc_sweep(angle: CGFloat, radius: NSSize, from: NSPoint, to: NSPoint, largeArcFlag: boolean, sweepFlag: boolean): void;
  svgPathAttribute(): NSXMLNode;
  fb_union(path: NSBezierPath): NSBezierPath;
  fb_intersect(path: NSBezierPath): NSBezierPath;
  fb_difference(path: NSBezierPath): NSBezierPath;
  fb_xor(path: NSBezierPath): NSBezierPath;
  fb_fitCurve(errorThreshold: CGFloat): NSBezierPath;
  fb_simplify(threshold: CGFloat): NSBezierPath;
  fb_pointAtIndex(index: NSUInteger): NSPoint;
  fb_elementAtIndex(index: NSUInteger): NSBezierElement;
  fb_subpathWithRange(range: NSRange): NSBezierPath;
  fb_copyAttributesFrom(path: NSBezierPath): void;
  fb_appendPath(path: NSBezierPath): void;
  fb_appendElement(element: NSBezierElement): void;

  lineWidth(): CGFloat;
  setLineWidth(lineWidth: CGFloat): void;
  lineCapStyle(): NSLineCapStyle;
  setLineCapStyle(lineCapStyle: NSLineCapStyle): void;
  lineJoinStyle(): NSLineJoinStyle;
  setLineJoinStyle(lineJoinStyle: NSLineJoinStyle): void;
  windingRule(): NSWindingRule;
  setWindingRule(windingRule: NSWindingRule): void;
  miterLimit(): CGFloat;
  setMiterLimit(miterLimit: CGFloat): void;
  flatness(): CGFloat;
  setFlatness(flatness: CGFloat): void;
  bezierPathByFlatteningPath(): NSBezierPath;
  bezierPathByReversingPath(): NSBezierPath;
  empty(): boolean;
  currentPoint(): NSPoint;
  controlPointBounds(): NSRect;
  bounds(): NSRect;
  elementCount(): NSInteger;
}
declare const NSBezierPath: {
  alloc(): NSBezierPathAllocator;  bezierPath(): NSBezierPath;
  bezierPathWithRect(rect: NSRect): NSBezierPath;
  bezierPathWithOvalInRect(rect: NSRect): NSBezierPath;
  bezierPathWithRoundedRect_xRadius_yRadius(rect: NSRect, xRadius: CGFloat, yRadius: CGFloat): NSBezierPath;
  fillRect(rect: NSRect): void;
  strokeRect(rect: NSRect): void;
  clipRect(rect: NSRect): void;
  strokeLineFromPoint_toPoint(point1: NSPoint, point2: NSPoint): void;
  drawPackedGlyphs_atPoint(packedGlyphs: string, point: NSPoint): void;
  bezierPathWithCGPath(path: CGPathRef): NSBezierPath;
  bezierPathFromPoint_toPoint(p1: NSPoint, p2: NSPoint): NSBezierPath;
  bezierCurveFromPoint_toPoint_controlPoint1_controlPoint2(from: NSPoint, to: NSPoint, cp1: NSPoint, cp2: NSPoint): NSBezierPath;
  bezierPathWithJSON_ms(json: any): NSBezierPath;
  bezierPathWithJSONString_ms(json: NSString | string): NSBezierPath;
  bezierPathWithPath(path: MSPath): NSBezierPath;
  validDashLengthFromProposedDashLength(dashLength: CGFloat): CGFloat;
  validDashPatternFromProposedDashPattern_padIfNeeded(proposed: NSArray<any> | any[], canPad: boolean): NSArray<any>;
  impliedDashPatternFromDashPattern_paddingToLength(dashPattern: NSArray<any> | any[], length: NSUInteger): NSArray<any>;
  bezierPathWithSubPaths(subPaths: NSArray<any> | any[]): NSBezierPath;
  bezierPathFromSVGString(contents: NSString | string): NSBezierPath;
  bezierPathFromEPSString(aString: NSString | string): NSBezierPath;
  circleAtPoint(point: NSPoint): NSBezierPath;
  rectAtPoint(point: NSPoint): NSBezierPath;
  triangleAtPoint_direction(point: NSPoint, tangent: NSPoint): NSBezierPath;
  smallCircleAtPoint(point: NSPoint): NSBezierPath;
  smallRectAtPoint(point: NSPoint): NSBezierPath;

  defaultMiterLimit(): CGFloat;
  setDefaultMiterLimit(defaultMiterLimit: CGFloat): void;
  defaultFlatness(): CGFloat;
  setDefaultFlatness(defaultFlatness: CGFloat): void;
  defaultWindingRule(): NSWindingRule;
  setDefaultWindingRule(defaultWindingRule: NSWindingRule): void;
  defaultLineCapStyle(): NSLineCapStyle;
  setDefaultLineCapStyle(defaultLineCapStyle: NSLineCapStyle): void;
  defaultLineJoinStyle(): NSLineJoinStyle;
  setDefaultLineJoinStyle(defaultLineJoinStyle: NSLineJoinStyle): void;
  defaultLineWidth(): CGFloat;
  setDefaultLineWidth(defaultLineWidth: CGFloat): void;

}

declare enum NSLineCapStyle {
  NSButtLineCapStyle = 0,
  NSRoundLineCapStyle = 1,
  NSSquareLineCapStyle = 2,
}

declare enum NSLineJoinStyle {
  NSMiterLineJoinStyle = 0,
  NSRoundLineJoinStyle = 1,
  NSBevelLineJoinStyle = 2,
}

declare enum NSWindingRule {
  NSNonZeroWindingRule = 0,
  NSEvenOddWindingRule = 1,
}

declare enum NSBezierPathElement {
  NSMoveToBezierPathElement,
  NSLineToBezierPathElement,
  NSCurveToBezierPathElement,
  NSClosePathBezierPathElement,
}

interface NSBitmapImageRepAllocator<InitializedType = NSBitmapImageRep> extends NSImageRepAllocator<NSBitmapImageRep> {
  initWithFocusedViewRect(rect: NSRect): InitializedType;
  initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bytesPerRow_bitsPerPixel(planes: string, width: NSInteger, height: NSInteger, bps: NSInteger, spp: NSInteger, alpha: boolean, isPlanar: boolean, colorSpaceName: NSColorSpaceName, rBytes: NSInteger, pBits: NSInteger): InitializedType;
  initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bitmapFormat_bytesPerRow_bitsPerPixel(planes: string, width: NSInteger, height: NSInteger, bps: NSInteger, spp: NSInteger, alpha: boolean, isPlanar: boolean, colorSpaceName: NSColorSpaceName, bitmapFormat: NSBitmapFormat, rBytes: NSInteger, pBits: NSInteger): InitializedType;
  initWithCGImage(cgImage: CGImageRef): InitializedType;
  initWithCIImage(ciImage: CIImage): InitializedType;
  initWithData(data: NSData): InitializedType;
  initForIncrementalLoad(): InitializedType;
}
interface NSBitmapImageRep extends NSImageRep, INSSecureCoding {
  getBitmapDataPlanes(data: string): void;
  getCompression_factor(compression: NSTIFFCompression | null, factor: number | null): void;
  setCompression_factor(compression: NSTIFFCompression, factor: number): void;
  TIFFRepresentationUsingCompression_factor(comp: NSTIFFCompression, factor: number): NSData;
  canBeCompressedUsing(compression: NSTIFFCompression): boolean;
  colorizeByMappingGray_toColor_blackMapping_whiteMapping(midPoint: CGFloat, midPointColor: NSColor | null, shadowColor: NSColor | null, lightColor: NSColor | null): void;
  incrementalLoadFromData_complete(data: NSData, complete: boolean): NSInteger;
  setColor_atX_y(color: NSColor, x: NSInteger, y: NSInteger): void;
  colorAtX_y(x: NSInteger, y: NSInteger): NSColor;
  getPixel_atX_y(p: NSUInteger[], x: NSInteger, y: NSInteger): void;
  setPixel_atX_y(p: NSUInteger[], x: NSInteger, y: NSInteger): void;
  bitmapImageRepByConvertingToColorSpace_renderingIntent(targetSpace: NSColorSpace, renderingIntent: NSColorRenderingIntent): NSBitmapImageRep;
  bitmapImageRepByRetaggingWithColorSpace(newSpace: NSColorSpace): NSBitmapImageRep;
  representationUsingType_properties(storageType: NSBitmapImageFileType, properties: NSDictionary<any, any> | {[key: string]: any}): NSData;
  setProperty_withValue(property: NSBitmapImageRepPropertyKey, value: any | null): void;
  valueForProperty(property: NSBitmapImageRepPropertyKey): any;
  JPGRepresentationWithCompression_progressive(compression: CGFloat, progressive: boolean): NSData;
  PNGRepresentationWithInterlaced(interlaced: boolean): NSData;
  PNGRepresentationWithInterlaced_includeAlpha(interlaced: boolean, includeAlpha: boolean): NSData;
  rectForTrimming(): NSRect;
  rectForTrimming(isBlankImage: boolean): NSRect;
  bitmapImageRepByCroppingToRect(r: NSRect): NSBitmapImageRep;
  bitmapImageRepByFlippingVertical(): NSBitmapImageRep;
  bitSafeBitmapImageRep(): NSBitmapImageRep;
  bitSafeFastRectForTrimming(): NSRect;
  bitSafeFastRectForTrimming(isBlankImage: boolean): NSRect;
  hasTransparentPixels(): boolean;

  bitmapData(): string;
  planar(): boolean;
  samplesPerPixel(): NSInteger;
  bitsPerPixel(): NSInteger;
  bytesPerRow(): NSInteger;
  bytesPerPlane(): NSInteger;
  numberOfPlanes(): NSInteger;
  bitmapFormat(): NSBitmapFormat;
  TIFFRepresentation(): NSData;
  CGImage(): CGImageRef;
  colorSpace(): NSColorSpace;
}
declare const NSBitmapImageRep: {
  alloc(): NSBitmapImageRepAllocator;  imageRepsWithData(data: NSData): NSArray<any>;
  imageRepWithData(data: NSData): NSBitmapImageRep;
  TIFFRepresentationOfImageRepsInArray(array: NSArray<any> | any[]): NSData;
  TIFFRepresentationOfImageRepsInArray_usingCompression_factor(array: NSArray<any> | any[], comp: NSTIFFCompression, factor: number): NSData;
  getTIFFCompressionTypes_count(list: NSTIFFCompression, numTypes: NSInteger): void;
  localizedNameForTIFFCompressionType(compression: NSTIFFCompression): NSString;
  representationOfImageRepsInArray_usingType_properties(imageReps: NSArray<any> | any[], storageType: NSBitmapImageFileType, properties: NSDictionary<any, any> | {[key: string]: any}): NSData;
  bitmapImageRepWithSize_flags_colorSpace_drawingBlock(size: NSSize, flags: DKCGContextCreateFlags, space: NSColorSpace, block: CGContextDrawBlock): NSBitmapImageRep;
  bitmapImageRepWithSize_pixelSize_flags_colorSpace_drawingBlock(size: NSSize, pixelSize: NSSize, flags: DKCGContextCreateFlags, space: NSColorSpace, block: CGContextDrawBlock): NSBitmapImageRep;

}

declare type NSBitmapImageRepPropertyKey = NSString

declare enum NSTIFFCompression {
  NSTIFFCompressionNone = 1,
  NSTIFFCompressionCCITTFAX3 = 3,
  NSTIFFCompressionCCITTFAX4 = 4,
  NSTIFFCompressionLZW = 5,
  NSTIFFCompressionJPEG = 6,
  NSTIFFCompressionNEXT = 32766,
  NSTIFFCompressionPackBits = 32773,
  NSTIFFCompressionOldJPEG = 32865,
}

declare enum NSBitmapImageFileType {
  NSBitmapImageFileTypeTIFF,
  NSBitmapImageFileTypeBMP,
  NSBitmapImageFileTypeGIF,
  NSBitmapImageFileTypeJPEG,
  NSBitmapImageFileTypePNG,
  NSBitmapImageFileTypeJPEG2000,
}

declare enum NSImageRepLoadStatus {
  NSImageRepLoadStatusUnknownType = -1,
  NSImageRepLoadStatusReadingHeader = -2,
  NSImageRepLoadStatusWillNeedAllData = -3,
  NSImageRepLoadStatusInvalidData = -4,
  NSImageRepLoadStatusUnexpectedEOF = -5,
  NSImageRepLoadStatusCompleted = -6,
}

declare enum NSBitmapFormat {
  NSBitmapFormatAlphaFirst = 1 << 0,
  NSBitmapFormatAlphaNonpremultiplied = 1 << 1,
  NSBitmapFormatFloatingPointSamples = 1 << 2,
  NSBitmapFormatSixteenBitLittleEndian,
  NSBitmapFormatThirtyTwoBitLittleEndian,
  NSBitmapFormatSixteenBitBigEndian,
  NSBitmapFormatThirtyTwoBitBigEndian,
}

interface NSBoxAllocator<InitializedType = NSBox> extends NSViewAllocator<NSBox> {}
interface NSBox extends NSView {
  sizeToFit(): void;
  setFrameFromContentFrame(contentFrame: NSRect): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;

  borderType(): NSBorderType;
  setBorderType(borderType: NSBorderType): void;
  titlePosition(): NSTitlePosition;
  setTitlePosition(titlePosition: NSTitlePosition): void;
  boxType(): NSBoxType;
  setBoxType(boxType: NSBoxType): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  titleFont(): NSFont;
  setTitleFont(titleFont: NSFont): void;
  borderRect(): NSRect;
  titleRect(): NSRect;
  titleCell(): any;
  contentViewMargins(): NSSize;
  setContentViewMargins(contentViewMargins: NSSize): void;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  transparent(): boolean;
  setTransparent(transparent: boolean): void;
  borderWidth(): CGFloat;
  setBorderWidth(borderWidth: CGFloat): void;
  cornerRadius(): CGFloat;
  setCornerRadius(cornerRadius: CGFloat): void;
  borderColor(): NSColor;
  setBorderColor(borderColor: NSColor): void;
  fillColor(): NSColor;
  setFillColor(fillColor: NSColor): void;
}
declare const NSBox: {
  alloc(): NSBoxAllocator;
}

declare enum NSTitlePosition {
  NSNoTitle = 0,
  NSAboveTop = 1,
  NSAtTop = 2,
  NSBelowTop = 3,
  NSAboveBottom = 4,
  NSAtBottom = 5,
  NSBelowBottom = 6,
}

declare enum NSBoxType {
  NSBoxPrimary = 0,
  NSBoxSecondary = 1,
  NSBoxSeparator = 2,
  NSBoxOldStyle = 3,
  NSBoxCustom = 4,
}

interface NSBrowserAllocator<InitializedType = NSBrowser> extends NSControlAllocator<NSBrowser> {}
interface NSBrowser extends NSControl {
  loadColumnZero(): void;
  setCellClass(factoryId: any): void;
  itemAtIndexPath(indexPath: NSIndexPath): any;
  itemAtRow_inColumn(row: NSInteger, column: NSInteger): any;
  indexPathForColumn(column: NSInteger): NSIndexPath;
  isLeafItem(item: any | null): boolean;
  reloadDataForRowIndexes_inColumn(rowIndexes: NSIndexSet, column: NSInteger): void;
  parentForItemsInColumn(column: NSInteger): any;
  scrollRowToVisible_inColumn(row: NSInteger, column: NSInteger): void;
  setTitle_ofColumn(string: NSString | string, column: NSInteger): void;
  titleOfColumn(column: NSInteger): NSString;
  setPath(path: NSString | string): boolean;
  path(): NSString;
  pathToColumn(column: NSInteger): NSString;
  selectedCellInColumn(column: NSInteger): any;
  selectRow_inColumn(row: NSInteger, column: NSInteger): void;
  selectedRowInColumn(column: NSInteger): NSInteger;
  selectRowIndexes_inColumn(indexes: NSIndexSet, column: NSInteger): void;
  selectedRowIndexesInColumn(column: NSInteger): NSIndexSet;
  reloadColumn(column: NSInteger): void;
  validateVisibleColumns(): void;
  scrollColumnsRightBy(shiftAmount: NSInteger): void;
  scrollColumnsLeftBy(shiftAmount: NSInteger): void;
  scrollColumnToVisible(column: NSInteger): void;
  addColumn(): void;
  loadedCellAtRow_column(row: NSInteger, col: NSInteger): any;
  selectAll(sender: any | null): void;
  tile(): void;
  doClick(sender: any | null): void;
  doDoubleClick(sender: any | null): void;
  sendAction(): boolean;
  titleFrameOfColumn(column: NSInteger): NSRect;
  drawTitleOfColumn_inRect(column: NSInteger, rect: NSRect): void;
  frameOfColumn(column: NSInteger): NSRect;
  frameOfInsideOfColumn(column: NSInteger): NSRect;
  frameOfRow_inColumn(row: NSInteger, column: NSInteger): NSRect;
  getRow_column_forPoint(row: NSInteger | null, column: NSInteger | null, point: NSPoint): boolean;
  columnWidthForColumnContentWidth(columnContentWidth: CGFloat): CGFloat;
  columnContentWidthForColumnWidth(columnWidth: CGFloat): CGFloat;
  setWidth_ofColumn(columnWidth: CGFloat, columnIndex: NSInteger): void;
  widthOfColumn(column: NSInteger): CGFloat;
  noteHeightOfRowsWithIndexesChanged_inColumn(indexSet: NSIndexSet, columnIndex: NSInteger): void;
  setDefaultColumnWidth(columnWidth: CGFloat): void;
  defaultColumnWidth(): CGFloat;
  canDragRowsWithIndexes_inColumn_withEvent(rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent): boolean;
  draggingImageForRowsWithIndexes_inColumn_withEvent_offset(rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent, dragImageOffset: NSPointPointer | null): NSImage;
  setDraggingSourceOperationMask_forLocal(mask: NSDragOperation, isLocal: boolean): void;
  editItemAtIndexPath_withEvent_select(indexPath: NSIndexPath, event: NSEvent | null, select: boolean): void;
  setAcceptsArrowKeys(flag: boolean): void;
  acceptsArrowKeys(): boolean;
  displayColumn(column: NSInteger): void;
  displayAllColumns(): void;
  scrollViaScroller(sender: NSScroller): void;
  updateScroller(): void;
  setMatrixClass(factoryId: any): void;
  matrixClass(): any;
  columnOfMatrix(matrix: NSMatrix): NSInteger;
  matrixInColumn(column: NSInteger): NSMatrix;

  loaded(): boolean;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  cellPrototype(): any;
  setCellPrototype(cellPrototype: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  reusesColumns(): boolean;
  setReusesColumns(reusesColumns: boolean): void;
  hasHorizontalScroller(): boolean;
  setHasHorizontalScroller(hasHorizontalScroller: boolean): void;
  autohidesScroller(): boolean;
  setAutohidesScroller(autohidesScroller: boolean): void;
  separatesColumns(): boolean;
  setSeparatesColumns(separatesColumns: boolean): void;
  titled(): boolean;
  setTitled(titled: boolean): void;
  minColumnWidth(): CGFloat;
  setMinColumnWidth(minColumnWidth: CGFloat): void;
  maxVisibleColumns(): NSInteger;
  setMaxVisibleColumns(maxVisibleColumns: NSInteger): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  allowsBranchSelection(): boolean;
  setAllowsBranchSelection(allowsBranchSelection: boolean): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  takesTitleFromPreviousColumn(): boolean;
  setTakesTitleFromPreviousColumn(takesTitleFromPreviousColumn: boolean): void;
  sendsActionOnArrowKeys(): boolean;
  setSendsActionOnArrowKeys(sendsActionOnArrowKeys: boolean): void;
  pathSeparator(): NSString;
  setPathSeparator(pathSeparator: NSString | string): void;
  clickedColumn(): NSInteger;
  clickedRow(): NSInteger;
  selectedColumn(): NSInteger;
  selectedCell(): any;
  selectedCells(): NSArray<any>;
  selectionIndexPath(): NSIndexPath;
  setSelectionIndexPath(selectionIndexPath: NSIndexPath): void;
  selectionIndexPaths(): NSArray<any>;
  setSelectionIndexPaths(selectionIndexPaths: NSArray<any> | any[]): void;
  lastColumn(): NSInteger;
  setLastColumn(lastColumn: NSInteger): void;
  numberOfVisibleColumns(): NSInteger;
  firstVisibleColumn(): NSInteger;
  lastVisibleColumn(): NSInteger;
  titleHeight(): CGFloat;
  columnResizingType(): NSBrowserColumnResizingType;
  setColumnResizingType(columnResizingType: NSBrowserColumnResizingType): void;
  prefersAllColumnUserResizing(): boolean;
  setPrefersAllColumnUserResizing(prefersAllColumnUserResizing: boolean): void;
  rowHeight(): CGFloat;
  setRowHeight(rowHeight: CGFloat): void;
  columnsAutosaveName(): NSBrowserColumnsAutosaveName;
  setColumnsAutosaveName(columnsAutosaveName: NSBrowserColumnsAutosaveName): void;
  allowsTypeSelect(): boolean;
  setAllowsTypeSelect(allowsTypeSelect: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}
declare const NSBrowser: {
  alloc(): NSBrowserAllocator;  removeSavedColumnsWithAutosaveName(name: NSBrowserColumnsAutosaveName): void;

  cellClass(): any;

}

interface INSBrowserDelegate {
  browser_numberOfRowsInColumn(sender: NSBrowser, column: NSInteger): NSInteger;
  browser_createRowsForColumn_inMatrix(sender: NSBrowser, column: NSInteger, matrix: NSMatrix): void;
  browser_numberOfChildrenOfItem(browser: NSBrowser, item: any | null): NSInteger;
  browser_child_ofItem(browser: NSBrowser, index: NSInteger, item: any | null): any;
  browser_isLeafItem(browser: NSBrowser, item: any | null): boolean;
  browser_objectValueForItem(browser: NSBrowser, item: any | null): any;
  browser_heightOfRow_inColumn(browser: NSBrowser, row: NSInteger, columnIndex: NSInteger): CGFloat;
  rootItemForBrowser(browser: NSBrowser): any;
  browser_setObjectValue_forItem(browser: NSBrowser, object: any | null, item: any | null): void;
  browser_shouldEditItem(browser: NSBrowser, item: any | null): boolean;
  browser_willDisplayCell_atRow_column(sender: NSBrowser, cell: any, row: NSInteger, column: NSInteger): void;
  browser_titleOfColumn(sender: NSBrowser, column: NSInteger): NSString;
  browser_selectCellWithString_inColumn(sender: NSBrowser, title: NSString | string, column: NSInteger): boolean;
  browser_selectRow_inColumn(sender: NSBrowser, row: NSInteger, column: NSInteger): boolean;
  browser_isColumnValid(sender: NSBrowser, column: NSInteger): boolean;
  browserWillScroll(sender: NSBrowser): void;
  browserDidScroll(sender: NSBrowser): void;
  browser_shouldSizeColumn_forUserResize_toWidth(browser: NSBrowser, columnIndex: NSInteger, forUserResize: boolean, suggestedWidth: CGFloat): CGFloat;
  browser_sizeToFitWidthOfColumn(browser: NSBrowser, columnIndex: NSInteger): CGFloat;
  browserColumnConfigurationDidChange(notification: NSNotification): void;
  browser_shouldShowCellExpansionForRow_column(browser: NSBrowser, row: NSInteger, column: NSInteger): boolean;
  browser_writeRowsWithIndexes_inColumn_toPasteboard(browser: NSBrowser, rowIndexes: NSIndexSet, column: NSInteger, pasteboard: NSPasteboard): boolean;
  browser_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes_inColumn(browser: NSBrowser, dropDestination: NSURL, rowIndexes: NSIndexSet, column: NSInteger): NSArray<any>;
  browser_canDragRowsWithIndexes_inColumn_withEvent(browser: NSBrowser, rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent): boolean;
  browser_draggingImageForRowsWithIndexes_inColumn_withEvent_offset(browser: NSBrowser, rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  browser_validateDrop_proposedRow_column_dropOperation(browser: NSBrowser, info: any, row: NSInteger, column: NSInteger, dropOperation: NSBrowserDropOperation): NSDragOperation;
  browser_acceptDrop_atRow_column_dropOperation(browser: NSBrowser, info: any, row: NSInteger, column: NSInteger, dropOperation: NSBrowserDropOperation): boolean;
  browser_typeSelectStringForRow_inColumn(browser: NSBrowser, row: NSInteger, column: NSInteger): NSString;
  browser_shouldTypeSelectForEvent_withCurrentSearchString(browser: NSBrowser, event: NSEvent, searchString: NSString | string | null): boolean;
  browser_nextTypeSelectMatchFromRow_toRow_inColumn_forString(browser: NSBrowser, startRow: NSInteger, endRow: NSInteger, column: NSInteger, searchString: NSString | string | null): NSInteger;
  browser_previewViewControllerForLeafItem(browser: NSBrowser, item: any): NSViewController;
  browser_headerViewControllerForItem(browser: NSBrowser, item: any | null): NSViewController;
  browser_didChangeLastColumn_toColumn(browser: NSBrowser, oldLastColumn: NSInteger, column: NSInteger): void;
  browser_selectionIndexesForProposedSelection_inColumn(browser: NSBrowser, proposedSelectionIndexes: NSIndexSet, column: NSInteger): NSIndexSet;
}

declare type NSBrowserColumnsAutosaveName = NSString

declare enum NSBrowserColumnResizingType {
  NSBrowserNoColumnResizing = 0,
  NSBrowserAutoColumnResizing = 1,
  NSBrowserUserColumnResizing = 2,
}

declare enum NSBrowserDropOperation {
  NSBrowserDropOn,
  NSBrowserDropAbove,
}

interface NSBrowserCellAllocator<InitializedType = NSBrowserCell> extends NSCellAllocator<NSBrowserCell> {}
interface NSBrowserCell extends NSCell {
  highlightColorInView(controlView: NSView): NSColor;
  reset(): void;
  set(): void;

  leaf(): boolean;
  setLeaf(leaf: boolean): void;
  loaded(): boolean;
  setLoaded(loaded: boolean): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
}
declare const NSBrowserCell: {
  alloc(): NSBrowserCellAllocator;
  branchImage(): NSImage;
  highlightedBranchImage(): NSImage;

}

interface NSButtonAllocator<InitializedType = NSButton> extends NSControlAllocator<NSButton> {}
interface NSButton extends NSControl, INSUserInterfaceValidations, INSAccessibilityButton, INSUserInterfaceCompression {
  setButtonType(type: NSButtonType): void;
  setPeriodicDelay_interval(delay: number, interval: number): void;
  getPeriodicDelay_interval(delay: number, interval: number): void;
  highlight(flag: boolean): void;
  performKeyEquivalent(key: NSEvent): boolean;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;
  setNextState(): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;

  title(): NSString;
  setTitle(title: NSString | string): void;
  alternateTitle(): NSString;
  setAlternateTitle(alternateTitle: NSString | string): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
  imagePosition(): NSCellImagePosition;
  setImagePosition(imagePosition: NSCellImagePosition): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  imageHugsTitle(): boolean;
  setImageHugsTitle(imageHugsTitle: boolean): void;
  state(): NSControlStateValue;
  setState(state: NSControlStateValue): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  transparent(): boolean;
  setTransparent(transparent: boolean): void;
  keyEquivalent(): NSString;
  setKeyEquivalent(keyEquivalent: NSString | string): void;
  keyEquivalentModifierMask(): NSEventModifierFlags;
  setKeyEquivalentModifierMask(keyEquivalentModifierMask: NSEventModifierFlags): void;
  springLoaded(): boolean;
  setSpringLoaded(springLoaded: boolean): void;
  maxAcceleratorLevel(): NSInteger;
  setMaxAcceleratorLevel(maxAcceleratorLevel: NSInteger): void;
  bezelColor(): NSColor;
  setBezelColor(bezelColor: NSColor): void;
  activeCompressionOptions(): NSUserInterfaceCompressionOptions;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  attributedAlternateTitle(): NSAttributedString;
  setAttributedAlternateTitle(attributedAlternateTitle: NSAttributedString): void;
  bezelStyle(): NSBezelStyle;
  setBezelStyle(bezelStyle: NSBezelStyle): void;
  allowsMixedState(): boolean;
  setAllowsMixedState(allowsMixedState: boolean): void;
  showsBorderOnlyWhileMouseInside(): boolean;
  setShowsBorderOnlyWhileMouseInside(showsBorderOnlyWhileMouseInside: boolean): void;
  sound(): NSSound;
  setSound(sound: NSSound): void;
}
declare const NSButton: {
  alloc(): NSButtonAllocator;  buttonWithTitle_image_target_action(title: NSString | string, image: NSImage, target: any | null, action: string | null): NSButton;
  buttonWithTitle_target_action(title: NSString | string, target: any | null, action: string | null): NSButton;
  buttonWithImage_target_action(image: NSImage, target: any | null, action: string | null): NSButton;
  checkboxWithTitle_target_action(title: NSString | string, target: any | null, action: string | null): NSButton;
  radioButtonWithTitle_target_action(title: NSString | string, target: any | null, action: string | null): NSButton;

}

interface NSButtonCellAllocator<InitializedType = NSButtonCell> extends NSActionCellAllocator<NSButtonCell> {}
interface NSButtonCell extends NSActionCell {
  setButtonType(type: NSButtonType): void;
  setPeriodicDelay_interval(delay: number, interval: number): void;
  getPeriodicDelay_interval(delay: number, interval: number): void;
  setKeyEquivalentFont_size(fontName: NSString | string, fontSize: CGFloat): void;
  performClick(sender: any | null): void;
  drawImage_withFrame_inView(image: NSImage, frame: NSRect, controlView: NSView): void;
  drawTitle_withFrame_inView(title: NSAttributedString, frame: NSRect, controlView: NSView): NSRect;
  drawBezelWithFrame_inView(frame: NSRect, controlView: NSView): void;
  mouseEntered(event: NSEvent): void;
  mouseExited(event: NSEvent): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  setAlternateTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  setAlternateMnemonicLocation(location: NSUInteger): void;
  alternateMnemonicLocation(): NSUInteger;
  alternateMnemonic(): NSString;

  title(): NSString;
  setTitle(title: NSString | string): void;
  alternateTitle(): NSString;
  setAlternateTitle(alternateTitle: NSString | string): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
  imagePosition(): NSCellImagePosition;
  setImagePosition(imagePosition: NSCellImagePosition): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  highlightsBy(): NSCellStyleMask;
  setHighlightsBy(highlightsBy: NSCellStyleMask): void;
  showsStateBy(): NSCellStyleMask;
  setShowsStateBy(showsStateBy: NSCellStyleMask): void;
  opaque(): boolean;
  transparent(): boolean;
  setTransparent(transparent: boolean): void;
  keyEquivalent(): NSString;
  setKeyEquivalent(keyEquivalent: NSString | string): void;
  keyEquivalentModifierMask(): NSEventModifierFlags;
  setKeyEquivalentModifierMask(keyEquivalentModifierMask: NSEventModifierFlags): void;
  keyEquivalentFont(): NSFont;
  setKeyEquivalentFont(keyEquivalentFont: NSFont): void;
  imageDimsWhenDisabled(): boolean;
  setImageDimsWhenDisabled(imageDimsWhenDisabled: boolean): void;
  showsBorderOnlyWhileMouseInside(): boolean;
  setShowsBorderOnlyWhileMouseInside(showsBorderOnlyWhileMouseInside: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  attributedAlternateTitle(): NSAttributedString;
  setAttributedAlternateTitle(attributedAlternateTitle: NSAttributedString): void;
  bezelStyle(): NSBezelStyle;
  setBezelStyle(bezelStyle: NSBezelStyle): void;
  sound(): NSSound;
  setSound(sound: NSSound): void;
  gradientType(): NSGradientType;
  setGradientType(gradientType: NSGradientType): void;
}
declare const NSButtonCell: {
  alloc(): NSButtonCellAllocator;
}

declare enum NSButtonType {
  NSButtonTypeMomentaryLight = 0,
  NSButtonTypePushOnPushOff = 1,
  NSButtonTypeToggle = 2,
  NSButtonTypeSwitch = 3,
  NSButtonTypeRadio = 4,
  NSButtonTypeMomentaryChange = 5,
  NSButtonTypeOnOff = 6,
  NSButtonTypeMomentaryPushIn = 7,
  NSButtonTypeAccelerator = 8,
  NSButtonTypeMultiLevelAccelerator = 9,
}

declare enum NSBezelStyle {
  NSBezelStyleRounded = 1,
  NSBezelStyleRegularSquare = 2,
  NSBezelStyleDisclosure = 5,
  NSBezelStyleShadowlessSquare = 6,
  NSBezelStyleCircular = 7,
  NSBezelStyleTexturedSquare = 8,
  NSBezelStyleHelpButton = 9,
  NSBezelStyleSmallSquare = 10,
  NSBezelStyleTexturedRounded = 11,
  NSBezelStyleRoundRect = 12,
  NSBezelStyleRecessed = 13,
  NSBezelStyleRoundedDisclosure = 14,
  NSBezelStyleInline = 15,
}

declare enum NSGradientType {
  NSGradientNone = 0,
  NSGradientConcaveWeak = 1,
  NSGradientConcaveStrong = 2,
  NSGradientConvexWeak = 3,
  NSGradientConvexStrong = 4,
}

interface NSCIImageRepAllocator<InitializedType = NSCIImageRep> extends NSImageRepAllocator<NSCIImageRep> {
  initWithCIImage(image: CIImage): InitializedType;
}
interface NSCIImageRep extends NSImageRep {

  CIImage(): CIImage;
}
declare const NSCIImageRep: {
  alloc(): NSCIImageRepAllocator;  imageRepWithCIImage(image: CIImage): NSCIImageRep;

}

interface CIImageAllocator<InitializedType = CIImage> {
  initWithBitmapImageRep(bitmapImageRep: NSBitmapImageRep): InitializedType;
}
interface CIImage {
  drawInRect_fromRect_operation_fraction(rect: NSRect, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  drawAtPoint_fromRect_operation_fraction(point: NSPoint, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  PNGRepresentationWithInterlaced(interlaced: boolean): NSData;
  imageByFlippingVertically(): CIImage;
}
declare const CIImage: {
  alloc(): CIImageAllocator;
}

interface NSCachedImageRepAllocator<InitializedType = NSCachedImageRep> extends NSImageRepAllocator<NSCachedImageRep> {
  initWithWindow_rect(win: NSWindow, rect: NSRect): InitializedType;
  initWithSize_depth_separate_alpha(size: NSSize, depth: NSWindowDepth, flag: boolean, alpha: boolean): InitializedType;
}
interface NSCachedImageRep extends NSImageRep {
  window(): NSWindow;
  rect(): NSRect;
}
declare const NSCachedImageRep: {
  alloc(): NSCachedImageRepAllocator;
}

interface NSCandidateListTouchBarItemAllocator<CandidateType, InitializedType = NSCandidateListTouchBarItem<CandidateType>> extends NSTouchBarItemAllocator<NSCandidateListTouchBarItem<CandidateType>> {}
interface NSCandidateListTouchBarItem<CandidateType> extends NSTouchBarItem {
  updateWithInsertionPointVisibility(isVisible: boolean): void;
  setCandidates_forSelectedRange_inString(candidates: NSArray<any> | any[], selectedRange: NSRange, originalString: NSString | string | null): void;

  client(): NSView;
  setClient(client: NSView): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
  allowsCollapsing(): boolean;
  setAllowsCollapsing(allowsCollapsing: boolean): void;
  candidateListVisible(): boolean;
  allowsTextInputContextCandidates(): boolean;
  setAllowsTextInputContextCandidates(allowsTextInputContextCandidates: boolean): void;
  candidates(): NSArray<any>;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
}
declare const NSCandidateListTouchBarItem: {
  alloc<CandidateType>(): NSCandidateListTouchBarItemAllocator<CandidateType>;
}

interface NSViewAllocator<InitializedType = NSView> extends NSResponderAllocator<NSView> {
  initWithFrame(frameRect: NSRect): InitializedType;
}
interface NSView extends NSResponder, INSAnimatablePropertyContainer, INSUserInterfaceItemIdentification, INSDraggingDestination, INSAppearanceCustomization, INSAccessibilityElement, INSAccessibility {
  reflectScrolledClipView(clipView: NSClipView): void;
  scrollClipView_toPoint(clipView: NSClipView, point: NSPoint): void;
  addConstraint(constraint: NSLayoutConstraint): void;
  addConstraints(constraints: NSArray<any> | any[]): void;
  removeConstraint(constraint: NSLayoutConstraint): void;
  removeConstraints(constraints: NSArray<any> | any[]): void;
  updateConstraintsForSubtreeIfNeeded(): void;
  layoutSubtreeIfNeeded(): void;
  layout(): void;
  alignmentRectForFrame(frame: NSRect): NSRect;
  frameForAlignmentRect(alignmentRect: NSRect): NSRect;
  invalidateIntrinsicContentSize(): void;
  contentHuggingPriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setContentHuggingPriority_forOrientation(priority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  contentCompressionResistancePriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setContentCompressionResistancePriority_forOrientation(priority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  constraintsAffectingLayoutForOrientation(orientation: NSLayoutConstraintOrientation): NSArray<any>;
  exerciseAmbiguityInLayout(): void;
  addLayoutGuide(guide: NSLayoutGuide): void;
  removeLayoutGuide(guide: NSLayoutGuide): void;
  rulerView_shouldMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willMoveMarker_toLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_didMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_shouldRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_didRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_shouldAddMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willAddMarker_atLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_didAddMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_handleMouseDown(ruler: NSRulerView, event: NSEvent): void;
  rulerView_willSetClientView(ruler: NSRulerView, newClient: NSView): void;
  rulerView_locationForPoint(ruler: NSRulerView, point: NSPoint): CGFloat;
  rulerView_pointForLocation(ruler: NSRulerView, point: CGFloat): NSPoint;
  isDescendantOf(view: NSView): boolean;
  ancestorSharedWithView(view: NSView): NSView;
  getRectsBeingDrawn_count(rects: NSRect, count: NSInteger | null): void;
  needsToDrawRect(rect: NSRect): boolean;
  viewDidHide(): void;
  viewDidUnhide(): void;
  addSubview(view: NSView): void;
  addSubview_positioned_relativeTo(view: NSView, place: NSWindowOrderingMode, otherView: NSView | null): void;
  viewWillMoveToWindow(newWindow: NSWindow | null): void;
  viewDidMoveToWindow(): void;
  viewWillMoveToSuperview(newSuperview: NSView | null): void;
  viewDidMoveToSuperview(): void;
  didAddSubview(subview: NSView): void;
  willRemoveSubview(subview: NSView): void;
  removeFromSuperview(): void;
  replaceSubview_with(oldView: NSView, newView: NSView): void;
  removeFromSuperviewWithoutNeedingDisplay(): void;
  viewDidChangeBackingProperties(): void;
  resizeSubviewsWithOldSize(oldSize: NSSize): void;
  resizeWithOldSuperviewSize(oldSize: NSSize): void;
  setFrameOrigin(newOrigin: NSPoint): void;
  setFrameSize(newSize: NSSize): void;
  setBoundsOrigin(newOrigin: NSPoint): void;
  setBoundsSize(newSize: NSSize): void;
  translateOriginToPoint(translation: NSPoint): void;
  scaleUnitSquareToSize(newUnitSize: NSSize): void;
  rotateByAngle(angle: CGFloat): void;
  convertPoint_fromView(point: NSPoint, view: NSView | null): NSPoint;
  convertPoint_toView(point: NSPoint, view: NSView | null): NSPoint;
  convertSize_fromView(size: NSSize, view: NSView | null): NSSize;
  convertSize_toView(size: NSSize, view: NSView | null): NSSize;
  convertRect_fromView(rect: NSRect, view: NSView | null): NSRect;
  convertRect_toView(rect: NSRect, view: NSView | null): NSRect;
  backingAlignedRect_options(rect: NSRect, options: NSAlignmentOptions): NSRect;
  centerScanRect(rect: NSRect): NSRect;
  convertPointToBacking(point: NSPoint): NSPoint;
  convertPointFromBacking(point: NSPoint): NSPoint;
  convertSizeToBacking(size: NSSize): NSSize;
  convertSizeFromBacking(size: NSSize): NSSize;
  convertRectToBacking(rect: NSRect): NSRect;
  convertRectFromBacking(rect: NSRect): NSRect;
  convertPointToLayer(point: NSPoint): NSPoint;
  convertPointFromLayer(point: NSPoint): NSPoint;
  convertSizeToLayer(size: NSSize): NSSize;
  convertSizeFromLayer(size: NSSize): NSSize;
  convertRectToLayer(rect: NSRect): NSRect;
  convertRectFromLayer(rect: NSRect): NSRect;
  setNeedsDisplayInRect(invalidRect: NSRect): void;
  lockFocus(): void;
  unlockFocus(): void;
  lockFocusIfCanDraw(): boolean;
  lockFocusIfCanDrawInContext(context: NSGraphicsContext): boolean;
  display(): void;
  displayIfNeeded(): void;
  displayIfNeededIgnoringOpacity(): void;
  displayRect(rect: NSRect): void;
  displayIfNeededInRect(rect: NSRect): void;
  displayRectIgnoringOpacity(rect: NSRect): void;
  displayIfNeededInRectIgnoringOpacity(rect: NSRect): void;
  drawRect(dirtyRect: NSRect): void;
  displayRectIgnoringOpacity_inContext(rect: NSRect, context: NSGraphicsContext): void;
  bitmapImageRepForCachingDisplayInRect(rect: NSRect): NSBitmapImageRep;
  cacheDisplayInRect_toBitmapImageRep(rect: NSRect, bitmapImageRep: NSBitmapImageRep): void;
  viewWillDraw(): void;
  scrollPoint(point: NSPoint): void;
  scrollRectToVisible(rect: NSRect): boolean;
  autoscroll(event: NSEvent): boolean;
  adjustScroll(newVisible: NSRect): NSRect;
  scrollRect_by(rect: NSRect, delta: NSSize): void;
  translateRectsNeedingDisplayInRect_by(clipRect: NSRect, delta: NSSize): void;
  hitTest(point: NSPoint): NSView;
  mouse_inRect(point: NSPoint, rect: NSRect): boolean;
  viewWithTag(tag: NSInteger): NSView;
  performKeyEquivalent(event: NSEvent): boolean;
  acceptsFirstMouse(event: NSEvent | null): boolean;
  shouldDelayWindowOrderingForEvent(event: NSEvent): boolean;
  addCursorRect_cursor(rect: NSRect, object: NSCursor): void;
  removeCursorRect_cursor(rect: NSRect, object: NSCursor): void;
  discardCursorRects(): void;
  resetCursorRects(): void;
  addTrackingRect_owner_userData_assumeInside(rect: NSRect, owner: any, data: void | null, flag: boolean): NSTrackingRectTag;
  removeTrackingRect(tag: NSTrackingRectTag): void;
  makeBackingLayer(): CALayer;
  updateLayer(): void;
  addTrackingArea(trackingArea: NSTrackingArea): void;
  removeTrackingArea(trackingArea: NSTrackingArea): void;
  updateTrackingAreas(): void;
  menuForEvent(event: NSEvent): NSMenu;
  willOpenMenu_withEvent(menu: NSMenu, event: NSEvent): void;
  didCloseMenu_withEvent(menu: NSMenu, event: NSEvent | null): void;
  addToolTipRect_owner_userData(rect: NSRect, owner: any, data: void | null): NSToolTipTag;
  removeToolTip(tag: NSToolTipTag): void;
  removeAllToolTips(): void;
  viewWillStartLiveResize(): void;
  viewDidEndLiveResize(): void;
  getRectsExposedDuringLiveResize_count(exposedRects: [NSRect, NSRect, NSRect, NSRect], count: NSInteger): void;
  rectForSmartMagnificationAtPoint_inRect(location: NSPoint, visibleRect: NSRect): NSRect;
  prepareForReuse(): void;
  prepareContentInRect(rect: NSRect): void;
  setKeyboardFocusRingNeedsDisplayInRect(rect: NSRect): void;
  drawFocusRingMask(): void;
  noteFocusRingMaskChanged(): void;
  writeEPSInsideRect_toPasteboard(rect: NSRect, pasteboard: NSPasteboard): void;
  dataWithEPSInsideRect(rect: NSRect): NSData;
  writePDFInsideRect_toPasteboard(rect: NSRect, pasteboard: NSPasteboard): void;
  dataWithPDFInsideRect(rect: NSRect): NSData;
  print(sender: any | null): void;
  knowsPageRange(range: NSRangePointer): boolean;
  adjustPageWidthNew_left_right_limit(newRight: CGFloat, oldLeft: CGFloat, oldRight: CGFloat, rightLimit: CGFloat): void;
  adjustPageHeightNew_top_bottom_limit(newBottom: CGFloat, oldTop: CGFloat, oldBottom: CGFloat, bottomLimit: CGFloat): void;
  rectForPage(page: NSInteger): NSRect;
  locationOfPrintRect(rect: NSRect): NSPoint;
  drawPageBorderWithSize(borderSize: NSSize): void;
  drawSheetBorderWithSize(borderSize: NSSize): void;
  beginDocument(): void;
  endDocument(): void;
  beginPageInRect_atPlacement(rect: NSRect, location: NSPoint): void;
  endPage(): void;
  beginDraggingSessionWithItems_event_source(items: NSArray<any> | any[], event: NSEvent, source: any): NSDraggingSession;
  registerForDraggedTypes(newTypes: NSArray<any> | any[]): void;
  unregisterDraggedTypes(): void;
  enterFullScreenMode_withOptions(screen: NSScreen, options: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  exitFullScreenModeWithOptions(options: NSDictionary<any, any> | {[key: string]: any} | null): void;
  showDefinitionForAttributedString_atPoint(attrString: NSAttributedString | null, textBaselineOrigin: NSPoint): void;
  showDefinitionForAttributedString_range_options_baselineOriginProvider(attrString: NSAttributedString | null, targetRange: NSRange, options: NSDictionary<any, any> | {[key: string]: any} | null, originProvider: Block): void;
  addGestureRecognizer(gestureRecognizer: NSGestureRecognizer): void;
  removeGestureRecognizer(gestureRecognizer: NSGestureRecognizer): void;
  dragImage_at_offset_event_pasteboard_source_slideBack(image: NSImage, viewLocation: NSPoint, initialOffset: NSSize, event: NSEvent, pboard: NSPasteboard, sourceObj: any, slideFlag: boolean): void;
  dragFile_fromRect_slideBack_event(filename: NSString | string, rect: NSRect, flag: boolean, event: NSEvent): boolean;
  dragPromisedFilesOfTypes_fromRect_source_slideBack_event(typeArray: NSArray<any> | any[], rect: NSRect, sourceObject: any, flag: boolean, event: NSEvent): boolean;
  convertPointToBase(point: NSPoint): NSPoint;
  convertPointFromBase(point: NSPoint): NSPoint;
  convertSizeToBase(size: NSSize): NSSize;
  convertSizeFromBase(size: NSSize): NSSize;
  convertRectToBase(rect: NSRect): NSRect;
  convertRectFromBase(rect: NSRect): NSRect;
  performMnemonic(string: NSString | string): boolean;
  shouldDrawColor(): boolean;
  gState(): NSInteger;
  allocateGState(): void;
  releaseGState(): void;
  setUpGState(): void;
  renewGState(): void;
  addSubview_constrainedBy_priority(subview: NSView, insets: NSEdgeInsets, priority: NSLayoutPriority): void;
  constrainHeight(height: CGFloat): void;
  constrainHeight_priority(height: CGFloat, priority: NSLayoutPriority): void;
  constrainWidth(width: CGFloat): void;
  constrainWidth_priority(width: CGFloat, priority: NSLayoutPriority): void;
  heightConstraint(): NSLayoutConstraint;
  hideWithZeroHeight(): void;
  hideWithZeroWidth(): void;
  showWithHeight(height: CGFloat): void;
  showWithWidth(width: CGFloat): void;
  horizontalConstraintWithView(anotherView: NSView): NSLayoutConstraint;
  horizontalConstraintsWithView(anotherView: NSView): NSArray<any>;
  verticalConstraintWithView(anotherView: NSView): NSLayoutConstraint;
  verticalConstraintsWithView(anotherView: NSView): NSArray<any>;
  widthConstraint(): NSLayoutConstraint;
  setFrameHeight(height: CGFloat): void;
  setFrameWidth(width: CGFloat): void;
  setFrameOriginX(x: CGFloat): void;
  setFrameOriginY(y: CGFloat): void;
  setNeedsDisplay(): void;
  imageRepresentation(): NSImage;
  beginDragFromEvent_image_type_data(event: NSEvent, image: NSImage, type: NSString | string, propertyListData: any): void;
  beginDragFromEvent_image_writersBlock(event: NSEvent, image: NSImage, block: MSPasteboardItemWritingBlock): void;
  containingAncestorViewOfClass(ancestorViewClass: any): NSView;
  nestedSubviewWithIdentifier(identifer: NSUserInterfaceItemIdentifier): NSView;
  animateToFrameOrigin_completionBlock(origin: NSPoint, block: MSAnimationBlock): void;
  animateToFrameOriginX_completionBlock(x: NSInteger, block: MSAnimationBlock): void;
  animateToFrameOriginX(x: NSInteger): void;
  subViewsForResponderFixer(): NSArray<any>;
  enclosingStackView(): MSInspectorStackView;
  viewHistoryMaker(): MSHistoryMaker;
  clickShouldDismissPopover(popover: BCPopover): boolean;
  wantsSeparatorBetweenSelfAndView(view: NSView): boolean;
  separatorInsetBetweenSelfAndView(view: NSView): NSEdgeInsets;

  candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
  leadingAnchor(): NSLayoutXAxisAnchor;
  trailingAnchor(): NSLayoutXAxisAnchor;
  leftAnchor(): NSLayoutXAxisAnchor;
  rightAnchor(): NSLayoutXAxisAnchor;
  topAnchor(): NSLayoutYAxisAnchor;
  bottomAnchor(): NSLayoutYAxisAnchor;
  widthAnchor(): NSLayoutDimension;
  heightAnchor(): NSLayoutDimension;
  centerXAnchor(): NSLayoutXAxisAnchor;
  centerYAnchor(): NSLayoutYAxisAnchor;
  firstBaselineAnchor(): NSLayoutYAxisAnchor;
  lastBaselineAnchor(): NSLayoutYAxisAnchor;
  constraints(): NSArray<any>;
  needsUpdateConstraints(): boolean;
  setNeedsUpdateConstraints(needsUpdateConstraints: boolean): void;
  needsLayout(): boolean;
  setNeedsLayout(needsLayout: boolean): void;
  translatesAutoresizingMaskIntoConstraints(): boolean;
  setTranslatesAutoresizingMaskIntoConstraints(translatesAutoresizingMaskIntoConstraints: boolean): void;
  alignmentRectInsets(): NSEdgeInsets;
  firstBaselineOffsetFromTop(): CGFloat;
  lastBaselineOffsetFromBottom(): CGFloat;
  baselineOffsetFromBottom(): CGFloat;
  intrinsicContentSize(): NSSize;
  fittingSize(): NSSize;
  hasAmbiguousLayout(): boolean;
  layoutGuides(): NSArray<any>;
  enclosingMenuItem(): NSMenuItem;
  wantsBestResolutionOpenGLSurface(): boolean;
  setWantsBestResolutionOpenGLSurface(wantsBestResolutionOpenGLSurface: boolean): void;
  wantsExtendedDynamicRangeOpenGLSurface(): boolean;
  setWantsExtendedDynamicRangeOpenGLSurface(wantsExtendedDynamicRangeOpenGLSurface: boolean): void;
  pressureConfiguration(): NSPressureConfiguration;
  setPressureConfiguration(pressureConfiguration: NSPressureConfiguration): void;
  window(): NSWindow;
  superview(): NSView;
  subviews(): NSArray<any>;
  setSubviews(subviews: NSArray<any> | any[]): void;
  opaqueAncestor(): NSView;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  hiddenOrHasHiddenAncestor(): boolean;
  wantsDefaultClipping(): boolean;
  postsFrameChangedNotifications(): boolean;
  setPostsFrameChangedNotifications(postsFrameChangedNotifications: boolean): void;
  autoresizesSubviews(): boolean;
  setAutoresizesSubviews(autoresizesSubviews: boolean): void;
  autoresizingMask(): NSAutoresizingMaskOptions;
  setAutoresizingMask(autoresizingMask: NSAutoresizingMaskOptions): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
  frameRotation(): CGFloat;
  setFrameRotation(frameRotation: CGFloat): void;
  frameCenterRotation(): CGFloat;
  setFrameCenterRotation(frameCenterRotation: CGFloat): void;
  boundsRotation(): CGFloat;
  setBoundsRotation(boundsRotation: CGFloat): void;
  bounds(): NSRect;
  setBounds(bounds: NSRect): void;
  flipped(): boolean;
  rotatedFromBase(): boolean;
  rotatedOrScaledFromBase(): boolean;
  opaque(): boolean;
  canDrawConcurrently(): boolean;
  setCanDrawConcurrently(canDrawConcurrently: boolean): void;
  canDraw(): boolean;
  needsDisplay(): boolean;
  setNeedsDisplay(needsDisplay: boolean): void;
  visibleRect(): NSRect;
  tag(): NSInteger;
  needsPanelToBecomeKey(): boolean;
  mouseDownCanMoveWindow(): boolean;
  acceptsTouchEvents(): boolean;
  setAcceptsTouchEvents(acceptsTouchEvents: boolean): void;
  wantsRestingTouches(): boolean;
  setWantsRestingTouches(wantsRestingTouches: boolean): void;
  layerContentsRedrawPolicy(): NSViewLayerContentsRedrawPolicy;
  setLayerContentsRedrawPolicy(layerContentsRedrawPolicy: NSViewLayerContentsRedrawPolicy): void;
  layerContentsPlacement(): NSViewLayerContentsPlacement;
  setLayerContentsPlacement(layerContentsPlacement: NSViewLayerContentsPlacement): void;
  wantsLayer(): boolean;
  setWantsLayer(wantsLayer: boolean): void;
  layer(): CALayer;
  setLayer(layer: CALayer): void;
  wantsUpdateLayer(): boolean;
  canDrawSubviewsIntoLayer(): boolean;
  setCanDrawSubviewsIntoLayer(canDrawSubviewsIntoLayer: boolean): void;
  alphaValue(): CGFloat;
  setAlphaValue(alphaValue: CGFloat): void;
  layerUsesCoreImageFilters(): boolean;
  setLayerUsesCoreImageFilters(layerUsesCoreImageFilters: boolean): void;
  backgroundFilters(): NSArray<any>;
  setBackgroundFilters(backgroundFilters: NSArray<any> | any[]): void;
  compositingFilter(): CIFilter;
  setCompositingFilter(compositingFilter: CIFilter): void;
  contentFilters(): NSArray<any>;
  setContentFilters(contentFilters: NSArray<any> | any[]): void;
  shadow(): NSShadow;
  setShadow(shadow: NSShadow): void;
  trackingAreas(): NSArray<any>;
  postsBoundsChangedNotifications(): boolean;
  setPostsBoundsChangedNotifications(postsBoundsChangedNotifications: boolean): void;
  enclosingScrollView(): NSScrollView;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  inLiveResize(): boolean;
  preservesContentDuringLiveResize(): boolean;
  rectPreservedDuringLiveResize(): NSRect;
  inputContext(): NSTextInputContext;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  preparedContentRect(): NSRect;
  setPreparedContentRect(preparedContentRect: NSRect): void;
  allowsVibrancy(): boolean;
  nextKeyView(): NSView;
  setNextKeyView(nextKeyView: NSView): void;
  previousKeyView(): NSView;
  nextValidKeyView(): NSView;
  previousValidKeyView(): NSView;
  canBecomeKeyView(): boolean;
  focusRingType(): NSFocusRingType;
  setFocusRingType(focusRingType: NSFocusRingType): void;
  focusRingMaskBounds(): NSRect;
  heightAdjustLimit(): CGFloat;
  widthAdjustLimit(): CGFloat;
  pageHeader(): NSAttributedString;
  pageFooter(): NSAttributedString;
  printJobTitle(): NSString;
  registeredDraggedTypes(): NSArray<any>;
  inFullScreenMode(): boolean;
  drawingFindIndicator(): boolean;
  gestureRecognizers(): NSArray<any>;
  setGestureRecognizers(gestureRecognizers: NSArray<any> | any[]): void;
  allowedTouchTypes(): NSTouchTypeMask;
  setAllowedTouchTypes(allowedTouchTypes: NSTouchTypeMask): void;
  dropDelegate_bc(): NSObject;
  setDropDelegate_bc(dropDelegate_bc: NSObject): void;
  allSubviews(): NSArray<any>;
  canBeKeyView(): boolean;
}
declare const NSView: {
  alloc(): NSViewAllocator;
  requiresConstraintBasedLayout(): boolean;
  focusView(): NSView;
  defaultMenu(): NSMenu;
  compatibleWithResponsiveScrolling(): boolean;
  defaultFocusRingType(): NSFocusRingType;

}

interface INSCandidateListTouchBarItemDelegate {
  candidateListTouchBarItem_beginSelectingCandidateAtIndex(anItem: NSCandidateListTouchBarItem<any>, index: NSInteger): void;
  candidateListTouchBarItem_changeSelectionFromCandidateAtIndex_toIndex(anItem: NSCandidateListTouchBarItem<any>, previousIndex: NSInteger, index: NSInteger): void;
  candidateListTouchBarItem_endSelectingCandidateAtIndex(anItem: NSCandidateListTouchBarItem<any>, index: NSInteger): void;
  candidateListTouchBarItem_changedCandidateListVisibility(anItem: NSCandidateListTouchBarItem<any>, isVisible: boolean): void;
}

interface NSCellAllocator<InitializedType = NSCell> extends NSObjectAllocator<NSCell> {
  init(): InitializedType;
  initTextCell(string: NSString | string): InitializedType;
  initImageCell(image: NSImage | null): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSCell extends NSObject, INSCopying, INSCoding, INSUserInterfaceItemIdentification, INSAccessibilityElement, INSAccessibility {
  sendActionOn(mask: NSInteger): NSInteger;
  compare(otherCell: any): NSComparisonResult;
  takeIntValueFrom(sender: any | null): void;
  takeFloatValueFrom(sender: any | null): void;
  takeDoubleValueFrom(sender: any | null): void;
  takeStringValueFrom(sender: any | null): void;
  takeObjectValueFrom(sender: any | null): void;
  cellAttribute(parameter: NSCellAttribute): NSInteger;
  setCellAttribute_to(parameter: NSCellAttribute, value: NSInteger): void;
  imageRectForBounds(rect: NSRect): NSRect;
  titleRectForBounds(rect: NSRect): NSRect;
  drawingRectForBounds(rect: NSRect): NSRect;
  cellSizeForBounds(rect: NSRect): NSSize;
  highlightColorWithFrame_inView(cellFrame: NSRect, controlView: NSView): NSColor;
  calcDrawInfo(rect: NSRect): void;
  setUpFieldEditorAttributes(textObj: NSText): NSText;
  drawInteriorWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  highlight_withFrame_inView(flag: boolean, cellFrame: NSRect, controlView: NSView): void;
  getPeriodicDelay_interval(delay: number, interval: number): void;
  startTrackingAt_inView(startPoint: NSPoint, controlView: NSView): boolean;
  continueTracking_at_inView(lastPoint: NSPoint, currentPoint: NSPoint, controlView: NSView): boolean;
  stopTracking_at_inView_mouseIsUp(lastPoint: NSPoint, stopPoint: NSPoint, controlView: NSView, flag: boolean): void;
  trackMouse_inRect_ofView_untilMouseUp(event: NSEvent, cellFrame: NSRect, controlView: NSView, flag: boolean): boolean;
  editWithFrame_inView_editor_delegate_event(rect: NSRect, controlView: NSView, textObj: NSText, delegate: any | null, event: NSEvent | null): void;
  selectWithFrame_inView_editor_delegate_start_length(rect: NSRect, controlView: NSView, textObj: NSText, delegate: any | null, selStart: NSInteger, selLength: NSInteger): void;
  endEditing(textObj: NSText): void;
  resetCursorRect_inView(cellFrame: NSRect, controlView: NSView): void;
  menuForEvent_inRect_ofView(event: NSEvent, cellFrame: NSRect, view: NSView): NSMenu;
  takeIntegerValueFrom(sender: any | null): void;
  fieldEditorForView(controlView: NSView): NSTextView;
  draggingImageComponentsWithFrame_inView(frame: NSRect, view: NSView): NSArray<any>;
  performClick(sender: any | null): void;
  drawFocusRingMaskWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  focusRingMaskBoundsForFrame_inView(cellFrame: NSRect, controlView: NSView): NSRect;
  setNextState(): void;
  hitTestForEvent_inRect_ofView(event: NSEvent, cellFrame: NSRect, controlView: NSView): NSCellHitResult;
  expansionFrameWithFrame_inView(cellFrame: NSRect, view: NSView): NSRect;
  drawWithExpansionFrame_inView(cellFrame: NSRect, view: NSView): void;
  entryType(): NSInteger;
  setEntryType(type: NSInteger): void;
  isEntryAcceptable(string: NSString | string): boolean;
  setFloatingPointFormat_left_right(autoRange: boolean, leftDigits: NSUInteger, rightDigits: NSUInteger): void;
  setMnemonicLocation(location: NSUInteger): void;
  mnemonicLocation(): NSUInteger;
  mnemonic(): NSString;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  inheritedBackgroundStyle(): NSBackgroundStyle;
  currentInspectorIconColor(): NSColor;
  drawInspectorButtonImage_centeredInRect(image: NSImage, rect: NSRect): void;
  drawInspectorButtonImage_centeredInRect_accented(image: NSImage, rect: NSRect, accented: boolean): void;
  drawInspectorStatelessControlImage_centeredInRect(image: NSImage, rect: NSRect): void;
  drawInspectorButtonPath_accented_highlighted(path: NSBezierPath, accented: boolean, highlighted: boolean): void;
  drawInspectorTextFieldBackgroundWithPath(path: NSBezierPath): void;
  drawInspectorFocusRingMaskWithWithPath(path: NSBezierPath): void;
  inspectorFocusRingMaskBoundsForFrame_inView(cellFrame: NSRect, controlView: NSView): NSRect;

  controlView(): NSView;
  setControlView(controlView: NSView): void;
  type(): NSCellType;
  setType(type: NSCellType): void;
  state(): NSControlStateValue;
  setState(state: NSControlStateValue): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  opaque(): boolean;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  scrollable(): boolean;
  setScrollable(scrollable: boolean): void;
  highlighted(): boolean;
  setHighlighted(highlighted: boolean): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  wraps(): boolean;
  setWraps(wraps: boolean): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  keyEquivalent(): NSString;
  formatter(): NSFormatter;
  setFormatter(formatter: NSFormatter): void;
  objectValue(): any;
  setObjectValue(objectValue: any): void;
  hasValidObjectValue(): boolean;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  intValue(): number;
  setIntValue(intValue: number): void;
  floatValue(): number;
  setFloatValue(floatValue: number): void;
  doubleValue(): number;
  setDoubleValue(doubleValue: number): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  cellSize(): NSSize;
  mouseDownFlags(): NSInteger;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  sendsActionOnEndEditing(): boolean;
  setSendsActionOnEndEditing(sendsActionOnEndEditing: boolean): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  allowsUndo(): boolean;
  setAllowsUndo(allowsUndo: boolean): void;
  integerValue(): NSInteger;
  setIntegerValue(integerValue: NSInteger): void;
  truncatesLastVisibleLine(): boolean;
  setTruncatesLastVisibleLine(truncatesLastVisibleLine: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  usesSingleLineMode(): boolean;
  setUsesSingleLineMode(usesSingleLineMode: boolean): void;
  refusesFirstResponder(): boolean;
  setRefusesFirstResponder(refusesFirstResponder: boolean): void;
  acceptsFirstResponder(): boolean;
  showsFirstResponder(): boolean;
  setShowsFirstResponder(showsFirstResponder: boolean): void;
  focusRingType(): NSFocusRingType;
  setFocusRingType(focusRingType: NSFocusRingType): void;
  wantsNotificationForMarkedText(): boolean;
  attributedStringValue(): NSAttributedString;
  setAttributedStringValue(attributedStringValue: NSAttributedString): void;
  allowsEditingTextAttributes(): boolean;
  setAllowsEditingTextAttributes(allowsEditingTextAttributes: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
  allowsMixedState(): boolean;
  setAllowsMixedState(allowsMixedState: boolean): void;
  nextState(): NSInteger;
  backgroundStyle(): NSBackgroundStyle;
  setBackgroundStyle(backgroundStyle: NSBackgroundStyle): void;
  interiorBackgroundStyle(): NSBackgroundStyle;
}
declare const NSCell: {
  alloc(): NSCellAllocator;
  prefersTrackingUntilMouseUp(): boolean;
  defaultMenu(): NSMenu;
  defaultFocusRingType(): NSFocusRingType;

}

declare type NSControlStateValue = NSInteger

declare type NSCellStateValue = NSControlStateValue

declare enum NSCellType {
  NSNullCellType = 0,
  NSTextCellType = 1,
  NSImageCellType = 2,
}

declare enum NSCellAttribute {
  NSCellDisabled = 0,
  NSCellState = 1,
  NSPushInCell = 2,
  NSCellEditable = 3,
  NSChangeGrayCell = 4,
  NSCellHighlighted = 5,
  NSCellLightsByContents = 6,
  NSCellLightsByGray = 7,
  NSChangeBackgroundCell = 8,
  NSCellLightsByBackground = 9,
  NSCellIsBordered = 10,
  NSCellHasOverlappingImage = 11,
  NSCellHasImageHorizontal = 12,
  NSCellHasImageOnLeftOrBottom = 13,
  NSCellChangesContents = 14,
  NSCellIsInsetButton = 15,
  NSCellAllowsMixedState = 16,
}

declare enum NSCellImagePosition {
  NSNoImage = 0,
  NSImageOnly = 1,
  NSImageLeft = 2,
  NSImageRight = 3,
  NSImageBelow = 4,
  NSImageAbove = 5,
  NSImageOverlaps = 6,
  NSImageLeading = 7,
  NSImageTrailing = 8,
}

declare enum NSImageScaling {
  NSImageScaleProportionallyDown = 0,
  NSImageScaleAxesIndependently,
  NSImageScaleNone,
  NSImageScaleProportionallyUpOrDown,
  NSScaleProportionally = 0,
  NSScaleToFit,
  NSScaleNone,
}

declare enum NSCellStyleMask {
  NSNoCellMask = 0,
  NSContentsCellMask = 1,
  NSPushInCellMask = 2,
  NSChangeGrayCellMask = 4,
  NSChangeBackgroundCellMask = 8,
}

declare enum NSControlTint {
  NSDefaultControlTint = 0,
  NSBlueControlTint = 1,
  NSGraphiteControlTint = 6,
  NSClearControlTint = 7,
}

declare enum NSControlSize {
  NSControlSizeRegular,
  NSControlSizeSmall,
  NSControlSizeMini,
}

declare enum NSCellHitResult {
  NSCellHitNone = 0,
  NSCellHitContentArea = 1 << 0,
  NSCellHitEditableTextArea = 1 << 1,
  NSCellHitTrackableArea = 1 << 2,
}

declare enum NSBackgroundStyle {
  NSBackgroundStyleLight = 0,
  NSBackgroundStyleDark,
  NSBackgroundStyleRaised,
  NSBackgroundStyleLowered,
}

interface NSClickGestureRecognizerAllocator<InitializedType = NSClickGestureRecognizer> extends NSGestureRecognizerAllocator<NSClickGestureRecognizer> {}
interface NSClickGestureRecognizer extends NSGestureRecognizer, INSCoding {

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  numberOfClicksRequired(): NSInteger;
  setNumberOfClicksRequired(numberOfClicksRequired: NSInteger): void;
  numberOfTouchesRequired(): NSInteger;
  setNumberOfTouchesRequired(numberOfTouchesRequired: NSInteger): void;
}
declare const NSClickGestureRecognizer: {
  alloc(): NSClickGestureRecognizerAllocator;
}

interface NSClipViewAllocator<InitializedType = NSClipView> extends NSViewAllocator<NSClipView> {}
interface NSClipView extends NSView {
  viewFrameChanged(notification: NSNotification): void;
  viewBoundsChanged(notification: NSNotification): void;
  autoscroll(event: NSEvent): boolean;
  scrollToPoint(newOrigin: NSPoint): void;
  constrainBoundsRect(proposedBounds: NSRect): NSRect;
  constrainScrollPoint(newOrigin: NSPoint): NSPoint;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  documentView(): NSView;
  setDocumentView(documentView: NSView): void;
  documentRect(): NSRect;
  documentCursor(): NSCursor;
  setDocumentCursor(documentCursor: NSCursor): void;
  documentVisibleRect(): NSRect;
  copiesOnScroll(): boolean;
  setCopiesOnScroll(copiesOnScroll: boolean): void;
  contentInsets(): NSEdgeInsets;
  setContentInsets(contentInsets: NSEdgeInsets): void;
  automaticallyAdjustsContentInsets(): boolean;
  setAutomaticallyAdjustsContentInsets(automaticallyAdjustsContentInsets: boolean): void;
}
declare const NSClipView: {
  alloc(): NSClipViewAllocator;
}

interface NSCollectionViewItemAllocator<InitializedType = NSCollectionViewItem> extends NSViewControllerAllocator<NSCollectionViewItem> {}
interface NSCollectionViewItem extends NSViewController, INSCopying, INSCollectionViewElement {

  collectionView(): NSCollectionView;
  selected(): boolean;
  setSelected(selected: boolean): void;
  highlightState(): NSCollectionViewItemHighlightState;
  setHighlightState(highlightState: NSCollectionViewItemHighlightState): void;
  imageView(): NSImageView;
  setImageView(imageView: NSImageView): void;
  textField(): NSTextField;
  setTextField(textField: NSTextField): void;
  draggingImageComponents(): NSArray<any>;
}
declare const NSCollectionViewItem: {
  alloc(): NSCollectionViewItemAllocator;
}

interface NSCollectionViewAllocator<InitializedType = NSCollectionView> extends NSViewAllocator<NSCollectionView> {}
interface NSCollectionView extends NSView, INSDraggingSource, INSDraggingDestination {
  reloadData(): void;
  layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryElementOfKind_atIndexPath(kind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  frameForItemAtIndex(index: NSUInteger): NSRect;
  frameForItemAtIndex_withNumberOfItems(index: NSUInteger, numberOfItems: NSUInteger): NSRect;
  numberOfItemsInSection(section: NSInteger): NSInteger;
  selectItemsAtIndexPaths_scrollPosition(indexPaths: NSSet<any>, scrollPosition: NSCollectionViewScrollPosition): void;
  deselectItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  selectAll(sender: any | null): IBAction;
  deselectAll(sender: any | null): IBAction;
  registerClass_forItemWithIdentifier(itemClass: any | null, identifier: NSUserInterfaceItemIdentifier): void;
  registerNib_forItemWithIdentifier(nib: NSNib | null, identifier: NSUserInterfaceItemIdentifier): void;
  registerClass_forSupplementaryViewOfKind_withIdentifier(viewClass: any | null, kind: NSCollectionViewSupplementaryElementKind, identifier: NSUserInterfaceItemIdentifier): void;
  registerNib_forSupplementaryViewOfKind_withIdentifier(nib: NSNib | null, kind: NSCollectionViewSupplementaryElementKind, identifier: NSUserInterfaceItemIdentifier): void;
  makeItemWithIdentifier_forIndexPath(identifier: NSUserInterfaceItemIdentifier, indexPath: NSIndexPath): NSCollectionViewItem;
  makeSupplementaryViewOfKind_withIdentifier_forIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, identifier: NSUserInterfaceItemIdentifier, indexPath: NSIndexPath): NSView;
  newItemForRepresentedObject(object: any): NSCollectionViewItem;
  itemAtIndex(index: NSUInteger): NSCollectionViewItem;
  itemAtIndexPath(indexPath: NSIndexPath): NSCollectionViewItem;
  visibleItems(): NSArray<any>;
  indexPathsForVisibleItems(): NSSet<any>;
  indexPathForItem(item: NSCollectionViewItem): NSIndexPath;
  indexPathForItemAtPoint(point: NSPoint): NSIndexPath;
  supplementaryViewForElementKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSView;
  visibleSupplementaryViewsOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSArray<any>;
  indexPathsForVisibleSupplementaryElementsOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSSet<any>;
  insertSections(sections: NSIndexSet): void;
  deleteSections(sections: NSIndexSet): void;
  reloadSections(sections: NSIndexSet): void;
  moveSection_toSection(section: NSInteger, newSection: NSInteger): void;
  insertItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  deleteItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  reloadItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  moveItemAtIndexPath_toIndexPath(indexPath: NSIndexPath, newIndexPath: NSIndexPath): void;
  performBatchUpdates_completionHandler(updates: Block, completionHandler: Block): void;
  toggleSectionCollapse(sender: any): IBAction;
  scrollToItemsAtIndexPaths_scrollPosition(indexPaths: NSSet<any>, scrollPosition: NSCollectionViewScrollPosition): void;
  setDraggingSourceOperationMask_forLocal(dragOperationMask: NSDragOperation, localDestination: boolean): void;
  draggingImageForItemsAtIndexPaths_withEvent_offset(indexPaths: NSSet<any>, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  draggingImageForItemsAtIndexes_withEvent_offset(indexes: NSIndexSet, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  prefetchDataSource(): any;
  setPrefetchDataSource(prefetchDataSource: any): void;
  content(): NSArray<any>;
  setContent(content: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  backgroundView(): NSView;
  setBackgroundView(backgroundView: NSView): void;
  backgroundViewScrollsWithContent(): boolean;
  setBackgroundViewScrollsWithContent(backgroundViewScrollsWithContent: boolean): void;
  collectionViewLayout(): NSCollectionViewLayout;
  setCollectionViewLayout(collectionViewLayout: NSCollectionViewLayout): void;
  maxNumberOfRows(): NSUInteger;
  setMaxNumberOfRows(maxNumberOfRows: NSUInteger): void;
  maxNumberOfColumns(): NSUInteger;
  setMaxNumberOfColumns(maxNumberOfColumns: NSUInteger): void;
  minItemSize(): NSSize;
  setMinItemSize(minItemSize: NSSize): void;
  maxItemSize(): NSSize;
  setMaxItemSize(maxItemSize: NSSize): void;
  backgroundColors(): NSArray<any>;
  setBackgroundColors(backgroundColors: NSArray<any> | any[]): void;
  numberOfSections(): NSInteger;
  firstResponder(): boolean;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  selectionIndexes(): NSIndexSet;
  setSelectionIndexes(selectionIndexes: NSIndexSet): void;
  selectionIndexPaths(): NSSet<any>;
  setSelectionIndexPaths(selectionIndexPaths: NSSet<any>): void;
  itemPrototype(): NSCollectionViewItem;
  setItemPrototype(itemPrototype: NSCollectionViewItem): void;
}
declare const NSCollectionView: {
  alloc(): NSCollectionViewAllocator;
}

interface INSCollectionViewSectionHeaderView {

  sectionCollapseButton(): NSButton;
  setSectionCollapseButton(sectionCollapseButton: NSButton): void;
}

interface INSCollectionViewDataSource {
  collectionView_numberOfItemsInSection(collectionView: NSCollectionView, section: NSInteger): NSInteger;
  collectionView_itemForRepresentedObjectAtIndexPath(collectionView: NSCollectionView, indexPath: NSIndexPath): NSCollectionViewItem;
  numberOfSectionsInCollectionView(collectionView: NSCollectionView): NSInteger;
  collectionView_viewForSupplementaryElementOfKind_atIndexPath(collectionView: NSCollectionView, kind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSView;
}

interface INSCollectionViewPrefetching {
  collectionView_prefetchItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSArray<any> | any[]): void;
  collectionView_cancelPrefetchingForItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSArray<any> | any[]): void;
}

interface INSCollectionViewDelegate {
  collectionView_canDragItemsAtIndexPaths_withEvent(collectionView: NSCollectionView, indexPaths: NSSet<any>, event: NSEvent): boolean;
  collectionView_canDragItemsAtIndexes_withEvent(collectionView: NSCollectionView, indexes: NSIndexSet, event: NSEvent): boolean;
  collectionView_writeItemsAtIndexPaths_toPasteboard(collectionView: NSCollectionView, indexPaths: NSSet<any>, pasteboard: NSPasteboard): boolean;
  collectionView_writeItemsAtIndexes_toPasteboard(collectionView: NSCollectionView, indexes: NSIndexSet, pasteboard: NSPasteboard): boolean;
  collectionView_namesOfPromisedFilesDroppedAtDestination_forDraggedItemsAtIndexPaths(collectionView: NSCollectionView, dropURL: NSURL, indexPaths: NSSet<any>): NSArray<any>;
  collectionView_namesOfPromisedFilesDroppedAtDestination_forDraggedItemsAtIndexes(collectionView: NSCollectionView, dropURL: NSURL, indexes: NSIndexSet): NSArray<any>;
  collectionView_draggingImageForItemsAtIndexPaths_withEvent_offset(collectionView: NSCollectionView, indexPaths: NSSet<any>, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  collectionView_draggingImageForItemsAtIndexes_withEvent_offset(collectionView: NSCollectionView, indexes: NSIndexSet, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  collectionView_validateDrop_proposedIndexPath_dropOperation(collectionView: NSCollectionView, draggingInfo: any, proposedDropIndexPath: NSIndexPath, proposedDropOperation: NSCollectionViewDropOperation): NSDragOperation;
  collectionView_validateDrop_proposedIndex_dropOperation(collectionView: NSCollectionView, draggingInfo: any, proposedDropIndex: NSInteger, proposedDropOperation: NSCollectionViewDropOperation): NSDragOperation;
  collectionView_acceptDrop_indexPath_dropOperation(collectionView: NSCollectionView, draggingInfo: any, indexPath: NSIndexPath, dropOperation: NSCollectionViewDropOperation): boolean;
  collectionView_acceptDrop_index_dropOperation(collectionView: NSCollectionView, draggingInfo: any, index: NSInteger, dropOperation: NSCollectionViewDropOperation): boolean;
  collectionView_pasteboardWriterForItemAtIndexPath(collectionView: NSCollectionView, indexPath: NSIndexPath): any;
  collectionView_pasteboardWriterForItemAtIndex(collectionView: NSCollectionView, index: NSUInteger): any;
  collectionView_draggingSession_willBeginAtPoint_forItemsAtIndexPaths(collectionView: NSCollectionView, session: NSDraggingSession, screenPoint: NSPoint, indexPaths: NSSet<any>): void;
  collectionView_draggingSession_willBeginAtPoint_forItemsAtIndexes(collectionView: NSCollectionView, session: NSDraggingSession, screenPoint: NSPoint, indexes: NSIndexSet): void;
  collectionView_draggingSession_endedAtPoint_dragOperation(collectionView: NSCollectionView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  collectionView_updateDraggingItemsForDrag(collectionView: NSCollectionView, draggingInfo: any): void;
  collectionView_shouldChangeItemsAtIndexPaths_toHighlightState(collectionView: NSCollectionView, indexPaths: NSSet<any>, highlightState: NSCollectionViewItemHighlightState): NSSet<any>;
  collectionView_didChangeItemsAtIndexPaths_toHighlightState(collectionView: NSCollectionView, indexPaths: NSSet<any>, highlightState: NSCollectionViewItemHighlightState): void;
  collectionView_shouldSelectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): NSSet<any>;
  collectionView_shouldDeselectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): NSSet<any>;
  collectionView_didSelectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): void;
  collectionView_didDeselectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): void;
  collectionView_willDisplayItem_forRepresentedObjectAtIndexPath(collectionView: NSCollectionView, item: NSCollectionViewItem, indexPath: NSIndexPath): void;
  collectionView_willDisplaySupplementaryView_forElementKind_atIndexPath(collectionView: NSCollectionView, view: NSView, elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): void;
  collectionView_didEndDisplayingItem_forRepresentedObjectAtIndexPath(collectionView: NSCollectionView, item: NSCollectionViewItem, indexPath: NSIndexPath): void;
  collectionView_didEndDisplayingSupplementaryView_forElementOfKind_atIndexPath(collectionView: NSCollectionView, view: NSView, elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): void;
  collectionView_transitionLayoutForOldLayout_newLayout(collectionView: NSCollectionView, fromLayout: NSCollectionViewLayout, toLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
}

declare type NSCollectionViewSupplementaryElementKind = NSString

declare enum NSCollectionViewDropOperation {
  NSCollectionViewDropOn = 0,
  NSCollectionViewDropBefore = 1,
}

declare enum NSCollectionViewItemHighlightState {
  NSCollectionViewItemHighlightNone = 0,
  NSCollectionViewItemHighlightForSelection = 1,
  NSCollectionViewItemHighlightForDeselection = 2,
  NSCollectionViewItemHighlightAsDropTarget = 3,
}

declare enum NSCollectionViewScrollPosition {
  NSCollectionViewScrollPositionNone = 0,
  NSCollectionViewScrollPositionTop = 1 << 0,
  NSCollectionViewScrollPositionCenteredVertically = 1 << 1,
  NSCollectionViewScrollPositionBottom = 1 << 2,
  NSCollectionViewScrollPositionNearestHorizontalEdge = 1 << 9,
  NSCollectionViewScrollPositionLeft = 1 << 3,
  NSCollectionViewScrollPositionCenteredHorizontally = 1 << 4,
  NSCollectionViewScrollPositionRight = 1 << 5,
  NSCollectionViewScrollPositionLeadingEdge = 1 << 6,
  NSCollectionViewScrollPositionTrailingEdge = 1 << 7,
  NSCollectionViewScrollPositionNearestVerticalEdge = 1 << 8,
}

interface NSCollectionViewFlowLayoutInvalidationContextAllocator<InitializedType = NSCollectionViewFlowLayoutInvalidationContext> extends NSCollectionViewLayoutInvalidationContextAllocator<NSCollectionViewFlowLayoutInvalidationContext> {}
interface NSCollectionViewFlowLayoutInvalidationContext extends NSCollectionViewLayoutInvalidationContext {

  invalidateFlowLayoutDelegateMetrics(): boolean;
  setInvalidateFlowLayoutDelegateMetrics(invalidateFlowLayoutDelegateMetrics: boolean): void;
  invalidateFlowLayoutAttributes(): boolean;
  setInvalidateFlowLayoutAttributes(invalidateFlowLayoutAttributes: boolean): void;
}
declare const NSCollectionViewFlowLayoutInvalidationContext: {
  alloc(): NSCollectionViewFlowLayoutInvalidationContextAllocator;
}

interface NSCollectionViewFlowLayoutAllocator<InitializedType = NSCollectionViewFlowLayout> extends NSCollectionViewLayoutAllocator<NSCollectionViewFlowLayout> {}
interface NSCollectionViewFlowLayout extends NSCollectionViewLayout {
  sectionAtIndexIsCollapsed(sectionIndex: NSUInteger): boolean;
  collapseSectionAtIndex(sectionIndex: NSUInteger): void;
  expandSectionAtIndex(sectionIndex: NSUInteger): void;

  minimumLineSpacing(): CGFloat;
  setMinimumLineSpacing(minimumLineSpacing: CGFloat): void;
  minimumInteritemSpacing(): CGFloat;
  setMinimumInteritemSpacing(minimumInteritemSpacing: CGFloat): void;
  itemSize(): NSSize;
  setItemSize(itemSize: NSSize): void;
  estimatedItemSize(): NSSize;
  setEstimatedItemSize(estimatedItemSize: NSSize): void;
  scrollDirection(): NSCollectionViewScrollDirection;
  setScrollDirection(scrollDirection: NSCollectionViewScrollDirection): void;
  headerReferenceSize(): NSSize;
  setHeaderReferenceSize(headerReferenceSize: NSSize): void;
  footerReferenceSize(): NSSize;
  setFooterReferenceSize(footerReferenceSize: NSSize): void;
  sectionInset(): NSEdgeInsets;
  setSectionInset(sectionInset: NSEdgeInsets): void;
  sectionHeadersPinToVisibleBounds(): boolean;
  setSectionHeadersPinToVisibleBounds(sectionHeadersPinToVisibleBounds: boolean): void;
  sectionFootersPinToVisibleBounds(): boolean;
  setSectionFootersPinToVisibleBounds(sectionFootersPinToVisibleBounds: boolean): void;
}
declare const NSCollectionViewFlowLayout: {
  alloc(): NSCollectionViewFlowLayoutAllocator;
}

interface INSCollectionViewDelegateFlowLayout {
  collectionView_layout_sizeForItemAtIndexPath(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, indexPath: NSIndexPath): NSSize;
  collectionView_layout_insetForSectionAtIndex(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): NSEdgeInsets;
  collectionView_layout_minimumLineSpacingForSectionAtIndex(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): CGFloat;
  collectionView_layout_minimumInteritemSpacingForSectionAtIndex(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): CGFloat;
  collectionView_layout_referenceSizeForHeaderInSection(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): NSSize;
  collectionView_layout_referenceSizeForFooterInSection(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): NSSize;
}

declare enum NSCollectionViewScrollDirection {
  NSCollectionViewScrollDirectionVertical,
  NSCollectionViewScrollDirectionHorizontal,
}

interface NSCollectionViewGridLayoutAllocator<InitializedType = NSCollectionViewGridLayout> extends NSCollectionViewLayoutAllocator<NSCollectionViewGridLayout> {}
interface NSCollectionViewGridLayout extends NSCollectionViewLayout {

  margins(): NSEdgeInsets;
  setMargins(margins: NSEdgeInsets): void;
  minimumInteritemSpacing(): CGFloat;
  setMinimumInteritemSpacing(minimumInteritemSpacing: CGFloat): void;
  minimumLineSpacing(): CGFloat;
  setMinimumLineSpacing(minimumLineSpacing: CGFloat): void;
  maximumNumberOfRows(): NSUInteger;
  setMaximumNumberOfRows(maximumNumberOfRows: NSUInteger): void;
  maximumNumberOfColumns(): NSUInteger;
  setMaximumNumberOfColumns(maximumNumberOfColumns: NSUInteger): void;
  minimumItemSize(): NSSize;
  setMinimumItemSize(minimumItemSize: NSSize): void;
  maximumItemSize(): NSSize;
  setMaximumItemSize(maximumItemSize: NSSize): void;
  backgroundColors(): NSArray<any>;
  setBackgroundColors(backgroundColors: NSArray<any> | any[]): void;
}
declare const NSCollectionViewGridLayout: {
  alloc(): NSCollectionViewGridLayoutAllocator;
}

interface NSCollectionViewLayoutAttributesAllocator<InitializedType = NSCollectionViewLayoutAttributes> extends NSObjectAllocator<NSCollectionViewLayoutAttributes> {}
interface NSCollectionViewLayoutAttributes extends NSObject, INSCopying {

  frame(): NSRect;
  setFrame(frame: NSRect): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  alpha(): CGFloat;
  setAlpha(alpha: CGFloat): void;
  zIndex(): NSInteger;
  setZIndex(zIndex: NSInteger): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  indexPath(): NSIndexPath;
  setIndexPath(indexPath: NSIndexPath): void;
  representedElementCategory(): NSCollectionElementCategory;
  representedElementKind(): NSString;
}
declare const NSCollectionViewLayoutAttributes: {
  alloc(): NSCollectionViewLayoutAttributesAllocator;  layoutAttributesForItemWithIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForInterItemGapBeforeIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryViewOfKind_withIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForDecorationViewOfKind_withIndexPath(decorationViewKind: NSCollectionViewDecorationElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;

}

interface NSCollectionViewUpdateItemAllocator<InitializedType = NSCollectionViewUpdateItem> extends NSObjectAllocator<NSCollectionViewUpdateItem> {}
interface NSCollectionViewUpdateItem extends NSObject {

  indexPathBeforeUpdate(): NSIndexPath;
  indexPathAfterUpdate(): NSIndexPath;
  updateAction(): NSCollectionUpdateAction;
}
declare const NSCollectionViewUpdateItem: {
  alloc(): NSCollectionViewUpdateItemAllocator;
}

interface NSCollectionViewLayoutInvalidationContextAllocator<InitializedType = NSCollectionViewLayoutInvalidationContext> extends NSObjectAllocator<NSCollectionViewLayoutInvalidationContext> {}
interface NSCollectionViewLayoutInvalidationContext extends NSObject {
  invalidateItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  invalidateSupplementaryElementsOfKind_atIndexPaths(elementKind: NSCollectionViewSupplementaryElementKind, indexPaths: NSSet<any>): void;
  invalidateDecorationElementsOfKind_atIndexPaths(elementKind: NSCollectionViewDecorationElementKind, indexPaths: NSSet<any>): void;

  invalidateEverything(): boolean;
  invalidateDataSourceCounts(): boolean;
  invalidatedItemIndexPaths(): NSSet<any>;
  invalidatedSupplementaryIndexPaths(): NSDictionary<any, any>;
  invalidatedDecorationIndexPaths(): NSDictionary<any, any>;
  contentOffsetAdjustment(): NSPoint;
  setContentOffsetAdjustment(contentOffsetAdjustment: NSPoint): void;
  contentSizeAdjustment(): NSSize;
  setContentSizeAdjustment(contentSizeAdjustment: NSSize): void;
}
declare const NSCollectionViewLayoutInvalidationContext: {
  alloc(): NSCollectionViewLayoutInvalidationContextAllocator;
}

interface NSCollectionViewLayoutAllocator<InitializedType = NSCollectionViewLayout> extends NSObjectAllocator<NSCollectionViewLayout> {
  initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath): InitializedType;
  initialLayoutAttributesForAppearingSupplementaryElementOfKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, elementIndexPath: NSIndexPath): InitializedType;
  initialLayoutAttributesForAppearingDecorationElementOfKind_atIndexPath(elementKind: NSCollectionViewDecorationElementKind, decorationIndexPath: NSIndexPath): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSCollectionViewLayout extends NSObject, INSCoding {
  invalidateLayout(): void;
  invalidateLayoutWithContext(context: NSCollectionViewLayoutInvalidationContext): void;
  registerClass_forDecorationViewOfKind(viewClass: any | null, elementKind: NSCollectionViewDecorationElementKind): void;
  registerNib_forDecorationViewOfKind(nib: NSNib | null, elementKind: NSCollectionViewDecorationElementKind): void;
  prepareLayout(): void;
  layoutAttributesForElementsInRect(rect: NSRect): NSArray<any>;
  layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryViewOfKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForDecorationViewOfKind_atIndexPath(elementKind: NSCollectionViewDecorationElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForDropTargetAtPoint(pointInCollectionView: NSPoint): NSCollectionViewLayoutAttributes;
  layoutAttributesForInterItemGapBeforeIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  shouldInvalidateLayoutForBoundsChange(newBounds: NSRect): boolean;
  invalidationContextForBoundsChange(newBounds: NSRect): NSCollectionViewLayoutInvalidationContext;
  shouldInvalidateLayoutForPreferredLayoutAttributes_withOriginalAttributes(preferredAttributes: NSCollectionViewLayoutAttributes, originalAttributes: NSCollectionViewLayoutAttributes): boolean;
  invalidationContextForPreferredLayoutAttributes_withOriginalAttributes(preferredAttributes: NSCollectionViewLayoutAttributes, originalAttributes: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutInvalidationContext;
  targetContentOffsetForProposedContentOffset_withScrollingVelocity(proposedContentOffset: NSPoint, velocity: NSPoint): NSPoint;
  targetContentOffsetForProposedContentOffset(proposedContentOffset: NSPoint): NSPoint;
  prepareForCollectionViewUpdates(updateItems: NSArray<any> | any[]): void;
  finalizeCollectionViewUpdates(): void;
  prepareForAnimatedBoundsChange(oldBounds: NSRect): void;
  finalizeAnimatedBoundsChange(): void;
  prepareForTransitionToLayout(newLayout: NSCollectionViewLayout): void;
  prepareForTransitionFromLayout(oldLayout: NSCollectionViewLayout): void;
  finalizeLayoutTransition(): void;
  finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  finalLayoutAttributesForDisappearingSupplementaryElementOfKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, elementIndexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  finalLayoutAttributesForDisappearingDecorationElementOfKind_atIndexPath(elementKind: NSCollectionViewDecorationElementKind, decorationIndexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  indexPathsToDeleteForSupplementaryViewOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSSet<any>;
  indexPathsToDeleteForDecorationViewOfKind(elementKind: NSCollectionViewDecorationElementKind): NSSet<any>;
  indexPathsToInsertForSupplementaryViewOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSSet<any>;
  indexPathsToInsertForDecorationViewOfKind(elementKind: NSCollectionViewDecorationElementKind): NSSet<any>;

  collectionView(): NSCollectionView;
  collectionViewContentSize(): NSSize;
}
declare const NSCollectionViewLayout: {
  alloc(): NSCollectionViewLayoutAllocator;
  layoutAttributesClass(): any;
  invalidationContextClass(): any;

}

declare type NSCollectionViewDecorationElementKind = NSString

declare enum NSCollectionElementCategory {
  NSCollectionElementCategoryItem,
  NSCollectionElementCategorySupplementaryView,
  NSCollectionElementCategoryDecorationView,
  NSCollectionElementCategoryInterItemGap,
}

declare enum NSCollectionUpdateAction {
  NSCollectionUpdateActionInsert,
  NSCollectionUpdateActionDelete,
  NSCollectionUpdateActionReload,
  NSCollectionUpdateActionMove,
  NSCollectionUpdateActionNone,
}

interface NSCollectionViewTransitionLayoutAllocator<InitializedType = NSCollectionViewTransitionLayout> extends NSCollectionViewLayoutAllocator<NSCollectionViewTransitionLayout> {
  initWithCurrentLayout_nextLayout(currentLayout: NSCollectionViewLayout, newLayout: NSCollectionViewLayout): InitializedType;
}
interface NSCollectionViewTransitionLayout extends NSCollectionViewLayout {
  updateValue_forAnimatedKey(value: CGFloat, key: NSCollectionViewTransitionLayoutAnimatedKey): void;
  valueForAnimatedKey(key: NSCollectionViewTransitionLayoutAnimatedKey): CGFloat;

  transitionProgress(): CGFloat;
  setTransitionProgress(transitionProgress: CGFloat): void;
  currentLayout(): NSCollectionViewLayout;
  nextLayout(): NSCollectionViewLayout;
}
declare const NSCollectionViewTransitionLayout: {
  alloc(): NSCollectionViewTransitionLayoutAllocator;
}

declare type NSCollectionViewTransitionLayoutAnimatedKey = NSString

interface NSColorAllocator<InitializedType = NSColor> extends NSObjectAllocator<NSColor> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): InitializedType;
}
interface NSColor extends NSObject, INSCopying, INSSecureCoding, INSPasteboardReading, INSPasteboardWriting {
  colorUsingType(type: NSColorType): NSColor;
  colorUsingColorSpace(space: NSColorSpace): NSColor;
  highlightWithLevel(val: CGFloat): NSColor;
  shadowWithLevel(val: CGFloat): NSColor;
  set(): void;
  setFill(): void;
  setStroke(): void;
  blendedColorWithFraction_ofColor(fraction: CGFloat, color: NSColor): NSColor;
  colorWithAlphaComponent(alpha: CGFloat): NSColor;
  getRed_green_blue_alpha(red: CGFloat | null, green: CGFloat | null, blue: CGFloat | null, alpha: CGFloat | null): void;
  getHue_saturation_brightness_alpha(hue: CGFloat | null, saturation: CGFloat | null, brightness: CGFloat | null, alpha: CGFloat | null): void;
  getWhite_alpha(white: CGFloat | null, alpha: CGFloat | null): void;
  getCyan_magenta_yellow_black_alpha(cyan: CGFloat | null, magenta: CGFloat | null, yellow: CGFloat | null, black: CGFloat | null, alpha: CGFloat | null): void;
  getComponents(components: CGFloat): void;
  writeToPasteboard(pasteBoard: NSPasteboard): void;
  drawSwatchInRect(rect: NSRect): void;
  colorUsingColorSpaceName_device(name: NSColorSpaceName | null, deviceDescription: NSDictionary<any, any> | {[key: string]: any} | null): NSColor;
  colorUsingColorSpaceName(name: NSColorSpaceName): NSColor;
  fuzzyIsEqual(object: any): boolean;
  newCGColor(): CGColorRef;
  isWhite(): boolean;
  colorByApplyingModifier(modifier: NSString | string): NSColor;
  colorByApplyingModifiers(modifiers: NSArray<any> | any[]): NSColor;
  stringValueWithAlpha(includeAlpha: boolean): NSString;
  hexValue(): NSString;
  colorTranslatedToColorSpace(colorSpace: NSColorSpace): NSColor;

  type(): NSColorType;
  catalogNameComponent(): NSColorListName;
  colorNameComponent(): NSColorName;
  localizedCatalogNameComponent(): NSString;
  localizedColorNameComponent(): NSString;
  redComponent(): CGFloat;
  greenComponent(): CGFloat;
  blueComponent(): CGFloat;
  hueComponent(): CGFloat;
  saturationComponent(): CGFloat;
  brightnessComponent(): CGFloat;
  whiteComponent(): CGFloat;
  cyanComponent(): CGFloat;
  magentaComponent(): CGFloat;
  yellowComponent(): CGFloat;
  blackComponent(): CGFloat;
  colorSpace(): NSColorSpace;
  numberOfComponents(): NSInteger;
  patternImage(): NSImage;
  alphaComponent(): CGFloat;
  CGColor(): CGColorRef;
  colorSpaceName(): NSColorSpaceName;
  themeCachingKey(): NSString;
  setThemeCachingKey(themeCachingKey: NSString | string): void;
  manifestComponents(): NSArray<any>;
}
declare const NSColor: {
  alloc(): NSColorAllocator;  colorWithColorSpace_components_count(space: NSColorSpace, components: CGFloat, numberOfComponents: NSInteger): NSColor;
  colorWithSRGBRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  colorWithGenericGamma22White_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  colorWithDisplayP3Red_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  colorWithWhite_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  colorWithHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  colorWithColorSpace_hue_saturation_brightness_alpha(space: NSColorSpace, hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  colorWithCatalogName_colorName(listName: NSColorListName, colorName: NSColorName): NSColor;
  colorNamed_bundle(name: NSColorName, bundle: NSBundle | null): NSColor;
  colorNamed(name: NSColorName): NSColor;
  colorWithDeviceWhite_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  colorWithDeviceRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  colorWithDeviceHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  colorWithDeviceCyan_magenta_yellow_black_alpha(cyan: CGFloat, magenta: CGFloat, yellow: CGFloat, black: CGFloat, alpha: CGFloat): NSColor;
  colorWithCalibratedWhite_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  colorWithCalibratedRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  colorWithCalibratedHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  colorWithPatternImage(image: NSImage): NSColor;
  colorForControlTint(controlTint: NSControlTint): NSColor;
  colorFromPasteboard(pasteBoard: NSPasteboard): NSColor;
  colorWithCGColor(cgColor: CGColorRef): NSColor;
  colorWithCIColor(color: CIColor): NSColor;
  colorWithGray(gray: CGFloat): NSColor;
  colorWithGray_alpha(gray: CGFloat, alpha: CGFloat): NSColor;
  tintColorIntense(): NSColor;
  tintColorIntenseDark(): NSColor;
  tintColorNormal(): NSColor;
  tintColorNormalDark(): NSColor;
  tintColorMild(): NSColor;
  tintColorMildDark(): NSColor;
  inspectorViewBackgroundColor(): NSColor;
  inspectorLabelTextColor(): NSColor;
  inspectorInlineLabelColor(): NSColor;
  inspectorLabelBackgroundColor(): NSColor;
  inspectorLabelBorderColor(): NSColor;
  inspectorBorderColor(): NSColor;
  inspectorHighlightedBorderColor(): NSColor;
  inspectorAccentColor(): NSColor;
  inspectorHighlightedAccentColor(): NSColor;
  inspectorButtonBackgroundColor(): NSColor;
  inspectorButtonHighlightedBackgroundColor(): NSColor;
  inspectorIconColor(): NSColor;
  inspectorDisabledIconColor(): NSColor;
  inspectorHighlightedIconColor(): NSColor;
  inspectorAccentedIconColor(): NSColor;
  inspectorSliderRightTrackColor(): NSColor;
  inspectorSliderKnobColor(): NSColor;
  inspectorHighlightedSliderKnobColor(): NSColor;
  inspectorSliderKnobBorderColor(): NSColor;
  inspectorSectionHeaderForegroundColor(): NSColor;
  inspectorResizePreviewBackgroundColor(): NSColor;
  inspectorResizePreviewEdgeIndicatorColor(): NSColor;
  inspectorResizePreviewInnerLayerColor(): NSColor;
  inspectorResizePreviewInnerLayerBorderColor(): NSColor;

  blackColor(): NSColor;
  darkGrayColor(): NSColor;
  lightGrayColor(): NSColor;
  whiteColor(): NSColor;
  grayColor(): NSColor;
  redColor(): NSColor;
  greenColor(): NSColor;
  blueColor(): NSColor;
  cyanColor(): NSColor;
  yellowColor(): NSColor;
  magentaColor(): NSColor;
  orangeColor(): NSColor;
  purpleColor(): NSColor;
  brownColor(): NSColor;
  clearColor(): NSColor;
  controlShadowColor(): NSColor;
  controlDarkShadowColor(): NSColor;
  controlColor(): NSColor;
  controlHighlightColor(): NSColor;
  controlLightHighlightColor(): NSColor;
  controlTextColor(): NSColor;
  controlBackgroundColor(): NSColor;
  selectedControlColor(): NSColor;
  secondarySelectedControlColor(): NSColor;
  selectedControlTextColor(): NSColor;
  disabledControlTextColor(): NSColor;
  textColor(): NSColor;
  textBackgroundColor(): NSColor;
  selectedTextColor(): NSColor;
  selectedTextBackgroundColor(): NSColor;
  gridColor(): NSColor;
  keyboardFocusIndicatorColor(): NSColor;
  windowBackgroundColor(): NSColor;
  underPageBackgroundColor(): NSColor;
  labelColor(): NSColor;
  secondaryLabelColor(): NSColor;
  tertiaryLabelColor(): NSColor;
  quaternaryLabelColor(): NSColor;
  scrollBarColor(): NSColor;
  knobColor(): NSColor;
  selectedKnobColor(): NSColor;
  windowFrameColor(): NSColor;
  windowFrameTextColor(): NSColor;
  selectedMenuItemColor(): NSColor;
  selectedMenuItemTextColor(): NSColor;
  highlightColor(): NSColor;
  shadowColor(): NSColor;
  headerColor(): NSColor;
  headerTextColor(): NSColor;
  alternateSelectedControlColor(): NSColor;
  alternateSelectedControlTextColor(): NSColor;
  scrubberTexturedBackgroundColor(): NSColor;
  controlAlternatingRowBackgroundColors(): NSArray<any>;
  systemRedColor(): NSColor;
  systemGreenColor(): NSColor;
  systemBlueColor(): NSColor;
  systemOrangeColor(): NSColor;
  systemYellowColor(): NSColor;
  systemBrownColor(): NSColor;
  systemPinkColor(): NSColor;
  systemPurpleColor(): NSColor;
  systemGrayColor(): NSColor;
  currentControlTint(): NSControlTint;
  ignoresAlpha(): boolean;
  setIgnoresAlpha(ignoresAlpha: boolean): void;

}

interface CIColorAllocator<InitializedType = CIColor> {
  initWithColor(color: NSColor): InitializedType;
}
interface CIColor {
}
declare const CIColor: {
  alloc(): CIColorAllocator;
}

declare enum NSColorType {
  NSColorTypeComponentBased,
  NSColorTypePattern,
  NSColorTypeCatalog,
}

interface NSColorListAllocator<InitializedType = NSColorList> extends NSObjectAllocator<NSColorList> {
  initWithName(name: NSColorListName): InitializedType;
  initWithName_fromFile(name: NSColorListName, path: NSString | string | null): InitializedType;
}
interface NSColorList extends NSObject, INSSecureCoding {
  setColor_forKey(color: NSColor, key: NSColorName): void;
  insertColor_key_atIndex(color: NSColor, key: NSColorName, loc: NSUInteger): void;
  removeColorWithKey(key: NSColorName): void;
  colorWithKey(key: NSColorName): NSColor;
  writeToURL_error(url: NSURL | null, errPtr: NSError): boolean;
  writeToFile(path: NSString | string | null): boolean;
  removeFile(): void;

  name(): NSColorListName;
  allKeys(): NSArray<any>;
  editable(): boolean;
}
declare const NSColorList: {
  alloc(): NSColorListAllocator;  colorListNamed(name: NSColorListName): NSColorList;

  availableColorLists(): NSArray<any>;

}

declare type NSColorListName = NSString

declare type NSColorName = NSString

interface NSColorPanelAllocator<InitializedType = NSColorPanel> extends NSPanelAllocator<NSColorPanel> {}
interface NSColorPanel extends NSPanel {
  setAction(selector: string | null): void;
  setTarget(target: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  shouldIgnoreChangeColorMessage(): boolean;
  shouldIgnoreNonInteractiveChangeColorMessage(): boolean;
  setColorWithoutNotifying(color: NSColor): void;

  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  showsAlpha(): boolean;
  setShowsAlpha(showsAlpha: boolean): void;
  mode(): NSColorPanelMode;
  setMode(mode: NSColorPanelMode): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  alpha(): CGFloat;
}
declare const NSColorPanel: {
  alloc(): NSColorPanelAllocator;  dragColor_withEvent_fromView(color: NSColor, event: NSEvent, sourceView: NSView): boolean;
  setPickerMask(mask: NSColorPanelOptions): void;
  setPickerMode(mode: NSColorPanelMode): void;

  sharedColorPanel(): NSColorPanel;
  sharedColorPanelExists(): boolean;

}

declare enum NSColorPanelMode {
  NSColorPanelModeNone = -1,
  NSColorPanelModeGray = 0,
  NSColorPanelModeRGB = 1,
  NSColorPanelModeCMYK = 2,
  NSColorPanelModeHSB = 3,
  NSColorPanelModeCustomPalette = 4,
  NSColorPanelModeColorList = 5,
  NSColorPanelModeWheel = 6,
  NSColorPanelModeCrayon = 7,
}

declare enum NSColorPanelOptions {
  NSColorPanelGrayModeMask = 0x00000001,
  NSColorPanelRGBModeMask = 0x00000002,
  NSColorPanelCMYKModeMask = 0x00000004,
  NSColorPanelHSBModeMask = 0x00000008,
  NSColorPanelCustomPaletteModeMask = 0x00000010,
  NSColorPanelColorListModeMask = 0x00000020,
  NSColorPanelWheelModeMask = 0x00000040,
  NSColorPanelCrayonModeMask = 0x00000080,
  NSColorPanelAllModesMask = 0x0000ffff,
}

interface NSColorPickerAllocator<InitializedType = NSColorPicker> extends NSObjectAllocator<NSColorPicker> {
  initWithPickerMask_colorPanel(mask: NSUInteger, owningColorPanel: NSColorPanel): InitializedType;
  initWithPickerMask_colorPanel(mask: NSUInteger, owningColorPanel: NSColorPanel): InitializedType;
}
interface NSColorPicker extends NSObject, INSColorPickingDefault {
  insertNewButtonImage_in(newButtonImage: NSImage, buttonCell: NSButtonCell): void;
  viewSizeChanged(sender: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  setMode(mode: NSColorPanelMode): void;

  colorPanel(): NSColorPanel;
  provideNewButtonImage(): NSImage;
  buttonToolTip(): NSString;
  minContentSize(): NSSize;
}
declare const NSColorPicker: {
  alloc(): NSColorPickerAllocator;
}

interface NSColorPickerTouchBarItemAllocator<InitializedType = NSColorPickerTouchBarItem> extends NSTouchBarItemAllocator<NSColorPickerTouchBarItem> {}
interface NSColorPickerTouchBarItem extends NSTouchBarItem {

  color(): NSColor;
  setColor(color: NSColor): void;
  showsAlpha(): boolean;
  setShowsAlpha(showsAlpha: boolean): void;
  allowedColorSpaces(): NSArray<any>;
  setAllowedColorSpaces(allowedColorSpaces: NSArray<any> | any[]): void;
  colorList(): NSColorList;
  setColorList(colorList: NSColorList): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}
declare const NSColorPickerTouchBarItem: {
  alloc(): NSColorPickerTouchBarItemAllocator;  colorPickerWithIdentifier(identifier: NSTouchBarItemIdentifier): NSColorPickerTouchBarItem;
  textColorPickerWithIdentifier(identifier: NSTouchBarItemIdentifier): NSColorPickerTouchBarItem;
  strokeColorPickerWithIdentifier(identifier: NSTouchBarItemIdentifier): NSColorPickerTouchBarItem;
  colorPickerWithIdentifier_buttonImage(identifier: NSTouchBarItemIdentifier, image: NSImage): NSColorPickerTouchBarItem;

}

interface INSColorPickingDefault {
  provideNewButtonImage(): NSImage;
  insertNewButtonImage_in(newButtonImage: NSImage, buttonCell: NSButtonCell): void;
  viewSizeChanged(sender: any | null): void;
  alphaControlAddedOrRemoved(sender: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  setMode(mode: NSColorPanelMode): void;
  buttonToolTip(): NSString;
  minContentSize(): NSSize;
}

interface INSColorPickingCustom {
  supportsMode(mode: NSColorPanelMode): boolean;
  currentMode(): NSColorPanelMode;
  provideNewView(initialRequest: boolean): NSView;
  setColor(newColor: NSColor): void;
}

interface NSColorSpaceAllocator<InitializedType = NSColorSpace> extends NSObjectAllocator<NSColorSpace> {
  initWithICCProfileData(iccData: NSData): InitializedType;
  initWithColorSyncProfile(prof: void): InitializedType;
  initWithCGColorSpace(cgColorSpace: CGColorSpaceRef): InitializedType;
}
interface NSColorSpace extends NSObject, INSSecureCoding {

  ICCProfileData(): NSData;
  colorSyncProfile(): void;
  CGColorSpace(): CGColorSpaceRef;
  numberOfColorComponents(): NSInteger;
  colorSpaceModel(): NSColorSpaceModel;
  localizedName(): NSString;
}
declare const NSColorSpace: {
  alloc(): NSColorSpaceAllocator;  availableColorSpacesWithModel(model: NSColorSpaceModel): NSArray<any>;
  RGBColorSpaceNamed(colorSpaceName: NSString | string): NSColorSpace;
  colorSpaceForSketchColorSpace(modelColorSpace: MSColorSpace): NSColorSpace;

  sRGBColorSpace(): NSColorSpace;
  genericGamma22GrayColorSpace(): NSColorSpace;
  extendedSRGBColorSpace(): NSColorSpace;
  extendedGenericGamma22GrayColorSpace(): NSColorSpace;
  displayP3ColorSpace(): NSColorSpace;
  adobeRGB1998ColorSpace(): NSColorSpace;
  genericRGBColorSpace(): NSColorSpace;
  genericGrayColorSpace(): NSColorSpace;
  genericCMYKColorSpace(): NSColorSpace;
  deviceRGBColorSpace(): NSColorSpace;
  deviceGrayColorSpace(): NSColorSpace;
  deviceCMYKColorSpace(): NSColorSpace;

}

declare enum NSColorSpaceModel {
  NSColorSpaceModelUnknown = -1,
  NSColorSpaceModelGray,
  NSColorSpaceModelRGB,
  NSColorSpaceModelCMYK,
  NSColorSpaceModelLAB,
  NSColorSpaceModelDeviceN,
  NSColorSpaceModelIndexed,
  NSColorSpaceModelPatterned,
}

interface NSColorWellAllocator<InitializedType = NSColorWell> extends NSControlAllocator<NSColorWell> {}
interface NSColorWell extends NSControl {
  deactivate(): void;
  activate(exclusive: boolean): void;
  drawWellInside(insideRect: NSRect): void;
  takeColorFrom(sender: any | null): void;

  active(): boolean;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  color(): NSColor;
  setColor(color: NSColor): void;
}
declare const NSColorWell: {
  alloc(): NSColorWellAllocator;
}

interface NSComboBoxAllocator<InitializedType = NSComboBox> extends NSTextFieldAllocator<NSComboBox> {}
interface NSComboBox extends NSTextField {
  reloadData(): void;
  noteNumberOfItemsChanged(): void;
  scrollItemAtIndexToTop(index: NSInteger): void;
  scrollItemAtIndexToVisible(index: NSInteger): void;
  selectItemAtIndex(index: NSInteger): void;
  deselectItemAtIndex(index: NSInteger): void;
  addItemWithObjectValue(object: any): void;
  addItemsWithObjectValues(objects: NSArray<any> | any[]): void;
  insertItemWithObjectValue_atIndex(object: any, index: NSInteger): void;
  removeItemWithObjectValue(object: any): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  selectItemWithObjectValue(object: any | null): void;
  itemObjectValueAtIndex(index: NSInteger): any;
  indexOfItemWithObjectValue(object: any): NSInteger;

  hasVerticalScroller(): boolean;
  setHasVerticalScroller(hasVerticalScroller: boolean): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  itemHeight(): CGFloat;
  setItemHeight(itemHeight: CGFloat): void;
  numberOfVisibleItems(): NSInteger;
  setNumberOfVisibleItems(numberOfVisibleItems: NSInteger): void;
  buttonBordered(): boolean;
  setButtonBordered(buttonBordered: boolean): void;
  usesDataSource(): boolean;
  setUsesDataSource(usesDataSource: boolean): void;
  indexOfSelectedItem(): NSInteger;
  numberOfItems(): NSInteger;
  completes(): boolean;
  setCompletes(completes: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  objectValueOfSelectedItem(): any;
  objectValues(): NSArray<any>;
}
declare const NSComboBox: {
  alloc(): NSComboBoxAllocator;
}

interface INSComboBoxDataSource {
  numberOfItemsInComboBox(comboBox: NSComboBox): NSInteger;
  comboBox_objectValueForItemAtIndex(comboBox: NSComboBox, index: NSInteger): any;
  comboBox_indexOfItemWithStringValue(comboBox: NSComboBox, string: NSString | string): NSUInteger;
  comboBox_completedString(comboBox: NSComboBox, string: NSString | string): NSString;
}

interface INSComboBoxDelegate {
  comboBoxWillPopUp(notification: NSNotification): void;
  comboBoxWillDismiss(notification: NSNotification): void;
  comboBoxSelectionDidChange(notification: NSNotification): void;
  comboBoxSelectionIsChanging(notification: NSNotification): void;
}

interface NSComboBoxCellAllocator<InitializedType = NSComboBoxCell> extends NSTextFieldCellAllocator<NSComboBoxCell> {}
interface NSComboBoxCell extends NSTextFieldCell {
  reloadData(): void;
  noteNumberOfItemsChanged(): void;
  scrollItemAtIndexToTop(index: NSInteger): void;
  scrollItemAtIndexToVisible(index: NSInteger): void;
  selectItemAtIndex(index: NSInteger): void;
  deselectItemAtIndex(index: NSInteger): void;
  completedString(string: NSString | string): NSString;
  addItemWithObjectValue(object: any): void;
  addItemsWithObjectValues(objects: NSArray<any> | any[]): void;
  insertItemWithObjectValue_atIndex(object: any, index: NSInteger): void;
  removeItemWithObjectValue(object: any): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  selectItemWithObjectValue(object: any | null): void;
  itemObjectValueAtIndex(index: NSInteger): any;
  indexOfItemWithObjectValue(object: any): NSInteger;

  hasVerticalScroller(): boolean;
  setHasVerticalScroller(hasVerticalScroller: boolean): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  itemHeight(): CGFloat;
  setItemHeight(itemHeight: CGFloat): void;
  numberOfVisibleItems(): NSInteger;
  setNumberOfVisibleItems(numberOfVisibleItems: NSInteger): void;
  buttonBordered(): boolean;
  setButtonBordered(buttonBordered: boolean): void;
  usesDataSource(): boolean;
  setUsesDataSource(usesDataSource: boolean): void;
  indexOfSelectedItem(): NSInteger;
  numberOfItems(): NSInteger;
  completes(): boolean;
  setCompletes(completes: boolean): void;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  objectValueOfSelectedItem(): any;
  objectValues(): NSArray<any>;
}
declare const NSComboBoxCell: {
  alloc(): NSComboBoxCellAllocator;
}

interface INSComboBoxCellDataSource {
  numberOfItemsInComboBoxCell(comboBoxCell: NSComboBoxCell): NSInteger;
  comboBoxCell_objectValueForItemAtIndex(comboBoxCell: NSComboBoxCell, index: NSInteger): any;
  comboBoxCell_indexOfItemWithStringValue(comboBoxCell: NSComboBoxCell, string: NSString | string): NSUInteger;
  comboBoxCell_completedString(comboBoxCell: NSComboBoxCell, uncompletedString: NSString | string): NSString;
}

interface NSControlAllocator<InitializedType = NSControl> extends NSViewAllocator<NSControl> {}
interface NSControl extends NSView {
  sizeThatFits(size: NSSize): NSSize;
  sizeToFit(): void;
  sendActionOn(mask: NSInteger): NSInteger;
  sendAction_to(action: string | null, target: any | null): boolean;
  takeIntValueFrom(sender: any | null): void;
  takeFloatValueFrom(sender: any | null): void;
  takeDoubleValueFrom(sender: any | null): void;
  takeStringValueFrom(sender: any | null): void;
  takeObjectValueFrom(sender: any | null): void;
  takeIntegerValueFrom(sender: any | null): void;
  mouseDown(event: NSEvent): void;
  performClick(sender: any | null): void;
  expansionFrameWithFrame(contentFrame: NSRect): NSRect;
  drawWithExpansionFrame_inView(contentFrame: NSRect, view: NSView): void;
  currentEditor(): NSText;
  abortEditing(): boolean;
  validateEditing(): void;
  editWithFrame_editor_delegate_event(rect: NSRect, textObj: NSText, delegate: any | null, event: NSEvent): void;
  selectWithFrame_editor_delegate_start_length(rect: NSRect, textObj: NSText, delegate: any | null, selStart: NSInteger, selLength: NSInteger): void;
  endEditing(textObj: NSText): void;
  setFloatingPointFormat_left_right(autoRange: boolean, leftDigits: NSUInteger, rightDigits: NSUInteger): void;
  selectedCell(): NSCell;
  selectedTag(): NSInteger;
  setNeedsDisplay(): void;
  calcSize(): void;
  updateCell(cell: NSCell): void;
  updateCellInside(cell: NSCell): void;
  drawCellInside(cell: NSCell): void;
  drawCell(cell: NSCell): void;
  selectCell(cell: NSCell): void;
  invalidateIntrinsicContentSizeForCell(cell: NSCell): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  ignoresMultiClick(): boolean;
  setIgnoresMultiClick(ignoresMultiClick: boolean): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  refusesFirstResponder(): boolean;
  setRefusesFirstResponder(refusesFirstResponder: boolean): void;
  highlighted(): boolean;
  setHighlighted(highlighted: boolean): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  formatter(): NSFormatter;
  setFormatter(formatter: NSFormatter): void;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  attributedStringValue(): NSAttributedString;
  setAttributedStringValue(attributedStringValue: NSAttributedString): void;
  objectValue(): any;
  setObjectValue(objectValue: any): void;
  intValue(): number;
  setIntValue(intValue: number): void;
  integerValue(): NSInteger;
  setIntegerValue(integerValue: NSInteger): void;
  floatValue(): number;
  setFloatValue(floatValue: number): void;
  doubleValue(): number;
  setDoubleValue(doubleValue: number): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  usesSingleLineMode(): boolean;
  setUsesSingleLineMode(usesSingleLineMode: boolean): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  allowsExpansionToolTips(): boolean;
  setAllowsExpansionToolTips(allowsExpansionToolTips: boolean): void;
  cell(): NSCell;
  setCell(cell: NSCell): void;
}
declare const NSControl: {
  alloc(): NSControlAllocator;  inpectorBorderPathForRect(rect: NSRect): NSBezierPath;
  inpectorCheckmarkBorderPathForRect(rect: NSRect): NSBezierPath;
  inpectorBorderPathForRectWithMaxRadius(rect: NSRect): NSBezierPath;
  inpectorBorderPathForRect_borderRadius(rect: NSRect, borderRadius: CGFloat): NSBezierPath;
  inpectorFocusRingPathForRect(rect: NSRect): NSBezierPath;

  cellClass(): any;
  setCellClass(cellClass: any): void;

}

interface INSControlTextEditingDelegate {
  control_textShouldBeginEditing(control: NSControl, fieldEditor: NSText): boolean;
  control_textShouldEndEditing(control: NSControl, fieldEditor: NSText): boolean;
  control_didFailToFormatString_errorDescription(control: NSControl, string: NSString | string, error: NSString | string | null): boolean;
  control_didFailToValidatePartialString_errorDescription(control: NSControl, string: NSString | string, error: NSString | string | null): void;
  control_isValidObject(control: NSControl, obj: any | null): boolean;
  control_textView_doCommandBySelector(control: NSControl, textView: NSTextView, commandSelector: string): boolean;
  control_textView_completions_forPartialWordRange_indexOfSelectedItem(control: NSControl, textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger): NSArray<any>;
}

interface NSControllerAllocator<InitializedType = NSController> extends NSObjectAllocator<NSController> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSController extends NSObject, INSCoding {
  objectDidBeginEditing(editor: any): void;
  objectDidEndEditing(editor: any): void;
  discardEditing(): void;
  commitEditing(): boolean;
  commitEditingWithDelegate_didCommitSelector_contextInfo(delegate: any | null, didCommitSelector: string | null, contextInfo: void | null): void;

  editing(): boolean;
}
declare const NSController: {
  alloc(): NSControllerAllocator;
}

interface NSCursorAllocator<InitializedType = NSCursor> extends NSObjectAllocator<NSCursor> {
  initWithImage_hotSpot(newImage: NSImage, point: NSPoint): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithImage_foregroundColorHint_backgroundColorHint_hotSpot(newImage: NSImage, fg: NSColor | null, bg: NSColor | null, hotSpot: NSPoint): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSCursor extends NSObject, INSCoding {
  pop(): void;
  push(): void;
  set(): void;
  setOnMouseExited(flag: boolean): void;
  setOnMouseEntered(flag: boolean): void;
  mouseEntered(event: NSEvent): void;
  mouseExited(event: NSEvent): void;

  image(): NSImage;
  hotSpot(): NSPoint;
  setOnMouseExited(): boolean;
  setOnMouseEntered(): boolean;
}
declare const NSCursor: {
  alloc(): NSCursorAllocator;  hide(): void;
  unhide(): void;
  setHiddenUntilMouseMoves(flag: boolean): void;
  cursorWithImageNamed(name: NSString | string): NSCursor;
  cursorWithImageNamed_hotSpot(name: NSString | string, spot: NSPoint): NSCursor;
  penCursor(): NSCursor;
  penAddCursor(): NSCursor;
  penCloseCursor(): NSCursor;
  pencilCursor(): NSCursor;
  resizeHorCursor(): NSCursor;
  resizeHorCursorShort(): NSCursor;
  resizeHorCursorLong(): NSCursor;
  resizeVerCursor(): NSCursor;
  resizeTopLeftToBottomRightCursor(): NSCursor;
  resizeBottomLeftToTopRightCursor(): NSCursor;
  rotateBottomRightCursor(): NSCursor;
  rotateBottomLeftCursor(): NSCursor;
  rotateTopLeftCursor(): NSCursor;
  rotateTopRightCursor(): NSCursor;
  rotateLeftCursor(): NSCursor;
  rotateRightCursor(): NSCursor;
  rotateTopCursor(): NSCursor;
  rotateBottomCursor(): NSCursor;

  currentCursor(): NSCursor;
  currentSystemCursor(): NSCursor;
  arrowCursor(): NSCursor;
  IBeamCursor(): NSCursor;
  pointingHandCursor(): NSCursor;
  closedHandCursor(): NSCursor;
  openHandCursor(): NSCursor;
  resizeLeftCursor(): NSCursor;
  resizeRightCursor(): NSCursor;
  resizeLeftRightCursor(): NSCursor;
  resizeUpCursor(): NSCursor;
  resizeDownCursor(): NSCursor;
  resizeUpDownCursor(): NSCursor;
  crosshairCursor(): NSCursor;
  disappearingItemCursor(): NSCursor;
  operationNotAllowedCursor(): NSCursor;
  dragLinkCursor(): NSCursor;
  dragCopyCursor(): NSCursor;
  contextualMenuCursor(): NSCursor;
  IBeamCursorForVerticalLayout(): NSCursor;

}

interface NSCustomImageRepAllocator<InitializedType = NSCustomImageRep> extends NSImageRepAllocator<NSCustomImageRep> {
  initWithSize_flipped_drawingHandler(size: NSSize, drawingHandlerShouldBeCalledWithFlippedContext: boolean, drawingHandler: Block): InitializedType;
  initWithDrawSelector_delegate(selector: string, delegate: any): InitializedType;
}
interface NSCustomImageRep extends NSImageRep {

  drawSelector(): string;
  delegate(): any;
}
declare const NSCustomImageRep: {
  alloc(): NSCustomImageRepAllocator;
}

interface NSCustomTouchBarItemAllocator<InitializedType = NSCustomTouchBarItem> extends NSTouchBarItemAllocator<NSCustomTouchBarItem> {}
interface NSCustomTouchBarItem extends NSTouchBarItem {

  view(): NSView;
  setView(view: NSView): void;
  viewController(): NSViewController;
  setViewController(viewController: NSViewController): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
}
declare const NSCustomTouchBarItem: {
  alloc(): NSCustomTouchBarItemAllocator;
}

interface NSDataAssetAllocator<InitializedType = NSDataAsset> extends NSObjectAllocator<NSDataAsset> {
  initWithName(name: NSDataAssetName): InitializedType;
  initWithName_bundle(name: NSDataAssetName, bundle: NSBundle): InitializedType;
}
interface NSDataAsset extends NSObject, INSCopying {

  name(): NSDataAssetName;
  data(): NSData;
  typeIdentifier(): NSString;
}
declare const NSDataAsset: {
  alloc(): NSDataAssetAllocator;
}

declare type NSDataAssetName = NSString

interface NSDatePickerAllocator<InitializedType = NSDatePicker> extends NSControlAllocator<NSDatePicker> {}
interface NSDatePicker extends NSControl {

  datePickerStyle(): NSDatePickerStyle;
  setDatePickerStyle(datePickerStyle: NSDatePickerStyle): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  datePickerMode(): NSDatePickerMode;
  setDatePickerMode(datePickerMode: NSDatePickerMode): void;
  datePickerElements(): NSDatePickerElementFlags;
  setDatePickerElements(datePickerElements: NSDatePickerElementFlags): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  dateValue(): NSDate;
  setDateValue(dateValue: NSDate): void;
  timeInterval(): NSTimeInterval;
  setTimeInterval(timeInterval: NSTimeInterval): void;
  minDate(): NSDate;
  setMinDate(minDate: NSDate): void;
  maxDate(): NSDate;
  setMaxDate(maxDate: NSDate): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const NSDatePicker: {
  alloc(): NSDatePickerAllocator;
}

interface NSDatePickerCellAllocator<InitializedType = NSDatePickerCell> extends NSActionCellAllocator<NSDatePickerCell> {}
interface NSDatePickerCell extends NSActionCell {

  datePickerStyle(): NSDatePickerStyle;
  setDatePickerStyle(datePickerStyle: NSDatePickerStyle): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  datePickerMode(): NSDatePickerMode;
  setDatePickerMode(datePickerMode: NSDatePickerMode): void;
  datePickerElements(): NSDatePickerElementFlags;
  setDatePickerElements(datePickerElements: NSDatePickerElementFlags): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  dateValue(): NSDate;
  setDateValue(dateValue: NSDate): void;
  timeInterval(): NSTimeInterval;
  setTimeInterval(timeInterval: NSTimeInterval): void;
  minDate(): NSDate;
  setMinDate(minDate: NSDate): void;
  maxDate(): NSDate;
  setMaxDate(maxDate: NSDate): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const NSDatePickerCell: {
  alloc(): NSDatePickerCellAllocator;
}

interface INSDatePickerCellDelegate {
  datePickerCell_validateProposedDateValue_timeInterval(datePickerCell: NSDatePickerCell, proposedDateValue: NSDate, proposedTimeInterval: NSTimeInterval | null): void;
}

declare enum NSDatePickerStyle {
  NSTextFieldAndStepperDatePickerStyle = 0,
  NSClockAndCalendarDatePickerStyle = 1,
  NSTextFieldDatePickerStyle = 2,
}

declare enum NSDatePickerMode {
  NSSingleDateMode = 0,
  NSRangeDateMode = 1,
}

declare enum NSDatePickerElementFlags {
  NSHourMinuteDatePickerElementFlag = 0x000c,
  NSHourMinuteSecondDatePickerElementFlag = 0x000e,
  NSTimeZoneDatePickerElementFlag = 0x0010,
  NSYearMonthDatePickerElementFlag = 0x00c0,
  NSYearMonthDayDatePickerElementFlag = 0x00e0,
  NSEraDatePickerElementFlag = 0x0100,
}

interface NSDictionaryControllerKeyValuePairAllocator<InitializedType = NSDictionaryControllerKeyValuePair> extends NSObjectAllocator<NSDictionaryControllerKeyValuePair> {}
interface NSDictionaryControllerKeyValuePair extends NSObject {

  key(): NSString;
  setKey(key: NSString | string): void;
  value(): any;
  setValue(value: any): void;
  localizedKey(): NSString;
  setLocalizedKey(localizedKey: NSString | string): void;
  explicitlyIncluded(): boolean;
}
declare const NSDictionaryControllerKeyValuePair: {
  alloc(): NSDictionaryControllerKeyValuePairAllocator;
}

interface NSDictionaryControllerAllocator<InitializedType = NSDictionaryController> extends NSArrayControllerAllocator<NSDictionaryController> {}
interface NSDictionaryController extends NSArrayController {
  newObject(): NSDictionaryControllerKeyValuePair;

  initialKey(): NSString;
  setInitialKey(initialKey: NSString | string): void;
  initialValue(): any;
  setInitialValue(initialValue: any): void;
  includedKeys(): NSArray<any>;
  setIncludedKeys(includedKeys: NSArray<any> | any[]): void;
  excludedKeys(): NSArray<any>;
  setExcludedKeys(excludedKeys: NSArray<any> | any[]): void;
  localizedKeyDictionary(): NSDictionary<any, any>;
  setLocalizedKeyDictionary(localizedKeyDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  localizedKeyTable(): NSString;
  setLocalizedKeyTable(localizedKeyTable: NSString | string): void;
}
declare const NSDictionaryController: {
  alloc(): NSDictionaryControllerAllocator;
}

interface NSDockTileAllocator<InitializedType = NSDockTile> extends NSObjectAllocator<NSDockTile> {}
interface NSDockTile extends NSObject {
  display(): void;

  size(): NSSize;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  showsApplicationBadge(): boolean;
  setShowsApplicationBadge(showsApplicationBadge: boolean): void;
  badgeLabel(): NSString;
  setBadgeLabel(badgeLabel: NSString | string): void;
  owner(): any;
}
declare const NSDockTile: {
  alloc(): NSDockTileAllocator;
}

interface INSDockTilePlugIn {
  setDockTile(dockTile: NSDockTile | null): void;
  dockMenu(): NSMenu;
}

interface NSDocumentAllocator<InitializedType = NSDocument> extends NSObjectAllocator<NSDocument> {
  init(): InitializedType;
  initWithType_error(typeName: NSString | string, outError: NSError): InitializedType;
  initWithContentsOfURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): InitializedType;
  initForURL_withContentsOfURL_ofType_error(urlOrNil: NSURL | null, contentsURL: NSURL, typeName: NSString | string, outError: NSError): InitializedType;
  initWithContentsOfFile_ofType(absolutePath: NSString | string, typeName: NSString | string): InitializedType;
  initWithContentsOfURL_ofType(url: NSURL, typeName: NSString | string): InitializedType;
}
interface NSDocument extends NSObject, INSFilePresenter, INSUserInterfaceValidations {
  performActivityWithSynchronousWaiting_usingBlock(waitSynchronously: boolean, block: Block): void;
  continueActivityUsingBlock(block: Block): void;
  continueAsynchronousWorkOnMainThreadUsingBlock(block: Block): void;
  performSynchronousFileAccessUsingBlock(block: Block): void;
  performAsynchronousFileAccessUsingBlock(block: Block): void;
  revertDocumentToSaved(sender: any | null): IBAction;
  revertToContentsOfURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): boolean;
  readFromURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): boolean;
  readFromFileWrapper_ofType_error(fileWrapper: NSFileWrapper, typeName: NSString | string, outError: NSError): boolean;
  readFromData_ofType_error(data: NSData, typeName: NSString | string, outError: NSError): boolean;
  writeToURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): boolean;
  fileWrapperOfType_error(typeName: NSString | string, outError: NSError): NSFileWrapper;
  dataOfType_error(typeName: NSString | string, outError: NSError): NSData;
  unblockUserInteraction(): void;
  writeSafelyToURL_ofType_forSaveOperation_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, outError: NSError): boolean;
  writeToURL_ofType_forSaveOperation_originalContentsURL_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, absoluteOriginalContentsURL: NSURL | null, outError: NSError): boolean;
  fileAttributesToWriteToURL_ofType_forSaveOperation_originalContentsURL_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, absoluteOriginalContentsURL: NSURL | null, outError: NSError): NSDictionary<any, any>;
  saveDocument(sender: any | null): IBAction;
  saveDocumentAs(sender: any | null): IBAction;
  saveDocumentTo(sender: any | null): IBAction;
  saveDocumentWithDelegate_didSaveSelector_contextInfo(delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  runModalSavePanelForSaveOperation_delegate_didSaveSelector_contextInfo(saveOperation: NSSaveOperationType, delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  prepareSavePanel(savePanel: NSSavePanel): boolean;
  saveToURL_ofType_forSaveOperation_delegate_didSaveSelector_contextInfo(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  saveToURL_ofType_forSaveOperation_completionHandler(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, completionHandler: Block): void;
  canAsynchronouslyWriteToURL_ofType_forSaveOperation(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType): boolean;
  checkAutosavingSafetyAndReturnError(outError: NSError): boolean;
  scheduleAutosaving(): void;
  autosaveDocumentWithDelegate_didAutosaveSelector_contextInfo(delegate: any | null, didAutosaveSelector: string | null, contextInfo: void | null): void;
  autosaveWithImplicitCancellability_completionHandler(autosavingIsImplicitlyCancellable: boolean, completionHandler: Block): void;
  browseDocumentVersions(sender: any | null): IBAction;
  stopBrowsingVersionsWithCompletionHandler(completionHandler: Block): void;
  canCloseDocumentWithDelegate_shouldCloseSelector_contextInfo(delegate: any, shouldCloseSelector: string | null, contextInfo: void | null): void;
  close(): void;
  duplicateDocument(sender: any | null): IBAction;
  duplicateDocumentWithDelegate_didDuplicateSelector_contextInfo(delegate: any | null, didDuplicateSelector: string | null, contextInfo: void | null): void;
  duplicateAndReturnError(outError: NSError): NSDocument;
  renameDocument(sender: any | null): IBAction;
  moveDocumentToUbiquityContainer(sender: any | null): IBAction;
  moveDocument(sender: any | null): IBAction;
  moveDocumentWithCompletionHandler(completionHandler: Block): void;
  moveToURL_completionHandler(url: NSURL, completionHandler: Block): void;
  lockDocument(sender: any | null): IBAction;
  unlockDocument(sender: any | null): IBAction;
  lockDocumentWithCompletionHandler(completionHandler: Block): void;
  lockWithCompletionHandler(completionHandler: Block): void;
  unlockDocumentWithCompletionHandler(completionHandler: Block): void;
  unlockWithCompletionHandler(completionHandler: Block): void;
  runPageLayout(sender: any | null): IBAction;
  runModalPageLayoutWithPrintInfo_delegate_didRunSelector_contextInfo(printInfo: NSPrintInfo, delegate: any | null, didRunSelector: string | null, contextInfo: void | null): void;
  preparePageLayout(pageLayout: NSPageLayout): boolean;
  shouldChangePrintInfo(newPrintInfo: NSPrintInfo): boolean;
  printDocument(sender: any | null): IBAction;
  printDocumentWithSettings_showPrintPanel_delegate_didPrintSelector_contextInfo(printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanel: boolean, delegate: any | null, didPrintSelector: string | null, contextInfo: void | null): void;
  printOperationWithSettings_error(printSettings: NSDictionary<any, any> | {[key: string]: any}, outError: NSError): NSPrintOperation;
  runModalPrintOperation_delegate_didRunSelector_contextInfo(printOperation: NSPrintOperation, delegate: any | null, didRunSelector: string | null, contextInfo: void | null): void;
  saveDocumentToPDF(sender: any | null): IBAction;
  shareDocumentWithSharingService_completionHandler(sharingService: NSSharingService, completionHandler: Block): void;
  prepareSharingServicePicker(sharingServicePicker: NSSharingServicePicker): void;
  updateChangeCount(change: NSDocumentChangeType): void;
  changeCountTokenForSaveOperation(saveOperation: NSSaveOperationType): any;
  updateChangeCountWithToken_forSaveOperation(changeCountToken: any, saveOperation: NSSaveOperationType): void;
  presentError_modalForWindow_delegate_didPresentSelector_contextInfo(error: NSError, window: NSWindow, delegate: any | null, didPresentSelector: string | null, contextInfo: void | null): void;
  presentError(error: NSError): boolean;
  willPresentError(error: NSError): NSError;
  willNotPresentError(error: NSError): void;
  makeWindowControllers(): void;
  windowControllerWillLoadNib(windowController: NSWindowController): void;
  windowControllerDidLoadNib(windowController: NSWindowController): void;
  setWindow(window: NSWindow | null): void;
  addWindowController(windowController: NSWindowController): void;
  removeWindowController(windowController: NSWindowController): void;
  showWindows(): void;
  shouldCloseWindowController_delegate_shouldCloseSelector_contextInfo(windowController: NSWindowController, delegate: any | null, shouldCloseSelector: string | null, contextInfo: void | null): void;
  setDisplayName(displayNameOrNil: NSString | string | null): void;
  defaultDraftName(): NSString;
  writableTypesForSaveOperation(saveOperation: NSSaveOperationType): NSArray<any>;
  fileNameExtensionForType_saveOperation(typeName: NSString | string, saveOperation: NSSaveOperationType): NSString;
  validateUserInterfaceItem(item: any): boolean;
  saveToURL_ofType_forSaveOperation_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, outError: NSError): boolean;
  dataRepresentationOfType(type: NSString | string): NSData;
  fileAttributesToWriteToFile_ofType_saveOperation(fullDocumentPath: NSString | string, documentTypeName: NSString | string, saveOperationType: NSSaveOperationType): NSDictionary<any, any>;
  fileName(): NSString;
  fileWrapperRepresentationOfType(type: NSString | string): NSFileWrapper;
  loadDataRepresentation_ofType(data: NSData, type: NSString | string): boolean;
  loadFileWrapperRepresentation_ofType(wrapper: NSFileWrapper, type: NSString | string): boolean;
  printShowingPrintPanel(flag: boolean): void;
  readFromFile_ofType(fileName: NSString | string, type: NSString | string): boolean;
  readFromURL_ofType(url: NSURL, type: NSString | string): boolean;
  revertToSavedFromFile_ofType(fileName: NSString | string, type: NSString | string): boolean;
  revertToSavedFromURL_ofType(url: NSURL, type: NSString | string): boolean;
  runModalPageLayoutWithPrintInfo(printInfo: NSPrintInfo): NSInteger;
  saveToFile_saveOperation_delegate_didSaveSelector_contextInfo(fileName: NSString | string, saveOperation: NSSaveOperationType, delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  setFileName(fileName: NSString | string | null): void;
  writeToFile_ofType(fileName: NSString | string, type: NSString | string): boolean;
  writeToFile_ofType_originalFile_saveOperation(fullDocumentPath: NSString | string, documentTypeName: NSString | string, fullOriginalDocumentPath: NSString | string | null, saveOperationType: NSSaveOperationType): boolean;
  writeToURL_ofType(url: NSURL, type: NSString | string): boolean;
  writeWithBackupToFile_ofType_saveOperation(fullDocumentPath: NSString | string, documentTypeName: NSString | string, saveOperationType: NSSaveOperationType): boolean;
  handleSaveScriptCommand(command: NSScriptCommand): any;
  handleCloseScriptCommand(command: NSCloseCommand): any;
  handlePrintScriptCommand(command: NSScriptCommand): any;
  updateUserActivityState(activity: NSUserActivity): void;
  restoreUserActivityState(activity: NSUserActivity): void;
  restoreDocumentWindowWithIdentifier_state_completionHandler(identifier: NSUserInterfaceItemIdentifier, state: NSCoder, completionHandler: Block): void;
  encodeRestorableStateWithCoder(coder: NSCoder): void;
  encodeRestorableStateWithCoder_backgroundQueue(coder: NSCoder, queue: NSOperationQueue): void;
  restoreStateWithCoder(coder: NSCoder): void;
  invalidateRestorableState(): void;
  menuNeedsUpdate(menu: NSMenu): void;

  fileType(): NSString;
  setFileType(fileType: NSString | string): void;
  fileURL(): NSURL;
  setFileURL(fileURL: NSURL): void;
  fileModificationDate(): NSDate;
  setFileModificationDate(fileModificationDate: NSDate): void;
  draft(): boolean;
  setDraft(draft: boolean): void;
  entireFileLoaded(): boolean;
  autosavingIsImplicitlyCancellable(): boolean;
  keepBackupFile(): boolean;
  backupFileURL(): NSURL;
  shouldRunSavePanelWithAccessoryView(): boolean;
  fileNameExtensionWasHiddenInLastRunSavePanel(): boolean;
  fileTypeFromLastRunSavePanel(): NSString;
  hasUnautosavedChanges(): boolean;
  browsingVersions(): boolean;
  autosavingFileType(): NSString;
  autosavedContentsFileURL(): NSURL;
  setAutosavedContentsFileURL(autosavedContentsFileURL: NSURL): void;
  locked(): boolean;
  printInfo(): NSPrintInfo;
  setPrintInfo(printInfo: NSPrintInfo): void;
  PDFPrintOperation(): NSPrintOperation;
  allowsDocumentSharing(): boolean;
  documentEdited(): boolean;
  inViewingMode(): boolean;
  undoManager(): NSUndoManager;
  setUndoManager(undoManager: NSUndoManager): void;
  hasUndoManager(): boolean;
  setHasUndoManager(hasUndoManager: boolean): void;
  windowNibName(): NSNibName;
  windowControllers(): NSArray<any>;
  displayName(): NSString;
  setDisplayName(displayName: NSString | string): void;
  windowForSheet(): NSWindow;
  lastComponentOfFileName(): NSString;
  setLastComponentOfFileName(lastComponentOfFileName: NSString | string): void;
  objectSpecifier(): NSScriptObjectSpecifier;
  userActivity(): NSUserActivity;
  setUserActivity(userActivity: NSUserActivity): void;
}
declare const NSDocument: {
  alloc(): NSDocumentAllocator;  canConcurrentlyReadDocumentsOfType(typeName: NSString | string): boolean;
  isNativeType(type: NSString | string): boolean;

  autosavesInPlace(): boolean;
  preservesVersions(): boolean;
  autosavesDrafts(): boolean;
  readableTypes(): NSArray<any>;
  writableTypes(): NSArray<any>;
  usesUbiquitousStorage(): boolean;
  restorableStateKeyPaths(): NSArray<any>;

}

declare enum NSDocumentChangeType {
  NSChangeDone = 0,
  NSChangeUndone = 1,
  NSChangeRedone = 5,
  NSChangeCleared = 2,
  NSChangeReadOtherContents = 3,
  NSChangeAutosaved = 4,
  NSChangeDiscardable = 256,
}

declare enum NSSaveOperationType {
  NSSaveOperation = 0,
  NSSaveAsOperation = 1,
  NSSaveToOperation = 2,
  NSAutosaveInPlaceOperation = 4,
  NSAutosaveElsewhereOperation = 3,
  NSAutosaveAsOperation = 5,
  NSAutosaveOperation = 3,
}

interface NSDocumentControllerAllocator<InitializedType = NSDocumentController> extends NSObjectAllocator<NSDocumentController> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSDocumentController extends NSObject, INSCoding, INSUserInterfaceValidations {
  documentForURL(url: NSURL): NSDocument;
  documentForWindow(window: NSWindow): NSDocument;
  addDocument(document: NSDocument): void;
  removeDocument(document: NSDocument): void;
  newDocument(sender: any | null): IBAction;
  openUntitledDocumentAndDisplay_error(displayDocument: boolean, outError: NSError): NSDocument;
  makeUntitledDocumentOfType_error(typeName: NSString | string, outError: NSError): NSDocument;
  openDocument(sender: any | null): IBAction;
  URLsFromRunningOpenPanel(): NSArray<any>;
  runModalOpenPanel_forTypes(openPanel: NSOpenPanel, types: NSArray<any> | any[] | null): NSInteger;
  beginOpenPanelWithCompletionHandler(completionHandler: Block): void;
  beginOpenPanel_forTypes_completionHandler(openPanel: NSOpenPanel, inTypes: NSArray<any> | any[] | null, completionHandler: Block): void;
  openDocumentWithContentsOfURL_display_completionHandler(url: NSURL, displayDocument: boolean, completionHandler: Block): void;
  makeDocumentWithContentsOfURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): NSDocument;
  reopenDocumentForURL_withContentsOfURL_display_completionHandler(urlOrNil: NSURL | null, contentsURL: NSURL, displayDocument: boolean, completionHandler: Block): void;
  makeDocumentForURL_withContentsOfURL_ofType_error(urlOrNil: NSURL | null, contentsURL: NSURL, typeName: NSString | string, outError: NSError): NSDocument;
  saveAllDocuments(sender: any | null): IBAction;
  reviewUnsavedDocumentsWithAlertTitle_cancellable_delegate_didReviewAllSelector_contextInfo(title: NSString | string | null, cancellable: boolean, delegate: any | null, didReviewAllSelector: string | null, contextInfo: void | null): void;
  closeAllDocumentsWithDelegate_didCloseAllSelector_contextInfo(delegate: any | null, didCloseAllSelector: string | null, contextInfo: void | null): void;
  duplicateDocumentWithContentsOfURL_copying_displayName_error(url: NSURL, duplicateByCopying: boolean, displayNameOrNil: NSString | string | null, outError: NSError): NSDocument;
  standardShareMenuItem(): NSMenuItem;
  presentError_modalForWindow_delegate_didPresentSelector_contextInfo(error: NSError, window: NSWindow, delegate: any | null, didPresentSelector: string | null, contextInfo: void | null): void;
  presentError(error: NSError): boolean;
  willPresentError(error: NSError): NSError;
  clearRecentDocuments(sender: any | null): IBAction;
  noteNewRecentDocument(document: NSDocument): void;
  noteNewRecentDocumentURL(url: NSURL): void;
  typeForContentsOfURL_error(url: NSURL, outError: NSError): NSString;
  documentClassForType(typeName: NSString | string): any;
  displayNameForType(typeName: NSString | string): NSString;
  validateUserInterfaceItem(item: any): boolean;
  openDocumentWithContentsOfURL_display_error(url: NSURL, displayDocument: boolean, outError: NSError): any;
  reopenDocumentForURL_withContentsOfURL_error(url: NSURL | null, contentsURL: NSURL, outError: NSError): boolean;
  fileExtensionsFromType(typeName: NSString | string): NSArray<any>;
  typeFromFileExtension(fileNameExtensionOrHFSFileType: NSString | string): NSString;
  documentForFileName(fileName: NSString | string): any;
  fileNamesFromRunningOpenPanel(): NSArray<any>;
  makeDocumentWithContentsOfFile_ofType(fileName: NSString | string, type: NSString | string): any;
  makeDocumentWithContentsOfURL_ofType(url: NSURL, type: NSString | string): any;
  makeUntitledDocumentOfType(type: NSString | string): any;
  openDocumentWithContentsOfFile_display(fileName: NSString | string, display: boolean): any;
  openDocumentWithContentsOfURL_display(url: NSURL, display: boolean): any;
  openUntitledDocumentOfType_display(type: NSString | string, display: boolean): any;
  setShouldCreateUI(flag: boolean): void;
  shouldCreateUI(): boolean;

  documents(): NSArray<any>;
  currentDocument(): NSDocument;
  currentDirectory(): NSString;
  autosavingDelay(): NSTimeInterval;
  setAutosavingDelay(autosavingDelay: NSTimeInterval): void;
  hasEditedDocuments(): boolean;
  allowsAutomaticShareMenu(): boolean;
  maximumRecentDocumentCount(): NSUInteger;
  recentDocumentURLs(): NSArray<any>;
  defaultType(): NSString;
  documentClassNames(): NSArray<any>;
}
declare const NSDocumentController: {
  alloc(): NSDocumentControllerAllocator;  enumerateOpenDocuments(block: MSDocumentIteratorBlock): void;

  sharedDocumentController(): NSDocumentController;

}

interface INSDraggingDestination {
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
}

interface INSDraggingSource {
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
}

interface INSSpringLoadingDestination {
  springLoadingActivated_draggingInfo(activated: boolean, draggingInfo: any): void;
  springLoadingHighlightChanged(draggingInfo: any): void;
  springLoadingEntered(draggingInfo: any): NSSpringLoadingOptions;
  springLoadingUpdated(draggingInfo: any): NSSpringLoadingOptions;
  springLoadingExited(draggingInfo: any): void;
  draggingEnded(draggingInfo: any): void;
}

declare enum NSDragOperation {
  NSDragOperationNone = 0,
  NSDragOperationCopy = 1,
  NSDragOperationLink = 2,
  NSDragOperationGeneric = 4,
  NSDragOperationPrivate = 8,
  NSDragOperationMove = 16,
  NSDragOperationDelete = 32,
  NSDragOperationEvery,
  NSDragOperationAll_Obsolete = 15,
  NSDragOperationAll,
}

declare enum NSDraggingFormation {
  NSDraggingFormationDefault = 0,
  NSDraggingFormationNone,
  NSDraggingFormationPile,
  NSDraggingFormationList,
  NSDraggingFormationStack,
}

declare enum NSDraggingContext {
  NSDraggingContextOutsideApplication = 0,
  NSDraggingContextWithinApplication,
}

declare enum NSDraggingItemEnumerationOptions {
  NSDraggingItemEnumerationConcurrent,
  NSDraggingItemEnumerationClearNonenumeratedImages,
}

declare enum NSSpringLoadingHighlight {
  NSSpringLoadingHighlightNone = 0,
  NSSpringLoadingHighlightStandard,
  NSSpringLoadingHighlightEmphasized,
}

declare enum NSSpringLoadingOptions {
  NSSpringLoadingDisabled = 0,
  NSSpringLoadingEnabled = 1 << 0,
  NSSpringLoadingContinuousActivation = 1 << 1,
  NSSpringLoadingNoHover = 1 << 3,
}

interface NSDraggingImageComponentAllocator<InitializedType = NSDraggingImageComponent> extends NSObjectAllocator<NSDraggingImageComponent> {
  initWithKey(key: NSDraggingImageComponentKey): InitializedType;
}
interface NSDraggingImageComponent extends NSObject {

  key(): NSDraggingImageComponentKey;
  setKey(key: NSDraggingImageComponentKey): void;
  contents(): any;
  setContents(contents: any): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
}
declare const NSDraggingImageComponent: {
  alloc(): NSDraggingImageComponentAllocator;  draggingImageComponentWithKey(key: NSDraggingImageComponentKey): NSDraggingImageComponent;

}

interface NSDraggingItemAllocator<InitializedType = NSDraggingItem> extends NSObjectAllocator<NSDraggingItem> {
  initWithPasteboardWriter(pasteboardWriter: any): InitializedType;
}
interface NSDraggingItem extends NSObject {
  setDraggingFrame_contents(frame: NSRect, contents: any | null): void;

  item(): any;
  draggingFrame(): NSRect;
  setDraggingFrame(draggingFrame: NSRect): void;
  imageComponents(): NSArray<any>;
}
declare const NSDraggingItem: {
  alloc(): NSDraggingItemAllocator;
}

declare type NSDraggingImageComponentKey = NSString

interface NSDraggingSessionAllocator<InitializedType = NSDraggingSession> extends NSObjectAllocator<NSDraggingSession> {}
interface NSDraggingSession extends NSObject {
  enumerateDraggingItemsWithOptions_forView_classes_searchOptions_usingBlock(enumOpts: NSDraggingItemEnumerationOptions, view: NSView | null, classArray: NSArray<any> | any[], searchOptions: NSDictionary<any, any> | {[key: string]: any}, block: Block): void;

  draggingFormation(): NSDraggingFormation;
  setDraggingFormation(draggingFormation: NSDraggingFormation): void;
  animatesToStartingPositionsOnCancelOrFail(): boolean;
  setAnimatesToStartingPositionsOnCancelOrFail(animatesToStartingPositionsOnCancelOrFail: boolean): void;
  draggingLeaderIndex(): NSInteger;
  setDraggingLeaderIndex(draggingLeaderIndex: NSInteger): void;
  draggingPasteboard(): NSPasteboard;
  draggingSequenceNumber(): NSInteger;
  draggingLocation(): NSPoint;
}
declare const NSDraggingSession: {
  alloc(): NSDraggingSessionAllocator;
}

interface NSDrawerAllocator<InitializedType = NSDrawer> extends NSResponderAllocator<NSDrawer> {
  initWithContentSize_preferredEdge(contentSize: NSSize, edge: NSRectEdge): InitializedType;
}
interface NSDrawer extends NSResponder, INSAccessibilityElement, INSAccessibility {
  open(): void;
  openOnEdge(edge: NSRectEdge): void;
  close(): void;
  open(sender: any | null): void;
  close(sender: any | null): void;
  toggle(sender: any | null): void;

  parentWindow(): NSWindow;
  setParentWindow(parentWindow: NSWindow): void;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  state(): NSInteger;
  edge(): NSRectEdge;
  contentSize(): NSSize;
  setContentSize(contentSize: NSSize): void;
  minContentSize(): NSSize;
  setMinContentSize(minContentSize: NSSize): void;
  maxContentSize(): NSSize;
  setMaxContentSize(maxContentSize: NSSize): void;
  leadingOffset(): CGFloat;
  setLeadingOffset(leadingOffset: CGFloat): void;
  trailingOffset(): CGFloat;
  setTrailingOffset(trailingOffset: CGFloat): void;
}
declare const NSDrawer: {
  alloc(): NSDrawerAllocator;
}

interface NSWindowAllocator<InitializedType = NSWindow> extends NSResponderAllocator<NSWindow> {
  initWithContentRect_styleMask_backing_defer(contentRect: NSRect, style: NSWindowStyleMask, backingStoreType: NSBackingStoreType, flag: boolean): InitializedType;
  initWithContentRect_styleMask_backing_defer_screen(contentRect: NSRect, style: NSWindowStyleMask, backingStoreType: NSBackingStoreType, flag: boolean, screen: NSScreen | null): InitializedType;
  initWithWindowRef(windowRef: void): InitializedType;
}
interface NSWindow extends NSResponder, INSAnimatablePropertyContainer, INSUserInterfaceValidations, INSUserInterfaceItemIdentification, INSAppearanceCustomization, INSAccessibilityElement, INSAccessibility {
  updateConstraintsIfNeeded(): void;
  layoutIfNeeded(): void;
  anchorAttributeForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutAttribute;
  setAnchorAttribute_forOrientation(attr: NSLayoutAttribute, orientation: NSLayoutConstraintOrientation): void;
  visualizeConstraints(constraints: NSArray<any> | any[] | null): void;
  frameRectForContentRect(contentRect: NSRect): NSRect;
  contentRectForFrameRect(frameRect: NSRect): NSRect;
  addTitlebarAccessoryViewController(childViewController: NSTitlebarAccessoryViewController): void;
  insertTitlebarAccessoryViewController_atIndex(childViewController: NSTitlebarAccessoryViewController, index: NSInteger): void;
  removeTitlebarAccessoryViewControllerAtIndex(index: NSInteger): void;
  setTitleWithRepresentedFilename(filename: NSString | string): void;
  fieldEditor_forObject(createFlag: boolean, object: any | null): NSText;
  endEditingFor(object: any | null): void;
  constrainFrameRect_toScreen(frameRect: NSRect, screen: NSScreen | null): NSRect;
  setFrame_display(frameRect: NSRect, flag: boolean): void;
  setContentSize(size: NSSize): void;
  setFrameOrigin(point: NSPoint): void;
  setFrameTopLeftPoint(point: NSPoint): void;
  cascadeTopLeftFromPoint(topLeftPoint: NSPoint): NSPoint;
  animationResizeTime(newFrame: NSRect): NSTimeInterval;
  setFrame_display_animate(frameRect: NSRect, displayFlag: boolean, animateFlag: boolean): void;
  disableFlushWindow(): void;
  enableFlushWindow(): void;
  flushWindow(): void;
  flushWindowIfNeeded(): void;
  displayIfNeeded(): void;
  display(): void;
  update(): void;
  makeFirstResponder(responder: NSResponder | null): boolean;
  keyDown(event: NSEvent): void;
  close(): void;
  miniaturize(sender: any | null): void;
  deminiaturize(sender: any | null): void;
  zoom(sender: any | null): void;
  tryToPerform_with(action: string, object: any | null): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  setContentBorderThickness_forEdge(thickness: CGFloat, edge: NSRectEdge): void;
  contentBorderThicknessForEdge(edge: NSRectEdge): CGFloat;
  setAutorecalculatesContentBorderThickness_forEdge(flag: boolean, edge: NSRectEdge): void;
  autorecalculatesContentBorderThicknessForEdge(edge: NSRectEdge): boolean;
  center(): void;
  makeKeyAndOrderFront(sender: any | null): void;
  orderFront(sender: any | null): void;
  orderBack(sender: any | null): void;
  orderOut(sender: any | null): void;
  orderWindow_relativeTo(place: NSWindowOrderingMode, otherWin: NSInteger): void;
  orderFrontRegardless(): void;
  makeKeyWindow(): void;
  makeMainWindow(): void;
  becomeKeyWindow(): void;
  resignKeyWindow(): void;
  becomeMainWindow(): void;
  resignMainWindow(): void;
  convertRectToScreen(rect: NSRect): NSRect;
  convertRectFromScreen(rect: NSRect): NSRect;
  convertRectToBacking(rect: NSRect): NSRect;
  convertRectFromBacking(rect: NSRect): NSRect;
  backingAlignedRect_options(rect: NSRect, options: NSAlignmentOptions): NSRect;
  performClose(sender: any | null): void;
  performMiniaturize(sender: any | null): void;
  performZoom(sender: any | null): void;
  dataWithEPSInsideRect(rect: NSRect): NSData;
  dataWithPDFInsideRect(rect: NSRect): NSData;
  print(sender: any | null): void;
  setDynamicDepthLimit(flag: boolean): void;
  invalidateShadow(): void;
  disableScreenUpdatesUntilFlush(): void;
  toggleFullScreen(sender: any | null): void;
  setFrameFromString(string: NSString | string): void;
  saveFrameUsingName(name: NSWindowFrameAutosaveName): void;
  setFrameUsingName_force(name: NSWindowFrameAutosaveName, force: boolean): boolean;
  setFrameUsingName(name: NSWindowFrameAutosaveName): boolean;
  setFrameAutosaveName(name: NSWindowFrameAutosaveName): boolean;
  beginSheet_completionHandler(sheetWindow: NSWindow, handler: Block): void;
  beginCriticalSheet_completionHandler(sheetWindow: NSWindow, handler: Block): void;
  endSheet(sheetWindow: NSWindow): void;
  endSheet_returnCode(sheetWindow: NSWindow, returnCode: NSModalResponse): void;
  standardWindowButton(b: NSWindowButton): NSButton;
  addChildWindow_ordered(childWin: NSWindow, place: NSWindowOrderingMode): void;
  removeChildWindow(childWin: NSWindow): void;
  canRepresentDisplayGamut(displayGamut: NSDisplayGamut): boolean;
  performWindowDragWithEvent(event: NSEvent): void;
  selectNextKeyView(sender: any | null): void;
  selectPreviousKeyView(sender: any | null): void;
  selectKeyViewFollowingView(view: NSView): void;
  selectKeyViewPrecedingView(view: NSView): void;
  disableKeyEquivalentForDefaultButtonCell(): void;
  enableKeyEquivalentForDefaultButtonCell(): void;
  recalculateKeyViewLoop(): void;
  toggleToolbarShown(sender: any | null): void;
  runToolbarCustomizationPalette(sender: any | null): void;
  selectNextTab(sender: any | null): IBAction;
  selectPreviousTab(sender: any | null): IBAction;
  moveTabToNewWindow(sender: any | null): IBAction;
  mergeAllWindows(sender: any | null): IBAction;
  toggleTabBar(sender: any | null): IBAction;
  toggleTabOverview(sender: any | null): IBAction;
  addTabbedWindow_ordered(window: NSWindow, ordered: NSWindowOrderingMode): void;
  trackEventsMatchingMask_timeout_mode_handler(mask: NSEventMask, timeout: NSTimeInterval, mode: NSRunLoopMode, trackingHandler: Block): void;
  nextEventMatchingMask(mask: NSUInteger): NSEvent;
  nextEventMatchingMask_untilDate_inMode_dequeue(mask: NSUInteger, expiration: NSDate | null, mode: NSRunLoopMode, deqFlag: boolean): NSEvent;
  discardEventsMatchingMask_beforeEvent(mask: NSUInteger, lastEvent: NSEvent | null): void;
  postEvent_atStart(event: NSEvent, flag: boolean): void;
  sendEvent(event: NSEvent): void;
  disableCursorRects(): void;
  enableCursorRects(): void;
  discardCursorRects(): void;
  invalidateCursorRectsForView(view: NSView): void;
  resetCursorRects(): void;
  dragImage_at_offset_event_pasteboard_source_slideBack(image: NSImage, baseLocation: NSPoint, initialOffset: NSSize, event: NSEvent, pboard: NSPasteboard, sourceObj: any, slideFlag: boolean): void;
  registerForDraggedTypes(newTypes: NSArray<any> | any[]): void;
  unregisterDraggedTypes(): void;
  cacheImageInRect(rect: NSRect): void;
  restoreCachedImage(): void;
  discardCachedImage(): void;
  gState(): NSInteger;
  convertBaseToScreen(point: NSPoint): NSPoint;
  convertScreenToBase(point: NSPoint): NSPoint;
  userSpaceScaleFactor(): CGFloat;
  useOptimizedDrawing(flag: boolean): void;
  canStoreColor(): boolean;
  disableSnapshotRestoration(): void;
  enableSnapshotRestoration(): void;
  setIsMiniaturized(flag: boolean): void;
  setIsVisible(flag: boolean): void;
  setIsZoomed(flag: boolean): void;
  handleCloseScriptCommand(command: NSCloseCommand): any;
  handlePrintScriptCommand(command: NSScriptCommand): any;
  handleSaveScriptCommand(command: NSScriptCommand): any;
  convertPointFromScreen_ch(point: NSPoint): NSPoint;
  closePopovers(): boolean;
  commitEditedTextRetainingFirstResponder(): void;

  drawers(): NSArray<any>;
  title(): NSString;
  setTitle(title: NSString | string): void;
  titleVisibility(): NSWindowTitleVisibility;
  setTitleVisibility(titleVisibility: NSWindowTitleVisibility): void;
  titlebarAppearsTransparent(): boolean;
  setTitlebarAppearsTransparent(titlebarAppearsTransparent: boolean): void;
  contentLayoutRect(): NSRect;
  contentLayoutGuide(): any;
  titlebarAccessoryViewControllers(): NSArray<any>;
  setTitlebarAccessoryViewControllers(titlebarAccessoryViewControllers: NSArray<any> | any[]): void;
  representedURL(): NSURL;
  setRepresentedURL(representedURL: NSURL): void;
  representedFilename(): NSString;
  setRepresentedFilename(representedFilename: NSString | string): void;
  excludedFromWindowsMenu(): boolean;
  setExcludedFromWindowsMenu(excludedFromWindowsMenu: boolean): void;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  windowNumber(): NSInteger;
  styleMask(): NSWindowStyleMask;
  setStyleMask(styleMask: NSWindowStyleMask): void;
  frame(): NSRect;
  inLiveResize(): boolean;
  showsResizeIndicator(): boolean;
  setShowsResizeIndicator(showsResizeIndicator: boolean): void;
  resizeIncrements(): NSSize;
  setResizeIncrements(resizeIncrements: NSSize): void;
  aspectRatio(): NSSize;
  setAspectRatio(aspectRatio: NSSize): void;
  contentResizeIncrements(): NSSize;
  setContentResizeIncrements(contentResizeIncrements: NSSize): void;
  contentAspectRatio(): NSSize;
  setContentAspectRatio(contentAspectRatio: NSSize): void;
  flushWindowDisabled(): boolean;
  viewsNeedDisplay(): boolean;
  setViewsNeedDisplay(viewsNeedDisplay: boolean): void;
  autodisplay(): boolean;
  setAutodisplay(autodisplay: boolean): void;
  preservesContentDuringLiveResize(): boolean;
  setPreservesContentDuringLiveResize(preservesContentDuringLiveResize: boolean): void;
  firstResponder(): NSResponder;
  resizeFlags(): NSEventModifierFlags;
  releasedWhenClosed(): boolean;
  setReleasedWhenClosed(releasedWhenClosed: boolean): void;
  zoomed(): boolean;
  miniaturized(): boolean;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  movable(): boolean;
  setMovable(movable: boolean): void;
  movableByWindowBackground(): boolean;
  setMovableByWindowBackground(movableByWindowBackground: boolean): void;
  hidesOnDeactivate(): boolean;
  setHidesOnDeactivate(hidesOnDeactivate: boolean): void;
  canHide(): boolean;
  setCanHide(canHide: boolean): void;
  miniwindowImage(): NSImage;
  setMiniwindowImage(miniwindowImage: NSImage): void;
  miniwindowTitle(): NSString;
  setMiniwindowTitle(miniwindowTitle: NSString | string): void;
  dockTile(): NSDockTile;
  documentEdited(): boolean;
  setDocumentEdited(documentEdited: boolean): void;
  visible(): boolean;
  keyWindow(): boolean;
  mainWindow(): boolean;
  canBecomeKeyWindow(): boolean;
  canBecomeMainWindow(): boolean;
  worksWhenModal(): boolean;
  preventsApplicationTerminationWhenModal(): boolean;
  setPreventsApplicationTerminationWhenModal(preventsApplicationTerminationWhenModal: boolean): void;
  backingScaleFactor(): CGFloat;
  oneShot(): boolean;
  setOneShot(oneShot: boolean): void;
  allowsToolTipsWhenApplicationIsInactive(): boolean;
  setAllowsToolTipsWhenApplicationIsInactive(allowsToolTipsWhenApplicationIsInactive: boolean): void;
  backingType(): NSBackingStoreType;
  setBackingType(backingType: NSBackingStoreType): void;
  level(): NSWindowLevel;
  setLevel(level: NSWindowLevel): void;
  depthLimit(): NSWindowDepth;
  setDepthLimit(depthLimit: NSWindowDepth): void;
  hasDynamicDepthLimit(): boolean;
  screen(): NSScreen;
  deepestScreen(): NSScreen;
  hasShadow(): boolean;
  setHasShadow(hasShadow: boolean): void;
  alphaValue(): CGFloat;
  setAlphaValue(alphaValue: CGFloat): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
  sharingType(): NSWindowSharingType;
  setSharingType(sharingType: NSWindowSharingType): void;
  preferredBackingLocation(): NSWindowBackingLocation;
  setPreferredBackingLocation(preferredBackingLocation: NSWindowBackingLocation): void;
  backingLocation(): NSWindowBackingLocation;
  allowsConcurrentViewDrawing(): boolean;
  setAllowsConcurrentViewDrawing(allowsConcurrentViewDrawing: boolean): void;
  displaysWhenScreenProfileChanges(): boolean;
  setDisplaysWhenScreenProfileChanges(displaysWhenScreenProfileChanges: boolean): void;
  canBecomeVisibleWithoutLogin(): boolean;
  setCanBecomeVisibleWithoutLogin(canBecomeVisibleWithoutLogin: boolean): void;
  collectionBehavior(): NSWindowCollectionBehavior;
  setCollectionBehavior(collectionBehavior: NSWindowCollectionBehavior): void;
  animationBehavior(): NSWindowAnimationBehavior;
  setAnimationBehavior(animationBehavior: NSWindowAnimationBehavior): void;
  onActiveSpace(): boolean;
  stringWithSavedFrame(): NSString;
  frameAutosaveName(): NSWindowFrameAutosaveName;
  minSize(): NSSize;
  setMinSize(minSize: NSSize): void;
  maxSize(): NSSize;
  setMaxSize(maxSize: NSSize): void;
  contentMinSize(): NSSize;
  setContentMinSize(contentMinSize: NSSize): void;
  contentMaxSize(): NSSize;
  setContentMaxSize(contentMaxSize: NSSize): void;
  minFullScreenContentSize(): NSSize;
  setMinFullScreenContentSize(minFullScreenContentSize: NSSize): void;
  maxFullScreenContentSize(): NSSize;
  setMaxFullScreenContentSize(maxFullScreenContentSize: NSSize): void;
  deviceDescription(): NSDictionary<any, any>;
  windowController(): NSWindowController;
  setWindowController(windowController: NSWindowController): void;
  sheets(): NSArray<any>;
  attachedSheet(): NSWindow;
  sheet(): boolean;
  sheetParent(): NSWindow;
  childWindows(): NSArray<any>;
  parentWindow(): NSWindow;
  setParentWindow(parentWindow: NSWindow): void;
  graphicsContext(): NSGraphicsContext;
  colorSpace(): NSColorSpace;
  setColorSpace(colorSpace: NSColorSpace): void;
  occlusionState(): NSWindowOcclusionState;
  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  initialFirstResponder(): NSView;
  setInitialFirstResponder(initialFirstResponder: NSView): void;
  keyViewSelectionDirection(): NSSelectionDirection;
  defaultButtonCell(): NSButtonCell;
  setDefaultButtonCell(defaultButtonCell: NSButtonCell): void;
  autorecalculatesKeyViewLoop(): boolean;
  setAutorecalculatesKeyViewLoop(autorecalculatesKeyViewLoop: boolean): void;
  toolbar(): NSToolbar;
  setToolbar(toolbar: NSToolbar): void;
  showsToolbarButton(): boolean;
  setShowsToolbarButton(showsToolbarButton: boolean): void;
  tabbingMode(): NSWindowTabbingMode;
  setTabbingMode(tabbingMode: NSWindowTabbingMode): void;
  tabbingIdentifier(): NSWindowTabbingIdentifier;
  setTabbingIdentifier(tabbingIdentifier: NSWindowTabbingIdentifier): void;
  tabbedWindows(): NSArray<any>;
  tab(): NSWindowTab;
  tabGroup(): NSWindowTabGroup;
  windowTitlebarLayoutDirection(): NSUserInterfaceLayoutDirection;
  currentEvent(): NSEvent;
  acceptsMouseMovedEvents(): boolean;
  setAcceptsMouseMovedEvents(acceptsMouseMovedEvents: boolean): void;
  ignoresMouseEvents(): boolean;
  setIgnoresMouseEvents(ignoresMouseEvents: boolean): void;
  mouseLocationOutsideOfEventStream(): NSPoint;
  areCursorRectsEnabled(): boolean;
  windowRef(): void;
  restorable(): boolean;
  setRestorable(restorable: boolean): void;
  restorationClass(): any;
  setRestorationClass(restorationClass: any): void;
  hasCloseBox(): boolean;
  hasTitleBar(): boolean;
  floatingPanel(): boolean;
  miniaturizable(): boolean;
  modalPanel(): boolean;
  resizable(): boolean;
  zoomable(): boolean;
  orderedIndex(): NSInteger;
  setOrderedIndex(orderedIndex: NSInteger): void;
}
declare const NSWindow: {
  alloc(): NSWindowAllocator;  frameRectForContentRect_styleMask(cRect: NSRect, style: NSWindowStyleMask): NSRect;
  contentRectForFrameRect_styleMask(fRect: NSRect, style: NSWindowStyleMask): NSRect;
  minFrameWidthWithTitle_styleMask(title: NSString | string, style: NSWindowStyleMask): CGFloat;
  removeFrameUsingName(name: NSWindowFrameAutosaveName): void;
  standardWindowButton_forStyleMask(b: NSWindowButton, styleMask: NSWindowStyleMask): NSButton;
  windowNumbersWithOptions(options: NSWindowNumberListOptions): NSArray<any>;
  windowNumberAtPoint_belowWindowWithWindowNumber(point: NSPoint, windowNumber: NSInteger): NSInteger;
  windowWithContentViewController(contentViewController: NSViewController): NSWindow;
  menuChanged(menu: NSMenu): void;

  defaultDepthLimit(): NSWindowDepth;
  allowsAutomaticWindowTabbing(): boolean;
  setAllowsAutomaticWindowTabbing(allowsAutomaticWindowTabbing: boolean): void;
  userTabbingPreference(): NSWindowUserTabbingPreference;

}

interface INSDrawerDelegate {
  drawerShouldOpen(sender: NSDrawer): boolean;
  drawerShouldClose(sender: NSDrawer): boolean;
  drawerWillResizeContents_toSize(sender: NSDrawer, contentSize: NSSize): NSSize;
  drawerWillOpen(notification: NSNotification): void;
  drawerDidOpen(notification: NSNotification): void;
  drawerWillClose(notification: NSNotification): void;
  drawerDidClose(notification: NSNotification): void;
}

declare enum NSDrawerState {
  NSDrawerClosedState = 0,
  NSDrawerOpeningState = 1,
  NSDrawerOpenState = 2,
  NSDrawerClosingState = 3,
}

interface NSEPSImageRepAllocator<InitializedType = NSEPSImageRep> extends NSImageRepAllocator<NSEPSImageRep> {
  initWithData(epsData: NSData): InitializedType;
}
interface NSEPSImageRep extends NSImageRep {
  prepareGState(): void;
  PDFRepresentation_ms(): NSData;

  EPSRepresentation(): NSData;
  boundingBox(): NSRect;
}
declare const NSEPSImageRep: {
  alloc(): NSEPSImageRepAllocator;  imageRepWithData(epsData: NSData): NSEPSImageRep;

}

interface NSEventAllocator<InitializedType = NSEvent> extends NSObjectAllocator<NSEvent> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSEvent extends NSObject, INSCopying, INSCoding {
  touchesMatchingPhase_inView(phase: NSTouchPhase, view: NSView | null): NSSet<any>;
  allTouches(): NSSet<any>;
  touchesForView(view: NSView): NSSet<any>;
  coalescedTouchesForTouch(touch: NSTouch): NSArray<any>;
  trackSwipeEventWithOptions_dampenAmountThresholdMin_max_usingHandler(options: NSEventSwipeTrackingOptions, minDampenThreshold: CGFloat, maxDampenThreshold: CGFloat, trackingHandler: Block): void;
  shouldStartDrag(): boolean;
  isDoubleClick(): boolean;
  isRightClick(): boolean;

  type(): NSEventType;
  timestamp(): NSTimeInterval;
  window(): NSWindow;
  windowNumber(): NSInteger;
  context(): NSGraphicsContext;
  clickCount(): NSInteger;
  buttonNumber(): NSInteger;
  eventNumber(): NSInteger;
  pressure(): number;
  locationInWindow(): NSPoint;
  deltaX(): CGFloat;
  deltaY(): CGFloat;
  deltaZ(): CGFloat;
  hasPreciseScrollingDeltas(): boolean;
  scrollingDeltaX(): CGFloat;
  scrollingDeltaY(): CGFloat;
  momentumPhase(): NSEventPhase;
  directionInvertedFromDevice(): boolean;
  characters(): NSString;
  charactersIgnoringModifiers(): NSString;
  ARepeat(): boolean;
  keyCode(): number;
  trackingNumber(): NSInteger;
  userData(): void;
  trackingArea(): NSTrackingArea;
  subtype(): NSEventSubtype;
  data1(): NSInteger;
  data2(): NSInteger;
  eventRef(): void;
  CGEvent(): CGEventRef;
  magnification(): CGFloat;
  deviceID(): NSUInteger;
  rotation(): number;
  absoluteX(): NSInteger;
  absoluteY(): NSInteger;
  absoluteZ(): NSInteger;
  buttonMask(): NSEventButtonMask;
  tilt(): NSPoint;
  tangentialPressure(): number;
  vendorDefined(): any;
  vendorID(): NSUInteger;
  tabletID(): NSUInteger;
  pointingDeviceID(): NSUInteger;
  systemTabletID(): NSUInteger;
  vendorPointingDeviceType(): NSUInteger;
  pointingDeviceSerialNumber(): NSUInteger;
  uniqueID(): number;
  capabilityMask(): NSUInteger;
  pointingDeviceType(): NSPointingDeviceType;
  enteringProximity(): boolean;
  phase(): NSEventPhase;
  stage(): NSInteger;
  stageTransition(): CGFloat;
  associatedEventsMask(): NSEventMask;
  pressureBehavior(): NSPressureBehavior;
}
declare const NSEvent: {
  alloc(): NSEventAllocator;  eventWithEventRef(eventRef: void): NSEvent;
  eventWithCGEvent(cgEvent: CGEventRef): NSEvent;
  startPeriodicEventsAfterDelay_withPeriod(delay: NSTimeInterval, period: NSTimeInterval): void;
  stopPeriodicEvents(): void;
  mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, eNum: NSInteger, cNum: NSInteger, pressure: number): NSEvent;
  keyEventWithType_location_modifierFlags_timestamp_windowNumber_context_characters_charactersIgnoringModifiers_isARepeat_keyCode(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, keys: NSString | string, ukeys: NSString | string, flag: boolean, code: number): NSEvent;
  enterExitEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_trackingNumber_userData(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, eNum: NSInteger, tNum: NSInteger, data: void | null): NSEvent;
  otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, subtype: number, d1: NSInteger, d2: NSInteger): NSEvent;
  addGlobalMonitorForEventsMatchingMask_handler(mask: NSEventMask, block: Block): any;
  addLocalMonitorForEventsMatchingMask_handler(mask: NSEventMask, block: Block): any;
  removeMonitor(eventMonitor: any): void;

  modifierFlags(): NSEventModifierFlags;
  mouseCoalescingEnabled(): boolean;
  setMouseCoalescingEnabled(mouseCoalescingEnabled: boolean): void;
  swipeTrackingFromScrollEventsEnabled(): boolean;
  mouseLocation(): NSPoint;
  pressedMouseButtons(): NSUInteger;
  doubleClickInterval(): NSTimeInterval;
  keyRepeatDelay(): NSTimeInterval;
  keyRepeatInterval(): NSTimeInterval;

}

declare enum NSEventType {
  NSEventTypeLeftMouseDown = 1,
  NSEventTypeLeftMouseUp = 2,
  NSEventTypeRightMouseDown = 3,
  NSEventTypeRightMouseUp = 4,
  NSEventTypeMouseMoved = 5,
  NSEventTypeLeftMouseDragged = 6,
  NSEventTypeRightMouseDragged = 7,
  NSEventTypeMouseEntered = 8,
  NSEventTypeMouseExited = 9,
  NSEventTypeKeyDown = 10,
  NSEventTypeKeyUp = 11,
  NSEventTypeFlagsChanged = 12,
  NSEventTypeAppKitDefined = 13,
  NSEventTypeSystemDefined = 14,
  NSEventTypeApplicationDefined = 15,
  NSEventTypePeriodic = 16,
  NSEventTypeCursorUpdate = 17,
  NSEventTypeScrollWheel = 22,
  NSEventTypeTabletPoint = 23,
  NSEventTypeTabletProximity = 24,
  NSEventTypeOtherMouseDown = 25,
  NSEventTypeOtherMouseUp = 26,
  NSEventTypeOtherMouseDragged = 27,
  NSEventTypeGesture = 29,
  NSEventTypeMagnify = 30,
  NSEventTypeSwipe = 31,
  NSEventTypeRotate = 18,
  NSEventTypeBeginGesture = 19,
  NSEventTypeEndGesture = 20,
  NSEventTypeSmartMagnify = 32,
  NSEventTypeQuickLook = 33,
  NSEventTypePressure = 34,
  NSEventTypeDirectTouch = 37,
}

declare enum NSEventMask {
  NSEventMaskLeftMouseDown = 1 << NSEventType.NSEventTypeLeftMouseDown,
  NSEventMaskLeftMouseUp = 1 << NSEventType.NSEventTypeLeftMouseUp,
  NSEventMaskRightMouseDown = 1 << NSEventType.NSEventTypeRightMouseDown,
  NSEventMaskRightMouseUp = 1 << NSEventType.NSEventTypeRightMouseUp,
  NSEventMaskMouseMoved = 1 << NSEventType.NSEventTypeMouseMoved,
  NSEventMaskLeftMouseDragged = 1 << NSEventType.NSEventTypeLeftMouseDragged,
  NSEventMaskRightMouseDragged = 1 << NSEventType.NSEventTypeRightMouseDragged,
  NSEventMaskMouseEntered = 1 << NSEventType.NSEventTypeMouseEntered,
  NSEventMaskMouseExited = 1 << NSEventType.NSEventTypeMouseExited,
  NSEventMaskKeyDown = 1 << NSEventType.NSEventTypeKeyDown,
  NSEventMaskKeyUp = 1 << NSEventType.NSEventTypeKeyUp,
  NSEventMaskFlagsChanged = 1 << NSEventType.NSEventTypeFlagsChanged,
  NSEventMaskAppKitDefined = 1 << NSEventType.NSEventTypeAppKitDefined,
  NSEventMaskSystemDefined = 1 << NSEventType.NSEventTypeSystemDefined,
  NSEventMaskApplicationDefined = 1 << NSEventType.NSEventTypeApplicationDefined,
  NSEventMaskPeriodic = 1 << NSEventType.NSEventTypePeriodic,
  NSEventMaskCursorUpdate = 1 << NSEventType.NSEventTypeCursorUpdate,
  NSEventMaskScrollWheel = 1 << NSEventType.NSEventTypeScrollWheel,
  NSEventMaskTabletPoint = 1 << NSEventType.NSEventTypeTabletPoint,
  NSEventMaskTabletProximity = 1 << NSEventType.NSEventTypeTabletProximity,
  NSEventMaskOtherMouseDown = 1 << NSEventType.NSEventTypeOtherMouseDown,
  NSEventMaskOtherMouseUp = 1 << NSEventType.NSEventTypeOtherMouseUp,
  NSEventMaskOtherMouseDragged = 1 << NSEventType.NSEventTypeOtherMouseDragged,
  NSEventMaskGesture = 1 << NSEventType.NSEventTypeGesture,
  NSEventMaskMagnify = 1 << NSEventType.NSEventTypeMagnify,
  NSEventMaskSwipe = 1 << NSEventType.NSEventTypeSwipe,
  NSEventMaskRotate = 1 << NSEventType.NSEventTypeRotate,
  NSEventMaskBeginGesture = 1 << NSEventType.NSEventTypeBeginGesture,
  NSEventMaskEndGesture = 1 << NSEventType.NSEventTypeEndGesture,
  NSEventMaskSmartMagnify = 1 << NSEventType.NSEventTypeSmartMagnify,
  NSEventMaskPressure = 1 << NSEventType.NSEventTypePressure,
  NSEventMaskDirectTouch = 1 << NSEventType.NSEventTypeDirectTouch,
  NSEventMaskAny,
}

declare enum NSEventModifierFlags {
  NSEventModifierFlagCapsLock = 1 << 16,
  NSEventModifierFlagShift = 1 << 17,
  NSEventModifierFlagControl = 1 << 18,
  NSEventModifierFlagOption = 1 << 19,
  NSEventModifierFlagCommand = 1 << 20,
  NSEventModifierFlagNumericPad = 1 << 21,
  NSEventModifierFlagHelp = 1 << 22,
  NSEventModifierFlagFunction = 1 << 23,
  NSEventModifierFlagDeviceIndependentFlagsMask = 0xffff0000,
}

declare enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown,
  NSPointingDeviceTypePen,
  NSPointingDeviceTypeCursor,
  NSPointingDeviceTypeEraser,
}

declare enum NSEventButtonMask {
  NSEventButtonMaskPenTip,
  NSEventButtonMaskPenLowerSide,
  NSEventButtonMaskPenUpperSide,
}

declare enum NSEventPhase {
  NSEventPhaseNone = 0,
  NSEventPhaseBegan = 0x1 << 0,
  NSEventPhaseStationary = 0x1 << 1,
  NSEventPhaseChanged = 0x1 << 2,
  NSEventPhaseEnded = 0x1 << 3,
  NSEventPhaseCancelled = 0x1 << 4,
  NSEventPhaseMayBegin = 0x1 << 5,
}

declare enum NSEventGestureAxis {
  NSEventGestureAxisNone = 0,
  NSEventGestureAxisHorizontal,
  NSEventGestureAxisVertical,
}

declare enum NSEventSwipeTrackingOptions {
  NSEventSwipeTrackingLockDirection = 0x1 << 0,
  NSEventSwipeTrackingClampGestureAmount = 0x1 << 1,
}

declare enum NSEventSubtype {
  NSEventSubtypeWindowExposed = 0,
  NSEventSubtypeApplicationActivated = 1,
  NSEventSubtypeApplicationDeactivated = 2,
  NSEventSubtypeWindowMoved = 4,
  NSEventSubtypeScreenChanged = 8,
  NSEventSubtypePowerOff = 1,
  NSEventSubtypeMouseEvent,
  NSEventSubtypeTabletPoint,
  NSEventSubtypeTabletProximity,
  NSEventSubtypeTouch,
}

declare enum NSPressureBehavior {
  NSPressureBehaviorUnknown = -1,
  NSPressureBehaviorPrimaryDefault = 0,
  NSPressureBehaviorPrimaryClick = 1,
  NSPressureBehaviorPrimaryGeneric = 2,
  NSPressureBehaviorPrimaryAccelerator = 3,
  NSPressureBehaviorPrimaryDeepClick = 5,
  NSPressureBehaviorPrimaryDeepDrag = 6,
}

interface NSFilePromiseProviderAllocator<InitializedType = NSFilePromiseProvider> extends NSObjectAllocator<NSFilePromiseProvider> {
  initWithFileType_delegate(fileType: NSString | string, delegate: any): InitializedType;
  init(): InitializedType;
}
interface NSFilePromiseProvider extends NSObject, INSPasteboardWriting {

  fileType(): NSString;
  setFileType(fileType: NSString | string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  userInfo(): any;
  setUserInfo(userInfo: any): void;
}
declare const NSFilePromiseProvider: {
  alloc(): NSFilePromiseProviderAllocator;
}

interface INSFilePromiseProviderDelegate {
  filePromiseProvider_fileNameForType(filePromiseProvider: NSFilePromiseProvider, fileType: NSString | string): NSString;
  filePromiseProvider_writePromiseToURL_completionHandler(filePromiseProvider: NSFilePromiseProvider, url: NSURL, completionHandler: Block): void;
  operationQueueForFilePromiseProvider(filePromiseProvider: NSFilePromiseProvider): NSOperationQueue;
}

interface NSFilePromiseReceiverAllocator<InitializedType = NSFilePromiseReceiver> extends NSObjectAllocator<NSFilePromiseReceiver> {
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): InitializedType;
}
interface NSFilePromiseReceiver extends NSObject, INSPasteboardReading {
  receivePromisedFilesAtDestination_options_operationQueue_reader(destinationDir: NSURL, options: NSDictionary<any, any> | {[key: string]: any}, operationQueue: NSOperationQueue, reader: Block): void;

  fileTypes(): NSArray<any>;
  fileNames(): NSArray<any>;
}
declare const NSFilePromiseReceiver: {
  alloc(): NSFilePromiseReceiverAllocator;
  readableDraggedTypes(): NSArray<any>;

}

interface NSFontAllocator<InitializedType = NSFont> extends NSObjectAllocator<NSFont> {}
interface NSFont extends NSObject, INSCopying, INSSecureCoding {
  boundingRectForCGGlyph(glyph: CGGlyph): NSRect;
  advancementForCGGlyph(glyph: CGGlyph): NSSize;
  getBoundingRects_forCGGlyphs_count(bounds: NSRectArray, glyphs: CGGlyph, glyphCount: NSUInteger): void;
  getAdvancements_forCGGlyphs_count(advancements: NSSizeArray, glyphs: CGGlyph, glyphCount: NSUInteger): void;
  set(): void;
  setInContext(graphicsContext: NSGraphicsContext): void;
  glyphWithName(name: NSString | string): NSGlyph;
  boundingRectForGlyph(glyph: NSGlyph): NSRect;
  advancementForGlyph(glyph: NSGlyph): NSSize;
  getBoundingRects_forGlyphs_count(bounds: NSRectArray, glyphs: NSGlyph, glyphCount: NSUInteger): void;
  getAdvancements_forGlyphs_count(advancements: NSSizeArray, glyphs: NSGlyph, glyphCount: NSUInteger): void;
  getAdvancements_forPackedGlyphs_length(advancements: NSSizeArray, packedGlyphs: void, length: NSUInteger): void;
  screenFontWithRenderingMode(renderingMode: NSFontRenderingMode): NSFont;
  widthOfString(string: NSString | string): CGFloat;
  isBaseFont(): boolean;
  afmDictionary(): NSDictionary<any, any>;
  glyphIsEncoded(glyph: NSGlyph): boolean;
  defaultLineHeightForFont(): CGFloat;
  encodingScheme(): NSString;
  glyphPacking(): NSMultibyteGlyphPacking;
  positionOfGlyph_precededByGlyph_isNominal(glyph: NSGlyph, prevGlyph: NSGlyph, nominal: boolean): NSPoint;
  positionsForCompositeSequence_numberOfGlyphs_pointArray(someGlyphs: NSGlyph, numGlyphs: NSInteger, points: NSPointArray): NSInteger;
  positionOfGlyph_struckOverGlyph_metricsExist(glyph: NSGlyph, prevGlyph: NSGlyph, exist: boolean): NSPoint;
  positionOfGlyph_struckOverRect_metricsExist(glyph: NSGlyph, rect: NSRect, exist: boolean): NSPoint;
  positionOfGlyph_forCharacter_struckOverRect(glyph: NSGlyph, character: unichar, rect: NSRect): NSPoint;
  positionOfGlyph_withRelation_toBaseGlyph_totalAdvancement_metricsExist(thisGlyph: NSGlyph, rel: NSGlyphRelation, baseGlyph: NSGlyph, adv: NSSizePointer, exist: boolean): NSPoint;
  addSVGAttributes(attributes: NSMutableArray<any> | any[]): void;

  fontName(): NSString;
  pointSize(): CGFloat;
  matrix(): CGFloat;
  familyName(): NSString;
  displayName(): NSString;
  fontDescriptor(): NSFontDescriptor;
  textTransform(): NSAffineTransform;
  numberOfGlyphs(): NSUInteger;
  mostCompatibleStringEncoding(): NSStringEncoding;
  coveredCharacterSet(): NSCharacterSet;
  boundingRectForFont(): NSRect;
  maximumAdvancement(): NSSize;
  ascender(): CGFloat;
  descender(): CGFloat;
  leading(): CGFloat;
  underlinePosition(): CGFloat;
  underlineThickness(): CGFloat;
  italicAngle(): CGFloat;
  capHeight(): CGFloat;
  xHeight(): CGFloat;
  fixedPitch(): boolean;
  verticalFont(): NSFont;
  vertical(): boolean;
  printerFont(): NSFont;
  screenFont(): NSFont;
  renderingMode(): NSFontRenderingMode;
}
declare const NSFont: {
  alloc(): NSFontAllocator;  fontWithName_size(fontName: NSString | string, fontSize: CGFloat): NSFont;
  fontWithName_matrix(fontName: NSString | string, fontMatrix: CGFloat): NSFont;
  fontWithDescriptor_size(fontDescriptor: NSFontDescriptor, fontSize: CGFloat): NSFont;
  fontWithDescriptor_textTransform(fontDescriptor: NSFontDescriptor, textTransform: NSAffineTransform | null): NSFont;
  userFontOfSize(fontSize: CGFloat): NSFont;
  userFixedPitchFontOfSize(fontSize: CGFloat): NSFont;
  setUserFont(font: NSFont | null): void;
  setUserFixedPitchFont(font: NSFont | null): void;
  systemFontOfSize(fontSize: CGFloat): NSFont;
  boldSystemFontOfSize(fontSize: CGFloat): NSFont;
  labelFontOfSize(fontSize: CGFloat): NSFont;
  titleBarFontOfSize(fontSize: CGFloat): NSFont;
  menuFontOfSize(fontSize: CGFloat): NSFont;
  menuBarFontOfSize(fontSize: CGFloat): NSFont;
  messageFontOfSize(fontSize: CGFloat): NSFont;
  paletteFontOfSize(fontSize: CGFloat): NSFont;
  toolTipsFontOfSize(fontSize: CGFloat): NSFont;
  controlContentFontOfSize(fontSize: CGFloat): NSFont;
  systemFontOfSize_weight(fontSize: CGFloat, weight: NSFontWeight): NSFont;
  monospacedDigitSystemFontOfSize_weight(fontSize: CGFloat, weight: NSFontWeight): NSFont;
  systemFontSizeForControlSize(controlSize: NSControlSize): CGFloat;
  useFont(fontName: NSString | string): void;
  preferredFontNames(): NSArray<any>;
  setPreferredFontNames(fontNameArray: NSArray<any> | any[]): void;
  preventsAutoActivation_bc(): boolean;
  setPreventsAutoActivation_bc(flag: boolean): void;
  fontWithName_size_bc(fontName: NSString | string, fontSize: CGFloat): NSFont;
  fontPreventingAutoActivationWithName_size_bc(fontName: NSString | string, fontSize: CGFloat): NSFont;

  systemFontSize(): CGFloat;
  smallSystemFontSize(): CGFloat;
  labelFontSize(): CGFloat;

}

declare type NSGlyph = number

declare type NSGlyphRelation = NSUInteger

declare enum NSFontRenderingMode {
  NSFontDefaultRenderingMode = 0,
  NSFontAntialiasedRenderingMode = 1,
  NSFontIntegerAdvancementsRenderingMode = 2,
  NSFontAntialiasedIntegerAdvancementsRenderingMode = 3,
}

declare enum NSMultibyteGlyphPacking {
  NSNativeShortGlyphPacking = 5,
}

interface NSFontAssetRequestAllocator<InitializedType = NSFontAssetRequest> extends NSObjectAllocator<NSFontAssetRequest> {
  initWithFontDescriptors_options(fontDescriptors: NSArray<any> | any[], options: NSFontAssetRequestOptions): InitializedType;
}
interface NSFontAssetRequest extends NSObject, INSProgressReporting {
  downloadFontAssetsWithCompletionHandler(completionHandler: Block): void;

  downloadedFontDescriptors(): NSArray<any>;
  progress(): NSProgress;
}
declare const NSFontAssetRequest: {
  alloc(): NSFontAssetRequestAllocator;
}

declare enum NSFontAssetRequestOptions {
  NSFontAssetRequestOptionUsesStandardUI = 1 << 0,
}

interface NSFontCollectionAllocator<InitializedType = NSFontCollection> extends NSObjectAllocator<NSFontCollection> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSFontCollection extends NSObject, INSCopying, INSMutableCopying, INSCoding {
  matchingDescriptorsWithOptions(options: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  matchingDescriptorsForFamily(family: NSString | string): NSArray<any>;
  matchingDescriptorsForFamily_options(family: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;

  queryDescriptors(): NSArray<any>;
  exclusionDescriptors(): NSArray<any>;
  matchingDescriptors(): NSArray<any>;
}
declare const NSFontCollection: {
  alloc(): NSFontCollectionAllocator;  fontCollectionWithDescriptors(queryDescriptors: NSArray<any> | any[]): NSFontCollection;
  fontCollectionWithLocale(locale: NSLocale): NSFontCollection;
  showFontCollection_withName_visibility_error(collection: NSFontCollection, name: NSFontCollectionName, visibility: NSFontCollectionVisibility, error: NSError): boolean;
  hideFontCollectionWithName_visibility_error(name: NSFontCollectionName, visibility: NSFontCollectionVisibility, error: NSError): boolean;
  renameFontCollectionWithName_visibility_toName_error(name: NSFontCollectionName, visibility: NSFontCollectionVisibility, name2: NSFontCollectionName, error: NSError): boolean;
  fontCollectionWithName(name: NSFontCollectionName): NSFontCollection;
  fontCollectionWithName_visibility(name: NSFontCollectionName, visibility: NSFontCollectionVisibility): NSFontCollection;

  fontCollectionWithAllAvailableDescriptors(): NSFontCollection;
  allFontCollectionNames(): NSArray<any>;

}

interface NSMutableFontCollectionAllocator<InitializedType = NSMutableFontCollection> extends NSFontCollectionAllocator<NSMutableFontCollection> {}
interface NSMutableFontCollection extends NSFontCollection {
  addQueryForDescriptors(descriptors: NSArray<any> | any[]): void;
  removeQueryForDescriptors(descriptors: NSArray<any> | any[]): void;

  queryDescriptors(): NSArray<any>;
  setQueryDescriptors(queryDescriptors: NSArray<any> | any[]): void;
  exclusionDescriptors(): NSArray<any>;
  setExclusionDescriptors(exclusionDescriptors: NSArray<any> | any[]): void;
}
declare const NSMutableFontCollection: {
  alloc(): NSMutableFontCollectionAllocator;  fontCollectionWithDescriptors(queryDescriptors: NSArray<any> | any[]): NSMutableFontCollection;
  fontCollectionWithLocale(locale: NSLocale): NSMutableFontCollection;
  fontCollectionWithName(name: NSFontCollectionName): NSMutableFontCollection;
  fontCollectionWithName_visibility(name: NSFontCollectionName, visibility: NSFontCollectionVisibility): NSMutableFontCollection;

  fontCollectionWithAllAvailableDescriptors(): NSMutableFontCollection;

}

declare type NSFontCollectionMatchingOptionKey = NSString

declare type NSFontCollectionName = NSString

declare type NSFontCollectionUserInfoKey = NSString

declare type NSFontCollectionActionTypeKey = NSString

declare enum NSFontCollectionVisibility {
  NSFontCollectionVisibilityProcess,
  NSFontCollectionVisibilityUser,
  NSFontCollectionVisibilityComputer,
}

interface NSFontDescriptorAllocator<InitializedType = NSFontDescriptor> extends NSObjectAllocator<NSFontDescriptor> {
  initWithFontAttributes(attributes: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface NSFontDescriptor extends NSObject, INSCopying, INSSecureCoding {
  objectForKey(attribute: NSFontDescriptorAttributeName): any;
  matchingFontDescriptorsWithMandatoryKeys(mandatoryKeys: NSSet<any> | null): NSArray<any>;
  matchingFontDescriptorWithMandatoryKeys(mandatoryKeys: NSSet<any> | null): NSFontDescriptor;
  fontDescriptorByAddingAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSFontDescriptor;
  fontDescriptorWithSymbolicTraits(symbolicTraits: NSFontDescriptorSymbolicTraits): NSFontDescriptor;
  fontDescriptorWithSize(newPointSize: CGFloat): NSFontDescriptor;
  fontDescriptorWithMatrix(matrix: NSAffineTransform): NSFontDescriptor;
  fontDescriptorWithFace(newFace: NSString | string): NSFontDescriptor;
  fontDescriptorWithFamily(newFamily: NSString | string): NSFontDescriptor;

  postscriptName(): NSString;
  pointSize(): CGFloat;
  matrix(): NSAffineTransform;
  symbolicTraits(): NSFontDescriptorSymbolicTraits;
  requiresFontAssetRequest(): boolean;
  fontAttributes(): NSDictionary<any, any>;
}
declare const NSFontDescriptor: {
  alloc(): NSFontDescriptorAllocator;  fontDescriptorWithFontAttributes(attributes: NSDictionary<any, any> | {[key: string]: any} | null): NSFontDescriptor;
  fontDescriptorWithName_size(fontName: NSString | string, size: CGFloat): NSFontDescriptor;
  fontDescriptorWithName_matrix(fontName: NSString | string, matrix: NSAffineTransform): NSFontDescriptor;

}

declare type NSFontSymbolicTraits = number

declare type NSFontDescriptorAttributeName = NSString

declare type NSFontDescriptorTraitKey = NSString

declare type NSFontDescriptorVariationKey = NSString

declare type NSFontDescriptorFeatureKey = NSString

declare type NSFontWeight = CGFloat

declare type NSFontFamilyClass = number

declare enum NSFontDescriptorSymbolicTraits {
  NSFontDescriptorTraitItalic = 1 << 0,
  NSFontDescriptorTraitBold = 1 << 1,
  NSFontDescriptorTraitExpanded = 1 << 5,
  NSFontDescriptorTraitCondensed = 1 << 6,
  NSFontDescriptorTraitMonoSpace = 1 << 10,
  NSFontDescriptorTraitVertical = 1 << 11,
  NSFontDescriptorTraitUIOptimized = 1 << 12,
  NSFontDescriptorTraitTightLeading = 1 << 15,
  NSFontDescriptorTraitLooseLeading = 1 << 16,
  NSFontDescriptorClassMask = 0xF0000000,
  NSFontDescriptorClassUnknown = 0 << 28,
  NSFontDescriptorClassOldStyleSerifs = 1 << 28,
  NSFontDescriptorClassTransitionalSerifs = 2 << 28,
  NSFontDescriptorClassModernSerifs = 3 << 28,
  NSFontDescriptorClassClarendonSerifs = 4 << 28,
  NSFontDescriptorClassSlabSerifs = 5 << 28,
  NSFontDescriptorClassFreeformSerifs = 7 << 28,
  NSFontDescriptorClassSansSerif = 8 << 28,
  NSFontDescriptorClassOrnamentals = 9 << 28,
  NSFontDescriptorClassScripts = 10 << 28,
  NSFontDescriptorClassSymbolic = 12 << 28,
}

interface NSFontManagerAllocator<InitializedType = NSFontManager> extends NSObjectAllocator<NSFontManager> {}
interface NSFontManager extends NSObject {
  setSelectedFont_isMultiple(fontObj: NSFont, flag: boolean): void;
  setFontMenu(newMenu: NSMenu): void;
  fontMenu(create: boolean): NSMenu;
  fontPanel(create: boolean): NSFontPanel;
  fontWithFamily_traits_weight_size(family: NSString | string, traits: NSFontTraitMask, weight: NSInteger, size: CGFloat): NSFont;
  traitsOfFont(fontObj: NSFont): NSFontTraitMask;
  weightOfFont(fontObj: NSFont): NSInteger;
  availableMembersOfFontFamily(fam: NSString | string): NSArray<any>;
  convertFont(fontObj: NSFont): NSFont;
  convertFont_toSize(fontObj: NSFont, size: CGFloat): NSFont;
  convertFont_toFace(fontObj: NSFont, typeface: NSString | string): NSFont;
  convertFont_toFamily(fontObj: NSFont, family: NSString | string): NSFont;
  convertFont_toHaveTrait(fontObj: NSFont, trait: NSFontTraitMask): NSFont;
  convertFont_toNotHaveTrait(fontObj: NSFont, trait: NSFontTraitMask): NSFont;
  convertWeight_ofFont(upFlag: boolean, fontObj: NSFont): NSFont;
  sendAction(): boolean;
  localizedNameForFamily_face(family: NSString | string, faceKey: NSString | string | null): NSString;
  setSelectedAttributes_isMultiple(attributes: NSDictionary<any, any> | {[key: string]: any}, flag: boolean): void;
  convertAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  availableFontNamesMatchingFontDescriptor(descriptor: NSFontDescriptor): NSArray<any>;
  fontDescriptorsInCollection(collectionNames: NSString | string): NSArray<any>;
  addCollection_options(collectionName: NSString | string, collectionOptions: NSFontCollectionOptions): boolean;
  removeCollection(collectionName: NSString | string): boolean;
  addFontDescriptors_toCollection(descriptors: NSArray<any> | any[], collectionName: NSString | string): void;
  removeFontDescriptor_fromCollection(descriptor: NSFontDescriptor, collection: NSString | string): void;
  convertFontTraits(traits: NSFontTraitMask): NSFontTraitMask;
  fontNamed_hasTraits(fName: NSString | string, someTraits: NSFontTraitMask): boolean;
  availableFontNamesWithTraits(someTraits: NSFontTraitMask): NSArray<any>;
  addFontTrait(sender: any | null): void;
  removeFontTrait(sender: any | null): void;
  modifyFontViaPanel(sender: any | null): void;
  modifyFont(sender: any | null): void;
  orderFrontFontPanel(sender: any | null): void;
  orderFrontStylesPanel(sender: any | null): void;

  multiple(): boolean;
  selectedFont(): NSFont;
  availableFonts(): NSArray<any>;
  availableFontFamilies(): NSArray<any>;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  action(): string;
  setAction(action: string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  collectionNames(): NSArray<any>;
  currentFontAction(): NSFontAction;
  target(): any;
  setTarget(target: any): void;
}
declare const NSFontManager: {
  alloc(): NSFontManagerAllocator;  setFontPanelFactory(factoryId: any | null): void;
  setFontManagerFactory(factoryId: any | null): void;

  sharedFontManager(): NSFontManager;

}

declare enum NSFontTraitMask {
  NSItalicFontMask = 0x00000001,
  NSBoldFontMask = 0x00000002,
  NSUnboldFontMask = 0x00000004,
  NSNonStandardCharacterSetFontMask = 0x00000008,
  NSNarrowFontMask = 0x00000010,
  NSExpandedFontMask = 0x00000020,
  NSCondensedFontMask = 0x00000040,
  NSSmallCapsFontMask = 0x00000080,
  NSPosterFontMask = 0x00000100,
  NSCompressedFontMask = 0x00000200,
  NSFixedPitchFontMask = 0x00000400,
  NSUnitalicFontMask = 0x01000000,
}

declare enum NSFontCollectionOptions {
  NSFontCollectionApplicationOnlyMask = 1 << 0,
}

declare enum NSFontAction {
  NSNoFontChangeAction = 0,
  NSViaPanelFontAction = 1,
  NSAddTraitFontAction = 2,
  NSSizeUpFontAction = 3,
  NSSizeDownFontAction = 4,
  NSHeavierFontAction = 5,
  NSLighterFontAction = 6,
  NSRemoveTraitFontAction = 7,
}

interface NSFontPanelAllocator<InitializedType = NSFontPanel> extends NSPanelAllocator<NSFontPanel> {}
interface NSFontPanel extends NSPanel {
  setPanelFont_isMultiple(fontObj: NSFont, flag: boolean): void;
  panelConvertFont(fontObj: NSFont): NSFont;
  reloadDefaultFontFamilies(): void;

  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  worksWhenModal(): boolean;
  setWorksWhenModal(worksWhenModal: boolean): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}
declare const NSFontPanel: {
  alloc(): NSFontPanelAllocator;
  sharedFontPanel(): NSFontPanel;
  sharedFontPanelExists(): boolean;

}

declare enum NSFontPanelModeMask {
  NSFontPanelModeMaskFace = 1 << 0,
  NSFontPanelModeMaskSize = 1 << 1,
  NSFontPanelModeMaskCollection = 1 << 2,
  NSFontPanelModeMaskUnderlineEffect = 1<<8,
  NSFontPanelModeMaskStrikethroughEffect = 1<<9,
  NSFontPanelModeMaskTextColorEffect = 1<< 10,
  NSFontPanelModeMaskDocumentColorEffect = 1<<11,
  NSFontPanelModeMaskShadowEffect = 1<<12,
  NSFontPanelModeMaskAllEffects = 0XFFF00,
  NSFontPanelModesMaskStandardModes = 0xFFFF,
  NSFontPanelModesMaskAllModes = 0xFFFFFFFF,
}

interface NSFormCellAllocator<InitializedType = NSFormCell> extends NSActionCellAllocator<NSFormCell> {}
interface NSFormCell extends NSActionCell {
  titleWidth(size: NSSize): CGFloat;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;

  titleWidth(): CGFloat;
  setTitleWidth(titleWidth: CGFloat): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  titleFont(): NSFont;
  setTitleFont(titleFont: NSFont): void;
  titleAlignment(): NSTextAlignment;
  setTitleAlignment(titleAlignment: NSTextAlignment): void;
  opaque(): boolean;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  titleBaseWritingDirection(): NSWritingDirection;
  setTitleBaseWritingDirection(titleBaseWritingDirection: NSWritingDirection): void;
  preferredTextFieldWidth(): CGFloat;
  setPreferredTextFieldWidth(preferredTextFieldWidth: CGFloat): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
}
declare const NSFormCell: {
  alloc(): NSFormCellAllocator;
}

interface NSGestureRecognizerAllocator<InitializedType = NSGestureRecognizer> extends NSObjectAllocator<NSGestureRecognizer> {
  initWithTarget_action(target: any | null, action: string | null): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSGestureRecognizer extends NSObject, INSCoding {
  locationInView(view: NSView | null): NSPoint;
  reset(): void;
  canPreventGestureRecognizer(preventedGestureRecognizer: NSGestureRecognizer): boolean;
  canBePreventedByGestureRecognizer(preventingGestureRecognizer: NSGestureRecognizer): boolean;
  shouldRequireFailureOfGestureRecognizer(otherGestureRecognizer: NSGestureRecognizer): boolean;
  shouldBeRequiredToFailByGestureRecognizer(otherGestureRecognizer: NSGestureRecognizer): boolean;
  mouseDown(event: NSEvent): void;
  rightMouseDown(event: NSEvent): void;
  otherMouseDown(event: NSEvent): void;
  mouseUp(event: NSEvent): void;
  rightMouseUp(event: NSEvent): void;
  otherMouseUp(event: NSEvent): void;
  mouseDragged(event: NSEvent): void;
  rightMouseDragged(event: NSEvent): void;
  otherMouseDragged(event: NSEvent): void;
  keyDown(event: NSEvent): void;
  keyUp(event: NSEvent): void;
  flagsChanged(event: NSEvent): void;
  tabletPoint(event: NSEvent): void;
  magnifyWithEvent(event: NSEvent): void;
  rotateWithEvent(event: NSEvent): void;
  pressureChangeWithEvent(event: NSEvent): void;
  touchesBeganWithEvent(event: NSEvent): void;
  touchesMovedWithEvent(event: NSEvent): void;
  touchesEndedWithEvent(event: NSEvent): void;
  touchesCancelledWithEvent(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  state(): NSGestureRecognizerState;
  setState(state: NSGestureRecognizerState): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  view(): NSView;
  pressureConfiguration(): NSPressureConfiguration;
  setPressureConfiguration(pressureConfiguration: NSPressureConfiguration): void;
  delaysPrimaryMouseButtonEvents(): boolean;
  setDelaysPrimaryMouseButtonEvents(delaysPrimaryMouseButtonEvents: boolean): void;
  delaysSecondaryMouseButtonEvents(): boolean;
  setDelaysSecondaryMouseButtonEvents(delaysSecondaryMouseButtonEvents: boolean): void;
  delaysOtherMouseButtonEvents(): boolean;
  setDelaysOtherMouseButtonEvents(delaysOtherMouseButtonEvents: boolean): void;
  delaysKeyEvents(): boolean;
  setDelaysKeyEvents(delaysKeyEvents: boolean): void;
  delaysMagnificationEvents(): boolean;
  setDelaysMagnificationEvents(delaysMagnificationEvents: boolean): void;
  delaysRotationEvents(): boolean;
  setDelaysRotationEvents(delaysRotationEvents: boolean): void;
  allowedTouchTypes(): NSTouchTypeMask;
  setAllowedTouchTypes(allowedTouchTypes: NSTouchTypeMask): void;
}
declare const NSGestureRecognizer: {
  alloc(): NSGestureRecognizerAllocator;
}

interface INSGestureRecognizerDelegate {
  gestureRecognizer_shouldAttemptToRecognizeWithEvent(gestureRecognizer: NSGestureRecognizer, event: NSEvent): boolean;
  gestureRecognizerShouldBegin(gestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer(gestureRecognizer: NSGestureRecognizer, otherGestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldRequireFailureOfGestureRecognizer(gestureRecognizer: NSGestureRecognizer, otherGestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer(gestureRecognizer: NSGestureRecognizer, otherGestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldReceiveTouch(gestureRecognizer: NSGestureRecognizer, touch: NSTouch): boolean;
}

declare enum NSGestureRecognizerState {
  NSGestureRecognizerStatePossible,
  NSGestureRecognizerStateBegan,
  NSGestureRecognizerStateChanged,
  NSGestureRecognizerStateEnded,
  NSGestureRecognizerStateCancelled,
  NSGestureRecognizerStateFailed,
  NSGestureRecognizerStateRecognized,
}

interface NSGlyphGeneratorAllocator<InitializedType = NSGlyphGenerator> extends NSObjectAllocator<NSGlyphGenerator> {}
interface NSGlyphGenerator extends NSObject {
  generateGlyphsForGlyphStorage_desiredNumberOfCharacters_glyphIndex_characterIndex(glyphStorage: any, nChars: NSUInteger, glyphIndex: NSUInteger | null, charIndex: NSUInteger | null): void;
}
declare const NSGlyphGenerator: {
  alloc(): NSGlyphGeneratorAllocator;
  sharedGlyphGenerator(): NSGlyphGenerator;

}

interface INSGlyphStorage {
  insertGlyphs_length_forStartingGlyphAtIndex_characterIndex(glyphs: NSGlyph, length: NSUInteger, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  setIntAttribute_value_forGlyphAtIndex(attributeTag: NSInteger, val: NSInteger, glyphIndex: NSUInteger): void;
  attributedString(): NSAttributedString;
  layoutOptions(): NSUInteger;
}

interface NSGlyphInfoAllocator<InitializedType = NSGlyphInfo> extends NSObjectAllocator<NSGlyphInfo> {}
interface NSGlyphInfo extends NSObject, INSCopying, INSSecureCoding {

  glyphID(): CGGlyph;
  baseString(): NSString;
  glyphName(): NSString;
  characterIdentifier(): NSUInteger;
  characterCollection(): NSCharacterCollection;
}
declare const NSGlyphInfo: {
  alloc(): NSGlyphInfoAllocator;  glyphInfoWithCGGlyph_forFont_baseString(glyph: CGGlyph, font: NSFont, string: NSString | string): NSGlyphInfo;
  glyphInfoWithGlyphName_forFont_baseString(glyphName: NSString | string, font: NSFont, string: NSString | string): NSGlyphInfo;
  glyphInfoWithGlyph_forFont_baseString(glyph: NSGlyph, font: NSFont, string: NSString | string): NSGlyphInfo;
  glyphInfoWithCharacterIdentifier_collection_baseString(cid: NSUInteger, characterCollection: NSCharacterCollection, string: NSString | string): NSGlyphInfo;

}

declare enum NSCharacterCollection {
  NSIdentityMappingCharacterCollection = 0,
  NSAdobeCNS1CharacterCollection = 1,
  NSAdobeGB1CharacterCollection = 2,
  NSAdobeJapan1CharacterCollection = 3,
  NSAdobeJapan2CharacterCollection = 4,
  NSAdobeKorea1CharacterCollection = 5,
}

interface NSGradientAllocator<InitializedType = NSGradient> extends NSObjectAllocator<NSGradient> {
  initWithStartingColor_endingColor(startingColor: NSColor, endingColor: NSColor): InitializedType;
  initWithColors(colorArray: NSArray<any> | any[]): InitializedType;
  initWithColorsAndLocations(firstColor: NSColor, ...args: any[]): InitializedType;
  initWithColors_atLocations_colorSpace(colorArray: NSArray<any> | any[], locations: CGFloat | null, colorSpace: NSColorSpace): InitializedType;
  initWithCoder(decoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSGradient extends NSObject, INSCopying, INSCoding {
  drawFromPoint_toPoint_options(startingPoint: NSPoint, endingPoint: NSPoint, options: NSGradientDrawingOptions): void;
  drawInRect_angle(rect: NSRect, angle: CGFloat): void;
  drawInBezierPath_angle(path: NSBezierPath, angle: CGFloat): void;
  drawFromCenter_radius_toCenter_radius_options(startCenter: NSPoint, startRadius: CGFloat, endCenter: NSPoint, endRadius: CGFloat, options: NSGradientDrawingOptions): void;
  drawInRect_relativeCenterPosition(rect: NSRect, relativeCenterPosition: NSPoint): void;
  drawInBezierPath_relativeCenterPosition(path: NSBezierPath, relativeCenterPosition: NSPoint): void;
  getColor_location_atIndex(color: NSColor, location: CGFloat | null, index: NSInteger): void;
  interpolatedColorAtLocation(location: CGFloat): NSColor;
  interpolatedGradientWithExtraStops_function(extraStops: NSUInteger, functionName: GradientInterpolationFunction): NSGradient;

  colorSpace(): NSColorSpace;
  numberOfColorStops(): NSInteger;
}
declare const NSGradient: {
  alloc(): NSGradientAllocator;
}

declare enum NSGradientDrawingOptions {
  NSGradientDrawsBeforeStartingLocation,
  NSGradientDrawsAfterEndingLocation,
}

declare type NSColorSpaceName = NSString

declare type NSDeviceDescriptionKey = NSString

declare enum NSCompositingOperation {
  NSCompositingOperationClear,
  NSCompositingOperationCopy,
  NSCompositingOperationSourceOver,
  NSCompositingOperationSourceIn,
  NSCompositingOperationSourceOut,
  NSCompositingOperationSourceAtop,
  NSCompositingOperationDestinationOver,
  NSCompositingOperationDestinationIn,
  NSCompositingOperationDestinationOut,
  NSCompositingOperationDestinationAtop,
  NSCompositingOperationXOR,
  NSCompositingOperationPlusDarker,
  NSCompositingOperationHighlight,
  NSCompositingOperationPlusLighter,
  NSCompositingOperationMultiply,
  NSCompositingOperationScreen,
  NSCompositingOperationOverlay,
  NSCompositingOperationDarken,
  NSCompositingOperationLighten,
  NSCompositingOperationColorDodge,
  NSCompositingOperationColorBurn,
  NSCompositingOperationSoftLight,
  NSCompositingOperationHardLight,
  NSCompositingOperationDifference,
  NSCompositingOperationExclusion,
  NSCompositingOperationHue,
  NSCompositingOperationSaturation,
  NSCompositingOperationColor,
  NSCompositingOperationLuminosity,
}

declare enum NSBackingStoreType {
  NSBackingStoreRetained = 0,
  NSBackingStoreNonretained = 1,
  NSBackingStoreBuffered = 2,
}

declare enum NSWindowOrderingMode {
  NSWindowAbove = 1,
  NSWindowBelow = -1,
  NSWindowOut = 0,
}

declare enum NSFocusRingPlacement {
  NSFocusRingOnly = 0,
  NSFocusRingBelow = 1,
  NSFocusRingAbove = 2,
}

declare enum NSFocusRingType {
  NSFocusRingTypeDefault = 0,
  NSFocusRingTypeNone = 1,
  NSFocusRingTypeExterior = 2,
}

declare enum NSColorRenderingIntent {
  NSColorRenderingIntentDefault,
  NSColorRenderingIntentAbsoluteColorimetric,
  NSColorRenderingIntentRelativeColorimetric,
  NSColorRenderingIntentPerceptual,
  NSColorRenderingIntentSaturation,
}

declare enum NSWindowDepth {
  NSWindowDepthTwentyfourBitRGB = 0x208,
  NSWindowDepthSixtyfourBitRGB = 0x210,
  NSWindowDepthOnehundredtwentyeightBitRGB = 0x220,
}

declare enum NSDisplayGamut {
  NSDisplayGamutSRGB = 1,
  NSDisplayGamutP3,
}

declare enum NSAnimationEffect {
  NSAnimationEffectDisappearingItemDefault = 0,
  NSAnimationEffectPoof = 10,
}

interface NSGraphicsContextAllocator<InitializedType = NSGraphicsContext> extends NSObjectAllocator<NSGraphicsContext> {}
interface NSGraphicsContext extends NSObject {
  saveGraphicsState(): void;
  restoreGraphicsState(): void;
  flushGraphics(): void;
  focusStack(): any;
  setFocusStack(stack: any): void;

  attributes(): NSDictionary<any, any>;
  drawingToScreen(): boolean;
  CGContext(): CGContextRef;
  flipped(): boolean;
  shouldAntialias(): boolean;
  setShouldAntialias(shouldAntialias: boolean): void;
  imageInterpolation(): NSImageInterpolation;
  setImageInterpolation(imageInterpolation: NSImageInterpolation): void;
  patternPhase(): NSPoint;
  setPatternPhase(patternPhase: NSPoint): void;
  compositingOperation(): NSCompositingOperation;
  setCompositingOperation(compositingOperation: NSCompositingOperation): void;
  colorRenderingIntent(): NSColorRenderingIntent;
  setColorRenderingIntent(colorRenderingIntent: NSColorRenderingIntent): void;
  CIContext(): CIContext;
  graphicsPort(): void;
}
declare const NSGraphicsContext: {
  alloc(): NSGraphicsContextAllocator;  graphicsContextWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSGraphicsContext;
  graphicsContextWithWindow(window: NSWindow): NSGraphicsContext;
  graphicsContextWithBitmapImageRep(bitmapRep: NSBitmapImageRep): NSGraphicsContext;
  graphicsContextWithCGContext_flipped(graphicsPort: CGContextRef, initialFlippedState: boolean): NSGraphicsContext;
  currentContextDrawingToScreen(): boolean;
  setGraphicsState(gState: NSInteger): void;
  graphicsContextWithGraphicsPort_flipped(graphicsPort: void, initialFlippedState: boolean): NSGraphicsContext;

  currentContext(): NSGraphicsContext;
  setCurrentContext(currentContext: NSGraphicsContext): void;

}

declare type NSGraphicsContextAttributeKey = NSString

declare type NSGraphicsContextRepresentationFormatName = NSString

declare enum NSImageInterpolation {
  NSImageInterpolationDefault = 0,
  NSImageInterpolationNone = 1,
  NSImageInterpolationLow = 2,
  NSImageInterpolationMedium = 4,
  NSImageInterpolationHigh = 3,
}

interface NSGridViewAllocator<InitializedType = NSGridView> extends NSViewAllocator<NSGridView> {}
interface NSGridView extends NSView {
  rowAtIndex(index: NSInteger): NSGridRow;
  indexOfRow(row: NSGridRow): NSInteger;
  columnAtIndex(index: NSInteger): NSGridColumn;
  indexOfColumn(column: NSGridColumn): NSInteger;
  cellAtColumnIndex_rowIndex(columnIndex: NSInteger, rowIndex: NSInteger): NSGridCell;
  cellForView(view: NSView): NSGridCell;
  addRowWithViews(views: NSArray<any> | any[]): NSGridRow;
  insertRowAtIndex_withViews(index: NSInteger, views: NSArray<any> | any[]): NSGridRow;
  moveRowAtIndex_toIndex(fromIndex: NSInteger, toIndex: NSInteger): void;
  removeRowAtIndex(index: NSInteger): void;
  addColumnWithViews(views: NSArray<any> | any[]): NSGridColumn;
  insertColumnAtIndex_withViews(index: NSInteger, views: NSArray<any> | any[]): NSGridColumn;
  moveColumnAtIndex_toIndex(fromIndex: NSInteger, toIndex: NSInteger): void;
  removeColumnAtIndex(index: NSInteger): void;
  mergeCellsInHorizontalRange_verticalRange(hRange: NSRange, vRange: NSRange): void;

  numberOfRows(): NSInteger;
  numberOfColumns(): NSInteger;
  xPlacement(): NSGridCellPlacement;
  setXPlacement(xPlacement: NSGridCellPlacement): void;
  yPlacement(): NSGridCellPlacement;
  setYPlacement(yPlacement: NSGridCellPlacement): void;
  rowAlignment(): NSGridRowAlignment;
  setRowAlignment(rowAlignment: NSGridRowAlignment): void;
  rowSpacing(): CGFloat;
  setRowSpacing(rowSpacing: CGFloat): void;
  columnSpacing(): CGFloat;
  setColumnSpacing(columnSpacing: CGFloat): void;
}
declare const NSGridView: {
  alloc(): NSGridViewAllocator;  gridViewWithNumberOfColumns_rows(columnCount: NSInteger, rowCount: NSInteger): NSGridView;
  gridViewWithViews(rows: NSArray<any> | any[]): NSGridView;

}

interface NSGridRowAllocator<InitializedType = NSGridRow> extends NSObjectAllocator<NSGridRow> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSGridRow extends NSObject, INSCoding {
  cellAtIndex(index: NSInteger): NSGridCell;
  mergeCellsInRange(range: NSRange): void;

  gridView(): NSGridView;
  numberOfCells(): NSInteger;
  yPlacement(): NSGridCellPlacement;
  setYPlacement(yPlacement: NSGridCellPlacement): void;
  rowAlignment(): NSGridRowAlignment;
  setRowAlignment(rowAlignment: NSGridRowAlignment): void;
  height(): CGFloat;
  setHeight(height: CGFloat): void;
  topPadding(): CGFloat;
  setTopPadding(topPadding: CGFloat): void;
  bottomPadding(): CGFloat;
  setBottomPadding(bottomPadding: CGFloat): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
}
declare const NSGridRow: {
  alloc(): NSGridRowAllocator;
}

interface NSGridColumnAllocator<InitializedType = NSGridColumn> extends NSObjectAllocator<NSGridColumn> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSGridColumn extends NSObject, INSCoding {
  cellAtIndex(index: NSInteger): NSGridCell;
  mergeCellsInRange(range: NSRange): void;

  gridView(): NSGridView;
  numberOfCells(): NSInteger;
  xPlacement(): NSGridCellPlacement;
  setXPlacement(xPlacement: NSGridCellPlacement): void;
  width(): CGFloat;
  setWidth(width: CGFloat): void;
  leadingPadding(): CGFloat;
  setLeadingPadding(leadingPadding: CGFloat): void;
  trailingPadding(): CGFloat;
  setTrailingPadding(trailingPadding: CGFloat): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
}
declare const NSGridColumn: {
  alloc(): NSGridColumnAllocator;
}

interface NSGridCellAllocator<InitializedType = NSGridCell> extends NSObjectAllocator<NSGridCell> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSGridCell extends NSObject, INSCoding {

  contentView(): NSView;
  setContentView(contentView: NSView): void;
  row(): NSGridRow;
  column(): NSGridColumn;
  xPlacement(): NSGridCellPlacement;
  setXPlacement(xPlacement: NSGridCellPlacement): void;
  yPlacement(): NSGridCellPlacement;
  setYPlacement(yPlacement: NSGridCellPlacement): void;
  rowAlignment(): NSGridRowAlignment;
  setRowAlignment(rowAlignment: NSGridRowAlignment): void;
  customPlacementConstraints(): NSArray<any>;
  setCustomPlacementConstraints(customPlacementConstraints: NSArray<any> | any[]): void;
}
declare const NSGridCell: {
  alloc(): NSGridCellAllocator;
  emptyContentView(): NSView;

}

declare enum NSGridCellPlacement {
  NSGridCellPlacementInherited = 0,
  NSGridCellPlacementNone,
  NSGridCellPlacementLeading,
  NSGridCellPlacementTop,
  NSGridCellPlacementTrailing,
  NSGridCellPlacementBottom,
  NSGridCellPlacementCenter,
  NSGridCellPlacementFill,
}

declare enum NSGridRowAlignment {
  NSGridRowAlignmentInherited = 0,
  NSGridRowAlignmentNone,
  NSGridRowAlignmentFirstBaseline,
  NSGridRowAlignmentLastBaseline,
}

interface NSGroupTouchBarItemAllocator<InitializedType = NSGroupTouchBarItem> extends NSTouchBarItemAllocator<NSGroupTouchBarItem> {}
interface NSGroupTouchBarItem extends NSTouchBarItem {

  groupTouchBar(): NSTouchBar;
  setGroupTouchBar(groupTouchBar: NSTouchBar): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
  groupUserInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setGroupUserInterfaceLayoutDirection(groupUserInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  prefersEqualWidths(): boolean;
  setPrefersEqualWidths(prefersEqualWidths: boolean): void;
  preferredItemWidth(): CGFloat;
  setPreferredItemWidth(preferredItemWidth: CGFloat): void;
  effectiveCompressionOptions(): NSUserInterfaceCompressionOptions;
  prioritizedCompressionOptions(): NSArray<any>;
  setPrioritizedCompressionOptions(prioritizedCompressionOptions: NSArray<any> | any[]): void;
}
declare const NSGroupTouchBarItem: {
  alloc(): NSGroupTouchBarItemAllocator;  groupItemWithIdentifier_items(identifier: NSTouchBarItemIdentifier, items: NSArray<any> | any[]): NSGroupTouchBarItem;
  groupItemWithIdentifier_items_allowedCompressionOptions(identifier: NSTouchBarItemIdentifier, items: NSArray<any> | any[], allowedCompressionOptions: NSUserInterfaceCompressionOptions): NSGroupTouchBarItem;
  alertStyleGroupItemWithIdentifier(identifier: NSTouchBarItemIdentifier): NSGroupTouchBarItem;

}

interface NSHapticFeedbackManagerAllocator<InitializedType = NSHapticFeedbackManager> extends NSObjectAllocator<NSHapticFeedbackManager> {}
interface NSHapticFeedbackManager extends NSObject {
}
declare const NSHapticFeedbackManager: {
  alloc(): NSHapticFeedbackManagerAllocator;
  defaultPerformer(): any;

}

interface INSHapticFeedbackPerformer {
  performFeedbackPattern_performanceTime(pattern: NSHapticFeedbackPattern, performanceTime: NSHapticFeedbackPerformanceTime): void;
}

declare enum NSHapticFeedbackPattern {
  NSHapticFeedbackPatternGeneric = 0,
  NSHapticFeedbackPatternAlignment,
  NSHapticFeedbackPatternLevelChange,
}

declare enum NSHapticFeedbackPerformanceTime {
  NSHapticFeedbackPerformanceTimeDefault = 0,
  NSHapticFeedbackPerformanceTimeNow,
  NSHapticFeedbackPerformanceTimeDrawCompleted,
}

interface NSHelpManagerAllocator<InitializedType = NSHelpManager> extends NSObjectAllocator<NSHelpManager> {}
interface NSHelpManager extends NSObject {
  setContextHelp_forObject(attrString: NSAttributedString, object: any): void;
  removeContextHelpForObject(object: any): void;
  contextHelpForObject(object: any): NSAttributedString;
  showContextHelpForObject_locationHint(object: any, pt: NSPoint): boolean;
  openHelpAnchor_inBook(anchor: NSHelpAnchorName, book: NSHelpBookName | null): void;
  findString_inBook(query: NSString | string, book: NSHelpBookName | null): void;
  registerBooksInBundle(bundle: NSBundle): boolean;
}
declare const NSHelpManager: {
  alloc(): NSHelpManagerAllocator;
  sharedHelpManager(): NSHelpManager;
  contextHelpModeActive(): boolean;
  setContextHelpModeActive(contextHelpModeActive: boolean): void;

}

declare type NSHelpBookName = NSString

declare type NSHelpAnchorName = NSString

declare type NSHelpManagerContextHelpKey = NSString

interface NSImageAllocator<InitializedType = NSImage> extends NSObjectAllocator<NSImage> {
  initWithSize(size: NSSize): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithData(data: NSData): InitializedType;
  initWithContentsOfFile(fileName: NSString | string): InitializedType;
  initWithContentsOfURL(url: NSURL): InitializedType;
  initByReferencingFile(fileName: NSString | string): InitializedType;
  initByReferencingURL(url: NSURL): InitializedType;
  initWithIconRef(iconRef: IconRef): InitializedType;
  initWithPasteboard(pasteboard: NSPasteboard): InitializedType;
  initWithDataIgnoringOrientation(data: NSData): InitializedType;
  initWithCGImage_size(cgImage: CGImageRef, size: NSSize): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): InitializedType;
}
interface NSImage extends NSObject, INSCopying, INSCoding, INSSecureCoding, INSPasteboardReading, INSPasteboardWriting {
  setName(string: NSImageName | null): boolean;
  name(): NSImageName;
  drawAtPoint_fromRect_operation_fraction(point: NSPoint, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  drawInRect_fromRect_operation_fraction(rect: NSRect, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  drawInRect_fromRect_operation_fraction_respectFlipped_hints(dstSpacePortionRect: NSRect, srcSpacePortionRect: NSRect, op: NSCompositingOperation, requestedAlpha: CGFloat, respectContextIsFlipped: boolean, hints: NSDictionary<any, any> | {[key: string]: any} | null): void;
  drawRepresentation_inRect(imageRep: NSImageRep, rect: NSRect): boolean;
  drawInRect(rect: NSRect): void;
  recache(): void;
  TIFFRepresentationUsingCompression_factor(comp: NSTIFFCompression, factor: number): NSData;
  addRepresentations(imageReps: NSArray<any> | any[]): void;
  addRepresentation(imageRep: NSImageRep): void;
  removeRepresentation(imageRep: NSImageRep): void;
  lockFocus(): void;
  lockFocusFlipped(flipped: boolean): void;
  unlockFocus(): void;
  bestRepresentationForDevice(deviceDescription: NSDictionary<any, any> | {[key: string]: any}): NSImageRep;
  cancelIncrementalLoad(): void;
  isTemplate(): boolean;
  setTemplate(isTemplate: boolean): void;
  CGImageForProposedRect_context_hints_CF_RETURNS_NOT_RETAINED(proposedDestRect: NSRect | null, referenceContext: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null): CGImageRef;
  bestRepresentationForRect_context_hints(rect: NSRect, referenceContext: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null): NSImageRep;
  hitTestRect_withImageDestinationRect_context_hints_flipped(testRectDestSpace: NSRect, imageRectDestSpace: NSRect, context: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null, flipped: boolean): boolean;
  recommendedLayerContentsScale(preferredContentsScale: CGFloat): CGFloat;
  layerContentsForContentsScale(layerContentsScale: CGFloat): any;
  setFlipped(flag: boolean): void;
  isFlipped(): boolean;
  dissolveToPoint_fraction(point: NSPoint, fraction: CGFloat): void;
  dissolveToPoint_fromRect_fraction(point: NSPoint, rect: NSRect, fraction: CGFloat): void;
  compositeToPoint_operation(point: NSPoint, op: NSCompositingOperation): void;
  compositeToPoint_fromRect_operation(point: NSPoint, rect: NSRect, op: NSCompositingOperation): void;
  compositeToPoint_operation_fraction(point: NSPoint, op: NSCompositingOperation, delta: CGFloat): void;
  compositeToPoint_fromRect_operation_fraction(point: NSPoint, rect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  lockFocusOnRepresentation(imageRepresentation: NSImageRep): void;
  setScalesWhenResized(flag: boolean): void;
  scalesWhenResized(): boolean;
  setDataRetained(flag: boolean): void;
  isDataRetained(): boolean;
  setCachedSeparately(flag: boolean): void;
  isCachedSeparately(): boolean;
  setCacheDepthMatchesImageDepth(flag: boolean): void;
  cacheDepthMatchesImageDepth(): boolean;
  tintedAsPrimaryImageForOwner(owner: any): NSImage;
  tintedAsSecondaryImageForOwner(owner: any): NSImage;
  tintedAsUnselectedImageForOwner_isSharedObject(owner: any, isShared: boolean): NSImage;
  tintedAsSelectedImageForOwner(owner: any): NSImage;
  badgedAs_forOwner(badgeType: MSLayerPreviewBadgeType, owner: any): NSImage;
  badgedWithImage_maskImage_offset_forOwner(badgeImage: NSImage, maskImage: NSImage, offset: NSPoint, owner: any): NSImage;
  badgedWithImageNamed_maskImageNamed_offset_forOwner(badgeName: NSString | string, badgeMaskName: NSString | string, offset: NSPoint, owner: any): NSImage;
  drawAtPoint(point: NSPoint): void;
  drawAtPoint_fraction(point: NSPoint, delta: CGFloat): void;
  scaledImageToSize(aSize: NSSize): any;
  drawProportionallyInRect_operation_fraction(rect: NSRect, op: NSCompositingOperation, frac: CGFloat): void;
  drawInRect_fraction(rect: NSRect, delta: CGFloat): void;
  selectedImage(): NSImage;
  hoverImage(): NSImage;
  pressedImage(): NSImage;
  altImage(): NSImage;
  highlightImage(): NSImage;
  drawFlippedAtPoint(point: NSPoint): void;
  drawFlippedAtPoint_fraction(point: NSPoint, fraction: CGFloat): void;
  firstBitmapImageRepOrCreateIfNecessary(): NSBitmapImageRep;
  firstBitmapImageRepOrCreateIfNecessaryPreservingPixelSize(preservePixelSize: boolean): NSBitmapImageRep;
  firstBitmapImageRep(): NSBitmapImageRep;
  firstBitmapImageRepOfScale(scale: CGFloat): NSBitmapImageRep;
  bitSafeBitmapImageRep(): NSBitmapImageRep;
  drawInRect_fromRect_fraction_respectFlipped_colorSpace(inRect: NSRect, fromRect: NSRect, fraction: CGFloat, isFlipped: boolean, space: NSColorSpace): void;
  isVectorImage(): boolean;
  imageWithPadding(padding: NSUInteger): NSImage;
  isImageSizeLargerThan(targetSize: NSSize): boolean;
  pixelSize(): NSSize;
  imageWithShadow_padding(shadow: NSShadow, padding: NSUInteger): NSImage;
  thumbWithSize_cornerRadius(size: NSSize, cornerRadius: CGFloat): NSImage;
  tintedWithColor(color: NSColor): NSImage;
  tintedWithColor_compositingOperation(color: NSColor, op: NSCompositingOperation): NSImage;
  tintedWithColor_forOwner(color: NSColor, imageOwner: any | null): NSImage;
  horizontallyFlipped(): NSImage;
  verticallyFlipped(): NSImage;
  imageHasAlpha(): boolean;
  dataForArchiving(): NSData;
  hasPDFData(): boolean;
  PDFImageRep(): NSPDFImageRep;
  hasEPSData(): boolean;
  EPSImageRep(): NSEPSImageRep;
  bitmapData(): NSData;

  size(): NSSize;
  setSize(size: NSSize): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  usesEPSOnResolutionMismatch(): boolean;
  setUsesEPSOnResolutionMismatch(usesEPSOnResolutionMismatch: boolean): void;
  prefersColorMatch(): boolean;
  setPrefersColorMatch(prefersColorMatch: boolean): void;
  matchesOnMultipleResolution(): boolean;
  setMatchesOnMultipleResolution(matchesOnMultipleResolution: boolean): void;
  matchesOnlyOnBestFittingAxis(): boolean;
  setMatchesOnlyOnBestFittingAxis(matchesOnlyOnBestFittingAxis: boolean): void;
  TIFFRepresentation(): NSData;
  representations(): NSArray<any>;
  valid(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  cacheMode(): NSImageCacheMode;
  setCacheMode(cacheMode: NSImageCacheMode): void;
  alignmentRect(): NSRect;
  setAlignmentRect(alignmentRect: NSRect): void;
  template(): boolean;
  setTemplate(template: boolean): void;
  accessibilityDescription(): NSString;
  setAccessibilityDescription(accessibilityDescription: NSString | string): void;
  capInsets(): NSEdgeInsets;
  setCapInsets(capInsets: NSEdgeInsets): void;
  resizingMode(): NSImageResizingMode;
  setResizingMode(resizingMode: NSImageResizingMode): void;
  embeddedXlinkValue(): NSString;
}
declare const NSImage: {
  alloc(): NSImageAllocator;  imageNamed(name: NSImageName): NSImage;
  imageWithSize_flipped_drawingHandler(size: NSSize, drawingHandlerShouldBeCalledWithFlippedContext: boolean, drawingHandler: Block): NSImage;
  imageUnfilteredFileTypes(): NSArray<any>;
  imageUnfilteredPasteboardTypes(): NSArray<any>;
  imageFileTypes(): NSArray<any>;
  imagePasteboardTypes(): NSArray<any>;
  canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  bundledImageNamed(imageName: NSString | string): NSImage;
  PDFImageWithSize_flipped_drawingHandler(size: NSSize, drawingHandlerShouldBeCalledWithFlippedContext: boolean, drawingHandler: Block): NSImage;
  pngDataByFixingInvalidGamma(data: NSData): NSData;
  drawImageWithSize_withBlock(aSize: NSSize, aBlock: BCVoidBlock): NSImage;
  drawImageFlippedWithSize_withBlock(aSize: NSSize, aBlock: BCVoidBlock): NSImage;
  drawImageFlipped_withSize_withBlock(shouldFlip: boolean, aSize: NSSize, aBlock: BCVoidBlock): NSImage;
  imageFromDataArchive(data: NSData): NSImage;

  imageTypes(): NSArray<any>;
  imageUnfilteredTypes(): NSArray<any>;

}

interface INSImageDelegate {
  imageDidNotDraw_inRect(sender: NSImage, rect: NSRect): NSImage;
  image_willLoadRepresentation(image: NSImage, rep: NSImageRep): void;
  image_didLoadRepresentationHeader(image: NSImage, rep: NSImageRep): void;
  image_didLoadPartOfRepresentation_withValidRows(image: NSImage, rep: NSImageRep, rows: NSInteger): void;
  image_didLoadRepresentation_withStatus(image: NSImage, rep: NSImageRep, status: NSImageLoadStatus): void;
}

declare type NSImageName = NSString

declare enum NSImageLoadStatus {
  NSImageLoadStatusCompleted,
  NSImageLoadStatusCancelled,
  NSImageLoadStatusInvalidData,
  NSImageLoadStatusUnexpectedEOF,
  NSImageLoadStatusReadError,
}

declare enum NSImageCacheMode {
  NSImageCacheDefault,
  NSImageCacheAlways,
  NSImageCacheBySize,
  NSImageCacheNever,
}

declare enum NSImageResizingMode {
  NSImageResizingModeStretch,
  NSImageResizingModeTile,
}

interface NSImageCellAllocator<InitializedType = NSImageCell> extends NSCellAllocator<NSImageCell> {}
interface NSImageCell extends NSCell, INSCopying, INSCoding {

  imageAlignment(): NSImageAlignment;
  setImageAlignment(imageAlignment: NSImageAlignment): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  imageFrameStyle(): NSImageFrameStyle;
  setImageFrameStyle(imageFrameStyle: NSImageFrameStyle): void;
}
declare const NSImageCell: {
  alloc(): NSImageCellAllocator;
}

declare enum NSImageAlignment {
  NSImageAlignCenter = 0,
  NSImageAlignTop,
  NSImageAlignTopLeft,
  NSImageAlignTopRight,
  NSImageAlignLeft,
  NSImageAlignBottom,
  NSImageAlignBottomLeft,
  NSImageAlignBottomRight,
  NSImageAlignRight,
}

declare enum NSImageFrameStyle {
  NSImageFrameNone = 0,
  NSImageFramePhoto,
  NSImageFrameGrayBezel,
  NSImageFrameGroove,
  NSImageFrameButton,
}

interface NSImageRepAllocator<InitializedType = NSImageRep> extends NSObjectAllocator<NSImageRep> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSImageRep extends NSObject, INSCopying, INSCoding {
  draw(): boolean;
  drawAtPoint(point: NSPoint): boolean;
  drawInRect(rect: NSRect): boolean;
  drawInRect_fromRect_operation_fraction_respectFlipped_hints(dstSpacePortionRect: NSRect, srcSpacePortionRect: NSRect, op: NSCompositingOperation, requestedAlpha: CGFloat, respectContextIsFlipped: boolean, hints: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  CGImageForProposedRect_context_hints_CF_RETURNS_NOT_RETAINED(proposedDestRect: NSRect | null, context: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null): CGImageRef;

  size(): NSSize;
  setSize(size: NSSize): void;
  alpha(): boolean;
  setAlpha(alpha: boolean): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
  colorSpaceName(): NSColorSpaceName;
  setColorSpaceName(colorSpaceName: NSColorSpaceName): void;
  bitsPerSample(): NSInteger;
  setBitsPerSample(bitsPerSample: NSInteger): void;
  pixelsWide(): NSInteger;
  setPixelsWide(pixelsWide: NSInteger): void;
  pixelsHigh(): NSInteger;
  setPixelsHigh(pixelsHigh: NSInteger): void;
  layoutDirection(): NSImageLayoutDirection;
  setLayoutDirection(layoutDirection: NSImageLayoutDirection): void;
}
declare const NSImageRep: {
  alloc(): NSImageRepAllocator;  registerImageRepClass(imageRepClass: any): void;
  unregisterImageRepClass(imageRepClass: any): void;
  imageRepClassForFileType(type: NSString | string): any;
  imageRepClassForPasteboardType(type: NSPasteboardType): any;
  imageRepClassForType(type: NSString | string): any;
  imageRepClassForData(data: NSData): any;
  canInitWithData(data: NSData): boolean;
  imageUnfilteredFileTypes(): NSArray<any>;
  imageUnfilteredPasteboardTypes(): NSArray<any>;
  imageFileTypes(): NSArray<any>;
  imagePasteboardTypes(): NSArray<any>;
  canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  imageRepsWithContentsOfFile(filename: NSString | string): NSArray<any>;
  imageRepWithContentsOfFile(filename: NSString | string): NSImageRep;
  imageRepsWithContentsOfURL(url: NSURL): NSArray<any>;
  imageRepWithContentsOfURL(url: NSURL): NSImageRep;
  imageRepsWithPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  imageRepWithPasteboard(pasteboard: NSPasteboard): NSImageRep;

  registeredImageRepClasses(): NSArray<any>;
  imageUnfilteredTypes(): NSArray<any>;
  imageTypes(): NSArray<any>;

}

declare type NSImageHintKey = NSString

declare enum NSImageLayoutDirection {
  NSImageLayoutDirectionUnspecified = -1,
  NSImageLayoutDirectionLeftToRight = 2,
  NSImageLayoutDirectionRightToLeft = 3,
}

interface NSImageViewAllocator<InitializedType = NSImageView> extends NSControlAllocator<NSImageView> {}
interface NSImageView extends NSControl, INSAccessibilityImage {

  image(): NSImage;
  setImage(image: NSImage): void;
  imageAlignment(): NSImageAlignment;
  setImageAlignment(imageAlignment: NSImageAlignment): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  imageFrameStyle(): NSImageFrameStyle;
  setImageFrameStyle(imageFrameStyle: NSImageFrameStyle): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  animates(): boolean;
  setAnimates(animates: boolean): void;
  allowsCutCopyPaste(): boolean;
  setAllowsCutCopyPaste(allowsCutCopyPaste: boolean): void;
}
declare const NSImageView: {
  alloc(): NSImageViewAllocator;  imageViewWithImage(image: NSImage): NSImageView;

}

interface NSInputManagerAllocator<InitializedType = NSInputManager> extends NSObjectAllocator<NSInputManager> {
  initWithName_host(inputServerName: NSString | string, hostName: NSString | string): InitializedType;
}
interface NSInputManager extends NSObject, INSTextInput {
  localizedInputManagerName(): NSString;
  markedTextAbandoned(cli: any): void;
  markedTextSelectionChanged_client(newSel: NSRange, cli: any): void;
  wantsToInterpretAllKeystrokes(): boolean;
  language(): NSString;
  image(): NSImage;
  server(): NSInputServer;
  wantsToHandleMouseEvents(): boolean;
  handleMouseEvent(mouseEvent: NSEvent): boolean;
  wantsToDelayTextChangeNotifications(): boolean;
}
declare const NSInputManager: {
  alloc(): NSInputManagerAllocator;  currentInputManager(): NSInputManager;
  cycleToNextInputLanguage(sender: any | null): void;
  cycleToNextInputServerInLanguage(sender: any | null): void;

}

interface INSTextInput {
  insertText(string: any): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange(string: any, selRange: NSRange): void;
  unmarkText(): void;
  hasMarkedText(): boolean;
  conversationIdentifier(): NSInteger;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  firstRectForCharacterRange(range: NSRange): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  validAttributesForMarkedText(): NSArray<any>;
}

interface NSInputServerAllocator<InitializedType = NSInputServer> extends NSObjectAllocator<NSInputServer> {
  initWithDelegate_name(delegate: any, name: NSString | string): InitializedType;
}
interface NSInputServer extends NSObject, INSInputServiceProvider, INSInputServerMouseTracker {
}
declare const NSInputServer: {
  alloc(): NSInputServerAllocator;
}

interface INSInputServiceProvider {
  insertText_client(string: any, sender: any): void;
  doCommandBySelector_client(selector: string, sender: any): void;
  markedTextAbandoned(sender: any | null): void;
  markedTextSelectionChanged_client(newSel: NSRange, sender: any): void;
  terminate(sender: any | null): void;
  canBeDisabled(): boolean;
  wantsToInterpretAllKeystrokes(): boolean;
  wantsToHandleMouseEvents(): boolean;
  wantsToDelayTextChangeNotifications(): boolean;
  inputClientBecomeActive(sender: any | null): void;
  inputClientResignActive(sender: any | null): void;
  inputClientEnabled(sender: any | null): void;
  inputClientDisabled(sender: any | null): void;
  activeConversationWillChange_fromOldConversation(sender: any, oldConversation: NSInteger): void;
  activeConversationChanged_toNewConversation(sender: any, newConversation: NSInteger): void;
}

interface INSInputServerMouseTracker {
  mouseDownOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseDraggedOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseUpOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): void;
}

interface NSResponderAllocator<InitializedType = NSResponder> extends NSObjectAllocator<NSResponder> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSResponder extends NSObject, INSCoding {
  interfaceStyle(): NSInterfaceStyle;
  setInterfaceStyle(interfaceStyle: NSInterfaceStyle): void;
  tryToPerform_with(action: string, object: any | null): boolean;
  performKeyEquivalent(event: NSEvent): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  mouseDown(event: NSEvent): void;
  rightMouseDown(event: NSEvent): void;
  otherMouseDown(event: NSEvent): void;
  mouseUp(event: NSEvent): void;
  rightMouseUp(event: NSEvent): void;
  otherMouseUp(event: NSEvent): void;
  mouseMoved(event: NSEvent): void;
  mouseDragged(event: NSEvent): void;
  scrollWheel(event: NSEvent): void;
  rightMouseDragged(event: NSEvent): void;
  otherMouseDragged(event: NSEvent): void;
  mouseEntered(event: NSEvent): void;
  mouseExited(event: NSEvent): void;
  keyDown(event: NSEvent): void;
  keyUp(event: NSEvent): void;
  flagsChanged(event: NSEvent): void;
  tabletPoint(event: NSEvent): void;
  tabletProximity(event: NSEvent): void;
  cursorUpdate(event: NSEvent): void;
  magnifyWithEvent(event: NSEvent): void;
  rotateWithEvent(event: NSEvent): void;
  swipeWithEvent(event: NSEvent): void;
  beginGestureWithEvent(event: NSEvent): void;
  endGestureWithEvent(event: NSEvent): void;
  smartMagnifyWithEvent(event: NSEvent): void;
  touchesBeganWithEvent(event: NSEvent): void;
  touchesMovedWithEvent(event: NSEvent): void;
  touchesEndedWithEvent(event: NSEvent): void;
  touchesCancelledWithEvent(event: NSEvent): void;
  quickLookWithEvent(event: NSEvent): void;
  pressureChangeWithEvent(event: NSEvent): void;
  noResponderFor(eventSelector: string): void;
  becomeFirstResponder(): boolean;
  resignFirstResponder(): boolean;
  interpretKeyEvents(eventArray: NSArray<any> | any[]): void;
  flushBufferedKeyEvents(): void;
  showContextHelp(sender: any | null): void;
  helpRequested(eventPtr: NSEvent): void;
  shouldBeTreatedAsInkEvent(event: NSEvent): boolean;
  wantsScrollEventsForSwipeTrackingOnAxis(axis: NSEventGestureAxis): boolean;
  wantsForwardedScrollEventsForAxis(axis: NSEventGestureAxis): boolean;
  supplementalTargetForAction_sender(action: string, sender: any | null): any;
  insertText(insertString: any): void;
  doCommandBySelector(selector: string): void;
  moveForward(sender: any | null): void;
  moveRight(sender: any | null): void;
  moveBackward(sender: any | null): void;
  moveLeft(sender: any | null): void;
  moveUp(sender: any | null): void;
  moveDown(sender: any | null): void;
  moveWordForward(sender: any | null): void;
  moveWordBackward(sender: any | null): void;
  moveToBeginningOfLine(sender: any | null): void;
  moveToEndOfLine(sender: any | null): void;
  moveToBeginningOfParagraph(sender: any | null): void;
  moveToEndOfParagraph(sender: any | null): void;
  moveToEndOfDocument(sender: any | null): void;
  moveToBeginningOfDocument(sender: any | null): void;
  pageDown(sender: any | null): void;
  pageUp(sender: any | null): void;
  centerSelectionInVisibleArea(sender: any | null): void;
  moveBackwardAndModifySelection(sender: any | null): void;
  moveForwardAndModifySelection(sender: any | null): void;
  moveWordForwardAndModifySelection(sender: any | null): void;
  moveWordBackwardAndModifySelection(sender: any | null): void;
  moveUpAndModifySelection(sender: any | null): void;
  moveDownAndModifySelection(sender: any | null): void;
  moveToBeginningOfLineAndModifySelection(sender: any | null): void;
  moveToEndOfLineAndModifySelection(sender: any | null): void;
  moveToBeginningOfParagraphAndModifySelection(sender: any | null): void;
  moveToEndOfParagraphAndModifySelection(sender: any | null): void;
  moveToEndOfDocumentAndModifySelection(sender: any | null): void;
  moveToBeginningOfDocumentAndModifySelection(sender: any | null): void;
  pageDownAndModifySelection(sender: any | null): void;
  pageUpAndModifySelection(sender: any | null): void;
  moveParagraphForwardAndModifySelection(sender: any | null): void;
  moveParagraphBackwardAndModifySelection(sender: any | null): void;
  moveWordRight(sender: any | null): void;
  moveWordLeft(sender: any | null): void;
  moveRightAndModifySelection(sender: any | null): void;
  moveLeftAndModifySelection(sender: any | null): void;
  moveWordRightAndModifySelection(sender: any | null): void;
  moveWordLeftAndModifySelection(sender: any | null): void;
  moveToLeftEndOfLine(sender: any | null): void;
  moveToRightEndOfLine(sender: any | null): void;
  moveToLeftEndOfLineAndModifySelection(sender: any | null): void;
  moveToRightEndOfLineAndModifySelection(sender: any | null): void;
  scrollPageUp(sender: any | null): void;
  scrollPageDown(sender: any | null): void;
  scrollLineUp(sender: any | null): void;
  scrollLineDown(sender: any | null): void;
  scrollToBeginningOfDocument(sender: any | null): void;
  scrollToEndOfDocument(sender: any | null): void;
  transpose(sender: any | null): void;
  transposeWords(sender: any | null): void;
  selectAll(sender: any | null): void;
  selectParagraph(sender: any | null): void;
  selectLine(sender: any | null): void;
  selectWord(sender: any | null): void;
  indent(sender: any | null): void;
  insertTab(sender: any | null): void;
  insertBacktab(sender: any | null): void;
  insertNewline(sender: any | null): void;
  insertParagraphSeparator(sender: any | null): void;
  insertNewlineIgnoringFieldEditor(sender: any | null): void;
  insertTabIgnoringFieldEditor(sender: any | null): void;
  insertLineBreak(sender: any | null): void;
  insertContainerBreak(sender: any | null): void;
  insertSingleQuoteIgnoringSubstitution(sender: any | null): void;
  insertDoubleQuoteIgnoringSubstitution(sender: any | null): void;
  changeCaseOfLetter(sender: any | null): void;
  uppercaseWord(sender: any | null): void;
  lowercaseWord(sender: any | null): void;
  capitalizeWord(sender: any | null): void;
  deleteForward(sender: any | null): void;
  deleteBackward(sender: any | null): void;
  deleteBackwardByDecomposingPreviousCharacter(sender: any | null): void;
  deleteWordForward(sender: any | null): void;
  deleteWordBackward(sender: any | null): void;
  deleteToBeginningOfLine(sender: any | null): void;
  deleteToEndOfLine(sender: any | null): void;
  deleteToBeginningOfParagraph(sender: any | null): void;
  deleteToEndOfParagraph(sender: any | null): void;
  yank(sender: any | null): void;
  complete(sender: any | null): void;
  setMark(sender: any | null): void;
  deleteToMark(sender: any | null): void;
  selectToMark(sender: any | null): void;
  swapWithMark(sender: any | null): void;
  cancelOperation(sender: any | null): void;
  makeBaseWritingDirectionNatural(sender: any | null): void;
  makeBaseWritingDirectionLeftToRight(sender: any | null): void;
  makeBaseWritingDirectionRightToLeft(sender: any | null): void;
  makeTextWritingDirectionNatural(sender: any | null): void;
  makeTextWritingDirectionLeftToRight(sender: any | null): void;
  makeTextWritingDirectionRightToLeft(sender: any | null): void;
  quickLookPreviewItems(sender: any | null): void;
  validateProposedFirstResponder_forEvent(responder: NSResponder, event: NSEvent | null): boolean;
  presentError_modalForWindow_delegate_didPresentSelector_contextInfo(error: NSError, window: NSWindow, delegate: any | null, didPresentSelector: string | null, contextInfo: void | null): void;
  presentError(error: NSError): boolean;
  willPresentError(error: NSError): NSError;
  performTextFinderAction(sender: any | null): void;
  newWindowForTab(sender: any | null): IBAction;
  performMnemonic(string: NSString | string): boolean;
  makeTouchBar(): NSTouchBar;
  updateUserActivityState(userActivity: NSUserActivity): void;
  restoreUserActivityState(userActivity: NSUserActivity): void;
  encodeRestorableStateWithCoder(coder: NSCoder): void;
  encodeRestorableStateWithCoder_backgroundQueue(coder: NSCoder, queue: NSOperationQueue): void;
  restoreStateWithCoder(coder: NSCoder): void;
  invalidateRestorableState(): void;
  followsResponder(aResponder: NSResponder): boolean;

  nextResponder(): NSResponder;
  setNextResponder(nextResponder: NSResponder): void;
  acceptsFirstResponder(): boolean;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  undoManager(): NSUndoManager;
  touchBar(): NSTouchBar;
  setTouchBar(touchBar: NSTouchBar): void;
  userActivity(): NSUserActivity;
  setUserActivity(userActivity: NSUserActivity): void;
  supportsTouchBar(): boolean;
}
declare const NSResponder: {
  alloc(): NSResponderAllocator;
  restorableStateKeyPaths(): NSArray<any>;

}

declare type NSInterfaceStyle = NSUInteger

declare type NSBindingName = NSString

declare type NSBindingOption = NSString

declare type NSBindingInfoKey = NSString

interface NSLayoutAnchorAllocator<InitializedType = NSLayoutAnchor> extends NSObjectAllocator<NSLayoutAnchor> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSLayoutAnchor extends NSObject, INSCopying, INSCoding {
  constraintEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;
  constraintEqualToAnchor_constant(anchor: NSLayoutAnchor, c: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor_constant(anchor: NSLayoutAnchor, c: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor_constant(anchor: NSLayoutAnchor, c: CGFloat): NSLayoutConstraint;
  copyWithZone(zone: NSZone): any;
  encodeWithCoder(aCoder: NSCoder): void;

  name(): NSString;
  setName(name: NSString): void;
  item(): any;
  setItem(item: any): void;
  hasAmbiguousLayout(): boolean;
  setHasAmbiguousLayout(hasAmbiguousLayout: boolean): void;
  constraintsAffectingLayout(): NSArray<any>;
  setConstraintsAffectingLayout(constraintsAffectingLayout: NSArray<any>): void;
}
declare const NSLayoutAnchor: {
  alloc(): NSLayoutAnchorAllocator;
}

interface NSLayoutXAxisAnchorAllocator<InitializedType = NSLayoutXAxisAnchor> extends NSLayoutAnchorAllocator<NSLayoutXAxisAnchor> {}
interface NSLayoutXAxisAnchor extends NSLayoutAnchor {
  anchorWithOffsetToAnchor(otherAnchor: NSLayoutXAxisAnchor): NSLayoutDimension;
}
declare const NSLayoutXAxisAnchor: {
  alloc(): NSLayoutXAxisAnchorAllocator;
}

interface NSLayoutYAxisAnchorAllocator<InitializedType = NSLayoutYAxisAnchor> extends NSLayoutAnchorAllocator<NSLayoutYAxisAnchor> {}
interface NSLayoutYAxisAnchor extends NSLayoutAnchor {
  anchorWithOffsetToAnchor(otherAnchor: NSLayoutYAxisAnchor): NSLayoutDimension;
}
declare const NSLayoutYAxisAnchor: {
  alloc(): NSLayoutYAxisAnchorAllocator;
}

interface NSLayoutDimensionAllocator<InitializedType = NSLayoutDimension> extends NSLayoutAnchorAllocator<NSLayoutDimension> {}
interface NSLayoutDimension extends NSLayoutAnchor {
  constraintEqualToConstant(c: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToConstant(c: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToConstant(c: CGFloat): NSLayoutConstraint;
  constraintEqualToAnchor_multiplier(anchor: NSLayoutDimension, m: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor_multiplier(anchor: NSLayoutDimension, m: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor_multiplier(anchor: NSLayoutDimension, m: CGFloat): NSLayoutConstraint;
  constraintEqualToAnchor_multiplier_constant(anchor: NSLayoutDimension, m: CGFloat, c: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor_multiplier_constant(anchor: NSLayoutDimension, m: CGFloat, c: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor_multiplier_constant(anchor: NSLayoutDimension, m: CGFloat, c: CGFloat): NSLayoutConstraint;
}
declare const NSLayoutDimension: {
  alloc(): NSLayoutDimensionAllocator;
}

interface NSLayoutConstraintAllocator<InitializedType = NSLayoutConstraint> extends NSObjectAllocator<NSLayoutConstraint> {}
interface NSLayoutConstraint extends NSObject, INSAnimatablePropertyContainer {

  priority(): NSLayoutPriority;
  setPriority(priority: NSLayoutPriority): void;
  shouldBeArchived(): boolean;
  setShouldBeArchived(shouldBeArchived: boolean): void;
  firstItem(): any;
  firstAttribute(): NSLayoutAttribute;
  secondItem(): any;
  secondAttribute(): NSLayoutAttribute;
  firstAnchor(): NSLayoutAnchor;
  secondAnchor(): NSLayoutAnchor;
  relation(): NSLayoutRelation;
  multiplier(): CGFloat;
  constant(): CGFloat;
  setConstant(constant: CGFloat): void;
  active(): boolean;
  setActive(active: boolean): void;
  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
}
declare const NSLayoutConstraint: {
  alloc(): NSLayoutConstraintAllocator;  constraintsWithVisualFormat_options_metrics_views(format: NSString | string, opts: NSLayoutFormatOptions, metrics: NSDictionary<any, any> | {[key: string]: any} | null, views: NSDictionary<any, any> | {[key: string]: any}): NSArray<any>;
  constraintWithItem_attribute_relatedBy_toItem_attribute_multiplier_constant(view1: any, attr1: NSLayoutAttribute, relation: NSLayoutRelation, view2: any | null, attr2: NSLayoutAttribute, multiplier: CGFloat, c: CGFloat): NSLayoutConstraint;
  activateConstraints(constraints: NSArray<any> | any[]): void;
  deactivateConstraints(constraints: NSArray<any> | any[]): void;

}

declare type NSLayoutPriority = number

declare enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual = -1,
  NSLayoutRelationEqual = 0,
  NSLayoutRelationGreaterThanOrEqual = 1,
}

declare enum NSLayoutAttribute {
  NSLayoutAttributeLeft = 1,
  NSLayoutAttributeRight,
  NSLayoutAttributeTop,
  NSLayoutAttributeBottom,
  NSLayoutAttributeLeading,
  NSLayoutAttributeTrailing,
  NSLayoutAttributeWidth,
  NSLayoutAttributeHeight,
  NSLayoutAttributeCenterX,
  NSLayoutAttributeCenterY,
  NSLayoutAttributeLastBaseline,
  NSLayoutAttributeBaseline,
  NSLayoutAttributeFirstBaseline,
  NSLayoutAttributeNotAnAttribute = 0,
}

declare enum NSLayoutFormatOptions {
  NSLayoutFormatAlignAllLeft,
  NSLayoutFormatAlignAllRight,
  NSLayoutFormatAlignAllTop,
  NSLayoutFormatAlignAllBottom,
  NSLayoutFormatAlignAllLeading,
  NSLayoutFormatAlignAllTrailing,
  NSLayoutFormatAlignAllCenterX,
  NSLayoutFormatAlignAllCenterY,
  NSLayoutFormatAlignAllBaseline,
  NSLayoutFormatAlignAllLastBaseline,
  NSLayoutFormatAlignAllFirstBaseline,
  NSLayoutFormatAlignmentMask = 0xFFFF,
  NSLayoutFormatDirectionLeadingToTrailing = 0 << 16,
  NSLayoutFormatDirectionLeftToRight = 1 << 16,
  NSLayoutFormatDirectionRightToLeft = 2 << 16,
  NSLayoutFormatDirectionMask = 0x3 << 16,
}

declare enum NSLayoutConstraintOrientation {
  NSLayoutConstraintOrientationHorizontal = 0,
  NSLayoutConstraintOrientationVertical = 1,
}

interface NSLayoutGuideAllocator<InitializedType = NSLayoutGuide> extends NSObjectAllocator<NSLayoutGuide> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSLayoutGuide extends NSObject, INSCoding, INSUserInterfaceItemIdentification {
  constraintsAffectingLayoutForOrientation(orientation: NSLayoutConstraintOrientation): NSArray<any>;

  frame(): NSRect;
  owningView(): NSView;
  setOwningView(owningView: NSView): void;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  leadingAnchor(): NSLayoutXAxisAnchor;
  trailingAnchor(): NSLayoutXAxisAnchor;
  leftAnchor(): NSLayoutXAxisAnchor;
  rightAnchor(): NSLayoutXAxisAnchor;
  topAnchor(): NSLayoutYAxisAnchor;
  bottomAnchor(): NSLayoutYAxisAnchor;
  widthAnchor(): NSLayoutDimension;
  heightAnchor(): NSLayoutDimension;
  centerXAnchor(): NSLayoutXAxisAnchor;
  centerYAnchor(): NSLayoutYAxisAnchor;
  hasAmbiguousLayout(): boolean;
}
declare const NSLayoutGuide: {
  alloc(): NSLayoutGuideAllocator;
}

interface NSLayoutManagerAllocator<InitializedType = NSLayoutManager> extends NSObjectAllocator<NSLayoutManager> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSLayoutManager extends NSObject, INSCoding {
  replaceTextStorage(newTextStorage: NSTextStorage): void;
  addTextContainer(container: NSTextContainer): void;
  insertTextContainer_atIndex(container: NSTextContainer, index: NSUInteger): void;
  removeTextContainerAtIndex(index: NSUInteger): void;
  textContainerChangedGeometry(container: NSTextContainer): void;
  textContainerChangedTextView(container: NSTextContainer): void;
  invalidateGlyphsForCharacterRange_changeInLength_actualCharacterRange(charRange: NSRange, delta: NSInteger, actualCharRange: NSRangePointer | null): void;
  invalidateLayoutForCharacterRange_actualCharacterRange(charRange: NSRange, actualCharRange: NSRangePointer | null): void;
  invalidateDisplayForCharacterRange(charRange: NSRange): void;
  invalidateDisplayForGlyphRange(glyphRange: NSRange): void;
  processEditingForTextStorage_edited_range_changeInLength_invalidatedRange(textStorage: NSTextStorage, editMask: NSTextStorageEditActions, newCharRange: NSRange, delta: NSInteger, invalidatedCharRange: NSRange): void;
  ensureGlyphsForCharacterRange(charRange: NSRange): void;
  ensureGlyphsForGlyphRange(glyphRange: NSRange): void;
  ensureLayoutForCharacterRange(charRange: NSRange): void;
  ensureLayoutForGlyphRange(glyphRange: NSRange): void;
  ensureLayoutForTextContainer(container: NSTextContainer): void;
  ensureLayoutForBoundingRect_inTextContainer(bounds: NSRect, container: NSTextContainer): void;
  setGlyphs_properties_characterIndexes_font_forGlyphRange(glyphs: CGGlyph, props: NSGlyphProperty, charIndexes: NSUInteger, aFont: NSFont, glyphRange: NSRange): void;
  CGGlyphAtIndex_isValidIndex(glyphIndex: NSUInteger, isValidIndex: boolean | null): CGGlyph;
  CGGlyphAtIndex(glyphIndex: NSUInteger): CGGlyph;
  isValidGlyphIndex(glyphIndex: NSUInteger): boolean;
  propertyForGlyphAtIndex(glyphIndex: NSUInteger): NSGlyphProperty;
  characterIndexForGlyphAtIndex(glyphIndex: NSUInteger): NSUInteger;
  glyphIndexForCharacterAtIndex(charIndex: NSUInteger): NSUInteger;
  getGlyphsInRange_glyphs_properties_characterIndexes_bidiLevels(glyphRange: NSRange, glyphBuffer: CGGlyph | null, props: NSGlyphProperty | null, charIndexBuffer: NSUInteger | null, bidiLevelBuffer: string | null): NSUInteger;
  setTextContainer_forGlyphRange(container: NSTextContainer, glyphRange: NSRange): void;
  setLineFragmentRect_forGlyphRange_usedRect(fragmentRect: NSRect, glyphRange: NSRange, usedRect: NSRect): void;
  setExtraLineFragmentRect_usedRect_textContainer(fragmentRect: NSRect, usedRect: NSRect, container: NSTextContainer): void;
  setLocation_forStartOfGlyphRange(location: NSPoint, glyphRange: NSRange): void;
  setNotShownAttribute_forGlyphAtIndex(flag: boolean, glyphIndex: NSUInteger): void;
  setDrawsOutsideLineFragment_forGlyphAtIndex(flag: boolean, glyphIndex: NSUInteger): void;
  setAttachmentSize_forGlyphRange(attachmentSize: NSSize, glyphRange: NSRange): void;
  getFirstUnlaidCharacterIndex_glyphIndex(charIndex: NSUInteger | null, glyphIndex: NSUInteger | null): void;
  firstUnlaidCharacterIndex(): NSUInteger;
  firstUnlaidGlyphIndex(): NSUInteger;
  textContainerForGlyphAtIndex_effectiveRange(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSTextContainer;
  textContainerForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null, flag: boolean): NSTextContainer;
  usedRectForTextContainer(container: NSTextContainer): NSRect;
  lineFragmentRectForGlyphAtIndex_effectiveRange(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  lineFragmentRectForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null, flag: boolean): NSRect;
  lineFragmentUsedRectForGlyphAtIndex_effectiveRange(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  lineFragmentUsedRectForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null, flag: boolean): NSRect;
  locationForGlyphAtIndex(glyphIndex: NSUInteger): NSPoint;
  notShownAttributeForGlyphAtIndex(glyphIndex: NSUInteger): boolean;
  drawsOutsideLineFragmentForGlyphAtIndex(glyphIndex: NSUInteger): boolean;
  attachmentSizeForGlyphAtIndex(glyphIndex: NSUInteger): NSSize;
  truncatedGlyphRangeInLineFragmentForGlyphAtIndex(glyphIndex: NSUInteger): NSRange;
  glyphRangeForCharacterRange_actualCharacterRange(charRange: NSRange, actualCharRange: NSRangePointer | null): NSRange;
  characterRangeForGlyphRange_actualGlyphRange(glyphRange: NSRange, actualGlyphRange: NSRangePointer | null): NSRange;
  glyphRangeForTextContainer(container: NSTextContainer): NSRange;
  rangeOfNominallySpacedGlyphsContainingIndex(glyphIndex: NSUInteger): NSRange;
  boundingRectForGlyphRange_inTextContainer(glyphRange: NSRange, container: NSTextContainer): NSRect;
  glyphRangeForBoundingRect_inTextContainer(bounds: NSRect, container: NSTextContainer): NSRange;
  glyphRangeForBoundingRectWithoutAdditionalLayout_inTextContainer(bounds: NSRect, container: NSTextContainer): NSRange;
  glyphIndexForPoint_inTextContainer_fractionOfDistanceThroughGlyph(point: NSPoint, container: NSTextContainer, partialFraction: CGFloat | null): NSUInteger;
  glyphIndexForPoint_inTextContainer(point: NSPoint, container: NSTextContainer): NSUInteger;
  fractionOfDistanceThroughGlyphForPoint_inTextContainer(point: NSPoint, container: NSTextContainer): CGFloat;
  characterIndexForPoint_inTextContainer_fractionOfDistanceBetweenInsertionPoints(point: NSPoint, container: NSTextContainer, partialFraction: CGFloat | null): NSUInteger;
  getLineFragmentInsertionPointsForCharacterAtIndex_alternatePositions_inDisplayOrder_positions_characterIndexes(charIndex: NSUInteger, aFlag: boolean, dFlag: boolean, positions: CGFloat | null, charIndexes: NSUInteger | null): NSUInteger;
  enumerateLineFragmentsForGlyphRange_usingBlock(glyphRange: NSRange, block: Block): void;
  enumerateEnclosingRectsForGlyphRange_withinSelectedGlyphRange_inTextContainer_usingBlock(glyphRange: NSRange, selectedRange: NSRange, textContainer: NSTextContainer, block: Block): void;
  drawBackgroundForGlyphRange_atPoint(glyphsToShow: NSRange, origin: NSPoint): void;
  drawGlyphsForGlyphRange_atPoint(glyphsToShow: NSRange, origin: NSPoint): void;
  showCGGlyphs_positions_count_font_matrix_attributes_inContext(glyphs: CGGlyph, positions: NSPoint, glyphCount: NSUInteger, font: NSFont, textMatrix: NSAffineTransform, attributes: NSDictionary<any, any> | {[key: string]: any}, graphicsContext: NSGraphicsContext): void;
  fillBackgroundRectArray_count_forCharacterRange_color(rectArray: NSRect, rectCount: NSUInteger, charRange: NSRange, color: NSColor): void;
  drawUnderlineForGlyphRange_underlineType_baselineOffset_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, underlineVal: NSUnderlineStyle, baselineOffset: CGFloat, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  underlineGlyphRange_underlineType_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, underlineVal: NSUnderlineStyle, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  drawStrikethroughForGlyphRange_strikethroughType_baselineOffset_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, strikethroughVal: NSUnderlineStyle, baselineOffset: CGFloat, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  strikethroughGlyphRange_strikethroughType_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, strikethroughVal: NSUnderlineStyle, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  showAttachmentCell_inRect_characterIndex(cell: NSCell, rect: NSRect, attachmentIndex: NSUInteger): void;
  setLayoutRect_forTextBlock_glyphRange(rect: NSRect, block: NSTextBlock, glyphRange: NSRange): void;
  setBoundsRect_forTextBlock_glyphRange(rect: NSRect, block: NSTextBlock, glyphRange: NSRange): void;
  layoutRectForTextBlock_glyphRange(block: NSTextBlock, glyphRange: NSRange): NSRect;
  boundsRectForTextBlock_glyphRange(block: NSTextBlock, glyphRange: NSRange): NSRect;
  layoutRectForTextBlock_atIndex_effectiveRange(block: NSTextBlock, glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  boundsRectForTextBlock_atIndex_effectiveRange(block: NSTextBlock, glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  temporaryAttributesAtCharacterIndex_effectiveRange(charIndex: NSUInteger, effectiveCharRange: NSRangePointer | null): NSDictionary<any, any>;
  setTemporaryAttributes_forCharacterRange(attrs: NSDictionary<any, any> | {[key: string]: any}, charRange: NSRange): void;
  addTemporaryAttributes_forCharacterRange(attrs: NSDictionary<any, any> | {[key: string]: any}, charRange: NSRange): void;
  removeTemporaryAttribute_forCharacterRange(attrName: NSAttributedStringKey, charRange: NSRange): void;
  temporaryAttribute_atCharacterIndex_effectiveRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null): any;
  temporaryAttribute_atCharacterIndex_longestEffectiveRange_inRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): any;
  temporaryAttributesAtCharacterIndex_longestEffectiveRange_inRange(location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): NSDictionary<any, any>;
  addTemporaryAttribute_value_forCharacterRange(attrName: NSAttributedStringKey, value: any, charRange: NSRange): void;
  defaultLineHeightForFont(theFont: NSFont): CGFloat;
  defaultBaselineOffsetForFont(theFont: NSFont): CGFloat;
  rulerMarkersForTextView_paragraphStyle_ruler(view: NSTextView, style: NSParagraphStyle, ruler: NSRulerView): NSArray<any>;
  rulerAccessoryViewForTextView_paragraphStyle_ruler_enabled(view: NSTextView, style: NSParagraphStyle, ruler: NSRulerView, isEnabled: boolean): NSView;
  layoutManagerOwnsFirstResponderInWindow(window: NSWindow): boolean;
  glyphAtIndex_isValidIndex(glyphIndex: NSUInteger, isValidIndex: boolean | null): NSGlyph;
  glyphAtIndex(glyphIndex: NSUInteger): NSGlyph;
  rectArrayForCharacterRange_withinSelectedCharacterRange_inTextContainer_rectCount(charRange: NSRange, selCharRange: NSRange, container: NSTextContainer, rectCount: NSUInteger): NSRectArray;
  rectArrayForGlyphRange_withinSelectedGlyphRange_inTextContainer_rectCount(glyphRange: NSRange, selGlyphRange: NSRange, container: NSTextContainer, rectCount: NSUInteger): NSRectArray;
  substituteFontForFont(originalFont: NSFont): NSFont;
  insertGlyphs_length_forStartingGlyphAtIndex_characterIndex(glyphs: NSGlyph, length: NSUInteger, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  insertGlyph_atGlyphIndex_characterIndex(glyph: NSGlyph, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  replaceGlyphAtIndex_withGlyph(glyphIndex: NSUInteger, newGlyph: NSGlyph): void;
  deleteGlyphsInRange(glyphRange: NSRange): void;
  setCharacterIndex_forGlyphAtIndex(charIndex: NSUInteger, glyphIndex: NSUInteger): void;
  setIntAttribute_value_forGlyphAtIndex(attributeTag: NSInteger, val: NSInteger, glyphIndex: NSUInteger): void;
  invalidateGlyphsOnLayoutInvalidationForGlyphRange(glyphRange: NSRange): void;
  intAttribute_forGlyphAtIndex(attributeTag: NSInteger, glyphIndex: NSUInteger): NSInteger;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits(glyphRange: NSRange, glyphBuffer: NSGlyph | null, charIndexBuffer: NSUInteger | null, inscribeBuffer: NSGlyphInscription | null, elasticBuffer: boolean | null): NSUInteger;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits_bidiLevels(glyphRange: NSRange, glyphBuffer: NSGlyph | null, charIndexBuffer: NSUInteger | null, inscribeBuffer: NSGlyphInscription | null, elasticBuffer: boolean | null, bidiLevelBuffer: string | null): NSUInteger;
  getGlyphs_range(glyphArray: NSGlyph | null, glyphRange: NSRange): NSUInteger;
  invalidateLayoutForCharacterRange_isSoft_actualCharacterRange(charRange: NSRange, flag: boolean, actualCharRange: NSRangePointer | null): void;
  textStorage_edited_range_changeInLength_invalidatedRange(str: NSTextStorage, editedMask: NSTextStorageEditedOptions, newCharRange: NSRange, delta: NSInteger, invalidatedCharRange: NSRange): void;
  setLocations_startingGlyphIndexes_count_forGlyphRange(locations: NSPointArray, glyphIndexes: NSUInteger, count: NSUInteger, glyphRange: NSRange): void;
  showPackedGlyphs_length_glyphRange_atPoint_font_color_printingAdjustment(glyphs: string, glyphLen: NSUInteger, glyphRange: NSRange, point: NSPoint, font: NSFont, color: NSColor, printingAdjustment: NSSize): void;
  temporaryAttributesForKey(key: NSString | string): NSDictionary<any, any>;
  setTemporaryAttributes_forKey(attrs: NSDictionary<any, any> | {[key: string]: any}, key: NSString | string): void;

  textStorage(): NSTextStorage;
  setTextStorage(textStorage: NSTextStorage): void;
  textContainers(): NSArray<any>;
  delegate(): any;
  setDelegate(delegate: any): void;
  showsInvisibleCharacters(): boolean;
  setShowsInvisibleCharacters(showsInvisibleCharacters: boolean): void;
  showsControlCharacters(): boolean;
  setShowsControlCharacters(showsControlCharacters: boolean): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  usesFontLeading(): boolean;
  setUsesFontLeading(usesFontLeading: boolean): void;
  allowsNonContiguousLayout(): boolean;
  setAllowsNonContiguousLayout(allowsNonContiguousLayout: boolean): void;
  hasNonContiguousLayout(): boolean;
  backgroundLayoutEnabled(): boolean;
  setBackgroundLayoutEnabled(backgroundLayoutEnabled: boolean): void;
  defaultAttachmentScaling(): NSImageScaling;
  setDefaultAttachmentScaling(defaultAttachmentScaling: NSImageScaling): void;
  typesetter(): NSTypesetter;
  setTypesetter(typesetter: NSTypesetter): void;
  typesetterBehavior(): NSTypesetterBehavior;
  setTypesetterBehavior(typesetterBehavior: NSTypesetterBehavior): void;
  numberOfGlyphs(): NSUInteger;
  extraLineFragmentRect(): NSRect;
  extraLineFragmentUsedRect(): NSRect;
  extraLineFragmentTextContainer(): NSTextContainer;
  firstTextView(): NSTextView;
  textViewForBeginningOfSelection(): NSTextView;
  usesScreenFonts(): boolean;
  setUsesScreenFonts(usesScreenFonts: boolean): void;
  glyphGenerator(): NSGlyphGenerator;
  setGlyphGenerator(glyphGenerator: NSGlyphGenerator): void;
}
declare const NSLayoutManager: {
  alloc(): NSLayoutManagerAllocator;
}

interface INSLayoutManagerDelegate {
  layoutManager_shouldGenerateGlyphs_properties_characterIndexes_font_forGlyphRange(layoutManager: NSLayoutManager, glyphs: CGGlyph, props: NSGlyphProperty, charIndexes: NSUInteger, aFont: NSFont, glyphRange: NSRange): NSUInteger;
  layoutManager_lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  layoutManager_paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  layoutManager_paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  layoutManager_shouldUseAction_forControlCharacterAtIndex(layoutManager: NSLayoutManager, action: NSControlCharacterAction, charIndex: NSUInteger): NSControlCharacterAction;
  layoutManager_shouldBreakLineByWordBeforeCharacterAtIndex(layoutManager: NSLayoutManager, charIndex: NSUInteger): boolean;
  layoutManager_shouldBreakLineByHyphenatingBeforeCharacterAtIndex(layoutManager: NSLayoutManager, charIndex: NSUInteger): boolean;
  layoutManager_boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, textContainer: NSTextContainer, proposedRect: NSRect, glyphPosition: NSPoint, charIndex: NSUInteger): NSRect;
  layoutManager_shouldSetLineFragmentRect_lineFragmentUsedRect_baselineOffset_inTextContainer_forGlyphRange(layoutManager: NSLayoutManager, lineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, baselineOffset: CGFloat, textContainer: NSTextContainer, glyphRange: NSRange): boolean;
  layoutManagerDidInvalidateLayout(sender: NSLayoutManager): void;
  layoutManager_didCompleteLayoutForTextContainer_atEnd(layoutManager: NSLayoutManager, textContainer: NSTextContainer | null, layoutFinishedFlag: boolean): void;
  layoutManager_textContainer_didChangeGeometryFromSize(layoutManager: NSLayoutManager, textContainer: NSTextContainer, oldSize: NSSize): void;
  layoutManager_shouldUseTemporaryAttributes_forDrawingToScreen_atCharacterIndex_effectiveRange(layoutManager: NSLayoutManager, attrs: NSDictionary<any, any> | {[key: string]: any}, toScreen: boolean, charIndex: NSUInteger, effectiveCharRange: NSRangePointer | null): NSDictionary<any, any>;
}

declare enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal = 0,
  NSTextLayoutOrientationVertical = 1,
}

declare enum NSGlyphProperty {
  NSGlyphPropertyNull,
  NSGlyphPropertyControlCharacter,
  NSGlyphPropertyElastic,
  NSGlyphPropertyNonBaseCharacter,
}

declare enum NSControlCharacterAction {
  NSControlCharacterActionZeroAdvancement,
  NSControlCharacterActionWhitespace,
  NSControlCharacterActionHorizontalTab,
  NSControlCharacterActionLineBreak,
  NSControlCharacterActionParagraphBreak,
  NSControlCharacterActionContainerBreak,
}

declare enum NSTypesetterBehavior {
  NSTypesetterLatestBehavior = -1,
  NSTypesetterOriginalBehavior = 0,
  NSTypesetterBehavior_10_2_WithCompatibility = 1,
  NSTypesetterBehavior_10_2 = 2,
  NSTypesetterBehavior_10_3 = 3,
  NSTypesetterBehavior_10_4 = 4,
}

declare enum NSGlyphInscription {
  NSGlyphInscribeBase = 0,
  NSGlyphInscribeBelow = 1,
  NSGlyphInscribeAbove = 2,
  NSGlyphInscribeOverstrike = 3,
  NSGlyphInscribeOverBelow = 4,
}

interface NSLevelIndicatorAllocator<InitializedType = NSLevelIndicator> extends NSControlAllocator<NSLevelIndicator> {}
interface NSLevelIndicator extends NSControl {
  tickMarkValueAtIndex(index: NSInteger): number;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;

  levelIndicatorStyle(): NSLevelIndicatorStyle;
  setLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicatorStyle): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  warningValue(): number;
  setWarningValue(warningValue: number): void;
  criticalValue(): number;
  setCriticalValue(criticalValue: number): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  numberOfMajorTickMarks(): NSInteger;
  setNumberOfMajorTickMarks(numberOfMajorTickMarks: NSInteger): void;
  fillColor(): NSColor;
  setFillColor(fillColor: NSColor): void;
  warningFillColor(): NSColor;
  setWarningFillColor(warningFillColor: NSColor): void;
  criticalFillColor(): NSColor;
  setCriticalFillColor(criticalFillColor: NSColor): void;
  drawsTieredCapacityLevels(): boolean;
  setDrawsTieredCapacityLevels(drawsTieredCapacityLevels: boolean): void;
  placeholderVisibility(): NSLevelIndicatorPlaceholderVisibility;
  setPlaceholderVisibility(placeholderVisibility: NSLevelIndicatorPlaceholderVisibility): void;
  ratingImage(): NSImage;
  setRatingImage(ratingImage: NSImage): void;
  ratingPlaceholderImage(): NSImage;
  setRatingPlaceholderImage(ratingPlaceholderImage: NSImage): void;
}
declare const NSLevelIndicator: {
  alloc(): NSLevelIndicatorAllocator;
}

declare enum NSLevelIndicatorPlaceholderVisibility {
  NSLevelIndicatorPlaceholderVisibilityAutomatic = 0,
  NSLevelIndicatorPlaceholderVisibilityAlways = 1,
  NSLevelIndicatorPlaceholderVisibilityWhileEditing = 2,
}

interface NSLevelIndicatorCellAllocator<InitializedType = NSLevelIndicatorCell> extends NSActionCellAllocator<NSLevelIndicatorCell> {
  initWithLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicatorStyle): InitializedType;
}
interface NSLevelIndicatorCell extends NSActionCell {
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;
  tickMarkValueAtIndex(index: NSInteger): number;

  levelIndicatorStyle(): NSLevelIndicatorStyle;
  setLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicatorStyle): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  warningValue(): number;
  setWarningValue(warningValue: number): void;
  criticalValue(): number;
  setCriticalValue(criticalValue: number): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  numberOfMajorTickMarks(): NSInteger;
  setNumberOfMajorTickMarks(numberOfMajorTickMarks: NSInteger): void;
}
declare const NSLevelIndicatorCell: {
  alloc(): NSLevelIndicatorCellAllocator;
}

declare enum NSLevelIndicatorStyle {
  NSLevelIndicatorStyleRelevancy,
  NSLevelIndicatorStyleContinuousCapacity,
  NSLevelIndicatorStyleDiscreteCapacity,
  NSLevelIndicatorStyleRating,
}

interface NSMagnificationGestureRecognizerAllocator<InitializedType = NSMagnificationGestureRecognizer> extends NSGestureRecognizerAllocator<NSMagnificationGestureRecognizer> {}
interface NSMagnificationGestureRecognizer extends NSGestureRecognizer {

  magnification(): CGFloat;
  setMagnification(magnification: CGFloat): void;
}
declare const NSMagnificationGestureRecognizer: {
  alloc(): NSMagnificationGestureRecognizerAllocator;
}

interface NSMatrixAllocator<InitializedType = NSMatrix> extends NSControlAllocator<NSMatrix> {
  initWithFrame_mode_prototype_numberOfRows_numberOfColumns(frameRect: NSRect, mode: NSMatrixMode, cell: NSCell, rowsHigh: NSInteger, colsWide: NSInteger): InitializedType;
  initWithFrame_mode_cellClass_numberOfRows_numberOfColumns(frameRect: NSRect, mode: NSMatrixMode, factoryId: any | null, rowsHigh: NSInteger, colsWide: NSInteger): InitializedType;
}
interface NSMatrix extends NSControl, INSUserInterfaceValidations {
  makeCellAtRow_column(row: NSInteger, col: NSInteger): NSCell;
  sendAction_to_forAllCells(selector: string, object: any, flag: boolean): void;
  sortUsingSelector(comparator: string): void;
  setSelectionFrom_to_anchor_highlight(startPos: NSInteger, endPos: NSInteger, anchorPos: NSInteger, lit: boolean): void;
  deselectSelectedCell(): void;
  deselectAllCells(): void;
  selectCellAtRow_column(row: NSInteger, col: NSInteger): void;
  selectAll(sender: any | null): void;
  selectCellWithTag(tag: NSInteger): boolean;
  setScrollable(flag: boolean): void;
  setState_atRow_column(value: NSInteger, row: NSInteger, col: NSInteger): void;
  getNumberOfRows_columns(rowCount: NSInteger | null, colCount: NSInteger | null): void;
  cellAtRow_column(row: NSInteger, col: NSInteger): NSCell;
  cellFrameAtRow_column(row: NSInteger, col: NSInteger): NSRect;
  getRow_column_ofCell(row: NSInteger, col: NSInteger, cell: NSCell): boolean;
  getRow_column_forPoint(row: NSInteger, col: NSInteger, point: NSPoint): boolean;
  renewRows_columns(newRows: NSInteger, newCols: NSInteger): void;
  putCell_atRow_column(newCell: NSCell, row: NSInteger, col: NSInteger): void;
  addRow(): void;
  addRowWithCells(newCells: NSArray<any> | any[]): void;
  insertRow(row: NSInteger): void;
  insertRow_withCells(row: NSInteger, newCells: NSArray<any> | any[] | null): void;
  removeRow(row: NSInteger): void;
  addColumn(): void;
  addColumnWithCells(newCells: NSArray<any> | any[]): void;
  insertColumn(column: NSInteger): void;
  insertColumn_withCells(column: NSInteger, newCells: NSArray<any> | any[] | null): void;
  removeColumn(col: NSInteger): void;
  cellWithTag(tag: NSInteger): NSCell;
  sizeToCells(): void;
  setValidateSize(flag: boolean): void;
  drawCellAtRow_column(row: NSInteger, col: NSInteger): void;
  highlightCell_atRow_column(flag: boolean, row: NSInteger, col: NSInteger): void;
  scrollCellToVisibleAtRow_column(row: NSInteger, col: NSInteger): void;
  mouseDown(event: NSEvent): void;
  performKeyEquivalent(event: NSEvent): boolean;
  sendAction(): boolean;
  sendDoubleAction(): void;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  selectText(sender: any | null): void;
  selectTextAtRow_column(row: NSInteger, col: NSInteger): NSCell;
  acceptsFirstMouse(event: NSEvent | null): boolean;
  resetCursorRects(): void;
  setToolTip_forCell(toolTipString: NSString | string | null, cell: NSCell): void;
  toolTipForCell(cell: NSCell): NSString;

  cellClass(): any;
  setCellClass(cellClass: any): void;
  prototype(): NSCell;
  setPrototype(prototype: NSCell): void;
  mode(): NSMatrixMode;
  setMode(mode: NSMatrixMode): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  cells(): NSArray<any>;
  selectedCell(): NSCell;
  selectedCells(): NSArray<any>;
  selectedRow(): NSInteger;
  selectedColumn(): NSInteger;
  selectionByRect(): boolean;
  setSelectionByRect(selectionByRect: boolean): void;
  cellSize(): NSSize;
  setCellSize(cellSize: NSSize): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  cellBackgroundColor(): NSColor;
  setCellBackgroundColor(cellBackgroundColor: NSColor): void;
  drawsCellBackground(): boolean;
  setDrawsCellBackground(drawsCellBackground: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  numberOfRows(): NSInteger;
  numberOfColumns(): NSInteger;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  autosizesCells(): boolean;
  setAutosizesCells(autosizesCells: boolean): void;
  autoscroll(): boolean;
  setAutoscroll(autoscroll: boolean): void;
  mouseDownFlags(): NSInteger;
  delegate(): any;
  setDelegate(delegate: any): void;
  autorecalculatesCellSize(): boolean;
  setAutorecalculatesCellSize(autorecalculatesCellSize: boolean): void;
  tabKeyTraversesCells(): boolean;
  setTabKeyTraversesCells(tabKeyTraversesCells: boolean): void;
  keyCell(): NSCell;
  setKeyCell(keyCell: NSCell): void;
}
declare const NSMatrix: {
  alloc(): NSMatrixAllocator;
}

interface INSMatrixDelegate {
}

declare enum NSMatrixMode {
  NSRadioModeMatrix = 0,
  NSHighlightModeMatrix = 1,
  NSListModeMatrix = 2,
  NSTrackModeMatrix = 3,
}

interface NSMediaLibraryBrowserControllerAllocator<InitializedType = NSMediaLibraryBrowserController> extends NSObjectAllocator<NSMediaLibraryBrowserController> {}
interface NSMediaLibraryBrowserController extends NSObject {
  togglePanel(sender: any | null): IBAction;

  visible(): boolean;
  setVisible(visible: boolean): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
  mediaLibraries(): NSMediaLibrary;
  setMediaLibraries(mediaLibraries: NSMediaLibrary): void;
}
declare const NSMediaLibraryBrowserController: {
  alloc(): NSMediaLibraryBrowserControllerAllocator;
  sharedMediaLibraryBrowserController(): NSMediaLibraryBrowserController;

}

declare enum NSMediaLibrary {
  NSMediaLibraryAudio = 1 << 0,
  NSMediaLibraryImage = 1 << 1,
  NSMediaLibraryMovie = 1 << 2,
}

interface NSMenuAllocator<InitializedType = NSMenu> extends NSObjectAllocator<NSMenu> {
  initWithTitle(title: NSString | string): InitializedType;
  initWithCoder(decoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSMenu extends NSObject, INSCopying, INSCoding, INSUserInterfaceItemIdentification, INSAccessibilityElement, INSAccessibility {
  popUpMenuPositioningItem_atLocation_inView(item: NSMenuItem | null, location: NSPoint, view: NSView | null): boolean;
  insertItem_atIndex(newItem: NSMenuItem, index: NSInteger): void;
  addItem(newItem: NSMenuItem): void;
  insertItemWithTitle_action_keyEquivalent_atIndex(string: NSString | string, selector: string | null, charCode: NSString | string, index: NSInteger): NSMenuItem;
  addItemWithTitle_action_keyEquivalent(string: NSString | string, selector: string | null, charCode: NSString | string): NSMenuItem;
  removeItemAtIndex(index: NSInteger): void;
  removeItem(item: NSMenuItem): void;
  setSubmenu_forItem(menu: NSMenu | null, item: NSMenuItem): void;
  removeAllItems(): void;
  itemAtIndex(index: NSInteger): NSMenuItem;
  indexOfItem(item: NSMenuItem): NSInteger;
  indexOfItemWithTitle(title: NSString | string): NSInteger;
  indexOfItemWithTag(tag: NSInteger): NSInteger;
  indexOfItemWithRepresentedObject(object: any | null): NSInteger;
  indexOfItemWithSubmenu(submenu: NSMenu | null): NSInteger;
  indexOfItemWithTarget_andAction(target: any | null, actionSelector: string | null): NSInteger;
  itemWithTitle(title: NSString | string): NSMenuItem;
  itemWithTag(tag: NSInteger): NSMenuItem;
  update(): void;
  performKeyEquivalent(event: NSEvent): boolean;
  itemChanged(item: NSMenuItem): void;
  performActionForItemAtIndex(index: NSInteger): void;
  cancelTracking(): void;
  cancelTrackingWithoutAnimation(): void;
  submenuAction(sender: any | null): void;
  setMenuRepresentation(menuRep: any): void;
  menuRepresentation(): any;
  setContextMenuRepresentation(menuRep: any): void;
  contextMenuRepresentation(): any;
  setTearOffMenuRepresentation(menuRep: any): void;
  tearOffMenuRepresentation(): any;
  attachedMenu(): NSMenu;
  isAttached(): boolean;
  sizeToFit(): void;
  locationForSubmenu(submenu: NSMenu): NSPoint;
  helpRequested(eventPtr: NSEvent): void;
  addItemWithTitle_action(title: NSString | string, aSelector: string): NSMenuItem;
  addItemWithTitle_small_target_action(title: NSString | string, smallFont: boolean, action: any, aSelector: string): NSMenuItem;
  addItemWithTitle_target_action(title: NSString | string, aTarget: any, action: string): NSMenuItem;
  addItemWithTitle_target_action_representedObject(title: NSString | string, aTarget: any, action: string, anObject: any): NSMenuItem;
  addItemWithTitle_target_action_submenu(title: NSString | string, aTarget: any, action: string, submenu: NSMenu): NSMenuItem;
  addItemWithTitle_target_action_image(title: NSString | string, target: any, action: string, image: NSImage): NSMenuItem;
  addItemWithTitle_target_action_imageNamed(title: NSString | string, aTarget: any, action: string, image: NSString | string): NSMenuItem;
  addSmallItalicItemWithTitle_target_action(aString: NSString | string, aTarget: any, aSelector: string): NSMenuItem;
  addSmallItemWithTitle_target_action(aString: NSString | string, aTarget: any, aSelector: string): NSMenuItem;
  addItemWithTitle_font_target_action(title: NSString | string, font: NSFont, aTarget: any, aSelector: string): NSMenuItem;
  addItemsFromArray(array: NSArray<any> | any[]): void;
  replaceItemWithAction_withMenuItem_ms(action: string, newItem: NSMenuItem): NSMenuItem;
  replaceMenuItem_withMenuItem_ms(oldItem: NSMenuItem, newItem: NSMenuItem): void;
  showPopUpMenuForEvent_relativeToRect_ofView(event: NSEvent, rect: NSRect, view: NSView): void;
  showPopUpMenuForEvent_relativeToRect_ofView_deferred(event: NSEvent, rect: NSRect, view: NSView, defer: boolean): void;
  parentMenuItem_bc(): NSMenuItem;

  title(): NSString;
  setTitle(title: NSString | string): void;
  supermenu(): NSMenu;
  setSupermenu(supermenu: NSMenu): void;
  itemArray(): NSArray<any>;
  numberOfItems(): NSInteger;
  autoenablesItems(): boolean;
  setAutoenablesItems(autoenablesItems: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  menuBarHeight(): CGFloat;
  highlightedItem(): NSMenuItem;
  minimumWidth(): CGFloat;
  setMinimumWidth(minimumWidth: CGFloat): void;
  size(): NSSize;
  font(): NSFont;
  setFont(font: NSFont): void;
  allowsContextMenuPlugIns(): boolean;
  setAllowsContextMenuPlugIns(allowsContextMenuPlugIns: boolean): void;
  showsStateColumn(): boolean;
  setShowsStateColumn(showsStateColumn: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  propertiesToUpdate(): NSMenuProperties;
  menuChangedMessagesEnabled(): boolean;
  setMenuChangedMessagesEnabled(menuChangedMessagesEnabled: boolean): void;
  tornOff(): boolean;
  isInMainMenu(): boolean;
  isDarkMode_ms(): boolean;
}
declare const NSMenu: {
  alloc(): NSMenuAllocator;  popUpContextMenu_withEvent_forView(menu: NSMenu, event: NSEvent, view: NSView): void;
  popUpContextMenu_withEvent_forView_withFont(menu: NSMenu, event: NSEvent, view: NSView, font: NSFont | null): void;
  setMenuBarVisible(visible: boolean): void;
  menuBarVisible(): boolean;
  menuZone(): NSZone;
  setMenuZone(zone: NSZone): void;
  menuWithItems(menuItems: NSArray<any> | any[]): NSMenu;

}

interface INSMenuDelegate {
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

declare enum NSMenuProperties {
  NSMenuPropertyItemTitle = 1 << 0,
  NSMenuPropertyItemAttributedTitle = 1 << 1,
  NSMenuPropertyItemKeyEquivalent = 1 << 2,
  NSMenuPropertyItemImage = 1 << 3,
  NSMenuPropertyItemEnabled = 1 << 4,
  NSMenuPropertyItemAccessibilityDescription = 1 << 5,
}

interface NSMenuItemAllocator<InitializedType = NSMenuItem> extends NSObjectAllocator<NSMenuItem> {
  initWithTitle_action_keyEquivalent(string: NSString | string, selector: string | null, charCode: NSString | string): InitializedType;
  initWithCoder(decoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSMenuItem extends NSObject, INSCopying, INSCoding, INSValidatedUserInterfaceItem, INSUserInterfaceItemIdentification, INSAccessibilityElement, INSAccessibility {
  setMnemonicLocation(location: NSUInteger): void;
  mnemonicLocation(): NSUInteger;
  mnemonic(): NSString;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  isInMainMenu(): boolean;
  setSmallFont(): void;
  generatePreviewWithColorSpace_backingScale_completionHandler(colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock): boolean;

  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  hasSubmenu(): boolean;
  submenu(): NSMenu;
  setSubmenu(submenu: NSMenu): void;
  parentItem(): NSMenuItem;
  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  separatorItem(): boolean;
  keyEquivalent(): NSString;
  setKeyEquivalent(keyEquivalent: NSString | string): void;
  keyEquivalentModifierMask(): NSEventModifierFlags;
  setKeyEquivalentModifierMask(keyEquivalentModifierMask: NSEventModifierFlags): void;
  userKeyEquivalent(): NSString;
  allowsKeyEquivalentWhenHidden(): boolean;
  setAllowsKeyEquivalentWhenHidden(allowsKeyEquivalentWhenHidden: boolean): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  state(): NSControlStateValue;
  setState(state: NSControlStateValue): void;
  onStateImage(): NSImage;
  setOnStateImage(onStateImage: NSImage): void;
  offStateImage(): NSImage;
  setOffStateImage(offStateImage: NSImage): void;
  mixedStateImage(): NSImage;
  setMixedStateImage(mixedStateImage: NSImage): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  alternate(): boolean;
  setAlternate(alternate: boolean): void;
  indentationLevel(): NSInteger;
  setIndentationLevel(indentationLevel: NSInteger): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  view(): NSView;
  setView(view: NSView): void;
  highlighted(): boolean;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  hiddenOrHasHiddenAncestor(): boolean;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  shareableObjectReferences(): NSArray<any>;
  setShareableObjectReferences(shareableObjectReferences: NSArray<any> | any[]): void;
  symbolMasterReferences(): NSArray<any>;
}
declare const NSMenuItem: {
  alloc(): NSMenuItemAllocator;  separatorItem(): NSMenuItem;
  itemWithTitle_action(title: NSString | string, action: string): NSMenuItem;
  itemWithTitle_target_action(title: NSString | string, aTarget: any, action: string): NSMenuItem;
  itemWithTitle_small_target_action(title: NSString | string, smallFont: boolean, aTarget: any, action: string): NSMenuItem;
  menuItemWithTruncatedTitle_target_action(aString: NSString | string, aTarget: any, anAction: string): NSMenuItem;

  usesUserKeyEquivalents(): boolean;
  setUsesUserKeyEquivalents(usesUserKeyEquivalents: boolean): void;

}

interface NSMenuItemCellAllocator<InitializedType = NSMenuItemCell> extends NSButtonCellAllocator<NSMenuItemCell> {}
interface NSMenuItemCell extends NSButtonCell {
  setMenuView(menuView: NSMenuView): void;
  menuView(): NSMenuView;
  calcSize(): void;
  stateImageRectForBounds(cellFrame: NSRect): NSRect;
  titleRectForBounds(cellFrame: NSRect): NSRect;
  keyEquivalentRectForBounds(cellFrame: NSRect): NSRect;
  drawSeparatorItemWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawStateImageWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawImageWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawTitleWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawKeyEquivalentWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawBorderAndBackgroundWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;

  menuItem(): NSMenuItem;
  setMenuItem(menuItem: NSMenuItem): void;
  needsSizing(): boolean;
  setNeedsSizing(needsSizing: boolean): void;
  needsDisplay(): boolean;
  setNeedsDisplay(needsDisplay: boolean): void;
  stateImageWidth(): CGFloat;
  imageWidth(): CGFloat;
  titleWidth(): CGFloat;
  keyEquivalentWidth(): CGFloat;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
}
declare const NSMenuItemCell: {
  alloc(): NSMenuItemCellAllocator;
}

interface NSMenuViewAllocator<InitializedType = NSMenuView> extends NSViewAllocator<NSMenuView> {
  initAsTearOff(): InitializedType;
}
interface NSMenuView extends NSView {
  setMenu(menu: NSMenu): void;
  menu(): NSMenu;
  itemChanged(notification: NSNotification): void;
  itemAdded(notification: NSNotification): void;
  itemRemoved(notification: NSNotification): void;
  update(): void;
  setHorizontal(flag: boolean): void;
  isHorizontal(): boolean;
  setFont(font: NSFont): void;
  font(): NSFont;
  innerRect(): NSRect;
  rectOfItemAtIndex(index: NSInteger): NSRect;
  indexOfItemAtPoint(point: NSPoint): NSInteger;
  setNeedsDisplayForItemAtIndex(index: NSInteger): void;
  setHighlightedItemIndex(index: NSInteger): void;
  highlightedItemIndex(): NSInteger;
  stateImageOffset(): CGFloat;
  stateImageWidth(): CGFloat;
  imageAndTitleOffset(): CGFloat;
  imageAndTitleWidth(): CGFloat;
  keyEquivalentOffset(): CGFloat;
  keyEquivalentWidth(): CGFloat;
  setMenuItemCell_forItemAtIndex(cell: NSMenuItemCell, index: NSInteger): void;
  menuItemCellForItemAtIndex(index: NSInteger): NSMenuItemCell;
  attachedMenuView(): NSMenuView;
  setNeedsSizing(flag: boolean): void;
  needsSizing(): boolean;
  sizeToFit(): void;
  attachedMenu(): NSMenu;
  isAttached(): boolean;
  isTornOff(): boolean;
  locationForSubmenu(submenu: NSMenu): NSPoint;
  setWindowFrameForAttachingToRect_onScreen_preferredEdge_popUpSelectedItem(screenRect: NSRect, screen: NSScreen, edge: NSRectEdge, selectedItemIndex: NSInteger): void;
  detachSubmenu(): void;
  attachSubmenuForItemAtIndex(index: NSInteger): void;
  performActionWithHighlightingForItemAtIndex(index: NSInteger): void;
  trackWithEvent(event: NSEvent): boolean;
  horizontalEdgePadding(): CGFloat;
  setHorizontalEdgePadding(pad: CGFloat): void;
}
declare const NSMenuView: {
  alloc(): NSMenuViewAllocator;  menuBarHeight(): CGFloat;

}

interface NSMovieAllocator<InitializedType = NSMovie> extends NSObjectAllocator<NSMovie> {
  initWithMovie(movie: QTMovie): InitializedType;
  initWithURL_byReference(url: NSURL, byRef: boolean): InitializedType;
  initWithPasteboard(pasteboard: NSPasteboard): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSMovie extends NSObject, INSCopying, INSCoding {
  QTMovie(): QTMovie;
  URL(): NSURL;
}
declare const NSMovie: {
  alloc(): NSMovieAllocator;  movieUnfilteredFileTypes(): NSArray<any>;
  movieUnfilteredPasteboardTypes(): NSArray<any>;
  canInitWithPasteboard(pasteboard: NSPasteboard): boolean;

}

interface NSMovieViewAllocator<InitializedType = NSMovieView> extends NSViewAllocator<NSMovieView> {}
interface NSMovieView extends NSView, INSUserInterfaceValidations {
  setMovie(movie: NSMovie): void;
  movie(): NSMovie;
  movieController(): void;
  movieRect(): NSRect;
  start(sender: any): void;
  stop(sender: any): void;
  isPlaying(): boolean;
  gotoPosterFrame(sender: any): void;
  gotoBeginning(sender: any): void;
  gotoEnd(sender: any): void;
  stepForward(sender: any): void;
  stepBack(sender: any): void;
  setRate(rate: number): void;
  rate(): number;
  setVolume(volume: number): void;
  volume(): number;
  setMuted(mute: boolean): void;
  isMuted(): boolean;
  setLoopMode(mode: NSQTMovieLoopMode): void;
  loopMode(): NSQTMovieLoopMode;
  setPlaysSelectionOnly(flag: boolean): void;
  playsSelectionOnly(): boolean;
  setPlaysEveryFrame(flag: boolean): void;
  playsEveryFrame(): boolean;
  showController_adjustingSize(show: boolean, adjustSize: boolean): void;
  isControllerVisible(): boolean;
  resizeWithMagnification(magnification: CGFloat): void;
  sizeForMagnification(magnification: CGFloat): NSSize;
  setEditable(editable: boolean): void;
  isEditable(): boolean;
  cut(sender: any): void;
  copy(sender: any): void;
  paste(sender: any): void;
  delete(sender: any): void;
  selectAll(sender: any): void;
  clear(sender: any): void;
}
declare const NSMovieView: {
  alloc(): NSMovieViewAllocator;
}

declare type NSQTMovieLoopMode = NSUInteger

interface NSNibAllocator<InitializedType = NSNib> extends NSObjectAllocator<NSNib> {
  initWithNibNamed_bundle(nibName: NSNibName, bundle: NSBundle | null): InitializedType;
  initWithNibData_bundle(nibData: NSData, bundle: NSBundle | null): InitializedType;
  initWithContentsOfURL(nibFileURL: NSURL): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSNib extends NSObject, INSCoding {
  instantiateWithOwner_topLevelObjects(owner: any | null, topLevelObjects: NSArray<any> | any[]): boolean;
  instantiateNibWithExternalNameTable(externalNameTable: NSDictionary<any, any> | {[key: string]: any}): boolean;
  instantiateNibWithOwner_topLevelObjects(owner: any, topLevelObjects: NSArray<any> | any[]): boolean;
}
declare const NSNib: {
  alloc(): NSNibAllocator;
}

declare type NSNibName = NSString

interface NSNibConnectorAllocator<InitializedType = NSNibConnector> extends NSObjectAllocator<NSNibConnector> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSNibConnector extends NSObject, INSCoding {
  replaceObject_withObject(oldObject: any, newObject: any): void;
  establishConnection(): void;

  source(): any;
  setSource(source: any): void;
  destination(): any;
  setDestination(destination: any): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
}
declare const NSNibConnector: {
  alloc(): NSNibConnectorAllocator;
}

interface NSNibControlConnectorAllocator<InitializedType = NSNibControlConnector> extends NSNibConnectorAllocator<NSNibControlConnector> {}
interface NSNibControlConnector extends NSNibConnector {
  establishConnection(): void;
}
declare const NSNibControlConnector: {
  alloc(): NSNibControlConnectorAllocator;
}

interface NSNibOutletConnectorAllocator<InitializedType = NSNibOutletConnector> extends NSNibConnectorAllocator<NSNibOutletConnector> {}
interface NSNibOutletConnector extends NSNibConnector {
  establishConnection(): void;
}
declare const NSNibOutletConnector: {
  alloc(): NSNibOutletConnectorAllocator;
}

interface NSObjectControllerAllocator<InitializedType = NSObjectController> extends NSControllerAllocator<NSObjectController> {
  initWithContent(content: any | null): InitializedType;
}
interface NSObjectController extends NSController {
  prepareContent(): void;
  newObject(): any;
  addObject(object: any): void;
  removeObject(object: any): void;
  add(sender: any | null): IBAction;
  remove(sender: any | null): IBAction;
  validateUserInterfaceItem(item: any): boolean;
  fetchWithRequest_merge_error(fetchRequest: NSFetchRequest | null, merge: boolean, error: NSError): boolean;
  fetch(sender: any | null): IBAction;
  defaultFetchRequest(): NSFetchRequest;

  content(): any;
  setContent(content: any): void;
  selection(): any;
  selectedObjects(): NSArray<any>;
  automaticallyPreparesContent(): boolean;
  setAutomaticallyPreparesContent(automaticallyPreparesContent: boolean): void;
  objectClass(): any;
  setObjectClass(objectClass: any): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  canAdd(): boolean;
  canRemove(): boolean;
  managedObjectContext(): NSManagedObjectContext;
  setManagedObjectContext(managedObjectContext: NSManagedObjectContext): void;
  entityName(): NSString;
  setEntityName(entityName: NSString | string): void;
  fetchPredicate(): NSPredicate;
  setFetchPredicate(fetchPredicate: NSPredicate): void;
  usesLazyFetching(): boolean;
  setUsesLazyFetching(usesLazyFetching: boolean): void;
}
declare const NSObjectController: {
  alloc(): NSObjectControllerAllocator;
}

interface NSOpenGLPixelFormatAllocator<InitializedType = NSOpenGLPixelFormat> extends NSObjectAllocator<NSOpenGLPixelFormat> {
  initWithCGLPixelFormatObj(format: _CGLPixelFormatObject): InitializedType;
  initWithAttributes(attribs: NSOpenGLPixelFormatAttribute): InitializedType;
  initWithData(attribs: NSData): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSOpenGLPixelFormat extends NSObject, INSCoding {
  attributes(): NSData;
  setAttributes(attribs: NSData): void;
  getValues_forAttribute_forVirtualScreen(vals: GLint, attrib: NSOpenGLPixelFormatAttribute, screen: GLint): void;

  numberOfVirtualScreens(): GLint;
  CGLPixelFormatObj(): _CGLPixelFormatObject;
}
declare const NSOpenGLPixelFormat: {
  alloc(): NSOpenGLPixelFormatAllocator;
}

interface NSOpenGLPixelBufferAllocator<InitializedType = NSOpenGLPixelBuffer> extends NSObjectAllocator<NSOpenGLPixelBuffer> {
  initWithTextureTarget_textureInternalFormat_textureMaxMipMapLevel_pixelsWide_pixelsHigh(target: GLenum, format: GLenum, maxLevel: GLint, pixelsWide: GLsizei, pixelsHigh: GLsizei): InitializedType;
  initWithCGLPBufferObj(pbuffer: _CGLPBufferObject): InitializedType;
}
interface NSOpenGLPixelBuffer extends NSObject {
  CGLPBufferObj(): _CGLPBufferObject;
  pixelsWide(): GLsizei;
  pixelsHigh(): GLsizei;
  textureTarget(): GLenum;
  textureInternalFormat(): GLenum;
  textureMaxMipMapLevel(): GLint;
}
declare const NSOpenGLPixelBuffer: {
  alloc(): NSOpenGLPixelBufferAllocator;
}

interface NSOpenGLContextAllocator<InitializedType = NSOpenGLContext> extends NSObjectAllocator<NSOpenGLContext> {
  initWithFormat_shareContext(format: NSOpenGLPixelFormat, share: NSOpenGLContext | null): InitializedType;
  initWithCGLContextObj(context: _CGLContextObject): InitializedType;
}
interface NSOpenGLContext extends NSObject, INSLocking {
  setFullScreen(): void;
  setOffScreen_width_height_rowbytes(baseaddr: void, width: GLsizei, height: GLsizei, rowbytes: GLint): void;
  clearDrawable(): void;
  update(): void;
  flushBuffer(): void;
  makeCurrentContext(): void;
  copyAttributesFromContext_withMask(context: NSOpenGLContext, mask: GLbitfield): void;
  setValues_forParameter(vals: GLint, param: NSOpenGLContextParameter): void;
  getValues_forParameter(vals: GLint, param: NSOpenGLContextParameter): void;
  createTexture_fromView_internalFormat(target: GLenum, view: NSView, format: GLenum): void;
  setPixelBuffer_cubeMapFace_mipMapLevel_currentVirtualScreen(pixelBuffer: NSOpenGLPixelBuffer, face: GLenum, level: GLint, screen: GLint): void;
  pixelBuffer(): NSOpenGLPixelBuffer;
  pixelBufferCubeMapFace(): GLenum;
  pixelBufferMipMapLevel(): GLint;
  setTextureImageToPixelBuffer_colorBuffer(pixelBuffer: NSOpenGLPixelBuffer, source: GLenum): void;

  pixelFormat(): NSOpenGLPixelFormat;
  view(): NSView;
  setView(view: NSView): void;
  currentVirtualScreen(): GLint;
  setCurrentVirtualScreen(currentVirtualScreen: GLint): void;
  CGLContextObj(): _CGLContextObject;
}
declare const NSOpenGLContext: {
  alloc(): NSOpenGLContextAllocator;  clearCurrentContext(): void;

  currentContext(): NSOpenGLContext;

}

declare type NSOpenGLPixelFormatAttribute = number

declare type NSOpenGLContextAuxiliary = _CGLContextObject

declare enum NSOpenGLGlobalOption {
  NSOpenGLGOFormatCacheSize = 501,
  NSOpenGLGOClearFormatCache = 502,
  NSOpenGLGORetainRenderers = 503,
  NSOpenGLGOUseBuildCache = 506,
  NSOpenGLGOResetLibrary = 504,
}

declare enum NSOpenGLContextParameter {
  NSOpenGLContextParameterSwapInterval = 222,
  NSOpenGLContextParameterSurfaceOrder = 235,
  NSOpenGLContextParameterSurfaceOpacity = 236,
  NSOpenGLContextParameterSurfaceBackingSize = 304,
  NSOpenGLContextParameterReclaimResources = 308,
  NSOpenGLContextParameterCurrentRendererID = 309,
  NSOpenGLContextParameterGPUVertexProcessing = 310,
  NSOpenGLContextParameterGPUFragmentProcessing = 311,
  NSOpenGLContextParameterHasDrawable = 314,
  NSOpenGLContextParameterMPSwapsInFlight = 315,
  NSOpenGLContextParameterSwapRectangle = 200,
  NSOpenGLContextParameterSwapRectangleEnable = 201,
  NSOpenGLContextParameterRasterizationEnable = 221,
  NSOpenGLContextParameterStateValidation = 301,
  NSOpenGLContextParameterSurfaceSurfaceVolatile = 306,
}

interface NSOpenGLViewAllocator<InitializedType = NSOpenGLView> extends NSViewAllocator<NSOpenGLView> {
  initWithFrame_pixelFormat(frameRect: NSRect, format: NSOpenGLPixelFormat | null): InitializedType;
}
interface NSOpenGLView extends NSView {
  clearGLContext(): void;
  update(): void;
  reshape(): void;
  prepareOpenGL(): void;

  openGLContext(): NSOpenGLContext;
  setOpenGLContext(openGLContext: NSOpenGLContext): void;
  pixelFormat(): NSOpenGLPixelFormat;
  setPixelFormat(pixelFormat: NSOpenGLPixelFormat): void;
}
declare const NSOpenGLView: {
  alloc(): NSOpenGLViewAllocator;  defaultPixelFormat(): NSOpenGLPixelFormat;

}

interface NSOpenPanelAllocator<InitializedType = NSOpenPanel> extends NSSavePanelAllocator<NSOpenPanel> {}
interface NSOpenPanel extends NSSavePanel {
  filenames(): NSArray<any>;
  beginSheetForDirectory_file_types_modalForWindow_modalDelegate_didEndSelector_contextInfo(path: NSString | string | null, name: NSString | string | null, fileTypes: NSArray<any> | any[] | null, docWindow: NSWindow | null, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  beginForDirectory_file_types_modelessDelegate_didEndSelector_contextInfo(path: NSString | string | null, name: NSString | string | null, fileTypes: NSArray<any> | any[] | null, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalForDirectory_file_types(path: NSString | string | null, name: NSString | string | null, fileTypes: NSArray<any> | any[] | null): NSInteger;
  runModalForTypes(fileTypes: NSArray<any> | any[] | null): NSInteger;

  URLs(): NSArray<any>;
  resolvesAliases(): boolean;
  setResolvesAliases(resolvesAliases: boolean): void;
  canChooseDirectories(): boolean;
  setCanChooseDirectories(canChooseDirectories: boolean): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  canChooseFiles(): boolean;
  setCanChooseFiles(canChooseFiles: boolean): void;
  canResolveUbiquitousConflicts(): boolean;
  setCanResolveUbiquitousConflicts(canResolveUbiquitousConflicts: boolean): void;
  canDownloadUbiquitousContents(): boolean;
  setCanDownloadUbiquitousContents(canDownloadUbiquitousContents: boolean): void;
  accessoryViewDisclosed(): boolean;
  setAccessoryViewDisclosed(accessoryViewDisclosed: boolean): void;
}
declare const NSOpenPanel: {
  alloc(): NSOpenPanelAllocator;  openPanel(): NSOpenPanel;

}

interface NSOutlineViewAllocator<InitializedType = NSOutlineView> extends NSTableViewAllocator<NSOutlineView> {}
interface NSOutlineView extends NSTableView, INSAccessibilityOutline {
  isExpandable(item: any | null): boolean;
  numberOfChildrenOfItem(item: any | null): NSInteger;
  child_ofItem(index: NSInteger, item: any | null): any;
  expandItem_expandChildren(item: any | null, expandChildren: boolean): void;
  expandItem(item: any | null): void;
  collapseItem_collapseChildren(item: any | null, collapseChildren: boolean): void;
  collapseItem(item: any | null): void;
  reloadItem_reloadChildren(item: any | null, reloadChildren: boolean): void;
  reloadItem(item: any | null): void;
  parentForItem(item: any | null): any;
  childIndexForItem(item: any): NSInteger;
  itemAtRow(row: NSInteger): any;
  rowForItem(item: any | null): NSInteger;
  levelForItem(item: any | null): NSInteger;
  levelForRow(row: NSInteger): NSInteger;
  isItemExpanded(item: any | null): boolean;
  frameOfOutlineCellAtRow(row: NSInteger): NSRect;
  setDropItem_dropChildIndex(item: any | null, index: NSInteger): void;
  shouldCollapseAutoExpandedItemsForDeposited(deposited: boolean): boolean;
  insertItemsAtIndexes_inParent_withAnimation(indexes: NSIndexSet, parent: any | null, animationOptions: NSTableViewAnimationOptions): void;
  removeItemsAtIndexes_inParent_withAnimation(indexes: NSIndexSet, parent: any | null, animationOptions: NSTableViewAnimationOptions): void;
  moveItemAtIndex_inParent_toIndex_inParent(fromIndex: NSInteger, oldParent: any | null, toIndex: NSInteger, newParent: any | null): void;
  insertRowsAtIndexes_withAnimation_UNAVAILABLE_ATTRIBUTE(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  removeRowsAtIndexes_withAnimation_UNAVAILABLE_ATTRIBUTE(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  moveRowAtIndex_toIndex_UNAVAILABLE_ATTRIBUTE(oldIndex: NSInteger, newIndex: NSInteger): void;
  selectItems_byExtendingSelection(items: NSArray<any> | any[], extend: boolean): void;
  selectItem_byExtendingSelection(item: any, extend: boolean): void;
  selectItem(item: any): void;
  simpleExpandedState(): any;
  setSimpleExpandedState(state: any): void;
  saveSimpleExpandedState(): void;
  restoreSimpleExpandedState(): void;
  expandAllItems(): void;
  collapseAllItems(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  outlineTableColumn(): NSTableColumn;
  setOutlineTableColumn(outlineTableColumn: NSTableColumn): void;
  indentationPerLevel(): CGFloat;
  setIndentationPerLevel(indentationPerLevel: CGFloat): void;
  indentationMarkerFollowsCell(): boolean;
  setIndentationMarkerFollowsCell(indentationMarkerFollowsCell: boolean): void;
  autoresizesOutlineColumn(): boolean;
  setAutoresizesOutlineColumn(autoresizesOutlineColumn: boolean): void;
  autosaveExpandedItems(): boolean;
  setAutosaveExpandedItems(autosaveExpandedItems: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  stronglyReferencesItems(): boolean;
  setStronglyReferencesItems(stronglyReferencesItems: boolean): void;
}
declare const NSOutlineView: {
  alloc(): NSOutlineViewAllocator;
}

interface INSOutlineViewDataSource {
  outlineView_numberOfChildrenOfItem(outlineView: NSOutlineView, item: any | null): NSInteger;
  outlineView_child_ofItem(outlineView: NSOutlineView, index: NSInteger, item: any | null): any;
  outlineView_isItemExpandable(outlineView: NSOutlineView, item: any): boolean;
  outlineView_objectValueForTableColumn_byItem(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any | null): any;
  outlineView_setObjectValue_forTableColumn_byItem(outlineView: NSOutlineView, object: any | null, tableColumn: NSTableColumn | null, item: any | null): void;
  outlineView_itemForPersistentObject(outlineView: NSOutlineView, object: any): any;
  outlineView_persistentObjectForItem(outlineView: NSOutlineView, item: any | null): any;
  outlineView_sortDescriptorsDidChange(outlineView: NSOutlineView, oldDescriptors: NSArray<any> | any[]): void;
  outlineView_pasteboardWriterForItem(outlineView: NSOutlineView, item: any): any;
  outlineView_draggingSession_willBeginAtPoint_forItems(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, draggedItems: NSArray<any> | any[]): void;
  outlineView_draggingSession_endedAtPoint_operation(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  outlineView_writeItems_toPasteboard(outlineView: NSOutlineView, items: NSArray<any> | any[], pasteboard: NSPasteboard): boolean;
  outlineView_updateDraggingItemsForDrag(outlineView: NSOutlineView, draggingInfo: any): void;
  outlineView_validateDrop_proposedItem_proposedChildIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): NSDragOperation;
  outlineView_acceptDrop_item_childIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): boolean;
  outlineView_namesOfPromisedFilesDroppedAtDestination_forDraggedItems(outlineView: NSOutlineView, dropDestination: NSURL, items: NSArray<any> | any[]): NSArray<any>;
}

interface INSOutlineViewDelegate {
  outlineView_viewForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSView;
  outlineView_rowViewForItem(outlineView: NSOutlineView, item: any): NSTableRowView;
  outlineView_didAddRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_didRemoveRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_willDisplayCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_shouldEditTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  selectionShouldChangeInOutlineView(outlineView: NSOutlineView): boolean;
  outlineView_shouldSelectItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_selectionIndexesForProposedSelection(outlineView: NSOutlineView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  outlineView_shouldSelectTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn | null): boolean;
  outlineView_mouseDownInHeaderOfTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didClickTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didDragTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_toolTipForCell_rect_tableColumn_item_mouseLocation(outlineView: NSOutlineView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, item: any, mouseLocation: NSPoint): NSString;
  outlineView_heightOfRowByItem(outlineView: NSOutlineView, item: any): CGFloat;
  outlineView_typeSelectStringForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSString;
  outlineView_nextTypeSelectMatchFromItem_toItem_forString(outlineView: NSOutlineView, startItem: any, endItem: any, searchString: NSString | string): any;
  outlineView_shouldTypeSelectForEvent_withCurrentSearchString(outlineView: NSOutlineView, event: NSEvent, searchString: NSString | string | null): boolean;
  outlineView_shouldShowCellExpansionForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_shouldTrackCell_forTableColumn_item(outlineView: NSOutlineView, cell: NSCell, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_dataCellForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSCell;
  outlineView_isGroupItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldExpandItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldCollapseItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_willDisplayOutlineCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_sizeToFitWidthOfColumn(outlineView: NSOutlineView, column: NSInteger): CGFloat;
  outlineView_shouldReorderColumn_toColumn(outlineView: NSOutlineView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  outlineView_shouldShowOutlineCellForItem(outlineView: NSOutlineView, item: any): boolean;
  outlineViewSelectionDidChange(notification: NSNotification): void;
  outlineViewColumnDidMove(notification: NSNotification): void;
  outlineViewColumnDidResize(notification: NSNotification): void;
  outlineViewSelectionIsChanging(notification: NSNotification): void;
  outlineViewItemWillExpand(notification: NSNotification): void;
  outlineViewItemDidExpand(notification: NSNotification): void;
  outlineViewItemWillCollapse(notification: NSNotification): void;
  outlineViewItemDidCollapse(notification: NSNotification): void;
}

interface NSPDFImageRepAllocator<InitializedType = NSPDFImageRep> extends NSImageRepAllocator<NSPDFImageRep> {
  initWithData(pdfData: NSData): InitializedType;
}
interface NSPDFImageRep extends NSImageRep {

  PDFRepresentation(): NSData;
  bounds(): NSRect;
  currentPage(): NSInteger;
  setCurrentPage(currentPage: NSInteger): void;
  pageCount(): NSInteger;
}
declare const NSPDFImageRep: {
  alloc(): NSPDFImageRepAllocator;  imageRepWithData(pdfData: NSData): NSPDFImageRep;

}

interface NSPDFInfoAllocator<InitializedType = NSPDFInfo> extends NSObjectAllocator<NSPDFInfo> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSPDFInfo extends NSObject, INSCopying, INSCoding {

  URL(): NSURL;
  setURL(URL: NSURL): void;
  fileExtensionHidden(): boolean;
  setFileExtensionHidden(fileExtensionHidden: boolean): void;
  tagNames(): NSArray<any>;
  setTagNames(tagNames: NSArray<any> | any[]): void;
  orientation(): NSPaperOrientation;
  setOrientation(orientation: NSPaperOrientation): void;
  paperSize(): NSSize;
  setPaperSize(paperSize: NSSize): void;
  attributes(): NSMutableDictionary<any, any>;
}
declare const NSPDFInfo: {
  alloc(): NSPDFInfoAllocator;
}

interface NSPDFPanelAllocator<InitializedType = NSPDFPanel> extends NSObjectAllocator<NSPDFPanel> {}
interface NSPDFPanel extends NSObject {
  beginSheetWithPDFInfo_modalForWindow_completionHandler(pdfInfo: NSPDFInfo, docWindow: NSWindow | null, completionHandler: Block): void;

  accessoryController(): NSViewController;
  setAccessoryController(accessoryController: NSViewController): void;
  options(): NSPDFPanelOptions;
  setOptions(options: NSPDFPanelOptions): void;
  defaultFileName(): NSString;
  setDefaultFileName(defaultFileName: NSString | string): void;
}
declare const NSPDFPanel: {
  alloc(): NSPDFPanelAllocator;  panel(): NSPDFPanel;

}

declare enum NSPDFPanelOptions {
  NSPDFPanelShowsPaperSize = 1 << 2,
  NSPDFPanelShowsOrientation = 1 << 3,
  NSPDFPanelRequestsParentDirectory = 1 << 24,
}

interface NSPICTImageRepAllocator<InitializedType = NSPICTImageRep> extends NSImageRepAllocator<NSPICTImageRep> {
  initWithData(pictData: NSData): InitializedType;
}
interface NSPICTImageRep extends NSImageRep {

  PICTRepresentation(): NSData;
  boundingBox(): NSRect;
}
declare const NSPICTImageRep: {
  alloc(): NSPICTImageRepAllocator;  imageRepWithData(pictData: NSData): NSPICTImageRep;

}

interface NSPageControllerAllocator<InitializedType = NSPageController> extends NSViewControllerAllocator<NSPageController> {}
interface NSPageController extends NSViewController, INSAnimatablePropertyContainer, INSCoding {
  navigateForwardToObject(object: any): void;
  completeTransition(): void;
  navigateBack(sender: any | null): IBAction;
  navigateForward(sender: any | null): IBAction;
  takeSelectedIndexFrom(sender: any | null): IBAction;

  delegate(): any;
  setDelegate(delegate: any): void;
  selectedViewController(): NSViewController;
  transitionStyle(): NSPageControllerTransitionStyle;
  setTransitionStyle(transitionStyle: NSPageControllerTransitionStyle): void;
  arrangedObjects(): NSArray<any>;
  setArrangedObjects(arrangedObjects: NSArray<any> | any[]): void;
  selectedIndex(): NSInteger;
  setSelectedIndex(selectedIndex: NSInteger): void;
}
declare const NSPageController: {
  alloc(): NSPageControllerAllocator;
}

interface INSPageControllerDelegate {
  pageController_identifierForObject(pageController: NSPageController, object: any): NSPageControllerObjectIdentifier;
  pageController_viewControllerForIdentifier(pageController: NSPageController, identifier: NSPageControllerObjectIdentifier): NSViewController;
  pageController_frameForObject(pageController: NSPageController, object: any | null): NSRect;
  pageController_prepareViewController_withObject(pageController: NSPageController, viewController: NSViewController, object: any | null): void;
  pageController_didTransitionToObject(pageController: NSPageController, object: any): void;
  pageControllerWillStartLiveTransition(pageController: NSPageController): void;
  pageControllerDidEndLiveTransition(pageController: NSPageController): void;
}

declare type NSPageControllerObjectIdentifier = NSString

declare enum NSPageControllerTransitionStyle {
  NSPageControllerTransitionStyleStackHistory,
  NSPageControllerTransitionStyleStackBook,
  NSPageControllerTransitionStyleHorizontalStrip,
}

interface NSPageLayoutAllocator<InitializedType = NSPageLayout> extends NSObjectAllocator<NSPageLayout> {}
interface NSPageLayout extends NSObject {
  addAccessoryController(accessoryController: NSViewController): void;
  removeAccessoryController(accessoryController: NSViewController): void;
  beginSheetWithPrintInfo_modalForWindow_delegate_didEndSelector_contextInfo(printInfo: NSPrintInfo, docWindow: NSWindow, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalWithPrintInfo(printInfo: NSPrintInfo): NSInteger;
  runModal(): NSInteger;
  setAccessoryView(accessoryView: NSView): void;
  accessoryView(): NSView;
  readPrintInfo(): void;
  writePrintInfo(): void;

  accessoryControllers(): NSArray<any>;
  printInfo(): NSPrintInfo;
}
declare const NSPageLayout: {
  alloc(): NSPageLayoutAllocator;  pageLayout(): NSPageLayout;

}

interface NSPanGestureRecognizerAllocator<InitializedType = NSPanGestureRecognizer> extends NSGestureRecognizerAllocator<NSPanGestureRecognizer> {}
interface NSPanGestureRecognizer extends NSGestureRecognizer, INSCoding {
  translationInView(view: NSView | null): NSPoint;
  setTranslation_inView(translation: NSPoint, view: NSView | null): void;
  velocityInView(view: NSView | null): NSPoint;

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  numberOfTouchesRequired(): NSInteger;
  setNumberOfTouchesRequired(numberOfTouchesRequired: NSInteger): void;
}
declare const NSPanGestureRecognizer: {
  alloc(): NSPanGestureRecognizerAllocator;
}

interface NSPanelAllocator<InitializedType = NSPanel> extends NSWindowAllocator<NSPanel> {}
interface NSPanel extends NSWindow {

  floatingPanel(): boolean;
  setFloatingPanel(floatingPanel: boolean): void;
  becomesKeyOnlyIfNeeded(): boolean;
  setBecomesKeyOnlyIfNeeded(becomesKeyOnlyIfNeeded: boolean): void;
  worksWhenModal(): boolean;
  setWorksWhenModal(worksWhenModal: boolean): void;
}
declare const NSPanel: {
  alloc(): NSPanelAllocator;
}

interface NSTextTabAllocator<InitializedType = NSTextTab> extends NSObjectAllocator<NSTextTab> {
  initWithTextAlignment_location_options(alignment: NSTextAlignment, loc: CGFloat, options: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithType_location(type: NSTextTabType, loc: CGFloat): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTextTab extends NSObject, INSCopying, INSCoding, INSSecureCoding {

  alignment(): NSTextAlignment;
  location(): CGFloat;
  options(): NSDictionary<any, any>;
  tabStopType(): NSTextTabType;
}
declare const NSTextTab: {
  alloc(): NSTextTabAllocator;  columnTerminatorsForLocale(aLocale: NSLocale | null): NSCharacterSet;

}

interface NSParagraphStyleAllocator<InitializedType = NSParagraphStyle> extends NSObjectAllocator<NSParagraphStyle> {}
interface NSParagraphStyle extends NSObject, INSCopying, INSMutableCopying, INSSecureCoding {
  addSVGAttributes(attributes: NSMutableArray<any> | any[]): void;

  lineSpacing(): CGFloat;
  paragraphSpacing(): CGFloat;
  alignment(): NSTextAlignment;
  headIndent(): CGFloat;
  tailIndent(): CGFloat;
  firstLineHeadIndent(): CGFloat;
  minimumLineHeight(): CGFloat;
  maximumLineHeight(): CGFloat;
  lineBreakMode(): NSLineBreakMode;
  baseWritingDirection(): NSWritingDirection;
  lineHeightMultiple(): CGFloat;
  paragraphSpacingBefore(): CGFloat;
  hyphenationFactor(): number;
  tabStops(): NSArray<any>;
  defaultTabInterval(): CGFloat;
  allowsDefaultTighteningForTruncation(): boolean;
  tighteningFactorForTruncation(): number;
  textBlocks(): NSArray<any>;
  textLists(): NSArray<any>;
  headerLevel(): NSInteger;
  fixedLineHeight_ms(): CGFloat;
}
declare const NSParagraphStyle: {
  alloc(): NSParagraphStyleAllocator;  defaultWritingDirectionForLanguage(languageName: NSString | string | null): NSWritingDirection;

  defaultParagraphStyle(): NSParagraphStyle;

}

interface NSMutableParagraphStyleAllocator<InitializedType = NSMutableParagraphStyle> extends NSParagraphStyleAllocator<NSMutableParagraphStyle> {}
interface NSMutableParagraphStyle extends NSParagraphStyle {
  addTabStop(anObject: NSTextTab): void;
  removeTabStop(anObject: NSTextTab): void;
  setParagraphStyle(obj: NSParagraphStyle): void;
  removeUnsupportedAttributes(): void;

  lineSpacing(): CGFloat;
  setLineSpacing(lineSpacing: CGFloat): void;
  paragraphSpacing(): CGFloat;
  setParagraphSpacing(paragraphSpacing: CGFloat): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  firstLineHeadIndent(): CGFloat;
  setFirstLineHeadIndent(firstLineHeadIndent: CGFloat): void;
  headIndent(): CGFloat;
  setHeadIndent(headIndent: CGFloat): void;
  tailIndent(): CGFloat;
  setTailIndent(tailIndent: CGFloat): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  minimumLineHeight(): CGFloat;
  setMinimumLineHeight(minimumLineHeight: CGFloat): void;
  maximumLineHeight(): CGFloat;
  setMaximumLineHeight(maximumLineHeight: CGFloat): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  lineHeightMultiple(): CGFloat;
  setLineHeightMultiple(lineHeightMultiple: CGFloat): void;
  paragraphSpacingBefore(): CGFloat;
  setParagraphSpacingBefore(paragraphSpacingBefore: CGFloat): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  tabStops(): NSArray<any>;
  setTabStops(tabStops: NSArray<any> | any[]): void;
  defaultTabInterval(): CGFloat;
  setDefaultTabInterval(defaultTabInterval: CGFloat): void;
  allowsDefaultTighteningForTruncation(): boolean;
  setAllowsDefaultTighteningForTruncation(allowsDefaultTighteningForTruncation: boolean): void;
  tighteningFactorForTruncation(): number;
  setTighteningFactorForTruncation(tighteningFactorForTruncation: number): void;
  textBlocks(): NSArray<any>;
  setTextBlocks(textBlocks: NSArray<any> | any[]): void;
  textLists(): NSArray<any>;
  setTextLists(textLists: NSArray<any> | any[]): void;
  headerLevel(): NSInteger;
  setHeaderLevel(headerLevel: NSInteger): void;
  fixedLineHeight_ms(): CGFloat;
  setFixedLineHeight_ms(fixedLineHeight_ms: CGFloat): void;
}
declare const NSMutableParagraphStyle: {
  alloc(): NSMutableParagraphStyleAllocator;
}

declare type NSTextTabOptionKey = NSString

declare enum NSLineBreakMode {
  NSLineBreakByWordWrapping = 0,
  NSLineBreakByCharWrapping,
  NSLineBreakByClipping,
  NSLineBreakByTruncatingHead,
  NSLineBreakByTruncatingTail,
  NSLineBreakByTruncatingMiddle,
}

declare enum NSTextTabType {
  NSLeftTabStopType = 0,
  NSRightTabStopType,
  NSCenterTabStopType,
  NSDecimalTabStopType,
}

interface NSPasteboardAllocator<InitializedType = NSPasteboard> extends NSObjectAllocator<NSPasteboard> {}
interface NSPasteboard extends NSObject {
  releaseGlobally(): void;
  prepareForNewContentsWithOptions(options: NSPasteboardContentsOptions): NSInteger;
  clearContents(): NSInteger;
  writeObjects(objects: NSArray<any> | any[]): boolean;
  readObjectsForClasses_options(classArray: NSArray<any> | any[], options: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  indexOfPasteboardItem(pasteboardItem: NSPasteboardItem): NSUInteger;
  canReadItemWithDataConformingToTypes(types: NSArray<any> | any[]): boolean;
  canReadObjectForClasses_options(classArray: NSArray<any> | any[], options: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  declareTypes_owner(newTypes: NSArray<any> | any[], newOwner: any | null): NSInteger;
  addTypes_owner(newTypes: NSArray<any> | any[], newOwner: any | null): NSInteger;
  availableTypeFromArray(types: NSArray<any> | any[]): NSPasteboardType;
  setData_forType(data: NSData | null, dataType: NSPasteboardType): boolean;
  setPropertyList_forType(plist: any, dataType: NSPasteboardType): boolean;
  setString_forType(string: NSString | string, dataType: NSPasteboardType): boolean;
  dataForType(dataType: NSPasteboardType): NSData;
  propertyListForType(dataType: NSPasteboardType): any;
  stringForType(dataType: NSPasteboardType): NSString;
  writeFileContents(filename: NSString | string): boolean;
  readFileContentsType_toFile(type: NSPasteboardType | null, filename: NSString | string): NSString;
  writeFileWrapper(wrapper: NSFileWrapper): boolean;
  readFileWrapper(): NSFileWrapper;

  name(): NSPasteboardName;
  changeCount(): NSInteger;
  pasteboardItems(): NSArray<any>;
  types(): NSArray<any>;
}
declare const NSPasteboard: {
  alloc(): NSPasteboardAllocator;  pasteboardWithName(name: NSPasteboardName): NSPasteboard;
  pasteboardWithUniqueName(): NSPasteboard;
  typesFilterableTo(type: NSPasteboardType): NSArray<any>;
  pasteboardByFilteringFile(filename: NSString | string): NSPasteboard;
  pasteboardByFilteringData_ofType(data: NSData, type: NSPasteboardType): NSPasteboard;
  pasteboardByFilteringTypesInPasteboard(pboard: NSPasteboard): NSPasteboard;

  generalPasteboard(): NSPasteboard;

}

interface INSPasteboardWriting {
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
}

interface INSPasteboardReading {
}

declare type NSPasteboardType = NSString

declare type NSPasteboardName = NSString

declare type NSPasteboardReadingOptionKey = NSString

declare enum NSPasteboardContentsOptions {
  NSPasteboardContentsCurrentHostOnly = 1 << 0,
}

declare enum NSPasteboardWritingOptions {
  NSPasteboardWritingPromised = 1 << 9,
}

declare enum NSPasteboardReadingOptions {
  NSPasteboardReadingAsData = 0,
  NSPasteboardReadingAsString = 1 << 0,
  NSPasteboardReadingAsPropertyList = 1 << 1,
  NSPasteboardReadingAsKeyedArchive = 1 << 2,
}

interface NSPasteboardItemAllocator<InitializedType = NSPasteboardItem> extends NSObjectAllocator<NSPasteboardItem> {
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): InitializedType;
}
interface NSPasteboardItem extends NSObject, INSPasteboardWriting, INSPasteboardReading {
  availableTypeFromArray(types: NSArray<any> | any[]): NSPasteboardType;
  setDataProvider_forTypes(dataProvider: any, types: NSArray<any> | any[]): boolean;
  setData_forType(data: NSData, type: NSPasteboardType): boolean;
  setString_forType(string: NSString | string, type: NSPasteboardType): boolean;
  setPropertyList_forType(propertyList: any, type: NSPasteboardType): boolean;
  dataForType(type: NSPasteboardType): NSData;
  stringForType(type: NSPasteboardType): NSString;
  propertyListForType(type: NSPasteboardType): any;

  types(): NSArray<any>;
}
declare const NSPasteboardItem: {
  alloc(): NSPasteboardItemAllocator;
}

interface INSPasteboardItemDataProvider {
  pasteboard_item_provideDataForType(pasteboard: NSPasteboard | null, item: NSPasteboardItem, type: NSPasteboardType): void;
  pasteboardFinishedWithDataProvider(pasteboard: NSPasteboard): void;
}

interface NSPathCellAllocator<InitializedType = NSPathCell> extends NSActionCellAllocator<NSPathCell> {}
interface NSPathCell extends NSActionCell, INSOpenSavePanelDelegate {
  setObjectValue(obj: any | null): void;
  rectOfPathComponentCell_withFrame_inView(cell: NSPathComponentCell, frame: NSRect, view: NSView): NSRect;
  pathComponentCellAtPoint_withFrame_inView(point: NSPoint, frame: NSRect, view: NSView): NSPathComponentCell;
  mouseEntered_withFrame_inView(event: NSEvent, frame: NSRect, view: NSView): void;
  mouseExited_withFrame_inView(event: NSEvent, frame: NSRect, view: NSView): void;

  pathStyle(): NSPathStyle;
  setPathStyle(pathStyle: NSPathStyle): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
  allowedTypes(): NSArray<any>;
  setAllowedTypes(allowedTypes: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  pathComponentCells(): NSArray<any>;
  setPathComponentCells(pathComponentCells: NSArray<any> | any[]): void;
  clickedPathComponentCell(): NSPathComponentCell;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
}
declare const NSPathCell: {
  alloc(): NSPathCellAllocator;
  pathComponentCellClass(): any;

}

interface INSPathCellDelegate {
  pathCell_willDisplayOpenPanel(pathCell: NSPathCell, openPanel: NSOpenPanel): void;
  pathCell_willPopUpMenu(pathCell: NSPathCell, menu: NSMenu): void;
}

declare enum NSPathStyle {
  NSPathStyleStandard,
  NSPathStylePopUp = 2,
  NSPathStyleNavigationBar = 1,
}

interface NSPathComponentCellAllocator<InitializedType = NSPathComponentCell> extends NSTextFieldCellAllocator<NSPathComponentCell> {}
interface NSPathComponentCell extends NSTextFieldCell {

  image(): NSImage;
  setImage(image: NSImage): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
}
declare const NSPathComponentCell: {
  alloc(): NSPathComponentCellAllocator;
}

interface NSPathControlAllocator<InitializedType = NSPathControl> extends NSControlAllocator<NSPathControl> {}
interface NSPathControl extends NSControl {
  setDraggingSourceOperationMask_forLocal(mask: NSDragOperation, isLocal: boolean): void;
  clickedPathComponentCell(): NSPathComponentCell;
  pathComponentCells(): NSArray<any>;
  setPathComponentCells(cells: NSArray<any> | any[]): void;

  editable(): boolean;
  setEditable(editable: boolean): void;
  allowedTypes(): NSArray<any>;
  setAllowedTypes(allowedTypes: NSArray<any> | any[]): void;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  pathStyle(): NSPathStyle;
  setPathStyle(pathStyle: NSPathStyle): void;
  clickedPathItem(): NSPathControlItem;
  pathItems(): NSArray<any>;
  setPathItems(pathItems: NSArray<any> | any[]): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
}
declare const NSPathControl: {
  alloc(): NSPathControlAllocator;
}

interface INSPathControlDelegate {
  pathControl_shouldDragItem_withPasteboard(pathControl: NSPathControl, pathItem: NSPathControlItem, pasteboard: NSPasteboard): boolean;
  pathControl_shouldDragPathComponentCell_withPasteboard(pathControl: NSPathControl, pathComponentCell: NSPathComponentCell, pasteboard: NSPasteboard): boolean;
  pathControl_validateDrop(pathControl: NSPathControl, info: any): NSDragOperation;
  pathControl_acceptDrop(pathControl: NSPathControl, info: any): boolean;
  pathControl_willDisplayOpenPanel(pathControl: NSPathControl, openPanel: NSOpenPanel): void;
  pathControl_willPopUpMenu(pathControl: NSPathControl, menu: NSMenu): void;
}

interface NSPathControlItemAllocator<InitializedType = NSPathControlItem> extends NSObjectAllocator<NSPathControlItem> {}
interface NSPathControlItem extends NSObject {

  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  URL(): NSURL;
}
declare const NSPathControlItem: {
  alloc(): NSPathControlItemAllocator;
}

interface NSPersistentDocumentAllocator<InitializedType = NSPersistentDocument> extends NSDocumentAllocator<NSPersistentDocument> {}
interface NSPersistentDocument extends NSDocument {
  configurePersistentStoreCoordinatorForURL_ofType_modelConfiguration_storeOptions_error(url: NSURL, fileType: NSString | string, configuration: NSString | string | null, storeOptions: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): boolean;
  persistentStoreTypeForFileType(fileType: NSString | string): NSString;
  writeToURL_ofType_forSaveOperation_originalContentsURL_error(absoluteURL: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, absoluteOriginalContentsURL: NSURL | null, error: NSError): boolean;
  readFromURL_ofType_error(absoluteURL: NSURL, typeName: NSString | string, error: NSError): boolean;
  revertToContentsOfURL_ofType_error(inAbsoluteURL: NSURL, inTypeName: NSString | string, outError: NSError): boolean;
  configurePersistentStoreCoordinatorForURL_ofType_error(url: NSURL, fileType: NSString | string, error: NSError): boolean;

  managedObjectContext(): NSManagedObjectContext;
  setManagedObjectContext(managedObjectContext: NSManagedObjectContext): void;
  managedObjectModel(): NSManagedObjectModel;
}
declare const NSPersistentDocument: {
  alloc(): NSPersistentDocumentAllocator;
}

interface NSPopUpButtonAllocator<InitializedType = NSPopUpButton> extends NSButtonAllocator<NSPopUpButton> {
  initWithFrame_pullsDown(buttonFrame: NSRect, flag: boolean): InitializedType;
}
interface NSPopUpButton extends NSButton {
  addItemWithTitle(title: NSString | string): void;
  addItemsWithTitles(itemTitles: NSArray<any> | any[]): void;
  insertItemWithTitle_atIndex(title: NSString | string, index: NSInteger): void;
  removeItemWithTitle(title: NSString | string): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  indexOfItem(item: NSMenuItem): NSInteger;
  indexOfItemWithTitle(title: NSString | string): NSInteger;
  indexOfItemWithTag(tag: NSInteger): NSInteger;
  indexOfItemWithRepresentedObject(obj: any | null): NSInteger;
  indexOfItemWithTarget_andAction(target: any | null, actionSelector: string | null): NSInteger;
  itemAtIndex(index: NSInteger): NSMenuItem;
  itemWithTitle(title: NSString | string): NSMenuItem;
  selectItem(item: NSMenuItem | null): void;
  selectItemAtIndex(index: NSInteger): void;
  selectItemWithTitle(title: NSString | string): void;
  selectItemWithTag(tag: NSInteger): boolean;
  setTitle(string: NSString | string): void;
  synchronizeTitleAndSelectedItem(): void;
  itemTitleAtIndex(index: NSInteger): NSString;

  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  pullsDown(): boolean;
  setPullsDown(pullsDown: boolean): void;
  autoenablesItems(): boolean;
  setAutoenablesItems(autoenablesItems: boolean): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
  itemArray(): NSArray<any>;
  numberOfItems(): NSInteger;
  lastItem(): NSMenuItem;
  selectedItem(): NSMenuItem;
  indexOfSelectedItem(): NSInteger;
  selectedTag(): NSInteger;
  itemTitles(): NSArray<any>;
  titleOfSelectedItem(): NSString;
}
declare const NSPopUpButton: {
  alloc(): NSPopUpButtonAllocator;
}

interface NSPopUpButtonCellAllocator<InitializedType = NSPopUpButtonCell> extends NSMenuItemCellAllocator<NSPopUpButtonCell> {
  initTextCell_pullsDown(stringValue: NSString | string, pullDown: boolean): InitializedType;
}
interface NSPopUpButtonCell extends NSMenuItemCell {
  addItemWithTitle(title: NSString | string): void;
  addItemsWithTitles(itemTitles: NSArray<any> | any[]): void;
  insertItemWithTitle_atIndex(title: NSString | string, index: NSInteger): void;
  removeItemWithTitle(title: NSString | string): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  indexOfItem(item: NSMenuItem): NSInteger;
  indexOfItemWithTitle(title: NSString | string): NSInteger;
  indexOfItemWithTag(tag: NSInteger): NSInteger;
  indexOfItemWithRepresentedObject(obj: any | null): NSInteger;
  indexOfItemWithTarget_andAction(target: any | null, actionSelector: string | null): NSInteger;
  itemAtIndex(index: NSInteger): NSMenuItem;
  itemWithTitle(title: NSString | string): NSMenuItem;
  selectItem(item: NSMenuItem | null): void;
  selectItemAtIndex(index: NSInteger): void;
  selectItemWithTitle(title: NSString | string): void;
  selectItemWithTag(tag: NSInteger): boolean;
  setTitle(string: NSString | string | null): void;
  synchronizeTitleAndSelectedItem(): void;
  itemTitleAtIndex(index: NSInteger): NSString;
  attachPopUpWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  dismissPopUp(): void;
  performClickWithFrame_inView(frame: NSRect, controlView: NSView): void;

  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  pullsDown(): boolean;
  setPullsDown(pullsDown: boolean): void;
  autoenablesItems(): boolean;
  setAutoenablesItems(autoenablesItems: boolean): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
  usesItemFromMenu(): boolean;
  setUsesItemFromMenu(usesItemFromMenu: boolean): void;
  altersStateOfSelectedItem(): boolean;
  setAltersStateOfSelectedItem(altersStateOfSelectedItem: boolean): void;
  itemArray(): NSArray<any>;
  numberOfItems(): NSInteger;
  lastItem(): NSMenuItem;
  selectedItem(): NSMenuItem;
  indexOfSelectedItem(): NSInteger;
  itemTitles(): NSArray<any>;
  titleOfSelectedItem(): NSString;
  arrowPosition(): NSPopUpArrowPosition;
  setArrowPosition(arrowPosition: NSPopUpArrowPosition): void;
}
declare const NSPopUpButtonCell: {
  alloc(): NSPopUpButtonCellAllocator;
}

declare enum NSPopUpArrowPosition {
  NSPopUpNoArrow = 0,
  NSPopUpArrowAtCenter = 1,
  NSPopUpArrowAtBottom = 2,
}

interface NSPopoverAllocator<InitializedType = NSPopover> extends NSResponderAllocator<NSPopover> {}
interface NSPopover extends NSResponder, INSAppearanceCustomization, INSAccessibilityElement, INSAccessibility {
  showRelativeToRect_ofView_preferredEdge(positioningRect: NSRect, positioningView: NSView, preferredEdge: NSRectEdge): void;
  performClose(sender: any | null): IBAction;
  close(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  //   appearance(): NSPopoverAppearance;
  //   setAppearance(appearance: NSPopoverAppearance): void;
  effectiveAppearance(): NSAppearance;
  behavior(): NSPopoverBehavior;
  setBehavior(behavior: NSPopoverBehavior): void;
  animates(): boolean;
  setAnimates(animates: boolean): void;
  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  contentSize(): NSSize;
  setContentSize(contentSize: NSSize): void;
  shown(): boolean;
  detached(): boolean;
  positioningRect(): NSRect;
  setPositioningRect(positioningRect: NSRect): void;
}
declare const NSPopover: {
  alloc(): NSPopoverAllocator;
}

interface INSPopoverDelegate {
  popoverShouldClose(popover: NSPopover): boolean;
  popoverShouldDetach(popover: NSPopover): boolean;
  popoverDidDetach(popover: NSPopover): void;
  detachableWindowForPopover(popover: NSPopover): NSWindow;
  popoverWillShow(notification: NSNotification): void;
  popoverDidShow(notification: NSNotification): void;
  popoverWillClose(notification: NSNotification): void;
  popoverDidClose(notification: NSNotification): void;
}

declare type NSPopoverCloseReasonValue = NSString

declare enum NSPopoverAppearance {
  NSPopoverAppearanceMinimal = 0,
  NSPopoverAppearanceHUD = 1,
}

declare enum NSPopoverBehavior {
  NSPopoverBehaviorApplicationDefined = 0,
  NSPopoverBehaviorTransient = 1,
  NSPopoverBehaviorSemitransient = 2,
}

interface NSPopoverTouchBarItemAllocator<InitializedType = NSPopoverTouchBarItem> extends NSTouchBarItemAllocator<NSPopoverTouchBarItem> {}
interface NSPopoverTouchBarItem extends NSTouchBarItem {
  showPopover(sender: any | null): void;
  dismissPopover(sender: any | null): void;
  makeStandardActivatePopoverGestureRecognizer(): NSGestureRecognizer;

  popoverTouchBar(): NSTouchBar;
  setPopoverTouchBar(popoverTouchBar: NSTouchBar): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
  collapsedRepresentation(): NSView;
  setCollapsedRepresentation(collapsedRepresentation: NSView): void;
  collapsedRepresentationImage(): NSImage;
  setCollapsedRepresentationImage(collapsedRepresentationImage: NSImage): void;
  collapsedRepresentationLabel(): NSString;
  setCollapsedRepresentationLabel(collapsedRepresentationLabel: NSString | string): void;
  pressAndHoldTouchBar(): NSTouchBar;
  setPressAndHoldTouchBar(pressAndHoldTouchBar: NSTouchBar): void;
  showsCloseButton(): boolean;
  setShowsCloseButton(showsCloseButton: boolean): void;
}
declare const NSPopoverTouchBarItem: {
  alloc(): NSPopoverTouchBarItemAllocator;
}

interface NSPredicateEditorAllocator<InitializedType = NSPredicateEditor> extends NSRuleEditorAllocator<NSPredicateEditor> {}
interface NSPredicateEditor extends NSRuleEditor {

  rowTemplates(): NSArray<any>;
  setRowTemplates(rowTemplates: NSArray<any> | any[]): void;
}
declare const NSPredicateEditor: {
  alloc(): NSPredicateEditorAllocator;
}

interface NSPredicateEditorRowTemplateAllocator<InitializedType = NSPredicateEditorRowTemplate> extends NSObjectAllocator<NSPredicateEditorRowTemplate> {
  initWithLeftExpressions_rightExpressions_modifier_operators_options(leftExpressions: NSArray<any> | any[], rightExpressions: NSArray<any> | any[], modifier: NSComparisonPredicateModifier, operators: NSArray<any> | any[], options: NSUInteger): InitializedType;
  initWithLeftExpressions_rightExpressionAttributeType_modifier_operators_options(leftExpressions: NSArray<any> | any[], attributeType: NSAttributeType, modifier: NSComparisonPredicateModifier, operators: NSArray<any> | any[], options: NSUInteger): InitializedType;
  initWithCompoundTypes(compoundTypes: NSArray<any> | any[]): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSPredicateEditorRowTemplate extends NSObject, INSCoding, INSCopying {
  matchForPredicate(predicate: NSPredicate): number;
  setPredicate(predicate: NSPredicate): void;
  predicateWithSubpredicates(subpredicates: NSArray<any> | any[] | null): NSPredicate;
  displayableSubpredicatesOfPredicate(predicate: NSPredicate): NSArray<any>;

  templateViews(): NSArray<any>;
  leftExpressions(): NSArray<any>;
  rightExpressions(): NSArray<any>;
  rightExpressionAttributeType(): NSAttributeType;
  modifier(): NSComparisonPredicateModifier;
  operators(): NSArray<any>;
  options(): NSUInteger;
  compoundTypes(): NSArray<any>;
}
declare const NSPredicateEditorRowTemplate: {
  alloc(): NSPredicateEditorRowTemplateAllocator;  templatesWithAttributeKeyPaths_inEntityDescription(keyPaths: NSArray<any> | any[], entityDescription: NSEntityDescription): NSArray<any>;

}

interface NSPressGestureRecognizerAllocator<InitializedType = NSPressGestureRecognizer> extends NSGestureRecognizerAllocator<NSPressGestureRecognizer> {}
interface NSPressGestureRecognizer extends NSGestureRecognizer, INSCoding {

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  minimumPressDuration(): NSTimeInterval;
  setMinimumPressDuration(minimumPressDuration: NSTimeInterval): void;
  allowableMovement(): CGFloat;
  setAllowableMovement(allowableMovement: CGFloat): void;
  numberOfTouchesRequired(): NSInteger;
  setNumberOfTouchesRequired(numberOfTouchesRequired: NSInteger): void;
}
declare const NSPressGestureRecognizer: {
  alloc(): NSPressGestureRecognizerAllocator;
}

interface NSPressureConfigurationAllocator<InitializedType = NSPressureConfiguration> extends NSObjectAllocator<NSPressureConfiguration> {
  initWithPressureBehavior(pressureBehavior: NSPressureBehavior): InitializedType;
}
interface NSPressureConfiguration extends NSObject {
  set(): void;

  pressureBehavior(): NSPressureBehavior;
}
declare const NSPressureConfiguration: {
  alloc(): NSPressureConfigurationAllocator;
}

interface NSPrintInfoAllocator<InitializedType = NSPrintInfo> extends NSObjectAllocator<NSPrintInfo> {
  initWithDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithCoder(inDecoder: NSCoder): InitializedType;
  init(): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSPrintInfo extends NSObject, INSCopying, INSCoding {
  dictionary(): NSMutableDictionary<any, any>;
  setUpPrintOperationDefaultValues(): void;
  PMPrintSession(): void;
  PMPageFormat(): void;
  PMPrintSettings(): void;
  updateFromPMPageFormat(): void;
  updateFromPMPrintSettings(): void;
  takeSettingsFromPDFInfo(inPDFInfo: NSPDFInfo): void;

  paperName(): NSPrinterPaperName;
  setPaperName(paperName: NSPrinterPaperName): void;
  paperSize(): NSSize;
  setPaperSize(paperSize: NSSize): void;
  orientation(): NSPaperOrientation;
  setOrientation(orientation: NSPaperOrientation): void;
  scalingFactor(): CGFloat;
  setScalingFactor(scalingFactor: CGFloat): void;
  leftMargin(): CGFloat;
  setLeftMargin(leftMargin: CGFloat): void;
  rightMargin(): CGFloat;
  setRightMargin(rightMargin: CGFloat): void;
  topMargin(): CGFloat;
  setTopMargin(topMargin: CGFloat): void;
  bottomMargin(): CGFloat;
  setBottomMargin(bottomMargin: CGFloat): void;
  horizontallyCentered(): boolean;
  setHorizontallyCentered(horizontallyCentered: boolean): void;
  verticallyCentered(): boolean;
  setVerticallyCentered(verticallyCentered: boolean): void;
  horizontalPagination(): NSPrintingPaginationMode;
  setHorizontalPagination(horizontalPagination: NSPrintingPaginationMode): void;
  verticalPagination(): NSPrintingPaginationMode;
  setVerticalPagination(verticalPagination: NSPrintingPaginationMode): void;
  jobDisposition(): NSPrintJobDispositionValue;
  setJobDisposition(jobDisposition: NSPrintJobDispositionValue): void;
  printer(): NSPrinter;
  setPrinter(printer: NSPrinter): void;
  imageablePageBounds(): NSRect;
  localizedPaperName(): NSString;
  printSettings(): NSMutableDictionary<any, any>;
  selectionOnly(): boolean;
  setSelectionOnly(selectionOnly: boolean): void;
}
declare const NSPrintInfo: {
  alloc(): NSPrintInfoAllocator;  setDefaultPrinter(printer: NSPrinter | null): void;
  sizeForPaperName(name: NSPrinterPaperName | null): NSSize;

  sharedPrintInfo(): NSPrintInfo;
  setSharedPrintInfo(sharedPrintInfo: NSPrintInfo): void;
  defaultPrinter(): NSPrinter;

}

declare type NSPrintInfoAttributeKey = NSString

declare type NSPrintJobDispositionValue = NSString

declare type NSPrintInfoSettingKey = NSString

declare enum NSPaperOrientation {
  NSPaperOrientationPortrait = 0,
  NSPaperOrientationLandscape = 1,
}

declare enum NSPrintingPaginationMode {
  NSAutoPagination = 0,
  NSFitPagination = 1,
  NSClipPagination = 2,
}

declare enum NSPrintingOrientation {
  NSPortraitOrientation = 0,
  NSLandscapeOrientation = 1,
}

interface NSPrintOperationAllocator<InitializedType = NSPrintOperation> extends NSObjectAllocator<NSPrintOperation> {}
interface NSPrintOperation extends NSObject {
  runOperationModalForWindow_delegate_didRunSelector_contextInfo(docWindow: NSWindow, delegate: any | null, didRunSelector: string | null, contextInfo: void | null): void;
  runOperation(): boolean;
  createContext(): NSGraphicsContext;
  destroyContext(): void;
  deliverResult(): boolean;
  cleanUpOperation(): void;
  setAccessoryView(view: NSView | null): void;
  accessoryView(): NSView;
  setJobStyleHint(hint: NSString | string | null): void;
  jobStyleHint(): NSString;
  setShowPanels(flag: boolean): void;
  showPanels(): boolean;

  copyingOperation(): boolean;
  preferredRenderingQuality(): NSPrintRenderingQuality;
  jobTitle(): NSString;
  setJobTitle(jobTitle: NSString | string): void;
  showsPrintPanel(): boolean;
  setShowsPrintPanel(showsPrintPanel: boolean): void;
  showsProgressPanel(): boolean;
  setShowsProgressPanel(showsProgressPanel: boolean): void;
  printPanel(): NSPrintPanel;
  setPrintPanel(printPanel: NSPrintPanel): void;
  PDFPanel(): NSPDFPanel;
  setPDFPanel(PDFPanel: NSPDFPanel): void;
  canSpawnSeparateThread(): boolean;
  setCanSpawnSeparateThread(canSpawnSeparateThread: boolean): void;
  pageOrder(): NSPrintingPageOrder;
  setPageOrder(pageOrder: NSPrintingPageOrder): void;
  view(): NSView;
  printInfo(): NSPrintInfo;
  setPrintInfo(printInfo: NSPrintInfo): void;
  context(): NSGraphicsContext;
  pageRange(): NSRange;
  currentPage(): NSInteger;
}
declare const NSPrintOperation: {
  alloc(): NSPrintOperationAllocator;  printOperationWithView_printInfo(view: NSView, printInfo: NSPrintInfo): NSPrintOperation;
  PDFOperationWithView_insideRect_toData_printInfo(view: NSView, rect: NSRect, data: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
  PDFOperationWithView_insideRect_toPath_printInfo(view: NSView, rect: NSRect, path: NSString | string, printInfo: NSPrintInfo): NSPrintOperation;
  EPSOperationWithView_insideRect_toData_printInfo(view: NSView, rect: NSRect, data: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
  EPSOperationWithView_insideRect_toPath_printInfo(view: NSView, rect: NSRect, path: NSString | string, printInfo: NSPrintInfo): NSPrintOperation;
  printOperationWithView(view: NSView): NSPrintOperation;
  PDFOperationWithView_insideRect_toData(view: NSView, rect: NSRect, data: NSMutableData): NSPrintOperation;
  EPSOperationWithView_insideRect_toData(view: NSView, rect: NSRect, data: NSMutableData | null): NSPrintOperation;

  currentOperation(): NSPrintOperation;
  setCurrentOperation(currentOperation: NSPrintOperation): void;

}

declare enum NSPrintingPageOrder {
  NSDescendingPageOrder = -1,
  NSSpecialPageOrder = 0,
  NSAscendingPageOrder = 1,
  NSUnknownPageOrder = 2,
}

declare enum NSPrintRenderingQuality {
  NSPrintRenderingQualityBest,
  NSPrintRenderingQualityResponsive,
}

interface NSPrintPanelAllocator<InitializedType = NSPrintPanel> extends NSObjectAllocator<NSPrintPanel> {}
interface NSPrintPanel extends NSObject {
  addAccessoryController(accessoryController: NSViewController): void;
  removeAccessoryController(accessoryController: NSViewController): void;
  setDefaultButtonTitle(defaultButtonTitle: NSString | string | null): void;
  defaultButtonTitle(): NSString;
  beginSheetWithPrintInfo_modalForWindow_delegate_didEndSelector_contextInfo(printInfo: NSPrintInfo, docWindow: NSWindow, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalWithPrintInfo(printInfo: NSPrintInfo): NSInteger;
  runModal(): NSInteger;
  setAccessoryView(accessoryView: NSView | null): void;
  accessoryView(): NSView;
  updateFromPrintInfo(): void;
  finalWritePrintInfo(): void;

  accessoryControllers(): NSArray<any>;
  options(): NSPrintPanelOptions;
  setOptions(options: NSPrintPanelOptions): void;
  helpAnchor(): NSHelpAnchorName;
  setHelpAnchor(helpAnchor: NSHelpAnchorName): void;
  jobStyleHint(): NSPrintPanelJobStyleHint;
  setJobStyleHint(jobStyleHint: NSPrintPanelJobStyleHint): void;
  printInfo(): NSPrintInfo;
}
declare const NSPrintPanel: {
  alloc(): NSPrintPanelAllocator;  printPanel(): NSPrintPanel;

}

interface INSPrintPanelAccessorizing {
  localizedSummaryItems(): NSArray<any>;
  keyPathsForValuesAffectingPreview(): NSSet<any>;
}

declare type NSPrintPanelJobStyleHint = NSString

declare type NSPrintPanelAccessorySummaryKey = NSString

declare enum NSPrintPanelOptions {
  NSPrintPanelShowsCopies = 1 << 0,
  NSPrintPanelShowsPageRange = 1 << 1,
  NSPrintPanelShowsPaperSize = 1 << 2,
  NSPrintPanelShowsOrientation = 1 << 3,
  NSPrintPanelShowsScaling = 1 << 4,
  NSPrintPanelShowsPrintSelection = 1 << 5,
  NSPrintPanelShowsPageSetupAccessory = 1 << 8,
  NSPrintPanelShowsPreview = 1 << 17,
}

interface NSPrinterAllocator<InitializedType = NSPrinter> extends NSObjectAllocator<NSPrinter> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSPrinter extends NSObject, INSCopying, INSCoding {
  pageSizeForPaper(paperName: NSPrinterPaperName): NSSize;
  statusForTable(tableName: NSString | string): NSPrinterTableStatus;
  isKey_inTable(key: NSString | string | null, table: NSString | string): boolean;
  booleanForKey_inTable(key: NSString | string | null, table: NSString | string): boolean;
  floatForKey_inTable(key: NSString | string | null, table: NSString | string): number;
  intForKey_inTable(key: NSString | string | null, table: NSString | string): number;
  rectForKey_inTable(key: NSString | string | null, table: NSString | string): NSRect;
  sizeForKey_inTable(key: NSString | string | null, table: NSString | string): NSSize;
  stringForKey_inTable(key: NSString | string | null, table: NSString | string): NSString;
  stringListForKey_inTable(key: NSString | string | null, table: NSString | string): NSArray<any>;
  imageRectForPaper(paperName: NSString | string | null): NSRect;
  acceptsBinary(): boolean;
  isColor(): boolean;
  isFontAvailable(faceName: NSString | string | null): boolean;
  isOutputStackInReverseOrder(): boolean;
  domain(): NSString;
  host(): NSString;
  note(): NSString;

  name(): NSString;
  type(): NSPrinterTypeName;
  languageLevel(): NSInteger;
  deviceDescription(): NSDictionary<any, any>;
}
declare const NSPrinter: {
  alloc(): NSPrinterAllocator;  printerWithName(name: NSString | string): NSPrinter;
  printerWithType(type: NSPrinterTypeName): NSPrinter;
  printerWithName_domain_includeUnavailable(name: NSString | string, domain: NSString | string | null, flag: boolean): NSPrinter;

  printerNames(): NSArray<any>;
  printerTypes(): NSArray<any>;

}

declare type NSPrinterTypeName = NSString

declare type NSPrinterPaperName = NSString

declare enum NSPrinterTableStatus {
  NSPrinterTableOK = 0,
  NSPrinterTableNotFound = 1,
  NSPrinterTableError = 2,
}

interface NSProgressIndicatorAllocator<InitializedType = NSProgressIndicator> extends NSViewAllocator<NSProgressIndicator> {}
interface NSProgressIndicator extends NSView, INSAccessibilityProgressIndicator {
  incrementBy(delta: number): void;
  startAnimation(sender: any | null): void;
  stopAnimation(sender: any | null): void;
  sizeToFit(): void;
  animationDelay(): NSTimeInterval;
  setAnimationDelay(delay: NSTimeInterval): void;
  animate(sender: any | null): void;

  indeterminate(): boolean;
  setIndeterminate(indeterminate: boolean): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  doubleValue(): number;
  setDoubleValue(doubleValue: number): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  usesThreadedAnimation(): boolean;
  setUsesThreadedAnimation(usesThreadedAnimation: boolean): void;
  style(): NSProgressIndicatorStyle;
  setStyle(style: NSProgressIndicatorStyle): void;
  displayedWhenStopped(): boolean;
  setDisplayedWhenStopped(displayedWhenStopped: boolean): void;
}
declare const NSProgressIndicator: {
  alloc(): NSProgressIndicatorAllocator;
}

declare enum NSProgressIndicatorStyle {
  NSProgressIndicatorStyleBar = 0,
  NSProgressIndicatorStyleSpinning = 1,
}

declare enum NSProgressIndicatorThickness {
  NSProgressIndicatorPreferredThickness = 14,
  NSProgressIndicatorPreferredSmallThickness = 10,
  NSProgressIndicatorPreferredLargeThickness = 18,
  NSProgressIndicatorPreferredAquaThickness = 12,
}

interface NSQuickDrawViewAllocator<InitializedType = NSQuickDrawView> extends NSViewAllocator<NSQuickDrawView> {}
interface NSQuickDrawView extends NSView {
  qdPort(): void;
}
declare const NSQuickDrawView: {
  alloc(): NSQuickDrawViewAllocator;
}

interface NSRotationGestureRecognizerAllocator<InitializedType = NSRotationGestureRecognizer> extends NSGestureRecognizerAllocator<NSRotationGestureRecognizer> {}
interface NSRotationGestureRecognizer extends NSGestureRecognizer {

  rotation(): CGFloat;
  setRotation(rotation: CGFloat): void;
  rotationInDegrees(): CGFloat;
  setRotationInDegrees(rotationInDegrees: CGFloat): void;
}
declare const NSRotationGestureRecognizer: {
  alloc(): NSRotationGestureRecognizerAllocator;
}

interface NSRuleEditorAllocator<InitializedType = NSRuleEditor> extends NSControlAllocator<NSRuleEditor> {}
interface NSRuleEditor extends NSControl {
  reloadCriteria(): void;
  reloadPredicate(): void;
  predicateForRow(row: NSInteger): NSPredicate;
  subrowIndexesForRow(rowIndex: NSInteger): NSIndexSet;
  criteriaForRow(row: NSInteger): NSArray<any>;
  displayValuesForRow(row: NSInteger): NSArray<any>;
  rowForDisplayValue(displayValue: any): NSInteger;
  rowTypeForRow(rowIndex: NSInteger): NSRuleEditorRowType;
  parentRowForRow(rowIndex: NSInteger): NSInteger;
  addRow(sender: any | null): void;
  insertRowAtIndex_withType_asSubrowOfRow_animate(rowIndex: NSInteger, rowType: NSRuleEditorRowType, parentRow: NSInteger, shouldAnimate: boolean): void;
  setCriteria_andDisplayValues_forRowAtIndex(criteria: NSArray<any> | any[], values: NSArray<any> | any[], rowIndex: NSInteger): void;
  removeRowAtIndex(rowIndex: NSInteger): void;
  removeRowsAtIndexes_includeSubrows(rowIndexes: NSIndexSet, includeSubrows: boolean): void;
  selectRowIndexes_byExtendingSelection(indexes: NSIndexSet, extend: boolean): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  formattingStringsFilename(): NSString;
  setFormattingStringsFilename(formattingStringsFilename: NSString | string): void;
  formattingDictionary(): NSDictionary<any, any>;
  setFormattingDictionary(formattingDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  nestingMode(): NSRuleEditorNestingMode;
  setNestingMode(nestingMode: NSRuleEditorNestingMode): void;
  rowHeight(): CGFloat;
  setRowHeight(rowHeight: CGFloat): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  canRemoveAllRows(): boolean;
  setCanRemoveAllRows(canRemoveAllRows: boolean): void;
  predicate(): NSPredicate;
  numberOfRows(): NSInteger;
  selectedRowIndexes(): NSIndexSet;
  rowClass(): any;
  setRowClass(rowClass: any): void;
  rowTypeKeyPath(): NSString;
  setRowTypeKeyPath(rowTypeKeyPath: NSString | string): void;
  subrowsKeyPath(): NSString;
  setSubrowsKeyPath(subrowsKeyPath: NSString | string): void;
  criteriaKeyPath(): NSString;
  setCriteriaKeyPath(criteriaKeyPath: NSString | string): void;
  displayValuesKeyPath(): NSString;
  setDisplayValuesKeyPath(displayValuesKeyPath: NSString | string): void;
}
declare const NSRuleEditor: {
  alloc(): NSRuleEditorAllocator;
}

interface INSRuleEditorDelegate {
  ruleEditor_numberOfChildrenForCriterion_withRowType(editor: NSRuleEditor, criterion: any | null, rowType: NSRuleEditorRowType): NSInteger;
  ruleEditor_child_forCriterion_withRowType(editor: NSRuleEditor, index: NSInteger, criterion: any | null, rowType: NSRuleEditorRowType): any;
  ruleEditor_displayValueForCriterion_inRow(editor: NSRuleEditor, criterion: any, row: NSInteger): any;
  ruleEditor_predicatePartsForCriterion_withDisplayValue_inRow(editor: NSRuleEditor, criterion: any, value: any, row: NSInteger): NSDictionary<any, any>;
  ruleEditorRowsDidChange(notification: NSNotification): void;
}

declare type NSRuleEditorPredicatePartKey = NSString

declare enum NSRuleEditorNestingMode {
  NSRuleEditorNestingModeSingle,
  NSRuleEditorNestingModeList,
  NSRuleEditorNestingModeCompound,
  NSRuleEditorNestingModeSimple,
}

declare enum NSRuleEditorRowType {
  NSRuleEditorRowTypeSimple,
  NSRuleEditorRowTypeCompound,
}

interface NSRulerMarkerAllocator<InitializedType = NSRulerMarker> extends NSObjectAllocator<NSRulerMarker> {
  initWithRulerView_markerLocation_image_imageOrigin(ruler: NSRulerView, location: CGFloat, image: NSImage, imageOrigin: NSPoint): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSRulerMarker extends NSObject, INSCopying, INSCoding {
  drawRect(rect: NSRect): void;
  trackMouse_adding(mouseDownEvent: NSEvent, isAdding: boolean): boolean;

  ruler(): NSRulerView;
  markerLocation(): CGFloat;
  setMarkerLocation(markerLocation: CGFloat): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  imageOrigin(): NSPoint;
  setImageOrigin(imageOrigin: NSPoint): void;
  movable(): boolean;
  setMovable(movable: boolean): void;
  removable(): boolean;
  setRemovable(removable: boolean): void;
  dragging(): boolean;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  imageRectInRuler(): NSRect;
  thicknessRequiredInRuler(): CGFloat;
}
declare const NSRulerMarker: {
  alloc(): NSRulerMarkerAllocator;
}

interface NSRulerViewAllocator<InitializedType = NSRulerView> extends NSViewAllocator<NSRulerView> {
  initWithScrollView_orientation(scrollView: NSScrollView | null, orientation: NSRulerOrientation): InitializedType;
}
interface NSRulerView extends NSView {
  addMarker(marker: NSRulerMarker): void;
  removeMarker(marker: NSRulerMarker): void;
  trackMarker_withMouseEvent(marker: NSRulerMarker, event: NSEvent): boolean;
  moveRulerlineFromLocation_toLocation(oldLocation: CGFloat, newLocation: CGFloat): void;
  invalidateHashMarks(): void;
  drawHashMarksAndLabelsInRect(rect: NSRect): void;
  drawMarkersInRect(rect: NSRect): void;

  scrollView(): NSScrollView;
  setScrollView(scrollView: NSScrollView): void;
  orientation(): NSRulerOrientation;
  setOrientation(orientation: NSRulerOrientation): void;
  baselineLocation(): CGFloat;
  requiredThickness(): CGFloat;
  ruleThickness(): CGFloat;
  setRuleThickness(ruleThickness: CGFloat): void;
  reservedThicknessForMarkers(): CGFloat;
  setReservedThicknessForMarkers(reservedThicknessForMarkers: CGFloat): void;
  reservedThicknessForAccessoryView(): CGFloat;
  setReservedThicknessForAccessoryView(reservedThicknessForAccessoryView: CGFloat): void;
  measurementUnits(): NSRulerViewUnitName;
  setMeasurementUnits(measurementUnits: NSRulerViewUnitName): void;
  originOffset(): CGFloat;
  setOriginOffset(originOffset: CGFloat): void;
  clientView(): NSView;
  setClientView(clientView: NSView): void;
  markers(): NSArray<any>;
  setMarkers(markers: NSArray<any> | any[]): void;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  flipped(): boolean;
}
declare const NSRulerView: {
  alloc(): NSRulerViewAllocator;  registerUnitWithName_abbreviation_unitToPointsConversionFactor_stepUpCycle_stepDownCycle(unitName: NSRulerViewUnitName, abbreviation: NSString | string, conversionFactor: CGFloat, stepUpCycle: NSArray<any> | any[], stepDownCycle: NSArray<any> | any[]): void;

}

declare type NSRulerViewUnitName = NSString

declare enum NSRulerOrientation {
  NSHorizontalRuler,
  NSVerticalRuler,
}

interface NSRunningApplicationAllocator<InitializedType = NSRunningApplication> extends NSObjectAllocator<NSRunningApplication> {}
interface NSRunningApplication extends NSObject {
  hide(): boolean;
  unhide(): boolean;
  activateWithOptions(options: NSApplicationActivationOptions): boolean;
  terminate(): boolean;
  forceTerminate(): boolean;

  terminated(): boolean;
  finishedLaunching(): boolean;
  hidden(): boolean;
  active(): boolean;
  ownsMenuBar(): boolean;
  activationPolicy(): NSApplicationActivationPolicy;
  localizedName(): NSString;
  bundleIdentifier(): NSString;
  bundleURL(): NSURL;
  executableURL(): NSURL;
  processIdentifier(): pid_t;
  launchDate(): NSDate;
  icon(): NSImage;
  executableArchitecture(): NSInteger;
}
declare const NSRunningApplication: {
  alloc(): NSRunningApplicationAllocator;  runningApplicationsWithBundleIdentifier(bundleIdentifier: NSString | string): NSArray<any>;
  runningApplicationWithProcessIdentifier(pid: pid_t): NSRunningApplication;
  terminateAutomaticallyTerminableApplications(): void;

  currentApplication(): NSRunningApplication;

}

declare enum NSApplicationActivationOptions {
  NSApplicationActivateAllWindows = 1 << 0,
  NSApplicationActivateIgnoringOtherApps = 1 << 1,
}

declare enum NSApplicationActivationPolicy {
  NSApplicationActivationPolicyRegular,
  NSApplicationActivationPolicyAccessory,
  NSApplicationActivationPolicyProhibited,
}

interface NSSavePanelAllocator<InitializedType = NSSavePanel> extends NSPanelAllocator<NSSavePanel> {}
interface NSSavePanel extends NSPanel {
  validateVisibleColumns(): void;
  ok(sender: any | null): IBAction;
  cancel(sender: any | null): IBAction;
  beginSheetModalForWindow_completionHandler(window: NSWindow, handler: Block): void;
  beginWithCompletionHandler(handler: Block): void;
  runModal(): NSModalResponse;
  filename(): NSString;
  directory(): NSString;
  setDirectory(path: NSString | string | null): void;
  requiredFileType(): NSString;
  setRequiredFileType(type: NSString | string | null): void;
  beginSheetForDirectory_file_modalForWindow_modalDelegate_didEndSelector_contextInfo(path: NSString | string, name: NSString | string | null, docWindow: NSWindow | null, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalForDirectory_file(path: NSString | string | null, name: NSString | string | null): NSInteger;
  selectText(sender: any | null): IBAction;

  URL(): NSURL;
  directoryURL(): NSURL;
  setDirectoryURL(directoryURL: NSURL): void;
  allowedFileTypes(): NSArray<any>;
  setAllowedFileTypes(allowedFileTypes: NSArray<any> | any[]): void;
  allowsOtherFileTypes(): boolean;
  setAllowsOtherFileTypes(allowsOtherFileTypes: boolean): void;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  expanded(): boolean;
  canCreateDirectories(): boolean;
  setCanCreateDirectories(canCreateDirectories: boolean): void;
  canSelectHiddenExtension(): boolean;
  setCanSelectHiddenExtension(canSelectHiddenExtension: boolean): void;
  extensionHidden(): boolean;
  setExtensionHidden(extensionHidden: boolean): void;
  treatsFilePackagesAsDirectories(): boolean;
  setTreatsFilePackagesAsDirectories(treatsFilePackagesAsDirectories: boolean): void;
  prompt(): NSString;
  setPrompt(prompt: NSString | string): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  nameFieldLabel(): NSString;
  setNameFieldLabel(nameFieldLabel: NSString | string): void;
  nameFieldStringValue(): NSString;
  setNameFieldStringValue(nameFieldStringValue: NSString | string): void;
  message(): NSString;
  setMessage(message: NSString | string): void;
  showsHiddenFiles(): boolean;
  setShowsHiddenFiles(showsHiddenFiles: boolean): void;
  showsTagField(): boolean;
  setShowsTagField(showsTagField: boolean): void;
  tagNames(): NSArray<any>;
  setTagNames(tagNames: NSArray<any> | any[]): void;
}
declare const NSSavePanel: {
  alloc(): NSSavePanelAllocator;  savePanel(): NSSavePanel;

}

interface INSOpenSavePanelDelegate {
  panel_shouldEnableURL(sender: any, url: NSURL): boolean;
  panel_validateURL_error(sender: any, url: NSURL, outError: NSError): boolean;
  panel_didChangeToDirectoryURL(sender: any, url: NSURL | null): void;
  panel_userEnteredFilename_confirmed(sender: any, filename: NSString | string, okFlag: boolean): NSString;
  panel_willExpand(sender: any, expanding: boolean): void;
  panelSelectionDidChange(sender: any | null): void;
}

interface NSScreenAllocator<InitializedType = NSScreen> extends NSObjectAllocator<NSScreen> {}
interface NSScreen extends NSObject {
  canRepresentDisplayGamut(displayGamut: NSDisplayGamut): boolean;
  convertRectToBacking(rect: NSRect): NSRect;
  convertRectFromBacking(rect: NSRect): NSRect;
  backingAlignedRect_options(rect: NSRect, options: NSAlignmentOptions): NSRect;
  userSpaceScaleFactor(): CGFloat;
  isOnRetinaScreen(): boolean;

  depth(): NSWindowDepth;
  frame(): NSRect;
  visibleFrame(): NSRect;
  deviceDescription(): NSDictionary<any, any>;
  colorSpace(): NSColorSpace;
  supportedWindowDepths(): NSWindowDepth;
  backingScaleFactor(): CGFloat;
  maximumExtendedDynamicRangeColorComponentValue(): CGFloat;
}
declare const NSScreen: {
  alloc(): NSScreenAllocator;
  screens(): NSArray<any>;
  mainScreen(): NSScreen;
  deepestScreen(): NSScreen;
  screensHaveSeparateSpaces(): boolean;
  highestBackingScale_bc(): CGFloat;

}

interface NSScrollViewAllocator<InitializedType = NSScrollView> extends NSViewAllocator<NSScrollView> {}
interface NSScrollView extends NSView, INSTextFinderBarContainer {
  tile(): void;
  reflectScrolledClipView(cView: NSClipView): void;
  scrollWheel(event: NSEvent): void;
  flashScrollers(): void;
  magnifyToFitRect(rect: NSRect): void;
  setMagnification_centeredAtPoint(magnification: CGFloat, point: NSPoint): void;
  addFloatingSubview_forAxis(view: NSView, axis: NSEventGestureAxis): void;

  documentVisibleRect(): NSRect;
  contentSize(): NSSize;
  documentView(): NSView;
  setDocumentView(documentView: NSView): void;
  contentView(): NSClipView;
  setContentView(contentView: NSClipView): void;
  documentCursor(): NSCursor;
  setDocumentCursor(documentCursor: NSCursor): void;
  borderType(): NSBorderType;
  setBorderType(borderType: NSBorderType): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  hasVerticalScroller(): boolean;
  setHasVerticalScroller(hasVerticalScroller: boolean): void;
  hasHorizontalScroller(): boolean;
  setHasHorizontalScroller(hasHorizontalScroller: boolean): void;
  verticalScroller(): NSScroller;
  setVerticalScroller(verticalScroller: NSScroller): void;
  horizontalScroller(): NSScroller;
  setHorizontalScroller(horizontalScroller: NSScroller): void;
  autohidesScrollers(): boolean;
  setAutohidesScrollers(autohidesScrollers: boolean): void;
  horizontalLineScroll(): CGFloat;
  setHorizontalLineScroll(horizontalLineScroll: CGFloat): void;
  verticalLineScroll(): CGFloat;
  setVerticalLineScroll(verticalLineScroll: CGFloat): void;
  lineScroll(): CGFloat;
  setLineScroll(lineScroll: CGFloat): void;
  horizontalPageScroll(): CGFloat;
  setHorizontalPageScroll(horizontalPageScroll: CGFloat): void;
  verticalPageScroll(): CGFloat;
  setVerticalPageScroll(verticalPageScroll: CGFloat): void;
  pageScroll(): CGFloat;
  setPageScroll(pageScroll: CGFloat): void;
  scrollsDynamically(): boolean;
  setScrollsDynamically(scrollsDynamically: boolean): void;
  scrollerStyle(): NSScrollerStyle;
  setScrollerStyle(scrollerStyle: NSScrollerStyle): void;
  scrollerKnobStyle(): NSScrollerKnobStyle;
  setScrollerKnobStyle(scrollerKnobStyle: NSScrollerKnobStyle): void;
  horizontalScrollElasticity(): NSScrollElasticity;
  setHorizontalScrollElasticity(horizontalScrollElasticity: NSScrollElasticity): void;
  verticalScrollElasticity(): NSScrollElasticity;
  setVerticalScrollElasticity(verticalScrollElasticity: NSScrollElasticity): void;
  usesPredominantAxisScrolling(): boolean;
  setUsesPredominantAxisScrolling(usesPredominantAxisScrolling: boolean): void;
  allowsMagnification(): boolean;
  setAllowsMagnification(allowsMagnification: boolean): void;
  magnification(): CGFloat;
  setMagnification(magnification: CGFloat): void;
  maxMagnification(): CGFloat;
  setMaxMagnification(maxMagnification: CGFloat): void;
  minMagnification(): CGFloat;
  setMinMagnification(minMagnification: CGFloat): void;
  automaticallyAdjustsContentInsets(): boolean;
  setAutomaticallyAdjustsContentInsets(automaticallyAdjustsContentInsets: boolean): void;
  contentInsets(): NSEdgeInsets;
  setContentInsets(contentInsets: NSEdgeInsets): void;
  scrollerInsets(): NSEdgeInsets;
  setScrollerInsets(scrollerInsets: NSEdgeInsets): void;
  rulersVisible(): boolean;
  setRulersVisible(rulersVisible: boolean): void;
  hasHorizontalRuler(): boolean;
  setHasHorizontalRuler(hasHorizontalRuler: boolean): void;
  hasVerticalRuler(): boolean;
  setHasVerticalRuler(hasVerticalRuler: boolean): void;
  horizontalRulerView(): NSRulerView;
  setHorizontalRulerView(horizontalRulerView: NSRulerView): void;
  verticalRulerView(): NSRulerView;
  setVerticalRulerView(verticalRulerView: NSRulerView): void;
  findBarPosition(): NSScrollViewFindBarPosition;
  setFindBarPosition(findBarPosition: NSScrollViewFindBarPosition): void;
}
declare const NSScrollView: {
  alloc(): NSScrollViewAllocator;  frameSizeForContentSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(cSize: NSSize, horizontalScrollerClass: any | null, verticalScrollerClass: any | null, type: NSBorderType, controlSize: NSControlSize, scrollerStyle: NSScrollerStyle): NSSize;
  contentSizeForFrameSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(fSize: NSSize, horizontalScrollerClass: any | null, verticalScrollerClass: any | null, type: NSBorderType, controlSize: NSControlSize, scrollerStyle: NSScrollerStyle): NSSize;
  frameSizeForContentSize_hasHorizontalScroller_hasVerticalScroller_borderType(cSize: NSSize, hFlag: boolean, vFlag: boolean, type: NSBorderType): NSSize;
  contentSizeForFrameSize_hasHorizontalScroller_hasVerticalScroller_borderType(fSize: NSSize, hFlag: boolean, vFlag: boolean, type: NSBorderType): NSSize;

  rulerViewClass(): any;
  setRulerViewClass(rulerViewClass: any): void;

}

declare enum NSScrollElasticity {
  NSScrollElasticityAutomatic = 0,
  NSScrollElasticityNone = 1,
  NSScrollElasticityAllowed = 2,
}

declare enum NSScrollViewFindBarPosition {
  NSScrollViewFindBarPositionAboveHorizontalRuler = 0,
  NSScrollViewFindBarPositionAboveContent = 1,
  NSScrollViewFindBarPositionBelowContent = 2,
}

interface NSScrollerAllocator<InitializedType = NSScroller> extends NSControlAllocator<NSScroller> {}
interface NSScroller extends NSControl {
  drawParts(): void;
  rectForPart(partCode: NSScrollerPart): NSRect;
  checkSpaceForParts(): void;
  drawArrow_highlight(whichArrow: NSScrollerArrow, flag: boolean): void;
  drawKnob(): void;
  drawKnobSlotInRect_highlight(slotRect: NSRect, flag: boolean): void;
  highlight(flag: boolean): void;
  testPart(point: NSPoint): NSScrollerPart;
  trackKnob(event: NSEvent): void;
  trackScrollButtons(event: NSEvent): void;
  setKnobProportion(proportion: CGFloat): void;
  setFloatValue_knobProportion(value: number, proportion: CGFloat): void;

  scrollerStyle(): NSScrollerStyle;
  setScrollerStyle(scrollerStyle: NSScrollerStyle): void;
  knobStyle(): NSScrollerKnobStyle;
  setKnobStyle(knobStyle: NSScrollerKnobStyle): void;
  usableParts(): NSUsableScrollerParts;
  arrowsPosition(): NSScrollArrowPosition;
  setArrowsPosition(arrowsPosition: NSScrollArrowPosition): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  hitPart(): NSScrollerPart;
  knobProportion(): CGFloat;
  setKnobProportion(knobProportion: CGFloat): void;
}
declare const NSScroller: {
  alloc(): NSScrollerAllocator;  scrollerWidthForControlSize_scrollerStyle(controlSize: NSControlSize, scrollerStyle: NSScrollerStyle): CGFloat;
  scrollerWidthForControlSize(controlSize: NSControlSize): CGFloat;
  scrollerWidth(): CGFloat;

  compatibleWithOverlayScrollers(): boolean;
  preferredScrollerStyle(): NSScrollerStyle;

}

declare enum NSScrollArrowPosition {
  NSScrollerArrowsMaxEnd = 0,
  NSScrollerArrowsMinEnd = 1,
  NSScrollerArrowsDefaultSetting = 0,
  NSScrollerArrowsNone = 2,
}

declare enum NSUsableScrollerParts {
  NSNoScrollerParts = 0,
  NSOnlyScrollerArrows = 1,
  NSAllScrollerParts = 2,
}

declare enum NSScrollerPart {
  NSScrollerNoPart = 0,
  NSScrollerDecrementPage = 1,
  NSScrollerKnob = 2,
  NSScrollerIncrementPage = 3,
  NSScrollerDecrementLine = 4,
  NSScrollerIncrementLine = 5,
  NSScrollerKnobSlot = 6,
}

declare enum NSScrollerArrow {
  NSScrollerIncrementArrow = 0,
  NSScrollerDecrementArrow = 1,
}

declare enum NSScrollerStyle {
  NSScrollerStyleLegacy = 0,
  NSScrollerStyleOverlay = 1,
}

declare enum NSScrollerKnobStyle {
  NSScrollerKnobStyleDefault = 0,
  NSScrollerKnobStyleDark = 1,
  NSScrollerKnobStyleLight = 2,
}

interface NSScrubberSelectionStyleAllocator<InitializedType = NSScrubberSelectionStyle> extends NSObjectAllocator<NSScrubberSelectionStyle> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSScrubberSelectionStyle extends NSObject, INSCoding {
  makeSelectionView(): NSScrubberSelectionView;
}
declare const NSScrubberSelectionStyle: {
  alloc(): NSScrubberSelectionStyleAllocator;
  outlineOverlayStyle(): NSScrubberSelectionStyle;
  roundedBackgroundStyle(): NSScrubberSelectionStyle;

}

interface NSScrubberAllocator<InitializedType = NSScrubber> extends NSViewAllocator<NSScrubber> {}
interface NSScrubber extends NSView {
  reloadData(): void;
  performSequentialBatchUpdates(updateBlock: Block): void;
  insertItemsAtIndexes(indexes: NSIndexSet): void;
  removeItemsAtIndexes(indexes: NSIndexSet): void;
  reloadItemsAtIndexes(indexes: NSIndexSet): void;
  moveItemAtIndex_toIndex(oldIndex: NSInteger, newIndex: NSInteger): void;
  scrollItemAtIndex_toAlignment(index: NSInteger, alignment: NSScrubberAlignment): void;
  itemViewForItemAtIndex(index: NSInteger): NSScrubberItemView;
  registerClass_forItemIdentifier(itemViewClass: any | null, itemIdentifier: NSUserInterfaceItemIdentifier): void;
  registerNib_forItemIdentifier(nib: NSNib | null, itemIdentifier: NSUserInterfaceItemIdentifier): void;
  makeItemWithIdentifier_owner(itemIdentifier: NSUserInterfaceItemIdentifier, owner: any | null): NSScrubberItemView;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  scrubberLayout(): NSScrubberLayout;
  setScrubberLayout(scrubberLayout: NSScrubberLayout): void;
  numberOfItems(): NSInteger;
  highlightedIndex(): NSInteger;
  selectedIndex(): NSInteger;
  setSelectedIndex(selectedIndex: NSInteger): void;
  mode(): NSScrubberMode;
  setMode(mode: NSScrubberMode): void;
  itemAlignment(): NSScrubberAlignment;
  setItemAlignment(itemAlignment: NSScrubberAlignment): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  floatsSelectionViews(): boolean;
  setFloatsSelectionViews(floatsSelectionViews: boolean): void;
  selectionBackgroundStyle(): NSScrubberSelectionStyle;
  setSelectionBackgroundStyle(selectionBackgroundStyle: NSScrubberSelectionStyle): void;
  selectionOverlayStyle(): NSScrubberSelectionStyle;
  setSelectionOverlayStyle(selectionOverlayStyle: NSScrubberSelectionStyle): void;
  showsArrowButtons(): boolean;
  setShowsArrowButtons(showsArrowButtons: boolean): void;
  showsAdditionalContentIndicators(): boolean;
  setShowsAdditionalContentIndicators(showsAdditionalContentIndicators: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  backgroundView(): NSView;
  setBackgroundView(backgroundView: NSView): void;
}
declare const NSScrubber: {
  alloc(): NSScrubberAllocator;
}

interface INSScrubberDataSource {
  numberOfItemsForScrubber(scrubber: NSScrubber): NSInteger;
  scrubber_viewForItemAtIndex(scrubber: NSScrubber, index: NSInteger): NSScrubberItemView;
}

interface INSScrubberDelegate {
  scrubber_didSelectItemAtIndex(scrubber: NSScrubber, selectedIndex: NSInteger): void;
  scrubber_didHighlightItemAtIndex(scrubber: NSScrubber, highlightedIndex: NSInteger): void;
  scrubber_didChangeVisibleRange(scrubber: NSScrubber, visibleRange: NSRange): void;
  didBeginInteractingWithScrubber(scrubber: NSScrubber): void;
  didFinishInteractingWithScrubber(scrubber: NSScrubber): void;
  didCancelInteractingWithScrubber(scrubber: NSScrubber): void;
}

declare enum NSScrubberMode {
  NSScrubberModeFixed = 0,
  NSScrubberModeFree,
}

declare enum NSScrubberAlignment {
  NSScrubberAlignmentNone = 0,
  NSScrubberAlignmentLeading,
  NSScrubberAlignmentTrailing,
  NSScrubberAlignmentCenter,
}

interface NSScrubberArrangedViewAllocator<InitializedType = NSScrubberArrangedView> extends NSViewAllocator<NSScrubberArrangedView> {}
interface NSScrubberArrangedView extends NSView {

  selected(): boolean;
  setSelected(selected: boolean): void;
  highlighted(): boolean;
  setHighlighted(highlighted: boolean): void;
}
declare const NSScrubberArrangedView: {
  alloc(): NSScrubberArrangedViewAllocator;
}

interface NSScrubberSelectionViewAllocator<InitializedType = NSScrubberSelectionView> extends NSScrubberArrangedViewAllocator<NSScrubberSelectionView> {}
interface NSScrubberSelectionView extends NSScrubberArrangedView {
}
declare const NSScrubberSelectionView: {
  alloc(): NSScrubberSelectionViewAllocator;
}

interface NSScrubberItemViewAllocator<InitializedType = NSScrubberItemView> extends NSScrubberArrangedViewAllocator<NSScrubberItemView> {}
interface NSScrubberItemView extends NSScrubberArrangedView {
}
declare const NSScrubberItemView: {
  alloc(): NSScrubberItemViewAllocator;
}

interface NSScrubberTextItemViewAllocator<InitializedType = NSScrubberTextItemView> extends NSScrubberItemViewAllocator<NSScrubberTextItemView> {}
interface NSScrubberTextItemView extends NSScrubberItemView {

  textField(): NSTextField;
  title(): NSString;
  setTitle(title: NSString | string): void;
}
declare const NSScrubberTextItemView: {
  alloc(): NSScrubberTextItemViewAllocator;
}

interface NSScrubberImageItemViewAllocator<InitializedType = NSScrubberImageItemView> extends NSScrubberItemViewAllocator<NSScrubberImageItemView> {}
interface NSScrubberImageItemView extends NSScrubberItemView {

  imageView(): NSImageView;
  image(): NSImage;
  setImage(image: NSImage): void;
  imageAlignment(): NSImageAlignment;
  setImageAlignment(imageAlignment: NSImageAlignment): void;
}
declare const NSScrubberImageItemView: {
  alloc(): NSScrubberImageItemViewAllocator;
}

interface NSScrubberLayoutAttributesAllocator<InitializedType = NSScrubberLayoutAttributes> extends NSObjectAllocator<NSScrubberLayoutAttributes> {}
interface NSScrubberLayoutAttributes extends NSObject, INSCopying {

  itemIndex(): NSInteger;
  setItemIndex(itemIndex: NSInteger): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
  alpha(): CGFloat;
  setAlpha(alpha: CGFloat): void;
}
declare const NSScrubberLayoutAttributes: {
  alloc(): NSScrubberLayoutAttributesAllocator;  layoutAttributesForItemAtIndex(index: NSInteger): NSScrubberLayoutAttributes;

}

interface NSScrubberLayoutAllocator<InitializedType = NSScrubberLayout> extends NSObjectAllocator<NSScrubberLayout> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSScrubberLayout extends NSObject, INSCoding {
  prepareLayout(): void;
  layoutAttributesForItemAtIndex(index: NSInteger): NSScrubberLayoutAttributes;
  layoutAttributesForItemsInRect(rect: NSRect): NSSet<any>;
  shouldInvalidateLayoutForChangeFromVisibleRect_toVisibleRect(fromVisibleRect: NSRect, toVisibleRect: NSRect): boolean;

  scrubber(): NSScrubber;
  visibleRect(): NSRect;
  scrubberContentSize(): NSSize;
  shouldInvalidateLayoutForSelectionChange(): boolean;
  shouldInvalidateLayoutForHighlightChange(): boolean;
  automaticallyMirrorsInRightToLeftLayout(): boolean;
}
declare const NSScrubberLayout: {
  alloc(): NSScrubberLayoutAllocator;
  layoutAttributesClass(): any;

}

interface NSScrubberFlowLayoutAllocator<InitializedType = NSScrubberFlowLayout> extends NSScrubberLayoutAllocator<NSScrubberFlowLayout> {}
interface NSScrubberFlowLayout extends NSScrubberLayout {
  invalidateLayoutForItemsAtIndexes(invalidItemIndexes: NSIndexSet): void;

  itemSpacing(): CGFloat;
  setItemSpacing(itemSpacing: CGFloat): void;
  itemSize(): NSSize;
  setItemSize(itemSize: NSSize): void;
}
declare const NSScrubberFlowLayout: {
  alloc(): NSScrubberFlowLayoutAllocator;
}

interface NSScrubberProportionalLayoutAllocator<InitializedType = NSScrubberProportionalLayout> extends NSScrubberLayoutAllocator<NSScrubberProportionalLayout> {
  initWithNumberOfVisibleItems(numberOfVisibleItems: NSInteger): InitializedType;
}
interface NSScrubberProportionalLayout extends NSScrubberLayout {

  numberOfVisibleItems(): NSInteger;
  setNumberOfVisibleItems(numberOfVisibleItems: NSInteger): void;
}
declare const NSScrubberProportionalLayout: {
  alloc(): NSScrubberProportionalLayoutAllocator;
}

interface INSScrubberFlowLayoutDelegate {
  scrubber_layout_sizeForItemAtIndex(scrubber: NSScrubber, layout: NSScrubberFlowLayout, itemIndex: NSInteger): NSSize;
}

interface NSSearchFieldAllocator<InitializedType = NSSearchField> extends NSTextFieldAllocator<NSSearchField> {}
interface NSSearchField extends NSTextField {
  rectForSearchTextWhenCentered(isCentered: boolean): NSRect;
  rectForSearchButtonWhenCentered(isCentered: boolean): NSRect;
  rectForCancelButtonWhenCentered(isCentered: boolean): NSRect;

  recentSearches(): NSArray<any>;
  setRecentSearches(recentSearches: NSArray<any> | any[]): void;
  recentsAutosaveName(): NSSearchFieldRecentsAutosaveName;
  setRecentsAutosaveName(recentsAutosaveName: NSSearchFieldRecentsAutosaveName): void;
  searchMenuTemplate(): NSMenu;
  setSearchMenuTemplate(searchMenuTemplate: NSMenu): void;
  sendsWholeSearchString(): boolean;
  setSendsWholeSearchString(sendsWholeSearchString: boolean): void;
  maximumRecents(): NSInteger;
  setMaximumRecents(maximumRecents: NSInteger): void;
  sendsSearchStringImmediately(): boolean;
  setSendsSearchStringImmediately(sendsSearchStringImmediately: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  centersPlaceholder(): boolean;
  setCentersPlaceholder(centersPlaceholder: boolean): void;
}
declare const NSSearchField: {
  alloc(): NSSearchFieldAllocator;
}

interface INSSearchFieldDelegate {
  searchFieldDidStartSearching(sender: NSSearchField): void;
  searchFieldDidEndSearching(sender: NSSearchField): void;
}

declare type NSSearchFieldRecentsAutosaveName = NSString

interface NSSearchFieldCellAllocator<InitializedType = NSSearchFieldCell> extends NSTextFieldCellAllocator<NSSearchFieldCell> {}
interface NSSearchFieldCell extends NSTextFieldCell {
  resetSearchButtonCell(): void;
  resetCancelButtonCell(): void;
  searchTextRectForBounds(rect: NSRect): NSRect;
  searchButtonRectForBounds(rect: NSRect): NSRect;
  cancelButtonRectForBounds(rect: NSRect): NSRect;

  searchButtonCell(): NSButtonCell;
  setSearchButtonCell(searchButtonCell: NSButtonCell): void;
  cancelButtonCell(): NSButtonCell;
  setCancelButtonCell(cancelButtonCell: NSButtonCell): void;
  searchMenuTemplate(): NSMenu;
  setSearchMenuTemplate(searchMenuTemplate: NSMenu): void;
  sendsWholeSearchString(): boolean;
  setSendsWholeSearchString(sendsWholeSearchString: boolean): void;
  maximumRecents(): NSInteger;
  setMaximumRecents(maximumRecents: NSInteger): void;
  recentSearches(): NSArray<any>;
  setRecentSearches(recentSearches: NSArray<any> | any[]): void;
  recentsAutosaveName(): NSSearchFieldRecentsAutosaveName;
  setRecentsAutosaveName(recentsAutosaveName: NSSearchFieldRecentsAutosaveName): void;
  sendsSearchStringImmediately(): boolean;
  setSendsSearchStringImmediately(sendsSearchStringImmediately: boolean): void;
}
declare const NSSearchFieldCell: {
  alloc(): NSSearchFieldCellAllocator;
}

interface NSSecureTextFieldAllocator<InitializedType = NSSecureTextField> extends NSTextFieldAllocator<NSSecureTextField> {}
interface NSSecureTextField extends NSTextField {
}
declare const NSSecureTextField: {
  alloc(): NSSecureTextFieldAllocator;
}

interface NSSecureTextFieldCellAllocator<InitializedType = NSSecureTextFieldCell> extends NSTextFieldCellAllocator<NSSecureTextFieldCell> {}
interface NSSecureTextFieldCell extends NSTextFieldCell {

  echosBullets(): boolean;
  setEchosBullets(echosBullets: boolean): void;
}
declare const NSSecureTextFieldCell: {
  alloc(): NSSecureTextFieldCellAllocator;
}

interface NSSegmentedCellAllocator<InitializedType = NSSegmentedCell> extends NSActionCellAllocator<NSSegmentedCell> {}
interface NSSegmentedCell extends NSActionCell {
  selectSegmentWithTag(tag: NSInteger): boolean;
  makeNextSegmentKey(): void;
  makePreviousSegmentKey(): void;
  setWidth_forSegment(width: CGFloat, segment: NSInteger): void;
  widthForSegment(segment: NSInteger): CGFloat;
  setImage_forSegment(image: NSImage | null, segment: NSInteger): void;
  imageForSegment(segment: NSInteger): NSImage;
  setImageScaling_forSegment(scaling: NSImageScaling, segment: NSInteger): void;
  imageScalingForSegment(segment: NSInteger): NSImageScaling;
  setLabel_forSegment(label: NSString | string, segment: NSInteger): void;
  labelForSegment(segment: NSInteger): NSString;
  setSelected_forSegment(selected: boolean, segment: NSInteger): void;
  isSelectedForSegment(segment: NSInteger): boolean;
  setEnabled_forSegment(enabled: boolean, segment: NSInteger): void;
  isEnabledForSegment(segment: NSInteger): boolean;
  setMenu_forSegment(menu: NSMenu | null, segment: NSInteger): void;
  menuForSegment(segment: NSInteger): NSMenu;
  setToolTip_forSegment(toolTip: NSString | string | null, segment: NSInteger): void;
  toolTipForSegment(segment: NSInteger): NSString;
  setTag_forSegment(tag: NSInteger, segment: NSInteger): void;
  tagForSegment(segment: NSInteger): NSInteger;
  drawSegment_inFrame_withView(segment: NSInteger, frame: NSRect, controlView: NSView): void;
  interiorBackgroundStyleForSegment(segment: NSInteger): NSBackgroundStyle;

  segmentCount(): NSInteger;
  setSegmentCount(segmentCount: NSInteger): void;
  selectedSegment(): NSInteger;
  setSelectedSegment(selectedSegment: NSInteger): void;
  trackingMode(): NSSegmentSwitchTracking;
  setTrackingMode(trackingMode: NSSegmentSwitchTracking): void;
  segmentStyle(): NSSegmentStyle;
  setSegmentStyle(segmentStyle: NSSegmentStyle): void;
}
declare const NSSegmentedCell: {
  alloc(): NSSegmentedCellAllocator;
}

interface NSSegmentedControlAllocator<InitializedType = NSSegmentedControl> extends NSControlAllocator<NSSegmentedControl> {}
interface NSSegmentedControl extends NSControl, INSUserInterfaceCompression {
  selectSegmentWithTag(tag: NSInteger): boolean;
  setWidth_forSegment(width: CGFloat, segment: NSInteger): void;
  widthForSegment(segment: NSInteger): CGFloat;
  setImage_forSegment(image: NSImage | null, segment: NSInteger): void;
  imageForSegment(segment: NSInteger): NSImage;
  setImageScaling_forSegment(scaling: NSImageScaling, segment: NSInteger): void;
  imageScalingForSegment(segment: NSInteger): NSImageScaling;
  setLabel_forSegment(label: NSString | string, segment: NSInteger): void;
  labelForSegment(segment: NSInteger): NSString;
  setMenu_forSegment(menu: NSMenu | null, segment: NSInteger): void;
  menuForSegment(segment: NSInteger): NSMenu;
  setSelected_forSegment(selected: boolean, segment: NSInteger): void;
  isSelectedForSegment(segment: NSInteger): boolean;
  setEnabled_forSegment(enabled: boolean, segment: NSInteger): void;
  isEnabledForSegment(segment: NSInteger): boolean;
  setToolTip_forSegment(toolTip: NSString | string | null, segment: NSInteger): void;
  toolTipForSegment(segment: NSInteger): NSString;
  setTag_forSegment(tag: NSInteger, segment: NSInteger): void;
  tagForSegment(segment: NSInteger): NSInteger;
  setShowsMenuIndicator_forSegment(showsMenuIndicator: boolean, segment: NSInteger): void;
  showsMenuIndicatorForSegment(segment: NSInteger): boolean;
  setAlignment_forSegment(alignment: NSTextAlignment, segment: NSInteger): void;
  alignmentForSegment(segment: NSInteger): NSTextAlignment;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;

  segmentCount(): NSInteger;
  setSegmentCount(segmentCount: NSInteger): void;
  selectedSegment(): NSInteger;
  setSelectedSegment(selectedSegment: NSInteger): void;
  segmentStyle(): NSSegmentStyle;
  setSegmentStyle(segmentStyle: NSSegmentStyle): void;
  springLoaded(): boolean;
  setSpringLoaded(springLoaded: boolean): void;
  trackingMode(): NSSegmentSwitchTracking;
  setTrackingMode(trackingMode: NSSegmentSwitchTracking): void;
  doubleValueForSelectedSegment(): number;
  selectedSegmentBezelColor(): NSColor;
  setSelectedSegmentBezelColor(selectedSegmentBezelColor: NSColor): void;
  indexOfSelectedItem(): NSInteger;
  segmentDistribution(): NSSegmentDistribution;
  setSegmentDistribution(segmentDistribution: NSSegmentDistribution): void;
  activeCompressionOptions(): NSUserInterfaceCompressionOptions;
}
declare const NSSegmentedControl: {
  alloc(): NSSegmentedControlAllocator;  segmentedControlWithLabels_trackingMode_target_action(labels: NSArray<any> | any[], trackingMode: NSSegmentSwitchTracking, target: any | null, action: string | null): NSSegmentedControl;
  segmentedControlWithImages_trackingMode_target_action(images: NSArray<any> | any[], trackingMode: NSSegmentSwitchTracking, target: any | null, action: string | null): NSSegmentedControl;

}

declare enum NSSegmentSwitchTracking {
  NSSegmentSwitchTrackingSelectOne = 0,
  NSSegmentSwitchTrackingSelectAny = 1,
  NSSegmentSwitchTrackingMomentary = 2,
  NSSegmentSwitchTrackingMomentaryAccelerator = 3,
}

declare enum NSSegmentStyle {
  NSSegmentStyleAutomatic = 0,
  NSSegmentStyleRounded = 1,
  NSSegmentStyleRoundRect = 3,
  NSSegmentStyleTexturedSquare = 4,
  NSSegmentStyleSmallSquare = 6,
  NSSegmentStyleSeparated = 8,
  NSSegmentStyleTexturedRounded = 2,
  NSSegmentStyleCapsule = 5,
}

declare enum NSSegmentDistribution {
  NSSegmentDistributionFit = 0,
  NSSegmentDistributionFill,
  NSSegmentDistributionFillEqually,
  NSSegmentDistributionFillProportionally,
}

interface NSShadowAllocator<InitializedType = NSShadow> extends NSObjectAllocator<NSShadow> {
  init(): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSShadow extends NSObject, INSCopying, INSCoding {
  set(): void;

  shadowOffset(): NSSize;
  setShadowOffset(shadowOffset: NSSize): void;
  shadowBlurRadius(): CGFloat;
  setShadowBlurRadius(shadowBlurRadius: CGFloat): void;
  shadowColor(): NSColor;
  setShadowColor(shadowColor: NSColor): void;
}
declare const NSShadow: {
  alloc(): NSShadowAllocator;  shadowWithColor_offset_blur(color: NSColor, offset: NSSize, blur: CGFloat): NSShadow;
  clearShadow(): void;

}

interface NSSharingServiceAllocator<InitializedType = NSSharingService> extends NSObjectAllocator<NSSharingService> {
  initWithTitle_image_alternateImage_handler(title: NSString | string, image: NSImage, alternateImage: NSImage | null, block: Block): InitializedType;
}
interface NSSharingService extends NSObject {
  canPerformWithItems(items: NSArray<any> | any[] | null): boolean;
  performWithItems(items: NSArray<any> | any[]): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  title(): NSString;
  image(): NSImage;
  alternateImage(): NSImage;
  menuItemTitle(): NSString;
  setMenuItemTitle(menuItemTitle: NSString | string): void;
  recipients(): NSArray<any>;
  setRecipients(recipients: NSArray<any> | any[]): void;
  subject(): NSString;
  setSubject(subject: NSString | string): void;
  messageBody(): NSString;
  permanentLink(): NSURL;
  accountName(): NSString;
  attachmentFileURLs(): NSArray<any>;
}
declare const NSSharingService: {
  alloc(): NSSharingServiceAllocator;  sharingServicesForItems(items: NSArray<any> | any[]): NSArray<any>;
  sharingServiceNamed(serviceName: NSSharingServiceName): NSSharingService;

}

interface NSSharingServicePickerAllocator<InitializedType = NSSharingServicePicker> extends NSObjectAllocator<NSSharingServicePicker> {
  initWithItems(items: NSArray<any> | any[]): InitializedType;
}
interface NSSharingServicePicker extends NSObject {
  showRelativeToRect_ofView_preferredEdge(rect: NSRect, view: NSView, preferredEdge: NSRectEdge): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const NSSharingServicePicker: {
  alloc(): NSSharingServicePickerAllocator;
}

interface INSSharingServiceDelegate {
  sharingService_willShareItems(sharingService: NSSharingService, items: NSArray<any> | any[]): void;
  sharingService_didFailToShareItems_error(sharingService: NSSharingService, items: NSArray<any> | any[], error: NSError): void;
  sharingService_didShareItems(sharingService: NSSharingService, items: NSArray<any> | any[]): void;
  sharingService_sourceFrameOnScreenForShareItem(sharingService: NSSharingService, item: any): NSRect;
  sharingService_transitionImageForShareItem_contentRect(sharingService: NSSharingService, item: any, contentRect: NSRect): NSImage;
  sharingService_sourceWindowForShareItems_sharingContentScope(sharingService: NSSharingService, items: NSArray<any> | any[], sharingContentScope: NSSharingContentScope): NSWindow;
  anchoringViewForSharingService_showRelativeToRect_preferredEdge(sharingService: NSSharingService, positioningRect: NSRect, preferredEdge: NSRectEdge): NSView;
}

interface INSCloudSharingServiceDelegate {
  sharingService_didCompleteForItems_error(sharingService: NSSharingService, items: NSArray<any> | any[], error: NSError | null): void;
  optionsForSharingService_shareProvider(cloudKitSharingService: NSSharingService, provider: NSItemProvider): NSCloudKitSharingServiceOptions;
  sharingService_didSaveShare(sharingService: NSSharingService, share: CKShare): void;
  sharingService_didStopSharing(sharingService: NSSharingService, share: CKShare): void;
}

interface INSSharingServicePickerDelegate {
  sharingServicePicker_sharingServicesForItems_proposedSharingServices(sharingServicePicker: NSSharingServicePicker, items: NSArray<any> | any[], proposedServices: NSArray<any> | any[]): NSArray<any>;
  sharingServicePicker_delegateForSharingService(sharingServicePicker: NSSharingServicePicker, sharingService: NSSharingService): any;
  sharingServicePicker_didChooseSharingService(sharingServicePicker: NSSharingServicePicker, service: NSSharingService | null): void;
}

declare type NSSharingServiceName = NSString

declare enum NSSharingContentScope {
  NSSharingContentScopeItem,
  NSSharingContentScopePartial,
  NSSharingContentScopeFull,
}

declare enum NSCloudKitSharingServiceOptions {
  NSCloudKitSharingServiceStandard = 0,
  NSCloudKitSharingServiceAllowPublic = 1 << 0,
  NSCloudKitSharingServiceAllowPrivate = 1 << 1,
  NSCloudKitSharingServiceAllowReadOnly = 1 << 4,
  NSCloudKitSharingServiceAllowReadWrite = 1 << 5,
}

interface NSSharingServicePickerTouchBarItemAllocator<InitializedType = NSSharingServicePickerTouchBarItem> extends NSTouchBarItemAllocator<NSSharingServicePickerTouchBarItem> {}
interface NSSharingServicePickerTouchBarItem extends NSTouchBarItem {

  delegate(): any;
  setDelegate(delegate: any): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  buttonTitle(): NSString;
  setButtonTitle(buttonTitle: NSString | string): void;
  buttonImage(): NSImage;
  setButtonImage(buttonImage: NSImage): void;
}
declare const NSSharingServicePickerTouchBarItem: {
  alloc(): NSSharingServicePickerTouchBarItemAllocator;
}

interface INSSharingServicePickerTouchBarItemDelegate {
  itemsForSharingServicePickerTouchBarItem(pickerTouchBarItem: NSSharingServicePickerTouchBarItem): NSArray<any>;
}

interface NSSimpleHorizontalTypesetterAllocator<InitializedType = NSSimpleHorizontalTypesetter> extends NSTypesetterAllocator<NSSimpleHorizontalTypesetter> {}
interface NSSimpleHorizontalTypesetter extends NSTypesetter {
  currentLayoutManager(): NSLayoutManager;
  currentContainer(): NSTextContainer;
  currentParagraphStyle(): NSParagraphStyle;
  currentTextStorage(): NSTextStorage;
  baseOfTypesetterGlyphInfo(): NSTypesetterGlyphInfo;
  sizeOfTypesetterGlyphInfo(): NSUInteger;
  capacityOfTypesetterGlyphInfo(): NSUInteger;
  firstGlyphIndexOfCurrentLineFragment(): NSUInteger;
  layoutGlyphsInLayoutManager_startingAtGlyphIndex_maxNumberOfLineFragments_nextGlyphIndex(layoutManager: NSLayoutManager, startGlyphIndex: NSUInteger, maxNumLines: NSUInteger, nextGlyph: NSUInteger): void;
  layoutGlyphsInHorizontalLineFragment_baseline(lineFragmentRect: NSRect, baseline: number): NSLayoutStatus;
  clearGlyphCache(): void;
  fillAttributesCache(): void;
  clearAttributesCache(): void;
  growGlyphCaches_fillGlyphInfo(desiredCapacity: NSUInteger, fillGlyphInfo: boolean): NSUInteger;
  updateCurGlyphOffset(): void;
  insertGlyph_atGlyphIndex_characterIndex(glyph: NSGlyph, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  layoutControlGlyphForLineFragment(lineFrag: NSRect): NSLayoutStatus;
  layoutTab(): void;
  breakLineAtIndex(location: NSUInteger): void;
  glyphIndexToBreakLineByHyphenatingWordAtIndex(charIndex: NSUInteger): NSUInteger;
  glyphIndexToBreakLineByWordWrappingAtIndex(charIndex: NSUInteger): NSUInteger;
  fullJustifyLineAtGlyphIndex(glyphIndexForLineBreak: NSUInteger): void;
  typesetterLaidOneGlyph(gl: NSTypesetterGlyphInfo): void;
  willSetLineFragmentRect_forGlyphRange_usedRect(rect: NSRect, range: NSRange, bRect: NSRect): void;
}
declare const NSSimpleHorizontalTypesetter: {
  alloc(): NSSimpleHorizontalTypesetterAllocator;  sharedInstance(): any;

}

declare enum NSLayoutStatus {
  NSLayoutNotDone = 0,
  NSLayoutDone,
  NSLayoutCantFit,
  NSLayoutOutOfGlyphs,
}

declare enum NSGlyphLayoutMode {
  NSGlyphLayoutAtAPoint = 0,
  NSGlyphLayoutAgainstAPoint,
  NSGlyphLayoutWithPrevious,
}

declare enum NSLayoutDirection {
  NSLayoutLeftToRight = 0,
  NSLayoutRightToLeft,
}

interface NSSliderAllocator<InitializedType = NSSlider> extends NSControlAllocator<NSSlider> {}
interface NSSlider extends NSControl, INSAccessibilitySlider {
  acceptsFirstMouse(event: NSEvent | null): boolean;
  tickMarkValueAtIndex(index: NSInteger): number;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;
  indexOfTickMarkAtPoint(point: NSPoint): NSInteger;
  closestTickMarkValueToValue(value: number): number;
  setTitleCell(cell: NSCell): void;
  titleCell(): any;
  setTitleColor(newColor: NSColor): void;
  titleColor(): NSColor;
  setTitleFont(fontObj: NSFont): void;
  titleFont(): NSFont;
  title(): NSString;
  setTitle(string: NSString | string): void;
  setKnobThickness(thickness: CGFloat): void;
  setImage(backgroundImage: NSImage): void;
  image(): NSImage;

  sliderType(): NSSliderType;
  setSliderType(sliderType: NSSliderType): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  altIncrementValue(): number;
  setAltIncrementValue(altIncrementValue: number): void;
  knobThickness(): CGFloat;
  vertical(): boolean;
  trackFillColor(): NSColor;
  setTrackFillColor(trackFillColor: NSColor): void;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  allowsTickMarkValuesOnly(): boolean;
  setAllowsTickMarkValuesOnly(allowsTickMarkValuesOnly: boolean): void;
}
declare const NSSlider: {
  alloc(): NSSliderAllocator;  sliderWithTarget_action(target: any | null, action: string | null): NSSlider;
  sliderWithValue_minValue_maxValue_target_action(value: number, minValue: number, maxValue: number, target: any | null, action: string | null): NSSlider;

}

interface NSSliderAccessoryAllocator<InitializedType = NSSliderAccessory> extends NSObjectAllocator<NSSliderAccessory> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSSliderAccessory extends NSObject, INSCoding, INSAccessibility, INSAccessibilityElement {

  behavior(): NSSliderAccessoryBehavior;
  setBehavior(behavior: NSSliderAccessoryBehavior): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}
declare const NSSliderAccessory: {
  alloc(): NSSliderAccessoryAllocator;  accessoryWithImage(image: NSImage): NSSliderAccessory;

}

interface NSSliderAccessoryBehaviorAllocator<InitializedType = NSSliderAccessoryBehavior> extends NSObjectAllocator<NSSliderAccessoryBehavior> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSSliderAccessoryBehavior extends NSObject, INSCoding, INSCopying {
  handleAction(sender: NSSliderAccessory): void;
}
declare const NSSliderAccessoryBehavior: {
  alloc(): NSSliderAccessoryBehaviorAllocator;  behaviorWithTarget_action(target: any | null, action: string): NSSliderAccessoryBehavior;
  behaviorWithHandler(handler: Block): NSSliderAccessoryBehavior;

  automaticBehavior(): NSSliderAccessoryBehavior;
  valueStepBehavior(): NSSliderAccessoryBehavior;
  valueResetBehavior(): NSSliderAccessoryBehavior;

}

interface NSSliderCellAllocator<InitializedType = NSSliderCell> extends NSActionCellAllocator<NSSliderCell> {}
interface NSSliderCell extends NSActionCell {
  knobRectFlipped(flipped: boolean): NSRect;
  barRectFlipped(flipped: boolean): NSRect;
  drawKnob(knobRect: NSRect): void;
  drawKnob(): void;
  drawBarInside_flipped(rect: NSRect, flipped: boolean): void;
  tickMarkValueAtIndex(index: NSInteger): number;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;
  indexOfTickMarkAtPoint(point: NSPoint): NSInteger;
  closestTickMarkValueToValue(value: number): number;
  drawTickMarks(): void;
  setTitleColor(newColor: NSColor): void;
  titleColor(): NSColor;
  setTitleFont(fontObj: NSFont): void;
  titleFont(): NSFont;
  title(): NSString;
  setTitle(string: NSString | string): void;
  setTitleCell(cell: NSCell): void;
  titleCell(): any;
  setKnobThickness(thickness: CGFloat): void;

  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  altIncrementValue(): number;
  setAltIncrementValue(altIncrementValue: number): void;
  sliderType(): NSSliderType;
  setSliderType(sliderType: NSSliderType): void;
  vertical(): boolean;
  trackRect(): NSRect;
  knobThickness(): CGFloat;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  allowsTickMarkValuesOnly(): boolean;
  setAllowsTickMarkValuesOnly(allowsTickMarkValuesOnly: boolean): void;
}
declare const NSSliderCell: {
  alloc(): NSSliderCellAllocator;
  prefersTrackingUntilMouseUp(): boolean;

}

declare enum NSTickMarkPosition {
  NSTickMarkPositionBelow = 0,
  NSTickMarkPositionAbove = 1,
  NSTickMarkPositionLeading,
  NSTickMarkPositionTrailing,
}

declare enum NSSliderType {
  NSSliderTypeLinear = 0,
  NSSliderTypeCircular = 1,
}

interface NSSliderTouchBarItemAllocator<InitializedType = NSSliderTouchBarItem> extends NSTouchBarItemAllocator<NSSliderTouchBarItem> {}
interface NSSliderTouchBarItem extends NSTouchBarItem {

  view(): NSView;
  slider(): NSSlider;
  setSlider(slider: NSSlider): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  minimumValueAccessory(): NSSliderAccessory;
  setMinimumValueAccessory(minimumValueAccessory: NSSliderAccessory): void;
  maximumValueAccessory(): NSSliderAccessory;
  setMaximumValueAccessory(maximumValueAccessory: NSSliderAccessory): void;
  valueAccessoryWidth(): NSSliderAccessoryWidth;
  setValueAccessoryWidth(valueAccessoryWidth: NSSliderAccessoryWidth): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
}
declare const NSSliderTouchBarItem: {
  alloc(): NSSliderTouchBarItemAllocator;
}

declare type NSSliderAccessoryWidth = CGFloat

interface NSSoundAllocator<InitializedType = NSSound> extends NSObjectAllocator<NSSound> {
  initWithContentsOfURL_byReference(url: NSURL, byRef: boolean): InitializedType;
  initWithContentsOfFile_byReference(path: NSString | string, byRef: boolean): InitializedType;
  initWithData(data: NSData): InitializedType;
  initWithPasteboard(pasteboard: NSPasteboard): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): InitializedType;
}
interface NSSound extends NSObject, INSCopying, INSCoding, INSPasteboardReading, INSPasteboardWriting {
  setName(string: NSSoundName | null): boolean;
  writeToPasteboard(pasteboard: NSPasteboard): void;
  play(): boolean;
  pause(): boolean;
  resume(): boolean;
  stop(): boolean;
  setChannelMapping(channelMapping: NSArray<any> | any[]): void;
  channelMapping(): NSArray<any>;

  name(): NSSoundName;
  playing(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  duration(): NSTimeInterval;
  volume(): number;
  setVolume(volume: number): void;
  currentTime(): NSTimeInterval;
  setCurrentTime(currentTime: NSTimeInterval): void;
  loops(): boolean;
  setLoops(loops: boolean): void;
  playbackDeviceIdentifier(): NSSoundPlaybackDeviceIdentifier;
  setPlaybackDeviceIdentifier(playbackDeviceIdentifier: NSSoundPlaybackDeviceIdentifier): void;
}
declare const NSSound: {
  alloc(): NSSoundAllocator;  soundNamed(name: NSSoundName): NSSound;
  canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  soundUnfilteredFileTypes(): NSArray<any>;
  soundUnfilteredPasteboardTypes(): NSArray<any>;

  soundUnfilteredTypes(): NSArray<any>;

}

interface INSSoundDelegate {
  sound_didFinishPlaying(sound: NSSound, flag: boolean): void;
}

declare type NSSoundName = NSString

declare type NSSoundPlaybackDeviceIdentifier = NSString

interface NSSpeechRecognizerAllocator<InitializedType = NSSpeechRecognizer> extends NSObjectAllocator<NSSpeechRecognizer> {
  init(): InitializedType;
}
interface NSSpeechRecognizer extends NSObject {
  startListening(): void;
  stopListening(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  commands(): NSArray<any>;
  setCommands(commands: NSArray<any> | any[]): void;
  displayedCommandsTitle(): NSString;
  setDisplayedCommandsTitle(displayedCommandsTitle: NSString | string): void;
  listensInForegroundOnly(): boolean;
  setListensInForegroundOnly(listensInForegroundOnly: boolean): void;
  blocksOtherRecognizers(): boolean;
  setBlocksOtherRecognizers(blocksOtherRecognizers: boolean): void;
}
declare const NSSpeechRecognizer: {
  alloc(): NSSpeechRecognizerAllocator;
}

interface INSSpeechRecognizerDelegate {
  speechRecognizer_didRecognizeCommand(sender: NSSpeechRecognizer, command: NSString | string): void;
}

interface NSSpeechSynthesizerAllocator<InitializedType = NSSpeechSynthesizer> extends NSObjectAllocator<NSSpeechSynthesizer> {
  initWithVoice(voice: NSSpeechSynthesizerVoiceName | null): InitializedType;
}
interface NSSpeechSynthesizer extends NSObject {
  startSpeakingString(string: NSString | string): boolean;
  startSpeakingString_toURL(string: NSString | string, url: NSURL): boolean;
  stopSpeaking(): void;
  stopSpeakingAtBoundary(boundary: NSSpeechBoundary): void;
  pauseSpeakingAtBoundary(boundary: NSSpeechBoundary): void;
  continueSpeaking(): void;
  voice(): NSSpeechSynthesizerVoiceName;
  setVoice(voice: NSSpeechSynthesizerVoiceName | null): boolean;
  addSpeechDictionary(speechDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  phonemesFromText(text: NSString | string): NSString;
  objectForProperty_error(property: NSSpeechPropertyKey, outError: NSError): any;
  setObject_forProperty_error(object: any | null, property: NSSpeechPropertyKey, outError: NSError): boolean;

  speaking(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  rate(): number;
  setRate(rate: number): void;
  volume(): number;
  setVolume(volume: number): void;
  usesFeedbackWindow(): boolean;
  setUsesFeedbackWindow(usesFeedbackWindow: boolean): void;
}
declare const NSSpeechSynthesizer: {
  alloc(): NSSpeechSynthesizerAllocator;  attributesForVoice(voice: NSSpeechSynthesizerVoiceName): NSDictionary<any, any>;

  anyApplicationSpeaking(): boolean;
  defaultVoice(): NSSpeechSynthesizerVoiceName;
  availableVoices(): NSArray<any>;

}

interface INSSpeechSynthesizerDelegate {
  speechSynthesizer_didFinishSpeaking(sender: NSSpeechSynthesizer, finishedSpeaking: boolean): void;
  speechSynthesizer_willSpeakWord_ofString(sender: NSSpeechSynthesizer, characterRange: NSRange, string: NSString | string): void;
  speechSynthesizer_willSpeakPhoneme(sender: NSSpeechSynthesizer, phonemeOpcode: number): void;
  speechSynthesizer_didEncounterErrorAtIndex_ofString_message(sender: NSSpeechSynthesizer, characterIndex: NSUInteger, string: NSString | string, message: NSString | string): void;
  speechSynthesizer_didEncounterSyncMessage(sender: NSSpeechSynthesizer, message: NSString | string): void;
}

declare type NSSpeechSynthesizerVoiceName = NSString

declare type NSVoiceAttributeKey = NSString

declare type NSSpeechDictionaryKey = NSString

declare type NSVoiceGenderName = NSString

declare type NSSpeechPropertyKey = NSString

declare type NSSpeechMode = NSString

declare type NSSpeechStatusKey = NSString

declare type NSSpeechErrorKey = NSString

declare type NSSpeechSynthesizerInfoKey = NSString

declare type NSSpeechPhonemeInfoKey = NSString

declare type NSSpeechCommandDelimiterKey = NSString

declare enum NSSpeechBoundary {
  NSSpeechImmediateBoundary = 0,
  NSSpeechWordBoundary,
  NSSpeechSentenceBoundary,
}

interface NSSpellCheckerAllocator<InitializedType = NSSpellChecker> extends NSObjectAllocator<NSSpellChecker> {}
interface NSSpellChecker extends NSObject {
  checkSpellingOfString_startingAt_language_wrap_inSpellDocumentWithTag_wordCount(stringToCheck: NSString | string, startingOffset: NSInteger, language: NSString | string | null, wrapFlag: boolean, tag: NSInteger, wordCount: NSInteger | null): NSRange;
  checkSpellingOfString_startingAt(stringToCheck: NSString | string, startingOffset: NSInteger): NSRange;
  countWordsInString_language(stringToCount: NSString | string, language: NSString | string | null): NSInteger;
  checkGrammarOfString_startingAt_language_wrap_inSpellDocumentWithTag_details(stringToCheck: NSString | string, startingOffset: NSInteger, language: NSString | string | null, wrapFlag: boolean, tag: NSInteger, details: NSArray<any> | any[]): NSRange;
  checkString_range_types_options_inSpellDocumentWithTag_orthography_wordCount(stringToCheck: NSString | string, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, tag: NSInteger, orthography: NSOrthography, wordCount: NSInteger | null): NSArray<any>;
  requestCheckingOfString_range_types_options_inSpellDocumentWithTag_completionHandler(stringToCheck: NSString | string, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, tag: NSInteger, completionHandler: Block): NSInteger;
  requestCandidatesForSelectedRange_inString_types_options_inSpellDocumentWithTag_completionHandler(selectedRange: NSRange, stringToCheck: NSString | string, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, tag: NSInteger, completionHandler: Block): NSInteger;
  menuForResult_string_options_atLocation_inView(result: NSTextCheckingResult, checkedString: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null, location: NSPoint, view: NSView): NSMenu;
  userQuotesArrayForLanguage(language: NSString | string): NSArray<any>;
  updateSpellingPanelWithMisspelledWord(word: NSString | string): void;
  updateSpellingPanelWithGrammarString_detail(string: NSString | string, detail: NSDictionary<any, any> | {[key: string]: any}): void;
  updatePanels(): void;
  ignoreWord_inSpellDocumentWithTag(wordToIgnore: NSString | string, tag: NSInteger): void;
  ignoredWordsInSpellDocumentWithTag(tag: NSInteger): NSArray<any>;
  setIgnoredWords_inSpellDocumentWithTag(words: NSArray<any> | any[], tag: NSInteger): void;
  guessesForWordRange_inString_language_inSpellDocumentWithTag(range: NSRange, string: NSString | string, language: NSString | string | null, tag: NSInteger): NSArray<any>;
  correctionForWordRange_inString_language_inSpellDocumentWithTag(range: NSRange, string: NSString | string, language: NSString | string, tag: NSInteger): NSString;
  completionsForPartialWordRange_inString_language_inSpellDocumentWithTag(range: NSRange, string: NSString | string, language: NSString | string | null, tag: NSInteger): NSArray<any>;
  languageForWordRange_inString_orthography(range: NSRange, string: NSString | string, orthography: NSOrthography | null): NSString;
  closeSpellDocumentWithTag(tag: NSInteger): void;
  recordResponse_toCorrection_forWord_language_inSpellDocumentWithTag(response: NSCorrectionResponse, correction: NSString | string, word: NSString | string, language: NSString | string | null, tag: NSInteger): void;
  showCorrectionIndicatorOfType_primaryString_alternativeStrings_forStringInRect_view_completionHandler(type: NSCorrectionIndicatorType, primaryString: NSString | string, alternativeStrings: NSArray<any> | any[], rectOfTypedString: NSRect, view: NSView, completionBlock: Block): void;
  dismissCorrectionIndicatorForView(view: NSView): void;
  preventsAutocorrectionBeforeString_language(string: NSString | string, language: NSString | string | null): boolean;
  deletesAutospaceBetweenString_andString_language(precedingString: NSString | string, followingString: NSString | string, language: NSString | string | null): boolean;
  setWordFieldStringValue(string: NSString | string): void;
  learnWord(word: NSString | string): void;
  hasLearnedWord(word: NSString | string): boolean;
  unlearnWord(word: NSString | string): void;
  language(): NSString;
  setLanguage(language: NSString | string): boolean;
  guessesForWord(word: NSString | string): NSArray<any>;
  forgetWord(word: NSString | string): void;

  userReplacementsDictionary(): NSDictionary<any, any>;
  spellingPanel(): NSPanel;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  substitutionsPanel(): NSPanel;
  substitutionsPanelAccessoryViewController(): NSViewController;
  setSubstitutionsPanelAccessoryViewController(substitutionsPanelAccessoryViewController: NSViewController): void;
  availableLanguages(): NSArray<any>;
  userPreferredLanguages(): NSArray<any>;
  automaticallyIdentifiesLanguages(): boolean;
  setAutomaticallyIdentifiesLanguages(automaticallyIdentifiesLanguages: boolean): void;
}
declare const NSSpellChecker: {
  alloc(): NSSpellCheckerAllocator;  uniqueSpellDocumentTag(): NSInteger;

  sharedSpellChecker(): NSSpellChecker;
  sharedSpellCheckerExists(): boolean;
  automaticTextReplacementEnabled(): boolean;
  automaticSpellingCorrectionEnabled(): boolean;
  automaticQuoteSubstitutionEnabled(): boolean;
  automaticDashSubstitutionEnabled(): boolean;
  automaticCapitalizationEnabled(): boolean;
  automaticPeriodSubstitutionEnabled(): boolean;
  automaticTextCompletionEnabled(): boolean;

}

declare type NSTextCheckingOptionKey = NSString

declare enum NSCorrectionResponse {
  NSCorrectionResponseNone,
  NSCorrectionResponseAccepted,
  NSCorrectionResponseRejected,
  NSCorrectionResponseIgnored,
  NSCorrectionResponseEdited,
  NSCorrectionResponseReverted,
}

declare enum NSCorrectionIndicatorType {
  NSCorrectionIndicatorTypeDefault = 0,
  NSCorrectionIndicatorTypeReversion,
  NSCorrectionIndicatorTypeGuesses,
}

interface INSChangeSpelling {
  changeSpelling(sender: any | null): void;
}

interface INSIgnoreMisspelledWords {
  ignoreSpelling(sender: any | null): void;
}

interface NSSplitViewAllocator<InitializedType = NSSplitView> extends NSViewAllocator<NSSplitView> {}
interface NSSplitView extends NSView {
  drawDividerInRect(rect: NSRect): void;
  adjustSubviews(): void;
  isSubviewCollapsed(subview: NSView): boolean;
  minPossiblePositionOfDividerAtIndex(dividerIndex: NSInteger): CGFloat;
  maxPossiblePositionOfDividerAtIndex(dividerIndex: NSInteger): CGFloat;
  setPosition_ofDividerAtIndex(position: CGFloat, dividerIndex: NSInteger): void;
  holdingPriorityForSubviewAtIndex(subviewIndex: NSInteger): NSLayoutPriority;
  setHoldingPriority_forSubviewAtIndex(priority: NSLayoutPriority, subviewIndex: NSInteger): void;
  addArrangedSubview(view: NSView): void;
  insertArrangedSubview_atIndex(view: NSView, index: NSInteger): void;
  removeArrangedSubview(view: NSView): void;
  setIsPaneSplitter(flag: boolean): void;
  isPaneSplitter(): boolean;

  vertical(): boolean;
  setVertical(vertical: boolean): void;
  dividerStyle(): NSSplitViewDividerStyle;
  setDividerStyle(dividerStyle: NSSplitViewDividerStyle): void;
  autosaveName(): NSSplitViewAutosaveName;
  setAutosaveName(autosaveName: NSSplitViewAutosaveName): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  dividerColor(): NSColor;
  dividerThickness(): CGFloat;
  arrangesAllSubviews(): boolean;
  setArrangesAllSubviews(arrangesAllSubviews: boolean): void;
  arrangedSubviews(): NSArray<any>;
}
declare const NSSplitView: {
  alloc(): NSSplitViewAllocator;
}

interface INSSplitViewDelegate {
  splitView_canCollapseSubview(splitView: NSSplitView, subview: NSView): boolean;
  splitView_shouldCollapseSubview_forDoubleClickOnDividerAtIndex(splitView: NSSplitView, subview: NSView, dividerIndex: NSInteger): boolean;
  splitView_constrainMinCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMinimumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainMaxCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMaximumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainSplitPosition_ofSubviewAt(splitView: NSSplitView, proposedPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_resizeSubviewsWithOldSize(splitView: NSSplitView, oldSize: NSSize): void;
  splitView_shouldAdjustSizeOfSubview(splitView: NSSplitView, view: NSView): boolean;
  splitView_shouldHideDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): boolean;
  splitView_effectiveRect_forDrawnRect_ofDividerAtIndex(splitView: NSSplitView, proposedEffectiveRect: NSRect, drawnRect: NSRect, dividerIndex: NSInteger): NSRect;
  splitView_additionalEffectiveRectOfDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): NSRect;
  splitViewWillResizeSubviews(notification: NSNotification): void;
  splitViewDidResizeSubviews(notification: NSNotification): void;
}

declare type NSSplitViewAutosaveName = NSString

declare enum NSSplitViewDividerStyle {
  NSSplitViewDividerStyleThick = 1,
  NSSplitViewDividerStyleThin = 2,
  NSSplitViewDividerStylePaneSplitter = 3,
}

interface NSSplitViewControllerAllocator<InitializedType = NSSplitViewController> extends NSViewControllerAllocator<NSSplitViewController> {}
interface NSSplitViewController extends NSViewController, INSSplitViewDelegate, INSUserInterfaceValidations {
  addSplitViewItem(splitViewItem: NSSplitViewItem): void;
  insertSplitViewItem_atIndex(splitViewItem: NSSplitViewItem, index: NSInteger): void;
  removeSplitViewItem(splitViewItem: NSSplitViewItem): void;
  splitViewItemForViewController(viewController: NSViewController): NSSplitViewItem;
  validateUserInterfaceItem(item: any): boolean;
  toggleSidebar(sender: any | null): IBAction;

  splitView(): NSSplitView;
  setSplitView(splitView: NSSplitView): void;
  splitViewItems(): NSArray<any>;
  setSplitViewItems(splitViewItems: NSArray<any> | any[]): void;
  minimumThicknessForInlineSidebars(): CGFloat;
  setMinimumThicknessForInlineSidebars(minimumThicknessForInlineSidebars: CGFloat): void;
}
declare const NSSplitViewController: {
  alloc(): NSSplitViewControllerAllocator;
}

interface NSSplitViewItemAllocator<InitializedType = NSSplitViewItem> extends NSObjectAllocator<NSSplitViewItem> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSSplitViewItem extends NSObject, INSAnimatablePropertyContainer, INSCoding {

  behavior(): NSSplitViewItemBehavior;
  viewController(): NSViewController;
  setViewController(viewController: NSViewController): void;
  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
  canCollapse(): boolean;
  setCanCollapse(canCollapse: boolean): void;
  collapseBehavior(): NSSplitViewItemCollapseBehavior;
  setCollapseBehavior(collapseBehavior: NSSplitViewItemCollapseBehavior): void;
  minimumThickness(): CGFloat;
  setMinimumThickness(minimumThickness: CGFloat): void;
  maximumThickness(): CGFloat;
  setMaximumThickness(maximumThickness: CGFloat): void;
  preferredThicknessFraction(): CGFloat;
  setPreferredThicknessFraction(preferredThicknessFraction: CGFloat): void;
  holdingPriority(): NSLayoutPriority;
  setHoldingPriority(holdingPriority: NSLayoutPriority): void;
  automaticMaximumThickness(): CGFloat;
  setAutomaticMaximumThickness(automaticMaximumThickness: CGFloat): void;
  springLoaded(): boolean;
  setSpringLoaded(springLoaded: boolean): void;
}
declare const NSSplitViewItem: {
  alloc(): NSSplitViewItemAllocator;  splitViewItemWithViewController(viewController: NSViewController): NSSplitViewItem;
  sidebarWithViewController(viewController: NSViewController): NSSplitViewItem;
  contentListWithViewController(viewController: NSViewController): NSSplitViewItem;

}

declare enum NSSplitViewItemBehavior {
  NSSplitViewItemBehaviorDefault,
  NSSplitViewItemBehaviorSidebar,
  NSSplitViewItemBehaviorContentList,
}

declare enum NSSplitViewItemCollapseBehavior {
  NSSplitViewItemCollapseBehaviorDefault,
  NSSplitViewItemCollapseBehaviorPreferResizingSplitViewWithFixedSiblings,
  NSSplitViewItemCollapseBehaviorPreferResizingSiblingsWithFixedSplitView,
  NSSplitViewItemCollapseBehaviorUseConstraints,
}

interface NSStackViewAllocator<InitializedType = NSStackView> extends NSViewAllocator<NSStackView> {}
interface NSStackView extends NSView {
  setCustomSpacing_afterView(spacing: CGFloat, view: NSView): void;
  customSpacingAfterView(view: NSView): CGFloat;
  addArrangedSubview(view: NSView): void;
  insertArrangedSubview_atIndex(view: NSView, index: NSInteger): void;
  removeArrangedSubview(view: NSView): void;
  setVisibilityPriority_forView(priority: NSStackViewVisibilityPriority, view: NSView): void;
  visibilityPriorityForView(view: NSView): NSStackViewVisibilityPriority;
  clippingResistancePriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setClippingResistancePriority_forOrientation(clippingResistancePriority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  huggingPriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setHuggingPriority_forOrientation(huggingPriority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  addView_inGravity(view: NSView, gravity: NSStackViewGravity): void;
  insertView_atIndex_inGravity(view: NSView, index: NSUInteger, gravity: NSStackViewGravity): void;
  removeView(view: NSView): void;
  viewsInGravity(gravity: NSStackViewGravity): NSArray<any>;
  setViews_inGravity(views: NSArray<any> | any[], gravity: NSStackViewGravity): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  orientation(): NSUserInterfaceLayoutOrientation;
  setOrientation(orientation: NSUserInterfaceLayoutOrientation): void;
  alignment(): NSLayoutAttribute;
  setAlignment(alignment: NSLayoutAttribute): void;
  edgeInsets(): NSEdgeInsets;
  setEdgeInsets(edgeInsets: NSEdgeInsets): void;
  distribution(): NSStackViewDistribution;
  setDistribution(distribution: NSStackViewDistribution): void;
  spacing(): CGFloat;
  setSpacing(spacing: CGFloat): void;
  detachesHiddenViews(): boolean;
  setDetachesHiddenViews(detachesHiddenViews: boolean): void;
  arrangedSubviews(): NSArray<any>;
  detachedViews(): NSArray<any>;
  views(): NSArray<any>;
  hasEqualSpacing(): boolean;
  setHasEqualSpacing(hasEqualSpacing: boolean): void;
}
declare const NSStackView: {
  alloc(): NSStackViewAllocator;  stackViewWithViews(views: NSArray<any> | any[]): NSStackView;

}

interface INSStackViewDelegate {
  stackView_willDetachViews(stackView: NSStackView, views: NSArray<any> | any[]): void;
  stackView_didReattachViews(stackView: NSStackView, views: NSArray<any> | any[]): void;
}

declare type NSStackViewVisibilityPriority = number

declare enum NSStackViewGravity {
  NSStackViewGravityTop = 1,
  NSStackViewGravityLeading = 1,
  NSStackViewGravityCenter = 2,
  NSStackViewGravityBottom = 3,
  NSStackViewGravityTrailing = 3,
}

declare enum NSStackViewDistribution {
  NSStackViewDistributionGravityAreas = -1,
  NSStackViewDistributionFill = 0,
  NSStackViewDistributionFillEqually,
  NSStackViewDistributionFillProportionally,
  NSStackViewDistributionEqualSpacing,
  NSStackViewDistributionEqualCentering,
}

interface NSStatusBarAllocator<InitializedType = NSStatusBar> extends NSObjectAllocator<NSStatusBar> {}
interface NSStatusBar extends NSObject {
  statusItemWithLength(length: CGFloat): NSStatusItem;
  removeStatusItem(item: NSStatusItem): void;

  vertical(): boolean;
  thickness(): CGFloat;
}
declare const NSStatusBar: {
  alloc(): NSStatusBarAllocator;
  systemStatusBar(): NSStatusBar;

}

interface NSStatusBarButtonAllocator<InitializedType = NSStatusBarButton> extends NSButtonAllocator<NSStatusBarButton> {}
interface NSStatusBarButton extends NSButton {

  appearsDisabled(): boolean;
  setAppearsDisabled(appearsDisabled: boolean): void;
}
declare const NSStatusBarButton: {
  alloc(): NSStatusBarButtonAllocator;
}

interface NSStatusItemAllocator<InitializedType = NSStatusItem> extends NSObjectAllocator<NSStatusItem> {}
interface NSStatusItem extends NSObject {
  sendActionOn(mask: NSInteger): NSInteger;
  drawStatusBarBackgroundInRect_withHighlight(rect: NSRect, highlight: boolean): void;
  popUpStatusItemMenu(menu: NSMenu): void;

  statusBar(): NSStatusBar;
  length(): CGFloat;
  setLength(length: CGFloat): void;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  button(): NSStatusBarButton;
  behavior(): NSStatusItemBehavior;
  setBehavior(behavior: NSStatusItemBehavior): void;
  visible(): boolean;
  setVisible(visible: boolean): void;
  autosaveName(): NSStatusItemAutosaveName;
  setAutosaveName(autosaveName: NSStatusItemAutosaveName): void;
  action(): string;
  setAction(action: string): void;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  target(): any;
  setTarget(target: any): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  highlightMode(): boolean;
  setHighlightMode(highlightMode: boolean): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  view(): NSView;
  setView(view: NSView): void;
}
declare const NSStatusItem: {
  alloc(): NSStatusItemAllocator;
}

declare type NSStatusItemAutosaveName = NSString

declare enum NSStatusItemBehavior {
  NSStatusItemBehaviorRemovalAllowed,
  NSStatusItemBehaviorTerminationOnRemoval,
}

interface NSStepperAllocator<InitializedType = NSStepper> extends NSControlAllocator<NSStepper> {}
interface NSStepper extends NSControl, INSAccessibilityStepper {

  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  increment(): number;
  setIncrement(increment: number): void;
  valueWraps(): boolean;
  setValueWraps(valueWraps: boolean): void;
  autorepeat(): boolean;
  setAutorepeat(autorepeat: boolean): void;
}
declare const NSStepper: {
  alloc(): NSStepperAllocator;
}

interface NSStepperCellAllocator<InitializedType = NSStepperCell> extends NSActionCellAllocator<NSStepperCell> {}
interface NSStepperCell extends NSActionCell {

  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  increment(): number;
  setIncrement(increment: number): void;
  valueWraps(): boolean;
  setValueWraps(valueWraps: boolean): void;
  autorepeat(): boolean;
  setAutorepeat(autorepeat: boolean): void;
}
declare const NSStepperCell: {
  alloc(): NSStepperCellAllocator;
}

interface NSStoryboardAllocator<InitializedType = NSStoryboard> extends NSObjectAllocator<NSStoryboard> {}
interface NSStoryboard extends NSObject {
  instantiateInitialController(): any;
  instantiateControllerWithIdentifier(identifier: NSStoryboardSceneIdentifier): any;
}
declare const NSStoryboard: {
  alloc(): NSStoryboardAllocator;  storyboardWithName_bundle(name: NSStoryboardName, storyboardBundleOrNil: NSBundle | null): NSStoryboard;

  mainStoryboard(): NSStoryboard;

}

declare type NSStoryboardName = NSString

declare type NSStoryboardSceneIdentifier = NSString

interface NSStoryboardSegueAllocator<InitializedType = NSStoryboardSegue> extends NSObjectAllocator<NSStoryboardSegue> {
  initWithIdentifier_source_destination(identifier: NSStoryboardSegueIdentifier, sourceController: any, destinationController: any): InitializedType;
}
interface NSStoryboardSegue extends NSObject {
  perform(): void;

  identifier(): NSStoryboardSegueIdentifier;
  sourceController(): any;
  destinationController(): any;
}
declare const NSStoryboardSegue: {
  alloc(): NSStoryboardSegueAllocator;  segueWithIdentifier_source_destination_performHandler(identifier: NSStoryboardSegueIdentifier, sourceController: any, destinationController: any, performHandler: Block): NSStoryboardSegue;

}

interface INSSeguePerforming {
  prepareForSegue_sender(segue: NSStoryboardSegue, sender: any | null): void;
  performSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): void;
  shouldPerformSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): boolean;
}

declare type NSStoryboardSegueIdentifier = NSString

interface NSStringDrawingContextAllocator<InitializedType = NSStringDrawingContext> extends NSObjectAllocator<NSStringDrawingContext> {}
interface NSStringDrawingContext extends NSObject {

  minimumScaleFactor(): CGFloat;
  setMinimumScaleFactor(minimumScaleFactor: CGFloat): void;
  actualScaleFactor(): CGFloat;
  totalBounds(): NSRect;
}
declare const NSStringDrawingContext: {
  alloc(): NSStringDrawingContextAllocator;
}

declare enum NSStringDrawingOptions {
  NSStringDrawingUsesLineFragmentOrigin = 1 << 0,
  NSStringDrawingUsesFontLeading = 1 << 1,
  NSStringDrawingUsesDeviceMetrics = 1 << 3,
  NSStringDrawingTruncatesLastVisibleLine = 1 << 5,
  NSStringDrawingDisableScreenFontSubstitution,
  NSStringDrawingOneShot,
}

interface NSTabViewAllocator<InitializedType = NSTabView> extends NSViewAllocator<NSTabView> {}
interface NSTabView extends NSView {
  selectTabViewItem(tabViewItem: NSTabViewItem | null): void;
  selectTabViewItemAtIndex(index: NSInteger): void;
  selectTabViewItemWithIdentifier(identifier: any): void;
  takeSelectedTabViewItemFromSender(sender: any | null): void;
  selectFirstTabViewItem(sender: any | null): void;
  selectLastTabViewItem(sender: any | null): void;
  selectNextTabViewItem(sender: any | null): void;
  selectPreviousTabViewItem(sender: any | null): void;
  addTabViewItem(tabViewItem: NSTabViewItem): void;
  insertTabViewItem_atIndex(tabViewItem: NSTabViewItem, index: NSInteger): void;
  removeTabViewItem(tabViewItem: NSTabViewItem): void;
  tabViewItemAtPoint(point: NSPoint): NSTabViewItem;
  indexOfTabViewItem(tabViewItem: NSTabViewItem): NSInteger;
  tabViewItemAtIndex(index: NSInteger): NSTabViewItem;
  indexOfTabViewItemWithIdentifier(identifier: any): NSInteger;

  selectedTabViewItem(): NSTabViewItem;
  font(): NSFont;
  setFont(font: NSFont): void;
  tabViewType(): NSTabViewType;
  setTabViewType(tabViewType: NSTabViewType): void;
  tabPosition(): NSTabPosition;
  setTabPosition(tabPosition: NSTabPosition): void;
  tabViewBorderType(): NSTabViewBorderType;
  setTabViewBorderType(tabViewBorderType: NSTabViewBorderType): void;
  tabViewItems(): NSArray<any>;
  allowsTruncatedLabels(): boolean;
  setAllowsTruncatedLabels(allowsTruncatedLabels: boolean): void;
  minimumSize(): NSSize;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  contentRect(): NSRect;
  numberOfTabViewItems(): NSInteger;
}
declare const NSTabView: {
  alloc(): NSTabViewAllocator;
}

interface INSTabViewDelegate {
  tabView_shouldSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): boolean;
  tabView_willSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabView_didSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabViewDidChangeNumberOfTabViewItems(tabView: NSTabView): void;
}

declare enum NSTabViewType {
  NSTopTabsBezelBorder = 0,
  NSLeftTabsBezelBorder = 1,
  NSBottomTabsBezelBorder = 2,
  NSRightTabsBezelBorder = 3,
  NSNoTabsBezelBorder = 4,
  NSNoTabsLineBorder = 5,
  NSNoTabsNoBorder = 6,
}

declare enum NSTabPosition {
  NSTabPositionNone = 0,
  NSTabPositionTop = 1,
  NSTabPositionLeft = 2,
  NSTabPositionBottom = 3,
  NSTabPositionRight = 4,
}

declare enum NSTabViewBorderType {
  NSTabViewBorderTypeNone = 0,
  NSTabViewBorderTypeLine = 1,
  NSTabViewBorderTypeBezel = 2,
}

interface NSTabViewControllerAllocator<InitializedType = NSTabViewController> extends NSViewControllerAllocator<NSTabViewController> {}
interface NSTabViewController extends NSViewController, INSTabViewDelegate, INSToolbarDelegate {
  addTabViewItem(tabViewItem: NSTabViewItem): void;
  insertTabViewItem_atIndex(tabViewItem: NSTabViewItem, index: NSInteger): void;
  removeTabViewItem(tabViewItem: NSTabViewItem): void;
  tabViewItemForViewController(viewController: NSViewController): NSTabViewItem;

  tabStyle(): NSTabViewControllerTabStyle;
  setTabStyle(tabStyle: NSTabViewControllerTabStyle): void;
  tabView(): NSTabView;
  setTabView(tabView: NSTabView): void;
  transitionOptions(): NSViewControllerTransitionOptions;
  setTransitionOptions(transitionOptions: NSViewControllerTransitionOptions): void;
  canPropagateSelectedChildViewControllerTitle(): boolean;
  setCanPropagateSelectedChildViewControllerTitle(canPropagateSelectedChildViewControllerTitle: boolean): void;
  tabViewItems(): NSArray<any>;
  setTabViewItems(tabViewItems: NSArray<any> | any[]): void;
  selectedTabViewItemIndex(): NSInteger;
  setSelectedTabViewItemIndex(selectedTabViewItemIndex: NSInteger): void;
}
declare const NSTabViewController: {
  alloc(): NSTabViewControllerAllocator;
}

declare enum NSTabViewControllerTabStyle {
  NSTabViewControllerTabStyleSegmentedControlOnTop = 0,
  NSTabViewControllerTabStyleSegmentedControlOnBottom,
  NSTabViewControllerTabStyleToolbar,
  NSTabViewControllerTabStyleUnspecified = -1,
}

interface NSTabViewItemAllocator<InitializedType = NSTabViewItem> extends NSObjectAllocator<NSTabViewItem> {
  initWithIdentifier(identifier: any | null): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTabViewItem extends NSObject, INSCoding {
  drawLabel_inRect(shouldTruncateLabel: boolean, labelRect: NSRect): void;
  sizeOfLabel(computeMin: boolean): NSSize;

  identifier(): any;
  setIdentifier(identifier: any): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  view(): NSView;
  setView(view: NSView): void;
  viewController(): NSViewController;
  setViewController(viewController: NSViewController): void;
  tabState(): NSTabState;
  tabView(): NSTabView;
  initialFirstResponder(): NSView;
  setInitialFirstResponder(initialFirstResponder: NSView): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
}
declare const NSTabViewItem: {
  alloc(): NSTabViewItemAllocator;  tabViewItemWithViewController(viewController: NSViewController): NSTabViewItem;

}

declare enum NSTabState {
  NSSelectedTab = 0,
  NSBackgroundTab = 1,
  NSPressedTab = 2,
}

interface NSTableCellViewAllocator<InitializedType = NSTableCellView> extends NSViewAllocator<NSTableCellView> {}
interface NSTableCellView extends NSView {

  objectValue(): any;
  setObjectValue(objectValue: any): void;
  textField(): NSTextField;
  setTextField(textField: NSTextField): void;
  imageView(): NSImageView;
  setImageView(imageView: NSImageView): void;
  backgroundStyle(): NSBackgroundStyle;
  setBackgroundStyle(backgroundStyle: NSBackgroundStyle): void;
  rowSizeStyle(): NSTableViewRowSizeStyle;
  setRowSizeStyle(rowSizeStyle: NSTableViewRowSizeStyle): void;
  draggingImageComponents(): NSArray<any>;
}
declare const NSTableCellView: {
  alloc(): NSTableCellViewAllocator;
}

interface NSTableColumnAllocator<InitializedType = NSTableColumn> extends NSObjectAllocator<NSTableColumn> {
  initWithIdentifier(identifier: NSUserInterfaceItemIdentifier): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTableColumn extends NSObject, INSCoding, INSUserInterfaceItemIdentification {
  sizeToFit(): void;
  setResizable(flag: boolean): void;
  isResizable(): boolean;
  dataCellForRow(row: NSInteger): any;

  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  width(): CGFloat;
  setWidth(width: CGFloat): void;
  minWidth(): CGFloat;
  setMinWidth(minWidth: CGFloat): void;
  maxWidth(): CGFloat;
  setMaxWidth(maxWidth: CGFloat): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  headerCell(): NSTableHeaderCell;
  setHeaderCell(headerCell: NSTableHeaderCell): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  sortDescriptorPrototype(): NSSortDescriptor;
  setSortDescriptorPrototype(sortDescriptorPrototype: NSSortDescriptor): void;
  resizingMask(): NSTableColumnResizingOptions;
  setResizingMask(resizingMask: NSTableColumnResizingOptions): void;
  headerToolTip(): NSString;
  setHeaderToolTip(headerToolTip: NSString | string): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  dataCell(): any;
  setDataCell(dataCell: any): void;
}
declare const NSTableColumn: {
  alloc(): NSTableColumnAllocator;
}

declare enum NSTableColumnResizingOptions {
  NSTableColumnNoResizing = 0,
  NSTableColumnAutoresizingMask,
  NSTableColumnUserResizingMask,
}

interface NSTableHeaderCellAllocator<InitializedType = NSTableHeaderCell> extends NSTextFieldCellAllocator<NSTableHeaderCell> {}
interface NSTableHeaderCell extends NSTextFieldCell {
  drawSortIndicatorWithFrame_inView_ascending_priority(cellFrame: NSRect, controlView: NSView, ascending: boolean, priority: NSInteger): void;
  sortIndicatorRectForBounds(rect: NSRect): NSRect;
}
declare const NSTableHeaderCell: {
  alloc(): NSTableHeaderCellAllocator;
}

interface NSTableHeaderViewAllocator<InitializedType = NSTableHeaderView> extends NSViewAllocator<NSTableHeaderView> {}
interface NSTableHeaderView extends NSView {
  headerRectOfColumn(column: NSInteger): NSRect;
  columnAtPoint(point: NSPoint): NSInteger;

  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  draggedColumn(): NSInteger;
  draggedDistance(): CGFloat;
  resizedColumn(): NSInteger;
}
declare const NSTableHeaderView: {
  alloc(): NSTableHeaderViewAllocator;
}

interface NSTableRowViewAllocator<InitializedType = NSTableRowView> extends NSViewAllocator<NSTableRowView> {}
interface NSTableRowView extends NSView, INSAccessibilityRow {
  drawBackgroundInRect(dirtyRect: NSRect): void;
  drawSelectionInRect(dirtyRect: NSRect): void;
  drawSeparatorInRect(dirtyRect: NSRect): void;
  drawDraggingDestinationFeedbackInRect(dirtyRect: NSRect): void;
  viewAtColumn(column: NSInteger): any;

  selectionHighlightStyle(): NSTableViewSelectionHighlightStyle;
  setSelectionHighlightStyle(selectionHighlightStyle: NSTableViewSelectionHighlightStyle): void;
  emphasized(): boolean;
  setEmphasized(emphasized: boolean): void;
  groupRowStyle(): boolean;
  setGroupRowStyle(groupRowStyle: boolean): void;
  selected(): boolean;
  setSelected(selected: boolean): void;
  previousRowSelected(): boolean;
  setPreviousRowSelected(previousRowSelected: boolean): void;
  nextRowSelected(): boolean;
  setNextRowSelected(nextRowSelected: boolean): void;
  floating(): boolean;
  setFloating(floating: boolean): void;
  targetForDropOperation(): boolean;
  setTargetForDropOperation(targetForDropOperation: boolean): void;
  draggingDestinationFeedbackStyle(): NSTableViewDraggingDestinationFeedbackStyle;
  setDraggingDestinationFeedbackStyle(draggingDestinationFeedbackStyle: NSTableViewDraggingDestinationFeedbackStyle): void;
  indentationForDropOperation(): CGFloat;
  setIndentationForDropOperation(indentationForDropOperation: CGFloat): void;
  interiorBackgroundStyle(): NSBackgroundStyle;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  numberOfColumns(): NSInteger;
}
declare const NSTableRowView: {
  alloc(): NSTableRowViewAllocator;
}

interface NSTableViewAllocator<InitializedType = NSTableView> extends NSControlAllocator<NSTableView> {}
interface NSTableView extends NSControl, INSUserInterfaceValidations, INSTextViewDelegate, INSDraggingSource, INSAccessibilityTable {
  noteHeightOfRowsWithIndexesChanged(indexSet: NSIndexSet): void;
  addTableColumn(tableColumn: NSTableColumn): void;
  removeTableColumn(tableColumn: NSTableColumn): void;
  moveColumn_toColumn(oldIndex: NSInteger, newIndex: NSInteger): void;
  columnWithIdentifier(identifier: NSUserInterfaceItemIdentifier): NSInteger;
  tableColumnWithIdentifier(identifier: NSUserInterfaceItemIdentifier): NSTableColumn;
  tile(): void;
  sizeToFit(): void;
  sizeLastColumnToFit(): void;
  scrollRowToVisible(row: NSInteger): void;
  scrollColumnToVisible(column: NSInteger): void;
  reloadData(): void;
  noteNumberOfRowsChanged(): void;
  reloadDataForRowIndexes_columnIndexes(rowIndexes: NSIndexSet, columnIndexes: NSIndexSet): void;
  setIndicatorImage_inTableColumn(image: NSImage | null, tableColumn: NSTableColumn): void;
  indicatorImageInTableColumn(tableColumn: NSTableColumn): NSImage;
  canDragRowsWithIndexes_atPoint(rowIndexes: NSIndexSet, mouseDownPoint: NSPoint): boolean;
  dragImageForRowsWithIndexes_tableColumns_event_offset(dragRows: NSIndexSet, tableColumns: NSArray<any> | any[], dragEvent: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  setDraggingSourceOperationMask_forLocal(mask: NSDragOperation, isLocal: boolean): void;
  setDropRow_dropOperation(row: NSInteger, dropOperation: NSTableViewDropOperation): void;
  selectAll(sender: any | null): void;
  deselectAll(sender: any | null): void;
  selectColumnIndexes_byExtendingSelection(indexes: NSIndexSet, extend: boolean): void;
  selectRowIndexes_byExtendingSelection(indexes: NSIndexSet, extend: boolean): void;
  deselectColumn(column: NSInteger): void;
  deselectRow(row: NSInteger): void;
  isColumnSelected(column: NSInteger): boolean;
  isRowSelected(row: NSInteger): boolean;
  rectOfColumn(column: NSInteger): NSRect;
  rectOfRow(row: NSInteger): NSRect;
  columnIndexesInRect(rect: NSRect): NSIndexSet;
  rowsInRect(rect: NSRect): NSRange;
  columnAtPoint(point: NSPoint): NSInteger;
  rowAtPoint(point: NSPoint): NSInteger;
  frameOfCellAtColumn_row(column: NSInteger, row: NSInteger): NSRect;
  editColumn_row_withEvent_select(column: NSInteger, row: NSInteger, event: NSEvent | null, select: boolean): void;
  drawRow_clipRect(row: NSInteger, clipRect: NSRect): void;
  highlightSelectionInClipRect(clipRect: NSRect): void;
  drawGridInClipRect(clipRect: NSRect): void;
  drawBackgroundInClipRect(clipRect: NSRect): void;
  viewAtColumn_row_makeIfNecessary(column: NSInteger, row: NSInteger, makeIfNecessary: boolean): NSView;
  rowViewAtRow_makeIfNecessary(row: NSInteger, makeIfNecessary: boolean): NSTableRowView;
  rowForView(view: NSView): NSInteger;
  columnForView(view: NSView): NSInteger;
  makeViewWithIdentifier_owner(identifier: NSUserInterfaceItemIdentifier, owner: any | null): NSView;
  enumerateAvailableRowViewsUsingBlock(handler: Block): void;
  beginUpdates(): void;
  endUpdates(): void;
  insertRowsAtIndexes_withAnimation(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  removeRowsAtIndexes_withAnimation(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  moveRowAtIndex_toIndex(oldIndex: NSInteger, newIndex: NSInteger): void;
  hideRowsAtIndexes_withAnimation(indexes: NSIndexSet, rowAnimation: NSTableViewAnimationOptions): void;
  unhideRowsAtIndexes_withAnimation(indexes: NSIndexSet, rowAnimation: NSTableViewAnimationOptions): void;
  registerNib_forIdentifier(nib: NSNib | null, identifier: NSUserInterfaceItemIdentifier): void;
  didAddRowView_forRow(rowView: NSTableRowView, row: NSInteger): void;
  didRemoveRowView_forRow(rowView: NSTableRowView, row: NSInteger): void;
  setDrawsGrid(flag: boolean): void;
  drawsGrid(): boolean;
  selectColumn_byExtendingSelection(column: NSInteger, extend: boolean): void;
  selectRow_byExtendingSelection(row: NSInteger, extend: boolean): void;
  selectedColumnEnumerator(): NSEnumerator<any>;
  selectedRowEnumerator(): NSEnumerator<any>;
  dragImageForRows_event_dragImageOffset(dragRows: NSArray<any> | any[], dragEvent: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  setAutoresizesAllColumnsToFit(flag: boolean): void;
  autoresizesAllColumnsToFit(): boolean;
  columnsInRect(rect: NSRect): NSRange;
  preparedCellAtColumn_row(column: NSInteger, row: NSInteger): NSCell;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  shouldFocusCell_atColumn_row(cell: NSCell, column: NSInteger, row: NSInteger): boolean;
  focusedColumn(): NSInteger;
  setFocusedColumn(focusedColumn: NSInteger): void;
  performClickOnCellAtColumn_row(column: NSInteger, row: NSInteger): void;
  selectRow_extendSelection(rowIndex: NSInteger, flag: boolean): void;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  headerView(): NSTableHeaderView;
  setHeaderView(headerView: NSTableHeaderView): void;
  cornerView(): NSView;
  setCornerView(cornerView: NSView): void;
  allowsColumnReordering(): boolean;
  setAllowsColumnReordering(allowsColumnReordering: boolean): void;
  allowsColumnResizing(): boolean;
  setAllowsColumnResizing(allowsColumnResizing: boolean): void;
  columnAutoresizingStyle(): NSTableViewColumnAutoresizingStyle;
  setColumnAutoresizingStyle(columnAutoresizingStyle: NSTableViewColumnAutoresizingStyle): void;
  gridStyleMask(): NSTableViewGridLineStyle;
  setGridStyleMask(gridStyleMask: NSTableViewGridLineStyle): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  usesAlternatingRowBackgroundColors(): boolean;
  setUsesAlternatingRowBackgroundColors(usesAlternatingRowBackgroundColors: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  gridColor(): NSColor;
  setGridColor(gridColor: NSColor): void;
  rowSizeStyle(): NSTableViewRowSizeStyle;
  setRowSizeStyle(rowSizeStyle: NSTableViewRowSizeStyle): void;
  effectiveRowSizeStyle(): NSTableViewRowSizeStyle;
  rowHeight(): CGFloat;
  setRowHeight(rowHeight: CGFloat): void;
  tableColumns(): NSArray<any>;
  numberOfColumns(): NSInteger;
  numberOfRows(): NSInteger;
  editedColumn(): NSInteger;
  editedRow(): NSInteger;
  clickedColumn(): NSInteger;
  clickedRow(): NSInteger;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  highlightedTableColumn(): NSTableColumn;
  setHighlightedTableColumn(highlightedTableColumn: NSTableColumn): void;
  verticalMotionCanBeginDrag(): boolean;
  setVerticalMotionCanBeginDrag(verticalMotionCanBeginDrag: boolean): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  allowsColumnSelection(): boolean;
  setAllowsColumnSelection(allowsColumnSelection: boolean): void;
  selectedColumnIndexes(): NSIndexSet;
  selectedRowIndexes(): NSIndexSet;
  selectedColumn(): NSInteger;
  selectedRow(): NSInteger;
  numberOfSelectedColumns(): NSInteger;
  numberOfSelectedRows(): NSInteger;
  allowsTypeSelect(): boolean;
  setAllowsTypeSelect(allowsTypeSelect: boolean): void;
  selectionHighlightStyle(): NSTableViewSelectionHighlightStyle;
  setSelectionHighlightStyle(selectionHighlightStyle: NSTableViewSelectionHighlightStyle): void;
  draggingDestinationFeedbackStyle(): NSTableViewDraggingDestinationFeedbackStyle;
  setDraggingDestinationFeedbackStyle(draggingDestinationFeedbackStyle: NSTableViewDraggingDestinationFeedbackStyle): void;
  autosaveName(): NSTableViewAutosaveName;
  setAutosaveName(autosaveName: NSTableViewAutosaveName): void;
  autosaveTableColumns(): boolean;
  setAutosaveTableColumns(autosaveTableColumns: boolean): void;
  floatsGroupRows(): boolean;
  setFloatsGroupRows(floatsGroupRows: boolean): void;
  rowActionsVisible(): boolean;
  setRowActionsVisible(rowActionsVisible: boolean): void;
  hiddenRowIndexes(): NSIndexSet;
  registeredNibsByIdentifier(): NSDictionary<any, any>;
  usesStaticContents(): boolean;
  setUsesStaticContents(usesStaticContents: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  usesAutomaticRowHeights(): boolean;
  setUsesAutomaticRowHeights(usesAutomaticRowHeights: boolean): void;
}
declare const NSTableView: {
  alloc(): NSTableViewAllocator;
}

interface INSTableViewDelegate {
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
}

interface INSTableViewDataSource {
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
}

declare type NSTableViewAutosaveName = NSString

declare enum NSTableViewDropOperation {
  NSTableViewDropOn,
  NSTableViewDropAbove,
}

declare enum NSTableViewColumnAutoresizingStyle {
  NSTableViewNoColumnAutoresizing = 0,
  NSTableViewUniformColumnAutoresizingStyle,
  NSTableViewSequentialColumnAutoresizingStyle,
  NSTableViewReverseSequentialColumnAutoresizingStyle,
  NSTableViewLastColumnOnlyAutoresizingStyle,
  NSTableViewFirstColumnOnlyAutoresizingStyle,
}

declare enum NSTableViewGridLineStyle {
  NSTableViewGridNone = 0,
  NSTableViewSolidVerticalGridLineMask = 1 << 0,
  NSTableViewSolidHorizontalGridLineMask = 1 << 1,
  NSTableViewDashedHorizontalGridLineMask = 1 << 3,
}

declare enum NSTableViewRowSizeStyle {
  NSTableViewRowSizeStyleDefault = -1,
  NSTableViewRowSizeStyleCustom = 0,
  NSTableViewRowSizeStyleSmall = 1,
  NSTableViewRowSizeStyleMedium = 2,
  NSTableViewRowSizeStyleLarge = 3,
}

declare enum NSTableViewSelectionHighlightStyle {
  NSTableViewSelectionHighlightStyleNone = -1,
  NSTableViewSelectionHighlightStyleRegular = 0,
  NSTableViewSelectionHighlightStyleSourceList = 1,
}

declare enum NSTableViewDraggingDestinationFeedbackStyle {
  NSTableViewDraggingDestinationFeedbackStyleNone = -1,
  NSTableViewDraggingDestinationFeedbackStyleRegular = 0,
  NSTableViewDraggingDestinationFeedbackStyleSourceList = 1,
  NSTableViewDraggingDestinationFeedbackStyleGap = 2,
}

declare enum NSTableRowActionEdge {
  NSTableRowActionEdgeLeading,
  NSTableRowActionEdgeTrailing,
}

declare enum NSTableViewAnimationOptions {
  NSTableViewAnimationEffectNone = 0x0,
  NSTableViewAnimationEffectFade = 0x1,
  NSTableViewAnimationEffectGap = 0x2,
  NSTableViewAnimationSlideUp = 0x10,
  NSTableViewAnimationSlideDown = 0x20,
  NSTableViewAnimationSlideLeft = 0x30,
  NSTableViewAnimationSlideRight = 0x40,
}

interface NSTableViewRowActionAllocator<InitializedType = NSTableViewRowAction> extends NSObjectAllocator<NSTableViewRowAction> {}
interface NSTableViewRowAction extends NSObject, INSCopying {

  style(): NSTableViewRowActionStyle;
  title(): NSString;
  setTitle(title: NSString | string): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  image(): NSImage;
  setImage(image: NSImage): void;
}
declare const NSTableViewRowAction: {
  alloc(): NSTableViewRowActionAllocator;  rowActionWithStyle_title_handler(style: NSTableViewRowActionStyle, title: NSString | string, handler: Block): NSTableViewRowAction;

}

declare enum NSTableViewRowActionStyle {
  NSTableViewRowActionStyleRegular,
  NSTableViewRowActionStyleDestructive,
}

interface NSTextAllocator<InitializedType = NSText> extends NSViewAllocator<NSText> {}
interface NSText extends NSView, INSChangeSpelling, INSIgnoreMisspelledWords {
  replaceCharactersInRange_withString(range: NSRange, string: NSString | string): void;
  replaceCharactersInRange_withRTF(range: NSRange, rtfData: NSData): void;
  replaceCharactersInRange_withRTFD(range: NSRange, rtfdData: NSData): void;
  RTFFromRange(range: NSRange): NSData;
  RTFDFromRange(range: NSRange): NSData;
  writeRTFDToFile_atomically(path: NSString | string, flag: boolean): boolean;
  readRTFDFromFile(path: NSString | string): boolean;
  scrollRangeToVisible(range: NSRange): void;
  setTextColor_range(color: NSColor | null, range: NSRange): void;
  setFont_range(font: NSFont, range: NSRange): void;
  sizeToFit(): void;
  copy(sender: any | null): void;
  copyFont(sender: any | null): void;
  copyRuler(sender: any | null): void;
  cut(sender: any | null): void;
  delete(sender: any | null): void;
  paste(sender: any | null): void;
  pasteFont(sender: any | null): void;
  pasteRuler(sender: any | null): void;
  selectAll(sender: any | null): void;
  changeFont(sender: any | null): void;
  alignLeft(sender: any | null): void;
  alignRight(sender: any | null): void;
  alignCenter(sender: any | null): void;
  subscript(sender: any | null): void;
  superscript(sender: any | null): void;
  underline(sender: any | null): void;
  unscript(sender: any | null): void;
  showGuessPanel(sender: any | null): void;
  checkSpelling(sender: any | null): void;
  toggleRuler(sender: any | null): void;

  string(): NSString;
  setString(string: NSString | string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  richText(): boolean;
  setRichText(richText: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
  fieldEditor(): boolean;
  setFieldEditor(fieldEditor: boolean): void;
  usesFontPanel(): boolean;
  setUsesFontPanel(usesFontPanel: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  rulerVisible(): boolean;
  selectedRange(): NSRange;
  setSelectedRange(selectedRange: NSRange): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  maxSize(): NSSize;
  setMaxSize(maxSize: NSSize): void;
  minSize(): NSSize;
  setMinSize(minSize: NSSize): void;
  horizontallyResizable(): boolean;
  setHorizontallyResizable(horizontallyResizable: boolean): void;
  verticallyResizable(): boolean;
  setVerticallyResizable(verticallyResizable: boolean): void;
}
declare const NSText: {
  alloc(): NSTextAllocator;
}

interface INSTextDelegate {
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
}

declare enum NSTextAlignment {
  NSTextAlignmentLeft = 0,
  NSTextAlignmentRight = 1,
  NSTextAlignmentCenter = 2,
  NSTextAlignmentJustified = 3,
  NSTextAlignmentNatural = 4,
}

declare enum NSWritingDirection {
  NSWritingDirectionNatural = -1,
  NSWritingDirectionLeftToRight = 0,
  NSWritingDirectionRightToLeft = 1,
}

declare enum NSTextMovement {
  NSTextMovementReturn = 0x10,
  NSTextMovementTab = 0x11,
  NSTextMovementBacktab = 0x12,
  NSTextMovementLeft = 0x13,
  NSTextMovementRight = 0x14,
  NSTextMovementUp = 0x15,
  NSTextMovementDown = 0x16,
  NSTextMovementCancel = 0x17,
  NSTextMovementOther = 0,
}

interface NSTextAlternativesAllocator<InitializedType = NSTextAlternatives> extends NSObjectAllocator<NSTextAlternatives> {
  initWithPrimaryString_alternativeStrings(primaryString: NSString | string, alternativeStrings: NSArray<any> | any[]): InitializedType;
}
interface NSTextAlternatives extends NSObject {
  noteSelectedAlternativeString(alternativeString: NSString | string): void;

  primaryString(): NSString;
  alternativeStrings(): NSArray<any>;
}
declare const NSTextAlternatives: {
  alloc(): NSTextAlternativesAllocator;
}

interface NSTextAttachmentAllocator<InitializedType = NSTextAttachment> extends NSObjectAllocator<NSTextAttachment> {
  initWithData_ofType(contentData: NSData | null, uti: NSString | string | null): InitializedType;
  initWithFileWrapper(fileWrapper: NSFileWrapper | null): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTextAttachment extends NSObject, INSTextAttachmentContainer, INSCoding {

  contents(): NSData;
  setContents(contents: NSData): void;
  fileType(): NSString;
  setFileType(fileType: NSString | string): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  bounds(): NSRect;
  setBounds(bounds: NSRect): void;
  fileWrapper(): NSFileWrapper;
  setFileWrapper(fileWrapper: NSFileWrapper): void;
  attachmentCell(): any;
  setAttachmentCell(attachmentCell: any): void;
}
declare const NSTextAttachment: {
  alloc(): NSTextAttachmentAllocator;
}

interface NSTextAttachmentCellAllocator<InitializedType = NSTextAttachmentCell> extends NSCellAllocator<NSTextAttachmentCell> {}
interface NSTextAttachmentCell extends NSCell, INSTextAttachmentCell {
}
declare const NSTextAttachmentCell: {
  alloc(): NSTextAttachmentCellAllocator;
}

interface INSTextAttachmentCell {
  drawWithFrame_inView(cellFrame: NSRect, controlView: NSView | null): void;
  wantsToTrackMouse(): boolean;
  highlight_withFrame_inView(flag: boolean, cellFrame: NSRect, controlView: NSView | null): void;
  trackMouse_inRect_ofView_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, flag: boolean): boolean;
  cellSize(): NSSize;
  cellBaselineOffset(): NSPoint;
  drawWithFrame_inView_characterIndex(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): void;
  drawWithFrame_inView_characterIndex_layoutManager(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, layoutManager: NSLayoutManager): void;
  wantsToTrackMouseForEvent_inRect_ofView_atCharacterIndex(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): boolean;
  trackMouse_inRect_ofView_atCharacterIndex_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, flag: boolean): boolean;
  cellFrameForTextContainer_proposedLineFragment_glyphPosition_characterIndex(textContainer: NSTextContainer, lineFrag: NSRect, position: NSPoint, charIndex: NSUInteger): NSRect;

  attachment(): NSTextAttachment;
  setAttachment(attachment: NSTextAttachment): void;
}

interface NSTextContainerAllocator<InitializedType = NSTextContainer> extends NSObjectAllocator<NSTextContainer> {
  initWithSize(size: NSSize): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithContainerSize(aContainerSize: NSSize): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTextContainer extends NSObject, INSCoding, INSTextLayoutOrientationProvider {
  replaceLayoutManager(newLayoutManager: NSLayoutManager): void;
  lineFragmentRectForProposedRect_atIndex_writingDirection_remainingRect(proposedRect: NSRect, characterIndex: NSUInteger, baseWritingDirection: NSWritingDirection, remainingRect: NSRect | null): NSRect;
  lineFragmentRectForProposedRect_sweepDirection_movementDirection_remainingRect(proposedRect: NSRect, sweepDirection: NSLineSweepDirection, movementDirection: NSLineMovementDirection, remainingRect: NSRectPointer | null): NSRect;
  containsPoint(point: NSPoint): boolean;

  layoutManager(): NSLayoutManager;
  setLayoutManager(layoutManager: NSLayoutManager): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  exclusionPaths(): NSArray<any>;
  setExclusionPaths(exclusionPaths: NSArray<any> | any[]): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  lineFragmentPadding(): CGFloat;
  setLineFragmentPadding(lineFragmentPadding: CGFloat): void;
  maximumNumberOfLines(): NSUInteger;
  setMaximumNumberOfLines(maximumNumberOfLines: NSUInteger): void;
  simpleRectangularTextContainer(): boolean;
  widthTracksTextView(): boolean;
  setWidthTracksTextView(widthTracksTextView: boolean): void;
  heightTracksTextView(): boolean;
  setHeightTracksTextView(heightTracksTextView: boolean): void;
  textView(): NSTextView;
  setTextView(textView: NSTextView): void;
  containerSize(): NSSize;
  setContainerSize(containerSize: NSSize): void;
}
declare const NSTextContainer: {
  alloc(): NSTextContainerAllocator;
}

declare enum NSLineSweepDirection {
  NSLineSweepLeft = 0,
  NSLineSweepRight = 1,
  NSLineSweepDown = 2,
  NSLineSweepUp = 3,
}

declare enum NSLineMovementDirection {
  NSLineDoesntMove = 0,
  NSLineMovesLeft = 1,
  NSLineMovesRight = 2,
  NSLineMovesDown = 3,
  NSLineMovesUp = 4,
}

interface NSTextFieldAllocator<InitializedType = NSTextField> extends NSControlAllocator<NSTextField> {}
interface NSTextField extends NSControl, INSUserInterfaceValidations, INSAccessibilityNavigableStaticText {
  selectText(sender: any | null): void;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;

  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  acceptsFirstResponder(): boolean;
  bezelStyle(): NSTextFieldBezelStyle;
  setBezelStyle(bezelStyle: NSTextFieldBezelStyle): void;
  preferredMaxLayoutWidth(): CGFloat;
  setPreferredMaxLayoutWidth(preferredMaxLayoutWidth: CGFloat): void;
  maximumNumberOfLines(): NSInteger;
  setMaximumNumberOfLines(maximumNumberOfLines: NSInteger): void;
  allowsDefaultTighteningForTruncation(): boolean;
  setAllowsDefaultTighteningForTruncation(allowsDefaultTighteningForTruncation: boolean): void;
  automaticTextCompletionEnabled(): boolean;
  setAutomaticTextCompletionEnabled(automaticTextCompletionEnabled: boolean): void;
  allowsCharacterPickerTouchBarItem(): boolean;
  setAllowsCharacterPickerTouchBarItem(allowsCharacterPickerTouchBarItem: boolean): void;
  allowsEditingTextAttributes(): boolean;
  setAllowsEditingTextAttributes(allowsEditingTextAttributes: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
}
declare const NSTextField: {
  alloc(): NSTextFieldAllocator;  labelWithString(stringValue: NSString | string): NSTextField;
  wrappingLabelWithString(stringValue: NSString | string): NSTextField;
  labelWithAttributedString(attributedStringValue: NSAttributedString): NSTextField;
  textFieldWithString(stringValue: NSString | string): NSTextField;

}

interface INSTextFieldDelegate {
  textField_textView_candidatesForSelectedRange(textField: NSTextField, textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textField_textView_candidates_forSelectedRange(textField: NSTextField, textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textField_textView_shouldSelectCandidateAtIndex(textField: NSTextField, textView: NSTextView, index: NSUInteger): boolean;
}

interface NSTextFieldCellAllocator<InitializedType = NSTextFieldCell> extends NSActionCellAllocator<NSTextFieldCell> {}
interface NSTextFieldCell extends NSActionCell {
  setUpFieldEditorAttributes(textObj: NSText): NSText;
  setWantsNotificationForMarkedText(flag: boolean): void;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  bezelStyle(): NSTextFieldBezelStyle;
  setBezelStyle(bezelStyle: NSTextFieldBezelStyle): void;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  allowedInputSourceLocales(): NSArray<any>;
  setAllowedInputSourceLocales(allowedInputSourceLocales: NSArray<any> | any[]): void;
}
declare const NSTextFieldCell: {
  alloc(): NSTextFieldCellAllocator;
}

declare enum NSTextFieldBezelStyle {
  NSTextFieldSquareBezel = 0,
  NSTextFieldRoundedBezel = 1,
}

interface NSTextFinderAllocator<InitializedType = NSTextFinder> extends NSObjectAllocator<NSTextFinder> {
  init(): InitializedType;
  initWithCoder(decoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTextFinder extends NSObject, INSCoding {
  performAction(op: NSTextFinderAction): void;
  validateAction(op: NSTextFinderAction): boolean;
  cancelFindIndicator(): void;
  noteClientStringWillChange(): void;

  client(): any;
  setClient(client: any): void;
  findBarContainer(): any;
  setFindBarContainer(findBarContainer: any): void;
  findIndicatorNeedsUpdate(): boolean;
  setFindIndicatorNeedsUpdate(findIndicatorNeedsUpdate: boolean): void;
  incrementalSearchingEnabled(): boolean;
  setIncrementalSearchingEnabled(incrementalSearchingEnabled: boolean): void;
  incrementalSearchingShouldDimContentView(): boolean;
  setIncrementalSearchingShouldDimContentView(incrementalSearchingShouldDimContentView: boolean): void;
  incrementalMatchRanges(): NSArray<any>;
}
declare const NSTextFinder: {
  alloc(): NSTextFinderAllocator;  drawIncrementalMatchHighlightInRect(rect: NSRect): void;

}

interface INSTextFinderClient {
  stringAtIndex_effectiveRange_endsWithSearchBoundary(characterIndex: NSUInteger, outRange: NSRangePointer, outFlag: boolean): NSString;
  stringLength(): NSUInteger;
  scrollRangeToVisible(range: NSRange): void;
  shouldReplaceCharactersInRanges_withStrings(ranges: NSArray<any> | any[], strings: NSArray<any> | any[]): boolean;
  replaceCharactersInRange_withString(range: NSRange, string: NSString | string): void;
  didReplaceCharacters(): void;
  contentViewAtIndex_effectiveCharacterRange(index: NSUInteger, outRange: NSRangePointer): NSView;
  rectsForCharacterRange(range: NSRange): NSArray<any>;
  drawCharactersInRange_forContentView(range: NSRange, view: NSView): void;

  selectable(): boolean;
  allowsMultipleSelection(): boolean;
  editable(): boolean;
  string(): NSString;
  firstSelectedRange(): NSRange;
  selectedRanges(): NSArray<any>;
  setSelectedRanges(selectedRanges: NSArray<any> | any[]): void;
  visibleCharacterRanges(): NSArray<any>;
}

interface INSTextFinderBarContainer {
  findBarViewDidChangeHeight(): void;
  contentView(): NSView;

  findBarView(): NSView;
  setFindBarView(findBarView: NSView): void;
  findBarVisible(): boolean;
  setFindBarVisible(findBarVisible: boolean): void;
}

declare type NSPasteboardTypeTextFinderOptionKey = NSString

declare enum NSTextFinderAction {
  NSTextFinderActionShowFindInterface = 1,
  NSTextFinderActionNextMatch = 2,
  NSTextFinderActionPreviousMatch = 3,
  NSTextFinderActionReplaceAll = 4,
  NSTextFinderActionReplace = 5,
  NSTextFinderActionReplaceAndFind = 6,
  NSTextFinderActionSetSearchString = 7,
  NSTextFinderActionReplaceAllInSelection = 8,
  NSTextFinderActionSelectAll = 9,
  NSTextFinderActionSelectAllInSelection = 10,
  NSTextFinderActionHideFindInterface = 11,
  NSTextFinderActionShowReplaceInterface = 12,
  NSTextFinderActionHideReplaceInterface = 13,
}

declare enum NSTextFinderMatchingType {
  NSTextFinderMatchingTypeContains = 0,
  NSTextFinderMatchingTypeStartsWith = 1,
  NSTextFinderMatchingTypeFullWord = 2,
  NSTextFinderMatchingTypeEndsWith = 3,
}

interface INSTextInputClient {
  insertText_replacementRange(string: any, replacementRange: NSRange): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange_replacementRange(string: any, selectedRange: NSRange, replacementRange: NSRange): void;
  unmarkText(): void;
  selectedRange(): NSRange;
  markedRange(): NSRange;
  hasMarkedText(): boolean;
  attributedSubstringForProposedRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSAttributedString;
  validAttributesForMarkedText(): NSArray<any>;
  firstRectForCharacterRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  attributedString(): NSAttributedString;
  fractionOfDistanceThroughGlyphForPoint(point: NSPoint): CGFloat;
  baselineDeltaForCharacterAtIndex(anIndex: NSUInteger): CGFloat;
  windowLevel(): NSInteger;
  drawsVerticallyForCharacterAtIndex(charIndex: NSUInteger): boolean;
}

interface NSTextInputContextAllocator<InitializedType = NSTextInputContext> extends NSObjectAllocator<NSTextInputContext> {
  initWithClient(client: any): InitializedType;
}
interface NSTextInputContext extends NSObject {
  activate(): void;
  deactivate(): void;
  handleEvent(event: NSEvent): boolean;
  discardMarkedText(): void;
  invalidateCharacterCoordinates(): void;

  client(): any;
  acceptsGlyphInfo(): boolean;
  setAcceptsGlyphInfo(acceptsGlyphInfo: boolean): void;
  allowedInputSourceLocales(): NSArray<any>;
  setAllowedInputSourceLocales(allowedInputSourceLocales: NSArray<any> | any[]): void;
  keyboardInputSources(): NSArray<any>;
  selectedKeyboardInputSource(): NSTextInputSourceIdentifier;
  setSelectedKeyboardInputSource(selectedKeyboardInputSource: NSTextInputSourceIdentifier): void;
}
declare const NSTextInputContext: {
  alloc(): NSTextInputContextAllocator;  localizedNameForInputSource(inputSourceIdentifier: NSTextInputSourceIdentifier): NSString;

  currentInputContext(): NSTextInputContext;

}

declare type NSTextInputSourceIdentifier = NSString

interface NSTextListAllocator<InitializedType = NSTextList> extends NSObjectAllocator<NSTextList> {
  initWithMarkerFormat_options(format: NSTextListMarkerFormat, mask: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTextList extends NSObject, INSCoding, INSCopying {
  markerForItemNumber(itemNum: NSInteger): NSString;

  markerFormat(): NSTextListMarkerFormat;
  listOptions(): NSTextListOptions;
  startingItemNumber(): NSInteger;
  setStartingItemNumber(startingItemNumber: NSInteger): void;
}
declare const NSTextList: {
  alloc(): NSTextListAllocator;
}

declare type NSTextListMarkerFormat = NSString

declare enum NSTextListOptions {
  NSTextListPrependEnclosingMarker,
}

interface NSTextStorageAllocator<InitializedType = NSTextStorage> extends NSMutableAttributedStringAllocator<NSTextStorage> {}
interface NSTextStorage extends NSMutableAttributedString {
  addLayoutManager(aLayoutManager: NSLayoutManager): void;
  removeLayoutManager(aLayoutManager: NSLayoutManager): void;
  edited_range_changeInLength(editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  processEditing(): void;
  invalidateAttributesInRange(range: NSRange): void;
  ensureAttributesAreFixedInRange(range: NSRange): void;
  copyTextStorage(): any;
  boundsForTextBehaviour_original(behaviour: BCTextBehaviourType, rect: NSRect): NSRect;
  glyphBounds(): NSRect;
  attributeValuesByRangeForKey(key: NSString | string): NSDictionary<any, any>;
  attributeValuesByRangeForKey_range(key: NSString | string, rangeToExamine: NSRange): NSDictionary<any, any>;
  setAttributeValuesByRange_forKey(valuesByRange: NSDictionary<any, any> | {[key: string]: any}, key: NSString | string): void;

  layoutManagers(): NSArray<any>;
  editedMask(): NSTextStorageEditActions;
  editedRange(): NSRange;
  changeInLength(): NSInteger;
  delegate(): any;
  setDelegate(delegate: any): void;
  fixesAttributesLazily(): boolean;
  attributeRuns(): NSArray<any>;
  setAttributeRuns(attributeRuns: NSArray<any> | any[]): void;
  paragraphs(): NSArray<any>;
  setParagraphs(paragraphs: NSArray<any> | any[]): void;
  words(): NSArray<any>;
  setWords(words: NSArray<any> | any[]): void;
  characters(): NSArray<any>;
  setCharacters(characters: NSArray<any> | any[]): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  foregroundColor(): NSColor;
  setForegroundColor(foregroundColor: NSColor): void;
}
declare const NSTextStorage: {
  alloc(): NSTextStorageAllocator;
}

interface INSTextStorageDelegate {
  textStorage_willProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  textStorage_didProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
}

declare type NSTextStorageEditedOptions = NSUInteger

declare enum NSTextStorageEditActions {
  NSTextStorageEditedAttributes,
  NSTextStorageEditedCharacters,
}

interface NSTextBlockAllocator<InitializedType = NSTextBlock> extends NSObjectAllocator<NSTextBlock> {
  init(): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTextBlock extends NSObject, INSCoding, INSCopying {
  setValue_type_forDimension(val: CGFloat, type: NSTextBlockValueType, dimension: NSTextBlockDimension): void;
  valueForDimension(dimension: NSTextBlockDimension): CGFloat;
  valueTypeForDimension(dimension: NSTextBlockDimension): NSTextBlockValueType;
  setContentWidth_type(val: CGFloat, type: NSTextBlockValueType): void;
  setWidth_type_forLayer_edge(val: CGFloat, type: NSTextBlockValueType, layer: NSTextBlockLayer, edge: NSRectEdge): void;
  setWidth_type_forLayer(val: CGFloat, type: NSTextBlockValueType, layer: NSTextBlockLayer): void;
  widthForLayer_edge(layer: NSTextBlockLayer, edge: NSRectEdge): CGFloat;
  widthValueTypeForLayer_edge(layer: NSTextBlockLayer, edge: NSRectEdge): NSTextBlockValueType;
  setBorderColor_forEdge(color: NSColor | null, edge: NSRectEdge): void;
  setBorderColor(color: NSColor | null): void;
  borderColorForEdge(edge: NSRectEdge): NSColor;
  rectForLayoutAtPoint_inRect_textContainer_characterRange(startingPoint: NSPoint, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  boundsRectForContentRect_inRect_textContainer_characterRange(contentRect: NSRect, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  drawBackgroundWithFrame_inView_characterRange_layoutManager(frameRect: NSRect, controlView: NSView, charRange: NSRange, layoutManager: NSLayoutManager): void;

  contentWidth(): CGFloat;
  contentWidthValueType(): NSTextBlockValueType;
  verticalAlignment(): NSTextBlockVerticalAlignment;
  setVerticalAlignment(verticalAlignment: NSTextBlockVerticalAlignment): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}
declare const NSTextBlock: {
  alloc(): NSTextBlockAllocator;
}

interface NSTextTableBlockAllocator<InitializedType = NSTextTableBlock> extends NSTextBlockAllocator<NSTextTableBlock> {
  initWithTable_startingRow_rowSpan_startingColumn_columnSpan(table: NSTextTable, row: NSInteger, rowSpan: NSInteger, col: NSInteger, colSpan: NSInteger): InitializedType;
}
interface NSTextTableBlock extends NSTextBlock {

  table(): NSTextTable;
  startingRow(): NSInteger;
  rowSpan(): NSInteger;
  startingColumn(): NSInteger;
  columnSpan(): NSInteger;
}
declare const NSTextTableBlock: {
  alloc(): NSTextTableBlockAllocator;
}

interface NSTextTableAllocator<InitializedType = NSTextTable> extends NSTextBlockAllocator<NSTextTable> {}
interface NSTextTable extends NSTextBlock {
  rectForBlock_layoutAtPoint_inRect_textContainer_characterRange(block: NSTextTableBlock, startingPoint: NSPoint, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  boundsRectForBlock_contentRect_inRect_textContainer_characterRange(block: NSTextTableBlock, contentRect: NSRect, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  drawBackgroundForBlock_withFrame_inView_characterRange_layoutManager(block: NSTextTableBlock, frameRect: NSRect, controlView: NSView, charRange: NSRange, layoutManager: NSLayoutManager): void;

  numberOfColumns(): NSUInteger;
  setNumberOfColumns(numberOfColumns: NSUInteger): void;
  layoutAlgorithm(): NSTextTableLayoutAlgorithm;
  setLayoutAlgorithm(layoutAlgorithm: NSTextTableLayoutAlgorithm): void;
  collapsesBorders(): boolean;
  setCollapsesBorders(collapsesBorders: boolean): void;
  hidesEmptyCells(): boolean;
  setHidesEmptyCells(hidesEmptyCells: boolean): void;
}
declare const NSTextTable: {
  alloc(): NSTextTableAllocator;
}

declare enum NSTextBlockValueType {
  NSTextBlockAbsoluteValueType = 0,
  NSTextBlockPercentageValueType = 1,
}

declare enum NSTextBlockDimension {
  NSTextBlockWidth = 0,
  NSTextBlockMinimumWidth = 1,
  NSTextBlockMaximumWidth = 2,
  NSTextBlockHeight = 4,
  NSTextBlockMinimumHeight = 5,
  NSTextBlockMaximumHeight = 6,
}

declare enum NSTextBlockLayer {
  NSTextBlockPadding = -1,
  NSTextBlockBorder = 0,
  NSTextBlockMargin = 1,
}

declare enum NSTextBlockVerticalAlignment {
  NSTextBlockTopAlignment = 0,
  NSTextBlockMiddleAlignment = 1,
  NSTextBlockBottomAlignment = 2,
  NSTextBlockBaselineAlignment = 3,
}

declare enum NSTextTableLayoutAlgorithm {
  NSTextTableAutomaticLayoutAlgorithm = 0,
  NSTextTableFixedLayoutAlgorithm = 1,
}

interface NSTextViewAllocator<InitializedType = NSTextView> extends NSTextAllocator<NSTextView> {
  initWithFrame_textContainer(frameRect: NSRect, container: NSTextContainer | null): InitializedType;
}
interface NSTextView extends NSText, INSUserInterfaceValidations, INSTextInputClient, INSTextLayoutOrientationProvider, INSDraggingSource, INSTextInput, INSAccessibilityNavigableStaticText {
  replaceTextContainer(newContainer: NSTextContainer): void;
  invalidateTextContainerOrigin(): void;
  insertText(insertString: any): void;
  setConstrainedFrameSize(desiredSize: NSSize): void;
  setAlignment_range(alignment: NSTextAlignment, range: NSRange): void;
  setBaseWritingDirection_range(writingDirection: NSWritingDirection, range: NSRange): void;
  turnOffKerning(sender: any | null): void;
  tightenKerning(sender: any | null): void;
  loosenKerning(sender: any | null): void;
  useStandardKerning(sender: any | null): void;
  turnOffLigatures(sender: any | null): void;
  useStandardLigatures(sender: any | null): void;
  useAllLigatures(sender: any | null): void;
  raiseBaseline(sender: any | null): void;
  lowerBaseline(sender: any | null): void;
  toggleTraditionalCharacterShape(sender: any | null): void;
  outline(sender: any | null): void;
  performFindPanelAction(sender: any | null): void;
  alignJustified(sender: any | null): void;
  changeColor(sender: any | null): void;
  changeAttributes(sender: any | null): void;
  changeDocumentBackgroundColor(sender: any | null): void;
  orderFrontSpacingPanel(sender: any | null): void;
  orderFrontLinkPanel(sender: any | null): void;
  orderFrontListPanel(sender: any | null): void;
  orderFrontTablePanel(sender: any | null): void;
  rulerView_didMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_didRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_didAddMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_shouldMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_shouldAddMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willMoveMarker_toLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_shouldRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willAddMarker_atLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_handleMouseDown(ruler: NSRulerView, event: NSEvent): void;
  setNeedsDisplayInRect_avoidAdditionalLayout(rect: NSRect, flag: boolean): void;
  drawInsertionPointInRect_color_turnedOn(rect: NSRect, color: NSColor, flag: boolean): void;
  drawViewBackgroundInRect(rect: NSRect): void;
  updateRuler(): void;
  updateFontPanel(): void;
  updateDragTypeRegistration(): void;
  selectionRangeForProposedRange_granularity(proposedCharRange: NSRange, granularity: NSSelectionGranularity): NSRange;
  clickedOnLink_atIndex(link: any, charIndex: NSUInteger): void;
  startSpeaking(sender: any | null): void;
  stopSpeaking(sender: any | null): void;
  setLayoutOrientation(orientation: NSTextLayoutOrientation): void;
  changeLayoutOrientation(sender: any | null): void;
  characterIndexForInsertionAtPoint(point: NSPoint): NSUInteger;
  complete(sender: any | null): void;
  completionsForPartialWordRange_indexOfSelectedItem(charRange: NSRange, index: NSInteger): NSArray<any>;
  insertCompletion_forPartialWordRange_movement_isFinal(word: NSString | string, charRange: NSRange, movement: NSInteger, flag: boolean): void;
  writeSelectionToPasteboard_type(pboard: NSPasteboard, type: NSPasteboardType): boolean;
  writeSelectionToPasteboard_types(pboard: NSPasteboard, types: NSArray<any> | any[]): boolean;
  preferredPasteboardTypeFromArray_restrictedToTypesFromArray(availableTypes: NSArray<any> | any[], allowedTypes: NSArray<any> | any[] | null): NSPasteboardType;
  readSelectionFromPasteboard_type(pboard: NSPasteboard, type: NSPasteboardType): boolean;
  readSelectionFromPasteboard(pboard: NSPasteboard): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  pasteAsPlainText(sender: any | null): void;
  pasteAsRichText(sender: any | null): void;
  dragSelectionWithEvent_offset_slideBack(event: NSEvent, mouseOffset: NSSize, slideBack: boolean): boolean;
  dragImageForSelectionWithEvent_origin(event: NSEvent, origin: NSPointPointer | null): NSImage;
  dragOperationForDraggingInfo_type(dragInfo: any, type: NSPasteboardType): NSDragOperation;
  cleanUpAfterDragOperation(): void;
  setSelectedRanges_affinity_stillSelecting(ranges: NSArray<any> | any[], affinity: NSSelectionAffinity, stillSelectingFlag: boolean): void;
  setSelectedRange_affinity_stillSelecting(charRange: NSRange, affinity: NSSelectionAffinity, stillSelectingFlag: boolean): void;
  updateInsertionPointStateAndRestartTimer(restartFlag: boolean): void;
  toggleContinuousSpellChecking(sender: any | null): void;
  toggleGrammarChecking(sender: any | null): void;
  setSpellingState_range(value: NSInteger, charRange: NSRange): void;
  shouldChangeTextInRanges_replacementStrings(affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  shouldChangeTextInRange_replacementString(affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  didChangeText(): void;
  breakUndoCoalescing(): void;
  showFindIndicatorForRange(charRange: NSRange): void;
  setSelectedRange(charRange: NSRange): void;
  smartDeleteRangeForProposedRange(proposedCharRange: NSRange): NSRange;
  toggleSmartInsertDelete(sender: any | null): void;
  smartInsertForString_replacingRange_beforeString_afterString(pasteString: NSString | string, charRangeToReplace: NSRange, beforeString: NSString | string, afterString: NSString | string): void;
  smartInsertBeforeStringForString_replacingRange(pasteString: NSString | string, charRangeToReplace: NSRange): NSString;
  smartInsertAfterStringForString_replacingRange(pasteString: NSString | string, charRangeToReplace: NSRange): NSString;
  toggleAutomaticQuoteSubstitution(sender: any | null): void;
  toggleAutomaticLinkDetection(sender: any | null): void;
  toggleAutomaticDataDetection(sender: any | null): void;
  toggleAutomaticDashSubstitution(sender: any | null): void;
  toggleAutomaticTextReplacement(sender: any | null): void;
  toggleAutomaticSpellingCorrection(sender: any | null): void;
  checkTextInRange_types_options(range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}): void;
  handleTextCheckingResults_forRange_types_options_orthography_wordCount(results: NSArray<any> | any[], range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, orthography: NSOrthography, wordCount: NSInteger): void;
  orderFrontSubstitutionsPanel(sender: any | null): void;
  checkTextInSelection(sender: any | null): void;
  checkTextInDocument(sender: any | null): void;
  toggleQuickLookPreviewPanel(sender: any | null): IBAction;
  quickLookPreviewableItemsInRanges(ranges: NSArray<any> | any[]): NSArray<any>;
  updateQuickLookPreviewPanel(): void;
  orderFrontSharingServicePicker(sender: any | null): IBAction;
  toggleAutomaticTextCompletion(sender: any | null): IBAction;
  updateTouchBarItemIdentifiers(): void;
  updateTextTouchBarItems(): void;
  updateCandidates(): void;
  toggleBaseWritingDirection(sender: any | null): void;

  textContainer(): NSTextContainer;
  setTextContainer(textContainer: NSTextContainer): void;
  textContainerInset(): NSSize;
  setTextContainerInset(textContainerInset: NSSize): void;
  textContainerOrigin(): NSPoint;
  layoutManager(): NSLayoutManager;
  textStorage(): NSTextStorage;
  shouldDrawInsertionPoint(): boolean;
  rangeForUserCompletion(): NSRange;
  writablePasteboardTypes(): NSArray<any>;
  readablePasteboardTypes(): NSArray<any>;
  acceptableDragTypes(): NSArray<any>;
  selectedRanges(): NSArray<any>;
  setSelectedRanges(selectedRanges: NSArray<any> | any[]): void;
  selectionAffinity(): NSSelectionAffinity;
  selectionGranularity(): NSSelectionGranularity;
  setSelectionGranularity(selectionGranularity: NSSelectionGranularity): void;
  selectedTextAttributes(): NSDictionary<any, any>;
  setSelectedTextAttributes(selectedTextAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  insertionPointColor(): NSColor;
  setInsertionPointColor(insertionPointColor: NSColor): void;
  markedTextAttributes(): NSDictionary<any, any>;
  setMarkedTextAttributes(markedTextAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  linkTextAttributes(): NSDictionary<any, any>;
  setLinkTextAttributes(linkTextAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  displaysLinkToolTips(): boolean;
  setDisplaysLinkToolTips(displaysLinkToolTips: boolean): void;
  acceptsGlyphInfo(): boolean;
  setAcceptsGlyphInfo(acceptsGlyphInfo: boolean): void;
  usesRuler(): boolean;
  setUsesRuler(usesRuler: boolean): void;
  usesInspectorBar(): boolean;
  setUsesInspectorBar(usesInspectorBar: boolean): void;
  continuousSpellCheckingEnabled(): boolean;
  setContinuousSpellCheckingEnabled(continuousSpellCheckingEnabled: boolean): void;
  spellCheckerDocumentTag(): NSInteger;
  grammarCheckingEnabled(): boolean;
  setGrammarCheckingEnabled(grammarCheckingEnabled: boolean): void;
  typingAttributes(): NSDictionary<any, any>;
  setTypingAttributes(typingAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  rangesForUserTextChange(): NSArray<any>;
  rangesForUserCharacterAttributeChange(): NSArray<any>;
  rangesForUserParagraphAttributeChange(): NSArray<any>;
  rangeForUserTextChange(): NSRange;
  rangeForUserCharacterAttributeChange(): NSRange;
  rangeForUserParagraphAttributeChange(): NSRange;
  allowsDocumentBackgroundColorChange(): boolean;
  setAllowsDocumentBackgroundColorChange(allowsDocumentBackgroundColorChange: boolean): void;
  defaultParagraphStyle(): NSParagraphStyle;
  setDefaultParagraphStyle(defaultParagraphStyle: NSParagraphStyle): void;
  allowsUndo(): boolean;
  setAllowsUndo(allowsUndo: boolean): void;
  coalescingUndo(): boolean;
  allowsImageEditing(): boolean;
  setAllowsImageEditing(allowsImageEditing: boolean): void;
  usesRolloverButtonForSelection(): boolean;
  setUsesRolloverButtonForSelection(usesRolloverButtonForSelection: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  richText(): boolean;
  setRichText(richText: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  fieldEditor(): boolean;
  setFieldEditor(fieldEditor: boolean): void;
  usesFontPanel(): boolean;
  setUsesFontPanel(usesFontPanel: boolean): void;
  rulerVisible(): boolean;
  setRulerVisible(rulerVisible: boolean): void;
  allowedInputSourceLocales(): NSArray<any>;
  setAllowedInputSourceLocales(allowedInputSourceLocales: NSArray<any> | any[]): void;
  smartInsertDeleteEnabled(): boolean;
  setSmartInsertDeleteEnabled(smartInsertDeleteEnabled: boolean): void;
  automaticQuoteSubstitutionEnabled(): boolean;
  setAutomaticQuoteSubstitutionEnabled(automaticQuoteSubstitutionEnabled: boolean): void;
  automaticLinkDetectionEnabled(): boolean;
  setAutomaticLinkDetectionEnabled(automaticLinkDetectionEnabled: boolean): void;
  automaticDataDetectionEnabled(): boolean;
  setAutomaticDataDetectionEnabled(automaticDataDetectionEnabled: boolean): void;
  automaticDashSubstitutionEnabled(): boolean;
  setAutomaticDashSubstitutionEnabled(automaticDashSubstitutionEnabled: boolean): void;
  automaticTextReplacementEnabled(): boolean;
  setAutomaticTextReplacementEnabled(automaticTextReplacementEnabled: boolean): void;
  automaticSpellingCorrectionEnabled(): boolean;
  setAutomaticSpellingCorrectionEnabled(automaticSpellingCorrectionEnabled: boolean): void;
  enabledTextCheckingTypes(): NSTextCheckingTypes;
  setEnabledTextCheckingTypes(enabledTextCheckingTypes: NSTextCheckingTypes): void;
  usesFindPanel(): boolean;
  setUsesFindPanel(usesFindPanel: boolean): void;
  usesFindBar(): boolean;
  setUsesFindBar(usesFindBar: boolean): void;
  incrementalSearchingEnabled(): boolean;
  setIncrementalSearchingEnabled(incrementalSearchingEnabled: boolean): void;
  automaticTextCompletionEnabled(): boolean;
  setAutomaticTextCompletionEnabled(automaticTextCompletionEnabled: boolean): void;
  allowsCharacterPickerTouchBarItem(): boolean;
  setAllowsCharacterPickerTouchBarItem(allowsCharacterPickerTouchBarItem: boolean): void;
  candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
}
declare const NSTextView: {
  alloc(): NSTextViewAllocator;  registerForServices(): void;

  stronglyReferencesTextStorage(): boolean;

}

interface INSTextViewDelegate {
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
}

declare type NSPasteboardTypeFindPanelSearchOptionKey = NSString

declare enum NSSelectionGranularity {
  NSSelectByCharacter = 0,
  NSSelectByWord = 1,
  NSSelectByParagraph = 2,
}

declare enum NSSelectionAffinity {
  NSSelectionAffinityUpstream = 0,
  NSSelectionAffinityDownstream = 1,
}

declare enum NSFindPanelAction {
  NSFindPanelActionShowFindPanel = 1,
  NSFindPanelActionNext = 2,
  NSFindPanelActionPrevious = 3,
  NSFindPanelActionReplaceAll = 4,
  NSFindPanelActionReplace = 5,
  NSFindPanelActionReplaceAndFind = 6,
  NSFindPanelActionSetFindString = 7,
  NSFindPanelActionReplaceAllInSelection = 8,
  NSFindPanelActionSelectAll = 9,
  NSFindPanelActionSelectAllInSelection = 10,
}

declare enum NSFindPanelSubstringMatchType {
  NSFindPanelSubstringMatchTypeContains = 0,
  NSFindPanelSubstringMatchTypeStartsWith = 1,
  NSFindPanelSubstringMatchTypeFullWord = 2,
  NSFindPanelSubstringMatchTypeEndsWith = 3,
}

interface NSTitlebarAccessoryViewControllerAllocator<InitializedType = NSTitlebarAccessoryViewController> extends NSViewControllerAllocator<NSTitlebarAccessoryViewController> {}
interface NSTitlebarAccessoryViewController extends NSViewController, INSAnimationDelegate, INSAnimatablePropertyContainer {

  layoutAttribute(): NSLayoutAttribute;
  setLayoutAttribute(layoutAttribute: NSLayoutAttribute): void;
  fullScreenMinHeight(): CGFloat;
  setFullScreenMinHeight(fullScreenMinHeight: CGFloat): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
}
declare const NSTitlebarAccessoryViewController: {
  alloc(): NSTitlebarAccessoryViewControllerAllocator;
}

interface NSTokenFieldAllocator<InitializedType = NSTokenField> extends NSTextFieldAllocator<NSTokenField> {}
interface NSTokenField extends NSTextField {

  delegate(): any;
  setDelegate(delegate: any): void;
  tokenStyle(): NSTokenStyle;
  setTokenStyle(tokenStyle: NSTokenStyle): void;
  completionDelay(): NSTimeInterval;
  setCompletionDelay(completionDelay: NSTimeInterval): void;
  tokenizingCharacterSet(): NSCharacterSet;
  setTokenizingCharacterSet(tokenizingCharacterSet: NSCharacterSet): void;
}
declare const NSTokenField: {
  alloc(): NSTokenFieldAllocator;
  defaultCompletionDelay(): NSTimeInterval;
  defaultTokenizingCharacterSet(): NSCharacterSet;

}

interface INSTokenFieldDelegate {
  tokenField_completionsForSubstring_indexOfToken_indexOfSelectedItem(tokenField: NSTokenField, substring: NSString | string, tokenIndex: NSInteger, selectedIndex: NSInteger | null): NSArray<any>;
  tokenField_shouldAddObjects_atIndex(tokenField: NSTokenField, tokens: NSArray<any> | any[], index: NSUInteger): NSArray<any>;
  tokenField_displayStringForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSString;
  tokenField_editingStringForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSString;
  tokenField_representedObjectForEditingString(tokenField: NSTokenField, editingString: NSString | string): any;
  tokenField_writeRepresentedObjects_toPasteboard(tokenField: NSTokenField, objects: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  tokenField_readFromPasteboard(tokenField: NSTokenField, pboard: NSPasteboard): NSArray<any>;
  tokenField_menuForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSMenu;
  tokenField_hasMenuForRepresentedObject(tokenField: NSTokenField, representedObject: any): boolean;
  tokenField_styleForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSTokenStyle;
}

interface NSTokenFieldCellAllocator<InitializedType = NSTokenFieldCell> extends NSTextFieldCellAllocator<NSTokenFieldCell> {}
interface NSTokenFieldCell extends NSTextFieldCell {

  tokenStyle(): NSTokenStyle;
  setTokenStyle(tokenStyle: NSTokenStyle): void;
  completionDelay(): NSTimeInterval;
  setCompletionDelay(completionDelay: NSTimeInterval): void;
  tokenizingCharacterSet(): NSCharacterSet;
  setTokenizingCharacterSet(tokenizingCharacterSet: NSCharacterSet): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const NSTokenFieldCell: {
  alloc(): NSTokenFieldCellAllocator;
  defaultCompletionDelay(): NSTimeInterval;
  defaultTokenizingCharacterSet(): NSCharacterSet;

}

interface INSTokenFieldCellDelegate {
  tokenFieldCell_completionsForSubstring_indexOfToken_indexOfSelectedItem(tokenFieldCell: NSTokenFieldCell, substring: NSString | string, tokenIndex: NSInteger, selectedIndex: NSInteger): NSArray<any>;
  tokenFieldCell_shouldAddObjects_atIndex(tokenFieldCell: NSTokenFieldCell, tokens: NSArray<any> | any[], index: NSUInteger): NSArray<any>;
  tokenFieldCell_displayStringForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSString;
  tokenFieldCell_editingStringForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSString;
  tokenFieldCell_representedObjectForEditingString(tokenFieldCell: NSTokenFieldCell, editingString: NSString | string): any;
  tokenFieldCell_writeRepresentedObjects_toPasteboard(tokenFieldCell: NSTokenFieldCell, objects: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  tokenFieldCell_readFromPasteboard(tokenFieldCell: NSTokenFieldCell, pboard: NSPasteboard): NSArray<any>;
  tokenFieldCell_menuForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSMenu;
  tokenFieldCell_hasMenuForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): boolean;
  tokenFieldCell_styleForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSTokenStyle;
}

declare enum NSTokenStyle {
  NSTokenStyleDefault,
  NSTokenStyleNone,
  NSTokenStyleRounded,
  NSTokenStyleSquared,
  NSTokenStylePlainSquared,
}

interface NSToolbarAllocator<InitializedType = NSToolbar> extends NSObjectAllocator<NSToolbar> {
  initWithIdentifier(identifier: NSToolbarIdentifier): InitializedType;
  init(): InitializedType;
}
interface NSToolbar extends NSObject {
  insertItemWithItemIdentifier_atIndex(itemIdentifier: NSToolbarItemIdentifier, index: NSInteger): void;
  removeItemAtIndex(index: NSInteger): void;
  runCustomizationPalette(sender: any | null): void;
  setConfigurationFromDictionary(configDict: NSDictionary<any, any> | {[key: string]: any}): void;
  validateVisibleItems(): void;
  itemWithIdentifier(identifier: NSString | string): NSToolbarItem;
  _toolbarView(): any;
  ms_toolbarHeight(): CGFloat;
  _fullLayout(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  visible(): boolean;
  setVisible(visible: boolean): void;
  customizationPaletteIsRunning(): boolean;
  displayMode(): NSToolbarDisplayMode;
  setDisplayMode(displayMode: NSToolbarDisplayMode): void;
  selectedItemIdentifier(): NSToolbarItemIdentifier;
  setSelectedItemIdentifier(selectedItemIdentifier: NSToolbarItemIdentifier): void;
  sizeMode(): NSToolbarSizeMode;
  setSizeMode(sizeMode: NSToolbarSizeMode): void;
  showsBaselineSeparator(): boolean;
  setShowsBaselineSeparator(showsBaselineSeparator: boolean): void;
  allowsUserCustomization(): boolean;
  setAllowsUserCustomization(allowsUserCustomization: boolean): void;
  identifier(): NSToolbarIdentifier;
  items(): NSArray<any>;
  visibleItems(): NSArray<any>;
  autosavesConfiguration(): boolean;
  setAutosavesConfiguration(autosavesConfiguration: boolean): void;
  configurationDictionary(): NSDictionary<any, any>;
  allowsExtensionItems(): boolean;
  setAllowsExtensionItems(allowsExtensionItems: boolean): void;
  fullScreenAccessoryView(): NSView;
  setFullScreenAccessoryView(fullScreenAccessoryView: NSView): void;
  fullScreenAccessoryViewMinHeight(): CGFloat;
  setFullScreenAccessoryViewMinHeight(fullScreenAccessoryViewMinHeight: CGFloat): void;
  fullScreenAccessoryViewMaxHeight(): CGFloat;
  setFullScreenAccessoryViewMaxHeight(fullScreenAccessoryViewMaxHeight: CGFloat): void;
}
declare const NSToolbar: {
  alloc(): NSToolbarAllocator;
}

interface INSToolbarDelegate {
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;
}

declare type NSToolbarIdentifier = NSString

declare type NSToolbarItemIdentifier = NSString

declare enum NSToolbarDisplayMode {
  NSToolbarDisplayModeDefault,
  NSToolbarDisplayModeIconAndLabel,
  NSToolbarDisplayModeIconOnly,
  NSToolbarDisplayModeLabelOnly,
}

declare enum NSToolbarSizeMode {
  NSToolbarSizeModeDefault,
  NSToolbarSizeModeRegular,
  NSToolbarSizeModeSmall,
}

interface NSToolbarItemAllocator<InitializedType = NSToolbarItem> extends NSObjectAllocator<NSToolbarItem> {
  initWithItemIdentifier(itemIdentifier: NSToolbarItemIdentifier): InitializedType;
}
interface NSToolbarItem extends NSObject, INSCopying, INSValidatedUserInterfaceItem {
  validate(): void;

  itemIdentifier(): NSToolbarItemIdentifier;
  toolbar(): NSToolbar;
  label(): NSString;
  setLabel(label: NSString | string): void;
  paletteLabel(): NSString;
  setPaletteLabel(paletteLabel: NSString | string): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  menuFormRepresentation(): NSMenuItem;
  setMenuFormRepresentation(menuFormRepresentation: NSMenuItem): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  view(): NSView;
  setView(view: NSView): void;
  minSize(): NSSize;
  setMinSize(minSize: NSSize): void;
  maxSize(): NSSize;
  setMaxSize(maxSize: NSSize): void;
  visibilityPriority(): NSToolbarItemVisibilityPriority;
  setVisibilityPriority(visibilityPriority: NSToolbarItemVisibilityPriority): void;
  autovalidates(): boolean;
  setAutovalidates(autovalidates: boolean): void;
  allowsDuplicatesInToolbar(): boolean;
}
declare const NSToolbarItem: {
  alloc(): NSToolbarItemAllocator;
}

interface INSCloudSharingValidation {
  cloudShareForUserInterfaceItem(item: any): CKShare;
}

declare type NSToolbarItemVisibilityPriority = NSInteger

interface NSToolbarItemGroupAllocator<InitializedType = NSToolbarItemGroup> extends NSToolbarItemAllocator<NSToolbarItemGroup> {}
interface NSToolbarItemGroup extends NSToolbarItem {

  subitems(): NSArray<any>;
  setSubitems(subitems: NSArray<any> | any[]): void;
}
declare const NSToolbarItemGroup: {
  alloc(): NSToolbarItemGroupAllocator;
}

interface NSTouchAllocator<InitializedType = NSTouch> extends NSObjectAllocator<NSTouch> {}
interface NSTouch extends NSObject, INSCopying {
  locationInView(view: NSView | null): NSPoint;
  previousLocationInView(view: NSView | null): NSPoint;

  identity(): any;
  phase(): NSTouchPhase;
  normalizedPosition(): NSPoint;
  resting(): boolean;
  device(): any;
  deviceSize(): NSSize;
  type(): NSTouchType;
}
declare const NSTouch: {
  alloc(): NSTouchAllocator;
}

declare enum NSTouchPhase {
  NSTouchPhaseBegan = 1 << 0,
  NSTouchPhaseMoved = 1 << 1,
  NSTouchPhaseStationary = 1 << 2,
  NSTouchPhaseEnded = 1 << 3,
  NSTouchPhaseCancelled = 1 << 4,
  NSTouchPhaseTouching,
  NSTouchPhaseAny,
}

declare enum NSTouchType {
  NSTouchTypeDirect,
  NSTouchTypeIndirect,
}

declare enum NSTouchTypeMask {
  NSTouchTypeMaskDirect,
  NSTouchTypeMaskIndirect,
}

interface NSTouchBarAllocator<InitializedType = NSTouchBar> extends NSObjectAllocator<NSTouchBar> {
  init(): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTouchBar extends NSObject, INSCoding, INSCoding {
  itemForIdentifier(identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  customizationIdentifier(): NSTouchBarCustomizationIdentifier;
  setCustomizationIdentifier(customizationIdentifier: NSTouchBarCustomizationIdentifier): void;
  customizationAllowedItemIdentifiers(): NSArray<any>;
  setCustomizationAllowedItemIdentifiers(customizationAllowedItemIdentifiers: NSArray<any> | any[]): void;
  customizationRequiredItemIdentifiers(): NSArray<any>;
  setCustomizationRequiredItemIdentifiers(customizationRequiredItemIdentifiers: NSArray<any> | any[]): void;
  defaultItemIdentifiers(): NSArray<any>;
  setDefaultItemIdentifiers(defaultItemIdentifiers: NSArray<any> | any[]): void;
  itemIdentifiers(): NSArray<any>;
  principalItemIdentifier(): NSTouchBarItemIdentifier;
  setPrincipalItemIdentifier(principalItemIdentifier: NSTouchBarItemIdentifier): void;
  escapeKeyReplacementItemIdentifier(): NSTouchBarItemIdentifier;
  setEscapeKeyReplacementItemIdentifier(escapeKeyReplacementItemIdentifier: NSTouchBarItemIdentifier): void;
  templateItems(): NSSet<any>;
  setTemplateItems(templateItems: NSSet<any>): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  visible(): boolean;
}
declare const NSTouchBar: {
  alloc(): NSTouchBarAllocator;
}

interface INSTouchBarDelegate extends NSObject {
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
}

interface INSTouchBarProvider {

  touchBar(): NSTouchBar;
}

declare type NSTouchBarCustomizationIdentifier = NSString

interface NSTouchBarItemAllocator<InitializedType = NSTouchBarItem> extends NSObjectAllocator<NSTouchBarItem> {
  initWithIdentifier(identifier: NSTouchBarItemIdentifier): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTouchBarItem extends NSObject, INSCoding, INSCoding {

  identifier(): NSTouchBarItemIdentifier;
  visibilityPriority(): NSTouchBarItemPriority;
  setVisibilityPriority(visibilityPriority: NSTouchBarItemPriority): void;
  view(): NSView;
  viewController(): NSViewController;
  customizationLabel(): NSString;
  visible(): boolean;
}
declare const NSTouchBarItem: {
  alloc(): NSTouchBarItemAllocator;
}

declare type NSTouchBarItemIdentifier = NSString

declare type NSTouchBarItemPriority = number

interface NSTrackingAreaAllocator<InitializedType = NSTrackingArea> extends NSObjectAllocator<NSTrackingArea> {
  initWithRect_options_owner_userInfo(rect: NSRect, options: NSTrackingAreaOptions, owner: any | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSTrackingArea extends NSObject, INSCopying, INSCoding {

  rect(): NSRect;
  options(): NSTrackingAreaOptions;
  owner(): any;
  userInfo(): NSDictionary<any, any>;
}
declare const NSTrackingArea: {
  alloc(): NSTrackingAreaAllocator;  mouseEnterExitTrackingArea(owner: any): NSTrackingArea;
  trackingAreaWithOptions_owner(options: NSTrackingAreaOptions, owner: any): NSTrackingArea;

}

declare enum NSTrackingAreaOptions {
  NSTrackingMouseEnteredAndExited = 0x01,
  NSTrackingMouseMoved = 0x02,
  NSTrackingCursorUpdate = 0x04,
  NSTrackingActiveWhenFirstResponder = 0x10,
  NSTrackingActiveInKeyWindow = 0x20,
  NSTrackingActiveInActiveApp = 0x40,
  NSTrackingActiveAlways = 0x80,
  NSTrackingAssumeInside = 0x100,
  NSTrackingInVisibleRect = 0x200,
  NSTrackingEnabledDuringMouseDrag = 0x400,
}

interface NSTreeControllerAllocator<InitializedType = NSTreeController> extends NSObjectControllerAllocator<NSTreeController> {}
interface NSTreeController extends NSObjectController {
  rearrangeObjects(): void;
  add(sender: any | null): IBAction;
  remove(sender: any | null): IBAction;
  addChild(sender: any | null): IBAction;
  insert(sender: any | null): IBAction;
  insertChild(sender: any | null): IBAction;
  insertObject_atArrangedObjectIndexPath(object: any | null, indexPath: NSIndexPath): void;
  insertObjects_atArrangedObjectIndexPaths(objects: NSArray<any> | any[], indexPaths: NSArray<any> | any[]): void;
  removeObjectAtArrangedObjectIndexPath(indexPath: NSIndexPath): void;
  removeObjectsAtArrangedObjectIndexPaths(indexPaths: NSArray<any> | any[]): void;
  setSelectionIndexPaths(indexPaths: NSArray<any> | any[]): boolean;
  setSelectionIndexPath(indexPath: NSIndexPath | null): boolean;
  addSelectionIndexPaths(indexPaths: NSArray<any> | any[]): boolean;
  removeSelectionIndexPaths(indexPaths: NSArray<any> | any[]): boolean;
  moveNode_toIndexPath(node: NSTreeNode, indexPath: NSIndexPath): void;
  moveNodes_toIndexPath(nodes: NSArray<any> | any[], startingIndexPath: NSIndexPath): void;
  childrenKeyPathForNode(node: NSTreeNode): NSString;
  countKeyPathForNode(node: NSTreeNode): NSString;
  leafKeyPathForNode(node: NSTreeNode): NSString;

  arrangedObjects(): NSTreeNode;
  childrenKeyPath(): NSString;
  setChildrenKeyPath(childrenKeyPath: NSString | string): void;
  countKeyPath(): NSString;
  setCountKeyPath(countKeyPath: NSString | string): void;
  leafKeyPath(): NSString;
  setLeafKeyPath(leafKeyPath: NSString | string): void;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  content(): any;
  setContent(content: any): void;
  canInsert(): boolean;
  canInsertChild(): boolean;
  canAddChild(): boolean;
  avoidsEmptySelection(): boolean;
  setAvoidsEmptySelection(avoidsEmptySelection: boolean): void;
  preservesSelection(): boolean;
  setPreservesSelection(preservesSelection: boolean): void;
  selectsInsertedObjects(): boolean;
  setSelectsInsertedObjects(selectsInsertedObjects: boolean): void;
  alwaysUsesMultipleValuesMarker(): boolean;
  setAlwaysUsesMultipleValuesMarker(alwaysUsesMultipleValuesMarker: boolean): void;
  selectedObjects(): NSArray<any>;
  selectionIndexPaths(): NSArray<any>;
  selectionIndexPath(): NSIndexPath;
  selectedNodes(): NSArray<any>;
}
declare const NSTreeController: {
  alloc(): NSTreeControllerAllocator;
}

interface NSTreeNodeAllocator<InitializedType = NSTreeNode> extends NSObjectAllocator<NSTreeNode> {
  initWithRepresentedObject(modelObject: any | null): InitializedType;
}
interface NSTreeNode extends NSObject {
  descendantNodeAtIndexPath(indexPath: NSIndexPath): NSTreeNode;
  sortWithSortDescriptors_recursively(sortDescriptors: NSArray<any> | any[], recursively: boolean): void;

  representedObject(): any;
  indexPath(): NSIndexPath;
  leaf(): boolean;
  childNodes(): NSArray<any>;
  mutableChildNodes(): NSMutableArray<any>;
  parentNode(): NSTreeNode;
}
declare const NSTreeNode: {
  alloc(): NSTreeNodeAllocator;  treeNodeWithRepresentedObject(modelObject: any | null): NSTreeNode;

}

interface NSTypesetterAllocator<InitializedType = NSTypesetter> extends NSObjectAllocator<NSTypesetter> {}
interface NSTypesetter extends NSObject {
  substituteFontForFont(originalFont: NSFont): NSFont;
  textTabForGlyphLocation_writingDirection_maxLocation(glyphLocation: CGFloat, direction: NSWritingDirection, maxLocation: CGFloat): NSTextTab;
  setParagraphGlyphRange_separatorGlyphRange(paragraphRange: NSRange, paragraphSeparatorRange: NSRange): void;
  layoutParagraphAtPoint(lineFragmentOrigin: NSPointPointer): NSUInteger;
  beginParagraph(): void;
  endParagraph(): void;
  beginLineWithGlyphAtIndex(glyphIndex: NSUInteger): void;
  endLineWithGlyphRange(lineGlyphRange: NSRange): void;
  lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  getLineFragmentRect_usedRect_forParagraphSeparatorGlyphRange_atProposedOrigin(lineFragmentRect: NSRectPointer, lineFragmentUsedRect: NSRectPointer, paragraphSeparatorGlyphRange: NSRange, lineOrigin: NSPoint): void;
  setHardInvalidation_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  layoutGlyphsInLayoutManager_startingAtGlyphIndex_maxNumberOfLineFragments_nextGlyphIndex(layoutManager: NSLayoutManager, startGlyphIndex: NSUInteger, maxNumLines: NSUInteger, nextGlyph: NSUInteger): void;
  layoutCharactersInRange_forLayoutManager_maximumNumberOfLineFragments(characterRange: NSRange, layoutManager: NSLayoutManager, maxNumLines: NSUInteger): NSRange;
  baselineOffsetInLayoutManager_glyphIndex(layoutMgr: NSLayoutManager, glyphIndex: NSUInteger): CGFloat;
  willSetLineFragmentRect_forGlyphRange_usedRect_baselineOffset(lineRect: NSRectPointer, glyphRange: NSRange, usedRect: NSRectPointer, baselineOffset: CGFloat): void;
  shouldBreakLineByWordBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  shouldBreakLineByHyphenatingBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  hyphenationFactorForGlyphAtIndex(glyphIndex: NSUInteger): number;
  hyphenCharacterForGlyphAtIndex(glyphIndex: NSUInteger): string;
  boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(glyphIndex: NSUInteger, textContainer: NSTextContainer, proposedRect: NSRect, glyphPosition: NSPoint, charIndex: NSUInteger): NSRect;
  characterRangeForGlyphRange_actualGlyphRange(glyphRange: NSRange, actualGlyphRange: NSRangePointer | null): NSRange;
  glyphRangeForCharacterRange_actualCharacterRange(charRange: NSRange, actualCharRange: NSRangePointer | null): NSRange;
  getLineFragmentRect_usedRect_remainingRect_forStartingGlyphAtIndex_proposedRect_lineSpacing_paragraphSpacingBefore_paragraphSpacingAfter(lineFragmentRect: NSRectPointer, lineFragmentUsedRect: NSRectPointer, remainingRect: NSRectPointer, startingGlyphIndex: NSUInteger, proposedRect: NSRect, lineSpacing: CGFloat, paragraphSpacingBefore: CGFloat, paragraphSpacingAfter: CGFloat): void;
  setLineFragmentRect_forGlyphRange_usedRect_baselineOffset(fragmentRect: NSRect, glyphRange: NSRange, usedRect: NSRect, baselineOffset: CGFloat): void;
  setNotShownAttribute_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  setDrawsOutsideLineFragment_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  setLocation_withAdvancements_forStartOfGlyphRange(location: NSPoint, advancements: CGFloat, glyphRange: NSRange): void;
  setAttachmentSize_forGlyphRange(attachmentSize: NSSize, glyphRange: NSRange): void;
  setBidiLevels_forGlyphRange(levels: number, glyphRange: NSRange): void;
  actionForControlCharacterAtIndex(charIndex: NSUInteger): NSTypesetterControlCharacterAction;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits_bidiLevels(glyphsRange: NSRange, glyphBuffer: NSGlyph, charIndexBuffer: NSUInteger, inscribeBuffer: NSGlyphInscription, elasticBuffer: boolean, bidiLevelBuffer: string): NSUInteger;
  substituteGlyphsInRange_withGlyphs(glyphRange: NSRange, glyphs: NSGlyph): void;
  insertGlyph_atGlyphIndex_characterIndex(glyph: NSGlyph, glyphIndex: NSUInteger, characterIndex: NSUInteger): void;
  deleteGlyphsInRange(glyphRange: NSRange): void;

  usesFontLeading(): boolean;
  setUsesFontLeading(usesFontLeading: boolean): void;
  typesetterBehavior(): NSTypesetterBehavior;
  setTypesetterBehavior(typesetterBehavior: NSTypesetterBehavior): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  lineFragmentPadding(): CGFloat;
  setLineFragmentPadding(lineFragmentPadding: CGFloat): void;
  bidiProcessingEnabled(): boolean;
  setBidiProcessingEnabled(bidiProcessingEnabled: boolean): void;
  attributedString(): NSAttributedString;
  setAttributedString(attributedString: NSAttributedString): void;
  paragraphGlyphRange(): NSRange;
  paragraphSeparatorGlyphRange(): NSRange;
  paragraphCharacterRange(): NSRange;
  paragraphSeparatorCharacterRange(): NSRange;
  attributesForExtraLineFragment(): NSDictionary<any, any>;
  layoutManager(): NSLayoutManager;
  textContainers(): NSArray<any>;
  currentTextContainer(): NSTextContainer;
  currentParagraphStyle(): NSParagraphStyle;
}
declare const NSTypesetter: {
  alloc(): NSTypesetterAllocator;  printingAdjustmentInLayoutManager_forNominallySpacedGlyphRange_packedGlyphs_count(layoutMgr: NSLayoutManager, nominallySpacedGlyphsRange: NSRange, packedGlyphs: string, packedGlyphsCount: NSUInteger): NSSize;
  sharedSystemTypesetterForBehavior(behavior: NSTypesetterBehavior): any;

  sharedSystemTypesetter(): NSTypesetter;
  defaultTypesetterBehavior(): NSTypesetterBehavior;

}

declare enum NSTypesetterControlCharacterAction {
  NSTypesetterZeroAdvancementAction,
  NSTypesetterWhitespaceAction,
  NSTypesetterHorizontalTabAction,
  NSTypesetterLineBreakAction,
  NSTypesetterParagraphBreakAction,
  NSTypesetterContainerBreakAction,
}

interface NSUserDefaultsControllerAllocator<InitializedType = NSUserDefaultsController> extends NSControllerAllocator<NSUserDefaultsController> {
  initWithDefaults_initialValues(defaults: NSUserDefaults | null, initialValues: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface NSUserDefaultsController extends NSController {
  revert(sender: any | null): IBAction;
  save(sender: any | null): IBAction;
  revertToInitialValues(sender: any | null): IBAction;

  defaults(): NSUserDefaults;
  initialValues(): NSDictionary<any, any>;
  setInitialValues(initialValues: NSDictionary<any, any> | {[key: string]: any}): void;
  appliesImmediately(): boolean;
  setAppliesImmediately(appliesImmediately: boolean): void;
  hasUnappliedChanges(): boolean;
  values(): any;
}
declare const NSUserDefaultsController: {
  alloc(): NSUserDefaultsControllerAllocator;
  sharedUserDefaultsController(): NSUserDefaultsController;

}

interface NSUserInterfaceCompressionOptionsAllocator<InitializedType = NSUserInterfaceCompressionOptions> extends NSObjectAllocator<NSUserInterfaceCompressionOptions> {
  init(): InitializedType;
  initWithCoder(coder: NSCoder): InitializedType;
  initWithIdentifier(identifier: NSString | string): InitializedType;
  initWithCompressionOptions(options: NSSet<any>): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface NSUserInterfaceCompressionOptions extends NSObject, INSCopying, INSCoding {
  containsOptions(options: NSUserInterfaceCompressionOptions): boolean;
  intersectsOptions(options: NSUserInterfaceCompressionOptions): boolean;
  optionsByAddingOptions(options: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
  optionsByRemovingOptions(options: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;

  empty(): boolean;
}
declare const NSUserInterfaceCompressionOptions: {
  alloc(): NSUserInterfaceCompressionOptionsAllocator;
  hideImagesOption(): NSUserInterfaceCompressionOptions;
  hideTextOption(): NSUserInterfaceCompressionOptions;
  reduceMetricsOption(): NSUserInterfaceCompressionOptions;
  breakEqualWidthsOption(): NSUserInterfaceCompressionOptions;
  standardOptions(): NSUserInterfaceCompressionOptions;

}

interface INSUserInterfaceCompression {
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;

  activeCompressionOptions(): NSUserInterfaceCompressionOptions;
}

interface INSUserInterfaceItemIdentification {

  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
}

declare type NSUserInterfaceItemIdentifier = NSString

interface INSUserInterfaceItemSearching {
  searchForItemsWithSearchString_resultLimit_matchedItemHandler(searchString: NSString | string, resultLimit: NSInteger, handleMatchedItems: Block): void;
  localizedTitlesForItem(item: any): NSArray<any>;
  performActionForItem(item: any): void;
  showAllHelpTopicsForSearchString(searchString: NSString | string): void;
}

declare enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight = 0,
  NSUserInterfaceLayoutDirectionRightToLeft = 1,
}

declare enum NSUserInterfaceLayoutOrientation {
  NSUserInterfaceLayoutOrientationHorizontal = 0,
  NSUserInterfaceLayoutOrientationVertical = 1,
}

interface INSValidatedUserInterfaceItem {

  action(): string;
  tag(): NSInteger;
}

interface INSUserInterfaceValidations {
  validateUserInterfaceItem(item: any): boolean;
}

declare type NSTrackingRectTag = NSInteger

declare type NSToolTipTag = NSInteger

declare type NSViewFullScreenModeOptionKey = NSString

declare type NSDefinitionOptionKey = NSString

declare type NSDefinitionPresentationType = NSString

declare enum NSAutoresizingMaskOptions {
  NSViewNotSizable = 0,
  NSViewMinXMargin = 1,
  NSViewWidthSizable = 2,
  NSViewMaxXMargin = 4,
  NSViewMinYMargin = 8,
  NSViewHeightSizable = 16,
  NSViewMaxYMargin = 32,
}

declare enum NSBorderType {
  NSNoBorder = 0,
  NSLineBorder = 1,
  NSBezelBorder = 2,
  NSGrooveBorder = 3,
}

declare enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever = 0,
  NSViewLayerContentsRedrawOnSetNeedsDisplay = 1,
  NSViewLayerContentsRedrawDuringViewResize = 2,
  NSViewLayerContentsRedrawBeforeViewResize = 3,
  NSViewLayerContentsRedrawCrossfade = 4,
}

declare enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently = 0,
  NSViewLayerContentsPlacementScaleProportionallyToFit = 1,
  NSViewLayerContentsPlacementScaleProportionallyToFill = 2,
  NSViewLayerContentsPlacementCenter = 3,
  NSViewLayerContentsPlacementTop = 4,
  NSViewLayerContentsPlacementTopRight = 5,
  NSViewLayerContentsPlacementRight = 6,
  NSViewLayerContentsPlacementBottomRight = 7,
  NSViewLayerContentsPlacementBottom = 8,
  NSViewLayerContentsPlacementBottomLeft = 9,
  NSViewLayerContentsPlacementLeft = 10,
  NSViewLayerContentsPlacementTopLeft = 11,
}

interface NSViewControllerAllocator<InitializedType = NSViewController> extends NSResponderAllocator<NSViewController> {
  initWithNibName_bundle(nibNameOrNil: NSNibName | null, nibBundleOrNil: NSBundle | null): InitializedType;
}
interface NSViewController extends NSResponder, INSCoding, INSSeguePerforming, INSUserInterfaceItemIdentification {
  loadView(): void;
  commitEditingWithDelegate_didCommitSelector_contextInfo(delegate: any | null, didCommitSelector: string | null, contextInfo: void | null): void;
  commitEditing(): boolean;
  discardEditing(): void;
  viewDidLoad(): void;
  viewWillAppear(): void;
  viewDidAppear(): void;
  viewWillDisappear(): void;
  viewDidDisappear(): void;
  updateViewConstraints(): void;
  viewWillLayout(): void;
  viewDidLayout(): void;
  presentViewController_animator(viewController: NSViewController, animator: any): void;
  dismissViewController(viewController: NSViewController): void;
  dismissController(sender: any | null): IBAction;
  presentViewControllerAsSheet(viewController: NSViewController): void;
  presentViewControllerAsModalWindow(viewController: NSViewController): void;
  presentViewController_asPopoverRelativeToRect_ofView_preferredEdge_behavior(viewController: NSViewController, positioningRect: NSRect, positioningView: NSView, preferredEdge: NSRectEdge, behavior: NSPopoverBehavior): void;
  transitionFromViewController_toViewController_options_completionHandler(fromViewController: NSViewController, toViewController: NSViewController, options: NSViewControllerTransitionOptions, completion: Block): void;
  addChildViewController(childViewController: NSViewController): void;
  removeFromParentViewController(): void;
  insertChildViewController_atIndex(childViewController: NSViewController, index: NSInteger): void;
  removeChildViewControllerAtIndex(index: NSInteger): void;
  preferredContentSizeDidChangeForViewController(viewController: NSViewController): void;
  viewWillTransitionToSize(newSize: NSSize): void;
  presentViewController_asBCPopoverRelativeToView_preferredEdge_screenEdgeBehaviour(viewController: NSViewController, positioningView: NSView, preferredEdge: NSRectEdge, behaviour: BCPopoverScreenEdgeBehaviour): BCPopover;
  targetViewControllerForAction_sender(action: string, sender: any | null): NSViewController;
  ensureLoaded(): void;
  inspectorController(): MSInspectorController;
  reloadInspectorStack(sender: any): IBAction;

  nibName(): NSNibName;
  nibBundle(): NSBundle;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  view(): NSView;
  setView(view: NSView): void;
  viewLoaded(): boolean;
  preferredContentSize(): NSSize;
  setPreferredContentSize(preferredContentSize: NSSize): void;
  presentedViewControllers(): NSArray<any>;
  presentingViewController(): NSViewController;
  parentViewController(): NSViewController;
  childViewControllers(): NSArray<any>;
  setChildViewControllers(childViewControllers: NSArray<any> | any[]): void;
  storyboard(): NSStoryboard;
  extensionContext(): NSExtensionContext;
  sourceItemView(): NSView;
  setSourceItemView(sourceItemView: NSView): void;
  preferredScreenOrigin(): NSPoint;
  setPreferredScreenOrigin(preferredScreenOrigin: NSPoint): void;
  preferredMinimumSize(): NSSize;
  preferredMaximumSize(): NSSize;
  rootViewController(): NSViewController;
}
declare const NSViewController: {
  alloc(): NSViewControllerAllocator;
}

interface INSViewControllerPresentationAnimator {
  animatePresentationOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
  animateDismissalOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
}

declare enum NSViewControllerTransitionOptions {
  NSViewControllerTransitionNone = 0x0,
  NSViewControllerTransitionCrossfade = 0x1,
  NSViewControllerTransitionSlideUp = 0x10,
  NSViewControllerTransitionSlideDown = 0x20,
  NSViewControllerTransitionSlideLeft = 0x40,
  NSViewControllerTransitionSlideRight = 0x80,
  NSViewControllerTransitionSlideForward = 0x140,
  NSViewControllerTransitionSlideBackward = 0x180,
  NSViewControllerTransitionAllowUserInteraction = 0x1000,
}

interface NSVisualEffectViewAllocator<InitializedType = NSVisualEffectView> extends NSViewAllocator<NSVisualEffectView> {}
interface NSVisualEffectView extends NSView {

  material(): NSVisualEffectMaterial;
  setMaterial(material: NSVisualEffectMaterial): void;
  interiorBackgroundStyle(): NSBackgroundStyle;
  blendingMode(): NSVisualEffectBlendingMode;
  setBlendingMode(blendingMode: NSVisualEffectBlendingMode): void;
  state(): NSVisualEffectState;
  setState(state: NSVisualEffectState): void;
  maskImage(): NSImage;
  setMaskImage(maskImage: NSImage): void;
  emphasized(): boolean;
  setEmphasized(emphasized: boolean): void;
}
declare const NSVisualEffectView: {
  alloc(): NSVisualEffectViewAllocator;
}

declare enum NSVisualEffectMaterial {
  NSVisualEffectMaterialAppearanceBased = 0,
  NSVisualEffectMaterialTitlebar = 3,
  NSVisualEffectMaterialSelection = 4,
  NSVisualEffectMaterialMenu = 5,
  NSVisualEffectMaterialPopover = 6,
  NSVisualEffectMaterialSidebar = 7,
  NSVisualEffectMaterialLight = 1,
  NSVisualEffectMaterialDark = 2,
  NSVisualEffectMaterialMediumLight = 8,
  NSVisualEffectMaterialUltraDark = 9,
}

declare enum NSVisualEffectBlendingMode {
  NSVisualEffectBlendingModeBehindWindow,
  NSVisualEffectBlendingModeWithinWindow,
}

declare enum NSVisualEffectState {
  NSVisualEffectStateFollowsWindowActiveState,
  NSVisualEffectStateActive,
  NSVisualEffectStateInactive,
}

interface INSWindowDelegate {
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
}

declare type NSWindowLevel = NSInteger

declare type NSWindowFrameAutosaveName = NSString

declare type NSWindowTabbingIdentifier = NSString

declare enum NSWindowStyleMask {
  NSWindowStyleMaskBorderless = 0,
  NSWindowStyleMaskTitled = 1 << 0,
  NSWindowStyleMaskClosable = 1 << 1,
  NSWindowStyleMaskMiniaturizable = 1 << 2,
  NSWindowStyleMaskResizable = 1 << 3,
  NSWindowStyleMaskTexturedBackground = 1 << 8,
  NSWindowStyleMaskUnifiedTitleAndToolbar = 1 << 12,
  NSWindowStyleMaskFullScreen = 1 << 14,
  NSWindowStyleMaskFullSizeContentView = 1 << 15,
  NSWindowStyleMaskUtilityWindow = 1 << 4,
  NSWindowStyleMaskDocModalWindow = 1 << 6,
  NSWindowStyleMaskNonactivatingPanel = 1 << 7,
  NSWindowStyleMaskHUDWindow = 1 << 13,
}

declare enum NSWindowSharingType {
  NSWindowSharingNone = 0,
  NSWindowSharingReadOnly = 1,
  NSWindowSharingReadWrite = 2,
}

declare enum NSWindowBackingLocation {
  NSWindowBackingLocationDefault = 0,
  NSWindowBackingLocationVideoMemory = 1,
  NSWindowBackingLocationMainMemory = 2,
}

declare enum NSWindowCollectionBehavior {
  NSWindowCollectionBehaviorDefault = 0,
  NSWindowCollectionBehaviorCanJoinAllSpaces = 1 << 0,
  NSWindowCollectionBehaviorMoveToActiveSpace = 1 << 1,
  NSWindowCollectionBehaviorManaged = 1 << 2,
  NSWindowCollectionBehaviorTransient = 1 << 3,
  NSWindowCollectionBehaviorStationary = 1 << 4,
  NSWindowCollectionBehaviorParticipatesInCycle = 1 << 5,
  NSWindowCollectionBehaviorIgnoresCycle = 1 << 6,
  NSWindowCollectionBehaviorFullScreenPrimary = 1 << 7,
  NSWindowCollectionBehaviorFullScreenAuxiliary = 1 << 8,
  NSWindowCollectionBehaviorFullScreenNone = 1 << 9,
  NSWindowCollectionBehaviorFullScreenAllowsTiling = 1 << 11,
  NSWindowCollectionBehaviorFullScreenDisallowsTiling = 1 << 12,
}

declare enum NSWindowAnimationBehavior {
  NSWindowAnimationBehaviorDefault = 0,
  NSWindowAnimationBehaviorNone = 2,
  NSWindowAnimationBehaviorDocumentWindow = 3,
  NSWindowAnimationBehaviorUtilityWindow = 4,
  NSWindowAnimationBehaviorAlertPanel = 5,
}

declare enum NSWindowNumberListOptions {
  NSWindowNumberListAllApplications = 1 << 0,
  NSWindowNumberListAllSpaces = 1 << 4,
}

declare enum NSWindowOcclusionState {
  NSWindowOcclusionStateVisible = 1 << 1,
}

declare enum NSSelectionDirection {
  NSDirectSelection = 0,
  NSSelectingNext,
  NSSelectingPrevious,
}

declare enum NSWindowButton {
  NSWindowCloseButton,
  NSWindowMiniaturizeButton,
  NSWindowZoomButton,
  NSWindowToolbarButton,
  NSWindowDocumentIconButton,
  NSWindowDocumentVersionsButton = 6,
  NSWindowFullScreenButton,
}

declare enum NSWindowTitleVisibility {
  NSWindowTitleVisible = 0,
  NSWindowTitleHidden = 1,
}

declare enum NSWindowUserTabbingPreference {
  NSWindowUserTabbingPreferenceManual,
  NSWindowUserTabbingPreferenceAlways,
  NSWindowUserTabbingPreferenceInFullScreen,
}

declare enum NSWindowTabbingMode {
  NSWindowTabbingModeAutomatic,
  NSWindowTabbingModePreferred,
  NSWindowTabbingModeDisallowed,
}

interface NSWindowControllerAllocator<InitializedType = NSWindowController> extends NSResponderAllocator<NSWindowController> {
  initWithWindow(window: NSWindow | null): InitializedType;
  initWithWindowNibName(windowNibName: NSNibName): InitializedType;
  initWithWindowNibName_owner(windowNibName: NSNibName, owner: any): InitializedType;
  initWithWindowNibPath_owner(windowNibPath: NSString | string, owner: any): InitializedType;
}
interface NSWindowController extends NSResponder, INSSeguePerforming {
  setDocumentEdited(dirtyFlag: boolean): void;
  synchronizeWindowTitleWithDocumentName(): void;
  windowTitleForDocumentDisplayName(displayName: NSString | string): NSString;
  windowWillLoad(): void;
  windowDidLoad(): void;
  loadWindow(): void;
  close(): void;
  showWindow(sender: any | null): IBAction;
  dismissController(sender: any | null): IBAction;

  windowNibName(): NSNibName;
  windowNibPath(): NSString;
  owner(): any;
  windowFrameAutosaveName(): NSWindowFrameAutosaveName;
  setWindowFrameAutosaveName(windowFrameAutosaveName: NSWindowFrameAutosaveName): void;
  shouldCascadeWindows(): boolean;
  setShouldCascadeWindows(shouldCascadeWindows: boolean): void;
  document(): any;
  setDocument(document: any): void;
  shouldCloseDocument(): boolean;
  setShouldCloseDocument(shouldCloseDocument: boolean): void;
  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  window(): NSWindow;
  setWindow(window: NSWindow): void;
  windowLoaded(): boolean;
  storyboard(): NSStoryboard;
}
declare const NSWindowController: {
  alloc(): NSWindowControllerAllocator;
}

interface INSWindowRestoration {
}

interface NSWindowTabAllocator<InitializedType = NSWindowTab> extends NSObjectAllocator<NSWindowTab> {}
interface NSWindowTab extends NSObject {

  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
}
declare const NSWindowTab: {
  alloc(): NSWindowTabAllocator;
}

interface NSWindowTabGroupAllocator<InitializedType = NSWindowTabGroup> extends NSObjectAllocator<NSWindowTabGroup> {}
interface NSWindowTabGroup extends NSObject {
  addWindow(window: NSWindow): void;
  insertWindow_atIndex(window: NSWindow, index: NSInteger): void;
  removeWindow(window: NSWindow): void;

  identifier(): NSWindowTabbingIdentifier;
  windows(): NSArray<any>;
  overviewVisible(): boolean;
  setOverviewVisible(overviewVisible: boolean): void;
  tabBarVisible(): boolean;
  selectedWindow(): NSWindow;
  setSelectedWindow(selectedWindow: NSWindow): void;
}
declare const NSWindowTabGroup: {
  alloc(): NSWindowTabGroupAllocator;
}

declare type NSWorkspaceLaunchConfigurationKey = NSString

declare type NSWorkspaceDesktopImageOptionKey = NSString

declare type NSWorkspaceFileOperationName = NSString

declare enum NSWorkspaceLaunchOptions {
  NSWorkspaceLaunchAndPrint = 0x00000002,
  NSWorkspaceLaunchWithErrorPresentation = 0x00000040,
  NSWorkspaceLaunchInhibitingBackgroundOnly = 0x00000080,
  NSWorkspaceLaunchWithoutAddingToRecents = 0x00000100,
  NSWorkspaceLaunchWithoutActivation = 0x00000200,
  NSWorkspaceLaunchAsync = 0x00010000,
  NSWorkspaceLaunchNewInstance = 0x00080000,
  NSWorkspaceLaunchAndHide = 0x00100000,
  NSWorkspaceLaunchAndHideOthers = 0x00200000,
  NSWorkspaceLaunchDefault,
  NSWorkspaceLaunchAllowingClassicStartup = 0x00020000,
  NSWorkspaceLaunchPreferringClassic = 0x00040000,
}

declare enum NSWorkspaceIconCreationOptions {
  NSExcludeQuickDrawElementsIconCreationOption = 1 << 1,
  NSExclude10_4ElementsIconCreationOption = 1 << 2,
}

interface AFHTTPRequestOperationAllocator<InitializedType = AFHTTPRequestOperation> extends AFURLConnectionOperationAllocator<AFHTTPRequestOperation> {}
interface AFHTTPRequestOperation extends AFURLConnectionOperation {
  setCompletionBlockWithSuccess_failure(success: Block | null, failure: Block | null): void;

  response(): NSHTTPURLResponse;
  responseSerializer(): AFHTTPResponseSerializer;
  setResponseSerializer(responseSerializer: AFHTTPResponseSerializer): void;
  responseObject(): any;
}
declare const AFHTTPRequestOperation: {
  alloc(): AFHTTPRequestOperationAllocator;
}

interface AFHTTPRequestOperationManagerAllocator<InitializedType = AFHTTPRequestOperationManager> extends NSObjectAllocator<AFHTTPRequestOperationManager> {
  initWithBaseURL(url: NSURL | null): InitializedType;
}
interface AFHTTPRequestOperationManager extends NSObject, INSSecureCoding, INSCopying {
  HTTPRequestOperationWithRequest_success_failure(request: NSURLRequest, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  GET_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  HEAD_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  POST_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  POST_parameters_constructingBodyWithBlock_success_failure(URLString: NSString | string, parameters: any | null, block: Block | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  PUT_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  PATCH_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  DELETE_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;

  baseURL(): NSURL;
  requestSerializer(): AFHTTPRequestSerializer;
  setRequestSerializer(requestSerializer: AFHTTPRequestSerializer): void;
  responseSerializer(): AFHTTPResponseSerializer;
  setResponseSerializer(responseSerializer: AFHTTPResponseSerializer): void;
  operationQueue(): NSOperationQueue;
  setOperationQueue(operationQueue: NSOperationQueue): void;
  shouldUseCredentialStorage(): boolean;
  setShouldUseCredentialStorage(shouldUseCredentialStorage: boolean): void;
  credential(): NSURLCredential;
  setCredential(credential: NSURLCredential): void;
  securityPolicy(): AFSecurityPolicy;
  setSecurityPolicy(securityPolicy: AFSecurityPolicy): void;
  reachabilityManager(): AFNetworkReachabilityManager;
  setReachabilityManager(reachabilityManager: AFNetworkReachabilityManager): void;
  completionQueue(): dispatch_queue_t;
  setCompletionQueue(completionQueue: dispatch_queue_t): void;
  completionGroup(): dispatch_group_t;
  setCompletionGroup(completionGroup: dispatch_group_t): void;
}
declare const AFHTTPRequestOperationManager: {
  alloc(): AFHTTPRequestOperationManagerAllocator;  manager(): AFHTTPRequestOperationManager;

}

interface AFHTTPSessionManagerAllocator<InitializedType = AFHTTPSessionManager> extends AFURLSessionManagerAllocator<AFHTTPSessionManager> {
  initWithBaseURL(url: NSURL | null): InitializedType;
  initWithBaseURL_sessionConfiguration(url: NSURL | null, configuration: NSURLSessionConfiguration | null): InitializedType;
}
interface AFHTTPSessionManager extends AFURLSessionManager, INSSecureCoding, INSCopying {
  GET_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  HEAD_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  POST_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  POST_parameters_constructingBodyWithBlock_success_failure(URLString: NSString | string, parameters: any | null, block: Block | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  PUT_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  PATCH_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  DELETE_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;

  baseURL(): NSURL;
  requestSerializer(): AFHTTPRequestSerializer;
  setRequestSerializer(requestSerializer: AFHTTPRequestSerializer): void;
  responseSerializer(): AFHTTPResponseSerializer;
  setResponseSerializer(responseSerializer: AFHTTPResponseSerializer): void;
}
declare const AFHTTPSessionManager: {
  alloc(): AFHTTPSessionManagerAllocator;  manager(): AFHTTPSessionManager;

}

interface AFNetworkReachabilityManagerAllocator<InitializedType = AFNetworkReachabilityManager> extends NSObjectAllocator<AFNetworkReachabilityManager> {
  initWithReachability(reachability: SCNetworkReachabilityRef): InitializedType;
}
interface AFNetworkReachabilityManager extends NSObject {
  startMonitoring(): void;
  stopMonitoring(): void;
  localizedNetworkReachabilityStatusString(): NSString;
  setReachabilityStatusChangeBlock(block: Block | null): void;

  networkReachabilityStatus(): AFNetworkReachabilityStatus;
  reachable(): boolean;
  reachableViaWWAN(): boolean;
  reachableViaWiFi(): boolean;
}
declare const AFNetworkReachabilityManager: {
  alloc(): AFNetworkReachabilityManagerAllocator;  sharedManager(): AFNetworkReachabilityManager;
  managerForDomain(domain: NSString | string): AFNetworkReachabilityManager;
  managerForAddress(address: void): AFNetworkReachabilityManager;

}

declare enum AFNetworkReachabilityStatus {
  AFNetworkReachabilityStatusUnknown = -1,
  AFNetworkReachabilityStatusNotReachable = 0,
  AFNetworkReachabilityStatusReachableViaWWAN = 1,
  AFNetworkReachabilityStatusReachableViaWiFi = 2,
}

interface AFSecurityPolicyAllocator<InitializedType = AFSecurityPolicy> extends NSObjectAllocator<AFSecurityPolicy> {}
interface AFSecurityPolicy extends NSObject, INSSecureCoding, INSCopying {
  evaluateServerTrust_DEPRECATED_ATTRIBUTE(serverTrust: SecTrustRef): boolean;
  evaluateServerTrust_forDomain(serverTrust: SecTrustRef, domain: NSString | string | null): boolean;

  SSLPinningMode(): AFSSLPinningMode;
  pinnedCertificates(): NSArray<any>;
  setPinnedCertificates(pinnedCertificates: NSArray<any> | any[]): void;
  allowInvalidCertificates(): boolean;
  setAllowInvalidCertificates(allowInvalidCertificates: boolean): void;
  validatesDomainName(): boolean;
  setValidatesDomainName(validatesDomainName: boolean): void;
}
declare const AFSecurityPolicy: {
  alloc(): AFSecurityPolicyAllocator;  defaultPolicy(): AFSecurityPolicy;
  policyWithPinningMode(pinningMode: AFSSLPinningMode): AFSecurityPolicy;

}

declare enum AFSSLPinningMode {
  AFSSLPinningModeNone,
  AFSSLPinningModePublicKey,
  AFSSLPinningModeCertificate,
}

interface AFURLConnectionOperationAllocator<InitializedType = AFURLConnectionOperation> extends NSOperationAllocator<AFURLConnectionOperation> {
  initWithRequest(urlRequest: NSURLRequest): InitializedType;
}
interface AFURLConnectionOperation extends NSOperation, INSURLConnectionDelegate, INSURLConnectionDataDelegate, INSSecureCoding, INSCopying {
  pause(): void;
  isPaused(): boolean;
  resume(): void;
  setShouldExecuteAsBackgroundTaskWithExpirationHandler(handler: Block | null): void;
  setUploadProgressBlock(block: Block | null): void;
  setDownloadProgressBlock(block: Block | null): void;
  setWillSendRequestForAuthenticationChallengeBlock(block: Block | null): void;
  setRedirectResponseBlock(block: Block | null): void;
  setCacheResponseBlock(block: Block | null): void;

  runLoopModes(): NSSet<any>;
  setRunLoopModes(runLoopModes: NSSet<any>): void;
  request(): NSURLRequest;
  response(): NSURLResponse;
  error(): NSError;
  responseData(): NSData;
  responseString(): NSString;
  responseStringEncoding(): NSStringEncoding;
  shouldUseCredentialStorage(): boolean;
  setShouldUseCredentialStorage(shouldUseCredentialStorage: boolean): void;
  credential(): NSURLCredential;
  setCredential(credential: NSURLCredential): void;
  securityPolicy(): AFSecurityPolicy;
  setSecurityPolicy(securityPolicy: AFSecurityPolicy): void;
  inputStream(): NSInputStream;
  setInputStream(inputStream: NSInputStream): void;
  outputStream(): NSOutputStream;
  setOutputStream(outputStream: NSOutputStream): void;
  completionQueue(): dispatch_queue_t;
  setCompletionQueue(completionQueue: dispatch_queue_t): void;
  completionGroup(): dispatch_group_t;
  setCompletionGroup(completionGroup: dispatch_group_t): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const AFURLConnectionOperation: {
  alloc(): AFURLConnectionOperationAllocator;  batchOfRequestOperations_progressBlock_completionBlock(operations: NSArray<any> | any[] | null, progressBlock: Block | null, completionBlock: Block | null): NSArray<any>;

}

interface AFHTTPRequestSerializerAllocator<InitializedType = AFHTTPRequestSerializer> extends NSObjectAllocator<AFHTTPRequestSerializer> {}
interface AFHTTPRequestSerializer extends NSObject, IAFURLRequestSerialization {
  setValue_forHTTPHeaderField(value: NSString | string | null, field: NSString | string): void;
  valueForHTTPHeaderField(field: NSString | string): NSString;
  setAuthorizationHeaderFieldWithUsername_password(username: NSString | string, password: NSString | string): void;
  setAuthorizationHeaderFieldWithToken_DEPRECATED_ATTRIBUTE(token: NSString | string): void;
  clearAuthorizationHeader(): void;
  setQueryStringSerializationWithStyle(style: AFHTTPRequestQueryStringSerializationStyle): void;
  setQueryStringSerializationWithBlock(block: Block | null): void;
  requestWithMethod_URLString_parameters_DEPRECATED_ATTRIBUTE(method: NSString | string, URLString: NSString | string, parameters: any): NSMutableURLRequest;
  requestWithMethod_URLString_parameters_error(method: NSString | string, URLString: NSString | string, parameters: any | null, error: NSError): NSMutableURLRequest;
  multipartFormRequestWithMethod_URLString_parameters_constructingBodyWithBlock_DEPRECATED_ATTRIBUTE(method: NSString | string, URLString: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, block: Block): NSMutableURLRequest;
  multipartFormRequestWithMethod_URLString_parameters_constructingBodyWithBlock_error(method: NSString | string, URLString: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any} | null, block: Block | null, error: NSError): NSMutableURLRequest;
  requestWithMultipartFormRequest_writingStreamContentsToFile_completionHandler(request: NSURLRequest, fileURL: NSURL, handler: Block | null): NSMutableURLRequest;

  stringEncoding(): NSStringEncoding;
  setStringEncoding(stringEncoding: NSStringEncoding): void;
  allowsCellularAccess(): boolean;
  setAllowsCellularAccess(allowsCellularAccess: boolean): void;
  cachePolicy(): NSURLRequestCachePolicy;
  setCachePolicy(cachePolicy: NSURLRequestCachePolicy): void;
  HTTPShouldHandleCookies(): boolean;
  setHTTPShouldHandleCookies(HTTPShouldHandleCookies: boolean): void;
  HTTPShouldUsePipelining(): boolean;
  setHTTPShouldUsePipelining(HTTPShouldUsePipelining: boolean): void;
  networkServiceType(): NSURLRequestNetworkServiceType;
  setNetworkServiceType(networkServiceType: NSURLRequestNetworkServiceType): void;
  timeoutInterval(): NSTimeInterval;
  setTimeoutInterval(timeoutInterval: NSTimeInterval): void;
  HTTPRequestHeaders(): NSDictionary<any, any>;
  HTTPMethodsEncodingParametersInURI(): NSSet<any>;
  setHTTPMethodsEncodingParametersInURI(HTTPMethodsEncodingParametersInURI: NSSet<any>): void;
}
declare const AFHTTPRequestSerializer: {
  alloc(): AFHTTPRequestSerializerAllocator;  serializer(): AFHTTPRequestSerializer;

}

interface AFJSONRequestSerializerAllocator<InitializedType = AFJSONRequestSerializer> extends AFHTTPRequestSerializerAllocator<AFJSONRequestSerializer> {}
interface AFJSONRequestSerializer extends AFHTTPRequestSerializer {

  writingOptions(): NSJSONWritingOptions;
  setWritingOptions(writingOptions: NSJSONWritingOptions): void;
}
declare const AFJSONRequestSerializer: {
  alloc(): AFJSONRequestSerializerAllocator;  serializerWithWritingOptions(writingOptions: NSJSONWritingOptions): AFJSONRequestSerializer;

}

interface AFPropertyListRequestSerializerAllocator<InitializedType = AFPropertyListRequestSerializer> extends AFHTTPRequestSerializerAllocator<AFPropertyListRequestSerializer> {}
interface AFPropertyListRequestSerializer extends AFHTTPRequestSerializer {

  format(): NSPropertyListFormat;
  setFormat(format: NSPropertyListFormat): void;
  writeOptions(): NSPropertyListWriteOptions;
  setWriteOptions(writeOptions: NSPropertyListWriteOptions): void;
}
declare const AFPropertyListRequestSerializer: {
  alloc(): AFPropertyListRequestSerializerAllocator;  serializerWithFormat_writeOptions(format: NSPropertyListFormat, writeOptions: NSPropertyListWriteOptions): AFPropertyListRequestSerializer;

}

interface IAFURLRequestSerialization {
  requestBySerializingRequest_withParameters_error(request: NSURLRequest, parameters: any | null, error: NSError): NSURLRequest;
}

interface IAFMultipartFormData {
  appendPartWithFileURL_name_error(fileURL: NSURL, name: NSString | string, error: NSError): boolean;
  appendPartWithFileURL_name_fileName_mimeType_error(fileURL: NSURL, name: NSString | string, fileName: NSString | string, mimeType: NSString | string, error: NSError): boolean;
  appendPartWithInputStream_name_fileName_length_mimeType(inputStream: NSInputStream | null, name: NSString | string, fileName: NSString | string, length: number, mimeType: NSString | string): void;
  appendPartWithFileData_name_fileName_mimeType(data: NSData, name: NSString | string, fileName: NSString | string, mimeType: NSString | string): void;
  appendPartWithFormData_name(data: NSData, name: NSString | string): void;
  appendPartWithHeaders_body(headers: NSDictionary<any, any> | {[key: string]: any} | null, body: NSData): void;
  throttleBandwidthWithPacketSize_delay(numberOfBytes: NSUInteger, delay: NSTimeInterval): void;
}

declare enum AFHTTPRequestQueryStringSerializationStyle {
  AFHTTPRequestQueryStringDefaultStyle = 0,
}

interface AFHTTPResponseSerializerAllocator<InitializedType = AFHTTPResponseSerializer> extends NSObjectAllocator<AFHTTPResponseSerializer> {
  init(): InitializedType;
}
interface AFHTTPResponseSerializer extends NSObject, IAFURLResponseSerialization {
  validateResponse_data_error(response: NSHTTPURLResponse | null, data: NSData | null, error: NSError): boolean;

  stringEncoding(): NSStringEncoding;
  setStringEncoding(stringEncoding: NSStringEncoding): void;
  acceptableStatusCodes(): NSIndexSet;
  setAcceptableStatusCodes(acceptableStatusCodes: NSIndexSet): void;
  acceptableContentTypes(): NSSet<any>;
  setAcceptableContentTypes(acceptableContentTypes: NSSet<any>): void;
}
declare const AFHTTPResponseSerializer: {
  alloc(): AFHTTPResponseSerializerAllocator;  serializer(): AFHTTPResponseSerializer;

}

interface AFJSONResponseSerializerAllocator<InitializedType = AFJSONResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFJSONResponseSerializer> {}
interface AFJSONResponseSerializer extends AFHTTPResponseSerializer {

  readingOptions(): NSJSONReadingOptions;
  setReadingOptions(readingOptions: NSJSONReadingOptions): void;
  removesKeysWithNullValues(): boolean;
  setRemovesKeysWithNullValues(removesKeysWithNullValues: boolean): void;
}
declare const AFJSONResponseSerializer: {
  alloc(): AFJSONResponseSerializerAllocator;  serializerWithReadingOptions(readingOptions: NSJSONReadingOptions): AFJSONResponseSerializer;

}

interface AFXMLParserResponseSerializerAllocator<InitializedType = AFXMLParserResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFXMLParserResponseSerializer> {}
interface AFXMLParserResponseSerializer extends AFHTTPResponseSerializer {
}
declare const AFXMLParserResponseSerializer: {
  alloc(): AFXMLParserResponseSerializerAllocator;
}

interface AFXMLDocumentResponseSerializerAllocator<InitializedType = AFXMLDocumentResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFXMLDocumentResponseSerializer> {}
interface AFXMLDocumentResponseSerializer extends AFHTTPResponseSerializer {

  options(): NSUInteger;
  setOptions(options: NSUInteger): void;
}
declare const AFXMLDocumentResponseSerializer: {
  alloc(): AFXMLDocumentResponseSerializerAllocator;  serializerWithXMLDocumentOptions(mask: NSUInteger): AFXMLDocumentResponseSerializer;

}

interface AFPropertyListResponseSerializerAllocator<InitializedType = AFPropertyListResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFPropertyListResponseSerializer> {}
interface AFPropertyListResponseSerializer extends AFHTTPResponseSerializer {

  format(): NSPropertyListFormat;
  setFormat(format: NSPropertyListFormat): void;
  readOptions(): NSPropertyListReadOptions;
  setReadOptions(readOptions: NSPropertyListReadOptions): void;
}
declare const AFPropertyListResponseSerializer: {
  alloc(): AFPropertyListResponseSerializerAllocator;  serializerWithFormat_readOptions(format: NSPropertyListFormat, readOptions: NSPropertyListReadOptions): AFPropertyListResponseSerializer;

}

interface AFImageResponseSerializerAllocator<InitializedType = AFImageResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFImageResponseSerializer> {}
interface AFImageResponseSerializer extends AFHTTPResponseSerializer {

  imageScale(): CGFloat;
  setImageScale(imageScale: CGFloat): void;
  automaticallyInflatesResponseImage(): boolean;
  setAutomaticallyInflatesResponseImage(automaticallyInflatesResponseImage: boolean): void;
}
declare const AFImageResponseSerializer: {
  alloc(): AFImageResponseSerializerAllocator;
}

interface AFCompoundResponseSerializerAllocator<InitializedType = AFCompoundResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFCompoundResponseSerializer> {}
interface AFCompoundResponseSerializer extends AFHTTPResponseSerializer {

  responseSerializers(): NSArray<any>;
}
declare const AFCompoundResponseSerializer: {
  alloc(): AFCompoundResponseSerializerAllocator;  compoundSerializerWithResponseSerializers(responseSerializers: NSArray<any> | any[]): AFCompoundResponseSerializer;

}

interface IAFURLResponseSerialization {
  responseObjectForResponse_data_error(response: NSURLResponse | null, data: NSData | null, error: NSError): any;
}

interface AFURLSessionManagerAllocator<InitializedType = AFURLSessionManager> extends NSObjectAllocator<AFURLSessionManager> {
  initWithSessionConfiguration(configuration: NSURLSessionConfiguration | null): InitializedType;
}
interface AFURLSessionManager extends NSObject, INSURLSessionDelegate, INSURLSessionTaskDelegate, INSURLSessionDataDelegate, INSURLSessionDownloadDelegate, INSSecureCoding, INSCopying {
  invalidateSessionCancelingTasks(cancelPendingTasks: boolean): void;
  dataTaskWithRequest_completionHandler(request: NSURLRequest, completionHandler: Block | null): NSURLSessionDataTask;
  uploadTaskWithRequest_fromFile_progress_completionHandler(request: NSURLRequest, fileURL: NSURL, progress: NSProgress, completionHandler: Block | null): NSURLSessionUploadTask;
  uploadTaskWithRequest_fromData_progress_completionHandler(request: NSURLRequest, bodyData: NSData | null, progress: NSProgress, completionHandler: Block | null): NSURLSessionUploadTask;
  uploadTaskWithStreamedRequest_progress_completionHandler(request: NSURLRequest, progress: NSProgress, completionHandler: Block | null): NSURLSessionUploadTask;
  downloadTaskWithRequest_progress_destination_completionHandler(request: NSURLRequest, progress: NSProgress, destination: Block | null, completionHandler: Block | null): NSURLSessionDownloadTask;
  downloadTaskWithResumeData_progress_destination_completionHandler(resumeData: NSData, progress: NSProgress, destination: Block | null, completionHandler: Block | null): NSURLSessionDownloadTask;
  uploadProgressForTask(uploadTask: NSURLSessionUploadTask): NSProgress;
  downloadProgressForTask(downloadTask: NSURLSessionDownloadTask): NSProgress;
  setSessionDidBecomeInvalidBlock(block: Block | null): void;
  setSessionDidReceiveAuthenticationChallengeBlock(block: Block | null): void;
  setTaskNeedNewBodyStreamBlock(block: Block | null): void;
  setTaskWillPerformHTTPRedirectionBlock(block: Block | null): void;
  setTaskDidReceiveAuthenticationChallengeBlock(block: Block | null): void;
  setTaskDidSendBodyDataBlock(block: Block | null): void;
  setTaskDidCompleteBlock(block: Block | null): void;
  setDataTaskDidReceiveResponseBlock(block: Block | null): void;
  setDataTaskDidBecomeDownloadTaskBlock(block: Block | null): void;
  setDataTaskDidReceiveDataBlock(block: Block | null): void;
  setDataTaskWillCacheResponseBlock(block: Block | null): void;
  setDidFinishEventsForBackgroundURLSessionBlock(block: Block | null): void;
  setDownloadTaskDidFinishDownloadingBlock(block: Block | null): void;
  setDownloadTaskDidWriteDataBlock(block: Block | null): void;
  setDownloadTaskDidResumeBlock(block: Block | null): void;

  session(): NSURLSession;
  operationQueue(): NSOperationQueue;
  responseSerializer(): any;
  setResponseSerializer(responseSerializer: any): void;
  securityPolicy(): AFSecurityPolicy;
  setSecurityPolicy(securityPolicy: AFSecurityPolicy): void;
  reachabilityManager(): AFNetworkReachabilityManager;
  setReachabilityManager(reachabilityManager: AFNetworkReachabilityManager): void;
  tasks(): NSArray<any>;
  dataTasks(): NSArray<any>;
  uploadTasks(): NSArray<any>;
  downloadTasks(): NSArray<any>;
  completionQueue(): dispatch_queue_t;
  setCompletionQueue(completionQueue: dispatch_queue_t): void;
  completionGroup(): dispatch_group_t;
  setCompletionGroup(completionGroup: dispatch_group_t): void;
  attemptsToRecreateUploadTasksForBackgroundSessions(): boolean;
  setAttemptsToRecreateUploadTasksForBackgroundSessions(attemptsToRecreateUploadTasksForBackgroundSessions: boolean): void;
}
declare const AFURLSessionManager: {
  alloc(): AFURLSessionManagerAllocator;
}

interface ExtensionDelegateAllocator<InitializedType = ExtensionDelegate> extends NSObjectAllocator<ExtensionDelegate> {}
interface ExtensionDelegate extends NSObject, IWKExtensionDelegate {
}
declare const ExtensionDelegate: {
  alloc(): ExtensionDelegateAllocator;
}

interface AFAppDotNetAPIClientAllocator<InitializedType = AFAppDotNetAPIClient> extends AFHTTPSessionManagerAllocator<AFAppDotNetAPIClient> {}
interface AFAppDotNetAPIClient extends AFHTTPSessionManager {
}
declare const AFAppDotNetAPIClient: {
  alloc(): AFAppDotNetAPIClientAllocator;  sharedClient(): AFAppDotNetAPIClient;

}

interface PostAllocator<InitializedType = Post> extends NSObjectAllocator<Post> {
  initWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface Post extends NSObject {

  postID(): NSUInteger;
  setPostID(postID: NSUInteger): void;
  text(): NSString;
  setText(text: NSString | string): void;
  user(): User;
  setUser(user: User): void;
}
declare const Post: {
  alloc(): PostAllocator;  globalTimelinePostsWithBlock(block: Block): NSURLSessionDataTask;

}

interface UserAllocator<InitializedType = User> extends NSObjectAllocator<User> {
  initWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface User extends NSObject {

  userID(): NSUInteger;
  username(): NSString;
  avatarImageURL(): NSURL;
  profileImage(): NSImage;
  setProfileImage(profileImage: NSImage): void;
}
declare const User: {
  alloc(): UserAllocator;
}

interface AFNetworkActivityIndicatorManagerAllocator<InitializedType = AFNetworkActivityIndicatorManager> extends NSObjectAllocator<AFNetworkActivityIndicatorManager> {}
interface AFNetworkActivityIndicatorManager extends NSObject {
  incrementActivityCount(): void;
  decrementActivityCount(): void;

  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  isNetworkActivityIndicatorVisible(): boolean;
}
declare const AFNetworkActivityIndicatorManager: {
  alloc(): AFNetworkActivityIndicatorManagerAllocator;  sharedManager(): AFNetworkActivityIndicatorManager;

}

interface BCAssertionAllocator<InitializedType = BCAssertion> extends NSObjectAllocator<BCAssertion> {}
interface BCAssertion extends NSObject {
}
declare const BCAssertion: {
  alloc(): BCAssertionAllocator;  assertObject_isOfClass(object: any, c: any): any;

}

declare enum BCAttributeMatchResult {
  BCAttributeMatchResultMixed = -1,
  BCAttributeMatchResultNone = 0,
  BCAttributeMatchResultMatched = 1,
}

interface MSRangeAllocator<InitializedType = MSRange> extends NSObjectAllocator<MSRange> {}
interface MSRange extends NSObject {
}
declare const MSRange: {
  alloc(): MSRangeAllocator;  from_to_do(fromIndex: NSUInteger, toIndex: NSUInteger, block: Block): void;

}

interface BCCacheAllocator<InitializedType = BCCache> extends NSObjectAllocator<BCCache> {}
interface BCCache extends NSObject {
  cachedObjectForOwner_andKey(owner: any, key: any): any;
  setCachedObject_forOwner_andKey(obj: any, owner: any, key: any): void;
  cachedObjectForOwner_andKey_orCreateWithBlock(owner: any, key: any, block: BCCacheCreateObjectBlock): any;
  removeCachedObjectForOwner_andKey(owner: any, key: any): void;
  removeCachedObjectsForOwner(owner: any): void;
  removeCachedObjectsExceptForOwners(ownersToKeep: NSSet<any>): void;
  removeAllCachedObjects(): void;

  count(): NSUInteger;
  allOwners(): NSSet<any>;
}
declare const BCCache: {
  alloc(): BCCacheAllocator;
}

declare enum BCConstraint {
  BCConstraintNone = 0,
  BCConstraintMaxXSizeable = 1 << 0,
  BCConstraintWidthSizeable = 1 << 1,
  BCConstraintMinXSizeable = 1 << 2,
  BCConstraintMaxYSizeable = 1 << 3,
  BCConstraintHeightSizeable = 1 << 4,
  BCConstraintMinYSizeable = 1 << 5,
  BCConstraintAllFixed = 1 << 6,
  BCConstraintAllSizeable,
}

declare enum BCCorner {
  BCCornerNone = -1,
  BCCornerTopLeft = 0,
  BCCornerTopRight = 1,
  BCCornerBottomLeft = 2,
  BCCornerBottomRight = 3,
  BCCornerMidTop = 4,
  BCCornerMidLeft = 5,
  BCCornerMidRight = 6,
  BCCornerMidBottom = 7,
  BCCornerMid = 8,
  BCCornerMinimum,
  BCCornerMaximum,
}

interface BCDownloadManagerAllocator<InitializedType = BCDownloadManager> {
  initWithSessionConfiguration_delegate_completionHandler(sessionConfiguration: NSURLSessionConfiguration, delegate: any | null, completionHandler: Block | null): InitializedType;
}
interface BCDownloadManager {
  addDownloadTaskWithDownloadRequestURL(downloadRequestURL: NSURL): NSString;
  addDownloadTaskWithDownloadRequest(downloadRequest: NSURLRequest): NSString;
  addDownloadTaskWithDownloadRequest_completionHandler(request: NSURLRequest, completionHandler: Block): NSString;
  removeDownloadTaskWithIdentifier(identifier: NSString | string): boolean;
  resumeDownloadTaskWithIdentifier(identifier: NSString | string): void;
  suspendDownloadTaskWithIdentifier(identifier: NSString | string): void;
  cancelAllTasksAndInvalidate(): void;
  finishTasksAndInvalidate(): void;
  downloadTaskCurrentStateWithIdentifier(identifier: NSString | string): NSDictionary<any, any>;
  cancelTaskWithIdentifier(identifier: NSString | string): void;

  identifier(): NSString;
  hasBeenInvalidated(): boolean;
  canAcceptNewDownloadTasks(): boolean;
  numberOfUnfinishedDownloadTasks(): NSInteger;
  allTasksIdentifiers(): NSArray<any>;
}
declare const BCDownloadManager: {
  alloc(): BCDownloadManagerAllocator;
}

interface IBCDownloadManagerDelegate {
  downloadManager_downloadTaskHasUpdatedForIdentifier_downloadedSoFar_withDownloadSize(downloadManager: BCDownloadManager, identifier: NSString | string, downloadedSoFar: NSUInteger, downloadSize: NSUInteger): void;
  downloadManager_downloadTaskFinishedForIdentifier_downloadedURL_httpStatusCode(downloadManager: BCDownloadManager, identifier: NSString | string, downloadedURL: NSURL, statusCode: NSInteger): void;
  downloadManager_downloadTaskWithIdentifier_failedWithError(downloadManager: BCDownloadManager, identifier: NSString | string, error: NSError): void;
  downloadManager_sessionBecameInvalidWithError(downloadManager: BCDownloadManager, error: NSError | null): void;
}

declare type BCFloatRange = {
  location: CGFloat
  length: CGFloat
}

declare type BCEdgePaddings = {
  maxYEdge: CGFloat
  minXEdge: CGFloat
  minYEdge: CGFloat
  maxXEdge: CGFloat
}

declare enum BCAxis {
  BCAxisNone = 0,
  BCAxisX = 1 << 0,
  BCAxisY = 1 << 1,
  BCAxisBoth,
}

declare enum BCEdge {
  BCEdgeLeft = 1<<0,
  BCEdgeRight = 1<<1,
  BCEdgeTop = 1<<2,
  BCEdgeBottom = 1<<3,
  BCEdgeMidX = 1<<4,
  BCEdgeMidY = 1<<5,
  BCEdgeAll,
  BCEdgeVertical,
  BCEdgeHorizontal,
}

declare type BCIntPoint = {
  x: number
  y: number
}

declare type BCIntPointArray = {
  count: number
  points: [BCIntPoint]
}

declare type BCIntRect = {
  x: number
  y: number
  width: number
  height: number
}

declare type BCIntRectArray = {
  count: number
  capacity: number
  rects: BCIntRect
}

interface BCJSONEncoderAllocator<InitializedType = BCJSONEncoder> extends NSObjectAllocator<BCJSONEncoder> {}
interface BCJSONEncoder extends NSObject {
  encodeRootObject_error(root: NSObject | null, error: NSError): boolean;
  encodeObject_forKey(object: NSObject | null, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeRect_forKey(rect: CGRect, key: NSString | string): void;
  encodePoint_forKey(point: CGPoint, key: NSString | string): void;
  encodeInteger_forKey(value: NSInteger, key: NSString | string): void;
  encodeSize_forKey(size: CGSize, key: NSString | string): void;

  userInfo(): any;
  setUserInfo(userInfo: any): void;
  error(): NSError;
  setError(error: NSError): void;
  archiver(): MSJSONArchiver;
  setArchiver(archiver: MSJSONArchiver): void;
}
declare const BCJSONEncoder: {
  alloc(): BCJSONEncoderAllocator;  encoderForWritingToMutableData(data: NSMutableData): BCJSONEncoder;
  encodeObjectAsData_error(root: NSObject, error: NSError): NSData;
  setAliasName_forClass(codedName: NSString | string | null, className: any): void;
  encoderForWritingToFile(file: NSFileHandle): BCJSONEncoder;
  encodeObject_toFile_error(root: NSObject, file: NSFileHandle, error: NSError): boolean;
  encoderForWritingToURL(url: NSURL): BCJSONEncoder;
  encodeObject_toURL_error(root: NSObject, url: NSURL, error: NSError): boolean;
  encodeObjectAsString_error(root: NSObject, error: NSError): NSString;

}

interface BCJSONDecoderAllocator<InitializedType = BCJSONDecoder> extends NSObjectAllocator<BCJSONDecoder> {}
interface BCJSONDecoder extends NSObject {
  decodeData_error(data: NSData, error: NSError): any;
  decodeDictionary_error(dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): any;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeDoubleForKey_withDefault(key: NSString | string, defaultValue: number): number;
  decodeBoolForKey_withDefault(key: NSString | string, defaultValue: boolean): boolean;
  decodeRectForKey_withDefault(key: NSString | string, defaultValue: CGRect): CGRect;
  decodePointForKey_withDefault(key: NSString | string, defaultValue: CGPoint): CGPoint;
  decodeIntegerForKey_withDefault(key: NSString | string, defaultValue: NSInteger): NSInteger;
  decodeSizeForKey_withDefault(key: NSString | string, defaultValue: CGSize): CGSize;

  userInfo(): any;
  setUserInfo(userInfo: any): void;
  error(): NSError;
  setError(error: NSError): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  unarchiver(): MSJSONUnarchiver;
  setUnarchiver(unarchiver: MSJSONUnarchiver): void;
}
declare const BCJSONDecoder: {
  alloc(): BCJSONDecoderAllocator;  setClass_forClassName(className: any | null, codedName: NSString | string): void;
  decodeFileAtURL_error(url: NSURL, error: NSError): any;

}

interface IBCJSONDecoderDelegate {
  decoder_shouldInstantiateObjectOfClass(decoder: BCJSONDecoder, aClass: any): boolean;
}

interface IBCJSONEncoding {
  encodeAsJSON(coder: BCJSONEncoder): void;
  replacementObjectForJSONEncoder(coder: BCJSONEncoder): NSObject;
}

declare type BCOrthogonalLine = {
  position: CGFloat
  axis: BCAxis
}

interface BCNetworkManagerAllocator<InitializedType = BCNetworkManager> extends NSObjectAllocator<BCNetworkManager> {}
interface BCNetworkManager extends NSObject {
}
declare const BCNetworkManager: {
  alloc(): BCNetworkManagerAllocator;  sendSynchronousRequest_returningResponse_error(request: NSURLRequest, response: NSURLResponse, error: NSError): NSData;

}

interface BCObjectPoolAllocator<InitializedType = BCObjectPool> extends NSObjectAllocator<BCObjectPool> {
  initWithObjectCreatorBlock(block: any): InitializedType;
}
interface BCObjectPool extends NSObject {
  vendObject(): any;
  recycleObject(object: any): void;

  maximumPoolCount(): NSUInteger;
  setMaximumPoolCount(maximumPoolCount: NSUInteger): void;
}
declare const BCObjectPool: {
  alloc(): BCObjectPoolAllocator;
}

interface BCObjectSortingAllocator<InitializedType = BCObjectSorting> extends NSObjectAllocator<BCObjectSorting> {}
interface BCObjectSorting extends NSObject {
}
declare const BCObjectSorting: {
  alloc(): BCObjectSortingAllocator;  sortObjectsAlphabetically(sortableObjects: NSArray<any> | any[]): NSArray<any>;
  sortObjectsWithNesting(sortableObjects: NSArray<any> | any[]): NSArray<any>;
  sortObjectsWithCompressedNesting(sortableObjects: NSArray<any> | any[]): NSArray<any>;

}

interface IBCSortable {

  name(): NSString;
}

interface BCPerformanceTimerAllocator<InitializedType = BCPerformanceTimer> extends NSObjectAllocator<BCPerformanceTimer> {}
interface BCPerformanceTimer extends NSObject {
}
declare const BCPerformanceTimer: {
  alloc(): BCPerformanceTimerAllocator;
}

declare type BCTime = number

declare type BCDuration = number

interface BCRangeMapAllocator<InitializedType = BCRangeMap> extends NSObjectAllocator<BCRangeMap> {}
interface BCRangeMap extends NSObject {
  allRanges(): NSSet<any>;
  allObjects(): NSSet<any>;
  objectForLocation(index: NSUInteger): any;
  rangeForLocation(index: NSUInteger): NSRange;
  setObject_forRange(object: any, range: NSRange): void;
  removeObjectsAtOrBeyondLocation(index: NSUInteger): void;
}
declare const BCRangeMap: {
  alloc(): BCRangeMapAllocator;
}

interface BCReadWriteLockAllocator<InitializedType = BCReadWriteLock> extends NSObjectAllocator<BCReadWriteLock> {}
interface BCReadWriteLock extends NSObject {
  protectedRead(block: BCVoidBlock): void;
  protectedWrite(block: BCVoidBlock): void;
}
declare const BCReadWriteLock: {
  alloc(): BCReadWriteLockAllocator;
}

interface BCRectAllocator<InitializedType = BCRect> extends NSObjectAllocator<BCRect> {
  initWithRect(aRect: CGRect): InitializedType;
}
interface BCRect extends NSObject, INSCopying, IBCRect {

  rect(): CGRect;
  setRect(rect: CGRect): void;
  size(): CGSize;
  setSize(size: CGSize): void;
}
declare const BCRect: {
  alloc(): BCRectAllocator;  rectWithRect(aRect: CGRect): BCRect;

}

interface IBCRect {

  rect(): CGRect;
  setRect(rect: CGRect): void;
  origin(): CGPoint;
  setOrigin(origin: CGPoint): void;
  size(): CGSize;
  setSize(size: CGSize): void;
}

declare enum BCRectComparison {
  BCRectComparisonLeftToRightTopToBottom = 0,
  BCRectComparisonRightToLeftTopToBottom,
  BCRectComparisonTopToBottomLeftToRight,
  BCRectComparisonTopToBottomRightToLeft,
  BCRectComparisonLeftToRightBottomToTop,
  BCRectComparisonRightToLeftBottomToTop,
  BCRectComparisonBottomToTopLeftToRight,
  BCRectComparisonBottomToTopRightToLeft,
  BCRectComparisonDefault,
}

interface BCSingletonAllocator<InitializedType = BCSingleton> extends NSObjectAllocator<BCSingleton> {}
interface BCSingleton extends NSObject {
}
declare const BCSingleton: {
  alloc(): BCSingletonAllocator;  sharedInstance(): BCSingleton;

}

interface BCToolRunningResultAllocator<InitializedType = BCToolRunningResult> extends NSObjectAllocator<BCToolRunningResult> {}
interface BCToolRunningResult extends NSObject {

  errorOutput(): NSData;
  exitStatus(): number;
  output(): NSData;
  terminationReason(): NSTaskTerminationReason;
}
declare const BCToolRunningResult: {
  alloc(): BCToolRunningResultAllocator;
}

interface BCToolRunnerAllocator<InitializedType = BCToolRunner> extends NSObjectAllocator<BCToolRunner> {}
interface BCToolRunner extends NSObject {
  runToolAtExecutableURL_workingDirectoryURL_arguments_completionHandler(toolURL: NSURL, workingDirectoryURL: NSURL, arguments: NSArray<any> | any[], completionHandler: MSToolCompletionHandler): void;
}
declare const BCToolRunner: {
  alloc(): BCToolRunnerAllocator;
}

declare type BCVector = CGVector

interface BCFilterInfoAllocator<InitializedType = BCFilterInfo> extends NSObjectAllocator<BCFilterInfo> {}
interface BCFilterInfo extends NSObject {
  filterTypeMatches(filterType: BCOutlineViewFilterTypeMask): boolean;
  shouldIncludeNode(node: any): boolean;

  filterTypeMask(): BCOutlineViewFilterTypeMask;
  setFilterTypeMask(filterTypeMask: BCOutlineViewFilterTypeMask): void;
  filterString(): NSString;
  setFilterString(filterString: NSString | string): void;
  isActive(): boolean;
}
declare const BCFilterInfo: {
  alloc(): BCFilterInfoAllocator;
}

interface BCIndifferentButtonCellAllocator<InitializedType = BCIndifferentButtonCell> extends NSButtonCellAllocator<BCIndifferentButtonCell> {}
interface BCIndifferentButtonCell extends NSButtonCell {
}
declare const BCIndifferentButtonCell: {
  alloc(): BCIndifferentButtonCellAllocator;
}

interface BCLayerListFilterViewControllerAllocator<InitializedType = BCLayerListFilterViewController> extends NSViewControllerAllocator<BCLayerListFilterViewController> {}
interface BCLayerListFilterViewController extends NSViewController {
  applyAppearance(): void;
  showFilterMenu(sender: any): IBAction;
  toggleFilter(sender: any): IBAction;
  findLayer(sender: any): IBAction;

  filter(): BCFilterInfo;
}
declare const BCLayerListFilterViewController: {
  alloc(): BCLayerListFilterViewControllerAllocator;
}

interface BCLayerListViewControllerAllocator<InitializedType = BCLayerListViewController> extends BCOutlineViewControllerAllocator<BCLayerListViewController> {}
interface BCLayerListViewController extends BCOutlineViewController {
}
declare const BCLayerListViewController: {
  alloc(): BCLayerListViewControllerAllocator;
}

interface BCOutlineViewAllocator<InitializedType = BCOutlineView> extends NSOutlineViewAllocator<BCOutlineView> {}
interface BCOutlineView extends NSOutlineView {
  deliberateScrollRowToVisible(row: NSInteger): void;
  scrollRowToVisible(row: NSInteger): void;

  useHighlightedBackgroundColor(): boolean;
  setUseHighlightedBackgroundColor(useHighlightedBackgroundColor: boolean): void;
  dataController(): BCOutlineViewDataController;
  setDataController(dataController: BCOutlineViewDataController): void;
  discloserTriangleClickedItem(): any;
}
declare const BCOutlineView: {
  alloc(): BCOutlineViewAllocator;
}

interface BCOutlineViewControllerAllocator<InitializedType = BCOutlineViewController> extends NSViewControllerAllocator<BCOutlineViewController> {
  initWithDataController(dataController: BCOutlineViewDataController): InitializedType;
}
interface BCOutlineViewController extends NSViewController, INSOutlineViewDataSource, INSOutlineViewDelegate {
  refreshWithMask(mask: BCOutlineViewControllerRefreshType): void;
  flagsChangedNotification(): void;
  renameNode(): void;
  executeAfterRefreshCompleted(block: BCOutlineViewControllerPostRefreshBlock): void;

  outlineView(): BCOutlineView;
  setOutlineView(outlineView: BCOutlineView): void;
  preferredHeight(): CGFloat;
  filter(): BCFilterInfo;
  setFilter(filter: BCFilterInfo): void;
}
declare const BCOutlineViewController: {
  alloc(): BCOutlineViewControllerAllocator;  itemRowCanFloat(item: any): boolean;

}

declare enum BCOutlineViewControllerRefreshType {
  BCOutlineViewControllerRefreshTypeSelection = 0x01,
  BCOutlineViewControllerRefreshTypeExpansion = 0x02,
  BCOutlineViewControllerRefreshTypeLayout = 0x04,
  BCOutlineViewControllerRefreshTypePreviewImages = 0x08,
  BCOutlineViewControllerRefreshTypeAll = 0x0F,
}

interface BCOutlineViewDataControllerAllocator<InitializedType = BCOutlineViewDataController> extends NSObjectAllocator<BCOutlineViewDataController> {
  initWithDataSource_delegate(dataSource: NSObject, delegate: NSObject): InitializedType;
}
interface BCOutlineViewDataController extends NSObject {
  childrenOfNode(node: any): NSArray<any>;
  numberOfChildrenOfNode(node: any): NSUInteger;
  childOfNode_atIndex(node: any, index: NSInteger): any;
  shouldExpandNode(node: any): boolean;
  writeNodes_toPasteboard(nodes: NSArray<any> | any[], pasteboard: NSPasteboard): boolean;
  handleDragWithPasteboard_forProposedItem_proposedChildIndex_copying_validationOnly(pasteboard: NSPasteboard, item: any, index: NSInteger, copying: boolean, validating: boolean): boolean;
  changeSelectionTo(selection: NSArray<any> | any[]): void;
  isNodeSelected(node: any): boolean;
  multipleNodesSelected(): boolean;
  isNodeExpanded(node: any): boolean;
  isNodeExpandable(node: any): boolean;
  updateNode_expandedState(node: any, expanded: BCOutlineViewNodeExpansionState): void;
  menuItemsForSelectedObjects(selection: NSArray<any> | any[]): NSArray<any>;
  hoverNodeDidChangeTo(node: any): void;
  isNodeHighlighted(node: any): boolean;
  handleBadgePressedOnNode_withAltState(node: any, alt: boolean): void;
  refreshPreviewsOnNodes(nodes: NSArray<any> | any[]): void;
  namesOfPromisedFilesDroppedAtDestination_forDraggedItems(dropDestination: NSURL, items: NSArray<any> | any[]): NSArray<any>;

  filter(): BCFilterInfo;
  setFilter(filter: BCFilterInfo): void;
  rootObject(): any;
  dragTypes(): NSArray<any>;
  canProvideContextMenuItems(): boolean;
}
declare const BCOutlineViewDataController: {
  alloc(): BCOutlineViewDataControllerAllocator;
}

interface IBCOutlineViewDataSource {
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
}

interface IBCOutlineViewDelegate {
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
}

declare enum BCOutlineViewNodeExpansionState {
  BCOutlineViewNodeExpansionStateModelExpanded,
  BCOutlineViewNodeExpansionStateUserExpanded,
  BCOutlineViewNodeExpansionStateDragAutoExpanded,
  BCOutlineViewNodeExpansionStateModelCollapsed,
  BCOutlineViewNodeExpansionStateUserCollapsed,
  BCOutlineViewNodeExpansionStateDragAutoCollapsed,
}

interface IBCOutlineViewNode {
  badgeMap(): NSDictionary<any, any>;
  previewImages(): NSDictionary<any, any>;
  badgeMenu(): NSMenu;

  displayType(): BCOutlineViewDisplayType;
  filterTypeMask(): BCOutlineViewFilterTypeMask;
  nodeName(): NSString;
  setNodeName(nodeName: NSString | string): void;
  isActive(): boolean;
  isEditableInLayerList(): boolean;
  hasBadgedIcon(): boolean;
  selectedBadgeMenuItemIndex(): NSUInteger;
  isExpanded(): boolean;
}

declare enum BCOutlineViewDisplayType {
  BCOutlineViewDisplayTypeStandard,
  BCOutlineViewDisplayTypeArtboard,
  BCOutlineViewDisplayTypePage,
  BCOutlineViewDisplayTypeOverride,
}

declare enum BCOutlineViewFilterTypeMask {
  BCOutlineViewFilterTypeMaskShape = 1 << 0,
  BCOutlineViewFilterTypeMaskText = 1 << 1,
  BCOutlineViewFilterTypeMaskImage = 1 << 2,
  BCOutlineViewFilterTypeMaskGroup = 1 << 3,
  BCOutlineViewFilterTypeMaskExportable = 1 << 4,
  BCOutlineViewFilterTypeMaskPrototypingFlow = 1 << 5,
  BCOutlineViewFilterTypeMaskSymbol = 1 << 6,
}

interface BCPageListViewControllerAllocator<InitializedType = BCPageListViewController> extends BCOutlineViewControllerAllocator<BCPageListViewController> {}
interface BCPageListViewController extends BCOutlineViewController {
}
declare const BCPageListViewController: {
  alloc(): BCPageListViewControllerAllocator;
}

interface BCSideBarViewControllerAllocator<InitializedType = BCSideBarViewController> extends NSViewControllerAllocator<BCSideBarViewController> {
  initWithPageListDataSource_delegate_layerListDataSource_delegate(pageListDataSource: NSObject, pageListDelegate: NSObject, layerListDataSource: NSObject, layerListDelegate: NSObject): InitializedType;
}
interface BCSideBarViewController extends NSViewController {
  refreshWithMask(mask: BCSideBarRefreshType): void;
  refreshAfterAppearanceChange(): void;
  renamePage(): IBAction;
  renameLayer(): IBAction;
  renameLayerAfterNextLayerListRefresh(): IBAction;
  flagsChangedNotification(): void;
  showPageView(): void;

  delegate(): NSObject;
  setDelegate(delegate: NSObject): void;
  filterViewController(): BCLayerListFilterViewController;
  setFilterViewController(filterViewController: BCLayerListFilterViewController): void;
}
declare const BCSideBarViewController: {
  alloc(): BCSideBarViewControllerAllocator;
}

interface IBCSideBarViewControllerDelegate {

  pageListHeight(): CGFloat;
  setPageListHeight(pageListHeight: CGFloat): void;
}

declare enum BCSideBarRefreshType {
  BCSideBarRefreshTypeSelection,
  BCSideBarRefreshTypeLayout,
  BCSideBarRefreshTypePreviewImages,
  BCSideBarRefreshTypeAll,
  BCSideBarRefreshTypeLayerList = 0x10,
  BCSideBarRefreshTypePageList = 0x20,
}

interface BCSidebarPreviewImageViewAllocator<InitializedType = BCSidebarPreviewImageView> extends NSViewAllocator<BCSidebarPreviewImageView> {}
interface BCSidebarPreviewImageView extends NSView {

  image(): NSImage;
  setImage(image: NSImage): void;
}
declare const BCSidebarPreviewImageView: {
  alloc(): BCSidebarPreviewImageViewAllocator;
}

interface BCSplitViewAllocator<InitializedType = BCSplitView> extends NSSplitViewAllocator<BCSplitView> {}
interface BCSplitView extends NSSplitView {
}
declare const BCSplitView: {
  alloc(): BCSplitViewAllocator;
}

interface BCStringWithoutNewlineTransformerAllocator<InitializedType = BCStringWithoutNewlineTransformer> extends NSValueTransformerAllocator<BCStringWithoutNewlineTransformer> {}
interface BCStringWithoutNewlineTransformer extends NSValueTransformer {
}
declare const BCStringWithoutNewlineTransformer: {
  alloc(): BCStringWithoutNewlineTransformerAllocator;
}

interface BCTableCellTitleTextFieldAllocator<InitializedType = BCTableCellTitleTextField> extends NSTextFieldAllocator<BCTableCellTitleTextField> {}
interface BCTableCellTitleTextField extends NSTextField {
}
declare const BCTableCellTitleTextField: {
  alloc(): BCTableCellTitleTextFieldAllocator;
}

interface BCTableCellViewAllocator<InitializedType = BCTableCellView> extends NSTableCellViewAllocator<BCTableCellView> {}
interface BCTableCellView extends NSTableCellView, INSMenuDelegate {
  renameNode(): void;
  updateBadge(): void;
  drawDragImageInRect(dragRect: NSRect): void;
  refreshPreviewImagesAlwaysDropPrimary(force: boolean): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  displayState(): BCTableCellViewDisplayState;
  setDisplayState(displayState: BCTableCellViewDisplayState): void;
  widthForDragImage(): CGFloat;
}
declare const BCTableCellView: {
  alloc(): BCTableCellViewAllocator;
}

interface IBCTableCellViewDelegate {
  isTableCellViewNodeSelected(tableCellView: BCTableCellView): boolean;
  tableCellViewHandleBadgePressed(tableCellView: BCTableCellView): void;
  tableCellViewMouseEntered(tableCellView: BCTableCellView): void;
  tableCellViewMouseExited(tableCellView: BCTableCellView): void;
  tableCellViewDidBeginEditing(tableCellView: BCTableCellView): void;
  tableCellViewDestinationWindow(view: BCTableCellView): NSWindow;
}

declare enum BCTableCellViewDisplayState {
  BCTableCellViewDisplayStateNormal,
  BCTableCellViewDisplayStateHovered,
  BCTableCellViewDisplayStateAlternate,
}

interface BCTableRowViewAllocator<InitializedType = BCTableRowView> extends NSTableRowViewAllocator<BCTableRowView> {}
interface BCTableRowView extends NSTableRowView {

  node(): NSObject;
  setNode(node: NSObject): void;
  delegate(): NSObject;
  setDelegate(delegate: NSObject): void;
  displayType(): BCOutlineViewDisplayType;
  expansionState(): BCOutlineViewNodeExpansionState;
  setExpansionState(expansionState: BCOutlineViewNodeExpansionState): void;
  outlineView(): BCOutlineView;
  drawsTopBorder(): boolean;
  drawsBottomBorder(): boolean;
  hasBottomPaddingApplied(): boolean;
  hasTopPaddingApplied(): boolean;
}
declare const BCTableRowView: {
  alloc(): BCTableRowViewAllocator;
}

interface IBCTableRowViewDelegate {
  isNodeSelectedInTableRowView(view: BCTableRowView): boolean;
  isNodeSelectedOnRow(row: NSInteger): boolean;
  multipleNodesSelected(): boolean;
  isNodeExpandedInTableRowView(view: BCTableRowView): boolean;
  indexOfTableRowView(view: BCTableRowView): NSInteger;
  tableRowView_displayTypeOfRowAtIndex(view: BCTableRowView, index: NSInteger): BCOutlineViewDisplayType;
}

declare enum MSLayerPreviewBadgeType {
  MSLayerPreviewBadgeTypeNone,
  MSLayerPreviewBadgeTypeSlice,
  MSLayerPreviewBadgeTypeFlow,
}

interface LLTestBaseControllerAllocator<InitializedType = LLTestBaseController> extends NSObjectAllocator<LLTestBaseController> {}
interface LLTestBaseController extends NSObject, IBCOutlineViewDataSource, IBCOutlineViewDelegate {
  dataController_removeNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;

  root(): any;
  setRoot(root: any): void;
}
declare const LLTestBaseController: {
  alloc(): LLTestBaseControllerAllocator;
}

interface LLTestLayerListControllerAllocator<InitializedType = LLTestLayerListController> extends LLTestBaseControllerAllocator<LLTestLayerListController> {}
interface LLTestLayerListController extends LLTestBaseController {
}
declare const LLTestLayerListController: {
  alloc(): LLTestLayerListControllerAllocator;
}

interface LLTestPageListControllerAllocator<InitializedType = LLTestPageListController> extends LLTestBaseControllerAllocator<LLTestPageListController> {}
interface LLTestPageListController extends LLTestBaseController {
  addPage(): void;
}
declare const LLTestPageListController: {
  alloc(): LLTestPageListControllerAllocator;
}

interface BCAppDelegateAllocator<InitializedType = BCAppDelegate> extends NSObjectAllocator<BCAppDelegate> {}
interface BCAppDelegate extends NSObject, INSApplicationDelegate, IBCPopoverDelegate, INSApplicationDelegate {
  attach(sender: any): IBAction;
  resize(sender: any): IBAction;

  window(): NSWindow;
  setWindow(window: NSWindow): void;
  button(): NSButton;
  setButton(button: NSButton): void;
}
declare const BCAppDelegate: {
  alloc(): BCAppDelegateAllocator;
}

interface BCDummyViewControllerAllocator<InitializedType = BCDummyViewController> extends NSViewControllerAllocator<BCDummyViewController> {}
interface BCDummyViewController extends NSViewController {
}
declare const BCDummyViewController: {
  alloc(): BCDummyViewControllerAllocator;
}

interface BCRedLinedViewAllocator<InitializedType = BCRedLinedView> extends NSViewAllocator<BCRedLinedView> {}
interface BCRedLinedView extends NSView {
}
declare const BCRedLinedView: {
  alloc(): BCRedLinedViewAllocator;
}

interface BCColorButtonCellAllocator<InitializedType = BCColorButtonCell> extends NSButtonCellAllocator<BCColorButtonCell> {}
interface BCColorButtonCell extends NSButtonCell {

  backgroundColorStringRepresentation(): NSString;
  setBackgroundColorStringRepresentation(backgroundColorStringRepresentation: NSString | string): void;
  backgroundHighlightedColor(): NSString;
  setBackgroundHighlightedColor(backgroundHighlightedColor: NSString | string): void;
  textColor(): NSString;
  setTextColor(textColor: NSString | string): void;
  backgroundSelectedColor(): NSString;
  setBackgroundSelectedColor(backgroundSelectedColor: NSString | string): void;
  backgroundSelectedHighlightedColor(): NSString;
  setBackgroundSelectedHighlightedColor(backgroundSelectedHighlightedColor: NSString | string): void;
  textSelectedColor(): NSString;
  setTextSelectedColor(textSelectedColor: NSString | string): void;
}
declare const BCColorButtonCell: {
  alloc(): BCColorButtonCellAllocator;
}

interface BCDebugMenuControllerAllocator<InitializedType = BCDebugMenuController> extends BCSingletonAllocator<BCDebugMenuController> {}
interface BCDebugMenuController extends BCSingleton {
  addDebugMenu(): void;
}
declare const BCDebugMenuController: {
  alloc(): BCDebugMenuControllerAllocator;
}

interface BCHighlightColorButtonCellAllocator<InitializedType = BCHighlightColorButtonCell> extends NSButtonCellAllocator<BCHighlightColorButtonCell> {}
interface BCHighlightColorButtonCell extends NSButtonCell {
}
declare const BCHighlightColorButtonCell: {
  alloc(): BCHighlightColorButtonCellAllocator;
}

interface BCHighlightColorTextFieldCellAllocator<InitializedType = BCHighlightColorTextFieldCell> extends NSTextFieldCellAllocator<BCHighlightColorTextFieldCell> {}
interface BCHighlightColorTextFieldCell extends NSTextFieldCell {

  highlightColor(): NSColor;
  setHighlightColor(highlightColor: NSColor): void;
}
declare const BCHighlightColorTextFieldCell: {
  alloc(): BCHighlightColorTextFieldCellAllocator;
}

interface BCHighlightImageCellAllocator<InitializedType = BCHighlightImageCell> extends NSImageCellAllocator<BCHighlightImageCell> {}
interface BCHighlightImageCell extends NSImageCell {
}
declare const BCHighlightImageCell: {
  alloc(): BCHighlightImageCellAllocator;
}

interface BCIOSStyleSwitchButtonAllocator<InitializedType = BCIOSStyleSwitchButton> extends NSButtonAllocator<BCIOSStyleSwitchButton> {}
interface BCIOSStyleSwitchButton extends NSButton {
}
declare const BCIOSStyleSwitchButton: {
  alloc(): BCIOSStyleSwitchButtonAllocator;
}

interface BCJSONZippedDecoderAllocator<InitializedType = BCJSONZippedDecoder> extends BCJSONDecoderAllocator<BCJSONZippedDecoder> {
  initWithURL(url: NSURL): InitializedType;
}
interface BCJSONZippedDecoder extends BCJSONDecoder {
  rawDataAtSubpath_error(path: NSString | string, error: NSError): NSData;
  decodeFileAtSubpath_error(path: NSString | string, error: NSError): any;
  containsFileAtSubpath(path: NSString | string): boolean;
}
declare const BCJSONZippedDecoder: {
  alloc(): BCJSONZippedDecoderAllocator;
}

interface BCJSONZippedEncoderAllocator<InitializedType = BCJSONZippedEncoder> extends BCJSONEncoderAllocator<BCJSONZippedEncoder> {}
interface BCJSONZippedEncoder extends BCJSONEncoder {
  encodeObject_toSubpath_error(root: NSObject, path: NSString | string, error: NSError): boolean;
  encodeRawData_toSubpath_error(data: NSData, path: NSString | string, error: NSError): boolean;
  finishEncodingError(error: NSError): boolean;
}
declare const BCJSONZippedEncoder: {
  alloc(): BCJSONZippedEncoderAllocator;  zipEncoderForWritingAtURL(url: NSURL): BCJSONZippedEncoder;

}

interface BCJSONZippedUnarchiverAllocator<InitializedType = BCJSONZippedUnarchiver> extends BCJSONUnarchiverAllocator<BCJSONZippedUnarchiver> {
  initWithURL(url: NSURL): InitializedType;
}
interface BCJSONZippedUnarchiver extends BCJSONUnarchiver {
  unarchiveObjectAtSubpath_error(path: NSString | string, error: NSError): any;
}
declare const BCJSONZippedUnarchiver: {
  alloc(): BCJSONZippedUnarchiverAllocator;
}

interface BCKeyEventActionTableViewAllocator<InitializedType = BCKeyEventActionTableView> extends NSTableViewAllocator<BCKeyEventActionTableView> {}
interface BCKeyEventActionTableView extends NSTableView {
  setTarget_action_forKeyDownEventWithCharacters(target: any, action: string, characters: NSString | string): void;
}
declare const BCKeyEventActionTableView: {
  alloc(): BCKeyEventActionTableViewAllocator;
}

interface BCPasteboardMockAllocator<InitializedType = BCPasteboardMock> extends NSObjectAllocator<BCPasteboardMock> {}
interface BCPasteboardMock extends NSObject {
  declareTypes_owner(types: NSArray<any> | any[], owner: any): void;
  addTypes_owner(types: NSArray<any> | any[], owner: any): void;
  setData_forType(data: NSData, dataType: NSString | string): void;
  dataForType(type: NSString | string): NSData;
  setString_forType(string: NSString | string, dataType: NSString | string): boolean;
  stringForType(dataType: NSString | string): NSString;
  setPropertyList_forType(plist: any, dataType: NSString | string): boolean;
  propertyListForType(dataType: NSString | string): any;
  availableTypeFromArray(types: NSArray<any> | any[]): NSString;
  types(): NSArray<any>;
  writeObjects(objects: NSArray<any> | any[]): boolean;
  clearContents(): void;

  name(): NSString;
  changeCount(): NSInteger;
}
declare const BCPasteboardMock: {
  alloc(): BCPasteboardMockAllocator;  generalPasteboard(): NSPasteboard;
  pasteboardWithName(name: NSString | string): NSPasteboard;

}

interface BCPopoverAllocator<InitializedType = BCPopover> extends NSObjectAllocator<BCPopover> {}
interface BCPopover extends NSObject, INSWindowDelegate, INSViewControllerPresentationAnimator {
  showRelativeToView_preferredEdge(view: NSView, edge: NSRectEdge): void;
  close(): void;
  move(): void;
  popoverWindowFrame(): NSRect;

  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  minimumHeight(): CGFloat;
  window(): BCPopoverWindow;
  setWindow(window: BCPopoverWindow): void;
  screenEdgeBehaviour(): BCPopoverScreenEdgeBehaviour;
  setScreenEdgeBehaviour(screenEdgeBehaviour: BCPopoverScreenEdgeBehaviour): void;
  layerDependency(): BCPopupLayerDependency;
  setLayerDependency(layerDependency: BCPopupLayerDependency): void;
  closesOnWindowDidResignKey(): boolean;
  setClosesOnWindowDidResignKey(closesOnWindowDidResignKey: boolean): void;
  attachedToView(): NSView;
  setAttachedToView(attachedToView: NSView): void;
  attachedToViewMargin(): CGFloat;
  setAttachedToViewMargin(attachedToViewMargin: CGFloat): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
}
declare const BCPopover: {
  alloc(): BCPopoverAllocator;
}

declare enum BCPopupLayerDependency {
  BCPopoverLayerDependant,
  BCPopoverLayerIndependent,
}

declare enum BCPopoverScreenEdgeBehaviour {
  BCPopoverScreenEdgeBehaviourNone,
  BCPopoverScreenEdgeBehaviourResize,
  BCPopoverScreenEdgeBehaviourMove,
}

interface BCPopoverContentViewAllocator<InitializedType = BCPopoverContentView> extends NSViewAllocator<BCPopoverContentView> {}
interface BCPopoverContentView extends NSView {
  availableContentRect(): NSRect;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  arrowEdge(): NSRectEdge;
  setArrowEdge(arrowEdge: NSRectEdge): void;
  arrowPosition(): CGFloat;
  setArrowPosition(arrowPosition: CGFloat): void;
}
declare const BCPopoverContentView: {
  alloc(): BCPopoverContentViewAllocator;
}

interface IBCPopoverDelegate {
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
}

interface BCPopoverWindowAllocator<InitializedType = BCPopoverWindow> extends NSWindowAllocator<BCPopoverWindow> {}
interface BCPopoverWindow extends NSWindow {

  arrowEdge(): NSRectEdge;
  setArrowEdge(arrowEdge: NSRectEdge): void;
  arrowPosition(): CGFloat;
  setArrowPosition(arrowPosition: CGFloat): void;
}
declare const BCPopoverWindow: {
  alloc(): BCPopoverWindowAllocator;  attachedWindowWithView(aView: NSView): any;

}

interface BCWindowBadgeAllocator<InitializedType = BCWindowBadge> extends MSHoverButtonAllocator<BCWindowBadge> {}
interface BCWindowBadge extends MSHoverButton {

  tintColor(): NSColor;
  setTintColor(tintColor: NSColor): void;
}
declare const BCWindowBadge: {
  alloc(): BCWindowBadgeAllocator;
}

interface BCZeroHeightWhenEmptyTextFieldAllocator<InitializedType = BCZeroHeightWhenEmptyTextField> extends NSTextFieldAllocator<BCZeroHeightWhenEmptyTextField> {}
interface BCZeroHeightWhenEmptyTextField extends NSTextField {

  paddingIfNotEmpty(): CGFloat;
  setPaddingIfNotEmpty(paddingIfNotEmpty: CGFloat): void;
}
declare const BCZeroHeightWhenEmptyTextField: {
  alloc(): BCZeroHeightWhenEmptyTextFieldAllocator;
}

interface CHFlippedViewAllocator<InitializedType = CHFlippedView> extends NSViewAllocator<CHFlippedView> {}
interface CHFlippedView extends NSView {
}
declare const CHFlippedView: {
  alloc(): CHFlippedViewAllocator;
}

interface CHImagelessPopupButtonCellAllocator<InitializedType = CHImagelessPopupButtonCell> extends NSPopUpButtonCellAllocator<CHImagelessPopupButtonCell> {}
interface CHImagelessPopupButtonCell extends NSPopUpButtonCell {
}
declare const CHImagelessPopupButtonCell: {
  alloc(): CHImagelessPopupButtonCellAllocator;
}

interface CHOutlineViewAllocator<InitializedType = CHOutlineView> extends NSOutlineViewAllocator<CHOutlineView> {}
interface CHOutlineView extends NSOutlineView {
}
declare const CHOutlineView: {
  alloc(): CHOutlineViewAllocator;
}

interface CHTableViewAllocator<InitializedType = CHTableView> extends NSTableViewAllocator<CHTableView> {}
interface CHTableView extends NSTableView {
}
declare const CHTableView: {
  alloc(): CHTableViewAllocator;
}

interface CHProgressSheetAllocator<InitializedType = CHProgressSheet> extends CHSheetControllerAllocator<CHProgressSheet> {}
interface CHProgressSheet extends CHSheetController {
  setProgressMaximum(max: NSInteger): void;
  incrementProgress(): void;
  incrementProgressBy(amount: NSInteger): void;
  isMaximum(): boolean;
  setMessage(message: NSString | string): void;
  setTitle(aTitle: NSString | string): void;
  setSubtitle(subtitle: NSString | string): void;
  setShowsCancelButton(flag: boolean): void;
  setIndeterminate(flag: boolean): void;
}
declare const CHProgressSheet: {
  alloc(): CHProgressSheetAllocator;
}

interface CHSheetControllerAllocator<InitializedType = CHSheetController> extends CHWindowControllerAllocator<CHSheetController> {}
interface CHSheetController extends CHWindowController, INSTouchBarDelegate {
  run(): any;
  confirm(sender: any): IBAction;
  cancel(sender: any): IBAction;
  _init(): any;
  touchBarItemIdentifiers(): NSArray<any>;
  selectorForTouchbarItemIdentifier(itemIdentifier: NSTouchBarItemIdentifier): string;

  object(): any;
  setObject(object: any): void;
}
declare const CHSheetController: {
  alloc(): CHSheetControllerAllocator;  runForWindow(window: NSWindow): any;
  runForWindow_withObject(window: NSWindow, obj: any): any;

}

interface CHStringAttributesAllocator<InitializedType = CHStringAttributes> extends NSDictionaryAllocator<any, any, CHStringAttributes> {}
interface CHStringAttributes extends NSDictionary<any, any>, INSCopying {

  font(): NSFont;
  setFont(font: NSFont): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  shadow(): NSShadow;
  setShadow(shadow: NSShadow): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  fontSize(): CGFloat;
  setFontSize(fontSize: CGFloat): void;
}
declare const CHStringAttributes: {
  alloc(): CHStringAttributesAllocator;  stringAttributesWithFont(aFont: NSFont): any;
  stringAttributesWithFont_color(aFont: NSFont, aColor: NSColor): any;
  stringAttributesWithFont_color_alignment(aFont: NSFont, aColor: NSColor, align: NSTextAlignment): any;

}

interface CHTransparentViewAllocator<InitializedType = CHTransparentView> extends NSViewAllocator<CHTransparentView> {}
interface CHTransparentView extends NSView {

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}
declare const CHTransparentView: {
  alloc(): CHTransparentViewAllocator;
}

interface CHTransparentWindowAllocator<InitializedType = CHTransparentWindow> extends NSWindowAllocator<CHTransparentWindow> {
  initWithContentRect(contentRect: NSRect): InitializedType;
}
interface CHTransparentWindow extends NSWindow {
}
declare const CHTransparentWindow: {
  alloc(): CHTransparentWindowAllocator;
}

interface CHVerticallyCentredPopupButtonCellAllocator<InitializedType = CHVerticallyCentredPopupButtonCell> extends NSPopUpButtonCellAllocator<CHVerticallyCentredPopupButtonCell> {}
interface CHVerticallyCentredPopupButtonCell extends NSPopUpButtonCell {
}
declare const CHVerticallyCentredPopupButtonCell: {
  alloc(): CHVerticallyCentredPopupButtonCellAllocator;
}

interface CHWindowControllerAllocator<InitializedType = CHWindowController> extends NSWindowControllerAllocator<CHWindowController> {}
interface CHWindowController extends NSWindowController {
}
declare const CHWindowController: {
  alloc(): CHWindowControllerAllocator;
}

interface MSAltButtonAllocator<InitializedType = MSAltButton> extends MSHoverButtonAllocator<MSAltButton> {}
interface MSAltButton extends MSHoverButton {

  bc_weakTarget(): any;
  setBc_weakTarget(bc_weakTarget: any): void;
}
declare const MSAltButton: {
  alloc(): MSAltButtonAllocator;
}

interface MSAltButtonCellAllocator<InitializedType = MSAltButtonCell> extends MSHoverButtonCellAllocator<MSAltButtonCell> {}
interface MSAltButtonCell extends MSHoverButtonCell {
}
declare const MSAltButtonCell: {
  alloc(): MSAltButtonCellAllocator;
}

interface IMSAltButtonTarget {
  altButtonCanShowAltImage(altButton: MSAltButton): boolean;
}

interface IMSDropableViewDelegate {
  draggedTypesForView(view: NSView): NSArray<any>;
  view_performDragOperation(view: NSView, sender: any): boolean;
  view_draggingEntered(view: NSView, sender: any): NSDragOperation;
  view_draggingUpdated(view: NSView, sender: any): NSDragOperation;
  view_draggingExited(view: NSView, sender: any): void;
  view_draggingEnded(view: NSView, sender: any): void;
  view_prepareForDragOperation(view: NSView, sender: any): boolean;
  view_concludeDragOperation(view: NSView, sender: any): void;
  viewWantsPeriodicDraggingUpdates(view: NSView): boolean;
  view_updateDraggingItemsForDrag(view: NSView, sender: any): void;
}

interface MSFileMonitorAllocator<InitializedType = MSFileMonitor> extends MSFolderMonitorAllocator<MSFileMonitor> {}
interface MSFileMonitor extends MSFolderMonitor {
}
declare const MSFileMonitor: {
  alloc(): MSFileMonitorAllocator;
}

interface MSFolderMonitorAllocator<InitializedType = MSFolderMonitor> extends NSObjectAllocator<MSFolderMonitor> {
  initWithURL_contentsChangedBlock(folderURL: NSURL, block: Block): InitializedType;
  initWithURL_latency_contentsChangedBlock(folderURL: NSURL, latency: NSTimeInterval, block: Block): InitializedType;
}
interface MSFolderMonitor extends NSObject {
  flush(): void;

  folderURL(): NSURL;
}
declare const MSFolderMonitor: {
  alloc(): MSFolderMonitorAllocator;
}

interface MSHoverButtonAllocator<InitializedType = MSHoverButton> extends NSButtonAllocator<MSHoverButton> {}
interface MSHoverButton extends NSButton {

  mouseIsHovering(): boolean;
  setMouseIsHovering(mouseIsHovering: boolean): void;
}
declare const MSHoverButton: {
  alloc(): MSHoverButtonAllocator;
}

interface MSHoverButtonCellAllocator<InitializedType = MSHoverButtonCell> extends NSButtonCellAllocator<MSHoverButtonCell> {}
interface MSHoverButtonCell extends NSButtonCell {
}
declare const MSHoverButtonCell: {
  alloc(): MSHoverButtonCellAllocator;
}

interface MSTintedHoverButtonCellAllocator<InitializedType = MSTintedHoverButtonCell> extends MSHoverButtonCellAllocator<MSTintedHoverButtonCell> {}
interface MSTintedHoverButtonCell extends MSHoverButtonCell {

  normalTint(): NSColor;
  hoverTint(): NSColor;
}
declare const MSTintedHoverButtonCell: {
  alloc(): MSTintedHoverButtonCellAllocator;
}

interface MSNamedInterfaceImageOwnerAllocator<InitializedType = MSNamedInterfaceImageOwner> extends NSObjectAllocator<MSNamedInterfaceImageOwner> {
  initWithImage_cacheOwner(image: NSImage, cacheOwner: any): InitializedType;
}
interface MSNamedInterfaceImageOwner extends NSObject, IMSInterfaceImageOwner {
}
declare const MSNamedInterfaceImageOwner: {
  alloc(): MSNamedInterfaceImageOwnerAllocator;
}

interface IMSInterfaceImageOwner {

  interfaceImageIdentifier(): NSString;
  cacheOwner(): any;
}

interface MSPlainButtonAllocator<InitializedType = MSPlainButton> extends MSHoverButtonAllocator<MSPlainButton> {}
interface MSPlainButton extends MSHoverButton {
}
declare const MSPlainButton: {
  alloc(): MSPlainButtonAllocator;
}

interface MSPlainButtonCellAllocator<InitializedType = MSPlainButtonCell> extends MSHoverButtonCellAllocator<MSPlainButtonCell> {}
interface MSPlainButtonCell extends MSHoverButtonCell {
}
declare const MSPlainButtonCell: {
  alloc(): MSPlainButtonCellAllocator;
}

interface MSPreviewPopupButtonCellAllocator<InitializedType = MSPreviewPopupButtonCell> extends NSPopUpButtonCellAllocator<MSPreviewPopupButtonCell> {}
interface MSPreviewPopupButtonCell extends NSPopUpButtonCell {

  previewImage(): NSImage;
  setPreviewImage(previewImage: NSImage): void;
  previewImageFrame(): CGRect;
  setPreviewImageFrame(previewImageFrame: CGRect): void;
  titleOffset(): CGFloat;
  setTitleOffset(titleOffset: CGFloat): void;
}
declare const MSPreviewPopupButtonCell: {
  alloc(): MSPreviewPopupButtonCellAllocator;
}

interface MSThemeAllocator<InitializedType = MSTheme> extends NSObjectAllocator<MSTheme> {}
interface MSTheme extends NSObject {
  layerListSelectionColorForWindow(window: NSWindow): NSColor;
  layerListSymbolOverrideSelectionColorForWindow(window: NSWindow): NSColor;
  layerListTextColorForBackgroundStyle(style: NSBackgroundStyle): NSColor;
  layerListTextEditingBackgroundColorForBackgroundStyle(style: NSBackgroundStyle): NSColor;
  colorNamed(colorName: NSColorName): NSColor;
  colorNamed_options(colorName: NSColorName, options: MSThemeResolvingOptions): NSColor;
  imageNamed(imageName: NSString | string): NSImage;
  imageNamed_options(imageName: NSString | string, options: MSThemeResolvingOptions): NSImage;
  cacheImage_forKey_owner(image: NSImage, key: NSString | string, owner: any): void;
  cachedImageForKey_owner(key: NSString | string, owner: any): NSImage;
  cachedImageForKey_owner_createBlock(key: NSString | string, owner: any, block: BCCacheCreateObjectBlock): NSImage;
  invalidateCachedResources(): void;
  attributedStringWithString_color_controlSize(string: NSString | string, color: NSColor, controlSize: NSControlSize): NSAttributedString;

  canvasArtboardTitleColor(): NSColor;
  canvasBackgroundColor(): NSColor;
  canvasFlowArrowColor(): NSColor;
  canvasLayerHighlightColor(): NSColor;
  canvasLayerSelectionColor(): NSColor;
  canvasMeasurementLabelBackgroundColor(): NSColor;
  canvasPageBackgroundColor(): NSColor;
  canvasPixelLineColor(): NSColor;
  canvasRulerBackgroundColor(): NSColor;
  canvasRulerLineColor(): NSColor;
  canvasRulerLineOccupiedColor(): NSColor;
  canvasRulerLockColor(): NSColor;
  canvasRulerOccupiedColor(): NSColor;
  canvasRulerTextColor(): NSColor;
  canvasRulerTextBackgroundColor(): NSColor;
  canvasSliceOutlineColor(): NSColor;
  canvasSymbolErrorBackgroundColor(): NSColor;
  canvasSymbolErrorBorderColor(): NSColor;
  canvasSymbolErrorTextColor(): NSColor;
  canvasSymbolTitleColor(): NSColor;
  colorPickerAssetBorderColor(): NSColor;
  colorPickerDarkShadowColor(): NSColor;
  colorPickerLightShadowColor(): NSColor;
  colorPickerMarkerFillColor(): NSColor;
  colorPickerMarkerShadowColor(): NSColor;
  colorPickerSeparatorColor(): NSColor;
  inspectorSectionBackgroundColor(): NSColor;
  inspectorSectionSeparatorColor(): NSColor;
  inspectorSeparatorColor(): NSColor;
  layerListArtboardBorderColor(): NSColor;
  layerListBackgroundColor(): NSColor;
  layerListLightBackgroundColor(): NSColor;
  layerListFilterTokenBackgroundColor(): NSColor;
  layerListFilterTokenSelectedBackgroundColor(): NSColor;
  layerListFilterTokenTitleColor(): NSColor;
  layerListFilterTokenSelectedTitleColor(): NSColor;
  layerListIconPressedTintColor(): NSColor;
  layerListIconPrimaryTintColor(): NSColor;
  layerListIconSecondaryTintColor(): NSColor;
  layerListIconSelectedTintColor(): NSColor;
  layerListIconSharedTintColor(): NSColor;
  layerListSplitViewDividerColor(): NSColor;
  layerListSymbolOverrideIconTintColor(): NSColor;
  layerListTabButtonColor(): NSColor;
  licenseWindowErrorTextColor(): NSColor;
  preferencesWindowErrorTextColor(): NSColor;
  windowBadgeFontsMissingColor(): NSColor;
  windowBadgeLibraryChangesAvailableColor(): NSColor;
  windowBadgePluginUpdatesAvailableColor(): NSColor;
  hoverButtonHoverColor(): NSColor;
  hoverButtonNormalColor(): NSColor;
  splitViewDividerColor(): NSColor;
  isDark(): boolean;
}
declare const MSTheme: {
  alloc(): MSThemeAllocator;
  sharedTheme(): MSTheme;

}

declare enum MSThemeResolvingOptions {
  MSThemeResolvingOptionsDefault = 0,
  MSThemeResolvingOptionInactiveWindow = 1,
  MSThemeResolvingOptionDarkMode = 2,
}

declare type CHTransformStruct = {
  rotation: CGFloat
  isFlippedHorizontal: boolean
  isFlippedVertical: boolean
  flipOrder: boolean
}

declare enum DKCGContextCreateFlags {
  DKCGContextCreateDefault = 0,
  DKCGContextCreateIsFlipped = 0x01,
}

interface COSAlertWindowAllocator<InitializedType = COSAlertWindow> extends NSObjectAllocator<COSAlertWindow> {}
interface COSAlertWindow extends NSObject {
  addTextFieldWithValue(value: NSString | string): void;
  addAccessoryView(view: NSView): void;

  alert(): NSAlert;
  setAlert(alert: NSAlert): void;
}
declare const COSAlertWindow: {
  alloc(): COSAlertWindowAllocator;
}

interface COSFiberAllocator<InitializedType = COSFiber> extends NSObjectAllocator<COSFiber> {}
interface COSFiber extends NSObject {
  onCleanup(jsFunction: MOJavaScriptObject | Function): void;
  cleanup(): void;

  coscript(): COScript;
  setCoscript(coscript: COScript): void;
  cleanUpJSfunc(): MOJavaScriptObject;
  setCleanUpJSfunc(cleanUpJSfunc: MOJavaScriptObject | Function): void;
}
declare const COSFiber: {
  alloc(): COSFiberAllocator;  createWithCocoaScript(cos: COScript): any;

}

interface COSGifAnimatorAllocator<InitializedType = COSGifAnimator> extends NSObjectAllocator<COSGifAnimator> {}
interface COSGifAnimator extends NSObject {

  fps(): CGFloat;
  setFps(fps: CGFloat): void;
  seconds(): CGFloat;
  setSeconds(seconds: CGFloat): void;
  size(): NSSize;
  setSize(size: NSSize): void;
}
declare const COSGifAnimator: {
  alloc(): COSGifAnimatorAllocator;
}

interface COSIntervalAllocator<InitializedType = COSInterval> extends COSFiberAllocator<COSInterval> {}
interface COSInterval extends COSFiber {
  cancel(): void;

  jsfunc(): MOJavaScriptObject;
  setJsfunc(jsfunc: MOJavaScriptObject | Function): void;
}
declare const COSInterval: {
  alloc(): COSIntervalAllocator;  scheduleWithInterval_cocoaScript_jsFunction_repeat(i: NSTimeInterval, cos: COScript, jsFunction: MOJavaScriptObject | Function, repeat: boolean): any;

}

interface COSListenerAllocator<InitializedType = COSListener> extends NSObjectAllocator<COSListener> {}
interface COSListener extends NSObject {

  rootObject(): any;
  setRootObject(rootObject: any): void;
}
declare const COSListener: {
  alloc(): COSListenerAllocator;  sharedListener(): COSListener;
  listen(): void;
  listenWithRootObject(rootObject: any): void;

}

interface COSMarkdownAllocator<InitializedType = COSMarkdown> extends NSObjectAllocator<COSMarkdown> {}
interface COSMarkdown extends NSObject {
}
declare const COSMarkdown: {
  alloc(): COSMarkdownAllocator;
}

interface COSPreprocessorAllocator<InitializedType = COSPreprocessor> extends NSObjectAllocator<COSPreprocessor> {}
interface COSPreprocessor extends NSObject {
}
declare const COSPreprocessor: {
  alloc(): COSPreprocessorAllocator;  preprocessCode(sourceString: NSString | string): NSString;
  preprocessCode_withBaseURL(sourceString: NSString | string, base: NSURL): NSString;

}

interface JSTPSymbolGroupAllocator<InitializedType = JSTPSymbolGroup> extends NSObjectAllocator<JSTPSymbolGroup> {}
interface JSTPSymbolGroup extends NSObject {
  addSymbol(aSymbol: any): void;

  args(): NSMutableArray<any>;
  setArgs(args: NSMutableArray<any> | any[]): void;
  parent(): JSTPSymbolGroup;
  setParent(parent: JSTPSymbolGroup): void;
}
declare const JSTPSymbolGroup: {
  alloc(): JSTPSymbolGroupAllocator;
}

interface COSRAllocator<InitializedType = COSR> extends NSObjectAllocator<COSR> {}
interface COSR extends NSObject {
}
declare const COSR: {
  alloc(): COSRAllocator;
}

interface COScriptAllocator<InitializedType = COScript> extends NSObjectAllocator<COScript> {
  initWithCoreModules_andName(coreModules: NSDictionary<any, any> | {[key: string]: any}, name: NSString | string): InitializedType;
}
interface COScript extends NSObject {
  addFiber(fiber: COSFiber): void;
  cleanupFibers(): void;
  removeFiber(fiber: COSFiber): void;
  createFiber(): COSFiber;
  cleanup(): void;
  garbageCollect(): void;
  executeString(str: NSString | string): any;
  executeString_baseURL(str: NSString | string, base: NSURL): any;
  pushObject_withName(obj: any, name: NSString | string): void;
  deleteObjectWithName(name: NSString | string): void;
  print(s: any): void;
  require(module: NSString | string): any;
  shouldKeepRunning(): boolean;
  context(): JSGlobalContextRef;
  callFunctionNamed_withArguments(name: NSString | string, args: NSArray<any> | any[]): any;
  hasFunctionNamed(name: NSString | string): boolean;
  callJSFunction_withArgumentsInArray(jsFunction: JSObjectRef, arguments: NSArray<any> | any[]): any;

  printController(): any;
  setPrintController(printController: any): void;
  env(): NSMutableDictionary<any, any>;
  setEnv(env: NSMutableDictionary<any, any> | {[key: string]: any}): void;
  shouldPreprocess(): boolean;
  setShouldPreprocess(shouldPreprocess: boolean): void;
  shouldKeepAround(): boolean;
  setShouldKeepAround(shouldKeepAround: boolean): void;
  processedSource(): NSString;
  setProcessedSource(processedSource: NSString | string): void;
  coreModuleMap(): NSDictionary<any, any>;
  setCoreModuleMap(coreModuleMap: NSDictionary<any, any> | {[key: string]: any}): void;
  moduleCache(): NSMutableDictionary<any, any>;
  setModuleCache(moduleCache: NSMutableDictionary<any, any> | {[key: string]: any}): void;
}
declare const COScript: {
  alloc(): COScriptAllocator;  insertInMainMenu(): boolean;
  loadBridgeSupportFileAtURL(url: NSURL): void;
  listen(): void;
  resetPlugins(): void;
  loadPlugins(): void;
  setShouldLoadJSTPlugins(b: boolean): void;
  application(app: NSString | string): any;
  app(app: NSString | string): any;
  currentCOScript(): COScript;
  setDebugController(debugController: any): any;

}

interface COSTargetAllocator<InitializedType = COSTarget> extends NSObjectAllocator<COSTarget> {
  initWithJSFunction(jsFunction: MOJavaScriptObject | Function): InitializedType;
}
interface COSTarget extends NSObject {
  callAction(sender: any): void;
  action(): string;

  jsFunction(): MOJavaScriptObject;
  setJsFunction(jsFunction: MOJavaScriptObject | Function): void;
  callCount(): NSUInteger;
  setCallCount(callCount: NSUInteger): void;
}
declare const COSTarget: {
  alloc(): COSTargetAllocator;  targetWithJSFunction(jsFunction: MOJavaScriptObject | Function): COSTarget;

}

interface JSTalkAllocator<InitializedType = JSTalk> extends COScriptAllocator<JSTalk> {}
interface JSTalk extends COScript {
}
declare const JSTalk: {
  alloc(): JSTalkAllocator;
}

interface ICOPrintController {
  print(s: any): void;
}

interface ICODebugController {
  output_args(format: NSString | string, ...args: any[]): void;
}

interface MarkerLineNumberViewAllocator<InitializedType = MarkerLineNumberView> extends NoodleLineNumberViewAllocator<MarkerLineNumberView> {}
interface MarkerLineNumberView extends NoodleLineNumberView {
}
declare const MarkerLineNumberView: {
  alloc(): MarkerLineNumberViewAllocator;
}

interface NoodleLineNumberMarkerAllocator<InitializedType = NoodleLineNumberMarker> extends NSRulerMarkerAllocator<NoodleLineNumberMarker> {
  initWithRulerView_lineNumber_image_imageOrigin(aRulerView: NSRulerView, line: CGFloat, anImage: NSImage, imageOrigin: NSPoint): InitializedType;
}
interface NoodleLineNumberMarker extends NSRulerMarker {
  setLineNumber(line: NSUInteger): void;
  lineNumber(): NSUInteger;
}
declare const NoodleLineNumberMarker: {
  alloc(): NoodleLineNumberMarkerAllocator;
}

interface NoodleLineNumberViewAllocator<InitializedType = NoodleLineNumberView> extends NSRulerViewAllocator<NoodleLineNumberView> {
  initWithScrollView(aScrollView: NSScrollView): InitializedType;
}
interface NoodleLineNumberView extends NSRulerView {
  setFont(aFont: NSFont): void;
  font(): NSFont;
  setTextColor(color: NSColor): void;
  textColor(): NSColor;
  setAlternateTextColor(color: NSColor): void;
  alternateTextColor(): NSColor;
  setBackgroundColor(color: NSColor): void;
  backgroundColor(): NSColor;
  lineNumberForLocation(location: CGFloat): NSInteger;
  markerAtLine(line: NSUInteger): NoodleLineNumberMarker;
}
declare const NoodleLineNumberView: {
  alloc(): NoodleLineNumberViewAllocator;
}

interface MOBridgeSupportControllerAllocator<InitializedType = MOBridgeSupportController> extends NSObjectAllocator<MOBridgeSupportController> {}
interface MOBridgeSupportController extends NSObject {
  isBridgeSupportLoadedForURL(aURL: NSURL): boolean;
  loadBridgeSupportAtURL_error(aURL: NSURL, outError: NSError): boolean;
  performQueryForSymbolsOfType(classes: NSArray<any> | any[]): NSDictionary<any, any>;
  performQueryForSymbolName(name: NSString | string): any;
  performQueryForSymbolName_ofType(name: NSString | string, klass: any): any;

  symbols(): NSDictionary<any, any>;
}
declare const MOBridgeSupportController: {
  alloc(): MOBridgeSupportControllerAllocator;  sharedController(): MOBridgeSupportController;

}

interface MOBridgeSupportLibraryAllocator<InitializedType = MOBridgeSupportLibrary> extends NSObjectAllocator<MOBridgeSupportLibrary> {}
interface MOBridgeSupportLibrary extends NSObject {
  addDependency(dependency: NSString | string): void;
  removeDependency(dependency: NSString | string): void;
  symbolWithName(name: NSString | string): MOBridgeSupportSymbol;
  setSymbol_forName(symbol: MOBridgeSupportSymbol, name: NSString | string): void;
  removeSymbolForName(name: NSString | string): void;

  name(): NSString;
  setName(name: NSString | string): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
  dependencies(): NSArray<any>;
  setDependencies(dependencies: NSArray<any> | any[]): void;
  symbols(): NSDictionary<any, any>;
  setSymbols(symbols: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const MOBridgeSupportLibrary: {
  alloc(): MOBridgeSupportLibraryAllocator;
}

interface MOBridgeSupportParserAllocator<InitializedType = MOBridgeSupportParser> extends NSObjectAllocator<MOBridgeSupportParser> {}
interface MOBridgeSupportParser extends NSObject {
  libraryWithBridgeSupportURL_error(aURL: NSURL, outError: NSError): MOBridgeSupportLibrary;
}
declare const MOBridgeSupportParser: {
  alloc(): MOBridgeSupportParserAllocator;
}

interface MOBridgeSupportSymbolAllocator<InitializedType = MOBridgeSupportSymbol> extends NSObjectAllocator<MOBridgeSupportSymbol> {}
interface MOBridgeSupportSymbol extends NSObject {

  name(): NSString;
  setName(name: NSString | string): void;
}
declare const MOBridgeSupportSymbol: {
  alloc(): MOBridgeSupportSymbolAllocator;
}

interface MOBridgeSupportStructAllocator<InitializedType = MOBridgeSupportStruct> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportStruct> {}
interface MOBridgeSupportStruct extends MOBridgeSupportSymbol {

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
}
declare const MOBridgeSupportStruct: {
  alloc(): MOBridgeSupportStructAllocator;
}

interface MOBridgeSupportCFTypeAllocator<InitializedType = MOBridgeSupportCFType> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportCFType> {}
interface MOBridgeSupportCFType extends MOBridgeSupportSymbol {

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  tollFreeBridgedClassName(): NSString;
  setTollFreeBridgedClassName(tollFreeBridgedClassName: NSString | string): void;
  getTypeIDFunctionName(): NSString;
  setGetTypeIDFunctionName(getTypeIDFunctionName: NSString | string): void;
}
declare const MOBridgeSupportCFType: {
  alloc(): MOBridgeSupportCFTypeAllocator;
}

interface MOBridgeSupportOpaqueAllocator<InitializedType = MOBridgeSupportOpaque> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportOpaque> {}
interface MOBridgeSupportOpaque extends MOBridgeSupportSymbol {

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  hasMagicCookie(): boolean;
  setHasMagicCookie(hasMagicCookie: boolean): void;
}
declare const MOBridgeSupportOpaque: {
  alloc(): MOBridgeSupportOpaqueAllocator;
}

interface MOBridgeSupportConstantAllocator<InitializedType = MOBridgeSupportConstant> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportConstant> {}
interface MOBridgeSupportConstant extends MOBridgeSupportSymbol {

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  hasMagicCookie(): boolean;
  setHasMagicCookie(hasMagicCookie: boolean): void;
}
declare const MOBridgeSupportConstant: {
  alloc(): MOBridgeSupportConstantAllocator;
}

interface MOBridgeSupportStringConstantAllocator<InitializedType = MOBridgeSupportStringConstant> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportStringConstant> {}
interface MOBridgeSupportStringConstant extends MOBridgeSupportSymbol {

  value(): NSString;
  setValue(value: NSString | string): void;
  hasNSString(): boolean;
  setHasNSString(hasNSString: boolean): void;
}
declare const MOBridgeSupportStringConstant: {
  alloc(): MOBridgeSupportStringConstantAllocator;
}

interface MOBridgeSupportEnumAllocator<InitializedType = MOBridgeSupportEnum> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportEnum> {}
interface MOBridgeSupportEnum extends MOBridgeSupportSymbol {

  value(): NSNumber;
  setValue(value: NSNumber | number): void;
  value64(): NSNumber;
  setValue64(value64: NSNumber | number): void;
  ignored(): boolean;
  setIgnored(ignored: boolean): void;
  suggestion(): NSString;
  setSuggestion(suggestion: NSString | string): void;
}
declare const MOBridgeSupportEnum: {
  alloc(): MOBridgeSupportEnumAllocator;
}

interface MOBridgeSupportFunctionAllocator<InitializedType = MOBridgeSupportFunction> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportFunction> {}
interface MOBridgeSupportFunction extends MOBridgeSupportSymbol {
  addArgument(argument: MOBridgeSupportArgument): void;
  removeArgument(argument: MOBridgeSupportArgument): void;

  variadic(): boolean;
  setVariadic(variadic: boolean): void;
  sentinel(): NSNumber;
  setSentinel(sentinel: NSNumber | number): void;
  inlineFunction(): boolean;
  setInlineFunction(inlineFunction: boolean): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  returnValue(): MOBridgeSupportArgument;
  setReturnValue(returnValue: MOBridgeSupportArgument): void;
}
declare const MOBridgeSupportFunction: {
  alloc(): MOBridgeSupportFunctionAllocator;
}

interface MOBridgeSupportFunctionAliasAllocator<InitializedType = MOBridgeSupportFunctionAlias> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportFunctionAlias> {}
interface MOBridgeSupportFunctionAlias extends MOBridgeSupportSymbol {

  original(): NSString;
  setOriginal(original: NSString | string): void;
}
declare const MOBridgeSupportFunctionAlias: {
  alloc(): MOBridgeSupportFunctionAliasAllocator;
}

interface MOBridgeSupportClassAllocator<InitializedType = MOBridgeSupportClass> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportClass> {}
interface MOBridgeSupportClass extends MOBridgeSupportSymbol {
  addMethod(method: MOBridgeSupportMethod): void;
  removeMethod(method: MOBridgeSupportMethod): void;
  methodWithSelector(selector: string): MOBridgeSupportMethod;

  methods(): NSArray<any>;
  setMethods(methods: NSArray<any> | any[]): void;
}
declare const MOBridgeSupportClass: {
  alloc(): MOBridgeSupportClassAllocator;
}

interface MOBridgeSupportInformalProtocolAllocator<InitializedType = MOBridgeSupportInformalProtocol> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportInformalProtocol> {}
interface MOBridgeSupportInformalProtocol extends MOBridgeSupportSymbol {
  addMethod(method: MOBridgeSupportMethod): void;
  removeMethod(method: MOBridgeSupportMethod): void;
  methodWithSelector(selector: string): MOBridgeSupportMethod;

  methods(): NSArray<any>;
  setMethods(methods: NSArray<any> | any[]): void;
}
declare const MOBridgeSupportInformalProtocol: {
  alloc(): MOBridgeSupportInformalProtocolAllocator;
}

interface MOBridgeSupportMethodAllocator<InitializedType = MOBridgeSupportMethod> extends MOBridgeSupportSymbolAllocator<MOBridgeSupportMethod> {}
interface MOBridgeSupportMethod extends MOBridgeSupportSymbol {
  addArgument(argument: MOBridgeSupportArgument): void;
  removeArgument(argument: MOBridgeSupportArgument): void;

  selector(): string;
  setSelector(selector: string): void;
  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  returnValue(): MOBridgeSupportArgument;
  setReturnValue(returnValue: MOBridgeSupportArgument): void;
  classMethod(): boolean;
  setClassMethod(classMethod: boolean): void;
  variadic(): boolean;
  setVariadic(variadic: boolean): void;
  sentinel(): NSNumber;
  setSentinel(sentinel: NSNumber | number): void;
  ignored(): boolean;
  setIgnored(ignored: boolean): void;
  suggestion(): NSString;
  setSuggestion(suggestion: NSString | string): void;
}
declare const MOBridgeSupportMethod: {
  alloc(): MOBridgeSupportMethodAllocator;
}

interface MOBridgeSupportArgumentAllocator<InitializedType = MOBridgeSupportArgument> extends NSObjectAllocator<MOBridgeSupportArgument> {}
interface MOBridgeSupportArgument extends NSObject {
  addArgument(argument: MOBridgeSupportArgument): void;
  removeArgument(argument: MOBridgeSupportArgument): void;

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  typeModifier(): NSString;
  setTypeModifier(typeModifier: NSString | string): void;
  signature(): NSString;
  setSignature(signature: NSString | string): void;
  signature64(): NSString;
  setSignature64(signature64: NSString | string): void;
  cArrayLengthInArg(): NSString;
  setCArrayLengthInArg(cArrayLengthInArg: NSString | string): void;
  cArrayOfFixedLength(): boolean;
  setCArrayOfFixedLength(cArrayOfFixedLength: boolean): void;
  cArrayDelimitedByNull(): boolean;
  setCArrayDelimitedByNull(cArrayDelimitedByNull: boolean): void;
  cArrayOfVariableLength(): boolean;
  setCArrayOfVariableLength(cArrayOfVariableLength: boolean): void;
  cArrayLengthInReturnValue(): boolean;
  setCArrayLengthInReturnValue(cArrayLengthInReturnValue: boolean): void;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
  acceptsNull(): boolean;
  setAcceptsNull(acceptsNull: boolean): void;
  acceptsPrintfFormat(): boolean;
  setAcceptsPrintfFormat(acceptsPrintfFormat: boolean): void;
  alreadyRetained(): boolean;
  setAlreadyRetained(alreadyRetained: boolean): void;
  functionPointer(): boolean;
  setFunctionPointer(functionPointer: boolean): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  returnValue(): MOBridgeSupportArgument;
  setReturnValue(returnValue: MOBridgeSupportArgument): void;
}
declare const MOBridgeSupportArgument: {
  alloc(): MOBridgeSupportArgumentAllocator;
}

interface MochaAllocator<InitializedType = Mocha> extends NSObjectAllocator<Mocha> {
  initWithName(name: NSString | string): InitializedType;
}
interface Mocha extends NSObject {
  evalString(string: NSString | string): any;
  evalString_atURL(string: NSString | string, url: NSURL): any;
  callFunctionWithName(functionName: NSString | string): any;
  callFunctionWithName_withArguments(functionName: NSString | string, firstArg: any, ...args: any[]): any;
  callFunctionWithName_withArgumentsInArray(functionName: NSString | string, arguments: NSArray<any> | any[]): any;
  isSyntaxValidForString(string: NSString | string): boolean;
  loadFrameworkWithName(frameworkName: NSString | string): boolean;
  loadFrameworkWithName_inDirectory(frameworkName: NSString | string, directory: NSString | string): boolean;
  loadBridgeSupportFilesAtPath(path: NSString | string): boolean;
  addFrameworkSearchPath(path: NSString | string): void;
  insertFrameworkSearchPath_atIndex(path: NSString | string, idx: NSUInteger): void;
  removeFrameworkSearchPathAtIndex(idx: NSUInteger): void;
  garbageCollect(): void;
  context(): JSGlobalContextRef;
  JSValueForObject(object: any): JSValueRef;
  objectForJSValue(value: JSValueRef): any;
  objectForJSValue_unboxObjects(value: JSValueRef, unboxObjects: boolean): any;
  boxedJSObjectForObject(object: any): JSObjectRef;
  unboxedObjectForJSObject(jsObject: JSObjectRef): any;
  objectWithName(name: NSString | string): any;
  setObject_withName(object: any, name: NSString | string): JSValueRef;
  setObject_withName_attributes(object: any, name: NSString | string, attributes: JSPropertyAttributes): JSValueRef;
  removeObjectWithName(name: NSString | string): boolean;
  evalJSString(string: NSString | string): JSValueRef;
  evalJSString_scriptPath(string: NSString | string, scriptPath: NSString | string): JSValueRef;
  JSFunctionWithName(functionName: NSString | string): JSObjectRef;
  callJSFunctionWithName_withArgumentsInArray(functionName: NSString | string, arguments: NSArray<any> | any[]): JSValueRef;
  callJSFunction_withArgumentsInArray(jsFunction: JSObjectRef, arguments: NSArray<any> | any[]): JSValueRef;
  exceptionWithJSException(exception: JSValueRef): NSException;
  throwJSException(exception: JSValueRef): void;
  installBuiltins(): void;
  cleanUp(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  frameworkSearchPaths(): NSArray<any>;
  setFrameworkSearchPaths(frameworkSearchPaths: NSArray<any> | any[]): void;
  globalSymbolNames(): NSArray<any>;
  context(): JSGlobalContextRef;
}
declare const Mocha: {
  alloc(): MochaAllocator;  sharedRuntime(): Mocha;
  runtimeWithContext(ctx: JSContextRef): Mocha;
  JSValueForObject_inContext(object: any, ctx: JSContextRef): JSValueRef;
  objectForJSValue_inContext(value: JSValueRef, ctx: JSContextRef): any;
  objectForJSValue_inContext_unboxObjects(value: JSValueRef, ctx: JSContextRef, unboxObjects: boolean): any;
  arrayForJSArray_inContext(arrayValue: JSObjectRef, ctx: JSContextRef): NSArray<any>;
  dictionaryForJSHash_inContext(hashValue: JSObjectRef, ctx: JSContextRef): NSDictionary<any, any>;
  exceptionWithJSException_context(exception: JSValueRef, ctx: JSContextRef): NSException;

}

interface IMochaDelegate {
}

interface MOAllocatorAllocator<InitializedType = MOAllocator> extends NSObjectAllocator<MOAllocator> {}
interface MOAllocator extends NSObject {

  objectClass(): any;
  setObjectClass(objectClass: any): void;
}
declare const MOAllocator: {
  alloc(): MOAllocatorAllocator;  allocator(): MOAllocator;

}

interface MOBoxAllocator<InitializedType = MOBox> extends NSObjectAllocator<MOBox> {
  initWithManager_object_jsObject(manager: MOBoxManager, object: any, jsObject: JSObjectRef): InitializedType;
}
interface MOBox extends NSObject {
  disassociateObject(): void;

  representedObject(): any;
  JSObject(): JSObjectRef;
  manager(): MOBoxManager;
  representedObjectCanaryDesc(): NSString;
  count(): NSUInteger;
}
declare const MOBox: {
  alloc(): MOBoxAllocator;
}

interface MOBoxManagerAllocator<InitializedType = MOBoxManager> extends NSObjectAllocator<MOBoxManager> {
  initWithContext(context: JSGlobalContextRef): InitializedType;
}
interface MOBoxManager extends NSObject {
  cleanup(): void;
  boxForObject(object: any): MOBox;
  makeBoxForObject_jsClass(object: any, jsClass: JSClassRef): JSObjectRef;
  removeBoxForObject(object: any): void;
}
declare const MOBoxManager: {
  alloc(): MOBoxManagerAllocator;
}

interface MOBoxManagerBoxContextAllocator<InitializedType = MOBoxManagerBoxContext> extends NSObjectAllocator<MOBoxManagerBoxContext> {
  initWithManager_object(manager: MOBoxManager, object: any): InitializedType;
}
interface MOBoxManagerBoxContext extends NSObject {
  finishMakingBoxForObject(jsObject: JSObjectRef): void;
}
declare const MOBoxManagerBoxContext: {
  alloc(): MOBoxManagerBoxContextAllocator;
}

interface MOClassDescriptionAllocator<InitializedType = MOClassDescription> extends NSObjectAllocator<MOClassDescription> {}
interface MOClassDescription extends NSObject {
  registerClass(): any;
  addInstanceVariableWithName_typeEncoding(name: NSString | string, typeEncoding: NSString | string): boolean;
  addClassMethodWithSelector_typeEncoding_block(selector: string, typeEncoding: NSString | string, block: any): boolean;
  addClassMethodWithSelector_function(selector: string, functionName: MOJavaScriptObject | Function): boolean;
  addInstanceMethodWithSelector_typeEncoding_block(selector: string, typeEncoding: NSString | string, block: any): boolean;
  addInstanceMethodWithSelector_function(selector: string, functionName: MOJavaScriptObject | Function): boolean;
  addProperty(property: MOPropertyDescription): boolean;
  addProtocol(protocol: MOProtocolDescription): void;

  name(): NSString;
  descriptedClass(): any;
  superclass(): MOClassDescription;
  ancestors(): NSArray<any>;
  instanceVariables(): NSArray<any>;
  instanceVariablesWithAncestors(): NSArray<any>;
  classMethods(): NSArray<any>;
  classMethodsWithAncestors(): NSArray<any>;
  instanceMethods(): NSArray<any>;
  instanceMethodsWithAncestors(): NSArray<any>;
  properties(): NSArray<any>;
  propertiesWithAncestors(): NSArray<any>;
  protocols(): NSArray<any>;
  protocolsWithAncestors(): NSArray<any>;
}
declare const MOClassDescription: {
  alloc(): MOClassDescriptionAllocator;  descriptionForClassWithName(name: NSString | string): MOClassDescription;
  descriptionForClass(aClass: any): MOClassDescription;
  allocateDescriptionForClassWithName_superclass(name: NSString | string, superclass: any): MOClassDescription;

}

interface MOClosureAllocator<InitializedType = MOClosure> extends NSObjectAllocator<MOClosure> {
  initWithBlock(block: any): InitializedType;
}
interface MOClosure extends NSObject {

  block(): any;
  callAddress(): void;
  typeEncoding(): string;
}
declare const MOClosure: {
  alloc(): MOClosureAllocator;  closureWithBlock(block: any): MOClosure;

}

interface MOInstanceVariableDescriptionAllocator<InitializedType = MOInstanceVariableDescription> extends NSObjectAllocator<MOInstanceVariableDescription> {
  initWithName_typeEncoding(name: NSString | string, typeEncoding: NSString | string): InitializedType;
}
interface MOInstanceVariableDescription extends NSObject {

  name(): NSString;
  setName(name: NSString | string): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
}
declare const MOInstanceVariableDescription: {
  alloc(): MOInstanceVariableDescriptionAllocator;  instanceVariableWithName_typeEncoding(name: NSString | string, typeEncoding: NSString | string): MOInstanceVariableDescription;

}

interface MOJavaScriptObjectAllocator<InitializedType = MOJavaScriptObject> extends NSObjectAllocator<MOJavaScriptObject> {}
interface MOJavaScriptObject extends NSObject {

  JSObject(): JSObjectRef;
  JSContext(): JSContextRef;
}
declare const MOJavaScriptObject: {
  alloc(): MOJavaScriptObjectAllocator;  objectWithJSObject_context(jsObject: JSObjectRef, ctx: JSContextRef): MOJavaScriptObject;

}

interface MOMethodAllocator<InitializedType = MOMethod> extends NSObjectAllocator<MOMethod> {}
interface MOMethod extends NSObject {

  target(): any;
  setTarget(target: any): void;
  selector(): string;
  setSelector(selector: string): void;
  block(): any;
  setBlock(block: any): void;
}
declare const MOMethod: {
  alloc(): MOMethodAllocator;  methodWithTarget_selector(target: any, selector: string): MOMethod;

}

interface MOMethodDescriptionAllocator<InitializedType = MOMethodDescription> extends NSObjectAllocator<MOMethodDescription> {
  initWithSelector_typeEncoding(selector: string, typeEncoding: NSString | string): InitializedType;
}
interface MOMethodDescription extends NSObject {

  selector(): string;
  setSelector(selector: string): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
}
declare const MOMethodDescription: {
  alloc(): MOMethodDescriptionAllocator;  methodWithSelector_typeEncoding(selector: string, typeEncoding: NSString | string): MOMethodDescription;

}

interface MOObjCRuntimeAllocator<InitializedType = MOObjCRuntime> extends NSObjectAllocator<MOObjCRuntime> {}
interface MOObjCRuntime extends NSObject {

  classes(): NSArray<any>;
  protocols(): NSArray<any>;
}
declare const MOObjCRuntime: {
  alloc(): MOObjCRuntimeAllocator;  sharedRuntime(): MOObjCRuntime;

}

interface MOPointerAllocator<InitializedType = MOPointer> extends NSObjectAllocator<MOPointer> {
  initWithValue(value: any): InitializedType;
  initWithTypeEncoding(typeEncoding: NSString | string): InitializedType;
}
interface MOPointer extends NSObject {

  value(): any;
  setValue(value: any): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
}
declare const MOPointer: {
  alloc(): MOPointerAllocator;
}

interface MOPointerValueAllocator<InitializedType = MOPointerValue> extends NSObjectAllocator<MOPointerValue> {
  initWithPointerValue_typeEncoding(pointerValue: void, typeEncoding: NSString | string): InitializedType;
}
interface MOPointerValue extends NSObject {

  pointerValue(): void;
  typeEncoding(): NSString;
}
declare const MOPointerValue: {
  alloc(): MOPointerValueAllocator;
}

interface MOPropertyDescriptionAllocator<InitializedType = MOPropertyDescription> extends NSObjectAllocator<MOPropertyDescription> {}
interface MOPropertyDescription extends NSObject {

  name(): NSString;
  setName(name: NSString | string): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
  ivarName(): NSString;
  setIvarName(ivarName: NSString | string): void;
  getterSelector(): string;
  setGetterSelector(getterSelector: string): void;
  setterSelector(): string;
  setSetterSelector(setterSelector: string): void;
  ownershipRule(): MOObjCOwnershipRule;
  setOwnershipRule(ownershipRule: MOObjCOwnershipRule): void;
  dynamic(): boolean;
  setDynamic(dynamic: boolean): void;
  nonAtomic(): boolean;
  setNonAtomic(nonAtomic: boolean): void;
  readOnly(): boolean;
  setReadOnly(readOnly: boolean): void;
  weak(): boolean;
  setWeak(weak: boolean): void;
}
declare const MOPropertyDescription: {
  alloc(): MOPropertyDescriptionAllocator;
}

interface MOProtocolDescriptionAllocator<InitializedType = MOProtocolDescription> extends NSObjectAllocator<MOProtocolDescription> {}
interface MOProtocolDescription extends NSObject {
  addClassMethod_required(method: MOMethodDescription, isRequired: boolean): void;
  addInstanceMethod_required(method: MOMethodDescription, isRequired: boolean): void;
  addProperty_required(property: MOPropertyDescription, isRequired: boolean): void;
  addProtocol(protocol: MOProtocolDescription): void;

  name(): NSString;
  requiredClassMethods(): NSArray<any>;
  optionalClassMethods(): NSArray<any>;
  requiredInstanceMethods(): NSArray<any>;
  optionalInstanceMethods(): NSArray<any>;
  properties(): NSArray<any>;
  protocols(): NSArray<any>;
  protocol(): Protocol;
}
declare const MOProtocolDescription: {
  alloc(): MOProtocolDescriptionAllocator;  descriptionForProtocol(protocol: Protocol): MOProtocolDescription;
  descriptionForProtocolWithName(name: NSString | string): MOProtocolDescription;
  allocateDescriptionForProtocolWithName(name: NSString | string): MOProtocolDescription;

}

interface MOStructAllocator<InitializedType = MOStruct> extends NSObjectAllocator<MOStruct> {
  initWithName_memberNames_runtime(name: NSString | string, memberNames: NSArray<any> | any[], runtime: Mocha): InitializedType;
}
interface MOStruct extends NSObject {
  objectForMemberName(name: NSString | string): any;
  setObject_forMemberName(obj: any, name: NSString | string): void;

  name(): NSString;
  memberNames(): NSArray<any>;
}
declare const MOStruct: {
  alloc(): MOStructAllocator;  structureWithName_memberNames_runtime(name: NSString | string, memberNames: NSArray<any> | any[], runtime: Mocha): MOStruct;

}

interface MOUndefinedAllocator<InitializedType = MOUndefined> extends NSObjectAllocator<MOUndefined> {}
interface MOUndefined extends NSObject {
}
declare const MOUndefined: {
  alloc(): MOUndefinedAllocator;  undefined(): MOUndefined;

}

interface MOFunctionArgumentAllocator<InitializedType = MOFunctionArgument> extends NSObjectAllocator<MOFunctionArgument> {}
interface MOFunctionArgument extends NSObject {
  setTypeEncoding_withCustomStorage(typeEncoding: string, storagePtr: void): void;
  setPointerTypeEncoding_withCustomStorage(pointerTypeEncoding: NSString | string, storagePtr: void): void;
  setStructureTypeEncoding_withCustomStorage(structureTypeEncoding: NSString | string, storagePtr: void): void;
  getValueAsJSValueInContext(ctx: JSContextRef): JSValueRef;
  setValueAsJSValue_context(value: JSValueRef, ctx: JSContextRef): void;
  getValueAsJSValueInContext_dereference(ctx: JSContextRef, dereference: boolean): JSValueRef;
  setValueAsJSValue_context_dereference(value: JSValueRef, ctx: JSContextRef, dereference: boolean): void;

  typeEncoding(): string;
  setTypeEncoding(typeEncoding: string): void;
  pointerTypeEncoding(): NSString;
  setPointerTypeEncoding(pointerTypeEncoding: NSString | string): void;
  structureTypeEncoding(): NSString;
  setStructureTypeEncoding(structureTypeEncoding: NSString | string): void;
  pointer(): MOPointer;
  setPointer(pointer: MOPointer): void;
  returnValue(): boolean;
  setReturnValue(returnValue: boolean): void;
  ffiType(): ffi_type;
  storage(): void;
  typeDescription(): NSString;
}
declare const MOFunctionArgument: {
  alloc(): MOFunctionArgumentAllocator;  getAlignment_ofTypeEncoding(alignment: size_t, encoding: string): boolean;
  getSize_ofTypeEncoding(size: size_t, encoding: string): boolean;
  ffiTypeForTypeEncoding(encoding: string): ffi_type;
  descriptionOfTypeEncoding(encoding: string): NSString;
  descriptionOfTypeEncoding_fullTypeEncoding(typeEncoding: string, fullTypeEncoding: NSString | string): NSString;
  sizeOfStructureTypeEncoding(encoding: NSString | string): size_t;
  structureNameFromStructureTypeEncoding(encoding: NSString | string): NSString;
  structureTypeEncodingDescription(structureTypeEncoding: NSString | string): NSString;
  structureFullTypeEncodingFromStructureTypeEncoding(encoding: NSString | string): NSString;
  structureFullTypeEncodingFromStructureName(structureName: NSString | string): NSString;
  typeEncodingsFromStructureTypeEncoding(structureTypeEncoding: NSString | string): NSArray<any>;
  typeEncodingsFromStructureTypeEncoding_parsedCount(structureTypeEncoding: NSString | string, count: NSInteger): NSArray<any>;
  fromJSValue_inContext_typeEncoding_fullTypeEncoding_storage(value: JSValueRef, ctx: JSContextRef, typeEncoding: string, fullTypeEncoding: NSString | string, ptr: void): boolean;
  toJSValue_inContext_typeEncoding_fullTypeEncoding_storage(value: JSValueRef, ctx: JSContextRef, typeEncoding: string, fullTypeEncoding: NSString | string, ptr: void): boolean;
  structureFromJSObject_inContext_inParentJSValueRef_cString_storage(object: JSObjectRef, ctx: JSContextRef, parentValue: JSValueRef, c: string, ptr: void): NSInteger;
  structureToJSValue_inContext_cString_storage(value: JSValueRef, ctx: JSContextRef, c: string, ptr: void): NSInteger;
  structureToJSValue_inContext_cString_storage_initialValues_initialValueCount_convertedValueCount(value: JSValueRef, ctx: JSContextRef, c: string, ptr: void, initialValues: JSValueRef, initialValueCount: NSInteger, convertedValueCount: NSInteger): NSInteger;

}

interface MOJSBlockAllocator<InitializedType = MOJSBlock> extends NSObjectAllocator<MOJSBlock> {
  initWithSignature_function(signature: string, functionName: MOJavaScriptObject | Function): InitializedType;
}
interface MOJSBlock extends NSObject, INSCopying {

  function(): MOJavaScriptObject;
  signature(): NSMethodSignature;
}
declare const MOJSBlock: {
  alloc(): MOJSBlockAllocator;  blockWithSignature_function(signature: NSString | string, functionName: MOJavaScriptObject | Function): MOJSBlock;

}

interface MOMapTableAllocator<InitializedType = MOMapTable> extends NSObjectAllocator<MOMapTable> {}
interface MOMapTable extends NSObject, INSFastEnumeration {
  keyEnumerator(): NSEnumerator<any>;
  objectEnumerator(): NSEnumerator<any>;
  count(): NSUInteger;
  allKeys(): NSArray<any>;
  allObjects(): NSArray<any>;
  objectForKey(key: any): any;
  setObject_forKey(value: any, key: any): void;
  removeObjectForKey(key: any): void;
  removeAllObjects(): void;
}
declare const MOMapTable: {
  alloc(): MOMapTableAllocator;  mapTableWithStrongToStrongObjects(): MOMapTable;
  mapTableWithStrongToUnretainedObjects(): MOMapTable;
  mapTableWithUnretainedToStrongObjects(): MOMapTable;
  mapTableWithUnretainedToUnretainedObjects(): MOMapTable;

}

interface TDAlternationAllocator<InitializedType = TDAlternation> extends TDCollectionParserAllocator<TDAlternation> {}
interface TDAlternation extends TDCollectionParser {
}
declare const TDAlternation: {
  alloc(): TDAlternationAllocator;  alternation(): any;

}

interface TDAnyAllocator<InitializedType = TDAny> extends TDTerminalAllocator<TDAny> {}
interface TDAny extends TDTerminal {
}
declare const TDAny: {
  alloc(): TDAnyAllocator;  any(): any;

}

interface TDAssemblyAllocator<InitializedType = TDAssembly> extends NSObjectAllocator<TDAssembly> {
  initWithString(s: NSString | string): InitializedType;
}
interface TDAssembly extends NSObject, INSCopying {
  peek(): any;
  next(): any;
  hasMore(): boolean;
  consumedObjectsJoinedByString(delimiter: NSString | string): NSString;
  remainingObjectsJoinedByString(delimiter: NSString | string): NSString;
  pop(): any;
  push(object: any): void;
  isStackEmpty(): boolean;
  objectsAbove(fence: any): NSArray<any>;

  length(): NSUInteger;
  objectsConsumed(): NSUInteger;
  objectsRemaining(): NSUInteger;
  defaultDelimiter(): NSString;
  stack(): NSMutableArray<any>;
  target(): any;
  setTarget(target: any): void;
}
declare const TDAssembly: {
  alloc(): TDAssemblyAllocator;  assemblyWithString(s: NSString | string): any;

}

interface TDCaseInsensitiveLiteralAllocator<InitializedType = TDCaseInsensitiveLiteral> extends TDLiteralAllocator<TDCaseInsensitiveLiteral> {}
interface TDCaseInsensitiveLiteral extends TDLiteral {
}
declare const TDCaseInsensitiveLiteral: {
  alloc(): TDCaseInsensitiveLiteralAllocator;
}

interface TDCharAllocator<InitializedType = TDChar> extends TDTerminalAllocator<TDChar> {}
interface TDChar extends TDTerminal {
}
declare const TDChar: {
  alloc(): TDCharAllocator;  char(): any;

}

interface TDCharacterAssemblyAllocator<InitializedType = TDCharacterAssembly> extends TDAssemblyAllocator<TDCharacterAssembly> {}
interface TDCharacterAssembly extends TDAssembly {
}
declare const TDCharacterAssembly: {
  alloc(): TDCharacterAssemblyAllocator;
}

interface TDCollectionParserAllocator<InitializedType = TDCollectionParser> extends TDParserAllocator<TDCollectionParser> {}
interface TDCollectionParser extends TDParser {
  add(p: TDParser): void;

  subparsers(): NSMutableArray<any>;
}
declare const TDCollectionParser: {
  alloc(): TDCollectionParserAllocator;
}

interface TDCommentAllocator<InitializedType = TDComment> extends TDTerminalAllocator<TDComment> {}
interface TDComment extends TDTerminal {
}
declare const TDComment: {
  alloc(): TDCommentAllocator;  comment(): any;

}

interface TDCommentStateAllocator<InitializedType = TDCommentState> extends TDTokenizerStateAllocator<TDCommentState> {}
interface TDCommentState extends TDTokenizerState {
  addSingleLineStartSymbol(start: NSString | string): void;
  removeSingleLineStartSymbol(start: NSString | string): void;
  addMultiLineStartSymbol_endSymbol(start: NSString | string, end: NSString | string): void;
  removeMultiLineStartSymbol(start: NSString | string): void;

  reportsCommentTokens(): boolean;
  setReportsCommentTokens(reportsCommentTokens: boolean): void;
  balancesEOFTerminatedComments(): boolean;
  setBalancesEOFTerminatedComments(balancesEOFTerminatedComments: boolean): void;
}
declare const TDCommentState: {
  alloc(): TDCommentStateAllocator;
}

interface TDDigitAllocator<InitializedType = TDDigit> extends TDTerminalAllocator<TDDigit> {}
interface TDDigit extends TDTerminal {
}
declare const TDDigit: {
  alloc(): TDDigitAllocator;  digit(): any;

}

interface TDEmptyAllocator<InitializedType = TDEmpty> extends TDParserAllocator<TDEmpty> {}
interface TDEmpty extends TDParser {
}
declare const TDEmpty: {
  alloc(): TDEmptyAllocator;  empty(): any;

}

interface TDLetterAllocator<InitializedType = TDLetter> extends TDTerminalAllocator<TDLetter> {}
interface TDLetter extends TDTerminal {
}
declare const TDLetter: {
  alloc(): TDLetterAllocator;  letter(): any;

}

interface TDLiteralAllocator<InitializedType = TDLiteral> extends TDTerminalAllocator<TDLiteral> {}
interface TDLiteral extends TDTerminal {
}
declare const TDLiteral: {
  alloc(): TDLiteralAllocator;  literalWithString(s: NSString | string): any;

}

interface TDLowercaseWordAllocator<InitializedType = TDLowercaseWord> extends TDWordAllocator<TDLowercaseWord> {}
interface TDLowercaseWord extends TDWord {
}
declare const TDLowercaseWord: {
  alloc(): TDLowercaseWordAllocator;
}

interface TDMultiLineCommentStateAllocator<InitializedType = TDMultiLineCommentState> extends TDTokenizerStateAllocator<TDMultiLineCommentState> {}
interface TDMultiLineCommentState extends TDTokenizerState {
}
declare const TDMultiLineCommentState: {
  alloc(): TDMultiLineCommentStateAllocator;
}

interface TDNonReservedWordAllocator<InitializedType = TDNonReservedWord> extends TDWordAllocator<TDNonReservedWord> {}
interface TDNonReservedWord extends TDWord {
}
declare const TDNonReservedWord: {
  alloc(): TDNonReservedWordAllocator;
}

interface TDNumAllocator<InitializedType = TDNum> extends TDTerminalAllocator<TDNum> {}
interface TDNum extends TDTerminal {
}
declare const TDNum: {
  alloc(): TDNumAllocator;  num(): any;

}

interface TDNumberStateAllocator<InitializedType = TDNumberState> extends TDTokenizerStateAllocator<TDNumberState> {}
interface TDNumberState extends TDTokenizerState {

  allowsTrailingDot(): boolean;
  setAllowsTrailingDot(allowsTrailingDot: boolean): void;
}
declare const TDNumberState: {
  alloc(): TDNumberStateAllocator;
}

interface TDParserAllocator<InitializedType = TDParser> extends NSObjectAllocator<TDParser> {}
interface TDParser extends NSObject {
  setAssembler_selector(a: any, sel: string): void;
  bestMatchFor(inAssembly: TDAssembly): TDAssembly;
  completeMatchFor(inAssembly: TDAssembly): TDAssembly;
  allMatchesFor(inAssemblies: NSSet<any>): NSSet<any>;

  assembler(): any;
  setAssembler(assembler: any): void;
  selector(): string;
  setSelector(selector: string): void;
  name(): NSString;
  setName(name: NSString | string): void;
}
declare const TDParser: {
  alloc(): TDParserAllocator;  parser(): any;

}

interface TDQuoteStateAllocator<InitializedType = TDQuoteState> extends TDTokenizerStateAllocator<TDQuoteState> {}
interface TDQuoteState extends TDTokenizerState {

  balancesEOFTerminatedQuotes(): boolean;
  setBalancesEOFTerminatedQuotes(balancesEOFTerminatedQuotes: boolean): void;
}
declare const TDQuoteState: {
  alloc(): TDQuoteStateAllocator;
}

interface TDQuotedStringAllocator<InitializedType = TDQuotedString> extends TDTerminalAllocator<TDQuotedString> {}
interface TDQuotedString extends TDTerminal {
}
declare const TDQuotedString: {
  alloc(): TDQuotedStringAllocator;  quotedString(): any;

}

interface TDReaderAllocator<InitializedType = TDReader> extends NSObjectAllocator<TDReader> {
  initWithString(s: NSString | string): InitializedType;
}
interface TDReader extends NSObject {
  read(): NSInteger;
  unread(): void;

  string(): NSString;
  setString(string: NSString | string): void;
}
declare const TDReader: {
  alloc(): TDReaderAllocator;
}

interface TDRepetitionAllocator<InitializedType = TDRepetition> extends TDParserAllocator<TDRepetition> {
  initWithSubparser(p: TDParser): InitializedType;
}
interface TDRepetition extends TDParser {
  setPreassembler_selector(a: any, sel: string): void;

  subparser(): TDParser;
  preassembler(): any;
  setPreassembler(preassembler: any): void;
  preassemblerSelector(): string;
  setPreassemblerSelector(preassemblerSelector: string): void;
}
declare const TDRepetition: {
  alloc(): TDRepetitionAllocator;  repetitionWithSubparser(p: TDParser): any;

}

interface TDReservedWordAllocator<InitializedType = TDReservedWord> extends TDWordAllocator<TDReservedWord> {}
interface TDReservedWord extends TDWord {
}
declare const TDReservedWord: {
  alloc(): TDReservedWordAllocator;  setReservedWords(inWords: NSArray<any> | any[]): void;

}

interface TDScientificNumberStateAllocator<InitializedType = TDScientificNumberState> extends TDNumberStateAllocator<TDScientificNumberState> {}
interface TDScientificNumberState extends TDNumberState {
}
declare const TDScientificNumberState: {
  alloc(): TDScientificNumberStateAllocator;
}

interface TDSequenceAllocator<InitializedType = TDSequence> extends TDCollectionParserAllocator<TDSequence> {}
interface TDSequence extends TDCollectionParser {
}
declare const TDSequence: {
  alloc(): TDSequenceAllocator;  sequence(): any;

}

interface TDTokenAllocator<InitializedType = TDToken> extends NSObjectAllocator<TDToken> {
  initWithTokenType_stringValue_floatValue(t: TDTokenType, s: NSString | string, n: CGFloat): InitializedType;
}
interface TDToken extends NSObject {
  isEqualIgnoringCase(obj: any): boolean;
  debugDescription(): NSString;

  whitespace(): boolean;
  number(): boolean;
  quotedString(): boolean;
  symbol(): boolean;
  word(): boolean;
  comment(): boolean;
  tokenType(): TDTokenType;
  floatValue(): CGFloat;
  stringValue(): NSString;
  value(): any;
}
declare const TDToken: {
  alloc(): TDTokenAllocator;  EOFToken(): TDToken;
  tokenWithTokenType_stringValue_floatValue(t: TDTokenType, s: NSString | string, n: CGFloat): any;

}

interface TDSignificantWhitespaceStateAllocator<InitializedType = TDSignificantWhitespaceState> extends TDWhitespaceStateAllocator<TDSignificantWhitespaceState> {}
interface TDSignificantWhitespaceState extends TDWhitespaceState {
}
declare const TDSignificantWhitespaceState: {
  alloc(): TDSignificantWhitespaceStateAllocator;
}

interface TDSingleLineCommentStateAllocator<InitializedType = TDSingleLineCommentState> extends TDTokenizerStateAllocator<TDSingleLineCommentState> {}
interface TDSingleLineCommentState extends TDTokenizerState {
}
declare const TDSingleLineCommentState: {
  alloc(): TDSingleLineCommentStateAllocator;
}

interface TDSpecificCharAllocator<InitializedType = TDSpecificChar> extends TDTerminalAllocator<TDSpecificChar> {
  initWithSpecificChar(c: NSInteger): InitializedType;
}
interface TDSpecificChar extends TDTerminal {
}
declare const TDSpecificChar: {
  alloc(): TDSpecificCharAllocator;  specificCharWithChar(c: NSInteger): any;

}

interface TDSymbolAllocator<InitializedType = TDSymbol> extends TDTerminalAllocator<TDSymbol> {}
interface TDSymbol extends TDTerminal {
}
declare const TDSymbol: {
  alloc(): TDSymbolAllocator;  symbol(): any;
  symbolWithString(s: NSString | string): any;

}

interface TDSymbolNodeAllocator<InitializedType = TDSymbolNode> extends NSObjectAllocator<TDSymbolNode> {
  initWithParent_character(p: TDSymbolNode, c: NSInteger): InitializedType;
}
interface TDSymbolNode extends NSObject {

  ancestry(): NSString;
}
declare const TDSymbolNode: {
  alloc(): TDSymbolNodeAllocator;
}

interface TDSymbolRootNodeAllocator<InitializedType = TDSymbolRootNode> extends TDSymbolNodeAllocator<TDSymbolRootNode> {}
interface TDSymbolRootNode extends TDSymbolNode {
  add(s: NSString | string): void;
  remove(s: NSString | string): void;
  nextSymbol_startingWith(r: TDReader, cin: NSInteger): NSString;
}
declare const TDSymbolRootNode: {
  alloc(): TDSymbolRootNodeAllocator;
}

interface TDSymbolStateAllocator<InitializedType = TDSymbolState> extends TDTokenizerStateAllocator<TDSymbolState> {}
interface TDSymbolState extends TDTokenizerState {
  add(s: NSString | string): void;
  remove(s: NSString | string): void;
}
declare const TDSymbolState: {
  alloc(): TDSymbolStateAllocator;
}

interface TDTerminalAllocator<InitializedType = TDTerminal> extends TDParserAllocator<TDTerminal> {
  initWithString(s: NSString | string | null): InitializedType;
}
interface TDTerminal extends TDParser {
  discard(): TDTerminal;

  string(): NSString;
}
declare const TDTerminal: {
  alloc(): TDTerminalAllocator;
}

declare enum TDTokenType {
  TDTokenTypeEOF,
  TDTokenTypeNumber,
  TDTokenTypeQuotedString,
  TDTokenTypeSymbol,
  TDTokenTypeWord,
  TDTokenTypeWhitespace,
  TDTokenTypeComment,
}

interface TDTokenArraySourceAllocator<InitializedType = TDTokenArraySource> extends NSObjectAllocator<TDTokenArraySource> {
  initWithTokenizer_delimiter(t: TDTokenizer, s: NSString | string): InitializedType;
}
interface TDTokenArraySource extends NSObject {
  hasMore(): boolean;
  nextTokenArray(): NSArray<any>;
}
declare const TDTokenArraySource: {
  alloc(): TDTokenArraySourceAllocator;
}

interface TDTokenAssemblyAllocator<InitializedType = TDTokenAssembly> extends TDAssemblyAllocator<TDTokenAssembly> {
  initWithTokenzier(t: TDTokenizer): InitializedType;
  initWithTokenArray(a: NSArray<any> | any[]): InitializedType;
}
interface TDTokenAssembly extends TDAssembly, INSCopying {

  preservesWhitespaceTokens(): boolean;
  setPreservesWhitespaceTokens(preservesWhitespaceTokens: boolean): void;
}
declare const TDTokenAssembly: {
  alloc(): TDTokenAssemblyAllocator;  assemblyWithTokenizer(t: TDTokenizer): any;
  assemblyWithTokenArray(a: NSArray<any> | any[]): any;

}

interface TDTokenizerAllocator<InitializedType = TDTokenizer> extends NSObjectAllocator<TDTokenizer> {
  initWithString(s: NSString | string): InitializedType;
}
interface TDTokenizer extends NSObject {
  nextToken(): TDToken;
  setTokenizerState_from_to(state: TDTokenizerState, start: NSInteger, end: NSInteger): void;

  string(): NSString;
  setString(string: NSString | string): void;
  numberState(): TDNumberState;
  setNumberState(numberState: TDNumberState): void;
  quoteState(): TDQuoteState;
  setQuoteState(quoteState: TDQuoteState): void;
  commentState(): TDCommentState;
  setCommentState(commentState: TDCommentState): void;
  symbolState(): TDSymbolState;
  setSymbolState(symbolState: TDSymbolState): void;
  whitespaceState(): TDWhitespaceState;
  setWhitespaceState(whitespaceState: TDWhitespaceState): void;
  wordState(): TDWordState;
  setWordState(wordState: TDWordState): void;
}
declare const TDTokenizer: {
  alloc(): TDTokenizerAllocator;  tokenizer(): any;
  tokenizerWithString(s: NSString | string): any;

}

interface TDTokenizerStateAllocator<InitializedType = TDTokenizerState> extends NSObjectAllocator<TDTokenizerState> {}
interface TDTokenizerState extends NSObject {
  nextTokenFromReader_startingWith_tokenizer(r: TDReader, cin: NSInteger, t: TDTokenizer): TDToken;
}
declare const TDTokenizerState: {
  alloc(): TDTokenizerStateAllocator;
}

interface TDTrackAllocator<InitializedType = TDTrack> extends TDSequenceAllocator<TDTrack> {}
interface TDTrack extends TDSequence {
}
declare const TDTrack: {
  alloc(): TDTrackAllocator;  track(): any;

}

interface TDTrackExceptionAllocator<InitializedType = TDTrackException> extends NSExceptionAllocator<TDTrackException> {}
interface TDTrackException extends NSException {
}
declare const TDTrackException: {
  alloc(): TDTrackExceptionAllocator;
}

interface TDUppercaseWordAllocator<InitializedType = TDUppercaseWord> extends TDWordAllocator<TDUppercaseWord> {}
interface TDUppercaseWord extends TDWord {
}
declare const TDUppercaseWord: {
  alloc(): TDUppercaseWordAllocator;
}

interface TDWhitespaceStateAllocator<InitializedType = TDWhitespaceState> extends TDTokenizerStateAllocator<TDWhitespaceState> {}
interface TDWhitespaceState extends TDTokenizerState {
  isWhitespaceChar(cin: NSInteger): boolean;
  setWhitespaceChars_from_to(yn: boolean, start: NSInteger, end: NSInteger): void;

  reportsWhitespaceTokens(): boolean;
  setReportsWhitespaceTokens(reportsWhitespaceTokens: boolean): void;
}
declare const TDWhitespaceState: {
  alloc(): TDWhitespaceStateAllocator;
}

interface TDWordAllocator<InitializedType = TDWord> extends TDTerminalAllocator<TDWord> {}
interface TDWord extends TDTerminal {
}
declare const TDWord: {
  alloc(): TDWordAllocator;  word(): any;

}

interface TDWordOrReservedStateAllocator<InitializedType = TDWordOrReservedState> extends TDWordStateAllocator<TDWordOrReservedState> {}
interface TDWordOrReservedState extends TDWordState {
  addReservedWord(s: NSString | string): void;
}
declare const TDWordOrReservedState: {
  alloc(): TDWordOrReservedStateAllocator;
}

interface TDWordStateAllocator<InitializedType = TDWordState> extends TDTokenizerStateAllocator<TDWordState> {}
interface TDWordState extends TDTokenizerState {
  setWordChars_from_to(yn: boolean, start: NSInteger, end: NSInteger): void;
  isWordChar(c: NSInteger): boolean;
}
declare const TDWordState: {
  alloc(): TDWordStateAllocator;
}

interface ECCommandLineExampleCommandAllocator<InitializedType = ECCommandLineExampleCommand> extends ECCommandLineCommandAllocator<ECCommandLineExampleCommand> {}
interface ECCommandLineExampleCommand extends ECCommandLineCommand {
}
declare const ECCommandLineExampleCommand: {
  alloc(): ECCommandLineExampleCommandAllocator;
}

interface ECCommandLineCommandAllocator<InitializedType = ECCommandLineCommand> extends NSObjectAllocator<ECCommandLineCommand> {}
interface ECCommandLineCommand extends NSObject {
  enumerateArguments(block: ArgumentBlock): void;
  engine_processCommands(engine: ECCommandLineEngine, commands: NSMutableArray<any> | any[]): ECCommandLineResult;
  engine_willProcessWithArguments(engine: ECCommandLineEngine, arguments: NSMutableArray<any> | any[]): ECCommandLineResult;
  engine_didProcessWithArguments(engine: ECCommandLineEngine, arguments: NSMutableArray<any> | any[]): ECCommandLineResult;
  help(): NSString;
  summaryAs_parentName(name: NSString | string, parentName: NSString | string): NSString;
  usageAs_parentName_engine(name: NSString | string, parentName: NSString | string, engine: ECCommandLineEngine): NSString;
  subcommandSummaryAs(name: NSString | string): NSString;
  resolveCommandPath(commands: NSMutableArray<any> | any[]): ECCommandLineCommand;

  name(): NSString;
  arguments(): NSArray<any>;
  parentCommand(): ECCommandLineCommand;
}
declare const ECCommandLineCommand: {
  alloc(): ECCommandLineCommandAllocator;  commandWithName_info_parentCommand(name: NSString | string, info: NSDictionary<any, any> | {[key: string]: any}, parentCommand: ECCommandLineCommand): ECCommandLineCommand;

}

declare enum ECCommandLineArgumentMode {
  ECCommandLineArgumentModeNone,
  ECCommandLineArgumentModeRequired,
  ECCommandLineArgumentModeOptinal,
}

interface ECCommandLineEngineAllocator<InitializedType = ECCommandLineEngine> extends NSObjectAllocator<ECCommandLineEngine> {
  initWithDelegate(delegate: any): InitializedType;
}
interface ECCommandLineEngine extends NSObject, IECIODelegate {
  processArguments_argv(argc: number, argv: string): ECCommandLineResult;
  showUsage(): void;
  outputDescription(description: NSString | string): void;
  info(): NSDictionary<any, any>;
  commandWithName(name: NSString | string): ECCommandLineCommand;
  optionWithName(name: NSString | string): ECCommandLineOption;
  paddingLength(): NSUInteger;
  exitWithResult(result: ECCommandLineResult): void;

  name(): NSString;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const ECCommandLineEngine: {
  alloc(): ECCommandLineEngineAllocator;  addCommandNamed_withInfo_toDictionary_parentCommand(mainName: NSString | string, info: NSDictionary<any, any> | {[key: string]: any}, dictionary: NSMutableDictionary<any, any> | {[key: string]: any}, parentCommand: ECCommandLineCommand): void;
  commandsInDisplayOrder(commands: NSDictionary<any, any> | {[key: string]: any}): NSArray<any>;

}

interface IECCommandLineEngineDelegate {
  engineDidFinishLaunching(engine: ECCommandLineEngine): void;
  engine_willProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
  engine_didProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
}

interface ECCommandLineHelpCommandAllocator<InitializedType = ECCommandLineHelpCommand> extends ECCommandLineCommandAllocator<ECCommandLineHelpCommand> {}
interface ECCommandLineHelpCommand extends ECCommandLineCommand {
}
declare const ECCommandLineHelpCommand: {
  alloc(): ECCommandLineHelpCommandAllocator;
}

interface ECCommandLineMissingClassCommandAllocator<InitializedType = ECCommandLineMissingClassCommand> extends ECCommandLineCommandAllocator<ECCommandLineMissingClassCommand> {}
interface ECCommandLineMissingClassCommand extends ECCommandLineCommand {
}
declare const ECCommandLineMissingClassCommand: {
  alloc(): ECCommandLineMissingClassCommandAllocator;
}

interface ECCommandLineOptionAllocator<InitializedType = ECCommandLineOption> extends NSObjectAllocator<ECCommandLineOption> {}
interface ECCommandLineOption extends NSObject {
  mode(): ECCommandLineOptionMode;
  shortOption(): string;
  help(): NSString;
  longUsage(): NSString;
  shortUsage(): NSString;
  defaultValue(): any;

  name(): NSString;
  value(): any;
  setValue(value: any): void;
}
declare const ECCommandLineOption: {
  alloc(): ECCommandLineOptionAllocator;  optionWithName_info(name: NSString | string, info: NSDictionary<any, any> | {[key: string]: any}): ECCommandLineOption;

}

declare enum ECCommandLineOptionMode {
  ECCommandLineOptionModeNone,
  ECCommandLineOptionModeRequired,
  ECCommandLineOptionModeOptinal,
}

declare enum ECCommandLineResult {
  ECCommandLineResultOKButTerminate = -2,
  ECCommandLineResultStayRunning = -1,
  ECCommandLineResultOK = 0,
  ECCommandLineResultUnknownCommand,
  ECCommandLineResultMissingCommandClass,
  ECCommandLineResultNotImplemented,
  ECCommandLineResultMissingArguments,
  ECCommandLineResultImplementationReturnedError,
  ECCommandLineResultMissingBundle,
  ECCommandLineResultJSONConversionFailed,
  ECCommandLineResultJSONOutputFailed,
}

interface BITCrashDetailsAllocator<InitializedType = BITCrashDetails> extends NSObjectAllocator<BITCrashDetails> {}
interface BITCrashDetails extends NSObject {

  incidentIdentifier(): NSString;
  reporterKey(): NSString;
  signal(): NSString;
  exceptionName(): NSString;
  exceptionReason(): NSString;
  appStartTime(): NSDate;
  crashTime(): NSDate;
  osVersion(): NSString;
  osBuild(): NSString;
  appVersion(): NSString;
  appBuild(): NSString;
  appProcessIdentifier(): NSUInteger;
}
declare const BITCrashDetails: {
  alloc(): BITCrashDetailsAllocator;
}

interface BITCrashExceptionApplicationAllocator<InitializedType = BITCrashExceptionApplication> extends NSApplicationAllocator<BITCrashExceptionApplication> {}
interface BITCrashExceptionApplication extends NSApplication {
}
declare const BITCrashExceptionApplication: {
  alloc(): BITCrashExceptionApplicationAllocator;
}

interface BITCrashManagerAllocator<InitializedType = BITCrashManager> extends BITHockeyBaseManagerAllocator<BITCrashManager> {}
interface BITCrashManager extends BITHockeyBaseManager {
  setCrashCallbacks(callbacks: BITCrashManagerCallbacks): void;
  handleUserInput_withUserProvidedMetaData(userInput: BITCrashManagerUserInput, userProvidedMetaData: BITCrashMetaData): boolean;
  setCrashReportUIHandler(crashReportUIHandler: BITCustomCrashReportUIHandler): void;
  generateTestCrash(): void;

  askUserDetails(): boolean;
  setAskUserDetails(askUserDetails: boolean): void;
  disableMachExceptionHandler(): boolean;
  setDisableMachExceptionHandler(disableMachExceptionHandler: boolean): void;
  autoSubmitCrashReport(): boolean;
  setAutoSubmitCrashReport(autoSubmitCrashReport: boolean): void;
  didCrashInLastSession(): boolean;
  lastSessionCrashDetails(): BITCrashDetails;
  timeintervalCrashInLastSessionOccured(): NSTimeInterval;
}
declare const BITCrashManager: {
  alloc(): BITCrashManagerAllocator;
}

declare type BITCrashManagerCallbacks = {
  context: void
  handleSignal: BITCrashManagerPostCrashSignalCallback
}

declare enum BITCrashManagerUserInput {
  BITCrashManagerUserInputDontSend = 0,
  BITCrashManagerUserInputSend = 1,
  BITCrashManagerUserInputAlwaysSend = 2,
}

interface IBITCrashManagerDelegate {
  crashManagerWillSendCrashReport(crashManager: BITCrashManager): void;
  crashManager_didFailWithError(crashManager: BITCrashManager, error: NSError): void;
  crashManagerDidFinishSendingCrashReport(crashManager: BITCrashManager): void;
}

interface BITCrashMetaDataAllocator<InitializedType = BITCrashMetaData> extends NSObjectAllocator<BITCrashMetaData> {}
interface BITCrashMetaData extends NSObject {

  userDescription(): NSString;
  setUserDescription(userDescription: NSString | string): void;
  userName(): NSString;
  setUserName(userName: NSString | string): void;
  userEmail(): NSString;
  setUserEmail(userEmail: NSString | string): void;
  userID(): NSString;
  setUserID(userID: NSString | string): void;
}
declare const BITCrashMetaData: {
  alloc(): BITCrashMetaDataAllocator;
}

interface BITFeedbackManagerAllocator<InitializedType = BITFeedbackManager> extends BITHockeyBaseManagerAllocator<BITFeedbackManager> {}
interface BITFeedbackManager extends BITHockeyBaseManager {
  showFeedbackWindow(): void;

  requireUserName(): BITFeedbackUserDataElement;
  setRequireUserName(requireUserName: BITFeedbackUserDataElement): void;
  requireUserEmail(): BITFeedbackUserDataElement;
  setRequireUserEmail(requireUserEmail: BITFeedbackUserDataElement): void;
  showAlertOnIncomingMessages(): boolean;
  setShowAlertOnIncomingMessages(showAlertOnIncomingMessages: boolean): void;
}
declare const BITFeedbackManager: {
  alloc(): BITFeedbackManagerAllocator;
}

declare enum BITFeedbackUserDataElement {
  BITFeedbackUserDataElementDontShow = 0,
  BITFeedbackUserDataElementOptional = 1,
  BITFeedbackUserDataElementRequired = 2,
}

interface BITFeedbackWindowControllerAllocator<InitializedType = BITFeedbackWindowController> extends NSWindowControllerAllocator<BITFeedbackWindowController> {
  initWithManager(feedbackManager: BITFeedbackManager): InitializedType;
}
interface BITFeedbackWindowController extends NSWindowController {
}
declare const BITFeedbackWindowController: {
  alloc(): BITFeedbackWindowControllerAllocator;
}

interface BITHockeyAttachmentAllocator<InitializedType = BITHockeyAttachment> extends NSObjectAllocator<BITHockeyAttachment> {
  initWithFilename_hockeyAttachmentData_contentType(filename: NSString | string, hockeyAttachmentData: NSData, contentType: NSString | string): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface BITHockeyAttachment extends NSObject, INSCoding, INSCoding, INSCoding {

  filename(): NSString;
  hockeyAttachmentData(): NSData;
  contentType(): NSString;
}
declare const BITHockeyAttachment: {
  alloc(): BITHockeyAttachmentAllocator;
}

interface BITHockeyBaseManagerAllocator<InitializedType = BITHockeyBaseManager> extends NSObjectAllocator<BITHockeyBaseManager> {}
interface BITHockeyBaseManager extends NSObject {

  serverURL(): NSString;
  setServerURL(serverURL: NSString | string): void;
}
declare const BITHockeyBaseManager: {
  alloc(): BITHockeyBaseManagerAllocator;
}

interface BITHockeyManagerAllocator<InitializedType = BITHockeyManager> extends NSObjectAllocator<BITHockeyManager> {}
interface BITHockeyManager extends NSObject {
  configureWithIdentifier(appIdentifier: NSString | string): void;
  configureWithIdentifier_delegate(appIdentifier: NSString | string, delegate: any): void;
  startManager(): void;
  setUserID(userID: NSString | string): void;
  setUserName(userName: NSString | string): void;
  setUserEmail(userEmail: NSString | string): void;
  setLogHandler(logHandler: BITLogHandler): void;
  testIdentifier(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  serverURL(): NSString;
  setServerURL(serverURL: NSString | string): void;
  crashManager(): BITCrashManager;
  disableCrashManager(): boolean;
  setDisableCrashManager(disableCrashManager: boolean): void;
  feedbackManager(): BITFeedbackManager;
  disableFeedbackManager(): boolean;
  setDisableFeedbackManager(disableFeedbackManager: boolean): void;
  metricsManager(): BITMetricsManager;
  disableMetricsManager(): boolean;
  setDisableMetricsManager(disableMetricsManager: boolean): void;
  logLevel(): BITLogLevel;
  setLogLevel(logLevel: BITLogLevel): void;
}
declare const BITHockeyManager: {
  alloc(): BITHockeyManagerAllocator;  sharedHockeyManager(): BITHockeyManager;

}

interface IBITHockeyManagerDelegate {
  userIDForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userNameForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userEmailForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
}

interface BITMetricsManagerAllocator<InitializedType = BITMetricsManager> extends BITHockeyBaseManagerAllocator<BITMetricsManager> {}
interface BITMetricsManager extends BITHockeyBaseManager {
  trackEventWithName(eventName: NSString | string): void;
  trackEventWithName_properties_measurements(eventName: NSString | string, properties: NSDictionary<any, any> | {[key: string]: any} | null, measurements: NSDictionary<any, any> | {[key: string]: any} | null): void;

  disabled(): boolean;
  setDisabled(disabled: boolean): void;
}
declare const BITMetricsManager: {
  alloc(): BITMetricsManagerAllocator;
}

interface BITSystemProfileAllocator<InitializedType = BITSystemProfile> extends NSObjectAllocator<BITSystemProfile> {}
interface BITSystemProfile extends NSObject {
  systemDataForBundle(bundle: NSBundle): NSMutableArray<any>;
  systemData(): NSMutableArray<any>;
  systemUsageDataForBundle(bundle: NSBundle): NSMutableArray<any>;
  systemUsageData(): NSMutableArray<any>;
  startUsageForBundle(bundle: NSBundle): void;
  startUsage(): void;
  stopUsage(): void;
}
declare const BITSystemProfile: {
  alloc(): BITSystemProfileAllocator;  sharedSystemProfile(): BITSystemProfile;
  deviceIdentifier(): NSString;
  deviceModel(): NSString;
  systemVersionString(): NSString;

}

declare enum BITCrashErrorReason {
  BITCrashErrorUnknown,
  BITCrashAPIAppVersionRejected,
  BITCrashAPIReceivedEmptyResponse,
  BITCrashAPIErrorWithStatusCode,
}

declare enum BITFeedbackErrorReason {
  BITFeedbackErrorUnknown,
  BITFeedbackAPIServerReturnedInvalidStatus,
  BITFeedbackAPIServerReturnedInvalidData,
  BITFeedbackAPIServerReturnedEmptyResponse,
  BITFeedbackAPIClientAuthorizationMissingSecret,
  BITFeedbackAPIClientCannotCreateConnection,
}

declare enum BITHockeyErrorReason {
  BITHockeyErrorUnknown,
}

declare enum BITLogLevel {
  BITLogLevelNone = 0,
  BITLogLevelError = 1,
  BITLogLevelWarning = 2,
  BITLogLevelDebug = 3,
  BITLogLevelVerbose = 4,
}

interface BCCodeSigningVerifierAllocator<InitializedType = BCCodeSigningVerifier> extends NSObjectAllocator<BCCodeSigningVerifier> {}
interface BCCodeSigningVerifier extends NSObject {
}
declare const BCCodeSigningVerifier: {
  alloc(): BCCodeSigningVerifierAllocator;
}

interface BCDeviceAllocator<InitializedType = BCDevice> extends NSObjectAllocator<BCDevice> {}
interface BCDevice extends NSObject {
}
declare const BCDevice: {
  alloc(): BCDeviceAllocator;
}

interface BCLicenseAllocator<InitializedType = BCLicense> extends NSObjectAllocator<BCLicense> {}
interface BCLicense extends NSObject {

  applicationID(): NSString;
  setApplicationID(applicationID: NSString | string): void;
}
declare const BCLicense: {
  alloc(): BCLicenseAllocator;
}

declare enum BCLicenseType {
  BCLicenseUnknown = -1,
  BCLicenseTrial = 0,
  BCLicenseTrialExpired = 1,
  BCLicensePurchased = 2,
}

interface BCLicenseManagerAllocator<InitializedType = BCLicenseManager> extends NSObjectAllocator<BCLicenseManager> {}
interface BCLicenseManager extends NSObject {
  canRenewLicense(): boolean;

  canUseCloud(): boolean;
}
declare const BCLicenseManager: {
  alloc(): BCLicenseManagerAllocator;
}

declare enum BCReceiptRegistrationResult {
  BCReceiptRegistrationOK,
  BCReceiptRegistrationLicenseInvalid,
  BCReceiptRegistrationLicenseNoFreeSlot,
  BCReceiptRegistrationVersionNotSupported,
  BCReceiptRegistrationNetworkError,
  BCReceiptRegistrationFailedToSave,
}

declare enum BCLicenseManagerLicenseResult {
  BCLicenseManagerLicenseOk,
  BCLicenseManagerLicenseExpiringSoon,
  BCLicenseManagerLicenseVersionNotSupported,
  BCLicenseManagerTrialExpired,
  BCLicenseManagerLicenseExpired,
  BCLicenseManagerLicenseVariantNotAllowed,
  BCLicenseManagerLicenseError,
}

interface BCNetworkTimeAllocator<InitializedType = BCNetworkTime> extends NSObjectAllocator<BCNetworkTime> {}
interface BCNetworkTime extends NSObject {
}
declare const BCNetworkTime: {
  alloc(): BCNetworkTimeAllocator;  requestTimeFromHost_timeout_completionBlock(host: NSString | string, timeout: NSUInteger, completion: MSNetworkTimeCompletionBlock): void;

}

interface BCRSASHA1VerifyAllocator<InitializedType = BCRSASHA1Verify> extends NSObjectAllocator<BCRSASHA1Verify> {}
interface BCRSASHA1Verify extends NSObject {

  error(): NSError;
  setError(error: NSError): void;
  verified(): boolean;
  setVerified(verified: boolean): void;
}
declare const BCRSASHA1Verify: {
  alloc(): BCRSASHA1VerifyAllocator;
}

declare type ASN1_Data = {
  length: size_t
  data: string
}

declare enum BCReceiptStatus {
  BCReceiptStatusNotChecked,
  BCReceiptStatusVerified,
  BCReceiptStatusInvalidBundleID,
  BCReceiptStatusInvalidBundleVersion,
  BCReceiptStatusFailedToCreateStaticCode,
  BCReceiptStatusFailedToCreateRequirement,
  BCReceiptStatusInvalidSignature,
  BCReceiptStatusMissingReceipt,
  BCReceiptStatusFailedToCreateDecoder,
  BCReceiptStatusFailedToUpdateMessage,
  BCReceiptStatusFailedToFinalizeMessage,
  BCReceiptStatusFailedToDecrypt,
  BCReceiptStatusFailedToGetSignerCount,
  BCReceiptStatusNoSignerFound,
  BCReceiptStatusFailedToGetSignerStatus,
  BCReceiptStatusNoValidSigner,
  BCReceiptStatusFailedToCreateASN1Decoder,
  BCReceiptStatusFailedToDecodePayload,
  BCReceiptStatusInvalidReceiptID,
  BCReceiptStatusInvalidReceiptVersion,
  BCReceiptStatusFailedToGetMACAddress,
  BCReceiptStatusBadReceiptHash,
  BCReceiptStatusFailedToDecodeInteger,
  BCReceiptStatusFailedToDecodeString,
  BCReceiptStatusFailedToDecodeDate,
  BCReceiptStatusFailedQuickValidation,
  BCReceiptStatusUnexpectedError,
}

interface BCReceiptValidationContextAllocator<InitializedType = BCReceiptValidationContext> extends NSObjectAllocator<BCReceiptValidationContext> {}
interface BCReceiptValidationContext extends NSObject {
}
declare const BCReceiptValidationContext: {
  alloc(): BCReceiptValidationContextAllocator;
}

interface BCReceiptValidationContextWithInfoAllocator<InitializedType = BCReceiptValidationContextWithInfo> extends BCReceiptValidationContextAllocator<BCReceiptValidationContextWithInfo> {
  initWithBundleID_minimumVersion(bundleID: NSString | string, minimumVersion: NSString | string): InitializedType;
}
interface BCReceiptValidationContextWithInfo extends BCReceiptValidationContext {

  expectedBundleID(): NSString;
  setExpectedBundleID(expectedBundleID: NSString | string): void;
  minimumVersion(): NSString;
  setMinimumVersion(minimumVersion: NSString | string): void;
}
declare const BCReceiptValidationContextWithInfo: {
  alloc(): BCReceiptValidationContextWithInfoAllocator;
}

interface BCReceiptValidationExceptionAllocator<InitializedType = BCReceiptValidationException> extends NSExceptionAllocator<BCReceiptValidationException> {}
interface BCReceiptValidationException extends NSException {

  status(): BCReceiptStatus;
}
declare const BCReceiptValidationException: {
  alloc(): BCReceiptValidationExceptionAllocator;  exceptionWithStatus(status: BCReceiptStatus): BCReceiptValidationException;
  raiseWithStatus(status: BCReceiptStatus): void;
  raiseWithStatus_error(status: BCReceiptStatus, error: OSStatus): void;

}

interface MSLicenseExpiredActionAllocator<InitializedType = MSLicenseExpiredAction> extends MSDocumentActionAllocator<MSLicenseExpiredAction> {}
interface MSLicenseExpiredAction extends MSDocumentAction, IMSWindowBadgeAction {
}
declare const MSLicenseExpiredAction: {
  alloc(): MSLicenseExpiredActionAllocator;
}

interface MSLicenseSheetActionAllocator<InitializedType = MSLicenseSheetAction> extends MSDocumentActionAllocator<MSLicenseSheetAction> {}
interface MSLicenseSheetAction extends MSDocumentAction, IMSWindowBadgeAction {
  runLicenseDialog(sender: any): IBAction;
}
declare const MSLicenseSheetAction: {
  alloc(): MSLicenseSheetActionAllocator;
}

interface ISCKAPIAuthentication {
  consumeAccessToken(): NSString;

  authToken(): NSString;
  accessToken(): NSString;
}

interface SCKAPIEnvironmentAllocator<InitializedType = SCKAPIEnvironment> extends NSObjectAllocator<SCKAPIEnvironment> {
  initWithHost(host: NSString | string | null): InitializedType;
  initWithName(name: NSString | string | null): InitializedType;
  initWithDefinition(definition: SCKAPIEnvironmentDefinition): InitializedType;
}
interface SCKAPIEnvironment extends NSObject, INSCopying {
  accountSettingsURLForUserID(userID: SCKObjectID | null): NSURL;
  settingsURLForShare(share: SCKShare | null): NSURL;
  sharesOverviewURLForUserID(userID: SCKObjectID | null): NSURL;
  signInURLUsingCallback_variant(usingCallback: boolean, variant: NSString | string | null): NSURL;
  signUpURLUsingCallback_variant(usingCallback: boolean, variant: NSString | string | null): NSURL;
  setCurrent(): void;
  setKeychainUser_error(keychainUser: SCKAuthenticatedUser | null, error: NSError): boolean;

  definition(): SCKAPIEnvironmentDefinition;
  host(): NSString;
  name(): NSString;
  displayName(): NSString;
  keychainUser(): SCKAuthenticatedUser;
  signature(): NSString;
  suffixRepresentation(): NSString;
}
declare const SCKAPIEnvironment: {
  alloc(): SCKAPIEnvironmentAllocator;  current(): SCKAPIEnvironment;

}

declare enum SCKAPIEnvironmentDefinition {
  SCKAPIEnvironmentDefinitionCustom,
  SCKAPIEnvironmentDefinitionProduction,
  SCKAPIEnvironmentDefinitionStaging,
  SCKAPIEnvironmentDefinitionTest,
  SCKAPIEnvironmentDefinitionDevelopment,
}

interface SCKAPIOperationAllocator<InitializedType = SCKAPIOperation> extends SCKURLOperationAllocator<SCKAPIOperation> {
  initWithRequest(request: SCKAPIRequest): InitializedType;
}
interface SCKAPIOperation extends SCKURLOperation {
  processData_response_error(data: NSData | null, response: NSHTTPURLResponse | null, error: NSError | null): void;

  request(): SCKAPIRequest;
  error(): NSError;
  result(): NSArray<any>;
}
declare const SCKAPIOperation: {
  alloc(): SCKAPIOperationAllocator;  executeRequest_completionHandler(request: SCKAPIRequest, handler: Block): void;

}

interface SCKAPIProtocolAllocator<InitializedType = SCKAPIProtocol> extends NSURLProtocolAllocator<SCKAPIProtocol> {}
interface SCKAPIProtocol extends NSURLProtocol {
}
declare const SCKAPIProtocol: {
  alloc(): SCKAPIProtocolAllocator;
}

interface SCKAPIRequestAllocator<InitializedType = SCKAPIRequest> extends NSMutableURLRequestAllocator<SCKAPIRequest> {}
interface SCKAPIRequest extends NSMutableURLRequest {

  environment(): SCKAPIEnvironment;
  setEnvironment(environment: SCKAPIEnvironment): void;
  authentication(): any;
  setAuthentication(authentication: any): void;
  body(): any;
  setBody(body: any): void;
  expectedObjectType(): any;
  setExpectedObjectType(expectedObjectType: any): void;
  applicationVersion(): NSString;
  setApplicationVersion(applicationVersion: NSString | string): void;
  applicationBuild(): NSString;
  setApplicationBuild(applicationBuild: NSString | string): void;
  type(): SCKAPIRequestType;
  setType(type: SCKAPIRequestType): void;
}
declare const SCKAPIRequest: {
  alloc(): SCKAPIRequestAllocator;  baseURLForEnvironment(environment: SCKAPIEnvironment): NSURL;
  requestWithPath_queryItems_environment(path: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any} | null, environment: SCKAPIEnvironment): SCKAPIRequest;
  requestWithPath_environment(path: NSString | string, environment: SCKAPIEnvironment): SCKAPIRequest;
  requestWithPath(path: NSString | string): SCKAPIRequest;

}

declare enum SCKAPIRequestType {
  SCKAPIRequestTypeGet,
  SCKAPIRequestTypeCreate,
  SCKAPIRequestTypeUpdate,
  SCKAPIRequestTypeDelete,
}

interface ISCKAPISignable {

  signableString(): NSString;
}

interface SCKAuthAPIRequestAllocator<InitializedType = SCKAuthAPIRequest> extends SCKAPIRequestAllocator<SCKAuthAPIRequest> {}
interface SCKAuthAPIRequest extends SCKAPIRequest {
}
declare const SCKAuthAPIRequest: {
  alloc(): SCKAuthAPIRequestAllocator;  loginRequestWithAccessToken(accessToken: NSString | string): SCKAuthAPIRequest;
  loginRequestWithEmail_password(email: NSString | string, password: NSString | string): SCKAuthAPIRequest;
  profileRequest(): SCKAuthAPIRequest;
  forgotPasswordRequestWithEmail(email: NSString | string): SCKAuthAPIRequest;

}

interface SCKDownloadOperationAllocator<InitializedType = SCKDownloadOperation> extends SCKURLOperationAllocator<SCKDownloadOperation> {
  initWithRequest(request: NSURLRequest): InitializedType;
}
interface SCKDownloadOperation extends SCKURLOperation, INSURLSessionDownloadDelegate {

  request(): NSURLRequest;
  downloadCompletionBlock(): SCKDownloadOperationHandler;
  setDownloadCompletionBlock(downloadCompletionBlock: SCKDownloadOperationHandler): void;
  progress(): NSProgress;
  error(): NSError;
}
declare const SCKDownloadOperation: {
  alloc(): SCKDownloadOperationAllocator;  operationByRequesting_completionHandler(request: NSURLRequest, block: SCKDownloadOperationHandler): SCKDownloadOperation;

}

interface SCKDownloadOperationSessionDelegateAllocator<InitializedType = SCKDownloadOperationSessionDelegate> extends NSObjectAllocator<SCKDownloadOperationSessionDelegate> {}
interface SCKDownloadOperationSessionDelegate extends NSObject, INSURLSessionDownloadDelegate {
  setDownloadTaskDelegate_forTask(delegate: any, task: NSURLSessionTask): void;
}
declare const SCKDownloadOperationSessionDelegate: {
  alloc(): SCKDownloadOperationSessionDelegateAllocator;
}

interface SCKOperationAllocator<InitializedType = SCKOperation> extends NSOperationAllocator<SCKOperation> {}
interface SCKOperation extends NSOperation {

  finished(): boolean;
  setFinished(finished: boolean): void;
  executing(): boolean;
  setExecuting(executing: boolean): void;
  cancelled(): boolean;
  setCancelled(cancelled: boolean): void;
}
declare const SCKOperation: {
  alloc(): SCKOperationAllocator;
}

interface SCKShareAPIRequestAllocator<InitializedType = SCKShareAPIRequest> extends SCKAPIRequestAllocator<SCKShareAPIRequest> {}
interface SCKShareAPIRequest extends SCKAPIRequest {
}
declare const SCKShareAPIRequest: {
  alloc(): SCKShareAPIRequestAllocator;  shareRequestWithID(shareID: SCKObjectID): SCKShareAPIRequest;
  shareRequestWithShortID(shortID: NSString | string): SCKShareAPIRequest;
  shareLibraryAppcastRequestWithShortID(shortID: NSString | string): SCKShareAPIRequest;
  userSharesListRequest(): SCKShareAPIRequest;
  shareCreationRequestWithManifest(manifest: NSDictionary<any, any> | {[key: string]: any}): SCKShareAPIRequest;
  shareUpdateRequestWithManifest_existingShare(manifest: NSDictionary<any, any> | {[key: string]: any}, share: SCKShare): SCKShareAPIRequest;
  shareDeletionRequestWithID(shareID: SCKObjectID): SCKShareAPIRequest;
  shareCancelUpdateRequestWithID(shareID: SCKObjectID): SCKShareAPIRequest;

}

interface SCKShareItemUploadOperationAllocator<InitializedType = SCKShareItemUploadOperation> extends SCKOperationAllocator<SCKShareItemUploadOperation> {}
interface SCKShareItemUploadOperation extends SCKOperation, INSURLSessionTaskDelegate, INSProgressReporting {

  urlSession(): NSURLSession;
  setUrlSession(urlSession: NSURLSession): void;
  taskIdentifier(): NSUInteger;
  sourceURL(): NSURL;
  multipartIndex(): NSUInteger;
  setMultipartIndex(multipartIndex: NSUInteger): void;
  documentMultipartSpecs(): SCKDocumentUploadMultipartSpecs;
  setDocumentMultipartSpecs(documentMultipartSpecs: SCKDocumentUploadMultipartSpecs): void;
  item(): SCKFileUploadSpecs;
  progress(): NSProgress;
  additionalRetryAttempts(): NSUInteger;
  setAdditionalRetryAttempts(additionalRetryAttempts: NSUInteger): void;
  error(): NSError;
}
declare const SCKShareItemUploadOperation: {
  alloc(): SCKShareItemUploadOperationAllocator;  itemUploadOperationWithItem_fromURL(item: SCKFileUploadSpecs, url: NSURL): SCKShareItemUploadOperation;
  itemUploadOperationWithDocumentUploadURL_fromURL(url: NSURL, localURL: NSURL): SCKShareItemUploadOperation;
  fileSizeOfItemAtURL(url: NSURL): NSUInteger;
  fileSizeOfItemAtURL_multipartIndex_maxChunkSize(url: NSURL, part: NSUInteger, maxSize: NSUInteger): NSUInteger;

}

interface SCKShareUploadOperationAllocator<InitializedType = SCKShareUploadOperation> extends SCKOperationAllocator<SCKShareUploadOperation> {
  initWithRequest(request: SCKShareAPIRequest): InitializedType;
}
interface SCKShareUploadOperation extends SCKOperation, INSProgressReporting {

  dataSource(): any;
  setDataSource(dataSource: any): void;
  progress(): NSProgress;
  share(): SCKShare;
  errors(): NSArray<any>;
}
declare const SCKShareUploadOperation: {
  alloc(): SCKShareUploadOperationAllocator;
}

interface ISCKShareUploadDataSource {
  shareUploadOperation_fileURLForItemWithHash(operation: SCKShareUploadOperation, hash: NSString | string): NSURL;
  shareUploadOperation_willStartUploadingShare(operation: SCKShareUploadOperation, share: SCKShare): void;
  shareUploadOperation_exportDocumentWithHandler(operation: SCKShareUploadOperation, handler: Block): void;
}

interface SCKURLOperationAllocator<InitializedType = SCKURLOperation> extends SCKOperationAllocator<SCKURLOperation> {}
interface SCKURLOperation extends SCKOperation {

  session(): NSURLSession;
  setSession(session: NSURLSession): void;
}
declare const SCKURLOperation: {
  alloc(): SCKURLOperationAllocator;  sharedURLSession(): NSURLSession;

}

interface SCKArtboardDiffAllocator<InitializedType = SCKArtboardDiff> extends NSObjectAllocator<SCKArtboardDiff> {
  initWithObject_comparedTo(object: SCKArtboard, otherObject: SCKArtboard): InitializedType;
}
interface SCKArtboardDiff extends NSObject, ISCKDiff {

  object(): SCKArtboard;
  comparedObject(): SCKArtboard;
  attributes(): SCKArtboardAttributes;
}
declare const SCKArtboardDiff: {
  alloc(): SCKArtboardDiffAllocator;
}

interface SCKArtboardAllocator<InitializedType = SCKArtboard> extends SCKObjectAllocator<SCKArtboard> {}
interface SCKArtboard extends SCKObject {
  diffComparedTo(object: SCKArtboard): SCKArtboardDiff;

  page(): SCKPage;
  name(): NSString;
  slug(): NSString;
  order(): NSUInteger;
  unread(): NSUInteger;
  size(): CGSize;
  viewport(): SCKArtboardViewport;
  files(): NSArray<any>;
  possibleFileTypes(): SCKFileImageType;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  isFlowHome(): boolean;
  setIsFlowHome(isFlowHome: boolean): void;
}
declare const SCKArtboard: {
  alloc(): SCKArtboardAllocator;
}

interface SCKCloudDocumentDiffAllocator<InitializedType = SCKCloudDocumentDiff> extends SCKDocumentDiffAllocator<SCKCloudDocumentDiff> {}
interface SCKCloudDocumentDiff extends SCKDocumentDiff {
}
declare const SCKCloudDocumentDiff: {
  alloc(): SCKCloudDocumentDiffAllocator;
}

interface SCKCloudDocumentAllocator<InitializedType = SCKCloudDocument> extends SCKDocumentAllocator<SCKCloudDocument> {}
interface SCKCloudDocument extends SCKDocument {
  diffComparedTo(object: SCKCloudDocument): SCKCloudDocumentDiff;

  slug(): NSString;
  downloadURL(): NSURL;
  isProcessing(): boolean;
  metaImageURL(): NSURL;
}
declare const SCKCloudDocument: {
  alloc(): SCKCloudDocumentAllocator;
}

interface SCKCollectionDiffAllocator<InitializedType = SCKCollectionDiff> extends NSObjectAllocator<SCKCollectionDiff> {
  initWithObject_comparedTo(object: NSArray<any> | any[], otherObject: NSArray<any> | any[]): InitializedType;
  initWithCollectionDiffSet(diffSet: NSSet<any>): InitializedType;
}
interface SCKCollectionDiff extends NSObject, ISCKDiff {

  object(): NSArray<any>;
  comparedObject(): NSArray<any>;
  insertions(): NSSet<any>;
  updateDiffs(): NSSet<any>;
  deletions(): NSSet<any>;
}
declare const SCKCollectionDiff: {
  alloc(): SCKCollectionDiffAllocator;
}

interface ISCKDiffable {
  diffComparedTo(object: SCKObject): any;
}

interface SCKDocumentDiffAllocator<InitializedType = SCKDocumentDiff> extends NSObjectAllocator<SCKDocumentDiff> {
  initWithObject_comparedTo(object: SCKDocument, otherObject: SCKDocument): InitializedType;
}
interface SCKDocumentDiff extends NSObject, ISCKDiff {

  object(): SCKDocument;
  comparedObject(): SCKDocument;
  attributes(): SCKDocumentAttributes;
  pageDiff(): SCKCollectionDiff;
  artboardsDiff(): SCKCollectionDiff;
}
declare const SCKDocumentDiff: {
  alloc(): SCKDocumentDiffAllocator;
}

interface SCKDocumentAllocator<InitializedType = SCKDocument> extends SCKObjectAllocator<SCKDocument> {}
interface SCKDocument extends SCKObject {
  diffComparedTo(object: SCKDocument): SCKDocumentDiff;

  name(): NSString;
  pages(): NSArray<any>;
  colorSpace(): SCKColorSpace;
}
declare const SCKDocument: {
  alloc(): SCKDocumentAllocator;
}

interface SCKFlowConnectionDiffAllocator<InitializedType = SCKFlowConnectionDiff> extends NSObjectAllocator<SCKFlowConnectionDiff> {
  initWithObject_comparedTo(object: SCKFlowConnection, otherObject: SCKFlowConnection): InitializedType;
}
interface SCKFlowConnectionDiff extends NSObject, ISCKDiff {

  object(): SCKFlowConnection;
  comparedObject(): SCKFlowConnection;
  attributes(): SCKFlowConnectionAttributes;
}
declare const SCKFlowConnectionDiff: {
  alloc(): SCKFlowConnectionDiffAllocator;
}

interface SCKFlowConnectionAllocator<InitializedType = SCKFlowConnection> extends SCKObjectAllocator<SCKFlowConnection> {}
interface SCKFlowConnection extends SCKObject {
  diffComparedTo(object: SCKFlowConnection): SCKFlowConnectionDiff;

  isBackAction(): boolean;
  destinationArtboardID(): SCKObjectID;
  animationType(): NSString;
  layer(): SCKLayer;
}
declare const SCKFlowConnection: {
  alloc(): SCKFlowConnectionAllocator;
}

interface SCKLayerDiffAllocator<InitializedType = SCKLayerDiff> extends NSObjectAllocator<SCKLayerDiff> {
  initWithObject_comparedTo(object: SCKLayer, otherObject: SCKLayer): InitializedType;
}
interface SCKLayerDiff extends NSObject, ISCKDiff {

  object(): SCKLayer;
  comparedObject(): SCKLayer;
  attributes(): SCKLayerAttributes;
}
declare const SCKLayerDiff: {
  alloc(): SCKLayerDiffAllocator;
}

interface SCKLayerAllocator<InitializedType = SCKLayer> extends SCKObjectAllocator<SCKLayer> {}
interface SCKLayer extends SCKObject {
  diffComparedTo(object: SCKLayer): SCKLayerDiff;

  name(): NSString;
  boundingRect(): CGRect;
  flowConnection(): SCKFlowConnection;
  artboard(): SCKArtboard;
  isFixedToViewport(): boolean;
}
declare const SCKLayer: {
  alloc(): SCKLayerAllocator;
}

interface SCKPageDiffAllocator<InitializedType = SCKPageDiff> extends NSObjectAllocator<SCKPageDiff> {
  initWithObject_comparedTo(object: SCKPage, otherObject: SCKPage): InitializedType;
}
interface SCKPageDiff extends NSObject, ISCKDiff {

  object(): SCKPage;
  comparedObject(): SCKPage;
  attributes(): SCKPageAttributes;
  artboardsDiff(): SCKCollectionDiff;
}
declare const SCKPageDiff: {
  alloc(): SCKPageDiffAllocator;
}

interface SCKPageAllocator<InitializedType = SCKPage> extends SCKObjectAllocator<SCKPage> {}
interface SCKPage extends SCKObject {
  diffComparedTo(object: SCKPage): SCKPageDiff;

  document(): SCKDocument;
  name(): NSString;
  slug(): NSString;
  order(): NSUInteger;
  artboards(): NSArray<any>;
}
declare const SCKPage: {
  alloc(): SCKPageAllocator;
}

declare type SCKArtboardViewport = {
  scale: CGFloat
  size: CGSize
}

declare enum SCKArtboardAttributes {
  SCKArtboardNoAttribute = 0,
  SCKArtboardNameAttribute = 1 << 0,
  SCKArtboardSlugAttribute = 1 << 1,
  SCKArtboardOrderAttribute = 1 << 2,
  SCKArtboardUnreadAttribute = 1 << 3,
  SCKArtboardSizeAttribute = 1 << 4,
  SCKArtboardFilesAttribute = 1 << 5,
  SCKArtboardLayersAttribute = 1 << 6,
  SCKArtboardIsFlowHomeAttribute = 1 << 7,
  SCKArtboardViewportAttribute = 1 << 8,
  SCKArtboardPossibleFileTypesAttribute = 1 << 9,
}

interface SCKAuthenticatedUserAllocator<InitializedType = SCKAuthenticatedUser> extends SCKUserAllocator<SCKAuthenticatedUser> {
  initWithObjectID_authToken(objectID: SCKObjectID, authToken: NSString | string | null): InitializedType;
}
interface SCKAuthenticatedUser extends SCKUser, ISCKAPIAuthentication {
  loginWithError(error: NSError): boolean;
  login(): boolean;
  loginToEnvironment_error(environment: SCKAPIEnvironment, error: NSError): boolean;
  loginToEnvironment(environment: SCKAPIEnvironment): boolean;
}
declare const SCKAuthenticatedUser: {
  alloc(): SCKAuthenticatedUserAllocator;  current(): SCKAuthenticatedUser;
  logoutWithError(error: NSError): boolean;
  logout(): boolean;

}

interface SCKAvatarAllocator<InitializedType = SCKAvatar> extends NSObjectAllocator<SCKAvatar> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SCKAvatar extends NSObject {

  dictionaryRepresentation(): NSDictionary<any, any>;
  type(): SCKAvatarType;
  url(): NSURL;
  largeURL(): NSURL;
}
declare const SCKAvatar: {
  alloc(): SCKAvatarAllocator;
}

declare enum SCKAvatarType {
  SCKAvatarTypeRandom = 0,
  SCKAvatarTypeUserDefined,
}

declare enum SCKColorSpace {
  SCKColorSpaceUnmanaged = 0,
  SCKColorSpaceSRGB = 1,
  SCKColorSpaceDisplayP3 = 2,
}

declare enum SCKDocumentAttributes {
  SCKDocumentNoAttribute = 0,
  SCKDocumentNameAttribute = 1 << 0,
  SCKDocumentSlugAttribute = 1 << 1,
  SCKDocumentDownloadURLAttribute = 1 << 2,
  SCKDocumentProcessingAttribute = 1 << 3,
  SCKDocumentMetaImageURLAttribute = 1 << 4,
  SCKDocumentPagesAttribute = 1 << 5,
  SCKDocumentColorSpaceAttribute = 1 << 6,
}

interface SCKDocumentUploadMultipartSpecsAllocator<InitializedType = SCKDocumentUploadMultipartSpecs> extends NSObjectAllocator<SCKDocumentUploadMultipartSpecs> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SCKDocumentUploadMultipartSpecs extends NSObject {
  uploadRequestCompletionBodyWithSize(size: NSUInteger): NSDictionary<any, any>;

  uploadID(): NSString;
  uploadKey(): NSString;
  partSize(): NSUInteger;
  uploadURLs(): NSArray<any>;
}
declare const SCKDocumentUploadMultipartSpecs: {
  alloc(): SCKDocumentUploadMultipartSpecsAllocator;
}

interface SCKFileAllocator<InitializedType = SCKFile> extends SCKObjectAllocator<SCKFile> {}
interface SCKFile extends SCKObject {

  dimensions(): CGSize;
  fileSize(): NSUInteger;
  scale(): CGFloat;
  thumbnails(): NSArray<any>;
  url(): NSURL;
  type(): SCKFileImageType;
}
declare const SCKFile: {
  alloc(): SCKFileAllocator;
}

declare enum SCKFileImageType {
  SCKFileImageTypeFull = 0,
  SCKFileImageTypeScrollable = 1 << 0,
  SCKFileImageTypeFixed = 1 << 1,
}

interface SCKFileUploadSpecsAllocator<InitializedType = SCKFileUploadSpecs> extends NSObjectAllocator<SCKFileUploadSpecs> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any} | null): InitializedType;
}
interface SCKFileUploadSpecs extends NSObject {

  fileHash(): NSString;
  uploadURL(): NSURL;
}
declare const SCKFileUploadSpecs: {
  alloc(): SCKFileUploadSpecsAllocator;
}

declare enum SCKFlowConnectionAttributes {
  SCKFlowConnectionNoAttribute = 0,
  SCKFlowConnectionBackActionAttribute = 1 << 0,
  SCKFlowConnectionDestinationArtboardIDAttribute = 1 << 1,
  SCKFlowConnectionAnimationTypeAttribute = 1 << 2,
}

declare enum SCKLayerAttributes {
  SCKLayerNoAttribute = 0,
  SCKLayerNameAttribute = 1 << 0,
  SCKLayerBoundingRectAttribute = 1 << 1,
  SCKLayerFlowConnectionAttribute = 1 << 2,
  SCKLayerFixedToViewportAttribute = 1 << 3,
}

interface SCKObjectAllocator<InitializedType = SCKObject> extends NSObjectAllocator<SCKObject> {
  initWithData_error(data: NSData | null, error: NSError): InitializedType;
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithDictionary_parentObject(dictionary: NSDictionary<any, any> | {[key: string]: any}, parent: SCKObject | null): InitializedType;
  initWithObjectID(objectID: SCKObjectID): InitializedType;
}
interface SCKObject extends NSObject, INSSecureCoding {

  parent(): SCKObject;
  objectID(): SCKObjectID;
  creationDate(): NSDate;
  updateDate(): NSDate;
  deletionDate(): NSDate;
  dictionaryRepresentation(): NSDictionary<any, any>;
  localizedUpdatedTimeComponentsString(): NSString;
}
declare const SCKObject: {
  alloc(): SCKObjectAllocator;
}

declare type SCKObjectID = NSString

declare enum SCKPageAttributes {
  SCKPageNoAttribute = 0,
  SCKPageNameAttribute = 1 << 0,
  SCKPageSlugAttribute = 1 << 1,
  SCKPageOrderAttribute = 1 << 2,
  SCKPageArtboardsAttribute = 1 << 3,
}

interface SCKShareAllocator<InitializedType = SCKShare> extends SCKObjectAllocator<SCKShare> {}
interface SCKShare extends SCKObject {

  shortID(): NSString;
  publicURL(): NSURL;
  isPrivate(): boolean;
  userID(): SCKObjectID;
  commentsEnabled(): boolean;
  currentVersion(): SCKShareVersion;
}
declare const SCKShare: {
  alloc(): SCKShareAllocator;
}

interface SCKShareUploadSpecsAllocator<InitializedType = SCKShareUploadSpecs> extends SCKShareAllocator<SCKShareUploadSpecs> {}
interface SCKShareUploadSpecs extends SCKShare {

  cloudDocumentID(): NSString;
  fileUploadSpecs(): NSArray<any>;
}
declare const SCKShareUploadSpecs: {
  alloc(): SCKShareUploadSpecsAllocator;
}

interface SCKShareVersionAllocator<InitializedType = SCKShareVersion> extends SCKObjectAllocator<SCKShareVersion> {}
interface SCKShareVersion extends SCKObject {

  number(): NSUInteger;
  message(): NSString;
  document(): SCKCloudDocument;
}
declare const SCKShareVersion: {
  alloc(): SCKShareVersionAllocator;
}

interface SCKThumbnailAllocator<InitializedType = SCKThumbnail> extends SCKObjectAllocator<SCKThumbnail> {}
interface SCKThumbnail extends SCKObject {

  URL(): NSURL;
  dimensions(): CGSize;
  fileSize(): NSUInteger;
}
declare const SCKThumbnail: {
  alloc(): SCKThumbnailAllocator;
}

interface SCKUserAllocator<InitializedType = SCKUser> extends SCKObjectAllocator<SCKUser> {}
interface SCKUser extends SCKObject {

  name(): NSString;
  email(): NSString;
  changedEmail(): NSString;
  isAdmin(): boolean;
  avatar(): SCKAvatar;
}
declare const SCKUser: {
  alloc(): SCKUserAllocator;
}

interface SCKTestAuthenticationAllocator<InitializedType = SCKTestAuthentication> extends NSObjectAllocator<SCKTestAuthentication> {}
interface SCKTestAuthentication extends NSObject, ISCKAPIAuthentication {

  accessToken(): NSString;
  authToken(): NSString;
  environment(): SCKAPIEnvironment;
}
declare const SCKTestAuthentication: {
  alloc(): SCKTestAuthenticationAllocator;
}

interface AFAmazonS3ManagerAllocator<InitializedType = AFAmazonS3Manager> extends AFHTTPRequestOperationManagerAllocator<AFAmazonS3Manager> {
  initWithAccessKeyID_secret(accessKey: NSString | string, secret: NSString | string): InitializedType;
}
interface AFAmazonS3Manager extends AFHTTPRequestOperationManager, INSSecureCoding, INSCopying {
  enqueueS3RequestOperationWithMethod_path_parameters_success_failure(method: NSString | string, path: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, success: Block, failure: Block): AFHTTPRequestOperation;
  getServiceWithSuccess_failure(success: Block, failure: Block): AFHTTPRequestOperation;
  getBucket_success_failure(bucket: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  putBucket_parameters_success_failure(bucket: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, success: Block, failure: Block): AFHTTPRequestOperation;
  deleteBucket_success_failure(bucket: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  headObjectWithPath_success_failure(path: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  getObjectWithPath_progress_success_failure(path: NSString | string, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  getObjectWithPath_outputStream_progress_success_failure(path: NSString | string, outputStream: NSOutputStream, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  postObjectWithFile_destinationPath_parameters_progress_success_failure(path: NSString | string, destinationPath: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  putObjectWithFile_destinationPath_parameters_progress_success_failure(path: NSString | string, destinationPath: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  deleteObjectWithPath_success_failure(path: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;

  baseURL(): NSURL;
  requestSerializer(): AFAmazonS3RequestSerializer;
  setRequestSerializer(requestSerializer: AFAmazonS3RequestSerializer): void;
}
declare const AFAmazonS3Manager: {
  alloc(): AFAmazonS3ManagerAllocator;
}

interface AFAmazonS3RequestSerializerAllocator<InitializedType = AFAmazonS3RequestSerializer> extends AFHTTPRequestSerializerAllocator<AFAmazonS3RequestSerializer> {}
interface AFAmazonS3RequestSerializer extends AFHTTPRequestSerializer {
  setAccessKeyID_secret(accessKey: NSString | string, secret: NSString | string): void;
  requestBySettingAuthorizationHeadersForRequest_error(request: NSURLRequest, error: NSError): NSURLRequest;
  preSignedRequestWithRequest_expiration_error(request: NSURLRequest, expiration: NSDate, error: NSError): NSURLRequest;

  bucket(): NSString;
  setBucket(bucket: NSString | string): void;
  region(): NSString;
  setRegion(region: NSString | string): void;
  sessionToken(): NSString;
  setSessionToken(sessionToken: NSString | string): void;
  useSSL(): boolean;
  setUseSSL(useSSL: boolean): void;
  endpointURL(): NSURL;
}
declare const AFAmazonS3RequestSerializer: {
  alloc(): AFAmazonS3RequestSerializerAllocator;
}

interface AFAmazonS3ResponseSerializerAllocator<InitializedType = AFAmazonS3ResponseSerializer> extends AFHTTPResponseSerializerAllocator<AFAmazonS3ResponseSerializer> {}
interface AFAmazonS3ResponseSerializer extends AFHTTPResponseSerializer {
}
declare const AFAmazonS3ResponseSerializer: {
  alloc(): AFAmazonS3ResponseSerializerAllocator;
}

interface AFAmazonS3ResponseObjectAllocator<InitializedType = AFAmazonS3ResponseObject> extends NSObjectAllocator<AFAmazonS3ResponseObject> {}
interface AFAmazonS3ResponseObject extends NSObject {

  URL(): NSURL;
  ETag(): NSString;
  originalResponse(): NSHTTPURLResponse;
}
declare const AFAmazonS3ResponseObject: {
  alloc(): AFAmazonS3ResponseObjectAllocator;  responseObject(response: NSHTTPURLResponse): AFAmazonS3ResponseObject;

}

interface MSActionAllocator<InitializedType = MSAction> extends NSResponderAllocator<MSAction> {}
interface MSAction extends NSResponder {
  menuItems(): NSArray<any>;
  menuItemsForMenu(menu: NSMenu): NSArray<any>;
  makeToolbarItemForToolbar(forToolbar: boolean): NSToolbarItem;
  //   validateToolbarItem(): void;
  doPerformAction(sender: any): IBAction;
  submenuActionIDs(): NSArray<any>;
  containsActionWithID(actionIdentifier: NSString | string): boolean;
  contextForActionObservers(): any;
  handlesKeyEvent(event: NSEvent): boolean;

  badgeTitle(): NSAttributedString;
  preferredMenuAction(): string;
  labelForMenu(): NSString;
  mayShowInToolbar(): boolean;
  tooltip(): NSString;
  labelForToolbar(): NSString;
  imageForToolbar(): NSImage;
  labelForToolbarCustomisationSheet(): NSString;
  controller(): MSActionController;
  setController(controller: MSActionController): void;
  toolbarItem(): NSToolbarItem;
  setToolbarItem(toolbarItem: NSToolbarItem): void;
  hasSubMenu(): boolean;
  hasDynamicTitle(): boolean;
  image(): NSImage;
  imageName(): NSString;
  label(): NSString;
  shortcutCharacter(): unichar;
  isActive(): boolean;
  isSelectable(): boolean;
  validate(): boolean;
  validationStatus(): MSActionValidation;
}
declare const MSAction: {
  alloc(): MSActionAllocator;  imageName(): NSString;

}

declare enum MSActionValidation {
  MSActionValidationInvalid = 0,
  MSActionValidationValid = 1,
  MSActionValidationUnavailable = 2,
}

interface MSActionControllerAllocator<InitializedType = MSActionController> extends NSResponderAllocator<MSActionController> {}
interface MSActionController extends NSResponder {
  registerAction(action: MSAction): void;
  actionForID(actionIdentifier: NSString | string): MSAction;
  actionForSelector(action: string): MSAction;
  performActionWithID_sender(actionIdentifier: NSString | string, sender: any | null): void;
  allActions(): NSArray<any>;
  insertAfterResponder(responder: NSResponder): void;
  forwardKeyEvent(event: NSEvent): boolean;
  willBeginActionWithID_context(actionID: NSString | string, context: any): void;
  didFinishActionWithID_context(actionID: NSString | string, context: any): void;
  didInstantActionWithID_context(actionID: NSString | string, context: any): void;
  registerActionObserver(observer: any): void;
  unregisterActionObserver(observer: any): void;
  performFakeActionWithID_context_block(actionID: NSString | string, context: any | null, block: MSActionFakeActionBlock | null): void;

  singleKeyShortcuts(): NSDictionary<any, any>;
  setSingleKeyShortcuts(singleKeyShortcuts: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const MSActionController: {
  alloc(): MSActionControllerAllocator;
}

interface IMSActionObserver {
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
}

interface MSAlignLayersUnionAllocator<InitializedType = MSAlignLayersUnion> extends BCRectAllocator<MSAlignLayersUnion> {}
interface MSAlignLayersUnion extends BCRect {

  layers(): any;
  setLayers(layers: any): void;
}
declare const MSAlignLayersUnion: {
  alloc(): MSAlignLayersUnionAllocator;  unionWithLayers(layers: NSArray<any> | any[]): MSAlignLayersUnion;

}

interface MSAlignmentEngineAllocator<InitializedType = MSAlignmentEngine> extends NSObjectAllocator<MSAlignmentEngine> {
  initWithCycle(cycle: MSAlignmentEngineCycle): InitializedType;
}
interface MSAlignmentEngine extends NSObject {
  canSnapOnAxis(axis: BCAxis): boolean;
  beginCycleWithPoint_constraint(point: NSPoint, constraint: MSAlignmentEngineConstraint | null): MSAlignmentEngineCycle;
  addTarget(target: MSSnappingTarget): void;
  addTargets(targets: NSArray<any> | any[]): void;
  addTargetWithLineSegment(segment: MSLineSegment): void;
  addOrthogonalTargetsThroughPoint(point: NSPoint): void;
  addTargetsForRect_includeCenter(rect: NSRect, includeCenter: boolean): void;
  includeRulerGuideTargetsForPage_zoomScale(page: MSPage, zoomScale: CGFloat): void;

  snapDistance(): CGFloat;
  setSnapDistance(snapDistance: CGFloat): void;
  constraint(): MSAlignmentEngineConstraint;
  currentCycle(): MSAlignmentEngineCycle;
  alignmentResult(): MSAlignmentEngineResult;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSAlignmentEngine: {
  alloc(): MSAlignmentEngineAllocator;  snapTargetsForCentersOfLayers(layers: NSArray<any> | any[]): NSArray<any>;
  enumeratorForPossibleSnapTargetLayersInGroup(group: MSLayerGroup): MSLayerEnumerator<any>;

}

interface IMSAlignmentEngineDelegate {
  alignmentEngine_alignPoint(engine: MSAlignmentEngine, point: NSPoint): NSPoint;
  alignmentEngine_roundPoint(engine: MSAlignmentEngine, point: NSPoint): NSPoint;
}

interface MSAlignmentEngineConstraintAllocator<InitializedType = MSAlignmentEngineConstraint> extends NSObjectAllocator<MSAlignmentEngineConstraint> {}
interface MSAlignmentEngineConstraint extends NSObject, INSCopying {

  sourcePoint(): NSPoint;
  line(): MSLine;
}
declare const MSAlignmentEngineConstraint: {
  alloc(): MSAlignmentEngineConstraintAllocator;  constraintWithSourcePoint_toPoint(sourcePoint: NSPoint, point2: NSPoint): MSAlignmentEngineConstraint;
  orthogonalOrDiagonalConstraintFromPoint_toPoint(sourcePoint: NSPoint, unsnappedDestination: NSPoint): MSAlignmentEngineConstraint;

}

interface MSAlignmentEngineResultGuideAllocator<InitializedType = MSAlignmentEngineResultGuide> extends NSObjectAllocator<MSAlignmentEngineResultGuide> {
  initWithLineSegment(segment: MSLineSegment): InitializedType;
}
interface MSAlignmentEngineResultGuide extends NSObject, INSCopying {
  bezierPath(): NSBezierPath;
  drawWithLineWidth(width: CGFloat): void;

  lineSegment(): MSLineSegment;
}
declare const MSAlignmentEngineResultGuide: {
  alloc(): MSAlignmentEngineResultGuideAllocator;
}

interface MSAlignmentEngineResultAllocator<InitializedType = MSAlignmentEngineResult> extends NSObjectAllocator<MSAlignmentEngineResult> {
  initWithPoint_guides(point: NSPoint, guides: NSArray<any> | any[]): InitializedType;
}
interface MSAlignmentEngineResult extends NSObject, INSCopying {
  drawAtZoomValue(zoomValue: CGFloat): void;

  point(): NSPoint;
  guides(): NSArray<any>;
}
declare const MSAlignmentEngineResult: {
  alloc(): MSAlignmentEngineResultAllocator;  snappingResultWithPoint(point: NSPoint): MSAlignmentEngineResult;

}

interface MSArtboardGroupAllocator<InitializedType = MSArtboardGroup> extends _MSArtboardGroupAllocator<MSArtboardGroup> {}
interface MSArtboardGroup extends _MSArtboardGroup, IMSArtboardGroup, IMSRootLayer, IMSLayerWithMutableBackgroundColor, IMSColorConvertible {
  optimalBoundingBox(): NSRect;
  resizeToFitChildren(): void;
  hitTestInNameLabel_zoomValue(mouse: NSPoint, zoom: CGFloat): boolean;
  moveChildrenToIdenticalPositionAfterResizeFromRect(oldRect: NSRect): void;
  makeChildRectsIntegral(): void;

  preset(): MSArtboardPreset;
  setPreset(preset: MSArtboardPreset): void;
}
declare const MSArtboardGroup: {
  alloc(): MSArtboardGroupAllocator;  artboardRectFromLayersInArray(layers: MSLayerArray): NSRect;

}

interface MSArtboardOrderSortingAllocator<InitializedType = MSArtboardOrderSorting> extends NSObjectAllocator<MSArtboardOrderSorting> {}
interface MSArtboardOrderSorting extends NSObject {
}
declare const MSArtboardOrderSorting: {
  alloc(): MSArtboardOrderSortingAllocator;  sortArtboards_inOrder(artboards: NSArray<any> | any[], order: MSLayerOrderSortingOptions): NSArray<any>;
  sortArtboardsInDefaultOrder(artboards: NSArray<any> | any[]): NSArray<any>;

}

declare enum MSLayerOrderSortingOptions {
  MSArtboardSortingCurrentOrder = 8,
  MSArtboardSortingReverseOrder = 9,
  MSArtboardSortingLeftToRight,
  MSArtboardSortingRightToLeft,
  MSArtboardSortingTopToBottom,
}

interface MSAssetLibraryAllocator<InitializedType = MSAssetLibrary> extends NSObjectAllocator<MSAssetLibrary> {
  initWithDocumentAtURL(url: NSURL): InitializedType;
  initWithName(name: NSString | string): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface MSAssetLibrary extends NSObject, IBCSortable, INSCoding, IMSLibraryObject {
  resolveLocationOnDisk(): void;
  loadSynchronously(): boolean;
  loadAsyncWithDispatchGroup_completionHandler(dispatchGroup: dispatch_group_t | null, block: dispatch_block_t): void;
  unload(): void;
  handleAssetLibraryUpdateWithCompletionHandler(block: Block): void;

  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  valid(): boolean;
  status(): MSAssetLibraryStatus;
  setStatus(status: MSAssetLibraryStatus): void;
  locationOnDisk(): NSURL;
  setLocationOnDisk(locationOnDisk: NSURL): void;
  canLibraryBeRemoved(): boolean;
  document(): MSDocumentData;
  name(): NSString;
  delegate(): any;
  setDelegate(delegate: any): void;
  dateLastModified(): NSDate;
  libraryType(): MSAssetLibraryType;
  propertyListDictionaryRepresentation(): NSDictionary<any, any>;
  previewURL(): NSURL;
}
declare const MSAssetLibrary: {
  alloc(): MSAssetLibraryAllocator;  URLForTemplateLibraryNamed(name: NSString | string): NSURL;
  assetLibraryStatusForDocumentErrorCode(errorCode: MSDocumentErrorCode): MSAssetLibraryStatus;

}

declare enum MSAssetLibraryStatus {
  MSAssetLibraryStatusLoaded = 0,
  MSAssetLibraryStatusNotLoaded,
  MSAssetLibraryStatusNotFound,
  MSAssetLibraryStatusIncompatibleVersion,
  MSAssetLibraryStatusLoadError,
}

declare enum MSAssetLibraryType {
  MSAssetLibraryTypeInternal = 0,
  MSAssetLibraryTypeUser = 1,
  MSAssetLibraryTypeRemote = 2,
}

declare enum MSAssetLibraryVersion {
  MSAssetLibraryInitialVersion = 1,
  MSAssetLibraryDownloadableLibraryVersion = 2,
  MSAssetLibraryBookMarkLocationTrackingRemoved = 3,
  MSAssetLibraryNextVersion,
  MSAssetLibraryCurrentVersion,
}

interface MSAssetLibraryControllerAllocator<InitializedType = MSAssetLibraryController> extends NSObjectAllocator<MSAssetLibraryController> {}
interface MSAssetLibraryController extends NSObject, IMSAssetLibraryDelegate {
  addAssetLibraryAtURL(url: NSURL): MSAssetLibraryControllerAddStatus;
  removeAssetLibrary(library: MSAssetLibrary): void;
  importShareableObjectReference_intoDocument(reference: MSShareableObjectReference, document: MSDocumentData): MSForeignObject;
  syncForeignObject_withMaster_fromLibrary(foreignObject: MSForeignObject, libraryMaster: MSShareableObject, sourceLibrary: MSAssetLibrary): void;
  enumerateForeignObjects_inDocument_includeDisabled_block(objects: NSArray<any> | any[], document: MSDocumentData, includeDisabled: boolean, block: Block): void;
  libraryForShareableObject(object: MSModelObject): MSAssetLibrary;
  loadLibrariesWithDispatchGroup(dispatchGroup: dispatch_group_t | null): void;
  loadInternalLibraryRepresentationWithCompletionHandler(completionHandler: Block): void;
  generatePreviewImageForLibrary_completionHandler(library: MSAssetLibrary, completionHandler: Block): void;
  addRemoteLibraryFromAppcastURL_withCompletionHandler(appcastURL: NSURL, completionHandler: Block): void;
  downloadAssetLibraryAppcastsWithHandler_completionHandler(handler: Block | null, completionBlock: Block): void;
  startDownloadingAssetLibrary_progressHandler_downloadCompletionHandler_completionHandler(assetLibrary: MSRemoteAssetLibrary, progressHandler: Block, downloadCompletionHandler: Block, completionHandler: Block): void;
  librariesWithUpdates(): NSArray<any>;
  addRemoteLibraryFromAppcastURL_context_callback(appcastURL: NSURL, coscript: COScript, callback: MOJavaScriptObject | Function): void;

  availableLibraries(): NSArray<any>;
  libraries(): NSArray<any>;
}
declare const MSAssetLibraryController: {
  alloc(): MSAssetLibraryControllerAllocator;
}

declare enum MSAssetLibraryControllerAddStatus {
  MSAssetLibraryControllerAddStatusOK,
  MSAssetLibraryControllerAddStatusDuplicate,
  MSAssetLibraryControllerAddStatusLegacyDocument,
  MSAssetLibraryControllerAddStatusInvalidFile,
}

interface IMSAssetLibraryDelegate {
  assetLibraryChangedOnDisk(library: MSAssetLibrary): void;
  assetLibraryEnableStateChanged(library: MSAssetLibrary): void;
}

interface MSAssetLibraryUpdaterAllocator<InitializedType = MSAssetLibraryUpdater> {}
interface MSAssetLibraryUpdater {
  startDownloadingAssetLibrary_progressHandler_completionHandler(assetLibrary: MSRemoteAssetLibrary, progressHandler: Block, completionHandler: Block): NSString;
  updateAssetLibrary_withLibraryDownloadedTo(assetLibrary: MSRemoteAssetLibrary, downloadedFileURL: NSURL): boolean;
  downloadAppcastAtURL_withCompletionHandler(appcastURL: NSURL, completionHandler: Block): void;
  startFileDownload_completionHandler(remoteURL: NSURL, completionHandler: Block): void;
  cancelDownloadTaskWithIdentifier(downloadTaskIdentifier: NSString | string | null): void;
}
declare const MSAssetLibraryUpdater: {
  alloc(): MSAssetLibraryUpdaterAllocator;
}

interface MSAttributeConverterAllocator<InitializedType = MSAttributeConverter> extends NSObjectAllocator<MSAttributeConverter> {
  initWithAttributeName_block(attributeName: NSString | string, conversionBlock: MSAttributeConverterBlock): InitializedType;
}
interface MSAttributeConverter extends NSObject {
  convertAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;

  attributeName(): NSString;
  conversionBlock(): MSAttributeConverterBlock;
}
declare const MSAttributeConverter: {
  alloc(): MSAttributeConverterAllocator;  converterWithAttributeName_block(attributeName: NSString | string, conversionBlock: MSAttributeConverterBlock): MSAttributeConverter;

}

interface MSAutoCappingNumberFormatterAllocator<InitializedType = MSAutoCappingNumberFormatter> extends MSMathNumberFormatterAllocator<MSAutoCappingNumberFormatter> {}
interface MSAutoCappingNumberFormatter extends MSMathNumberFormatter {
}
declare const MSAutoCappingNumberFormatter: {
  alloc(): MSAutoCappingNumberFormatterAllocator;
}

interface MSAutoSelectingArrayControllerAllocator<InitializedType = MSAutoSelectingArrayController> extends NSArrayControllerAllocator<MSAutoSelectingArrayController> {}
interface MSAutoSelectingArrayController extends NSArrayController {
}
declare const MSAutoSelectingArrayController: {
  alloc(): MSAutoSelectingArrayControllerAllocator;
}

interface MSAveragingRenderMonitorAllocator<InitializedType = MSAveragingRenderMonitor> extends MSRenderMonitorAllocator<MSAveragingRenderMonitor> {
  initWithUpdateBlock(block: MSAveragingRenderMonitorUpdateBlock): InitializedType;
}
interface MSAveragingRenderMonitor extends MSRenderMonitor {

  start(): BCTime;
  setStart(start: BCTime): void;
  updateTimer(): NSTimer;
  setUpdateTimer(updateTimer: NSTimer): void;
}
declare const MSAveragingRenderMonitor: {
  alloc(): MSAveragingRenderMonitorAllocator;
}

interface MSBaseGridAllocator<InitializedType = MSBaseGrid> extends _MSBaseGridAllocator<MSBaseGrid> {}
interface MSBaseGrid extends _MSBaseGrid {
  verticalGuidesForRulerData_inRect(ruler: MSRulerData, aRect: NSRect): NSArray<any>;
  horizontalGuidesForRulerData_inRect(ruler: MSRulerData, aRect: NSRect): NSArray<any>;
  shouldDraw(): boolean;
  drawInRect_horizontalRuler_verticalRuler(dirtyRect: NSRect, horizontalRuler: MSRulerView, verticalRuler: MSRulerView): void;
  verticalGuidesForRuler_inRect(ruler: MSRulerView, aRect: NSRect): NSArray<any>;
  horizontalGuidesForRuler_inRect(ruler: MSRulerView, aRect: NSRect): NSArray<any>;

  forceDraw(): boolean;
  setForceDraw(forceDraw: boolean): void;
}
declare const MSBaseGrid: {
  alloc(): MSBaseGridAllocator;  defaultGrid(): any;
  setDefaultGrid(grid: MSBaseGrid): void;

}

interface MSBeepSuppressorAllocator<InitializedType = MSBeepSuppressor> extends NSObjectAllocator<MSBeepSuppressor> {}
interface MSBeepSuppressor extends NSObject {
}
declare const MSBeepSuppressor: {
  alloc(): MSBeepSuppressorAllocator;  failSilentlyInBlock(block: Block): void;

  shouldSuppressBeep(): boolean;

}

interface MSButtonToolbarItemAllocator<InitializedType = MSButtonToolbarItem> extends MSToolbarItemAllocator<MSButtonToolbarItem> {}
interface MSButtonToolbarItem extends MSToolbarItem {
}
declare const MSButtonToolbarItem: {
  alloc(): MSButtonToolbarItemAllocator;
}

interface MSClickGestureRecognizerAllocator<InitializedType = MSClickGestureRecognizer> extends MSGestureRecognizerAllocator<MSClickGestureRecognizer> {}
interface MSClickGestureRecognizer extends MSGestureRecognizer {

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  numberOfClicksRequired(): NSInteger;
  setNumberOfClicksRequired(numberOfClicksRequired: NSInteger): void;
}
declare const MSClickGestureRecognizer: {
  alloc(): MSClickGestureRecognizerAllocator;
}

interface MSClosePathChangeAllocator<InitializedType = MSClosePathChange> extends MSShapeChangeAllocator<MSClosePathChange> {}
interface MSClosePathChange extends MSShapeChange {
  validateWithContext(context: MSShapeChangeContext): boolean;
  titleForContext(context: MSShapeChangeContext): NSString;
}
declare const MSClosePathChange: {
  alloc(): MSClosePathChangeAllocator;  toggleClosePath(): MSClosePathChange;

}

interface IMSCloudExportableDocument {

  documentData(): MSDocumentData;
  UIMetadata(): NSDictionary<any, any>;
  cacheManager(): MSCacheManager;
  cloudShare(): SCKShare;
  setCloudShare(cloudShare: SCKShare): void;
  cloudName(): NSString;
}

interface MSCloudManifestMakerAllocator<InitializedType = MSCloudManifestMaker> extends MSManifestMakerAllocator<MSCloudManifestMaker> {}
interface MSCloudManifestMaker extends MSManifestMaker {

  imageFileProviderBlock(): MSManifestImageProviderBlock;
  setImageFileProviderBlock(imageFileProviderBlock: MSManifestImageProviderBlock): void;
}
declare const MSCloudManifestMaker: {
  alloc(): MSCloudManifestMakerAllocator;
}

interface MSCloudShareUploadControllerAllocator<InitializedType = MSCloudShareUploadController> extends NSObjectAllocator<MSCloudShareUploadController> {
  initWithDocument(document: any): InitializedType;
}
interface MSCloudShareUploadController extends NSObject {
  startUpload(): void;
  cancel(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  existingShare(): SCKShare;
  setExistingShare(existingShare: SCKShare): void;
  cancelled(): boolean;
  progress(): NSProgress;
}
declare const MSCloudShareUploadController: {
  alloc(): MSCloudShareUploadControllerAllocator;
}

interface IMSCloudShareUploadControllerDelegate {
  cloudShareController_didUploadShare(controller: MSCloudShareUploadController, share: SCKShare): void;
  cloudShareController_exportDocumentWithHandler(controller: MSCloudShareUploadController, handler: Block): void;
  cloudShareController_uploadDidFailWithError(controller: MSCloudShareUploadController, error: NSError | null): void;
  cloudShareController_didChangeProgress(controller: MSCloudShareUploadController, progress: NSProgress | null): void;
}

interface MSCloudUserAllocator<InitializedType = MSCloudUser> extends NSObjectAllocator<MSCloudUser> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface MSCloudUser extends NSObject, INSSecureCoding {
  verifiedUser(): MSCloudUser;

  identifier(): NSString;
  email(): NSString;
  pendingEmail(): NSString;
  isAdmin(): boolean;
  isVerified(): boolean;
  name(): NSString;
  webAccessToken(): NSString;
}
declare const MSCloudUser: {
  alloc(): MSCloudUserAllocator;  userWithIdentifier_verified(identifier: NSString | string, verified: boolean): MSCloudUser;

}

interface MSColorSpaceConverterAllocator<InitializedType = MSColorSpaceConverter> extends NSObjectAllocator<MSColorSpaceConverter> {
  initForConversionFromColorSpace_to(oldColorSpace: MSColorSpace, targetColorSpace: MSColorSpace): InitializedType;
}
interface MSColorSpaceConverter extends NSObject, IMSColorConverter {

  oldColorSpace(): MSColorSpace;
  targetColorSpace(): MSColorSpace;
  oldNSColorSpace(): NSColorSpace;
  targetNSColorSpace(): NSColorSpace;
}
declare const MSColorSpaceConverter: {
  alloc(): MSColorSpaceConverterAllocator;
}

interface MSCompoundSnapItemAllocator<InitializedType = MSCompoundSnapItem> extends MSSnapItemAllocator<MSCompoundSnapItem> {}
interface MSCompoundSnapItem extends MSSnapItem {
}
declare const MSCompoundSnapItem: {
  alloc(): MSCompoundSnapItemAllocator;
}

interface MSCoordinateInspectorValueAdaptorAllocator<InitializedType = MSCoordinateInspectorValueAdaptor> extends MSMathInspectorValueAdaptorAllocator<MSCoordinateInspectorValueAdaptor> {
  initWithLayerController_layerKeyPath_axis(layerController: NSArrayController, keyPath: NSString | string, axis: BCAxis): InitializedType;
  initWithLayerController_valueGetter_valueSetter_layerKeyPathsToWatch_axis(layerController: NSArrayController, valueGetter: Block, valueSetter: Block, layerKeyPathsToWatch: NSArray<any> | any[], axis: BCAxis): InitializedType;
}
interface MSCoordinateInspectorValueAdaptor extends MSMathInspectorValueAdaptor {

  axis(): BCAxis;
}
declare const MSCoordinateInspectorValueAdaptor: {
  alloc(): MSCoordinateInspectorValueAdaptorAllocator;
}

interface MSCornerRadiusInspectorValueAdaptorAllocator<InitializedType = MSCornerRadiusInspectorValueAdaptor> extends MSMathInspectorValueAdaptorAllocator<MSCornerRadiusInspectorValueAdaptor> {
  initWithModelsController(arrayController: NSArrayController): InitializedType;
}
interface MSCornerRadiusInspectorValueAdaptor extends MSMathInspectorValueAdaptor {
}
declare const MSCornerRadiusInspectorValueAdaptor: {
  alloc(): MSCornerRadiusInspectorValueAdaptorAllocator;
}

interface MSCornerRadiusInspectorValueAdaptorContextAllocator<InitializedType = MSCornerRadiusInspectorValueAdaptorContext> extends NSObjectAllocator<MSCornerRadiusInspectorValueAdaptorContext> {}
interface MSCornerRadiusInspectorValueAdaptorContext extends NSObject {
  componentStringWithMathValueForModel(model: MSRectangleShape): NSString;

  mode(): MSCornerRadiusMode;
  setMode(mode: MSCornerRadiusMode): void;
  componentString(): NSString;
  setComponentString(componentString: NSString | string): void;
  mathOperator(): NSString;
  setMathOperator(mathOperator: NSString | string): void;
  value(): NSNumber;
  setValue(value: NSNumber | number): void;
}
declare const MSCornerRadiusInspectorValueAdaptorContext: {
  alloc(): MSCornerRadiusInspectorValueAdaptorContextAllocator;
}

declare enum MSCornerRadiusMode {
  MSCornerRadiusModeComponentString,
  MSCornerRadiusModeMath,
  MSCornerRadiusModeValue,
}

interface MSDataMenuProviderAllocator<InitializedType = MSDataMenuProvider> extends NSObjectAllocator<MSDataMenuProvider> {
  initWithDataManager(dataManager: MSDataSupplierManager): InitializedType;
}
interface MSDataMenuProvider extends NSObject, INSMenuDelegate {
  menu(): NSMenu;
  overridesMenu(): NSMenu;
  menuItemsForDataType_indentationLevel_smallFont(dataType: MSDataType, menuItemIndentation: NSInteger, smallFont: boolean): NSArray<any>;
  clearDataMenuItemWithSmallFont(smallFont: boolean): NSMenuItem;
  refreshDataMenuItemsWithSmallFont_overridesMenu(smallFont: boolean, overridesMenu: boolean): NSArray<any>;
  addImageToMenuItems(menuItems: NSArray<any> | any[]): NSImage;

  dataManager(): MSDataSupplierManager;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSDataMenuProvider: {
  alloc(): MSDataMenuProviderAllocator;
}

interface IMSDataMenuProviderDelegate {
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
}

interface MSDataOverrideAllocator<InitializedType = MSDataOverride> extends NSObjectAllocator<MSDataOverride> {
  initWithOverride_symbolInstance(availableOverride: MSAvailableOverride, symbolInstance: MSSymbolInstance): InitializedType;
}
interface MSDataOverride extends NSObject {

  availableOverride(): MSAvailableOverride;
  symbolInstance(): MSSymbolInstance;
  affectedLayer(): MSImmutableStyledLayer;
  overrideIdentifier(): NSString;
}
declare const MSDataOverride: {
  alloc(): MSDataOverrideAllocator;
}

interface MSDataSupplierAllocator<InitializedType = MSDataSupplier> extends NSObjectAllocator<MSDataSupplier> {
  initWithDataIdentifier_dataName_dataType(dataIdentifier: NSString | string, dataName: NSString | string, dataType: MSDataType): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface MSDataSupplier extends NSObject, INSCoding {
  resetMenuItemImage(): void;
  imageFileURLForDataItem(dataItem: NSString | string): NSURL;
  applyDataWithCount_data_dataApplier(count: NSUInteger, dataArray: NSArray<any> | any[], block: MSDataApplierBlock): void;
  generateDataForLayers_dataSupplierManager_dataApplier(layers: NSArray<any> | any[], manager: MSDataSupplierManager, applierBlock: MSDataApplierBlock): void;
  generateDataForOverrides_dataSupplierManager_dataApplier(overrides: NSArray<any> | any[], manager: MSDataSupplierManager, applierBlock: MSDataApplierBlock): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  dataName(): NSString;
  setDataName(dataName: NSString | string): void;
  dataType(): MSDataType;
  dataIdentifier(): NSString;
  valid(): boolean;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  menuItemImage(): NSImage;
}
declare const MSDataSupplier: {
  alloc(): MSDataSupplierAllocator;
}

interface IMSDataSupplierDelegate {
  dataSupplierMenuItemImage(dataSupplier: MSDataSupplier): NSImage;
  dataSupplierDataChanged(localDataSupplier: MSLocalDataSupplier): void;
}

interface MSDataSupplierManagerAllocator<InitializedType = MSDataSupplierManager> extends NSObjectAllocator<MSDataSupplierManager> {
  initWithDelegate(delegate: any): InitializedType;
}
interface MSDataSupplierManager extends NSObject {
  registerPluginDataSupplier_withName_dataType_pluginIdentifier_commandIdentifier(dynamicDataKey: NSString | string, dataName: NSString | string, dataType: NSString | string, pluginIdentifier: NSString | string, commandIdentifier: NSString | string): void;
  deregisterDataSuppliersForPluginWithIdentifier(pluginIdentifier: NSString | string): void;
  removePluginDataSuppliersNotIdentifiedWithIdentifiers(dataSupplierIdentifiers: NSDictionary<any, any> | {[key: string]: any}): void;
  requestDataFromPluginDataSupplier_dataContext_applierBlock(dataSupplier: MSPluginDataSupplier, dataSupplierContext: MSPluginDataSupplierContext, applierBlock: MSDataApplierBlock): void;
  supplyData_forKey(data: NSArray<any> | any[], dataKey: NSString | string): void;
  addLocalData(localDataSupplier: MSLocalDataSupplier): void;
  removeLocalDataSupplier(dataSupplier: MSLocalDataSupplier): void;
  loadDataSuppliersWithResetBuiltin(resetBuiltin: boolean): void;
  hasLocalDataSupplierWithURL(dataURL: NSURL): boolean;
  dataSupplierWithIdentifier(identifier: NSString | string | null): MSDataSupplier;
  useableDataSupplierWithIdentifier(identifier: NSString | string): MSDataSupplier;

  dataSuppliers(): NSArray<any>;
  delegate(): any;
}
declare const MSDataSupplierManager: {
  alloc(): MSDataSupplierManagerAllocator;  validLocalDataFileSystemURL(possibleDataURL: NSURL): boolean;
  URLForBuiltinDataNamed(name: NSString | string): NSURL;

}

interface IMSDataSupplierManagerDelegate {
  requestDataFromPluginDataSupplier_pluginContext(pluginDataSupplier: MSPluginDataSupplier, pluginContext: NSDictionary<any, any> | {[key: string]: any}): void;
  isThereAPluginForDataSupplier(pluginDataSupplier: MSPluginDataSupplier): boolean;
  pluginIconForIdentifier(pluginIdentifier: NSString | string): NSImage;
  pluginNameForIdentifier(pluginIdentifier: NSString | string): NSString;
}

declare enum MSDataType {
  MSDataTypeNone = 0,
  MSDataTypeText = 1<<0,
  MSDataTypeImage = 1<<1,
  MSDataTypeAny,
}

interface MSDigitStringFormatterAllocator<InitializedType = MSDigitStringFormatter> extends NSFormatterAllocator<MSDigitStringFormatter> {}
interface MSDigitStringFormatter extends NSFormatter {
}
declare const MSDigitStringFormatter: {
  alloc(): MSDigitStringFormatterAllocator;  isDigitString(string: NSString | string): boolean;

}

interface MSDocumentDataAllocator<InitializedType = MSDocumentData> extends _MSDocumentDataAllocator<MSDocumentData> {}
interface MSDocumentData extends _MSDocumentData, IMSDocumentData {
  enumerateColorConvertiblesIgnoringForeignSymbols(block: MSColorConvertibleHandler): void;
  replaceInstancesOfColor_withColor_ignoreAlphaWhenMatching_replaceAlphaOfOriginalColor(color: MSColor, replacementColor: MSColor, ignoreAlphaWhenMatching: boolean, replaceAlphaOfOriginalColor: boolean): void;
  assignColorSpace(colorSpace: MSColorSpace): void;
  convertToColorSpace(colorSpace: MSColorSpace): void;
  defaultPagesArray(): NSArray<any>;
  removePages_detachInstances(page: NSArray<any> | any[], shouldDetachInstances: boolean): void;
  addBlankPage(): MSPage;
  symbolsPage(): MSPage;
  symbolsPageOrCreateIfNecessary(): MSPage;
  sharedObjectContainerOfType(type: MSSharedStyleType): MSSharedObjectContainer;
  documentIsEmpty(): boolean;
  selectedLayers(): MSLayerArray;
  layerTreeLayoutDidChange(): void;
  layerWithID(objectID: NSString | string): MSLayer;
  artboardWithID(objectID: any): MSArtboardGroup;
  layersByObjectID(): NSDictionary<any, any>;
  allArtboards(): NSArray<any>;
  allSymbols(): NSArray<any>;
  localSymbols(): NSArray<any>;
  symbolWithID(symbolID: any): MSSymbolMaster;
  textStyleWithID(sharedStyleID: NSString | string | null): MSSharedStyle;
  layerStyleWithID(sharedStyleID: NSString | string | null): MSSharedStyle;
  allForeignObjects(): NSArray<any>;
  addCopyOfMasterToDocumentIfNecessary(master: MSSymbolMaster): MSSymbolMaster;
  addCopyOfInstanceMasterToDocumentIfNecessary(instance: MSSymbolInstance): MSSymbolMaster;
  addSymbolMaster(master: MSSymbolMaster): void;
  enumerateForeignObjects_withLibraries_block(objects: NSArray<any> | any[], libraries: NSArray<any> | any[], block: Block): void;
  libraryForForeignObject_inLibraries(object: MSForeignObject, libraries: NSArray<any> | any[]): any;
  temporarilyHideSelectionForLayers(layer: NSArray<any> | any[]): void;
  immediatelyShowSelectionForAllLayers(): void;
  replaceExistingCreationMetadata(): void;
  refreshOverlayInRect(rect: NSRect): void;
  refreshOverlay(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  purgeForeignObjects(): void;
  invalidateAffectedSymbolInstances(): void;
  removeShareableObjectsFromInstanceOverrides(removed: NSSet<any>): void;
  replaceFonts(fontReplacements: NSDictionary<any, any> | {[key: string]: any}): void;
  invalidateFonts(): void;
  storeMetadata_forKey_object(toStore: any, key: NSString | string, object: MSModelObject): void;
  metadataForKey_object(key: NSString | string, object: MSModelObject): any;

  cache(): BCCache;
  setCache(cache: BCCache): void;
  currentPage(): MSPage;
  setCurrentPage(currentPage: MSPage): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  autoExpandGroupsInLayerList(): boolean;
  setAutoExpandGroupsInLayerList(autoExpandGroupsInLayerList: boolean): void;
  metadata(): NSDictionary<any, any>;
  fontList(): MSFontList;
  selectedOverrides(): NSArray<any>;
  setSelectedOverrides(selectedOverrides: NSArray<any> | any[]): void;
}
declare const MSDocumentData: {
  alloc(): MSDocumentDataAllocator;
}

interface MSDocumentationSearchEntryAllocator<InitializedType = MSDocumentationSearchEntry> extends NSObjectAllocator<MSDocumentationSearchEntry> {}
interface MSDocumentationSearchEntry extends NSObject {
  titles(): NSArray<any>;
  matchesSearchQuery(query: NSString | string): boolean;
  show(): void;
}
declare const MSDocumentationSearchEntry: {
  alloc(): MSDocumentationSearchEntryAllocator;  searchEntryWithDictionary(dict: NSDictionary<any, any> | {[key: string]: any}): MSDocumentationSearchEntry;
  markSearchEntriesAsDuplicates(entries: NSArray<any> | any[]): void;

}

interface MSDocumentationSearcherAllocator<InitializedType = MSDocumentationSearcher> extends NSObjectAllocator<MSDocumentationSearcher> {}
interface MSDocumentationSearcher extends NSObject, INSUserInterfaceItemSearching {
  documentationMightHaveChanged(): void;
}
declare const MSDocumentationSearcher: {
  alloc(): MSDocumentationSearcherAllocator;
}

interface MSDragGestureRecognizerAllocator<InitializedType = MSDragGestureRecognizer> extends MSGestureRecognizerAllocator<MSDragGestureRecognizer> {}
interface MSDragGestureRecognizer extends MSGestureRecognizer {
  locationInLayer(layer: MSLayer | null): NSPoint;
  translationInLayer(layer: MSLayer | null): CGVector;
  setTranslation_inLayer(translation: CGVector, layer: MSLayer | null): void;
  translationAsPointInLayer(layer: MSLayer | null): NSPoint;
  originInLayer(layer: MSLayer | null): NSPoint;

  beginsUponMouseDown(): boolean;
  setBeginsUponMouseDown(beginsUponMouseDown: boolean): void;
  translationLocked(): boolean;
  setTranslationLocked(translationLocked: boolean): void;
  modifierFlags(): NSEventModifierFlags;
}
declare const MSDragGestureRecognizer: {
  alloc(): MSDragGestureRecognizerAllocator;
}

interface MSExportRequestAllocator<InitializedType = MSExportRequest> extends NSObjectAllocator<MSExportRequest> {}
interface MSExportRequest extends NSObject, INSCopying {
  readSettingsFromDefaults(): void;
  configureForLayer_layerOptions_includedIDs(layer: MSLayer, layerOptions: MSExportLayerOptions, includedIDs: NSArray<any> | any[]): void;
  setNameFromID_exportFormat(objectID: NSString | string, format: MSImmutableExportFormat): void;
  configureForLayerAncestry_layerOptions_includedIDs(ancestry: MSImmutableLayerAncestry, layerOptions: MSExportLayerOptions, includedIDs: NSArray<any> | any[]): void;

  rect(): NSRect;
  setRect(rect: NSRect): void;
  name(): NSString;
  setName(name: NSString | string): void;
  options(): MSExportLayerOptions;
  setOptions(options: MSExportLayerOptions): void;
  includedLayerIDs(): NSSet<any>;
  setIncludedLayerIDs(includedLayerIDs: NSSet<any>): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  shouldTrim(): boolean;
  setShouldTrim(shouldTrim: boolean): void;
  backgroundColor(): MSImmutableColor;
  setBackgroundColor(backgroundColor: MSImmutableColor): void;
  rootLayer(): MSImmutableLayer;
  setRootLayer(rootLayer: MSImmutableLayer): void;
  immutableDocument(): MSImmutableDocumentData;
  setImmutableDocument(immutableDocument: MSImmutableDocumentData): void;
  format(): NSString;
  setFormat(format: NSString | string): void;
  saveForWeb(): boolean;
  setSaveForWeb(saveForWeb: boolean): void;
  compression(): CGFloat;
  setCompression(compression: CGFloat): void;
  progressive(): boolean;
  setProgressive(progressive: boolean): void;
  interlaced(): boolean;
  setInterlaced(interlaced: boolean): void;
  includeArtboardBackground(): boolean;
  setIncludeArtboardBackground(includeArtboardBackground: boolean): void;
}
declare const MSExportRequest: {
  alloc(): MSExportRequestAllocator;  exportRequestsFromExportableLayer(layer: MSLayer): NSArray<any>;
  exportRequestsFromExportableLayer_useIDForName(layer: MSLayer, useIDForName: boolean): NSArray<any>;
  exportRequestsFromExportableLayer_exportFormats_useIDForName(layer: MSLayer, exportFormats: NSArray<any> | any[], useIDForName: boolean): NSArray<any>;
  exportRequestsFromExportableLayer_inRect_useIDForName(layer: MSLayer, rect: NSRect, useIDForName: boolean): NSArray<any>;
  exportRequestsFromExportableLayer_exportFormats_inRect_useIDForName(layer: MSLayer, exportFormats: NSArray<any> | any[], rect: NSRect, useIDForName: boolean): NSArray<any>;
  exportRequestFromExportFormat_layer_inRect_useIDForName(exportFormat: MSExportFormat, layer: MSLayer, rect: NSRect, useIDForName: boolean): MSExportRequest;
  exportRequestsFromLayerAncestry(layerAncestry: MSImmutableLayerAncestry): NSArray<any>;
  exportRequestsFromLayerAncestry_inRect(layerAncestry: MSImmutableLayerAncestry, rect: NSRect): NSArray<any>;
  exportRequestsFromLayerAncestry_exportFormats(layerAncestry: MSImmutableLayerAncestry, exportFormats: NSArray<any> | any[]): NSArray<any>;
  exportRequestsFromLayerAncestry_exportFormats_inRect(layerAncestry: MSImmutableLayerAncestry, exportFormats: NSArray<any> | any[], rect: NSRect): NSArray<any>;
  exportRequestFromLayerAncestry_exportFormat_inRect(ancestry: MSImmutableLayerAncestry, exportFormat: MSImmutableExportFormat, rect: NSRect): MSExportRequest;

}

interface MSFlashControllerAllocator<InitializedType = MSFlashController> extends NSObjectAllocator<MSFlashController> {}
interface MSFlashController extends NSObject {
  displayFlashMessage(message: NSString | string): any;
  displayWarningMessage_withHelpHandler(message: NSString | string, helpBlock: MSFlashControllerHelpBlock | null): any;
  displayFixedMessage_withHelpHandler(message: NSString | string, helpBlock: MSFlashControllerHelpBlock | null): any;
  removeMessage(message: any): void;
  clearFlash(): void;

  stackView(): NSStackView;
  setStackView(stackView: NSStackView): void;
}
declare const MSFlashController: {
  alloc(): MSFlashControllerAllocator;
}

interface MSFlashViewControllerAllocator<InitializedType = MSFlashViewController> extends NSViewControllerAllocator<MSFlashViewController> {}
interface MSFlashViewController extends NSViewController {
}
declare const MSFlashViewController: {
  alloc(): MSFlashViewControllerAllocator;  flashViewControllerWithMessage_closeBlock_helpBlock(message: NSString | string, closeBlock: MSFlashViewControllerBlock | null, helpBlock: MSFlashViewControllerBlock | null): MSFlashViewController;

}

interface MSFlattenActionValidatorAllocator<InitializedType = MSFlattenActionValidator> extends NSObjectAllocator<MSFlattenActionValidator> {}
interface MSFlattenActionValidator extends NSObject {
}
declare const MSFlattenActionValidator: {
  alloc(): MSFlattenActionValidatorAllocator;  isValidForSelectedLayers(selectedLayers: MSLayerArray): boolean;
  hasFlattenablePathInSelection(selectedLayers: MSLayerArray): boolean;

}

interface MSForeignObjectCollectorAllocator<InitializedType = MSForeignObjectCollector> extends NSObjectAllocator<MSForeignObjectCollector> {
  initWithProvider(provider: any): InitializedType;
}
interface MSForeignObjectCollector extends NSObject {
  buildCollectionWithFilter(filter: MSForeignObjectCollectionFilter | null): NSArray<any>;

  provider(): any;
}
declare const MSForeignObjectCollector: {
  alloc(): MSForeignObjectCollectorAllocator;
}

interface IMSForeignObjectProvider {
  localObjectsForDocument(document: MSDocumentData): NSArray<any>;
  currentDocumentIsLibrary(library: MSAssetLibrary): boolean;
  masterObjectForInstance(instance: MSModelObject): MSShareableObject;
  masterIsOutOfSyncWithInstance(instance: MSModelObject): boolean;

  foreignObjects(): NSArray<any>;
  currentDocument(): MSDocumentData;
  libraryController(): MSAssetLibraryController;
  objectType(): MSShareableObjectType;
}

interface MSForeignObjectMenuBuilderAllocator<InitializedType = MSForeignObjectMenuBuilder> extends MSSortableObjectMenuBuilderAllocator<MSForeignObjectMenuBuilder> {
  initWithCollector_delegate(collector: MSForeignObjectCollector, delegate: any): InitializedType;
  initWithProvider_delegate(provider: any, delegate: any): InitializedType;
}
interface MSForeignObjectMenuBuilder extends MSSortableObjectMenuBuilder {
  buildMenuItemsForMenu_withTarget_selector(menu: NSMenu, target: any, selector: string): NSArray<any>;
  buildMenuItemsForMenu_withAction(menu: NSMenu, action: MSAction): NSArray<any>;
  gatherSymbolsForMenus(): NSArray<any>;
  menuItemForLibrary_mainMenu_target_selector(library: MSAssetLibrary | null, mainMenu: boolean, target: any | null, selector: string | null): NSMenuItem;

  filter(): MSForeignObjectCollectionFilter;
  setFilter(filter: MSForeignObjectCollectionFilter): void;
  requiresLocalSubmenu(): boolean;
  setRequiresLocalSubmenu(requiresLocalSubmenu: boolean): void;
  collector(): MSForeignObjectCollector;
}
declare const MSForeignObjectMenuBuilder: {
  alloc(): MSForeignObjectMenuBuilderAllocator;  filterForReplacingSymbolInstances(layers: NSArray<any> | any[]): MSForeignObjectCollectionFilter;

}

interface MSGestureRecognizerAllocator<InitializedType = MSGestureRecognizer> extends NSObjectAllocator<MSGestureRecognizer> {
  initWithTarget_action(target: any | null, action: string | null): InitializedType;
}
interface MSGestureRecognizer extends NSObject {
  locationInLayer(layer: MSLayer | null): NSPoint;
  reset(): void;
  mouseDown_clickCount_modifierFlags(location: NSPoint, clickCount: NSUInteger, flags: NSEventModifierFlags): void;
  mouseUp_location(event: NSEvent, location: NSPoint): void;
  mouseDragged_modifierFlags(location: NSPoint, flags: NSEventModifierFlags): void;
  keyDown(event: NSEvent): void;
  keyUp_flags(c: unichar, flags: NSUInteger): void;
  flagsChanged(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  state(): NSGestureRecognizerState;
  setState(state: NSGestureRecognizerState): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSGestureRecognizer: {
  alloc(): MSGestureRecognizerAllocator;
}

interface IMSGestureRecognizerDelegate {
  gestureRecognizer_shouldAttemptToRecognizeAtPoint_modifierFlags(gestureRecognizer: MSGestureRecognizer, point: NSPoint, flags: NSEventModifierFlags): boolean;
}

interface MSGridConstructorAllocator<InitializedType = MSGridConstructor> extends NSObjectAllocator<MSGridConstructor> {}
interface MSGridConstructor extends NSObject {
  makeGridWithLayers_options(layers: MSLayerArray, options: MSMakeGridOptions): void;
}
declare const MSGridConstructor: {
  alloc(): MSGridConstructorAllocator;
}

declare type MSMakeGridOptions = {
  numberOfRows: NSUInteger
  numberOfColumns: NSUInteger
  horizontalPadding: NSInteger
  verticalPadding: NSInteger
  hasHorizontalPadding: boolean
  hasVerticalPadding: boolean
  skipFillingHoles: boolean
}

interface IMSHUDClient {
  hudSetMonitor(monitor: MSRenderMonitor): void;

  hudClientName(): NSString;
  hudDocumentData(): MSDocumentData;
}

interface IMSHUDOwner {

  hud(): MSHUDWindowController;
}

interface MSHUDViewControllerAllocator<InitializedType = MSHUDViewController> extends NSViewControllerAllocator<MSHUDViewController> {}
interface MSHUDViewController extends NSViewController {
}
declare const MSHUDViewController: {
  alloc(): MSHUDViewControllerAllocator;
}

interface MSHUDWindowControllerAllocator<InitializedType = MSHUDWindowController> extends NSWindowControllerAllocator<MSHUDWindowController> {}
interface MSHUDWindowController extends NSWindowController, INSWindowDelegate {
  toggle(): void;

  isVisible(): boolean;
}
declare const MSHUDWindowController: {
  alloc(): MSHUDWindowControllerAllocator;  makeHUD(): MSHUDWindowController;

}

interface MSHandleDrawingAllocator<InitializedType = MSHandleDrawing> extends NSObjectAllocator<MSHandleDrawing> {}
interface MSHandleDrawing extends NSObject {
}
declare const MSHandleDrawing: {
  alloc(): MSHandleDrawingAllocator;  drawRectAtPoint_ofType(aPoint: NSPoint, type: MSDotRectType): void;
  drawBezier(bezier: NSBezierPath): void;
  drawAtPoint_ofType_state(aPoint: NSPoint, type: MSHandleSize, state: MSHandleState): void;
  drawGradientHandleAtPoint_color_selected(aPoint: NSPoint, aColor: NSColor | null, isSelected: boolean): void;
  drawShadowForHover_inBlock(isHovering: boolean, block: BCVoidBlock): void;
  drawWithTransformStruct_aroundPoint_usingBlock(tStruct: CHTransformStruct, point: NSPoint, block: Block): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  resetZoomValue(): void;

}

declare enum MSHandleSize {
  MSHandleSizeSmall = 0,
  MSHandleSizeRegular = 1,
  MSHandleSizeHuge = 2,
}

declare enum MSHandleState {
  MSHandleStateNormal = 0,
  MSHandleStateHighlighted = 1 << 0,
  MSHandleStateHovering = 1 << 1,
  MSHandleStateSelected = 1 << 2,
  MSHandleStateRelatedToSelection = 1 << 4,
}

declare enum MSDotRectType {
  MSDotRectGradient,
  MSDotRectLocked,
}

declare enum MSVectorComponent {
  MSVectorComponentPoint,
  MSVectorComponentHandle1,
  MSVectorComponentHandle2,
  MSVectorComponentSegment = 5,
}

interface MSHistoryAllocator<InitializedType = MSHistory> extends NSObjectAllocator<MSHistory> {
  initWithInitialMoment(initMoment: MSMoment): InitializedType;
}
interface MSHistory extends NSObject {
  addMoment(newMoment: MSMoment): MSHistoryUpdate;
  addMomentWithTitle_documentData(title: NSString | string, documentData: MSImmutableDocumentData): MSHistoryUpdate;
  addMomentWithTitle_documentData_adaptability(newTitle: NSString | string, documentData: MSImmutableDocumentData, adaptability: MSMomentAdaptability): MSHistoryUpdate;
  revertToPreviousMoment(): boolean;
  progressToNextMoment(): boolean;
  commitCurrentMoment(): void;

  currentMoment(): MSMoment;
  previousMoment(): MSMoment;
  nextMoment(): MSMoment;
  canRevertToPreviousMoment(): boolean;
  canProgressToNextMoment(): boolean;
  allowsCoalescingOfMomentsCloseInTime(): boolean;
  setAllowsCoalescingOfMomentsCloseInTime(allowsCoalescingOfMomentsCloseInTime: boolean): void;
  numberOfMoments(): NSUInteger;
}
declare const MSHistory: {
  alloc(): MSHistoryAllocator;
}

declare enum MSHistoryUpdate {
  MSHistoryUpdateNoChange = 0,
  MSHistoryUpdateAddedMoment,
  MSHistoryUpdateCoalescedMoment,
  MSHistoryUpdateAmendedMoment,
}

interface IMSHoverableItem {
  drawHoverWithZoom_color_cache(zoom: CGFloat, color: NSColor, cache: BCCache): void;
  canBeHoveredOnPage(page: MSPage): boolean;
  refreshOverlay(): void;

  hoveredLayer(): MSLayer;
}

interface MSImageLayerImporterAllocator<InitializedType = MSImageLayerImporter> extends NSObjectAllocator<MSImageLayerImporter> {}
interface MSImageLayerImporter extends NSObject {
}
declare const MSImageLayerImporter: {
  alloc(): MSImageLayerImporterAllocator;  layerWithContentsOfPath_mode(fileURL: NSURL, importPreference: MSPasteboardImagePreferMode): MSLayer;

}

declare enum MSPasteboardImagePreferMode {
  MSPasteboardImagePreferVectors,
  MSPasteboardImagePreferImages,
}

interface MSImageSizeReducerAllocator<InitializedType = MSImageSizeReducer> extends NSObjectAllocator<MSImageSizeReducer> {}
interface MSImageSizeReducer extends NSObject {
}
declare const MSImageSizeReducer: {
  alloc(): MSImageSizeReducerAllocator;  reduceImageSizeOfLayers_windowForSheet_completionBlock(layers: NSArray<any> | any[], windowForSheet: NSWindow | null, completionBlock: BCVoidBlock | null): void;
  largestSizeForImagesMapTableFromOwners(layers: NSArray<any> | any[]): NSMapTable<any, any>;

}

interface MSImmutableColorAllocator<InitializedType = MSImmutableColor> extends _MSImmutableColorAllocator<MSImmutableColor> {}
interface MSImmutableColor extends _MSImmutableColor, IMSColor {
  NSColorWithColorSpace(colorSpace: NSColorSpace): NSColor;
  newCGColorWithColorSpace(colorSpace: CGColorSpaceRef): CGColorRef;
  hexValue(): NSString;
  isWhite(): boolean;
  isBlack(): boolean;
  isGrayscale(): boolean;
  fuzzyIsEqual(other: MSImmutableColor): boolean;
  fuzzyIsEqual_precision(other: MSImmutableColor, precision: CGFloat): boolean;
  fuzzyIsEqualExcludingAlpha(other: MSImmutableColor): boolean;
  fuzzyIsEqualExcludingAlpha_precision(other: MSImmutableColor, precision: CGFloat): boolean;
  colorWithAlphaComponent(alpha: CGFloat): MSImmutableColor;
  stringValueWithAlpha(includeAlpha: boolean): NSString;
  stringValueWithAlpha_alphaMultiplication(includeAlpha: boolean, alphaMultiplication: CGFloat): NSString;
  svgRepresentation(): NSString;
  NSColorForContext(context: MSRenderingContext): NSColor;

  manifestComponents(): NSArray<any>;
  opaque(): boolean;
}
declare const MSImmutableColor: {
  alloc(): MSImmutableColorAllocator;  colorWithNSColor(color: NSColor): MSImmutableColor;
  colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): MSImmutableColor;
  colorWithWhite_alpha(white: CGFloat, alpha: CGFloat): MSImmutableColor;
  colorWithIntegerRed_green_blue(red: NSInteger, green: NSInteger, blue: NSInteger): MSImmutableColor;
  colorWithIntegerRed_green_blue_alpha(red: NSInteger, green: NSInteger, blue: NSInteger, alpha: NSInteger): MSImmutableColor;
  whiteColor(): MSImmutableColor;
  blackColor(): MSImmutableColor;
  availableRGBColorSpaces(): NSArray<any>;
  getRed_green_blue_fromHexValue(red: CGFloat, green: CGFloat, blue: CGFloat, hexValue: NSString | string): void;
  hexValueForRed_green_blue(red: CGFloat, green: CGFloat, blue: CGFloat): NSString;
  namedColor(name: NSString | string): MSImmutableColor;
  colorWithSVGString(string: NSString | string): MSImmutableColor;

}

interface MSImmutableLayerGroupAllocator<InitializedType = MSImmutableLayerGroup> extends _MSImmutableLayerGroupAllocator<MSImmutableLayerGroup> {}
interface MSImmutableLayerGroup extends _MSImmutableLayerGroup, IMSLayerGroup {
  influenceRectClipsToBounds(): boolean;
  includeChildrenInCalculatingStyleSize(): boolean;
  pathCombiningChildrenByApplyingBlock(block: Block): MSPath;
  constraintForLayer(layer: MSImmutableLayer): BCConstraint;
  addChildrenToElement_exporter(parentElement: NSXMLElement, exporter: SketchSVGExporter): void;

  mirrorExportScale(): CGFloat;
  mirrorViewPortSize(): CGSize;
}
declare const MSImmutableLayerGroup: {
  alloc(): MSImmutableLayerGroupAllocator;
}

interface IMSImporter extends NSObject {
  prepareToImportFromData(data: NSData): NSUInteger;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importIntoPage_name_progress(page: MSPage, name: NSString | string, progress: BCVoidBlock): void;
  finishImporting(): void;
  firstPhaseSubtitle(): NSString;
  secondPhaseSubtitleForValue_maximum(value: NSInteger, maximum: NSInteger): NSString;
  shouldExpandPages(): boolean;
  shouldCollapseSinglePage(): boolean;
  importAsLayer(): MSLayer;
}

interface MSInspectorNumberFormatterAllocator<InitializedType = MSInspectorNumberFormatter> extends NSNumberFormatterAllocator<MSInspectorNumberFormatter> {}
interface MSInspectorNumberFormatter extends NSNumberFormatter {
}
declare const MSInspectorNumberFormatter: {
  alloc(): MSInspectorNumberFormatterAllocator;  standardFloatFormatter(): MSInspectorNumberFormatter;
  standardIntegerFormatter(): MSInspectorNumberFormatter;
  standardPercentFormatter(): MSInspectorNumberFormatter;
  standardPercentFormatterWithoutPercentSign(): MSInspectorNumberFormatter;

}

interface IMSInspectorSection {
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
}

interface MSInspectorValueAdaptorAllocator<InitializedType = MSInspectorValueAdaptor> extends NSObjectAllocator<MSInspectorValueAdaptor> {
  initWithModelsController_valueGetter_valueSetter_modelKeyPathsToWatch(modelsController: NSArrayController, valueGetter: Block, valueSetter: Block, modelKeyPathsToWatch: NSArray<any> | any[]): InitializedType;
  initWithModelsController_valueGetter_valueSetter(modelsController: NSArrayController, valueGetter: Block, valueSetter: Block): InitializedType;
  initWithModelsController_modelKeyPath(modelsController: NSArrayController, keyPath: NSString | string): InitializedType;
}
interface MSInspectorValueAdaptor extends NSObject {
  transformedValuesFromAdaptorValue_contexts_error(adaptorValue: AdaptorValueType, contextsOut: NSPointerArray, error: NSError): NSArray<any>;
  transformAdaptorValue_forModel_context_error(adaptorValue: AdaptorValueType, model: ModelType, context: any, error: NSError): ModelValueType;
  valuesDidChange(): void;
  addChangeObserver(observer: any): void;
  removeChangeObserver(observer: any): void;

  modelsController(): NSArrayController;
  value(): AdaptorValueType;
  setValue(value: AdaptorValueType): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  showsDefaultAlerts(): boolean;
  setShowsDefaultAlerts(showsDefaultAlerts: boolean): void;
  view(): NSView;
  setView(view: NSView): void;
}
declare const MSInspectorValueAdaptor: {
  alloc(): MSInspectorValueAdaptorAllocator;
}

declare type ModelType = any

declare type ModelValueType = any

declare type AdaptorValueType = any

declare enum MSInspectorValueAdaptorErrorCode {
  MSInspectorValueAdaptorErrorInvalidInput = 1,
}

interface IMSInspectorValueAdaptorChangeObserver {
  inspectorValueAdaptorDidChangeValue(adaptor: MSInspectorValueAdaptor): void;
}

interface IMSInspectorValueAdaptorDelegate {
  inspectorValueAdaptor_validateValue_forModel_context(adaptor: MSInspectorValueAdaptor, value: ModelValueType, model: any, context: any): boolean;
  inspectorValueAdaptorDidChangeValue(adaptor: MSInspectorValueAdaptor): void;
  inspectorValueAdaptor_didEncounterError(adaptor: MSInspectorValueAdaptor, error: NSError): void;
}

interface MSLayerAllocator<InitializedType = MSLayer> extends _MSLayerAllocator<MSLayer> {
  initWithFrame(frame: NSRect): InitializedType;
}
interface MSLayer extends _MSLayer, IMSLayer, INSCopying, IMSRectDelegate {
  hudDescription(): NSString;
  layerDidResizeFromInspector(axis: BCAxis): void;
  boundsOfParentLayer(): NSRect;
  minimumAdjustedRectForValue_axis_anchor(value: CGFloat, axis: BCAxis, anchor: BCCorner): CGRect;
  layersByConvertingToOutlines(): NSArray<any>;
  canConvertToOutlines(): boolean;
  replaceWithInstanceOfSymbol(symbol: MSSymbolMaster): MSSymbolInstance;
  snapItemClass(): any;
  canSnap_toLayer(snapType: MSSnapType, otherLayer: MSLayer): boolean;
  styleForBooleanOperation(): MSStyle;
  supportsInnerOuterBorders(): boolean;
  supportsMultipleShadows(): boolean;
  changeColor(sender: any): void;
  displayName(): NSString;
  parentForInsertingLayers(): MSLayerGroup;
  canCutSegments(): boolean;
  possiblyFixRectangleBorderBeforeCut(): void;
  cutBezierSegmentAtIndex(index: NSUInteger): void;
  CSSAttributeString(): NSString;
  CSSAttributes(): NSArray<any>;
  resetConstraints(): void;
  replaceFonts(fontReplacements: NSDictionary<any, any> | {[key: string]: any}): void;
  selectionHitTest_options_zoomValue(point: NSPoint, options: MSLayerSelectionOptions, zoomValue: CGFloat): MSHitTestResult;
  containsPoint_options_zoomValue(point: NSPoint, options: MSLayerSelectionOptions, zoomValue: CGFloat): boolean;
  hitTestRect_options(selectionRect: NSRect, options: MSLayerSelectionOptions): boolean;
  layoutDirection(): NSUserInterfaceLayoutDirection;
  applyOverrides_document(overrides: NSArray<any> | any[], document: MSImmutableDocumentData): void;
  applyOverride_document(overrideValue: MSImmutableOverrideValue, document: MSImmutableDocumentData): void;
  applyRotation_explicitRotationCenter(rotation: CGFloat, rotationCenter: NSValue | null): void;
  applyUserVisibleRotation_explicitRotationCenter(userVisibleRotation: CGFloat, rotationCenter: NSValue | null): void;
  resetSharedStyle(): void;
  updateSharedStyleToMatchSelf(): void;
  makeNameUniqueWithOptions(options: MSLayerRenameOptions): void;
  makeNameUniqueInRoot_withOptions(root: any, options: MSLayerRenameOptions): void;
  rootForNameUniquing(): any;
  frameForTransforms(): NSRect;
  absoluteRect(): MSAbsoluteRect;
  setWidthRespectingProportions(newWidth: CGFloat): void;
  setHeightRespectingProportions(newHeight: CGFloat): void;
  calculateProportions(): void;
  makeOriginIntegral(): void;
  makeRectIntegral(): void;
  isRectIntegral(): boolean;
  moveBySuggestedOffset(offset: CGVector): void;
  selectionCornerMaskWithZoomValue(zoomValue: CGFloat): NSUInteger;
  refreshOverlay(): void;
  refreshOverlayWithAbsoluteMargins(size: NSSize): void;
  refreshOverlayInRect(rect: NSRect): void;
  absoluteInfluenceRect(): NSRect;
  alignmentRectInCoordinateSpace_options(coordinateSpace: any, options: MSAlignmentRectOptions): NSRect;
  boundsRectForAlignment(): NSRect;
  select_byExtendingSelection(flag: boolean, expand: boolean): void;
  select_byExtendingSelection_showSelection(shouldSelect: boolean, expand: boolean, showSelection: boolean): void;
  containsSelectedItemIncludingSelf(includeSelf: boolean): boolean;
  isSelectableOnCanvasWithOptions(options: MSLayerSelectionOptions): boolean;
  isOpenForSelectionWithOptions(options: MSLayerSelectionOptions): boolean;
  limitsSelectionToBounds(): boolean;
  selectableLayersWithOptions(options: MSLayerSelectionOptions): NSArray<any>;
  parentPage(): MSPage;
  parentShape(): MSShapeGroup;
  parentSymbol(): MSSymbolMaster;
  parentRoot(): MSLayerGroup;
  removeFromParent(): void;
  ancestorsAndSelf(): NSArray<any>;
  ancestors(): NSArray<any>;
  canContainLayer(layer: MSLayer): boolean;
  adjustmentHandleAtPoint_zoomScale_resizing(point: NSPoint, zoom: CGFloat, resizing: boolean): BCCorner;
  transform(): NSAffineTransform;
  ancestorsAndSelfTransforms(): NSArray<any>;
  concatAncestorsAndSelfTransforms(): void;
  canBeTransformed(): boolean;
  canRotate(): boolean;
  canScale(): boolean;
  hasEnabledBackgroundBlur(): boolean;
  moveInLayerTreeInBlock(block: BCVoidBlock): void;
  multiplyBy(amount: CGFloat): void;
  layerDidEndResize(): void;
  layerDidResizeFromRect_corner(rect: NSRect, corner: BCCorner): void;
  calculateMinimumSize(): NSSize;
  allSymbolInstancesInChildren(): NSSet<any>;
  isLine(): boolean;
  resetFlow(): void;
  isPartOfClippingMask(): boolean;
  hasClippingMask(): boolean;
  candidatesForMasking(): NSArray<any>;
  closestClippingLayer(): MSShapeGroup;
  followMaskChainForLayerAtIndex_usingBlock(index: NSUInteger, block: Block): void;
  addChangeObserver(observer: any): void;
  removeChangeObserver(observer: any): void;
  enumeratorWithOptions(options: MSLayerEnumeratorFlags): MSLayerEnumerator<any>;
  configureBackgroundOfRequest(request: MSExportRequest): void;
  adjustAfterInsert(): void;
  handleDoubleClick(): boolean;
  handlerClass(): any;
  shouldRefreshOverlayForFlows(): boolean;
  inspectorSections(): NSArray<any>;
  writeBitmapImageToFile(path: NSString | string): void;
  shouldDrawSelection(): boolean;
  shouldDrawSelectionStroke(): boolean;
  cornerRectType(): MSDotRectType;
  shouldFlattenAfterRotate(): boolean;

  canChangeBooleanOperation(): boolean;
  shareableObjectType(): MSShareableObjectType;
  sharedMaster(): MSShareableObject;
  hasFixedEdges(): boolean;
  setHasFixedEdges(hasFixedEdges: boolean): void;
  dataSupplierIdentifier(): NSString;
  setDataSupplierIdentifier(dataSupplierIdentifier: NSString | string): void;
  userVisibleRotation(): CGFloat;
  isSharedStyleOutOfSync(): boolean;
  sharedStyle(): MSSharedStyle;
  setSharedStyle(sharedStyle: MSSharedStyle): void;
  constrainProportions(): boolean;
  setConstrainProportions(constrainProportions: boolean): void;
  proportions(): CGFloat;
  setProportions(proportions: CGFloat): void;
  rect(): CGRect;
  setRect(rect: CGRect): void;
  bounds(): CGRect;
  origin(): CGPoint;
  setOrigin(origin: CGPoint): void;
  center(): CGPoint;
  setCenter(center: CGPoint): void;
  isExpanded(): boolean;
  absolutePosition(): NSPoint;
  setAbsolutePosition(absolutePosition: NSPoint): void;
  isSelected(): boolean;
  parentArtboard(): MSArtboardGroup;
  ancestry(): MSImmutableLayerAncestry;
  unitCoordinateSpace(): any;
  rulerCoordinateSpace(): any;
  usedStyle(): MSStyle;
  transformStruct(): CHTransformStruct;
  setTransformStruct(transformStruct: CHTransformStruct): void;
}
declare const MSLayer: {
  alloc(): MSLayerAllocator;  alignLayers_withMode_toKey_pixelFit(layerArray: MSLayerArray, mode: MSLayerAlignmentMode, key: NSString | string, shouldPixelFit: boolean): void;
  userVisibleRotationForRotation(r: CGFloat): CGFloat;
  layerWithPath(path: MSPath): MSStyledLayer;
  makeLayerNamesUnique_withOptions(layers: NSArray<any> | any[], options: MSLayerRenameOptions): void;

}

declare enum MSLayerAlignmentMode {
  MSLayerAlignToLayers,
  MSLayerAlignToParentArtboard,
}

declare type MSLayerListItem = NSObject

interface MSStyledLayerAllocator<InitializedType = MSStyledLayer> extends _MSStyledLayerAllocator<MSStyledLayer> {}
interface MSStyledLayer extends _MSStyledLayer, IMSStyledLayer {
  prepareAsMask(): void;
  copyStyleToPasteboard(): NSPasteboard;
  copyStyleToPasteboard(pasteboard: NSPasteboard): void;
  writeStyleToPasteboard(pasteboard: NSPasteboard): void;
  layerStyleDidChange(): void;
  sharedObject(): MSSharedObject;
  setStyleByPreservingSharedObjectReference(style: MSStyle): void;
  hasMarkers(): boolean;
  applyPropertiesToBezier(bezier: NSBezierPath): void;
}
declare const MSStyledLayer: {
  alloc(): MSStyledLayerAllocator;  layerWithImageFromPasteboard(pasteboard: NSPasteboard): MSStyledLayer;
  layerWithImageFromFileURL(fileURL: NSURL): MSStyledLayer;
  pasteStyleFromPasteboardOnLayers_document(styledLayers: NSArray<any> | any[], document: MSDocumentData): void;
  pasteStyleFromPasteboard_onLayers_document(pasteboard: NSPasteboard, styledLayers: NSArray<any> | any[], document: MSDocumentData): void;
  pasteStyleDict_onLayers_document(style: NSDictionary<any, any> | {[key: string]: any}, styledLayers: NSArray<any> | any[], document: MSDocumentData): void;
  supportedPasteboardTypesForStyleCopying(): NSArray<any>;

}

interface MSLayerGroupAllocator<InitializedType = MSLayerGroup> extends _MSLayerGroupAllocator<MSLayerGroup> {}
interface MSLayerGroup extends _MSLayerGroup, IMSLayerGroup {
  prepareAsMaskContainer(): void;
  enumerateLayersAvoidingFaultingWithOptions_passingTest_usingBlock(options: MSLayerEnumeratorFlags, predicate: MSLayerIteratorTestBlock, enumeratorBlock: MSLayerIteratorBlock): void;
  ungroup(): NSArray<any>;
  ungroupSingleChildDescendentGroups(): void;
  applyTransformsToLayers(layers: NSArray<any> | any[]): void;
  disableAutomaticScalingInBlock(block: BCVoidBlock): void;
  deselectLayerAndParent(): void;
  resizeToFitChildrenWithOption(resizeOption: MSLayerGroupResizeOption): boolean;
  insertLayer_afterLayerOrAtEnd(layer: MSLayer, after: MSLayer | null): void;
  resizeChildrenWithOldSize(oldSize: NSSize): void;
  shouldStripShadowsAndInnerShadow(): boolean;

  isAutomaticScalingEnabled(): boolean;
}
declare const MSLayerGroup: {
  alloc(): MSLayerGroupAllocator;  groupWithLayer(layer: MSLayer): MSLayerGroup;
  groupWithLayers(layers: MSLayerArray): MSLayerGroup;
  groupBoundsForContainer(containter: any): NSRect;
  groupBoundsShouldBeIntegral(): boolean;

}

interface MSShapePathLayerAllocator<InitializedType = MSShapePathLayer> extends _MSShapePathLayerAllocator<MSShapePathLayer> {}
interface MSShapePathLayer extends _MSShapePathLayer, IMSPathLayer {
  resetPoints(): void;
  resetPointsBasedOnUserInteraction(): void;
  editable(): boolean;
  simplify(): void;
  reversePath(): void;
  adjustFrameAfterEditIntegral(makeIntegral: boolean): void;
  didEdit(): void;
  isNearlyEmpty(): boolean;
  pointCenteredAfterPointIndex(pointIndex: NSUInteger): NSPoint;
  indexOfSegmentAtPoint_tolerance(point: NSPoint, tolerance: NSSize): NSUInteger;
  flatten(): void;
  flattenedLayer(): MSShapePathLayer;
  pointsAroundIndex(index: NSUInteger): NSArray<any>;
  isRectangle(): boolean;
  isPolygon(): boolean;
  adjustGeometryToBoundsRect(targetBounds: NSRect): void;
  insertionCursor(): NSCursor;

  isEditing(): boolean;
  setIsEditing(isEditing: boolean): void;
  hasRoundedCorners(): boolean;
  numberOfCurvePoints(): NSUInteger;
  canFlatten(): boolean;
  pathInFrame(): MSPath;
  setPathInFrame(pathInFrame: MSPath): void;
}
declare const MSShapePathLayer: {
  alloc(): MSShapePathLayerAllocator;  layerWithPath(path: MSPath): MSShapePathLayer;
  shapeWithRect(rect: NSRect): MSRectangleShape;
  performBatchEdits(edits: Block): void;

}

interface MSSliceLayerAllocator<InitializedType = MSSliceLayer> extends _MSSliceLayerAllocator<MSSliceLayer> {}
interface MSSliceLayer extends _MSSliceLayer, IMSLayerWithMutableBackgroundColor, IMSColorConvertible {
}
declare const MSSliceLayer: {
  alloc(): MSSliceLayerAllocator;  sliceLayerFromLayer(layer: MSLayer): MSSliceLayer;

}

interface MSHotspotLayerAllocator<InitializedType = MSHotspotLayer> extends _MSHotspotLayerAllocator<MSHotspotLayer> {}
interface MSHotspotLayer extends _MSHotspotLayer {
}
declare const MSHotspotLayer: {
  alloc(): MSHotspotLayerAllocator;  hotspotLayerFromLayer(layer: MSLayer): MSHotspotLayer;

}

interface MSShapeGroupAllocator<InitializedType = MSShapeGroup> extends _MSShapeGroupAllocator<MSShapeGroup> {}
interface MSShapeGroup extends _MSShapeGroup, IMSShapeGroup, IMSPathLayer {
  canProbablyFlatten(): boolean;
  canFlatten(): boolean;
  changeInnerOuterBordersIfHasOpenPaths(): void;
  isHorizontalLine(): boolean;
  isVerticalLine(): boolean;
  simplify(): void;
  flatten(): MSStyledLayer;
  moveTransformsToChildren(): void;
  setEdited(flag: boolean): void;
  makeLinePixelAligned(): void;

  pathInFrame(): MSPath;
  setPathInFrame(pathInFrame: MSPath): void;
  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
}
declare const MSShapeGroup: {
  alloc(): MSShapeGroupAllocator;  shapeWithBooleanOperation_onLayers(operation: MSBooleanOperation, layers: MSLayerArray): MSShapeGroup;
  layerWithPath(path: MSPath): MSShapeGroup;

}

interface MSSymbolMasterAllocator<InitializedType = MSSymbolMaster> extends _MSSymbolMasterAllocator<MSSymbolMaster> {}
interface MSSymbolMaster extends _MSSymbolMaster, IBCSortable {
  newSymbolInstance(): MSSymbolInstance;
  copyWithIDMapping(idMap: NSMutableDictionary<any, any> | {[key: string]: any}): MSSymbolMaster;
  canInsertInstanceIntoGroupWithoutInfiniteRecursion(group: MSLayerGroup): boolean;
  hasInstances(): boolean;
  ensureSymbolIDUniqueInDocument(doc: MSDocumentData): boolean;
  detachAllInstances(): void;
  removeFromParentAndDetachAllInstances(): void;
  isSafeToDelete(): boolean;
  ancestorIDsForLayerNamed(layerName: NSString | string): NSArray<any>;

  availableOverrides(): NSArray<any>;
  changeIdentifier(): NSInteger;
  setChangeIdentifier(changeIdentifier: NSInteger): void;
  isDirty(): boolean;
  setIsDirty(isDirty: boolean): void;
  allInstances(): NSArray<any>;
  allInfluencedInstances(): NSArray<any>;
  nestedSymbols(): NSSet<any>;
}
declare const MSSymbolMaster: {
  alloc(): MSSymbolMasterAllocator;  convertArtboardToSymbol(artboard: MSArtboardGroup): MSSymbolMaster;
  convertSymbolToArtboard(symbol: MSSymbolMaster): MSArtboardGroup;

}

interface MSImmutableLayerAllocator<InitializedType = MSImmutableLayer> extends _MSImmutableLayerAllocator<MSImmutableLayer> {}
interface MSImmutableLayer extends _MSImmutableLayer, IMSLayer, IMSLayerTraits {
  absoluteRectForAncestorGroups(ancestors: NSArray<any> | any[]): NSRect;
  absoluteInfluenceRectForAncestorGroups_document(ancestors: NSArray<any> | any[], doc: MSImmutableDocumentData): NSRect;
  influenceRectForFrameInDocument(doc: MSImmutableDocumentData | null): NSRect;
  influenceRectForBoundsInDocument(doc: MSImmutableDocumentData | null): NSRect;
  influenceRectForFrameInDocument_visitedSymbols(doc: MSImmutableDocumentData | null, visitedSymbols: NSSet<any> | null): NSRect;
  influenceRectForBoundsInDocument_visitedSymbols(doc: MSImmutableDocumentData | null, visitedSymbols: NSSet<any> | null): NSRect;
  calculateInfluenceRectForBoundsInDocument_visitedSymbols(doc: MSImmutableDocumentData | null, visitedSymbols: NSSet<any> | null): NSRect;
  influenceRectForBoundsOrCalculateInBlock(creatorBlock: Block): NSRect;
  absoluteOverlayInfluenceRectForAncestorGroups(ancestors: NSArray<any> | any[]): NSRect;
  bezierBoundsInAbsoluteCoordinatesWithAncestors(ancestors: NSArray<any> | any[]): MSPath;
  transformRectToParentCoordinates(rect: NSRect): NSRect;
  canSkipAdvancedClipForStrokes(): boolean;
  isLine(): boolean;
  descendantsToLayerWithID(objectID: NSString | string): NSArray<any>;
  defaultValueForOverridePoint_relatedOverrides_document(point: MSOverridePoint, relatedOverrides: NSArray<any> | any[], document: MSImmutableDocumentData): any;
  canOverridePoint(point: MSOverridePoint): boolean;
  overridePointsWithParent_overrides_document(parent: MSOverridePoint | null, overrides: NSArray<any> | any[], document: MSImmutableDocumentData): NSArray<any>;
  enumeratorWithOptions(options: MSLayerEnumeratorFlags): MSLayerEnumerator<any>;
  renderBitmapEffects(image: CIImage): CIImage;
  pathForRenderingInBoundsInDocument_cache(doc: MSImmutableDocumentData, cache: BCCache): MSPath;
  shouldRenderInTransparencyLayer(): boolean;
  transparencyLayerUseRectCondition(): MSTransparencyRectangleOption;
  shouldSkipDrawingInContext(context: MSRenderingContext): boolean;
  configureBackgroundOfRequest(request: MSExportRequest): void;
  requiresPathDefinition(exporter: SketchSVGExporter): boolean;
  writeSVGToElement_withExporter(element: NSXMLElement, exporter: SketchSVGExporter): void;
  addTransformAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;
  relativeRectWithExporter(exporter: SketchSVGExporter): NSRect;
  addPathDefinitionToDocument(exporter: SketchSVGExporter): void;
  simplifyPathElement_exporter_inset(element: NSXMLElement, exporter: SketchSVGExporter, inset: CGFloat): void;
  addGroupContentToElement_attributes_exporter(parentElement: NSXMLElement, attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): NSXMLElement;
  addDefaultFillAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;
  shouldIncludeInSVGExport(exporter: SketchSVGExporter): boolean;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  center(): NSPoint;
  transform(): NSAffineTransform;
  frameForTransforms(): NSRect;
  hasEnabledBackgroundBlur(): boolean;
  traits(): MSTraits;
  isLayerExportable(): boolean;
  shouldBeIncludedInParentPath(): boolean;
  influenceRectForFrame(): NSRect;
  influenceRectEdgePaddingsThatCascadeToContainedLayers(): BCEdgePaddings;
  influenceRectEdgePaddingsThatDoNotCascade(): BCEdgePaddings;
  hasClippingMask(): boolean;
  canBreakMaskChain(): boolean;
  fontNames(): NSSet<any>;
  unavailableFontNames(): NSSet<any>;
  dataSupplierIdentifier(): NSString;
}
declare const MSImmutableLayer: {
  alloc(): MSImmutableLayerAllocator;
}

interface MSImmutableStyledLayerAllocator<InitializedType = MSImmutableStyledLayer> extends _MSImmutableStyledLayerAllocator<MSImmutableStyledLayer> {}
interface MSImmutableStyledLayer extends _MSImmutableStyledLayer, IMSStyledLayer {
  bezierPathForStartDecorationOnPath(bezier: MSPath): MSPath;
  bezierPathForEndDecorationOnPath(bezier: MSPath): MSPath;
  hasMarkers(): boolean;
  applyPropertiesToBezier(bezier: NSBezierPath): void;
  prepareDrawingInContext_inBlock(context: MSRenderingContext, block: BCVoidBlock): void;
  fillPathWithDecorations(pathInOut: MSPath): MSPath;
  fillStyleForDecoratedPath(): MSImmutableStyle;
  strokeStyleForDecoratedPath(): MSImmutableStyle;
  pathWithExporter_border(exporter: SketchSVGExporter, border: MSImmutableStyleBorder | null): MSPath;

  decoratedPathInBounds(): MSPath;
  allowsBlur(): boolean;
  shouldRasterize(): boolean;
}
declare const MSImmutableStyledLayer: {
  alloc(): MSImmutableStyledLayerAllocator;  cacheDecorations(): void;

}

interface MSImmutableShapeGroupAllocator<InitializedType = MSImmutableShapeGroup> extends _MSImmutableShapeGroupAllocator<MSImmutableShapeGroup> {}
interface MSImmutableShapeGroup extends _MSImmutableShapeGroup, IMSShapeGroup, IMSImmutablePathLayer {
}
declare const MSImmutableShapeGroup: {
  alloc(): MSImmutableShapeGroupAllocator;
}

interface MSImmutableShapePathLayerAllocator<InitializedType = MSImmutableShapePathLayer> extends _MSImmutableShapePathLayerAllocator<MSImmutableShapePathLayer> {}
interface MSImmutableShapePathLayer extends _MSImmutableShapePathLayer, IMSImmutablePathLayer {
  migratePropertiesFromShapeGroup(shape: MSImmutableShapeGroup): void;
  migrateByTakingStyleFrom(shape: MSImmutableShapeGroup): void;

  isEditing(): boolean;
  usedStyle(): MSImmutableStyle;
  isPolygon(): boolean;
  isPolyline(): boolean;
  isRectangle(): boolean;
  numberOfCurvePoints(): NSUInteger;
}
declare const MSImmutableShapePathLayer: {
  alloc(): MSImmutableShapePathLayerAllocator;
}

interface MSImmutableSliceLayerAllocator<InitializedType = MSImmutableSliceLayer> extends _MSImmutableSliceLayerAllocator<MSImmutableSliceLayer> {}
interface MSImmutableSliceLayer extends _MSImmutableSliceLayer, IMSLayerWithBackgroundColor {
}
declare const MSImmutableSliceLayer: {
  alloc(): MSImmutableSliceLayerAllocator;
}

interface MSImmutableHotspotLayerAllocator<InitializedType = MSImmutableHotspotLayer> extends _MSImmutableHotspotLayerAllocator<MSImmutableHotspotLayer> {}
interface MSImmutableHotspotLayer extends _MSImmutableHotspotLayer {
}
declare const MSImmutableHotspotLayer: {
  alloc(): MSImmutableHotspotLayerAllocator;
}

interface IMSLayerPreviewability {
  selectedPreviewTemplateImage(): NSImage;
  unselectedPreviewTemplateImage(): NSImage;
  contextualMenuPreviewTemplateImage(): NSImage;

  badgeType(): MSLayerPreviewBadgeType;
}

interface IMSImmutableLayerPreviewability {
  previewImagesRequireRefreshWithDocumentData_forOwner(documentData: MSImmutableDocumentData, owner: any): boolean;
  refreshPreviewImagesWithDocumentData_forOwner(documentData: MSImmutableDocumentData, owner: any): void;
}

interface MSLayerArrayAllocator<InitializedType = MSLayerArray> extends NSObjectAllocator<MSLayerArray> {
  initWithLayers(layers: NSArray<any> | any[]): InitializedType;
}
interface MSLayerArray extends NSObject, IMSLayerContainment, INSFastEnumeration {
  addStylePartsOfType(type: MSStylePartType): NSArray<any>;
  removeUnusedStylePartsOfType(type: MSStylePartType): void;
  copyByGivingNewObjectIDs(): MSLayerArray;
  parentOfFirstLayer(): MSLayerGroup;
  uniqueParents(): MSLayerArray;
  effectivePage(): MSPage;
  effectiveArtboard(): MSArtboardGroup;
  layerToInsertAfter(): MSLayer;
  commonArtboard(): MSArtboardGroup;
  map(block: Block): MSLayerArray;
  filter(block: MSLayerFilterBlock): MSLayerArray;
  sortedArrayByUsingComparator(comparator: Block): MSLayerArray;
}
declare const MSLayerArray: {
  alloc(): MSLayerArrayAllocator;  arrayWithLayer(layer: MSLayer | null): MSLayerArray;
  arrayWithLayers(layers: NSArray<any> | any[]): MSLayerArray;
  emptyArray(): MSLayerArray;

}

interface MSLayerFlattenerAllocator<InitializedType = MSLayerFlattener> extends NSObjectAllocator<MSLayerFlattener> {}
interface MSLayerFlattener extends NSObject {
  flattenLayers(layers: MSLayerArray): void;
  imageFromLayers_immutablePage_immutableDoc(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData): NSImage;
  imageFromLayers_immutablePage_immutableDoc_includeArtboardBackground(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData, includeArtboardBackground: boolean): NSImage;
  trimmedRectFromLayers_immutablePage_immutableDoc(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData): NSRect;
  trimmedRectFromLayers_immutablePage_immutableDoc_includeArtboardBackground(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData, includeArtboardBackground: boolean): NSRect;
  bitmapFromRect_fromLayers_withImage(bitmapRect: NSRect, layers: MSLayerArray, image: NSImage): MSBitmapLayer;
}
declare const MSLayerFlattener: {
  alloc(): MSLayerFlattenerAllocator;
}

interface MSLayerListControllerAllocator<InitializedType = MSLayerListController> extends MSSidebarListControllerAllocator<MSLayerListController> {}
interface MSLayerListController extends MSSidebarListController, IBCOutlineViewDataSource, IBCOutlineViewDelegate {
}
declare const MSLayerListController: {
  alloc(): MSLayerListControllerAllocator;
}

interface MSLayerSelectorAllocator<InitializedType = MSLayerSelector> extends NSObjectAllocator<MSLayerSelector> {}
interface MSLayerSelector extends NSObject {
  updateSelectionWithRect_page_extendSelection_options(selectionRect: NSRect, page: MSPage, extend: boolean, options: MSLayerSelectionOptions): void;

  initialSelection(): MSLayerArray;
  setInitialSelection(initialSelection: MSLayerArray): void;
}
declare const MSLayerSelector: {
  alloc(): MSLayerSelectorAllocator;
}

interface MSStyleAllocator<InitializedType = MSStyle> extends _MSStyleAllocator<MSStyle> {}
interface MSStyle extends _MSStyle, IMSSharedObjectInstance, INSCopying {
  multiplyBy(size: CGFloat): void;
  enabledFills(): NSArray<any>;
  enabledBorders(): NSArray<any>;
  enabledShadows(): NSArray<any>;
  enabledInnerShadows(): NSArray<any>;
  firstEnabledBorder(): MSStyleBorder;
  firstEnabledFill(): MSStyleFill;
  firstEnabledShadow(): MSStyleShadow;
  disableAllBorders(): void;
  disableAllFills(): void;
  disableAllShadows(): void;
  disableAllInnerShadows(): void;
  hasTextStyle(): boolean;
  parentLayer(): MSStyledLayer;
  supportsAdvancedBorderSettings(): boolean;
  stylePartsOfType(type: MSStylePartType): NSArray<any>;
  addStylePartOfType(type: MSStylePartType): MSStylePart;

  primitiveTextStyle(): MSTextStyle;
  setPrimitiveTextStyle(primitiveTextStyle: MSTextStyle): void;
  primitiveSharedObjectID(): NSString;
  setPrimitiveSharedObjectID(primitiveSharedObjectID: NSString | string): void;
  hasBlending(): boolean;
  hasMarkers(): boolean;
  hasEnabledBackgroundBlur(): boolean;
  hasEnabledBorder(): boolean;
  hasEnabledFill(): boolean;
  hasEnabledShadow(): boolean;
  hasMoreThanOneEnabledFill(): boolean;
  thickestInnerStroke(): CGFloat;
  thickestStroke(): CGFloat;
}
declare const MSStyle: {
  alloc(): MSStyleAllocator;
}

interface MSTextStyleAllocator<InitializedType = MSTextStyle> extends _MSTextStyleAllocator<MSTextStyle> {}
interface MSTextStyle extends _MSTextStyle {
  generatePreviewWithText_imageSize_previewSize_colorSpace_backingScale_completionBlock(text: NSString | string, imageSize: CGSize, previewSize: CGSize, colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): void;
  syncOwningTextLayerWithThisStyle(): void;
  updateAttributesWithoutSyncingOwningTextLayer(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  resetDecodedAttributes(): void;

  attributes(): NSDictionary<any, any>;
  setAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  isRequiredFontAvailable(): boolean;
  fontPostscriptName(): NSString;
}
declare const MSTextStyle: {
  alloc(): MSTextStyleAllocator;  styleWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): MSTextStyle;

}

interface MSLayoutAnchorAllocator<InitializedType = MSLayoutAnchor> extends NSObjectAllocator<MSLayoutAnchor> {
  initWithItem_attribute(item: any, attribute: MSLayoutAttribute): InitializedType;
}
interface MSLayoutAnchor extends NSObject {

  item(): any;
  attribute(): MSLayoutAttribute;
  axis(): BCAxis;
}
declare const MSLayoutAnchor: {
  alloc(): MSLayoutAnchorAllocator;
}

interface MSLayoutPositionAllocator<InitializedType = MSLayoutPosition> extends MSLayoutAnchorAllocator<MSLayoutPosition> {}
interface MSLayoutPosition extends MSLayoutAnchor {
  positionInLayer(layer: MSLayer | null): CGFloat;
  snappingTargetInLayer(layer: MSLayer | null): MSSnappingTarget;
  rectBySnappingToPosition_oldFrame_mayResize(position: CGFloat, oldFrame: NSRect, resize: boolean): NSRect;

  snapTag(): MSSnapTag;
  setSnapTag(snapTag: MSSnapTag): void;
}
declare const MSLayoutPosition: {
  alloc(): MSLayoutPositionAllocator;  positionAnchorWithLine_inLayer_attribute(line: BCOrthogonalLine, layer: MSLayer, attribute: MSLayoutAttribute): MSLayoutPosition;
  snapPoint_toLines_onAxis_margin(point: CGPoint, lines: NSArray<any> | any[], axis: BCAxis, margin: CGFloat): CGPoint;

}

interface MSLayoutDimensionAllocator<InitializedType = MSLayoutDimension> extends MSLayoutAnchorAllocator<MSLayoutDimension> {}
interface MSLayoutDimension extends MSLayoutAnchor {
}
declare const MSLayoutDimension: {
  alloc(): MSLayoutDimensionAllocator;
}

declare enum MSSnapTag {
  MSSnapAll = 0,
  MSSnapEdge = 1,
  MSSnapBaseline = 3,
}

interface MSLayoutGridAllocator<InitializedType = MSLayoutGrid> extends _MSLayoutGridAllocator<MSLayoutGrid> {}
interface MSLayoutGrid extends _MSLayoutGrid {
  totalNumberOfGutters(): NSInteger;
  determineAppropriateColumnWidth(): void;
}
declare const MSLayoutGrid: {
  alloc(): MSLayoutGridAllocator;
}

interface MSLayoutRelationshipAllocator<InitializedType = MSLayoutRelationship> extends NSObjectAllocator<MSLayoutRelationship> {
  initWithAnchor_anchor(anchor1: MSLayoutAnchor, anchor2: MSLayoutAnchor | null): InitializedType;
  initWithItem_attribute_item_attribute(item1: any, attr1: MSLayoutAttribute, item2: any | null, attr2: MSLayoutAttribute): InitializedType;
  initWithFirstItem_attribute_secondAnchor(item1: any, attr1: MSLayoutAttribute, anchor2: MSLayoutAnchor | null): InitializedType;
}
interface MSLayoutRelationship extends NSObject {

  firstAnchor(): MSLayoutAnchor;
  firstItem(): any;
  firstAttribute(): MSLayoutAttribute;
  secondAnchor(): MSLayoutAnchor;
  secondItem(): any;
  secondAttribute(): MSLayoutAttribute;
  rect(): NSRect;
}
declare const MSLayoutRelationship: {
  alloc(): MSLayoutRelationshipAllocator;  dimensionMeasurementWithItem_axis(item: any, axis: BCAxis): MSLayoutRelationship;
  spacingMeasurementWithItem_toItem_onAxis(firstItem: any, secondItem: any, axis: BCAxis): MSLayoutRelationship;

}

interface MSLoadedImageDataAllocator<InitializedType = MSLoadedImageData> extends NSObjectAllocator<MSLoadedImageData> {}
interface MSLoadedImageData extends NSObject {

  image(): MSImageData;
  setImage(image: MSImageData): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  intendedDPI(): NSInteger;
  setIntendedDPI(intendedDPI: NSInteger): void;
}
declare const MSLoadedImageData: {
  alloc(): MSLoadedImageDataAllocator;  imageFromPasteboard(pasteboard: NSPasteboard): MSLoadedImageData;
  imageFromFileURL(fileURL: NSURL): MSLoadedImageData;
  scalingFactorForFilename(filename: NSString | string): NSUInteger;

}

interface MSLocalDataSupplierAllocator<InitializedType = MSLocalDataSupplier> extends MSDataSupplierAllocator<MSLocalDataSupplier> {
  initWithFileSystemURL_isBuiltin(fsURL: NSURL, isBuiltin: boolean): InitializedType;
}
interface MSLocalDataSupplier extends MSDataSupplier {

  dataSource(): NSURL;
  isBuiltin(): boolean;
}
declare const MSLocalDataSupplier: {
  alloc(): MSLocalDataSupplierAllocator;  textDataFromFileURL(fileURL: NSURL): NSArray<any>;
  imageFileNamesFromFolderURL(folderURL: NSURL): NSArray<any>;

}

interface MSManifestMakerAllocator<InitializedType = MSManifestMaker> extends NSObjectAllocator<MSManifestMaker> {
  initWithDocument(documentData: MSImmutableDocumentData): InitializedType;
}
interface MSManifestMaker extends NSObject {
  createManifest(): NSDictionary<any, any>;
  metadataForRootLayer_onPage_earlierSlugs(root: MSImmutableLayerGroup, page: MSImmutablePage, slugs: NSMutableDictionary<any, any> | {[key: string]: any} | null): NSDictionary<any, any>;
  filesMetadataForRootLayer_onPage_id(root: MSImmutableLayerGroup, page: MSImmutablePage, fileID: NSString | string): NSArray<any>;

  documentData(): MSImmutableDocumentData;
  cacheManager(): MSCacheManager;
  setCacheManager(cacheManager: MSCacheManager): void;
  name(): NSString;
  setName(name: NSString | string): void;
  selectiveExport(): boolean;
  setSelectiveExport(selectiveExport: boolean): void;
  usePageIfMissingArtboard(): boolean;
  setUsePageIfMissingArtboard(usePageIfMissingArtboard: boolean): void;
}
declare const MSManifestMaker: {
  alloc(): MSManifestMakerAllocator;  keyForFlowAnimationType(type: MSFlowAnimationType): NSString;

}

interface MSMaskWithShapeAllocator<InitializedType = MSMaskWithShape> extends NSObjectAllocator<MSMaskWithShape> {}
interface MSMaskWithShape extends NSObject {
}
declare const MSMaskWithShape: {
  alloc(): MSMaskWithShapeAllocator;  createMaskWithShapeForLayers(layers: MSLayerArray): MSLayer;

}

interface MSMathInspectorValueAdaptorAllocator<InitializedType =  MSMathInspectorValueAdaptor> extends MSInspectorValueAdaptorAllocator<MSMathInspectorValueAdaptor> {
  initWithModelsController_floatValueGetter_floatValueSetter_modelKeyPathsToWatch(modelsController: NSArrayController, floatValueGetter: Block, floatValueSetter: Block, modelKeyPathsToWatch: NSArray<any>): InitializedType;
}
interface MSMathInspectorValueAdaptor extends MSInspectorValueAdaptor {
  checkAndAdjustValues_contexts_withNumberFormatter_error(values: NSArray<any>, contexts: NSPointerArray, numberFormatter: NSNumberFormatter, error: NSError): NSArray<any>;
  effectiveNumberFormatter(): NSNumberFormatter;
  currentAdjustOptions(): MSValueAdaptorAdjustOptions;
  valueFromPrefixStrippedString_forModel_originalString_error(string: NSString, model: any, originalString: NSString, error: NSError): NSNumber;
  errorWithUnparsableString(unparsable: NSString): NSError;
  trimValueString_getMathPrefix(string: NSString, prefix: NSString): NSString;
  forceRelativeMathForBlock(block: Block): void;
  clampsValues(): boolean;
  setClampsValues(clampsValues: boolean): void;
  adjustIndividually(): boolean;
  setAdjustIndividually(adjustIndividually: boolean): void;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  isIncrementing(): boolean;
  setIsIncrementing(isIncrementing: boolean): void;
}
declare const MSMathInspectorValueAdaptor: {
  alloc(): MSMathInspectorValueAdaptorAllocator;
}

interface IMSIncrementDecrementDelegate {
  incrementBy(amount: CGFloat): void;
}

interface IMSInspectorMathValueAdaptorDelegate {
  inspectorValueAdaptorAllowFloat(adaptor: MSInspectorValueAdaptor): boolean;
}

declare enum MSValueAdaptorAdjustOptions {
  MSValueAdaptorAdjustValues = 1 << 0,
  MSValueAdaptorAdjustIgnoreMinimum = 1 << 1,
  MSValueAdaptorAdjustIgnoreMaximum = 1 << 2,
  MSValueAdaptorAdjustIndividually = 1 << 3,
}

interface MSMathNumberFormatterAllocator<InitializedType = MSMathNumberFormatter> extends NSNumberFormatterAllocator<MSMathNumberFormatter> {}
interface MSMathNumberFormatter extends NSNumberFormatter {
}
declare const MSMathNumberFormatter: {
  alloc(): MSMathNumberFormatterAllocator;
}

interface MSMomentAllocator<InitializedType = MSMoment> extends NSObjectAllocator<MSMoment> {
  initWithTitle_documentData(newTitle: NSString | string, document: MSImmutableDocumentData): InitializedType;
}
interface MSMoment extends NSObject {

  timestamp(): NSTimeInterval;
  title(): NSString;
  setTitle(title: NSString | string): void;
  document(): MSImmutableDocumentData;
  setDocument(document: MSImmutableDocumentData): void;
  adaptability(): MSMomentAdaptability;
  setAdaptability(adaptability: MSMomentAdaptability): void;
  selectedLayerIDs(): NSSet<any>;
  setSelectedLayerIDs(selectedLayerIDs: NSSet<any>): void;
  pageID(): NSString;
  setPageID(pageID: NSString | string): void;
}
declare const MSMoment: {
  alloc(): MSMomentAllocator;
}

declare enum MSMomentAdaptability {
  MSMomentAdaptabilityTransient,
  MSMomentAdaptabilityCoalesces,
  MSMomentAdaptabilityAmends,
}

interface MSNetworkHelperAllocator<InitializedType = MSNetworkHelper> extends NSObjectAllocator<MSNetworkHelper> {}
interface MSNetworkHelper extends NSObject {
}
declare const MSNetworkHelper: {
  alloc(): MSNetworkHelperAllocator;
}

interface MSOpacityKeyboardShortcutRecognizerAllocator<InitializedType = MSOpacityKeyboardShortcutRecognizer> extends NSObjectAllocator<MSOpacityKeyboardShortcutRecognizer> {
  initWithTarget_action(target: any | null, action: string | null): InitializedType;
}
interface MSOpacityKeyboardShortcutRecognizer extends NSObject {
  keyDown(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  concatenationDuration(): NSTimeInterval;
  setConcatenationDuration(concatenationDuration: NSTimeInterval): void;
  opacity(): CGFloat;
}
declare const MSOpacityKeyboardShortcutRecognizer: {
  alloc(): MSOpacityKeyboardShortcutRecognizerAllocator;
}

interface MSOverrideRepresentationAllocator<InitializedType = MSOverrideRepresentation> extends MSOverrideRepresentationBaseAllocator<MSOverrideRepresentation> {}
interface MSOverrideRepresentation extends MSOverrideRepresentationBase {
  updateExpandedStateAfterSelection(): void;
  createOverrideViewController(): MSOverrideInspectorItem;

  selectionID(): NSString;
  availableOverride(): MSAvailableOverride;
  previousSibling(): MSOverrideRepresentation;
  pathInInstance(): CGPathRef;
  layerListExpandedType(): MSLayerListStatus;
  setLayerListExpandedType(layerListExpandedType: MSLayerListStatus): void;
  isEditable(): boolean;
}
declare const MSOverrideRepresentation: {
  alloc(): MSOverrideRepresentationAllocator;
}

interface MSOverrideRepresentationContainerAllocator<InitializedType = MSOverrideRepresentationContainer> extends MSOverrideRepresentationBaseAllocator<MSOverrideRepresentationContainer> {}
interface MSOverrideRepresentationContainer extends MSOverrideRepresentationBase {

  selectedOverrides(): NSArray<any>;
}
declare const MSOverrideRepresentationContainer: {
  alloc(): MSOverrideRepresentationContainerAllocator;  rootRepresentationForSymbolInstance(instance: MSSymbolInstance): MSOverrideRepresentationContainer;

}

interface MSOverrideRepresentationBaseAllocator<InitializedType = MSOverrideRepresentationBase> extends NSObjectAllocator<MSOverrideRepresentationBase> {}
interface MSOverrideRepresentationBase extends NSObject {
  childrenForLayerList(): NSArray<any>;

  isExpanded(): boolean;
  children(): NSArray<any>;
  instance(): MSSymbolInstance;
}
declare const MSOverrideRepresentationBase: {
  alloc(): MSOverrideRepresentationBaseAllocator;
}

interface MSPDFImporterAllocator<InitializedType = MSPDFImporter> extends NSObjectAllocator<MSPDFImporter> {}
interface MSPDFImporter extends NSObject, IMSImporter {
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importAsLayer(): MSLayer;
}
declare const MSPDFImporter: {
  alloc(): MSPDFImporterAllocator;  pdfImporter(): MSPDFImporter;
  epsImporter(): MSPDFImporter;

}

interface MSPageAllocator<InitializedType = MSPage> extends _MSPageAllocator<MSPage> {}
interface MSPage extends _MSPage, IMSRootLayer {
  selectedLayers(): MSLayerArray;
  artboardWithID(objectID: any): MSArtboardGroup;
  isLayerSelected(layer: MSLayer): boolean;
  changeSelectionUsingBlock(block: MSSelectionModifierBlock): void;
  changeSelectionBySelectingLayers(layers: NSArray<any> | any[] | null): void;
  clearSelectionCache(): void;
  addOrRemoveLayerFromArtboardIfNecessary(layer: MSLayer): boolean;
  tryToMoveLayer_toArtboards(layer: MSLayer, artboards: NSArray<any> | any[]): boolean;
  destinationArtboardForLayers_artboards(layers: NSArray<any> | any[], artboards: NSArray<any> | any[]): MSArtboardGroup;
  moveLayersToArtboards(): void;
  originForNewArtboardWithSize(size: NSSize): NSPoint;
  layersByObjectID(): NSDictionary<any, any>;
  contentIntersectsWithRect(rect: NSRect): boolean;
  resetSelectedLayerIDs(layerIDs: NSSet<any>): void;
  adjustRulerDataToTopLeftInViewBounds(): void;
  scrollOriginToCenterContentInViewBounds(viewBounds: NSRect): NSPoint;

  currentArtboard(): MSArtboardGroup;
  setCurrentArtboard(currentArtboard: MSArtboardGroup): void;
  artboards(): NSArray<any>;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  symbols(): NSArray<any>;
  exportableLayers(): NSArray<any>;
  currentRoot(): MSLayerGroup;
}
declare const MSPage: {
  alloc(): MSPageAllocator;  page(): MSPage;

}

interface MSPageListControllerAllocator<InitializedType = MSPageListController> extends MSSidebarListControllerAllocator<MSPageListController> {}
interface MSPageListController extends MSSidebarListController, IBCOutlineViewDataSource, IBCOutlineViewDelegate {
}
declare const MSPageListController: {
  alloc(): MSPageListControllerAllocator;
}

interface MSPasteboardFileDataProviderAllocator<InitializedType = MSPasteboardFileDataProvider> extends NSObjectAllocator<MSPasteboardFileDataProvider> {}
interface MSPasteboardFileDataProvider extends NSObject {
}
declare const MSPasteboardFileDataProvider: {
  alloc(): MSPasteboardFileDataProviderAllocator;  addLayers_toPasteboard(layers: NSArray<any> | any[], pboard: NSPasteboard): void;
  exportLayers_toFolder(layers: NSArray<any> | any[], folder: NSURL): NSArray<any>;

}

interface MSPasteboardImageProviderAllocator<InitializedType = MSPasteboardImageProvider> extends NSObjectAllocator<MSPasteboardImageProvider> {}
interface MSPasteboardImageProvider extends NSObject {
}
declare const MSPasteboardImageProvider: {
  alloc(): MSPasteboardImageProviderAllocator;  preparePasteboard_withExportRequest(pboard: NSPasteboard, request: MSExportRequest): void;

}

interface MSPasteboardImageWriterAllocator<InitializedType = MSPasteboardImageWriter> extends NSObjectAllocator<MSPasteboardImageWriter> {}
interface MSPasteboardImageWriter extends NSObject, IMSPasteboardWriter {
}
declare const MSPasteboardImageWriter: {
  alloc(): MSPasteboardImageWriterAllocator;
}

interface MSPasteboardImagesReaderAllocator<InitializedType = MSPasteboardImagesReader> extends NSObjectAllocator<MSPasteboardImagesReader> {}
interface MSPasteboardImagesReader extends NSObject, IMSPasteboardReader {
}
declare const MSPasteboardImagesReader: {
  alloc(): MSPasteboardImagesReaderAllocator;
}

interface MSPasteboardInternalImageReaderAllocator<InitializedType = MSPasteboardInternalImageReader> extends MSPasteboardImagesReaderAllocator<MSPasteboardInternalImageReader> {}
interface MSPasteboardInternalImageReader extends MSPasteboardImagesReader {
}
declare const MSPasteboardInternalImageReader: {
  alloc(): MSPasteboardInternalImageReaderAllocator;
}

interface MSPasteboardLayerListImageProviderAllocator<InitializedType = MSPasteboardLayerListImageProvider> extends NSObjectAllocator<MSPasteboardLayerListImageProvider> {}
interface MSPasteboardLayerListImageProvider extends NSObject {
}
declare const MSPasteboardLayerListImageProvider: {
  alloc(): MSPasteboardLayerListImageProviderAllocator;  addLayer_toPasteboard(layer: MSLayer, pboard: NSPasteboard): void;

}

interface MSPasteboardPDFReaderAllocator<InitializedType = MSPasteboardPDFReader> extends NSObjectAllocator<MSPasteboardPDFReader> {}
interface MSPasteboardPDFReader extends NSObject {
}
declare const MSPasteboardPDFReader: {
  alloc(): MSPasteboardPDFReaderAllocator;
}

interface MSPasteboardPathsReaderAllocator<InitializedType = MSPasteboardPathsReader> extends NSObjectAllocator<MSPasteboardPathsReader> {}
interface MSPasteboardPathsReader extends NSObject, IMSPasteboardReader {
}
declare const MSPasteboardPathsReader: {
  alloc(): MSPasteboardPathsReaderAllocator;
}

interface MSPasteboardTextReaderAllocator<InitializedType = MSPasteboardTextReader> extends NSObjectAllocator<MSPasteboardTextReader> {}
interface MSPasteboardTextReader extends NSObject, IMSPasteboardReader {
  attributedStringFromPasteboard_options(pasteboard: NSPasteboard, options: MSPasteboardReaderOptions): NSAttributedString;
}
declare const MSPasteboardTextReader: {
  alloc(): MSPasteboardTextReaderAllocator;
}

interface MSPasteboardTextWritingAllocator<InitializedType = MSPasteboardTextWriting> extends NSObjectAllocator<MSPasteboardTextWriting> {}
interface MSPasteboardTextWriting extends NSObject {
}
declare const MSPasteboardTextWriting: {
  alloc(): MSPasteboardTextWritingAllocator;  supportedTypes(): NSArray<any>;
  writeAttributedString_toPasteboard_type_documentColorSpace(attributedString: NSAttributedString, pasteboard: NSPasteboard, type: NSString | string, colorSpace: NSColorSpace): boolean;

}

interface MSPluginDataSupplierAllocator<InitializedType = MSPluginDataSupplier> extends MSDataSupplierAllocator<MSPluginDataSupplier> {
  initWithPluginIdentifier_commandIdentifier_dataName_dataTypeStringRepresentation_dynamicDataKey(identifier: NSString | string, commandIdentifier: NSString | string, dataName: NSString | string, dataType: NSString | string, dynamicDataKey: NSString | string): InitializedType;
}
interface MSPluginDataSupplier extends MSDataSupplier {

  pluginIdentifier(): NSString;
  commandIdentifier(): NSString;
  dynamicDataKey(): NSString;
  registered(): boolean;
  setRegistered(registered: boolean): void;
}
declare const MSPluginDataSupplier: {
  alloc(): MSPluginDataSupplierAllocator;  identifierWithPluginIdentifier_commandIdentifier_dynamicDataKey(pluginIdentifier: NSString | string, commandIdentifier: NSString | string, dynamicDataKey: NSString | string): NSString;

}

interface MSPluginDataSupplierContextAllocator<InitializedType = MSPluginDataSupplierContext> extends NSObjectAllocator<MSPluginDataSupplierContext> {
  initWithLayers(layers: NSArray<any> | any[]): InitializedType;
  initWithOverrides(overrides: NSArray<any> | any[]): InitializedType;
}
interface MSPluginDataSupplierContext extends NSObject {

  isSymbolInstanceOverride(): boolean;
  layers(): NSArray<any>;
  overrides(): NSArray<any>;
  dictionaryRepresentation(): NSDictionary<any, any>;
  requestedCount(): NSUInteger;
  key(): NSString;
}
declare const MSPluginDataSupplierContext: {
  alloc(): MSPluginDataSupplierContextAllocator;
}

interface MSPointInsertionAllocator<InitializedType = MSPointInsertion> extends NSObjectAllocator<MSPointInsertion> {}
interface MSPointInsertion extends NSObject {
}
declare const MSPointInsertion: {
  alloc(): MSPointInsertionAllocator;  insertPointAtLocation_index_layer_options(location: NSPoint, index: NSUInteger, layer: MSShapePathLayer, options: MSPointInsertionOptions): MSCurvePoint;
  canInsertAtProposedLocation_index_layer_options(proposedPoint: NSPoint, index: NSUInteger, layer: MSShapePathLayer, options: MSPointInsertionOptions): boolean;

}

declare enum MSPointInsertionOptions {
  MSPointInsertionStraight = 1 << 0,
  MSPointInsertionCenter = 1 << 1,
}

interface MSPopUpToolbarItemAllocator<InitializedType = MSPopUpToolbarItem> extends MSToolbarItemAllocator<MSPopUpToolbarItem> {}
interface MSPopUpToolbarItem extends MSToolbarItem {
}
declare const MSPopUpToolbarItem: {
  alloc(): MSPopUpToolbarItemAllocator;
}

interface IMSPreviewGeneration {
  generatePreviewWithImageSize_previewSize_colorSpace_backingScale_completionBlock(imageSize: CGSize, previewSize: CGSize, colorSpace: NSColorSpace | null, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): void;
}

interface MSRectSnapItemAllocator<InitializedType = MSRectSnapItem> extends MSSnapItemAllocator<MSRectSnapItem> {}
interface MSRectSnapItem extends MSSnapItem {
}
declare const MSRectSnapItem: {
  alloc(): MSRectSnapItemAllocator;  rectSnapItemWithLayer_rect_constrainProportions(layer: MSLayer, rect: NSRect, constrainProportions: boolean): MSRectSnapItem;

}

interface MSRectangleShapeAllocator<InitializedType = MSRectangleShape> extends _MSRectangleShapeAllocator<MSRectangleShape> {}
interface MSRectangleShape extends _MSRectangleShape {
  validateProposedCornerRadiusSizeWithString(radiusString: NSString | string): boolean;
  validateProposedCornerRadiusWithFloat(radius: CGFloat): boolean;
  resetPathsToRect(): void;
  resetPathsToRoundedRect(): void;

  cornerRadiusString(): NSString;
  setCornerRadiusString(cornerRadiusString: NSString | string): void;
  cornerRadiusFloat(): CGFloat;
  setCornerRadiusFloat(cornerRadiusFloat: CGFloat): void;
  normalizedExponentialCornerRadius(): CGFloat;
  setNormalizedExponentialCornerRadius(normalizedExponentialCornerRadius: CGFloat): void;
  hasSmoothCorners(): boolean;
  setHasSmoothCorners(hasSmoothCorners: boolean): void;
  smoothCornersAllowed(): boolean;
  maximumAllowedRadius(): CGFloat;
}
declare const MSRectangleShape: {
  alloc(): MSRectangleShapeAllocator;  looksLikeComponentString(string: NSString | string): boolean;
  componentStringWithValues(values: NSArray<any> | any[]): NSString;
  validateComponentString(string: NSString | string): boolean;

  lastUsedCornerRadius(): CGFloat;
  useSmoothCorners(): boolean;

}

interface MSAssetLibraryUpdatingInfoAllocator<InitializedType = MSAssetLibraryUpdatingInfo> extends NSObjectAllocator<MSAssetLibraryUpdatingInfo> {
  initWithDownloadURL_libraryName_imageURL_newVersionNumber_shareLink_downloadSize(downloadURL: NSURL, libraryName: NSString | string | null, imageURL: NSURL | null, newVersionNumber: NSString | string, shareLink: NSURL | null, downloadSize: NSUInteger): InitializedType;
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface MSAssetLibraryUpdatingInfo extends NSObject, INSCoding {
  isEqual(object: any | null): boolean;
  isHigherVersionThan(otherVersion: NSString | string | null): boolean;

  downloadURL(): NSURL;
  versionNumberForUpdate(): NSString;
  downloadSize(): NSUInteger;
  libraryName(): NSString;
  imageURL(): NSURL;
  folderMonitor(): MSFolderMonitor;
  setFolderMonitor(folderMonitor: MSFolderMonitor): void;
  downloadTaskIdentifier(): NSString;
  setDownloadTaskIdentifier(downloadTaskIdentifier: NSString | string): void;
  shareLink(): NSURL;
}
declare const MSAssetLibraryUpdatingInfo: {
  alloc(): MSAssetLibraryUpdatingInfoAllocator;
}

interface MSRemoteAssetLibraryAllocator<InitializedType = MSRemoteAssetLibrary> extends MSAssetLibraryAllocator<MSRemoteAssetLibrary> {
  initWithName_appcastURL_version_infoText(libraryName: NSString | string, appcastURL: NSURL, libraryVersion: NSString | string | null, infoText: NSString | string | null): InitializedType;
}
interface MSRemoteAssetLibrary extends MSAssetLibrary {
  assetLibraryUpdated(): void;

  appcastURL(): NSURL;
  setAppcastURL(appcastURL: NSURL): void;
  libraryVersion(): NSString;
  setLibraryVersion(libraryVersion: NSString | string): void;
  originalName(): NSString;
  infoText(): NSString;
  setInfoText(infoText: NSString | string): void;
  newUpdatingInfo(): boolean;
  setNewUpdatingInfo(newUpdatingInfo: boolean): void;
  updatingInfo(): MSAssetLibraryUpdatingInfo;
  setUpdatingInfo(updatingInfo: MSAssetLibraryUpdatingInfo): void;
  downloadAvailable(): boolean;
  updateAvailable(): boolean;
  fileName(): NSString;
}
declare const MSRemoteAssetLibrary: {
  alloc(): MSRemoteAssetLibraryAllocator;  URLForApplicationSupportLibraryNamed(name: NSString | string): NSURL;

  assetLibraryFolder(): NSURL;

}

interface MSRenderMonitorAllocator<InitializedType = MSRenderMonitor> extends NSObjectAllocator<MSRenderMonitor> {}
interface MSRenderMonitor extends NSObject {
  recordEvent(event: MSRenderMonitorEvent): void;
  recordEvent_timestamp(event: MSRenderMonitorEvent, timestamp: BCTime): void;
  timestampForEvent(event: MSRenderMonitorEvent): BCTime;
  timeIntervalBetweenStartEvent_endEvent(startEvent: MSRenderMonitorEvent, endEvent: MSRenderMonitorEvent): NSTimeInterval;
  registerHook_forEvent(hook: MSRenderMonitorHook, event: MSRenderMonitorEvent): void;

  shouldRemoveWhenDone(): boolean;
  setShouldRemoveWhenDone(shouldRemoveWhenDone: boolean): void;
  shouldClearAllCaches(): boolean;
  setShouldClearAllCaches(shouldClearAllCaches: boolean): void;
  shouldForceFullRedraw(): boolean;
  setShouldForceFullRedraw(shouldForceFullRedraw: boolean): void;
}
declare const MSRenderMonitor: {
  alloc(): MSRenderMonitorAllocator;
}

declare enum MSRenderMonitorEvent {
  MSRenderMonitorEventQueued,
  MSRenderMonitorEventDiffStarted,
  MSRenderMonitorEventOverlayRenderStarted,
  MSRenderMonitorEventOverlayRenderFinished,
  MSRenderMonitorEventTileRenderStarted,
  MSRenderMonitorEventTileRenderFinished,
  MSRenderMonitorEventCount,
}

interface MSResizeArtboardToFitValidatorAllocator<InitializedType = MSResizeArtboardToFitValidator> extends NSObjectAllocator<MSResizeArtboardToFitValidator> {}
interface MSResizeArtboardToFitValidator extends NSObject {
}
declare const MSResizeArtboardToFitValidator: {
  alloc(): MSResizeArtboardToFitValidatorAllocator;  isValidForSelectedLayers(selectedLayers: MSLayerArray): boolean;

}

interface MSRotatedSnapItemAllocator<InitializedType = MSRotatedSnapItem> extends MSSnapItemAllocator<MSRotatedSnapItem> {}
interface MSRotatedSnapItem extends MSSnapItem {
}
declare const MSRotatedSnapItem: {
  alloc(): MSRotatedSnapItemAllocator;
}

interface MSRulerGuidesAllocator<InitializedType = MSRulerGuides> extends NSObjectAllocator<MSRulerGuides> {}
interface MSRulerGuides extends NSObject {
}
declare const MSRulerGuides: {
  alloc(): MSRulerGuidesAllocator;  findHoverGuidesOnPage_mouse_mask_zoomScale(page: MSPage, mouse: NSPoint, mask: MSAlignmentGuideMask, zoomScale: CGFloat): NSArray<any>;
  horizontalGuidesForVerticalRulerOnPage_mask_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, zoomScale: CGFloat): NSArray<any>;
  horizontalGuidesForVerticalRulerOnPage_mask_inRect_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, rect: NSRect, zoomScale: CGFloat): NSArray<any>;
  verticalGuidesForHorizontalRulerOnPage_mask_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, zoomScale: CGFloat): NSArray<any>;
  verticalGuidesForHorizontalRulerOnPage_mask_inRect_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, rect: NSRect, zoomScale: CGFloat): NSArray<any>;

}

declare enum MSAlignmentGuideMask {
  MSAlignmentGuideMaskCustom = 1 << 0,
  MSAlignmentGuideMaskGrid = 1 << 1,
}

interface MSSVGImporterAllocator<InitializedType = MSSVGImporter> extends NSObjectAllocator<MSSVGImporter> {}
interface MSSVGImporter extends NSObject, IMSImporter {
  importAsLayer(): MSLayer;
}
declare const MSSVGImporter: {
  alloc(): MSSVGImporterAllocator;  svgImporter(): MSSVGImporter;

}

interface MSShapeChangeContextAllocator<InitializedType = MSShapeChangeContext> extends NSObjectAllocator<MSShapeChangeContext> {
  initWithLayers_handleIndexPaths(layers: NSArray<any> | any[], indexPaths: NSArray<any> | any[] | null): InitializedType;
}
interface MSShapeChangeContext extends NSObject, INSCopying {
  enumerateCurvePointsUsingBlock(block: Block): void;
  curvePointAtIndexPath(indexPath: NSIndexPath): MSCurvePoint;
  locationOfHandleAtIndexPath_inCoordinateSpace(indexPath: NSIndexPath, coordinateSpace: any | null): NSPoint;

  layers(): NSArray<any>;
  handleIndexPaths(): NSArray<any>;
  orderedHandleIndexPaths(): NSArray<any>;
}
declare const MSShapeChangeContext: {
  alloc(): MSShapeChangeContextAllocator;
}

interface MSShapeChangeAllocator<InitializedType = MSShapeChange> extends NSObjectAllocator<MSShapeChange> {}
interface MSShapeChange extends NSObject {
  executeWithContext(context: MSShapeChangeContext): void;
}
declare const MSShapeChange: {
  alloc(): MSShapeChangeAllocator;  moveToPoint_options(location: NSPoint, options: MSCurveMoveOptions): MSShapeChange;
  moveByOffset_options(offset: NSSize, options: MSCurveMoveOptions): MSShapeChange;
  moveToLocation_onAxis(location: CGFloat, axis: BCAxis): MSShapeChange;
  moveHandle_toLocation_onAxis(indexPath: NSIndexPath, location: CGFloat, axis: BCAxis): MSShapeChange;
  nudgeWithKey_distance_flags(key: unichar, distance: CGFloat, flags: NSEventModifierFlags): MSShapeChange;
  changeToCurveMode(curveMode: MSCurveMode): MSShapeChange;
  alignToKey(key: NSString | string): MSShapeChange;
  distributeAlongAxis(axis: BCAxis): MSShapeChange;
  deleteHandle(): MSShapeChange;
  customActionWithBlock(block: Block): MSShapeChange;

}

interface MSShapeEditingBehaviorAllocator<InitializedType = MSShapeEditingBehavior> extends NSObjectAllocator<MSShapeEditingBehavior> {
  initForDrawingNewShape(drawingNewShape: boolean): InitializedType;
}
interface MSShapeEditingBehavior extends NSObject {
  isAddingPoints(context: MSShapeChangeContext): boolean;
  canInsertPoints(): boolean;
  shouldClosePathWhenMouseDownOnHandleAtIndexPath_modifierFlags_context(indexPath: NSIndexPath, flags: NSEventModifierFlags, context: MSShapeChangeContext): boolean;

  isNewShape(): boolean;
  allowSelectionOnly(): boolean;
  setAllowSelectionOnly(allowSelectionOnly: boolean): void;
  allowClosingPathUsingMouse(): boolean;
  setAllowClosingPathUsingMouse(allowClosingPathUsingMouse: boolean): void;
}
declare const MSShapeEditingBehavior: {
  alloc(): MSShapeEditingBehaviorAllocator;
}

interface MSShareableObjectPopUpButtonAllocator<InitializedType = MSShareableObjectPopUpButton> extends NSPopUpButtonAllocator<MSShareableObjectPopUpButton> {}
interface MSShareableObjectPopUpButton extends NSPopUpButton {
  updateWithMenuBuilder_forLayers(menuBuilder: MSForeignObjectMenuBuilder, layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
}
declare const MSShareableObjectPopUpButton: {
  alloc(): MSShareableObjectPopUpButtonAllocator;
}

interface MSShareableObjectReferenceAllocator<InitializedType = MSShareableObjectReference> extends NSObjectAllocator<MSShareableObjectReference> {}
interface MSShareableObjectReference extends NSObject, IBCSortable, IMSSharedObjectStyling {
  foreignObjectCollectionInDocument(document: MSDocumentData): NSArray<any>;

  sourceLibrary(): MSAssetLibrary;
  shareableObject(): MSShareableObject;
  shareableObjectType(): MSShareableObjectType;
  sharedObjectID(): NSString;
  locationPath(): NSString;
}
declare const MSShareableObjectReference: {
  alloc(): MSShareableObjectReferenceAllocator;  referenceForShareableObject(object: MSModelObject): MSShareableObjectReference;
  referenceForShareableObject_inLibrary(object: MSModelObject, library: MSAssetLibrary): MSShareableObjectReference;

}

declare type MSShareableObject = MSModelObject

declare enum MSShareableObjectType {
  MSShareableObjectTypeSymbol = 0,
  MSShareableObjectTypeLayerStyle,
  MSShareableObjectTypeTextStyle,
  MSShareableObjectTypeUnknown,
}

interface MSShareableObjectUpdaterAllocator<InitializedType = MSShareableObjectUpdater> extends NSObjectAllocator<MSShareableObjectUpdater> {}
interface MSShareableObjectUpdater extends NSObject {
  performCreateNewStyleAction(): void;
  performSyncAndOrUnlinkAction(): void;
  performResetAction(): void;
  performDetachAction(): void;

  selectedLayers(): MSLayerArray;
  setSelectedLayers(selectedLayers: MSLayerArray): void;
  shareableObjectType(): MSShareableObjectType;
  hasOutOfSyncStyles(): boolean;
  allSharedObjects(): NSSet<any>;
  shareableObject(): MSShareableObject;
  selectedStyle(): MSStyle;
  foreignSharedObjects(): NSSet<any>;
  menuItemTitleForCreateNewStyleAction(): NSString;
  menuItemTitleForSyncAction(): NSString;
  menuItemTitleForUnlinkAction(): NSString;
  menuItemTitleForUnlinkAndSyncAction(): NSString;
  menuItemTitleForResetStyleAction(): NSString;
  menuItemTitleForDetachAction(): NSString;
}
declare const MSShareableObjectUpdater: {
  alloc(): MSShareableObjectUpdaterAllocator;
}

interface MSSharedStyleAllocator<InitializedType = MSSharedStyle> extends _MSSharedStyleAllocator<MSSharedStyle> {}
interface MSSharedStyle extends _MSSharedStyle {
  resetReferencingInstances(): void;
  newInstance(): MSStyle;

  style(): MSStyle;
}
declare const MSSharedStyle: {
  alloc(): MSSharedStyleAllocator;
}

interface IMSSharedObjectStyling {
  generatePreviewForMenuItem_withColorSpace_backingScale_completionBlock(menuItem: NSMenuItem, colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForPopup_backingScale_completionBlock(cell: NSPopUpButtonCell, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForManageSheetWithBackingScale_completionBlock(backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForSyncSheetWithSize_backingScale_shadow_colorSpace_completionBlock(size: CGSize, backingScale: CGFloat, shadow: boolean, colorSpace: NSColorSpace, block: MSPreviewGeneratorBlock): void;
  applyStyleToMenuItem_withColorSpace(item: NSMenuItem | null, colorSpace: NSColorSpace | null): void;
}

interface MSSharedStyleReferenceAllocator<InitializedType = MSSharedStyleReference> extends MSShareableObjectReferenceAllocator<MSSharedStyleReference> {}
interface MSSharedStyleReference extends MSShareableObjectReference {
}
declare const MSSharedStyleReference: {
  alloc(): MSSharedStyleReferenceAllocator;
}

interface MSSharedLayerReferenceAllocator<InitializedType = MSSharedLayerReference> extends MSSharedStyleReferenceAllocator<MSSharedLayerReference> {}
interface MSSharedLayerReference extends MSSharedStyleReference {
}
declare const MSSharedLayerReference: {
  alloc(): MSSharedLayerReferenceAllocator;
}

interface MSSharedTextReferenceAllocator<InitializedType = MSSharedTextReference> extends MSSharedStyleReferenceAllocator<MSSharedTextReference> {}
interface MSSharedTextReference extends MSSharedStyleReference {
}
declare const MSSharedTextReference: {
  alloc(): MSSharedTextReferenceAllocator;
}

interface MSSharedStylesPopUpButtonCellAllocator<InitializedType = MSSharedStylesPopUpButtonCell> extends NSPopUpButtonCellAllocator<MSSharedStylesPopUpButtonCell> {}
interface MSSharedStylesPopUpButtonCell extends NSPopUpButtonCell {

  localIsOutOfSync(): boolean;
  setLocalIsOutOfSync(localIsOutOfSync: boolean): void;
}
declare const MSSharedStylesPopUpButtonCell: {
  alloc(): MSSharedStylesPopUpButtonCellAllocator;
}

interface MSSidebarListControllerAllocator<InitializedType = MSSidebarListController> extends NSObjectAllocator<MSSidebarListController> {
  initWithDelegate(delegate: any): InitializedType;
}
interface MSSidebarListController extends NSObject {
  readDragNodesFromPasteboard(pboard: NSPasteboard): NSArray<any>;
  layerForNode(node: any): MSLayer;
  layersFromNodeArray(nodes: NSArray<any> | any[]): NSArray<any>;
  canMoveNode_toParent_after(node: any, parent: any, previousNode: any): boolean;
  canCopyNode_toParent_after(node: any, parent: any, previousNode: any): boolean;
  moveNode_toParent_after(node: any, parent: any, previousNode: any): boolean;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;

  delegate(): any;
  documentData(): MSDocumentData;
  rootObject(): any;
}
declare const MSSidebarListController: {
  alloc(): MSSidebarListControllerAllocator;
}

interface MSSimpleGridAllocator<InitializedType = MSSimpleGrid> extends _MSSimpleGridAllocator<MSSimpleGrid> {}
interface MSSimpleGrid extends _MSSimpleGrid {
  horizontalGuidesForRulerData_inRect(rulerData: MSRulerData, rect: NSRect): NSArray<any>;
  verticalGuidesForRulerData_inRect(rulerData: MSRulerData, rect: NSRect): NSArray<any>;
}
declare const MSSimpleGrid: {
  alloc(): MSSimpleGridAllocator;
}

interface MSSizeInspectorValueAdaptorAllocator<InitializedType = MSSizeInspectorValueAdaptor> extends MSCoordinateInspectorValueAdaptorAllocator<MSSizeInspectorValueAdaptor> {}
interface MSSizeInspectorValueAdaptor extends MSCoordinateInspectorValueAdaptor {
}
declare const MSSizeInspectorValueAdaptor: {
  alloc(): MSSizeInspectorValueAdaptorAllocator;
}

interface MSSmartGuideDrawingAllocator<InitializedType = MSSmartGuideDrawing> extends NSObjectAllocator<MSSmartGuideDrawing> {}
interface MSSmartGuideDrawing extends NSObject {
}
declare const MSSmartGuideDrawing: {
  alloc(): MSSmartGuideDrawingAllocator;  smartGuideColor(): NSColor;
  resetSmartGuideColor(): void;

}

interface MSMeasurementDrawingAllocator<InitializedType = MSMeasurementDrawing> extends MSSmartGuideDrawingAllocator<MSMeasurementDrawing> {}
interface MSMeasurementDrawing extends MSSmartGuideDrawing {
  drawWithFrame_zoomScale(frame: NSRect, zoomScale: CGFloat): void;
  frameForMeasuringSizeOfRect_zoomScale(targetRect: NSRect, zoomScale: CGFloat): NSRect;

  orientation(): BCAxis;
  setOrientation(orientation: BCAxis): void;
  labelText(): NSString;
  setLabelText(labelText: NSString | string): void;
  labelTransform(): CGAffineTransform;
  setLabelTransform(labelTransform: CGAffineTransform): void;
  color(): NSColor;
  setColor(color: NSColor): void;
}
declare const MSMeasurementDrawing: {
  alloc(): MSMeasurementDrawingAllocator;
}

interface MSSnapItemAllocator<InitializedType = MSSnapItem> extends NSObjectAllocator<MSSnapItem> {
  initWithLayers(layers: NSArray<any> | any[]): InitializedType;
}
interface MSSnapItem extends NSObject, IMSSnappable {
  rotation(): CGFloat;
  snapInBlock(block: BCVoidBlock): void;
  candidateLayersForSnapping(snapType: MSSnapType): NSArray<any>;
  artboardForSnapping(): MSArtboardGroup;
  shouldDrawDistanceOnSnapTo(snapItem: any): boolean;

  rectForSnapping(): NSRect;
  setRectForSnapping(rectForSnapping: NSRect): void;
  shouldConstrainProportions(): boolean;
  supportsResizingForSnapping(): boolean;
  layers(): NSArray<any>;
  layer(): MSLayer;
}
declare const MSSnapItem: {
  alloc(): MSSnapItemAllocator;  snapItemWithLayers(layers: NSArray<any> | any[]): MSSnapItem;

}

interface IMSSnappable {
  boundsRect(): NSRect;
  alignmentRectInCoordinateSpace_options(coordinateSpace: any, options: MSAlignmentRectOptions): NSRect;
  enumerateAnchorsForSnappingOnAxes_usingBlock(axes: BCAxis, block: Block): void;
  anchorsForSnappingOnAxes(axes: BCAxis): NSArray<any>;
  distanceRectangleToItem_axis(other: any, axis: BCAxis): NSRect;
  refreshOverlayWithAbsoluteMargins(margins: NSSize): void;
  concatAncestorsAndSelfTransforms(): void;
  textCorrectionTransform(): CGAffineTransform;

  rectForSnapping(): NSRect;
  coordinateSpace(): MSLayer;
  leftAnchor(): MSLayoutPosition;
  rightAnchor(): MSLayoutPosition;
  topAnchor(): MSLayoutPosition;
  bottomAnchor(): MSLayoutPosition;
  centerXAnchor(): MSLayoutPosition;
  centerYAnchor(): MSLayoutPosition;
  widthAnchor(): MSLayoutDimension;
  heightAnchor(): MSLayoutDimension;
  baselineAnchor(): MSLayoutPosition;
  midXHeightAnchor(): MSLayoutPosition;
  snapItemForDrawing(): any;
  name(): NSString;
}

declare enum MSLayoutAttribute {
  MSLayoutAttributeLeft,
  MSLayoutAttributeRight,
  MSLayoutAttributeTop,
  MSLayoutAttributeBottom,
  MSLayoutAttributeWidth,
  MSLayoutAttributeHeight,
  MSLayoutAttributeCenterX,
  MSLayoutAttributeCenterY,
  MSLayoutAttributeBaseline,
  MSLayoutAttributeMidXHeight,
  MSLayoutAttributeCapHeight,
  MSLayoutAttributeGuideX,
  MSLayoutAttributeGuideY,
  MSLayoutAttributeNotAnAttribute,
}

declare enum MSSnapType {
  MSSnapGuides,
  MSSnapSpacing,
  MSSnapDimension,
}

interface MSSnapperAllocator<InitializedType = MSSnapper> extends NSObjectAllocator<MSSnapper> {}
interface MSSnapper extends NSObject {
  snapSize_edges(snap: BCAxis, mask: NSInteger): BCAxis;
  snapSpacingOnEdges_mayResize(mask: BCEdge, resize: boolean): BCAxis;
  snapDuringSession(session: MSSnappingSession): MSSnapperData;
  snapToLines_adjustableAxes_mayResize(lines: NSArray<any> | any[], adjustableAxes: BCAxis, resize: boolean): void;

  snapperData(): MSSnapperData;
  setSnapperData(snapperData: MSSnapperData): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}
declare const MSSnapper: {
  alloc(): MSSnapperAllocator;
}

interface MSSnapperDataAllocator<InitializedType = MSSnapperData> extends NSObjectAllocator<MSSnapperData> {
  initWithSnappingSession(session: MSSnappingSession): InitializedType;
}
interface MSSnapperData extends NSObject {
  accumulatorForAxis(axis: BCAxis): MSSnappingAccumulator;
  firstDimensionSnapForAxis(axis: BCAxis): MSLayoutRelationship;
  addDimensionSnap(snap: MSLayoutRelationship): void;
  firstSpacingSnapForAxis(axis: BCAxis): MSLayoutRelationship;
  addSpacingSnap(snap: MSLayoutRelationship): void;
  addEdgeSnap(relationship: MSLayoutRelationship): void;
  resetEdgeSnapsForAxis(axis: BCAxis): void;
  addSpacingMeasurementsForEdgeSnaps(): void;
  drawForGroup_zoomScale(group: MSLayerGroup, zoom: CGFloat): void;

  snappingSession(): MSSnappingSession;
  item(): MSSnapItem;
  xAxisAccumulator(): MSSnappingAccumulator;
  yAxisAccumulator(): MSSnappingAccumulator;
  dimensionAxes(): BCAxis;
  spacingAxes(): BCAxis;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
}
declare const MSSnapperData: {
  alloc(): MSSnapperDataAllocator;
}

interface MSSnappingAccumulatorAllocator<InitializedType = MSSnappingAccumulator> extends NSObjectAllocator<MSSnappingAccumulator> {
  initWithAxis(axis: BCAxis): InitializedType;
}
interface MSSnappingAccumulator extends NSObject {
  removeAllEdgeSnaps(): void;
  removeAllDimensionSnaps(): void;
  removeAllSpacingSnaps(): void;

  axis(): BCAxis;
  edgeSnaps(): NSArray<any>;
  dimensionSnaps(): NSArray<any>;
  spacingSnaps(): NSArray<any>;
}
declare const MSSnappingAccumulator: {
  alloc(): MSSnappingAccumulatorAllocator;
}

interface MSSnappingSessionAllocator<InitializedType = MSSnappingSession> extends NSObjectAllocator<MSSnappingSession> {}
interface MSSnappingSession extends NSObject {

  sessionType(): MSSnappingSessionType;
  snapDistance(): CGFloat;
  setSnapDistance(snapDistance: CGFloat): void;
  zoomScale(): CGFloat;
  setZoomScale(zoomScale: CGFloat): void;
  effectiveSnapDistance(): CGFloat;
  allowedAxes(): BCAxis;
  setAllowedAxes(allowedAxes: BCAxis): void;
  item(): MSSnapItem;
  layers(): NSArray<any>;
  layer(): MSLayer;
  corner(): BCCorner;
  setCorner(corner: BCCorner): void;
  snappableEdges(): BCEdge;
  snappableAttributes(): NSIndexSet;
  shouldSnapToLayers(): boolean;
  setShouldSnapToLayers(shouldSnapToLayers: boolean): void;
  snappableGuidesMask(): MSAlignmentGuideMask;
  setSnappableGuidesMask(snappableGuidesMask: MSAlignmentGuideMask): void;
}
declare const MSSnappingSession: {
  alloc(): MSSnappingSessionAllocator;  moveSnappingSessionWithItem(item: MSSnapItem): MSSnappingSession;
  resizeSnappingSessionWithItem_corner(item: MSSnapItem, corner: BCCorner): MSSnappingSession;
  keySnappingSessionWithItem(item: MSSnapItem): MSSnappingSession;

}

declare enum MSSnappingSessionType {
  MSSnappingSessionTypeMove,
  MSSnappingSessionTypeResize,
  MSSnappingSessionTypeKey,
}

interface MSSnappingTargetAllocator<InitializedType = MSSnappingTarget> extends NSObjectAllocator<MSSnappingTarget> {
  initWithGuideLine(lineSegment: MSLineSegment): InitializedType;
  initWithPosition_onAxis(value: CGFloat, axis: BCAxis): InitializedType;
  initWithPoint_axis_wantsGuide_length(point: NSPoint, axis: BCAxis, showGuide: boolean, length: CGFloat): InitializedType;
  initWithPoint_directionVector_guideType(point: NSPoint, vector: CGVector, guideType: MSSnappingTargetGuideType): InitializedType;
}
interface MSSnappingTarget extends NSObject, INSCopying {

  point(): NSPoint;
  directionVector(): CGVector;
  line(): MSLine;
  lineSegment(): MSLineSegment;
  guideType(): MSSnappingTargetGuideType;
}
declare const MSSnappingTarget: {
  alloc(): MSSnappingTargetAllocator;  targetsForEdgesOfRect_includeCenter(rect: NSRect, includeCenter: boolean): NSArray<any>;

}

declare enum MSSnappingTargetGuideType {
  MSSnappingTargetGuideNone,
  MSSnappingTargetGuidePoint,
  MSSnappingTargetGuideSegment,
}

interface MSSortableObjectMenuBuilderAllocator<InitializedType = MSSortableObjectMenuBuilder> extends NSObjectAllocator<MSSortableObjectMenuBuilder> {
  initWithDelegate(delegate: any): InitializedType;
}
interface MSSortableObjectMenuBuilder extends NSObject, INSMenuDelegate {
  menuItemsForSortableObjects_selectedObjects_target_selector(objects: NSArray<any> | any[], selectedObjects: NSArray<any> | any[], target: any, action: string): NSArray<any>;
  addSortableObjects_selectedObjects_toPopUpButton_target_selector(objects: NSArray<any> | any[], selectedObjects: NSArray<any> | any[], button: NSPopUpButton, target: any, action: string): void;
  menuWillOpen(menu: NSMenu): void;
  prepareForDisplay(menuItem: NSMenuItem): void;
}
declare const MSSortableObjectMenuBuilder: {
  alloc(): MSSortableObjectMenuBuilderAllocator;
}

interface IMSMenuBuilderDelegate {
  previewColorSpaceForItem(item: NSMenuItem): NSColorSpace;
}

interface MSStyleOverridePopupButtonAllocator<InitializedType = MSStyleOverridePopupButton> extends NSPopUpButtonAllocator<MSStyleOverridePopupButton> {}
interface MSStyleOverridePopupButton extends NSPopUpButton {
  buildMenuForOverride_withMenuBuilder_document(primaryOverride: MSAvailableOverride, menuBuilder: MSForeignObjectMenuBuilder, document: MSDocumentData): void;
}
declare const MSStyleOverridePopupButton: {
  alloc(): MSStyleOverridePopupButtonAllocator;
}

interface MSStyleOverridePopupButtonCellAllocator<InitializedType = MSStyleOverridePopupButtonCell> extends NSPopUpButtonCellAllocator<MSStyleOverridePopupButtonCell> {}
interface MSStyleOverridePopupButtonCell extends NSPopUpButtonCell {
}
declare const MSStyleOverridePopupButtonCell: {
  alloc(): MSStyleOverridePopupButtonCellAllocator;
}

interface MSStylePartAllocator<InitializedType = MSStylePart> extends _MSStylePartAllocator<MSStylePart> {}
interface MSStylePart extends _MSStylePart, INSCopying, IMSStylePart {
  previewImageForSize_colorSpace(size: NSSize, colorSpace: NSColorSpace): NSImage;
  hasEqualAppearance(other: MSStylePart): boolean;
  multiplyBy(amount: CGFloat): void;
  parentStyle(): MSStyle;
  parentLayer(): MSStyledLayer;
  blendingViewForColorInspector(blendingViews: NSDictionary<any, any> | {[key: string]: any}): NSView;
  topViewForColorInspector(topViews: NSDictionary<any, any> | {[key: string]: any}): NSView;
}
declare const MSStylePart: {
  alloc(): MSStylePartAllocator;  stylesHaveEqualAppearance(styles: NSArray<any> | any[]): boolean;
  defaultStylePartForStyle(style: MSStyle): MSStylePart;

}

interface MSStylePartInspectorValueAdaptorAllocator<InitializedType = MSStylePartInspectorValueAdaptor> extends MSInspectorValueAdaptorAllocator<MSStylePartInspectorValueAdaptor> {}
interface MSStylePartInspectorValueAdaptor extends MSInspectorValueAdaptor {
}
declare const MSStylePartInspectorValueAdaptor: {
  alloc(): MSStylePartInspectorValueAdaptorAllocator;
}

interface MSSymbolCreatorAllocator<InitializedType = MSSymbolCreator> extends NSObjectAllocator<MSSymbolCreator> {}
interface MSSymbolCreator extends NSObject {
}
declare const MSSymbolCreator: {
  alloc(): MSSymbolCreatorAllocator;  canCreateSymbolFromLayers(layers: MSLayerArray): boolean;
  createSymbolFromLayers_withName_onSymbolsPage(layers: MSLayerArray, name: NSString | string, useSymbolsPage: boolean): MSSymbolInstance;

}

interface MSSymbolMasterReferenceAllocator<InitializedType = MSSymbolMasterReference> extends MSShareableObjectReferenceAllocator<MSSymbolMasterReference> {}
interface MSSymbolMasterReference extends MSShareableObjectReference {

  symbolMaster(): MSSymbolMaster;
  descriptor(): MSSymbolMasterReferenceDescriptor;
}
declare const MSSymbolMasterReference: {
  alloc(): MSSymbolMasterReferenceAllocator;
}

interface MSSymbolMasterReferenceDescriptorAllocator<InitializedType = MSSymbolMasterReferenceDescriptor> extends NSObjectAllocator<MSSymbolMasterReferenceDescriptor> {
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): InitializedType;
}
interface MSSymbolMasterReferenceDescriptor extends NSObject, INSPasteboardWriting, INSPasteboardReading {

  libraryLocation(): NSURL;
  setLibraryLocation(libraryLocation: NSURL): void;
  symbolID(): NSString;
  setSymbolID(symbolID: NSString | string): void;
}
declare const MSSymbolMasterReferenceDescriptor: {
  alloc(): MSSymbolMasterReferenceDescriptorAllocator;  pasteboardType(): NSString;

}

interface MSSymbolPreviewGeneratorAllocator<InitializedType = MSSymbolPreviewGenerator> extends NSObjectAllocator<MSSymbolPreviewGenerator> {}
interface MSSymbolPreviewGenerator extends NSObject {
}
declare const MSSymbolPreviewGenerator: {
  alloc(): MSSymbolPreviewGeneratorAllocator;  imageForSymbolAncestry_withSize_colorSpace_trimmed(ancestry: MSImmutableLayerAncestry, size: NSSize, colorSpace: NSColorSpace, trimmed: boolean): NSImage;

}

interface MSTextLayerAllocator<InitializedType = MSTextLayer> extends _MSTextLayerAllocator<MSTextLayer> {
  initWithAttributedString_documentColorSpace_maxWidth(attributedString: NSAttributedString | null, colorSpace: NSColorSpace, maxWidth: CGFloat): InitializedType;
  initWithFrame_attributes_documentColorSpace_type(aRect: NSRect, attributes: NSDictionary<any, any> | {[key: string]: any} | null, colorSpace: NSColorSpace, behaviourType: BCTextBehaviourType): InitializedType;
}
interface MSTextLayer extends _MSTextLayer, IMSFirstLineTypesetterDelegate, IMSColorConvertible {
  layersByConvertingToOutlines(): NSArray<any>;
  changeFont(sender: any | null): void;
  font(): NSFont;
  shapeToUseForTextOnPath(): MSStyledLayer;
  bezierPathFromGlyphsInBounds(): NSBezierPath;
  isEmpty(): boolean;
  finishEditing(): void;
  updateNameFromStorage(): void;
  replaceMissingFontsIfNecessary(): void;
  adjustFrameToFit(): void;
  ignoreDelegateNotificationsInBlock(block: BCVoidBlock): void;
  addAttribute_value_forRange(attributeName: NSString | string, value: any | null, range: NSRange): void;
  setAttributes_forRange(attributes: NSDictionary<any, any> | {[key: string]: any} | null, range: NSRange): void;
  makeUppercase(sender: any | null): IBAction;
  makeLowercase(sender: any | null): IBAction;
  setTextTransform_range(textTransform: MSAttributedStringTextTransform, range: NSRange): void;
  changeListType(textList: NSTextList | null): void;
  syncTextStyleAttributes(): void;
  checkTextBehaviourAndClippingAfterResizeFromCorner_mayClip(corner: BCCorner, mayClip: boolean): void;
  shouldStorePDFPreviews(): boolean;
  PDFPreview(): MSImageData;

  supportsVerticalAlignment(): boolean;
  previousRectCache(): NSRect;
  setPreviousRectCache(previousRectCache: NSRect): void;
  isEditingText(): boolean;
  setIsEditingText(isEditingText: boolean): void;
  textAlignment(): NSTextAlignment;
  setTextAlignment(textAlignment: NSTextAlignment): void;
  verticalAlignment(): MSTextStyleVerticalAlignment;
  setVerticalAlignment(verticalAlignment: MSTextStyleVerticalAlignment): void;
  characterSpacing(): NSNumber;
  setCharacterSpacing(characterSpacing: NSNumber | number): void;
  fontPostscriptName(): NSString;
  setFontPostscriptName(fontPostscriptName: NSString | string): void;
  styleAttributes(): NSDictionary<any, any>;
  setStyleAttributes(styleAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  attributedStringValue(): NSAttributedString;
  setAttributedStringValue(attributedStringValue: NSAttributedString): void;
  transientGlyphBoundsValue(): NSValue;
  setTransientGlyphBoundsValue(transientGlyphBoundsValue: NSValue): void;
  textColor(): MSColor;
  setTextColor(textColor: MSColor): void;
  editingDelegate(): any;
  setEditingDelegate(editingDelegate: any): void;
}
declare const MSTextLayer: {
  alloc(): MSTextLayerAllocator;  canSetTextAlignmentForLayers(layers: MSLayerArray): boolean;
  setTextAlignment_forLayers(alignment: NSTextAlignment, layers: MSLayerArray): void;
  menuItemStateForAlignment_forLayers(alignment: NSTextAlignment, layers: MSLayerArray): NSInteger;
  canSetTextVerticalAlignmentForLayers(layers: MSLayerArray): boolean;
  setTextVerticalAlignment_forLayers(alignment: MSTextStyleVerticalAlignment, layers: MSLayerArray): void;
  menuItemStateForTextVerticalAlignment_forLayers(alignment: MSTextStyleVerticalAlignment, layers: MSLayerArray): NSInteger;
  maintainTextLayerBaselinesForLayers_inBlock(textLayers: NSArray<any> | any[], block: BCVoidBlock): void;

}

interface MSTextSnapItemAllocator<InitializedType = MSTextSnapItem> extends MSSnapItemAllocator<MSTextSnapItem> {}
interface MSTextSnapItem extends MSSnapItem {
}
declare const MSTextSnapItem: {
  alloc(): MSTextSnapItemAllocator;
}

interface MSTextStyleMenuPreviewAllocator<InitializedType = MSTextStyleMenuPreview> extends NSObjectAllocator<MSTextStyleMenuPreview> {}
interface MSTextStyleMenuPreview extends NSObject {
}
declare const MSTextStyleMenuPreview: {
  alloc(): MSTextStyleMenuPreviewAllocator;  applyTextStylesToMenuItem_colorSpace(item: NSMenuItem, colorSpace: NSColorSpace): void;
  attributedTitleForTextStyle_colorSpace(sharedStyle: MSSharedStyle, colorSpace: NSColorSpace): NSAttributedString;

}

interface MSToggleHUDActionAllocator<InitializedType = MSToggleHUDAction> extends MSActionAllocator<MSToggleHUDAction> {}
interface MSToggleHUDAction extends MSAction {
  toggleHUD(sender: any): IBAction;
}
declare const MSToggleHUDAction: {
  alloc(): MSToggleHUDActionAllocator;
}

interface MSToolbarItemAllocator<InitializedType = MSToolbarItem> extends NSToolbarItemAllocator<MSToolbarItem> {
  initWithAction(action: MSAction): InitializedType;
}
interface MSToolbarItem extends NSToolbarItem {
  makeViewForAction(action: MSAction): NSView;
}
declare const MSToolbarItem: {
  alloc(): MSToolbarItemAllocator;
}

interface MSUserAssetLibraryAllocator<InitializedType = MSUserAssetLibrary> extends MSAssetLibraryAllocator<MSUserAssetLibrary> {}
interface MSUserAssetLibrary extends MSAssetLibrary {
}
declare const MSUserAssetLibrary: {
  alloc(): MSUserAssetLibraryAllocator;
}

interface MSVectorHandleStateDeciderAllocator<InitializedType = MSVectorHandleStateDecider> extends NSObjectAllocator<MSVectorHandleStateDecider> {}
interface MSVectorHandleStateDecider extends NSObject {
  reset(): void;
  isHandleAtIndexPathSelected(indexPath: NSIndexPath): boolean;
  isHandleAtIndexPathVisible(indexPath: NSIndexPath): boolean;
  stateOfCurvePointAtIndexPath_curveToState_curveFromState(indexPath: NSIndexPath, curveToState: MSHandleState, curveFromState: MSHandleState): MSHandleState;
  indexPathOfHandleAtPoint_tolerance(point: NSPoint, tolerance: CGFloat): NSIndexPath;

  visibilityAroundSelectedHandles(): MSCurveAdjustmentHandleVisibility;
  setVisibilityAroundSelectedHandles(visibilityAroundSelectedHandles: MSCurveAdjustmentHandleVisibility): void;
  visibilityAroundHighlight(): MSCurveAdjustmentHandleVisibility;
  setVisibilityAroundHighlight(visibilityAroundHighlight: MSCurveAdjustmentHandleVisibility): void;
  selectionContext(): MSShapeChangeContext;
  setSelectionContext(selectionContext: MSShapeChangeContext): void;
  indexPathForHighlightedComponent(): NSIndexPath;
  setIndexPathForHighlightedComponent(indexPathForHighlightedComponent: NSIndexPath): void;
}
declare const MSVectorHandleStateDecider: {
  alloc(): MSVectorHandleStateDeciderAllocator;
}

declare enum MSCurveAdjustmentHandleVisibility {
  MSCurveAdjustmentHandleVisibilityDirect,
  MSCurveAdjustmentHandleVisibilityAdjacent,
  MSCurveAdjustmentHandleVisibilityExtended,
  MSCurveAdjustmentHandleVisibilityAll,
}

interface MSVectorRoundingAllocator<InitializedType = MSVectorRounding> extends NSObjectAllocator<MSVectorRounding> {}
interface MSVectorRounding extends NSObject {
}
declare const MSVectorRounding: {
  alloc(): MSVectorRoundingAllocator;  precision(): MSVectorPrecision;
  roundPoint_layer(p: NSPoint, layer: MSLayer): NSPoint;
  roundPoint(p: NSPoint): NSPoint;

}

declare enum MSVectorPrecision {
  MSVectorPrecisionFreeForm,
  MSVectorPrecisionHalfPixel,
  MSVectorPrecisionPixel,
}

interface MSViewPortAllocator<InitializedType = MSViewPort> extends NSObjectAllocator<MSViewPort> {}
interface MSViewPort extends NSObject {

  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}
declare const MSViewPort: {
  alloc(): MSViewPortAllocator;  viewPortWithScrollOrigin_zoom(origin: NSPoint, zoom: CGFloat): MSViewPort;
  cappedZoom(zoom: CGFloat): CGFloat;
  minimumZoomValue(): CGFloat;
  maximumZoomValue(): CGFloat;

}

declare enum MSWebExportLayerBehavior {
  MSWebExportLayerBehaviorDefault = 0,
  MSWebExportLayerBehaviorScrollable = 1 << 0,
  MSWebExportLayerBehaviorFixedToTop = 1 << 1,
  MSWebExportLayerBehaviorFixedToBottom = 1 << 2,
  MSWebExportLayerBehaviorFixed,
}

interface MSWebExportRequestAllocator<InitializedType = MSWebExportRequest> extends MSExportRequestAllocator<MSWebExportRequest> {}
interface MSWebExportRequest extends MSExportRequest {

  rootLayer(): MSImmutableLayer;
  setRootLayer(rootLayer: MSImmutableLayer): void;
  layerBehavior(): MSWebExportLayerBehavior;
  setLayerBehavior(layerBehavior: MSWebExportLayerBehavior): void;
}
declare const MSWebExportRequest: {
  alloc(): MSWebExportRequestAllocator;  webExportRequestForRootLayer_inDocument_atScale(rootLayer: MSImmutableLayer, documentData: MSImmutableDocumentData, scale: CGFloat): MSWebExportRequest;

}

interface MSImmutableArtboardGroupAllocator<InitializedType = MSImmutableArtboardGroup> extends _MSImmutableArtboardGroupAllocator<MSImmutableArtboardGroup> {}
interface MSImmutableArtboardGroup extends _MSImmutableArtboardGroup, IMSLayerWithBackgroundColor, IMSArtboardGroup, IMSImmutableRootLayer {
  shouldDrawBackgroundInContext(context: MSRenderingContext): boolean;

  unscaledNameSize(): NSSize;
  preset(): MSArtboardPreset;
}
declare const MSImmutableArtboardGroup: {
  alloc(): MSImmutableArtboardGroupAllocator;
}

interface MSImmutablePageAllocator<InitializedType = MSImmutablePage> extends _MSImmutablePageAllocator<MSImmutablePage> {}
interface MSImmutablePage extends _MSImmutablePage, IMSImmutableRootLayer {
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;

  selectedLayerIDs(): NSSet<any>;
  artboards(): NSArray<any>;
  hasArtboards(): boolean;
  symbols(): NSArray<any>;
}
declare const MSImmutablePage: {
  alloc(): MSImmutablePageAllocator;
}

interface MSSubtreeRootAllocator<InitializedType = MSSubtreeRoot> extends NSObjectAllocator<MSSubtreeRoot> {}
interface MSSubtreeRoot extends NSObject {
  contentDirtyDiffRect(): NSRect;
  overlayInfluenceRect(): NSRect;

  webExportableRootLayer(): MSImmutableLayerGroup;
  object(): MSImmutableModelObject;
  setObject(object: MSImmutableModelObject): void;
  ancestorsOfObject(): NSArray<any>;
  setAncestorsOfObject(ancestorsOfObject: NSArray<any> | any[]): void;
  document(): MSImmutableDocumentData;
  setDocument(document: MSImmutableDocumentData): void;
}
declare const MSSubtreeRoot: {
  alloc(): MSSubtreeRootAllocator;
}

interface IMSWebExportableRootLayer {
  webExportLayerBehaviorWithRect_fromLayer(rect: CGRect, layer: MSImmutableLayer): MSWebExportLayerBehavior;
  rectInFixedViewportWithRect_fromFixingLayer(rect: CGRect, layer: MSImmutableLayer): CGRect;

  webExporterBackgoundColor(): MSImmutableColor;
  webExporterShouldIncludeBackgroundColor(): boolean;
  isFlowHome(): boolean;
  preset(): MSArtboardPreset;
  containsFixedLayers(): boolean;
}

interface MSWebExporterAllocator<InitializedType = MSWebExporter> extends NSObjectAllocator<MSWebExporter> {
  initWithDocument_name_localURL(doc: MSDocumentData, name: NSString | string, localURL: NSURL): InitializedType;
}
interface MSWebExporter extends NSObject {
  exportArtboardsWithCompletionBlock(completionBlock: MSWebExporterCompletionBlock): void;
  exportDocumentWithUIMetadata_completionBlock(UIMetadata: NSDictionary<any, any> | {[key: string]: any}, completionBlock: MSWebExporterCompletionBlock): void;
  cancel(): void;

  documentData(): MSDocumentData;
  destinationURL(): NSURL;
  name(): NSString;
  cacheManager(): MSCacheManager;
  setCacheManager(cacheManager: MSCacheManager): void;
  selectiveExport(): boolean;
  setSelectiveExport(selectiveExport: boolean): void;
}
declare const MSWebExporter: {
  alloc(): MSWebExporterAllocator;  exportArtboardsOfDocument_withName_toLocalURL_completionBlock(doc: MSDocumentData, name: NSString | string, localURL: NSURL, completionBlock: MSWebExporterCompletionBlock): void;
  exportSelectedArtboardsOfDocument_withName_toLocalURL_completionBlock(doc: MSDocumentData, name: NSString | string, localURL: NSURL, completionBlock: MSWebExporterCompletionBlock): void;
  exportBitmapImageForRequest(request: MSWebExportRequest): NSBitmapImageRep;
  imageURLWithHash_inDirectory(dataHash: NSString | string, directory: NSURL): NSURL;
  documentURLInDirectory(directory: NSURL): NSURL;

}

interface IMSWindowBadgeAction {

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

interface BCSketchFileMigratorClientAllocator<InitializedType = BCSketchFileMigratorClient> extends NSObjectAllocator<BCSketchFileMigratorClient> {}
interface BCSketchFileMigratorClient extends NSObject {
  validateDocumentAtURL_options_withReply(atURL: NSURL, options: BCSketchFileMigratorOptions, reply: Block): void;
  migrateDocumentAtURL_intoFolderAtURL_options_withReply(atURL: NSURL, intoURL: NSURL, options: BCSketchFileMigratorOptions, reply: Block): void;
  migrateResourcesWithNames_atURL_options_withReply(names: NSArray<any> | any[], url: NSURL, options: BCSketchFileMigratorOptions, reply: Block): void;
}
declare const BCSketchFileMigratorClient: {
  alloc(): BCSketchFileMigratorClientAllocator;
}

declare enum BCSketchFileMigratorOptions {
  BCSketchFileMigrateAsynchronous = 0x00,
  BCSketchFileMigrateSynchronous = 0x01,
  BCSketchFileMigratePartOfChain = 0x02,
  BCSketchFileMigrateBadParameters = 0x04,
}

interface BCSketchFileMigratorErrorAllocator<InitializedType = BCSketchFileMigratorError> extends NSErrorAllocator<BCSketchFileMigratorError> {}
interface BCSketchFileMigratorError extends NSError {
}
declare const BCSketchFileMigratorError: {
  alloc(): BCSketchFileMigratorErrorAllocator;  errorWithCode(code: BCSketchFileMigratorErrorCode): BCSketchFileMigratorError;
  errorWithCode_underlyingCode_missingFonts(code: BCSketchFileMigratorErrorCode, underlyingCode: MSDocumentErrorCode, missingFonts: NSArray<any> | any[]): BCSketchFileMigratorError;

}

declare enum BCSketchFileMigratorErrorCode {
  BCSketchFileMigratorNoError,
  BCSketchFileMigratorGenericError,
  BCSketchFileMigratorBadFromURL,
  BCSketchFileMigratorBadToURL,
  BCSketchFileMigratorFileAlreadyMigrated,
  BCSketchFileMigratorFileTooNew,
  BCSketchFileMigratorFailedToValidateInputFile,
  BCSketchFileMigratorFailedToReadInputFile,
  BCSketchFileMigratorFailedToWriteOutputFile,
  BCSketchFileMigratorXPCInterrupted,
}

interface IBCSketchFileMigrator {
  validateDocumentAtBookmark_withReply(bookmark: NSData, reply: Block): void;
  migrateDocumentAtBookmark_intoFolderAtBookmark_withReply(fromBookmark: NSData, toBookmark: NSData, reply: Block): void;
  migrateResourcesNamed_inFolderAtBookmark_withReply(names: NSArray<any> | any[], bookmark: NSData, reply: Block): void;
}

interface SMKArtboardRequestAllocator<InitializedType = SMKArtboardRequest> extends NSObjectAllocator<SMKArtboardRequest> {
  initWithArtboardID_rect_additive_constrainedToSize_scale_type(artboardID: SCKObjectID, rect: CGRect, additive: boolean, constrainingSize: CGSize, scale: CGFloat, type: SCKFileImageType): InitializedType;
}
interface SMKArtboardRequest extends NSObject {
  squashableWithRequest(request: SMKArtboardRequest): boolean;
  squashedWithRequest(request: SMKArtboardRequest): SMKArtboardRequest;
  urlWithHost_port_token(host: NSString | string, port: NSUInteger, token: NSString | string): NSURL;

  artboardID(): SCKObjectID;
  rect(): CGRect;
  scale(): CGFloat;
  constrainingSize(): CGSize;
  isConstrained(): boolean;
  isAdditive(): boolean;
  type(): SCKFileImageType;
}
declare const SMKArtboardRequest: {
  alloc(): SMKArtboardRequestAllocator;  requestForArtboardID_atScale_type(artboardID: SCKObjectID, scale: CGFloat, type: SCKFileImageType): SMKArtboardRequest;
  requestForArtboardID_atScale_constrainedToSize_type(artboardID: SCKObjectID, scale: CGFloat, size: CGSize, type: SCKFileImageType): SMKArtboardRequest;
  requestForArtboardID_atScale_constrainedToSize_inRect_type(artboardID: SCKObjectID, scale: CGFloat, size: CGSize, rect: CGRect, type: SCKFileImageType): SMKArtboardRequest;
  requestForArtboardID_atScale_additiveInRect_type(artboardID: SCKObjectID, scale: CGFloat, rect: CGRect, type: SCKFileImageType): SMKArtboardRequest;

}

interface SMKMirrorControllerAllocator<InitializedType = SMKMirrorController> extends NSObjectAllocator<SMKMirrorController> {}
interface SMKMirrorController extends NSObject {
  disconnect(): void;
  performArtboardRequest_handler(request: SMKArtboardRequest, handler: Block): void;
  performURLRequest_completionHandler(request: NSURLRequest, completionHandler: Block): void;
  connect(client: SMKMirrorClient): void;
  disconnect(client: SMKMirrorClient): void;
  continueUserActivity(userActivity: NSUserActivity): void;
  whitelistClientAdvertisementID(advertisementID: NSUUID): void;
  isClientWhitelisted(client: SMKMirrorClient): boolean;
  invalidateContent(): void;
  invalidateCurrentArtboard(): void;
  invalidateImageForArtboardIdentifier_inRect(identifier: NSString | string, rect: CGRect): void;

  connectionStatus(): SMKConnectionStatus;
  connectionType(): SMKConnectionType;
  serverName(): NSString;
  canDisconnect(): boolean;
  document(): SCKDocument;
  setDocument(document: SCKDocument): void;
  currentArtboardID(): SCKObjectID;
  setCurrentArtboardID(currentArtboardID: SCKObjectID): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  usbEnabled(): boolean;
  webEnabled(): boolean;
  netserviceEnabled(): boolean;
  clients(): NSArray<any>;
  hasConnectedClients(): boolean;
  webURL(): NSURL;
  dataSource(): any;
  setDataSource(dataSource: any): void;
}
declare const SMKMirrorController: {
  alloc(): SMKMirrorControllerAllocator;
}

interface SMKUSBConnectionAllocator<InitializedType = SMKUSBConnection> extends SMKConnectionAllocator<SMKUSBConnection> {}
interface SMKUSBConnection extends SMKConnection {
}
declare const SMKUSBConnection: {
  alloc(): SMKUSBConnectionAllocator;
}

interface SMKWebConnectionAllocator<InitializedType = SMKWebConnection> extends SMKConnectionAllocator<SMKWebConnection> {
  initWithAdvertisement(advertisement: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKWebConnection extends SMKConnection {
  destroy(): void;

  advertisement(): NSDictionary<any, any>;
  setAdvertisement(advertisement: NSDictionary<any, any> | {[key: string]: any}): void;
  advertising(): boolean;
  setAdvertising(advertising: boolean): void;
}
declare const SMKWebConnection: {
  alloc(): SMKWebConnectionAllocator;
}

interface ISMKCommunicationInterface {
  startUsingOptions_webPort(options: SMKCommunicationOptions, port: NSUInteger): void;
  connectionInfoWithReply(reply: Block): void;
  connect(connectionID: NSUUID): void;
  disconnect(connectionID: NSUUID): void;
  broadcastData(data: NSData): void;
  sendData_to(data: NSData, connectionID: NSUUID): void;
}

declare enum SMKCommunicationOptions {
  SMKCommunicationOptionsNone = 0,
  SMKCommunicationOptionsDisableUSB = 1 << 0,
  SMKCommunicationOptionsDisableWeb = 1 << 1,
  SMKCommunicationOptionsDisableNetService = 1 << 2,
}

interface SMKServerControllerAllocator<InitializedType = SMKServerController> extends NSObjectAllocator<SMKServerController> {}
interface SMKServerController extends NSObject {

  connections(): NSArray<any>;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const SMKServerController: {
  alloc(): SMKServerControllerAllocator;
}

interface ISMKServerControllerDelegate {
  serverController_connectionsDidChange(controller: SMKServerController, connections: NSArray<any> | any[]): void;
}

interface SMKUSBServerConnectionAllocator<InitializedType = SMKUSBServerConnection> extends SMKConnectionAllocator<SMKUSBServerConnection> {
  initWithDeviceID(deviceID: NSNumber | number): InitializedType;
}
interface SMKUSBServerConnection extends SMKConnection {

  deviceID(): NSNumber;
}
declare const SMKUSBServerConnection: {
  alloc(): SMKUSBServerConnectionAllocator;
}

interface SMKUSBServerControllerAllocator<InitializedType = SMKUSBServerController> extends SMKServerControllerAllocator<SMKUSBServerController> {}
interface SMKUSBServerController extends SMKServerController {
}
declare const SMKUSBServerController: {
  alloc(): SMKUSBServerControllerAllocator;
}

interface SMKWebServerControllerAllocator<InitializedType = SMKWebServerController> extends SMKServerControllerAllocator<SMKWebServerController> {
  initWithServerPort(port: NSUInteger): InitializedType;
}
interface SMKWebServerController extends SMKServerController {
}
declare const SMKWebServerController: {
  alloc(): SMKWebServerControllerAllocator;
}

interface ISMKCommunicationResponseInterface {
  connectionInfoDidChange(info: NSArray<any> | any[]): void;
  connectionStatusDidChange(info: SMKConnectionInfo): void;
  connectionAdvertisementDidChange(info: SMKConnectionInfo): void;
  connectionInfo_didReceiveData(info: SMKConnectionInfo, data: NSData): void;
}

interface SMKMirrorClientAllocator<InitializedType = SMKMirrorClient> extends NSObjectAllocator<SMKMirrorClient> {}
interface SMKMirrorClient extends NSObject {

  connectionID(): NSUUID;
  setConnectionID(connectionID: NSUUID): void;
  advertisement(): SMKAdvertisement;
  setAdvertisement(advertisement: SMKAdvertisement): void;
  status(): SMKConnectionStatus;
  setStatus(status: SMKConnectionStatus): void;
  type(): SMKConnectionType;
  setType(type: SMKConnectionType): void;
}
declare const SMKMirrorClient: {
  alloc(): SMKMirrorClientAllocator;  clientWithConnectionInfo(connectionInfo: SMKConnectionInfo): SMKMirrorClient;

}

interface ISMKMirrorControllerDelegate {
  mirrorController_didChangeClients(controller: SMKMirrorController, clients: NSArray<any> | any[] | null): void;
  mirrorController_didChangeWebURL(controller: SMKMirrorController, url: NSURL | null): void;
}

interface ISMKMirrorDataSource {

  currentArtboardID(): NSString;
  manifestContent(): NSDictionary<any, any>;
}

interface SMKWebServerAllocator<InitializedType = SMKWebServer> extends NSObjectAllocator<SMKWebServer> {}
interface SMKWebServer extends NSObject {
  start(): void;
  stop(): void;
  authorizeAdvertisementID(connectionID: NSUUID): NSString;
  tokenForAdvertisementID(connectionID: NSUUID): NSString;
  deauthorizeAdvertisementID(connectionID: NSUUID): void;
  invalidateArtboardID(artboardID: NSString | string): void;
  invalidateAllArtboards(): void;
  dataForExportRequest(requestURL: NSURL): NSData;

  URL(): NSURL;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  port(): NSUInteger;
}
declare const SMKWebServer: {
  alloc(): SMKWebServerAllocator;
}

interface ISMKWebServerDataSource {
  renderExportForRequest_handler(requestURL: NSURL, handler: Block): void;
}

interface SMKAdvertisementAllocator<InitializedType = SMKAdvertisement> extends NSObjectAllocator<SMKAdvertisement> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKAdvertisement extends NSObject, INSCopying, INSSecureCoding {

  dictionaryRepresentation(): NSDictionary<any, any>;
  identifier(): NSUUID;
  setIdentifier(identifier: NSUUID): void;
  name(): NSString;
  setName(name: NSString | string): void;
  modelName(): NSString;
  setModelName(modelName: NSString | string): void;
}
declare const SMKAdvertisement: {
  alloc(): SMKAdvertisementAllocator;
}

interface SMKConnectionAllocator<InitializedType = SMKConnection> extends NSObjectAllocator<SMKConnection> {}
interface SMKConnection extends NSObject {
  connect(): void;
  close(): void;
  sendData(data: NSData): void;
  didReceiveData(data: NSData): void;

  UUID(): NSUUID;
  error(): NSError;
  queue(): dispatch_queue_t;
  advertisement(): NSDictionary<any, any>;
  status(): NSUInteger;
  setStatus(status: NSUInteger): void;
  connectionInfo(): SMKConnectionInfo;
  connectionType(): NSUInteger;
  resourceHost(): NSString;
}
declare const SMKConnection: {
  alloc(): SMKConnectionAllocator;
}

interface SMKConnectionInfoAllocator<InitializedType = SMKConnectionInfo> extends NSObjectAllocator<SMKConnectionInfo> {}
interface SMKConnectionInfo extends NSObject, INSSecureCoding {
  compareConnectionInfo(info: SMKConnectionInfo): NSComparisonResult;

  UUID(): NSUUID;
  setUUID(UUID: NSUUID): void;
  status(): SMKConnectionStatus;
  setStatus(status: SMKConnectionStatus): void;
  type(): SMKConnectionType;
  setType(type: SMKConnectionType): void;
  advertisement(): NSDictionary<any, any>;
  setAdvertisement(advertisement: NSDictionary<any, any> | {[key: string]: any}): void;
  hidden(): boolean;
}
declare const SMKConnectionInfo: {
  alloc(): SMKConnectionInfoAllocator;
}

declare enum SMKConnectionStatus {
  SMKConnectionStatusDestroyed,
  SMKConnectionStatusClosed,
  SMKConnectionStatusOpening,
  SMKConnectionStatusOpen,
}

declare enum SMKConnectionType {
  SMKConnectionTypeUSB,
  SMKConnectionTypeBonjour,
  SMKConnectionTypeWeb,
}

declare enum SMKErrorCode {
  SMKConnectionNotEstablishedErrorCode = 2000,
  SMKConnectionDidBecomeCorruptErrorCode = 2001,
  SMKConnectionDidReceiveInvalidDataErrorCode = 2002,
  SMKConnectionCouldNotArchiveObjectErrorCode = 2003,
  SMKConnectionDidTimeoutErrorCode = 2004,
  SMKImageUpdateDataNotAvailableErrorCode = 2005,
}

interface SMKMessageAllocator<InitializedType = SMKMessage> extends NSObjectAllocator<SMKMessage> {
  initWithType(type: NSString | string): InitializedType;
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKMessage extends NSObject, ISMKMessageCoding {

  type(): NSString;
  setType(type: NSString | string): void;
  contentClass(): any;
  content(): any;
  setContent(content: any): void;
  messageData(): NSData;
}
declare const SMKMessage: {
  alloc(): SMKMessageAllocator;  messageFromData(data: NSData): SMKMessage;

}

interface SMKManifestMessageContentAllocator<InitializedType = SMKManifestMessageContent> extends NSObjectAllocator<SMKManifestMessageContent> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKManifestMessageContent extends NSObject, ISMKMessageCoding {

  manifest(): NSDictionary<any, any>;
  setManifest(manifest: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const SMKManifestMessageContent: {
  alloc(): SMKManifestMessageContentAllocator;
}

interface SMKArtboardMessageContentAllocator<InitializedType = SMKArtboardMessageContent> extends NSObjectAllocator<SMKArtboardMessageContent> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKArtboardMessageContent extends NSObject, ISMKMessageCoding {

  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  rect(): CGRect;
  setRect(rect: CGRect): void;
  constrainingSize(): CGSize;
  setConstrainingSize(constrainingSize: CGSize): void;
}
declare const SMKArtboardMessageContent: {
  alloc(): SMKArtboardMessageContentAllocator;
}

interface SMKConnectionMessageContentAllocator<InitializedType = SMKConnectionMessageContent> extends NSObjectAllocator<SMKConnectionMessageContent> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKConnectionMessageContent extends NSObject, ISMKMessageCoding {

  token(): NSString;
  setToken(token: NSString | string): void;
  device(): NSString;
  setDevice(device: NSString | string): void;
  serverPort(): NSUInteger;
  setServerPort(serverPort: NSUInteger): void;
  serverName(): NSString;
  setServerName(serverName: NSString | string): void;
  supportsURLRequests(): boolean;
  setSupportsURLRequests(supportsURLRequests: boolean): void;
}
declare const SMKConnectionMessageContent: {
  alloc(): SMKConnectionMessageContentAllocator;
}

interface SMKAdvertisementMessageContentAllocator<InitializedType = SMKAdvertisementMessageContent> extends NSObjectAllocator<SMKAdvertisementMessageContent> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface SMKAdvertisementMessageContent extends NSObject, ISMKMessageCoding {

  advertisement(): SMKAdvertisement;
  setAdvertisement(advertisement: SMKAdvertisement): void;
  challenge(): NSString;
  setChallenge(challenge: NSString | string): void;
}
declare const SMKAdvertisementMessageContent: {
  alloc(): SMKAdvertisementMessageContentAllocator;
}

interface ISMKMessageCoding {

  dictionaryRepresentation(): NSDictionary<any, any>;
}

interface SMKURLResponseAllocator<InitializedType = SMKURLResponse> extends NSObjectAllocator<SMKURLResponse> {}
interface SMKURLResponse extends NSObject, INSSecureCoding {

  request(): NSURLRequest;
  setRequest(request: NSURLRequest): void;
  response(): NSURLResponse;
  setResponse(response: NSURLResponse): void;
  data(): NSData;
  setData(data: NSData): void;
  error(): NSError;
  setError(error: NSError): void;
}
declare const SMKURLResponse: {
  alloc(): SMKURLResponseAllocator;
}

interface SMKUSBHTTPResponseAllocator<InitializedType = SMKUSBHTTPResponse> extends SMKURLResponseAllocator<SMKUSBHTTPResponse> {}
interface SMKUSBHTTPResponse extends SMKURLResponse {
}
declare const SMKUSBHTTPResponse: {
  alloc(): SMKUSBHTTPResponseAllocator;
}

interface BCStructuredFileAllocator<InitializedType = BCStructuredFile> extends NSObjectAllocator<BCStructuredFile> {
  initWithURL_error(url: NSURL, error: NSError): InitializedType;
}
interface BCStructuredFile extends NSObject {
  metadata(): NSDictionary<any, any>;
  metaDataWithKey(key: NSString | string): any;
  dataWithKey_error(key: NSString | string, error: NSError): NSData;
  close(error: NSError): boolean;
}
declare const BCStructuredFile: {
  alloc(): BCStructuredFileAllocator;
}

declare enum BCStructuredFileErrorCode {
  BCStructuredFileUnknownError,
  BCStructuredFileInvalidURL,
  BCStructuredFileErrorClosed,
}

declare enum BCTextBehaviourType {
  BCTextBehaviourFlexibleWidth,
  BCTextBehaviourFixedWidth,
  BCTextBehaviourFixedWidthAndHeight,
}

declare enum BCTextLineSpacingBehaviourType {
  BCTextLineSpacingBehaviourUnknown = -1,
  BCTextLineSpacingBehaviourV1 = 0,
  BCTextLineSpacingBehaviourV2 = 1,
  BCTextLineSpacingBehaviourV3 = 2,
  BCTextLineSpacingBehaviourCurrent,
  BCTextLineSpacingBehaviourDefault,
}

declare enum MSTextStyleVerticalAlignment {
  MSTextStyleVerticalAlignmentTop = 0,
  MSTextStyleVerticalAlignmentMiddle = 1,
  MSTextStyleVerticalAlignmentBottom = 2,
  MSTextStyleVerticalAlignmentDefault,
}

interface _MSArtboardGroupAllocator<InitializedType = _MSArtboardGroup> extends MSLayerGroupAllocator<_MSArtboardGroup> {}
interface _MSArtboardGroup extends MSLayerGroup {

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
  includeBackgroundColorInExport(): boolean;
  setIncludeBackgroundColorInExport(includeBackgroundColorInExport: boolean): void;
  includeInCloudUpload(): boolean;
  setIncludeInCloudUpload(includeInCloudUpload: boolean): void;
  isFlowHome(): boolean;
  setIsFlowHome(isFlowHome: boolean): void;
  presetDictionary(): NSDictionary<any, any>;
  setPresetDictionary(presetDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  resizesContent(): boolean;
  setResizesContent(resizesContent: boolean): void;
  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  horizontalRulerData(): MSRulerData;
  setHorizontalRulerData(horizontalRulerData: MSRulerData): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  verticalRulerData(): MSRulerData;
  setVerticalRulerData(verticalRulerData: MSRulerData): void;
}
declare const _MSArtboardGroup: {
  alloc(): _MSArtboardGroupAllocator;
}

interface _MSAssetCollectionAllocator<InitializedType = _MSAssetCollection> extends MSModelObjectAllocator<_MSAssetCollection> {}
interface _MSAssetCollection extends MSModelObject {
  addColor(value: MSColor): void;
  addColors(colors: NSArray<any> | any[]): void;
  insertColor_atIndex(value: MSColor, index: NSUInteger): void;
  insertColor_beforeColor(value: MSColor, after: MSColor | null): void;
  insertColors_beforeColor(values: NSArray<any> | any[], before: MSColor | null): void;
  insertColor_afterColor(value: MSColor, after: MSColor | null): void;
  insertColors_afterColor(values: NSArray<any> | any[], after: MSColor | null): void;
  removeColor(value: MSColor): void;
  removeColorAtIndex(index: NSUInteger): void;
  removeColorsAtIndexes(indexes: NSIndexSet): void;
  removeAllColors(): void;
  moveColorIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addExportPreset(value: MSExportPreset): void;
  addExportPresets(exportPresets: NSArray<any> | any[]): void;
  insertExportPreset_atIndex(value: MSExportPreset, index: NSUInteger): void;
  insertExportPreset_beforeExportPreset(value: MSExportPreset, after: MSExportPreset | null): void;
  insertExportPresets_beforeExportPreset(values: NSArray<any> | any[], before: MSExportPreset | null): void;
  insertExportPreset_afterExportPreset(value: MSExportPreset, after: MSExportPreset | null): void;
  insertExportPresets_afterExportPreset(values: NSArray<any> | any[], after: MSExportPreset | null): void;
  removeExportPreset(value: MSExportPreset): void;
  removeExportPresetAtIndex(index: NSUInteger): void;
  removeExportPresetsAtIndexes(indexes: NSIndexSet): void;
  removeAllExportPresets(): void;
  moveExportPresetIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addGradient(value: MSGradient): void;
  addGradients(gradients: NSArray<any> | any[]): void;
  insertGradient_atIndex(value: MSGradient, index: NSUInteger): void;
  insertGradient_beforeGradient(value: MSGradient, after: MSGradient | null): void;
  insertGradients_beforeGradient(values: NSArray<any> | any[], before: MSGradient | null): void;
  insertGradient_afterGradient(value: MSGradient, after: MSGradient | null): void;
  insertGradients_afterGradient(values: NSArray<any> | any[], after: MSGradient | null): void;
  removeGradient(value: MSGradient): void;
  removeGradientAtIndex(index: NSUInteger): void;
  removeGradientsAtIndexes(indexes: NSIndexSet): void;
  removeAllGradients(): void;
  moveGradientIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  images(): NSArray<any>;
  setImages(images: NSArray<any> | any[]): void;
  colors(): NSArray<any>;
  setColors(colors: NSArray<any> | any[]): void;
  exportPresets(): NSArray<any>;
  setExportPresets(exportPresets: NSArray<any> | any[]): void;
  gradients(): NSArray<any>;
  setGradients(gradients: NSArray<any> | any[]): void;
  imageCollection(): MSImageCollection;
  setImageCollection(imageCollection: MSImageCollection): void;
}
declare const _MSAssetCollection: {
  alloc(): _MSAssetCollectionAllocator;
}

interface _MSBaseGridAllocator<InitializedType = _MSBaseGrid> extends MSModelObjectAllocator<_MSBaseGrid> {}
interface _MSBaseGrid extends MSModelObject {

  isEnabled(): boolean;
  setIsEnabled(isEnabled: boolean): void;
}
declare const _MSBaseGrid: {
  alloc(): _MSBaseGridAllocator;
}

interface _MSBitmapLayerAllocator<InitializedType = _MSBitmapLayer> extends MSStyledLayerAllocator<_MSBitmapLayer> {}
interface _MSBitmapLayer extends MSStyledLayer {

  clippingMask(): NSRect;
  setClippingMask(clippingMask: NSRect): void;
  fillReplacesImage(): boolean;
  setFillReplacesImage(fillReplacesImage: boolean): void;
  image(): MSImageData;
  setImage(image: MSImageData): void;
  intendedDPI(): NSInteger;
  setIntendedDPI(intendedDPI: NSInteger): void;
}
declare const _MSBitmapLayer: {
  alloc(): _MSBitmapLayerAllocator;
}

interface _MSColorAllocator<InitializedType = _MSColor> extends MSModelObjectAllocator<_MSColor> {}
interface _MSColor extends MSModelObject {

  alpha(): CGFloat;
  blue(): CGFloat;
  green(): CGFloat;
  red(): CGFloat;
}
declare const _MSColor: {
  alloc(): _MSColorAllocator;
}

interface _MSCurvePointAllocator<InitializedType = _MSCurvePoint> extends MSModelObjectAllocator<_MSCurvePoint> {}
interface _MSCurvePoint extends MSModelObject {

  cornerRadius(): CGFloat;
  setCornerRadius(cornerRadius: CGFloat): void;
  curveFrom(): NSPoint;
  setCurveFrom(curveFrom: NSPoint): void;
  curveMode(): MSCurveMode;
  setCurveMode(curveMode: MSCurveMode): void;
  curveTo(): NSPoint;
  setCurveTo(curveTo: NSPoint): void;
  hasCurveFrom(): boolean;
  setHasCurveFrom(hasCurveFrom: boolean): void;
  hasCurveTo(): boolean;
  setHasCurveTo(hasCurveTo: boolean): void;
  point(): NSPoint;
  setPoint(point: NSPoint): void;
}
declare const _MSCurvePoint: {
  alloc(): _MSCurvePointAllocator;
}

interface _MSDocumentDataAllocator<InitializedType = _MSDocumentData> extends MSModelObjectAllocator<_MSDocumentData> {}
interface _MSDocumentData extends MSModelObject {
  addForeignLayerStyle(value: MSForeignLayerStyle): void;
  addForeignLayerStyles(foreignLayerStyles: NSArray<any> | any[]): void;
  insertForeignLayerStyle_atIndex(value: MSForeignLayerStyle, index: NSUInteger): void;
  insertForeignLayerStyle_beforeForeignLayerStyle(value: MSForeignLayerStyle, after: MSForeignLayerStyle | null): void;
  insertForeignLayerStyles_beforeForeignLayerStyle(values: NSArray<any> | any[], before: MSForeignLayerStyle | null): void;
  insertForeignLayerStyle_afterForeignLayerStyle(value: MSForeignLayerStyle, after: MSForeignLayerStyle | null): void;
  insertForeignLayerStyles_afterForeignLayerStyle(values: NSArray<any> | any[], after: MSForeignLayerStyle | null): void;
  removeForeignLayerStyle(value: MSForeignLayerStyle): void;
  removeForeignLayerStyleAtIndex(index: NSUInteger): void;
  removeForeignLayerStylesAtIndexes(indexes: NSIndexSet): void;
  removeAllForeignLayerStyles(): void;
  moveForeignLayerStyleIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addForeignSymbol(value: MSForeignSymbol): void;
  addForeignSymbols(foreignSymbols: NSArray<any> | any[]): void;
  insertForeignSymbol_atIndex(value: MSForeignSymbol, index: NSUInteger): void;
  insertForeignSymbol_beforeForeignSymbol(value: MSForeignSymbol, after: MSForeignSymbol | null): void;
  insertForeignSymbols_beforeForeignSymbol(values: NSArray<any> | any[], before: MSForeignSymbol | null): void;
  insertForeignSymbol_afterForeignSymbol(value: MSForeignSymbol, after: MSForeignSymbol | null): void;
  insertForeignSymbols_afterForeignSymbol(values: NSArray<any> | any[], after: MSForeignSymbol | null): void;
  removeForeignSymbol(value: MSForeignSymbol): void;
  removeForeignSymbolAtIndex(index: NSUInteger): void;
  removeForeignSymbolsAtIndexes(indexes: NSIndexSet): void;
  removeAllForeignSymbols(): void;
  moveForeignSymbolIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addForeignTextStyle(value: MSForeignTextStyle): void;
  addForeignTextStyles(foreignTextStyles: NSArray<any> | any[]): void;
  insertForeignTextStyle_atIndex(value: MSForeignTextStyle, index: NSUInteger): void;
  insertForeignTextStyle_beforeForeignTextStyle(value: MSForeignTextStyle, after: MSForeignTextStyle | null): void;
  insertForeignTextStyles_beforeForeignTextStyle(values: NSArray<any> | any[], before: MSForeignTextStyle | null): void;
  insertForeignTextStyle_afterForeignTextStyle(value: MSForeignTextStyle, after: MSForeignTextStyle | null): void;
  insertForeignTextStyles_afterForeignTextStyle(values: NSArray<any> | any[], after: MSForeignTextStyle | null): void;
  removeForeignTextStyle(value: MSForeignTextStyle): void;
  removeForeignTextStyleAtIndex(index: NSUInteger): void;
  removeForeignTextStylesAtIndexes(indexes: NSIndexSet): void;
  removeAllForeignTextStyles(): void;
  moveForeignTextStyleIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addPage(value: MSPage): void;
  addPages(pages: NSArray<any> | any[]): void;
  insertPage_atIndex(value: MSPage, index: NSUInteger): void;
  insertPage_beforePage(value: MSPage, after: MSPage | null): void;
  insertPages_beforePage(values: NSArray<any> | any[], before: MSPage | null): void;
  insertPage_afterPage(value: MSPage, after: MSPage | null): void;
  insertPages_afterPage(values: NSArray<any> | any[], after: MSPage | null): void;
  removePage(value: MSPage): void;
  removePageAtIndex(index: NSUInteger): void;
  removePagesAtIndexes(indexes: NSIndexSet): void;
  removeAllPages(): void;
  movePageIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  colorSpace(): MSColorSpace;
  setColorSpace(colorSpace: MSColorSpace): void;
  currentPageIndex(): NSUInteger;
  setCurrentPageIndex(currentPageIndex: NSUInteger): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  assets(): MSAssetCollection;
  setAssets(assets: MSAssetCollection): void;
  foreignLayerStyles(): NSArray<any>;
  setForeignLayerStyles(foreignLayerStyles: NSArray<any> | any[]): void;
  foreignSymbols(): NSArray<any>;
  setForeignSymbols(foreignSymbols: NSArray<any> | any[]): void;
  foreignTextStyles(): NSArray<any>;
  setForeignTextStyles(foreignTextStyles: NSArray<any> | any[]): void;
  layerStyles(): MSSharedStyleContainer;
  setLayerStyles(layerStyles: MSSharedStyleContainer): void;
  layerSymbols(): MSSymbolContainer;
  setLayerSymbols(layerSymbols: MSSymbolContainer): void;
  layerTextStyles(): MSSharedTextStyleContainer;
  setLayerTextStyles(layerTextStyles: MSSharedTextStyleContainer): void;
  pages(): NSArray<any>;
  setPages(pages: NSArray<any> | any[]): void;
}
declare const _MSDocumentData: {
  alloc(): _MSDocumentDataAllocator;
}

interface _MSExportFormatAllocator<InitializedType = _MSExportFormat> extends MSModelObjectAllocator<_MSExportFormat> {}
interface _MSExportFormat extends MSModelObject {

  absoluteSize(): CGFloat;
  setAbsoluteSize(absoluteSize: CGFloat): void;
  fileFormat(): NSString;
  setFileFormat(fileFormat: NSString | string): void;
  name(): NSString;
  setName(name: NSString | string): void;
  namingScheme(): MSExportFormatNamingScheme;
  setNamingScheme(namingScheme: MSExportFormatNamingScheme): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  visibleScaleType(): MSUserVisibleScaleType;
  setVisibleScaleType(visibleScaleType: MSUserVisibleScaleType): void;
}
declare const _MSExportFormat: {
  alloc(): _MSExportFormatAllocator;
}

interface _MSExportOptionsAllocator<InitializedType = _MSExportOptions> extends MSModelObjectAllocator<_MSExportOptions> {}
interface _MSExportOptions extends MSModelObject {
  addExportFormat(value: MSExportFormat): void;
  addExportFormats(exportFormats: NSArray<any> | any[]): void;
  insertExportFormat_atIndex(value: MSExportFormat, index: NSUInteger): void;
  insertExportFormat_beforeExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_beforeExportFormat(values: NSArray<any> | any[], before: MSExportFormat | null): void;
  insertExportFormat_afterExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_afterExportFormat(values: NSArray<any> | any[], after: MSExportFormat | null): void;
  removeExportFormat(value: MSExportFormat): void;
  removeExportFormatAtIndex(index: NSUInteger): void;
  removeExportFormatsAtIndexes(indexes: NSIndexSet): void;
  removeAllExportFormats(): void;
  moveExportFormatIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  includedLayerIds(): NSArray<any>;
  setIncludedLayerIds(includedLayerIds: NSArray<any> | any[]): void;
  layerOptions(): MSExportLayerOptions;
  setLayerOptions(layerOptions: MSExportLayerOptions): void;
  shouldTrim(): boolean;
  setShouldTrim(shouldTrim: boolean): void;
  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
}
declare const _MSExportOptions: {
  alloc(): _MSExportOptionsAllocator;
}

interface _MSExportPresetAllocator<InitializedType = _MSExportPreset> extends MSModelObjectAllocator<_MSExportPreset> {}
interface _MSExportPreset extends MSModelObject {
  addExportFormat(value: MSExportFormat): void;
  addExportFormats(exportFormats: NSArray<any> | any[]): void;
  insertExportFormat_atIndex(value: MSExportFormat, index: NSUInteger): void;
  insertExportFormat_beforeExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_beforeExportFormat(values: NSArray<any> | any[], before: MSExportFormat | null): void;
  insertExportFormat_afterExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_afterExportFormat(values: NSArray<any> | any[], after: MSExportFormat | null): void;
  removeExportFormat(value: MSExportFormat): void;
  removeExportFormatAtIndex(index: NSUInteger): void;
  removeExportFormatsAtIndexes(indexes: NSIndexSet): void;
  removeAllExportFormats(): void;
  moveExportFormatIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  name(): NSString;
  setName(name: NSString | string): void;
  shouldApplyAutomatically(): boolean;
  setShouldApplyAutomatically(shouldApplyAutomatically: boolean): void;
  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
}
declare const _MSExportPreset: {
  alloc(): _MSExportPresetAllocator;
}

interface _MSFlowConnectionAllocator<InitializedType = _MSFlowConnection> extends MSModelObjectAllocator<_MSFlowConnection> {}
interface _MSFlowConnection extends MSModelObject {

  animationType(): NSInteger;
  setAnimationType(animationType: NSInteger): void;
  destinationArtboardID(): NSString;
  setDestinationArtboardID(destinationArtboardID: NSString | string): void;
}
declare const _MSFlowConnection: {
  alloc(): _MSFlowConnectionAllocator;
}

interface _MSForeignLayerStyleAllocator<InitializedType = _MSForeignLayerStyle> extends MSForeignStyleAllocator<_MSForeignLayerStyle> {}
interface _MSForeignLayerStyle extends MSForeignStyle {
}
declare const _MSForeignLayerStyle: {
  alloc(): _MSForeignLayerStyleAllocator;
}

interface _MSForeignObjectAllocator<InitializedType = _MSForeignObject> extends MSModelObjectAllocator<_MSForeignObject> {}
interface _MSForeignObject extends MSModelObject {

  libraryID(): NSString;
  setLibraryID(libraryID: NSString | string): void;
  sourceLibraryName(): NSString;
  setSourceLibraryName(sourceLibraryName: NSString | string): void;
}
declare const _MSForeignObject: {
  alloc(): _MSForeignObjectAllocator;
}

interface _MSForeignStyleAllocator<InitializedType = _MSForeignStyle> extends MSForeignObjectAllocator<_MSForeignStyle> {}
interface _MSForeignStyle extends MSForeignObject {

  remoteStyleID(): NSString;
  setRemoteStyleID(remoteStyleID: NSString | string): void;
  localSharedStyle(): MSSharedStyle;
  setLocalSharedStyle(localSharedStyle: MSSharedStyle): void;
}
declare const _MSForeignStyle: {
  alloc(): _MSForeignStyleAllocator;
}

interface _MSForeignSymbolAllocator<InitializedType = _MSForeignSymbol> extends MSForeignObjectAllocator<_MSForeignSymbol> {}
interface _MSForeignSymbol extends MSForeignObject {

  originalMaster(): MSSymbolMaster;
  setOriginalMaster(originalMaster: MSSymbolMaster): void;
  symbolMaster(): MSSymbolMaster;
  setSymbolMaster(symbolMaster: MSSymbolMaster): void;
}
declare const _MSForeignSymbol: {
  alloc(): _MSForeignSymbolAllocator;
}

interface _MSForeignTextStyleAllocator<InitializedType = _MSForeignTextStyle> extends MSForeignStyleAllocator<_MSForeignTextStyle> {}
interface _MSForeignTextStyle extends MSForeignStyle {
}
declare const _MSForeignTextStyle: {
  alloc(): _MSForeignTextStyleAllocator;
}

interface _MSGradientAllocator<InitializedType = _MSGradient> extends MSModelObjectAllocator<_MSGradient> {}
interface _MSGradient extends MSModelObject {
  addGradientStop(value: MSGradientStop): void;
  addGradientStops(stops: NSArray<any> | any[]): void;
  insertGradientStop_atIndex(value: MSGradientStop, index: NSUInteger): void;
  insertGradientStop_beforeGradientStop(value: MSGradientStop, after: MSGradientStop | null): void;
  insertGradientStops_beforeGradientStop(values: NSArray<any> | any[], before: MSGradientStop | null): void;
  insertGradientStop_afterGradientStop(value: MSGradientStop, after: MSGradientStop | null): void;
  insertGradientStops_afterGradientStop(values: NSArray<any> | any[], after: MSGradientStop | null): void;
  removeGradientStop(value: MSGradientStop): void;
  removeGradientStopAtIndex(index: NSUInteger): void;
  removeGradientStopsAtIndexes(indexes: NSIndexSet): void;
  removeAllGradientStops(): void;
  moveGradientStopIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  elipseLength(): CGFloat;
  setElipseLength(elipseLength: CGFloat): void;
  from(): NSPoint;
  setFrom(from: NSPoint): void;
  gradientType(): MSGradientType;
  setGradientType(gradientType: MSGradientType): void;
  to(): NSPoint;
  setTo(to: NSPoint): void;
  stops(): NSArray<any>;
  setStops(stops: NSArray<any> | any[]): void;
}
declare const _MSGradient: {
  alloc(): _MSGradientAllocator;
}

interface _MSGradientStopAllocator<InitializedType = _MSGradientStop> extends MSModelObjectAllocator<_MSGradientStop> {}
interface _MSGradientStop extends MSModelObject {

  position(): CGFloat;
  setPosition(position: CGFloat): void;
  color(): MSColor;
  setColor(color: MSColor): void;
}
declare const _MSGradientStop: {
  alloc(): _MSGradientStopAllocator;
}

interface _MSGraphicsContextSettingsAllocator<InitializedType = _MSGraphicsContextSettings> extends MSModelObjectAllocator<_MSGraphicsContextSettings> {}
interface _MSGraphicsContextSettings extends MSModelObject {

  blendMode(): MSBlendMode;
  setBlendMode(blendMode: MSBlendMode): void;
  opacity(): CGFloat;
  setOpacity(opacity: CGFloat): void;
}
declare const _MSGraphicsContextSettings: {
  alloc(): _MSGraphicsContextSettingsAllocator;
}

interface _MSHotspotLayerAllocator<InitializedType = _MSHotspotLayer> extends MSLayerAllocator<_MSHotspotLayer> {}
interface _MSHotspotLayer extends MSLayer {
}
declare const _MSHotspotLayer: {
  alloc(): _MSHotspotLayerAllocator;
}

interface _MSImageCollectionAllocator<InitializedType = _MSImageCollection> extends MSModelObjectAllocator<_MSImageCollection> {}
interface _MSImageCollection extends MSModelObject {

  images(): NSDictionary<any, any>;
  setImages(images: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const _MSImageCollection: {
  alloc(): _MSImageCollectionAllocator;
}

interface _MSImmutableArtboardGroupAllocator<InitializedType = _MSImmutableArtboardGroup> extends MSImmutableLayerGroupAllocator<_MSImmutableArtboardGroup> {}
interface _MSImmutableArtboardGroup extends MSImmutableLayerGroup {

  hasBackgroundColor(): boolean;
  includeBackgroundColorInExport(): boolean;
  includeInCloudUpload(): boolean;
  isFlowHome(): boolean;
  presetDictionary(): NSDictionary<any, any>;
  resizesContent(): boolean;
  backgroundColor(): MSImmutableColor;
  grid(): MSImmutableSimpleGrid;
  horizontalRulerData(): MSImmutableRulerData;
  layout(): MSImmutableLayoutGrid;
  verticalRulerData(): MSImmutableRulerData;
}
declare const _MSImmutableArtboardGroup: {
  alloc(): _MSImmutableArtboardGroupAllocator;
}

interface _MSImmutableAssetCollectionAllocator<InitializedType = _MSImmutableAssetCollection> extends MSImmutableModelObjectAllocator<_MSImmutableAssetCollection> {}
interface _MSImmutableAssetCollection extends MSImmutableModelObject {

  images(): NSArray<any>;
  colors(): NSArray<any>;
  exportPresets(): NSArray<any>;
  gradients(): NSArray<any>;
  imageCollection(): MSImmutableImageCollection;
}
declare const _MSImmutableAssetCollection: {
  alloc(): _MSImmutableAssetCollectionAllocator;
}

interface _MSImmutableBaseGridAllocator<InitializedType = _MSImmutableBaseGrid> extends MSImmutableModelObjectAllocator<_MSImmutableBaseGrid> {}
interface _MSImmutableBaseGrid extends MSImmutableModelObject {

  isEnabled(): boolean;
}
declare const _MSImmutableBaseGrid: {
  alloc(): _MSImmutableBaseGridAllocator;
}

interface _MSImmutableBitmapLayerAllocator<InitializedType = _MSImmutableBitmapLayer> extends MSImmutableStyledLayerAllocator<_MSImmutableBitmapLayer> {}
interface _MSImmutableBitmapLayer extends MSImmutableStyledLayer {

  clippingMask(): NSRect;
  fillReplacesImage(): boolean;
  image(): MSImageData;
  intendedDPI(): NSInteger;
}
declare const _MSImmutableBitmapLayer: {
  alloc(): _MSImmutableBitmapLayerAllocator;
}

interface _MSImmutableColorAllocator<InitializedType = _MSImmutableColor> extends MSImmutableModelObjectAllocator<_MSImmutableColor> {}
interface _MSImmutableColor extends MSImmutableModelObject {

  alpha(): CGFloat;
  blue(): CGFloat;
  green(): CGFloat;
  red(): CGFloat;
}
declare const _MSImmutableColor: {
  alloc(): _MSImmutableColorAllocator;
}

interface _MSImmutableCurvePointAllocator<InitializedType = _MSImmutableCurvePoint> extends MSImmutableModelObjectAllocator<_MSImmutableCurvePoint> {}
interface _MSImmutableCurvePoint extends MSImmutableModelObject {

  cornerRadius(): CGFloat;
  curveFrom(): NSPoint;
  curveMode(): MSCurveMode;
  curveTo(): NSPoint;
  hasCurveFrom(): boolean;
  hasCurveTo(): boolean;
  point(): NSPoint;
}
declare const _MSImmutableCurvePoint: {
  alloc(): _MSImmutableCurvePointAllocator;
}

interface _MSImmutableDocumentDataAllocator<InitializedType = _MSImmutableDocumentData> extends MSImmutableModelObjectAllocator<_MSImmutableDocumentData> {}
interface _MSImmutableDocumentData extends MSImmutableModelObject {

  colorSpace(): MSColorSpace;
  currentPageIndex(): NSUInteger;
  userInfo(): NSDictionary<any, any>;
  assets(): MSImmutableAssetCollection;
  foreignLayerStyles(): NSArray<any>;
  foreignSymbols(): NSArray<any>;
  foreignTextStyles(): NSArray<any>;
  layerStyles(): MSImmutableSharedStyleContainer;
  layerSymbols(): MSImmutableSymbolContainer;
  layerTextStyles(): MSImmutableSharedTextStyleContainer;
  pages(): NSArray<any>;
}
declare const _MSImmutableDocumentData: {
  alloc(): _MSImmutableDocumentDataAllocator;
}

interface _MSImmutableExportFormatAllocator<InitializedType = _MSImmutableExportFormat> extends MSImmutableModelObjectAllocator<_MSImmutableExportFormat> {}
interface _MSImmutableExportFormat extends MSImmutableModelObject {

  absoluteSize(): CGFloat;
  fileFormat(): NSString;
  name(): NSString;
  namingScheme(): MSExportFormatNamingScheme;
  scale(): CGFloat;
  visibleScaleType(): MSUserVisibleScaleType;
}
declare const _MSImmutableExportFormat: {
  alloc(): _MSImmutableExportFormatAllocator;
}

interface _MSImmutableExportOptionsAllocator<InitializedType = _MSImmutableExportOptions> extends MSImmutableModelObjectAllocator<_MSImmutableExportOptions> {}
interface _MSImmutableExportOptions extends MSImmutableModelObject {

  includedLayerIds(): NSArray<any>;
  layerOptions(): MSExportLayerOptions;
  shouldTrim(): boolean;
  exportFormats(): NSArray<any>;
}
declare const _MSImmutableExportOptions: {
  alloc(): _MSImmutableExportOptionsAllocator;
}

interface _MSImmutableExportPresetAllocator<InitializedType = _MSImmutableExportPreset> extends MSImmutableModelObjectAllocator<_MSImmutableExportPreset> {}
interface _MSImmutableExportPreset extends MSImmutableModelObject {

  name(): NSString;
  shouldApplyAutomatically(): boolean;
  exportFormats(): NSArray<any>;
}
declare const _MSImmutableExportPreset: {
  alloc(): _MSImmutableExportPresetAllocator;
}

interface _MSImmutableFlowConnectionAllocator<InitializedType = _MSImmutableFlowConnection> extends MSImmutableModelObjectAllocator<_MSImmutableFlowConnection> {}
interface _MSImmutableFlowConnection extends MSImmutableModelObject {

  animationType(): NSInteger;
  destinationArtboardID(): NSString;
}
declare const _MSImmutableFlowConnection: {
  alloc(): _MSImmutableFlowConnectionAllocator;
}

interface _MSImmutableForeignLayerStyleAllocator<InitializedType = _MSImmutableForeignLayerStyle> extends MSImmutableForeignStyleAllocator<_MSImmutableForeignLayerStyle> {}
interface _MSImmutableForeignLayerStyle extends MSImmutableForeignStyle {
}
declare const _MSImmutableForeignLayerStyle: {
  alloc(): _MSImmutableForeignLayerStyleAllocator;
}

interface _MSImmutableForeignObjectAllocator<InitializedType = _MSImmutableForeignObject> extends MSImmutableModelObjectAllocator<_MSImmutableForeignObject> {}
interface _MSImmutableForeignObject extends MSImmutableModelObject {

  libraryID(): NSString;
  sourceLibraryName(): NSString;
}
declare const _MSImmutableForeignObject: {
  alloc(): _MSImmutableForeignObjectAllocator;
}

interface _MSImmutableForeignStyleAllocator<InitializedType = _MSImmutableForeignStyle> extends MSImmutableForeignObjectAllocator<_MSImmutableForeignStyle> {}
interface _MSImmutableForeignStyle extends MSImmutableForeignObject {

  remoteStyleID(): NSString;
  localSharedStyle(): MSImmutableSharedStyle;
}
declare const _MSImmutableForeignStyle: {
  alloc(): _MSImmutableForeignStyleAllocator;
}

interface _MSImmutableForeignSymbolAllocator<InitializedType = _MSImmutableForeignSymbol> extends MSImmutableForeignObjectAllocator<_MSImmutableForeignSymbol> {}
interface _MSImmutableForeignSymbol extends MSImmutableForeignObject {

  originalMaster(): MSImmutableSymbolMaster;
  symbolMaster(): MSImmutableSymbolMaster;
}
declare const _MSImmutableForeignSymbol: {
  alloc(): _MSImmutableForeignSymbolAllocator;
}

interface _MSImmutableForeignTextStyleAllocator<InitializedType = _MSImmutableForeignTextStyle> extends MSImmutableForeignStyleAllocator<_MSImmutableForeignTextStyle> {}
interface _MSImmutableForeignTextStyle extends MSImmutableForeignStyle {
}
declare const _MSImmutableForeignTextStyle: {
  alloc(): _MSImmutableForeignTextStyleAllocator;
}

interface _MSImmutableGradientAllocator<InitializedType = _MSImmutableGradient> extends MSImmutableModelObjectAllocator<_MSImmutableGradient> {}
interface _MSImmutableGradient extends MSImmutableModelObject {

  elipseLength(): CGFloat;
  from(): NSPoint;
  gradientType(): MSGradientType;
  to(): NSPoint;
  stops(): NSArray<any>;
}
declare const _MSImmutableGradient: {
  alloc(): _MSImmutableGradientAllocator;
}

interface _MSImmutableGradientStopAllocator<InitializedType = _MSImmutableGradientStop> extends MSImmutableModelObjectAllocator<_MSImmutableGradientStop> {}
interface _MSImmutableGradientStop extends MSImmutableModelObject {

  position(): CGFloat;
  color(): MSImmutableColor;
}
declare const _MSImmutableGradientStop: {
  alloc(): _MSImmutableGradientStopAllocator;
}

interface _MSImmutableGraphicsContextSettingsAllocator<InitializedType = _MSImmutableGraphicsContextSettings> extends MSImmutableModelObjectAllocator<_MSImmutableGraphicsContextSettings> {}
interface _MSImmutableGraphicsContextSettings extends MSImmutableModelObject {

  blendMode(): MSBlendMode;
  opacity(): CGFloat;
}
declare const _MSImmutableGraphicsContextSettings: {
  alloc(): _MSImmutableGraphicsContextSettingsAllocator;
}

interface _MSImmutableHotspotLayerAllocator<InitializedType = _MSImmutableHotspotLayer> extends MSImmutableLayerAllocator<_MSImmutableHotspotLayer> {}
interface _MSImmutableHotspotLayer extends MSImmutableLayer {
}
declare const _MSImmutableHotspotLayer: {
  alloc(): _MSImmutableHotspotLayerAllocator;
}

interface _MSImmutableImageCollectionAllocator<InitializedType = _MSImmutableImageCollection> extends MSImmutableModelObjectAllocator<_MSImmutableImageCollection> {}
interface _MSImmutableImageCollection extends MSImmutableModelObject {

  images(): NSDictionary<any, any>;
}
declare const _MSImmutableImageCollection: {
  alloc(): _MSImmutableImageCollectionAllocator;
}

interface _MSImmutableLayerAllocator<InitializedType = _MSImmutableLayer> extends MSImmutableModelObjectAllocator<_MSImmutableLayer> {}
interface _MSImmutableLayer extends MSImmutableModelObject {

  booleanOperation(): MSBooleanOperation;
  isFixedToViewport(): boolean;
  isFlippedHorizontal(): boolean;
  isFlippedVertical(): boolean;
  isLocked(): boolean;
  isVisible(): boolean;
  layerListExpandedType(): MSLayerListStatus;
  name(): NSString;
  nameIsFixed(): boolean;
  originalObjectID(): NSString;
  pathInBounds(): MSPath;
  resizingConstraint(): BCConstraint;
  resizingType(): MSLayerResizingType;
  rotation(): CGFloat;
  shouldBreakMaskChain(): boolean;
  userInfo(): NSDictionary<any, any>;
  exportOptions(): MSImmutableExportOptions;
  flow(): MSImmutableFlowConnection;
  frame(): MSImmutableRect;
}
declare const _MSImmutableLayer: {
  alloc(): _MSImmutableLayerAllocator;
}

interface _MSImmutableLayerGroupAllocator<InitializedType = _MSImmutableLayerGroup> extends MSImmutableStyledLayerAllocator<_MSImmutableLayerGroup> {}
interface _MSImmutableLayerGroup extends MSImmutableStyledLayer {

  hasClickThrough(): boolean;
  sharedObjectID(): NSString;
  layers(): NSArray<any>;
}
declare const _MSImmutableLayerGroup: {
  alloc(): _MSImmutableLayerGroupAllocator;
}

interface _MSImmutableLayoutGridAllocator<InitializedType = _MSImmutableLayoutGrid> extends MSImmutableBaseGridAllocator<_MSImmutableLayoutGrid> {}
interface _MSImmutableLayoutGrid extends MSImmutableBaseGrid {

  columnWidth(): CGFloat;
  drawHorizontal(): boolean;
  drawHorizontalLines(): boolean;
  drawVertical(): boolean;
  gutterHeight(): CGFloat;
  gutterWidth(): CGFloat;
  guttersOutside(): boolean;
  horizontalOffset(): CGFloat;
  numberOfColumns(): CGFloat;
  rowHeightMultiplication(): CGFloat;
  totalWidth(): CGFloat;
}
declare const _MSImmutableLayoutGrid: {
  alloc(): _MSImmutableLayoutGridAllocator;
}

interface _MSImmutableOvalShapeAllocator<InitializedType = _MSImmutableOvalShape> extends MSImmutableShapePathLayerAllocator<_MSImmutableOvalShape> {}
interface _MSImmutableOvalShape extends MSImmutableShapePathLayer {
}
declare const _MSImmutableOvalShape: {
  alloc(): _MSImmutableOvalShapeAllocator;
}

interface _MSImmutableOverrideValueAllocator<InitializedType = _MSImmutableOverrideValue> extends MSImmutableModelObjectAllocator<_MSImmutableOverrideValue> {}
interface _MSImmutableOverrideValue extends MSImmutableModelObject {

  overrideName(): NSString;
  value(): NSObject;
}
declare const _MSImmutableOverrideValue: {
  alloc(): _MSImmutableOverrideValueAllocator;
}

interface _MSImmutablePageAllocator<InitializedType = _MSImmutablePage> extends MSImmutableLayerGroupAllocator<_MSImmutablePage> {}
interface _MSImmutablePage extends MSImmutableLayerGroup {

  includeInCloudUpload(): boolean;
  grid(): MSImmutableSimpleGrid;
  horizontalRulerData(): MSImmutableRulerData;
  layout(): MSImmutableLayoutGrid;
  verticalRulerData(): MSImmutableRulerData;
}
declare const _MSImmutablePage: {
  alloc(): _MSImmutablePageAllocator;
}

interface _MSImmutablePolygonShapeAllocator<InitializedType = _MSImmutablePolygonShape> extends MSImmutableShapePathLayerAllocator<_MSImmutablePolygonShape> {}
interface _MSImmutablePolygonShape extends MSImmutableShapePathLayer {

  numberOfPoints(): NSInteger;
}
declare const _MSImmutablePolygonShape: {
  alloc(): _MSImmutablePolygonShapeAllocator;
}

interface _MSImmutableRectAllocator<InitializedType = _MSImmutableRect> extends MSImmutableModelObjectAllocator<_MSImmutableRect> {}
interface _MSImmutableRect extends MSImmutableModelObject {

  constrainProportions(): boolean;
  height(): CGFloat;
  width(): CGFloat;
  x(): CGFloat;
  y(): CGFloat;
}
declare const _MSImmutableRect: {
  alloc(): _MSImmutableRectAllocator;
}

interface _MSImmutableRectangleShapeAllocator<InitializedType = _MSImmutableRectangleShape> extends MSImmutableShapePathLayerAllocator<_MSImmutableRectangleShape> {}
interface _MSImmutableRectangleShape extends MSImmutableShapePathLayer {

  fixedRadius(): CGFloat;
  hasConvertedToNewRoundCorners(): boolean;
}
declare const _MSImmutableRectangleShape: {
  alloc(): _MSImmutableRectangleShapeAllocator;
}

interface _MSImmutableRulerDataAllocator<InitializedType = _MSImmutableRulerData> extends MSImmutableModelObjectAllocator<_MSImmutableRulerData> {}
interface _MSImmutableRulerData extends MSImmutableModelObject {

  base(): NSInteger;
  guides(): NSArray<any>;
}
declare const _MSImmutableRulerData: {
  alloc(): _MSImmutableRulerDataAllocator;
}

interface _MSImmutableShapeGroupAllocator<InitializedType = _MSImmutableShapeGroup> extends MSImmutableLayerGroupAllocator<_MSImmutableShapeGroup> {}
interface _MSImmutableShapeGroup extends MSImmutableLayerGroup {
}
declare const _MSImmutableShapeGroup: {
  alloc(): _MSImmutableShapeGroupAllocator;
}

interface _MSImmutableShapePathAllocator<InitializedType = _MSImmutableShapePath> extends MSImmutableModelObjectAllocator<_MSImmutableShapePath> {}
interface _MSImmutableShapePath extends MSImmutableModelObject {

  isClosed(): boolean;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  points(): NSArray<any>;
}
declare const _MSImmutableShapePath: {
  alloc(): _MSImmutableShapePathAllocator;
}

interface _MSImmutableShapePathLayerAllocator<InitializedType = _MSImmutableShapePathLayer> extends MSImmutableStyledLayerAllocator<_MSImmutableShapePathLayer> {}
interface _MSImmutableShapePathLayer extends MSImmutableStyledLayer {

  edited(): boolean;
  isClosed(): boolean;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  points(): NSArray<any>;
}
declare const _MSImmutableShapePathLayer: {
  alloc(): _MSImmutableShapePathLayerAllocator;
}

interface _MSImmutableSharedObjectAllocator<InitializedType = _MSImmutableSharedObject> extends MSImmutableModelObjectAllocator<_MSImmutableSharedObject> {}
interface _MSImmutableSharedObject extends MSImmutableModelObject {

  name(): NSString;
  value(): MSImmutableModelObject;
}
declare const _MSImmutableSharedObject: {
  alloc(): _MSImmutableSharedObjectAllocator;
}

interface _MSImmutableSharedObjectContainerAllocator<InitializedType = _MSImmutableSharedObjectContainer> extends MSImmutableModelObjectAllocator<_MSImmutableSharedObjectContainer> {}
interface _MSImmutableSharedObjectContainer extends MSImmutableModelObject {

  objects(): NSArray<any>;
}
declare const _MSImmutableSharedObjectContainer: {
  alloc(): _MSImmutableSharedObjectContainerAllocator;
}

interface _MSImmutableSharedStyleAllocator<InitializedType = _MSImmutableSharedStyle> extends MSImmutableSharedObjectAllocator<_MSImmutableSharedStyle> {}
interface _MSImmutableSharedStyle extends MSImmutableSharedObject {
}
declare const _MSImmutableSharedStyle: {
  alloc(): _MSImmutableSharedStyleAllocator;
}

interface _MSImmutableSharedStyleContainerAllocator<InitializedType = _MSImmutableSharedStyleContainer> extends MSImmutableSharedObjectContainerAllocator<_MSImmutableSharedStyleContainer> {}
interface _MSImmutableSharedStyleContainer extends MSImmutableSharedObjectContainer {
}
declare const _MSImmutableSharedStyleContainer: {
  alloc(): _MSImmutableSharedStyleContainerAllocator;
}

interface _MSImmutableSharedTextStyleContainerAllocator<InitializedType = _MSImmutableSharedTextStyleContainer> extends MSImmutableSharedStyleContainerAllocator<_MSImmutableSharedTextStyleContainer> {}
interface _MSImmutableSharedTextStyleContainer extends MSImmutableSharedStyleContainer {
}
declare const _MSImmutableSharedTextStyleContainer: {
  alloc(): _MSImmutableSharedTextStyleContainerAllocator;
}

interface _MSImmutableSimpleGridAllocator<InitializedType = _MSImmutableSimpleGrid> extends MSImmutableBaseGridAllocator<_MSImmutableSimpleGrid> {}
interface _MSImmutableSimpleGrid extends MSImmutableBaseGrid {

  gridSize(): NSInteger;
  thickGridTimes(): NSInteger;
}
declare const _MSImmutableSimpleGrid: {
  alloc(): _MSImmutableSimpleGridAllocator;
}

interface _MSImmutableSliceLayerAllocator<InitializedType = _MSImmutableSliceLayer> extends MSImmutableLayerAllocator<_MSImmutableSliceLayer> {}
interface _MSImmutableSliceLayer extends MSImmutableLayer {

  hasBackgroundColor(): boolean;
  backgroundColor(): MSImmutableColor;
}
declare const _MSImmutableSliceLayer: {
  alloc(): _MSImmutableSliceLayerAllocator;
}

interface _MSImmutableStarShapeAllocator<InitializedType = _MSImmutableStarShape> extends MSImmutableShapePathLayerAllocator<_MSImmutableStarShape> {}
interface _MSImmutableStarShape extends MSImmutableShapePathLayer {

  numberOfPoints(): NSInteger;
  radius(): CGFloat;
}
declare const _MSImmutableStarShape: {
  alloc(): _MSImmutableStarShapeAllocator;
}

interface _MSImmutableStyleAllocator<InitializedType = _MSImmutableStyle> extends MSImmutableModelObjectAllocator<_MSImmutableStyle> {}
interface _MSImmutableStyle extends MSImmutableModelObject {

  endMarkerType(): MSMarkerType;
  miterLimit(): NSInteger;
  sharedObjectID(): NSString;
  startMarkerType(): MSMarkerType;
  windingRule(): NSWindingRule;
  blur(): MSImmutableStyleBlur;
  borderOptions(): MSImmutableStyleBorderOptions;
  borders(): NSArray<any>;
  colorControls(): MSImmutableStyleColorControls;
  contextSettings(): MSImmutableGraphicsContextSettings;
  fills(): NSArray<any>;
  innerShadows(): NSArray<any>;
  shadows(): NSArray<any>;
  textStyle(): MSImmutableTextStyle;
}
declare const _MSImmutableStyle: {
  alloc(): _MSImmutableStyleAllocator;
}

interface _MSImmutableStyleBasicFillAllocator<InitializedType = _MSImmutableStyleBasicFill> extends MSImmutableStylePartAllocator<_MSImmutableStyleBasicFill> {}
interface _MSImmutableStyleBasicFill extends MSImmutableStylePart {

  fillType(): BCFillType;
  color(): MSImmutableColor;
  contextSettings(): MSImmutableGraphicsContextSettings;
  gradient(): MSImmutableGradient;
}
declare const _MSImmutableStyleBasicFill: {
  alloc(): _MSImmutableStyleBasicFillAllocator;
}

interface _MSImmutableStyleBlurAllocator<InitializedType = _MSImmutableStyleBlur> extends MSImmutableStylePartAllocator<_MSImmutableStyleBlur> {}
interface _MSImmutableStyleBlur extends MSImmutableStylePart {

  center(): NSPoint;
  motionAngle(): CGFloat;
  radius(): CGFloat;
  saturation(): CGFloat;
  type(): MSStyleBlurType;
}
declare const _MSImmutableStyleBlur: {
  alloc(): _MSImmutableStyleBlurAllocator;
}

interface _MSImmutableStyleBorderAllocator<InitializedType = _MSImmutableStyleBorder> extends MSImmutableStyleBasicFillAllocator<_MSImmutableStyleBorder> {}
interface _MSImmutableStyleBorder extends MSImmutableStyleBasicFill {

  position(): MSBorderPositionType;
  thickness(): CGFloat;
}
declare const _MSImmutableStyleBorder: {
  alloc(): _MSImmutableStyleBorderAllocator;
}

interface _MSImmutableStyleBorderOptionsAllocator<InitializedType = _MSImmutableStyleBorderOptions> extends MSImmutableStylePartAllocator<_MSImmutableStyleBorderOptions> {}
interface _MSImmutableStyleBorderOptions extends MSImmutableStylePart {

  dashPattern(): NSArray<any>;
  lineCapStyle(): NSLineCapStyle;
  lineJoinStyle(): NSLineJoinStyle;
}
declare const _MSImmutableStyleBorderOptions: {
  alloc(): _MSImmutableStyleBorderOptionsAllocator;
}

interface _MSImmutableStyleColorControlsAllocator<InitializedType = _MSImmutableStyleColorControls> extends MSImmutableStylePartAllocator<_MSImmutableStyleColorControls> {}
interface _MSImmutableStyleColorControls extends MSImmutableStylePart {

  brightness(): CGFloat;
  contrast(): CGFloat;
  hue(): CGFloat;
  saturation(): CGFloat;
}
declare const _MSImmutableStyleColorControls: {
  alloc(): _MSImmutableStyleColorControlsAllocator;
}

interface _MSImmutableStyleFillAllocator<InitializedType = _MSImmutableStyleFill> extends MSImmutableStyleBasicFillAllocator<_MSImmutableStyleFill> {}
interface _MSImmutableStyleFill extends MSImmutableStyleBasicFill {

  image(): MSImageData;
  noiseIndex(): NSInteger;
  noiseIntensity(): CGFloat;
  patternFillType(): MSPatternFillType;
  patternTileScale(): CGFloat;
}
declare const _MSImmutableStyleFill: {
  alloc(): _MSImmutableStyleFillAllocator;
}

interface _MSImmutableStyleInnerShadowAllocator<InitializedType = _MSImmutableStyleInnerShadow> extends MSImmutableStyleShadowAllocator<_MSImmutableStyleInnerShadow> {}
interface _MSImmutableStyleInnerShadow extends MSImmutableStyleShadow {
}
declare const _MSImmutableStyleInnerShadow: {
  alloc(): _MSImmutableStyleInnerShadowAllocator;
}

interface _MSImmutableStylePartAllocator<InitializedType = _MSImmutableStylePart> extends MSImmutableModelObjectAllocator<_MSImmutableStylePart> {}
interface _MSImmutableStylePart extends MSImmutableModelObject {

  isEnabled(): boolean;
}
declare const _MSImmutableStylePart: {
  alloc(): _MSImmutableStylePartAllocator;
}

interface _MSImmutableStyleReflectionAllocator<InitializedType = _MSImmutableStyleReflection> extends MSImmutableStylePartAllocator<_MSImmutableStyleReflection> {}
interface _MSImmutableStyleReflection extends MSImmutableStylePart {

  distance(): CGFloat;
  strength(): CGFloat;
}
declare const _MSImmutableStyleReflection: {
  alloc(): _MSImmutableStyleReflectionAllocator;
}

interface _MSImmutableStyleShadowAllocator<InitializedType = _MSImmutableStyleShadow> extends MSImmutableStylePartAllocator<_MSImmutableStyleShadow> {}
interface _MSImmutableStyleShadow extends MSImmutableStylePart {

  blurRadius(): CGFloat;
  offsetX(): CGFloat;
  offsetY(): CGFloat;
  spread(): CGFloat;
  color(): MSImmutableColor;
  contextSettings(): MSImmutableGraphicsContextSettings;
}
declare const _MSImmutableStyleShadow: {
  alloc(): _MSImmutableStyleShadowAllocator;
}

interface _MSImmutableStyledLayerAllocator<InitializedType = _MSImmutableStyledLayer> extends MSImmutableLayerAllocator<_MSImmutableStyledLayer> {}
interface _MSImmutableStyledLayer extends MSImmutableLayer {

  clippingMaskMode(): NSInteger;
  hasClippingMask(): boolean;
  style(): MSImmutableStyle;
}
declare const _MSImmutableStyledLayer: {
  alloc(): _MSImmutableStyledLayerAllocator;
}

interface _MSImmutableSymbolAllocator<InitializedType = _MSImmutableSymbol> extends MSImmutableSharedObjectAllocator<_MSImmutableSymbol> {}
interface _MSImmutableSymbol extends MSImmutableSharedObject {
}
declare const _MSImmutableSymbol: {
  alloc(): _MSImmutableSymbolAllocator;
}

interface _MSImmutableSymbolContainerAllocator<InitializedType = _MSImmutableSymbolContainer> extends MSImmutableSharedObjectContainerAllocator<_MSImmutableSymbolContainer> {}
interface _MSImmutableSymbolContainer extends MSImmutableSharedObjectContainer {
}
declare const _MSImmutableSymbolContainer: {
  alloc(): _MSImmutableSymbolContainerAllocator;
}

interface _MSImmutableSymbolInstanceAllocator<InitializedType = _MSImmutableSymbolInstance> extends MSImmutableStyledLayerAllocator<_MSImmutableSymbolInstance> {}
interface _MSImmutableSymbolInstance extends MSImmutableStyledLayer {

  horizontalSpacing(): CGFloat;
  scale(): CGFloat;
  symbolID(): NSString;
  verticalSpacing(): CGFloat;
  overrideValues(): NSArray<any>;
}
declare const _MSImmutableSymbolInstance: {
  alloc(): _MSImmutableSymbolInstanceAllocator;
}

interface _MSImmutableSymbolMasterAllocator<InitializedType = _MSImmutableSymbolMaster> extends MSImmutableArtboardGroupAllocator<_MSImmutableSymbolMaster> {}
interface _MSImmutableSymbolMaster extends MSImmutableArtboardGroup {

  includeBackgroundColorInInstance(): boolean;
  symbolID(): NSString;
}
declare const _MSImmutableSymbolMaster: {
  alloc(): _MSImmutableSymbolMasterAllocator;
}

interface _MSImmutableTextLayerAllocator<InitializedType = _MSImmutableTextLayer> extends MSImmutableStyledLayerAllocator<_MSImmutableTextLayer> {}
interface _MSImmutableTextLayer extends MSImmutableStyledLayer {

  attributedString(): MSAttributedString;
  automaticallyDrawOnUnderlyingPath(): boolean;
  dontSynchroniseWithSymbol(): boolean;
  glyphBounds(): NSRect;
  lineSpacingBehaviour(): BCTextLineSpacingBehaviourType;
  preview(): MSImageData;
  textBehaviour(): BCTextBehaviourType;
}
declare const _MSImmutableTextLayer: {
  alloc(): _MSImmutableTextLayerAllocator;
}

interface _MSImmutableTextStyleAllocator<InitializedType = _MSImmutableTextStyle> extends MSImmutableModelObjectAllocator<_MSImmutableTextStyle> {}
interface _MSImmutableTextStyle extends MSImmutableModelObject {

  encodedAttributes(): NSDictionary<any, any>;
  verticalAlignment(): MSTextStyleVerticalAlignment;
}
declare const _MSImmutableTextStyle: {
  alloc(): _MSImmutableTextStyleAllocator;
}

interface _MSImmutableTriangleShapeAllocator<InitializedType = _MSImmutableTriangleShape> extends MSImmutableShapePathLayerAllocator<_MSImmutableTriangleShape> {}
interface _MSImmutableTriangleShape extends MSImmutableShapePathLayer {

  isEquilateral(): boolean;
}
declare const _MSImmutableTriangleShape: {
  alloc(): _MSImmutableTriangleShapeAllocator;
}

interface _MSLayerAllocator<InitializedType = _MSLayer> extends MSModelObjectAllocator<_MSLayer> {}
interface _MSLayer extends MSModelObject {

  booleanOperation(): MSBooleanOperation;
  setBooleanOperation(booleanOperation: MSBooleanOperation): void;
  isFixedToViewport(): boolean;
  setIsFixedToViewport(isFixedToViewport: boolean): void;
  isFlippedHorizontal(): boolean;
  setIsFlippedHorizontal(isFlippedHorizontal: boolean): void;
  isFlippedVertical(): boolean;
  setIsFlippedVertical(isFlippedVertical: boolean): void;
  isLocked(): boolean;
  setIsLocked(isLocked: boolean): void;
  isVisible(): boolean;
  setIsVisible(isVisible: boolean): void;
  layerListExpandedType(): MSLayerListStatus;
  setLayerListExpandedType(layerListExpandedType: MSLayerListStatus): void;
  name(): NSString;
  setName(name: NSString | string): void;
  nameIsFixed(): boolean;
  setNameIsFixed(nameIsFixed: boolean): void;
  originalObjectID(): NSString;
  setOriginalObjectID(originalObjectID: NSString | string): void;
  pathInBounds(): MSPath;
  resizingConstraint(): BCConstraint;
  setResizingConstraint(resizingConstraint: BCConstraint): void;
  resizingType(): MSLayerResizingType;
  setResizingType(resizingType: MSLayerResizingType): void;
  rotation(): CGFloat;
  setRotation(rotation: CGFloat): void;
  shouldBreakMaskChain(): boolean;
  setShouldBreakMaskChain(shouldBreakMaskChain: boolean): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  exportOptions(): MSExportOptions;
  setExportOptions(exportOptions: MSExportOptions): void;
  flow(): MSFlowConnection;
  setFlow(flow: MSFlowConnection): void;
  frame(): MSRect;
  setFrame(frame: MSRect): void;
}
declare const _MSLayer: {
  alloc(): _MSLayerAllocator;
}

interface _MSLayerGroupAllocator<InitializedType = _MSLayerGroup> extends MSStyledLayerAllocator<_MSLayerGroup> {}
interface _MSLayerGroup extends MSStyledLayer {
  addLayer(value: MSLayer): void;
  addLayers(layers: NSArray<any> | any[]): void;
  insertLayer_atIndex(value: MSLayer, index: NSUInteger): void;
  insertLayer_beforeLayer(value: MSLayer, after: MSLayer | null): void;
  insertLayers_beforeLayer(values: NSArray<any> | any[], before: MSLayer | null): void;
  insertLayer_afterLayer(value: MSLayer, after: MSLayer | null): void;
  insertLayers_afterLayer(values: NSArray<any> | any[], after: MSLayer | null): void;
  removeLayer(value: MSLayer): void;
  removeLayerAtIndex(index: NSUInteger): void;
  removeLayersAtIndexes(indexes: NSIndexSet): void;
  removeAllLayers(): void;
  moveLayerIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  hasClickThrough(): boolean;
  setHasClickThrough(hasClickThrough: boolean): void;
  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}
declare const _MSLayerGroup: {
  alloc(): _MSLayerGroupAllocator;
}

interface _MSLayoutGridAllocator<InitializedType = _MSLayoutGrid> extends MSBaseGridAllocator<_MSLayoutGrid> {}
interface _MSLayoutGrid extends MSBaseGrid {

  columnWidth(): CGFloat;
  setColumnWidth(columnWidth: CGFloat): void;
  drawHorizontal(): boolean;
  setDrawHorizontal(drawHorizontal: boolean): void;
  drawHorizontalLines(): boolean;
  setDrawHorizontalLines(drawHorizontalLines: boolean): void;
  drawVertical(): boolean;
  setDrawVertical(drawVertical: boolean): void;
  gutterHeight(): CGFloat;
  setGutterHeight(gutterHeight: CGFloat): void;
  gutterWidth(): CGFloat;
  setGutterWidth(gutterWidth: CGFloat): void;
  guttersOutside(): boolean;
  setGuttersOutside(guttersOutside: boolean): void;
  horizontalOffset(): CGFloat;
  setHorizontalOffset(horizontalOffset: CGFloat): void;
  numberOfColumns(): CGFloat;
  setNumberOfColumns(numberOfColumns: CGFloat): void;
  rowHeightMultiplication(): CGFloat;
  setRowHeightMultiplication(rowHeightMultiplication: CGFloat): void;
  totalWidth(): CGFloat;
  setTotalWidth(totalWidth: CGFloat): void;
}
declare const _MSLayoutGrid: {
  alloc(): _MSLayoutGridAllocator;
}

interface _MSOvalShapeAllocator<InitializedType = _MSOvalShape> extends MSShapePathLayerAllocator<_MSOvalShape> {}
interface _MSOvalShape extends MSShapePathLayer {
}
declare const _MSOvalShape: {
  alloc(): _MSOvalShapeAllocator;
}

interface _MSOverrideValueAllocator<InitializedType = _MSOverrideValue> extends MSModelObjectAllocator<_MSOverrideValue> {}
interface _MSOverrideValue extends MSModelObject {

  overrideName(): NSString;
  setOverrideName(overrideName: NSString | string): void;
  value(): NSObject;
  setValue(value: NSObject): void;
}
declare const _MSOverrideValue: {
  alloc(): _MSOverrideValueAllocator;
}

interface _MSPageAllocator<InitializedType = _MSPage> extends MSLayerGroupAllocator<_MSPage> {}
interface _MSPage extends MSLayerGroup {

  includeInCloudUpload(): boolean;
  setIncludeInCloudUpload(includeInCloudUpload: boolean): void;
  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  horizontalRulerData(): MSRulerData;
  setHorizontalRulerData(horizontalRulerData: MSRulerData): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  verticalRulerData(): MSRulerData;
  setVerticalRulerData(verticalRulerData: MSRulerData): void;
}
declare const _MSPage: {
  alloc(): _MSPageAllocator;
}

interface _MSPolygonShapeAllocator<InitializedType = _MSPolygonShape> extends MSShapePathLayerAllocator<_MSPolygonShape> {}
interface _MSPolygonShape extends MSShapePathLayer {

  numberOfPoints(): NSInteger;
  setNumberOfPoints(numberOfPoints: NSInteger): void;
}
declare const _MSPolygonShape: {
  alloc(): _MSPolygonShapeAllocator;
}

interface _MSRectAllocator<InitializedType = _MSRect> extends MSModelObjectAllocator<_MSRect> {}
interface _MSRect extends MSModelObject {

  constrainProportions(): boolean;
  setConstrainProportions(constrainProportions: boolean): void;
  height(): CGFloat;
  setHeight(height: CGFloat): void;
  width(): CGFloat;
  setWidth(width: CGFloat): void;
  x(): CGFloat;
  setX(x: CGFloat): void;
  y(): CGFloat;
  setY(y: CGFloat): void;
}
declare const _MSRect: {
  alloc(): _MSRectAllocator;
}

interface _MSRectangleShapeAllocator<InitializedType = _MSRectangleShape> extends MSShapePathLayerAllocator<_MSRectangleShape> {}
interface _MSRectangleShape extends MSShapePathLayer {

  fixedRadius(): CGFloat;
  setFixedRadius(fixedRadius: CGFloat): void;
  hasConvertedToNewRoundCorners(): boolean;
  setHasConvertedToNewRoundCorners(hasConvertedToNewRoundCorners: boolean): void;
}
declare const _MSRectangleShape: {
  alloc(): _MSRectangleShapeAllocator;
}

interface _MSRulerDataAllocator<InitializedType = _MSRulerData> extends MSModelObjectAllocator<_MSRulerData> {}
interface _MSRulerData extends MSModelObject {

  base(): NSInteger;
  setBase(base: NSInteger): void;
  guides(): NSArray<any>;
  setGuides(guides: NSArray<any> | any[]): void;
}
declare const _MSRulerData: {
  alloc(): _MSRulerDataAllocator;
}

interface _MSShapeGroupAllocator<InitializedType = _MSShapeGroup> extends MSLayerGroupAllocator<_MSShapeGroup> {}
interface _MSShapeGroup extends MSLayerGroup {
}
declare const _MSShapeGroup: {
  alloc(): _MSShapeGroupAllocator;
}

interface _MSShapePathAllocator<InitializedType = _MSShapePath> extends MSModelObjectAllocator<_MSShapePath> {}
interface _MSShapePath extends MSModelObject {
  addCurvePoint(value: MSCurvePoint): void;
  addCurvePoints(points: NSArray<any> | any[]): void;
  insertCurvePoint_atIndex(value: MSCurvePoint, index: NSUInteger): void;
  insertCurvePoint_beforeCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_beforeCurvePoint(values: NSArray<any> | any[], before: MSCurvePoint | null): void;
  insertCurvePoint_afterCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_afterCurvePoint(values: NSArray<any> | any[], after: MSCurvePoint | null): void;
  removeCurvePoint(value: MSCurvePoint): void;
  removeCurvePointAtIndex(index: NSUInteger): void;
  removeCurvePointsAtIndexes(indexes: NSIndexSet): void;
  removeAllCurvePoints(): void;
  moveCurvePointIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  setPointRadiusBehaviour(pointRadiusBehaviour: MSPointRadiusBehaviour): void;
  points(): NSArray<any>;
  setPoints(points: NSArray<any> | any[]): void;
}
declare const _MSShapePath: {
  alloc(): _MSShapePathAllocator;
}

interface _MSShapePathLayerAllocator<InitializedType = _MSShapePathLayer> extends MSStyledLayerAllocator<_MSShapePathLayer> {}
interface _MSShapePathLayer extends MSStyledLayer {
  addCurvePoint(value: MSCurvePoint): void;
  addCurvePoints(points: NSArray<any> | any[]): void;
  insertCurvePoint_atIndex(value: MSCurvePoint, index: NSUInteger): void;
  insertCurvePoint_beforeCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_beforeCurvePoint(values: NSArray<any> | any[], before: MSCurvePoint | null): void;
  insertCurvePoint_afterCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_afterCurvePoint(values: NSArray<any> | any[], after: MSCurvePoint | null): void;
  removeCurvePoint(value: MSCurvePoint): void;
  removeCurvePointAtIndex(index: NSUInteger): void;
  removeCurvePointsAtIndexes(indexes: NSIndexSet): void;
  removeAllCurvePoints(): void;
  moveCurvePointIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  edited(): boolean;
  setEdited(edited: boolean): void;
  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  setPointRadiusBehaviour(pointRadiusBehaviour: MSPointRadiusBehaviour): void;
  points(): NSArray<any>;
  setPoints(points: NSArray<any> | any[]): void;
}
declare const _MSShapePathLayer: {
  alloc(): _MSShapePathLayerAllocator;
}

interface _MSSharedObjectAllocator<InitializedType = _MSSharedObject> extends MSModelObjectAllocator<_MSSharedObject> {}
interface _MSSharedObject extends MSModelObject {

  name(): NSString;
  setName(name: NSString | string): void;
  value(): MSModelObjectCommon;
  setValue(value: MSModelObjectCommon): void;
}
declare const _MSSharedObject: {
  alloc(): _MSSharedObjectAllocator;
}

interface _MSSharedObjectContainerAllocator<InitializedType = _MSSharedObjectContainer> extends MSModelObjectAllocator<_MSSharedObjectContainer> {}
interface _MSSharedObjectContainer extends MSModelObject {
  addSharedObject(value: MSSharedObject): void;
  addSharedObjects(objects: NSArray<any> | any[]): void;
  insertSharedObject_atIndex(value: MSSharedObject, index: NSUInteger): void;
  insertSharedObject_beforeSharedObject(value: MSSharedObject, after: MSSharedObject | null): void;
  insertSharedObjects_beforeSharedObject(values: NSArray<any> | any[], before: MSSharedObject | null): void;
  insertSharedObject_afterSharedObject(value: MSSharedObject, after: MSSharedObject | null): void;
  insertSharedObjects_afterSharedObject(values: NSArray<any> | any[], after: MSSharedObject | null): void;
  removeSharedObject(value: MSSharedObject): void;
  removeSharedObjectAtIndex(index: NSUInteger): void;
  removeSharedObjectsAtIndexes(indexes: NSIndexSet): void;
  removeAllSharedObjects(): void;
  moveSharedObjectIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  objects(): NSArray<any>;
  setObjects(objects: NSArray<any> | any[]): void;
}
declare const _MSSharedObjectContainer: {
  alloc(): _MSSharedObjectContainerAllocator;
}

interface _MSSharedStyleAllocator<InitializedType = _MSSharedStyle> extends MSSharedObjectAllocator<_MSSharedStyle> {}
interface _MSSharedStyle extends MSSharedObject {
}
declare const _MSSharedStyle: {
  alloc(): _MSSharedStyleAllocator;
}

interface _MSSharedStyleContainerAllocator<InitializedType = _MSSharedStyleContainer> extends MSSharedObjectContainerAllocator<_MSSharedStyleContainer> {}
interface _MSSharedStyleContainer extends MSSharedObjectContainer {
}
declare const _MSSharedStyleContainer: {
  alloc(): _MSSharedStyleContainerAllocator;
}

interface _MSSharedTextStyleContainerAllocator<InitializedType = _MSSharedTextStyleContainer> extends MSSharedStyleContainerAllocator<_MSSharedTextStyleContainer> {}
interface _MSSharedTextStyleContainer extends MSSharedStyleContainer {
}
declare const _MSSharedTextStyleContainer: {
  alloc(): _MSSharedTextStyleContainerAllocator;
}

interface _MSSimpleGridAllocator<InitializedType = _MSSimpleGrid> extends MSBaseGridAllocator<_MSSimpleGrid> {}
interface _MSSimpleGrid extends MSBaseGrid {

  gridSize(): NSInteger;
  setGridSize(gridSize: NSInteger): void;
  thickGridTimes(): NSInteger;
  setThickGridTimes(thickGridTimes: NSInteger): void;
}
declare const _MSSimpleGrid: {
  alloc(): _MSSimpleGridAllocator;
}

interface _MSSliceLayerAllocator<InitializedType = _MSSliceLayer> extends MSLayerAllocator<_MSSliceLayer> {}
interface _MSSliceLayer extends MSLayer {

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
}
declare const _MSSliceLayer: {
  alloc(): _MSSliceLayerAllocator;
}

interface _MSStarShapeAllocator<InitializedType = _MSStarShape> extends MSShapePathLayerAllocator<_MSStarShape> {}
interface _MSStarShape extends MSShapePathLayer {

  numberOfPoints(): NSInteger;
  setNumberOfPoints(numberOfPoints: NSInteger): void;
  radius(): CGFloat;
  setRadius(radius: CGFloat): void;
}
declare const _MSStarShape: {
  alloc(): _MSStarShapeAllocator;
}

interface _MSStyleAllocator<InitializedType = _MSStyle> extends MSModelObjectAllocator<_MSStyle> {}
interface _MSStyle extends MSModelObject {
  addStyleBorder(value: MSStyleBorder): void;
  addStyleBorders(borders: NSArray<any> | any[]): void;
  insertStyleBorder_atIndex(value: MSStyleBorder, index: NSUInteger): void;
  insertStyleBorder_beforeStyleBorder(value: MSStyleBorder, after: MSStyleBorder | null): void;
  insertStyleBorders_beforeStyleBorder(values: NSArray<any> | any[], before: MSStyleBorder | null): void;
  insertStyleBorder_afterStyleBorder(value: MSStyleBorder, after: MSStyleBorder | null): void;
  insertStyleBorders_afterStyleBorder(values: NSArray<any> | any[], after: MSStyleBorder | null): void;
  removeStyleBorder(value: MSStyleBorder): void;
  removeStyleBorderAtIndex(index: NSUInteger): void;
  removeStyleBordersAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleBorders(): void;
  moveStyleBorderIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addStyleFill(value: MSStyleFill): void;
  addStyleFills(fills: NSArray<any> | any[]): void;
  insertStyleFill_atIndex(value: MSStyleFill, index: NSUInteger): void;
  insertStyleFill_beforeStyleFill(value: MSStyleFill, after: MSStyleFill | null): void;
  insertStyleFills_beforeStyleFill(values: NSArray<any> | any[], before: MSStyleFill | null): void;
  insertStyleFill_afterStyleFill(value: MSStyleFill, after: MSStyleFill | null): void;
  insertStyleFills_afterStyleFill(values: NSArray<any> | any[], after: MSStyleFill | null): void;
  removeStyleFill(value: MSStyleFill): void;
  removeStyleFillAtIndex(index: NSUInteger): void;
  removeStyleFillsAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleFills(): void;
  moveStyleFillIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addStyleInnerShadow(value: MSStyleInnerShadow): void;
  addStyleInnerShadows(innerShadows: NSArray<any> | any[]): void;
  insertStyleInnerShadow_atIndex(value: MSStyleInnerShadow, index: NSUInteger): void;
  insertStyleInnerShadow_beforeStyleInnerShadow(value: MSStyleInnerShadow, after: MSStyleInnerShadow | null): void;
  insertStyleInnerShadows_beforeStyleInnerShadow(values: NSArray<any> | any[], before: MSStyleInnerShadow | null): void;
  insertStyleInnerShadow_afterStyleInnerShadow(value: MSStyleInnerShadow, after: MSStyleInnerShadow | null): void;
  insertStyleInnerShadows_afterStyleInnerShadow(values: NSArray<any> | any[], after: MSStyleInnerShadow | null): void;
  removeStyleInnerShadow(value: MSStyleInnerShadow): void;
  removeStyleInnerShadowAtIndex(index: NSUInteger): void;
  removeStyleInnerShadowsAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleInnerShadows(): void;
  moveStyleInnerShadowIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addStyleShadow(value: MSStyleShadow): void;
  addStyleShadows(shadows: NSArray<any> | any[]): void;
  insertStyleShadow_atIndex(value: MSStyleShadow, index: NSUInteger): void;
  insertStyleShadow_beforeStyleShadow(value: MSStyleShadow, after: MSStyleShadow | null): void;
  insertStyleShadows_beforeStyleShadow(values: NSArray<any> | any[], before: MSStyleShadow | null): void;
  insertStyleShadow_afterStyleShadow(value: MSStyleShadow, after: MSStyleShadow | null): void;
  insertStyleShadows_afterStyleShadow(values: NSArray<any> | any[], after: MSStyleShadow | null): void;
  removeStyleShadow(value: MSStyleShadow): void;
  removeStyleShadowAtIndex(index: NSUInteger): void;
  removeStyleShadowsAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleShadows(): void;
  moveStyleShadowIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  endMarkerType(): MSMarkerType;
  setEndMarkerType(endMarkerType: MSMarkerType): void;
  miterLimit(): NSInteger;
  setMiterLimit(miterLimit: NSInteger): void;
  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
  startMarkerType(): MSMarkerType;
  setStartMarkerType(startMarkerType: MSMarkerType): void;
  windingRule(): NSWindingRule;
  setWindingRule(windingRule: NSWindingRule): void;
  blur(): MSStyleBlur;
  setBlur(blur: MSStyleBlur): void;
  borderOptions(): MSStyleBorderOptions;
  setBorderOptions(borderOptions: MSStyleBorderOptions): void;
  borders(): NSArray<any>;
  setBorders(borders: NSArray<any> | any[]): void;
  colorControls(): MSStyleColorControls;
  setColorControls(colorControls: MSStyleColorControls): void;
  contextSettings(): MSGraphicsContextSettings;
  setContextSettings(contextSettings: MSGraphicsContextSettings): void;
  fills(): NSArray<any>;
  setFills(fills: NSArray<any> | any[]): void;
  innerShadows(): NSArray<any>;
  setInnerShadows(innerShadows: NSArray<any> | any[]): void;
  shadows(): NSArray<any>;
  setShadows(shadows: NSArray<any> | any[]): void;
  textStyle(): MSTextStyle;
  setTextStyle(textStyle: MSTextStyle): void;
}
declare const _MSStyle: {
  alloc(): _MSStyleAllocator;
}

interface _MSStyleBasicFillAllocator<InitializedType = _MSStyleBasicFill> extends MSStylePartAllocator<_MSStyleBasicFill> {}
interface _MSStyleBasicFill extends MSStylePart {

  fillType(): BCFillType;
  setFillType(fillType: BCFillType): void;
  color(): MSColor;
  setColor(color: MSColor): void;
  contextSettings(): MSGraphicsContextSettings;
  setContextSettings(contextSettings: MSGraphicsContextSettings): void;
  gradient(): MSGradient;
  setGradient(gradient: MSGradient): void;
}
declare const _MSStyleBasicFill: {
  alloc(): _MSStyleBasicFillAllocator;
}

interface _MSStyleBlurAllocator<InitializedType = _MSStyleBlur> extends MSStylePartAllocator<_MSStyleBlur> {}
interface _MSStyleBlur extends MSStylePart {

  center(): NSPoint;
  setCenter(center: NSPoint): void;
  motionAngle(): CGFloat;
  setMotionAngle(motionAngle: CGFloat): void;
  radius(): CGFloat;
  setRadius(radius: CGFloat): void;
  saturation(): CGFloat;
  setSaturation(saturation: CGFloat): void;
  type(): MSStyleBlurType;
  setType(type: MSStyleBlurType): void;
}
declare const _MSStyleBlur: {
  alloc(): _MSStyleBlurAllocator;
}

interface _MSStyleBorderAllocator<InitializedType = _MSStyleBorder> extends MSStyleBasicFillAllocator<_MSStyleBorder> {}
interface _MSStyleBorder extends MSStyleBasicFill {

  position(): MSBorderPositionType;
  setPosition(position: MSBorderPositionType): void;
  thickness(): CGFloat;
  setThickness(thickness: CGFloat): void;
}
declare const _MSStyleBorder: {
  alloc(): _MSStyleBorderAllocator;
}

interface _MSStyleBorderOptionsAllocator<InitializedType = _MSStyleBorderOptions> extends MSStylePartAllocator<_MSStyleBorderOptions> {}
interface _MSStyleBorderOptions extends MSStylePart {

  dashPattern(): NSArray<any>;
  setDashPattern(dashPattern: NSArray<any> | any[]): void;
  lineCapStyle(): NSLineCapStyle;
  setLineCapStyle(lineCapStyle: NSLineCapStyle): void;
  lineJoinStyle(): NSLineJoinStyle;
  setLineJoinStyle(lineJoinStyle: NSLineJoinStyle): void;
}
declare const _MSStyleBorderOptions: {
  alloc(): _MSStyleBorderOptionsAllocator;
}

interface _MSStyleColorControlsAllocator<InitializedType = _MSStyleColorControls> extends MSStylePartAllocator<_MSStyleColorControls> {}
interface _MSStyleColorControls extends MSStylePart {

  brightness(): CGFloat;
  setBrightness(brightness: CGFloat): void;
  contrast(): CGFloat;
  setContrast(contrast: CGFloat): void;
  hue(): CGFloat;
  setHue(hue: CGFloat): void;
  saturation(): CGFloat;
  setSaturation(saturation: CGFloat): void;
}
declare const _MSStyleColorControls: {
  alloc(): _MSStyleColorControlsAllocator;
}

interface _MSStyleFillAllocator<InitializedType = _MSStyleFill> extends MSStyleBasicFillAllocator<_MSStyleFill> {}
interface _MSStyleFill extends MSStyleBasicFill {

  image(): MSImageData;
  setImage(image: MSImageData): void;
  noiseIndex(): NSInteger;
  setNoiseIndex(noiseIndex: NSInteger): void;
  noiseIntensity(): CGFloat;
  setNoiseIntensity(noiseIntensity: CGFloat): void;
  patternFillType(): MSPatternFillType;
  setPatternFillType(patternFillType: MSPatternFillType): void;
  patternTileScale(): CGFloat;
  setPatternTileScale(patternTileScale: CGFloat): void;
}
declare const _MSStyleFill: {
  alloc(): _MSStyleFillAllocator;
}

interface _MSStyleInnerShadowAllocator<InitializedType = _MSStyleInnerShadow> extends MSStyleShadowAllocator<_MSStyleInnerShadow> {}
interface _MSStyleInnerShadow extends MSStyleShadow {
}
declare const _MSStyleInnerShadow: {
  alloc(): _MSStyleInnerShadowAllocator;
}

interface _MSStylePartAllocator<InitializedType = _MSStylePart> extends MSModelObjectAllocator<_MSStylePart> {}
interface _MSStylePart extends MSModelObject {

  isEnabled(): boolean;
  setIsEnabled(isEnabled: boolean): void;
}
declare const _MSStylePart: {
  alloc(): _MSStylePartAllocator;
}

interface _MSStyleReflectionAllocator<InitializedType = _MSStyleReflection> extends MSStylePartAllocator<_MSStyleReflection> {}
interface _MSStyleReflection extends MSStylePart {

  distance(): CGFloat;
  setDistance(distance: CGFloat): void;
  strength(): CGFloat;
  setStrength(strength: CGFloat): void;
}
declare const _MSStyleReflection: {
  alloc(): _MSStyleReflectionAllocator;
}

interface _MSStyleShadowAllocator<InitializedType = _MSStyleShadow> extends MSStylePartAllocator<_MSStyleShadow> {}
interface _MSStyleShadow extends MSStylePart {

  blurRadius(): CGFloat;
  setBlurRadius(blurRadius: CGFloat): void;
  offsetX(): CGFloat;
  setOffsetX(offsetX: CGFloat): void;
  offsetY(): CGFloat;
  setOffsetY(offsetY: CGFloat): void;
  spread(): CGFloat;
  setSpread(spread: CGFloat): void;
  color(): MSColor;
  setColor(color: MSColor): void;
  contextSettings(): MSGraphicsContextSettings;
  setContextSettings(contextSettings: MSGraphicsContextSettings): void;
}
declare const _MSStyleShadow: {
  alloc(): _MSStyleShadowAllocator;
}

interface _MSStyledLayerAllocator<InitializedType = _MSStyledLayer> extends MSLayerAllocator<_MSStyledLayer> {}
interface _MSStyledLayer extends MSLayer {

  clippingMaskMode(): NSInteger;
  setClippingMaskMode(clippingMaskMode: NSInteger): void;
  hasClippingMask(): boolean;
  setHasClippingMask(hasClippingMask: boolean): void;
  style(): MSStyle;
  setStyle(style: MSStyle): void;
}
declare const _MSStyledLayer: {
  alloc(): _MSStyledLayerAllocator;
}

interface _MSSymbolAllocator<InitializedType = _MSSymbol> extends MSSharedObjectAllocator<_MSSymbol> {}
interface _MSSymbol extends MSSharedObject {
}
declare const _MSSymbol: {
  alloc(): _MSSymbolAllocator;
}

interface _MSSymbolContainerAllocator<InitializedType = _MSSymbolContainer> extends MSSharedObjectContainerAllocator<_MSSymbolContainer> {}
interface _MSSymbolContainer extends MSSharedObjectContainer {
}
declare const _MSSymbolContainer: {
  alloc(): _MSSymbolContainerAllocator;
}

interface _MSSymbolInstanceAllocator<InitializedType = _MSSymbolInstance> extends MSStyledLayerAllocator<_MSSymbolInstance> {}
interface _MSSymbolInstance extends MSStyledLayer {
  addOverrideValue(value: MSOverrideValue): void;
  addOverrideValues(overrideValues: NSArray<any> | any[]): void;
  insertOverrideValue_atIndex(value: MSOverrideValue, index: NSUInteger): void;
  insertOverrideValue_beforeOverrideValue(value: MSOverrideValue, after: MSOverrideValue | null): void;
  insertOverrideValues_beforeOverrideValue(values: NSArray<any> | any[], before: MSOverrideValue | null): void;
  insertOverrideValue_afterOverrideValue(value: MSOverrideValue, after: MSOverrideValue | null): void;
  insertOverrideValues_afterOverrideValue(values: NSArray<any> | any[], after: MSOverrideValue | null): void;
  removeOverrideValue(value: MSOverrideValue): void;
  removeOverrideValueAtIndex(index: NSUInteger): void;
  removeOverrideValuesAtIndexes(indexes: NSIndexSet): void;
  removeAllOverrideValues(): void;
  moveOverrideValueIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  horizontalSpacing(): CGFloat;
  setHorizontalSpacing(horizontalSpacing: CGFloat): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  symbolID(): NSString;
  setSymbolID(symbolID: NSString | string): void;
  verticalSpacing(): CGFloat;
  setVerticalSpacing(verticalSpacing: CGFloat): void;
  overrideValues(): NSArray<any>;
  setOverrideValues(overrideValues: NSArray<any> | any[]): void;
}
declare const _MSSymbolInstance: {
  alloc(): _MSSymbolInstanceAllocator;
}

interface _MSSymbolMasterAllocator<InitializedType = _MSSymbolMaster> extends MSArtboardGroupAllocator<_MSSymbolMaster> {}
interface _MSSymbolMaster extends MSArtboardGroup {

  includeBackgroundColorInInstance(): boolean;
  setIncludeBackgroundColorInInstance(includeBackgroundColorInInstance: boolean): void;
  symbolID(): NSString;
  setSymbolID(symbolID: NSString | string): void;
}
declare const _MSSymbolMaster: {
  alloc(): _MSSymbolMasterAllocator;
}

interface _MSTextLayerAllocator<InitializedType = _MSTextLayer> extends MSStyledLayerAllocator<_MSTextLayer> {}
interface _MSTextLayer extends MSStyledLayer {

  attributedString(): MSAttributedString;
  setAttributedString(attributedString: MSAttributedString): void;
  automaticallyDrawOnUnderlyingPath(): boolean;
  setAutomaticallyDrawOnUnderlyingPath(automaticallyDrawOnUnderlyingPath: boolean): void;
  dontSynchroniseWithSymbol(): boolean;
  setDontSynchroniseWithSymbol(dontSynchroniseWithSymbol: boolean): void;
  glyphBounds(): NSRect;
  setGlyphBounds(glyphBounds: NSRect): void;
  lineSpacingBehaviour(): BCTextLineSpacingBehaviourType;
  setLineSpacingBehaviour(lineSpacingBehaviour: BCTextLineSpacingBehaviourType): void;
  preview(): MSImageData;
  setPreview(preview: MSImageData): void;
  textBehaviour(): BCTextBehaviourType;
  setTextBehaviour(textBehaviour: BCTextBehaviourType): void;
}
declare const _MSTextLayer: {
  alloc(): _MSTextLayerAllocator;
}

interface _MSTextStyleAllocator<InitializedType = _MSTextStyle> extends MSModelObjectAllocator<_MSTextStyle> {}
interface _MSTextStyle extends MSModelObject {

  encodedAttributes(): NSDictionary<any, any>;
  setEncodedAttributes(encodedAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  verticalAlignment(): MSTextStyleVerticalAlignment;
  setVerticalAlignment(verticalAlignment: MSTextStyleVerticalAlignment): void;
}
declare const _MSTextStyle: {
  alloc(): _MSTextStyleAllocator;
}

interface _MSTriangleShapeAllocator<InitializedType = _MSTriangleShape> extends MSShapePathLayerAllocator<_MSTriangleShape> {}
interface _MSTriangleShape extends MSShapePathLayer {

  isEquilateral(): boolean;
  setIsEquilateral(isEquilateral: boolean): void;
}
declare const _MSTriangleShape: {
  alloc(): _MSTriangleShapeAllocator;
}

interface MSImmutableArrayAllocator<InitializedType = MSImmutableArray> extends MSImmutableModelObjectAllocator<MSImmutableArray> {}
interface MSImmutableArray extends MSImmutableModelObject {
}
declare const MSImmutableArray: {
  alloc(): MSImmutableArrayAllocator;
}

interface MSImmutableAssetCollectionAllocator<InitializedType = MSImmutableAssetCollection> extends _MSImmutableAssetCollectionAllocator<MSImmutableAssetCollection> {}
interface MSImmutableAssetCollection extends _MSImmutableAssetCollection {
}
declare const MSImmutableAssetCollection: {
  alloc(): MSImmutableAssetCollectionAllocator;
}

interface MSImmutableBaseGridAllocator<InitializedType = MSImmutableBaseGrid> extends _MSImmutableBaseGridAllocator<MSImmutableBaseGrid> {}
interface MSImmutableBaseGrid extends _MSImmutableBaseGrid {
  shouldDrawAtZoom(zoom: CGFloat): boolean;
}
declare const MSImmutableBaseGrid: {
  alloc(): MSImmutableBaseGridAllocator;  displayableAtZoom(zoom: CGFloat): boolean;

}

interface MSImmutableBitmapLayerAllocator<InitializedType = MSImmutableBitmapLayer> extends _MSImmutableBitmapLayerAllocator<MSImmutableBitmapLayer> {}
interface MSImmutableBitmapLayer extends _MSImmutableBitmapLayer {
  NSImage(): NSImage;

  fillReplacesImage(): boolean;
  setFillReplacesImage(fillReplacesImage: boolean): void;
  image(): MSImageData;
  setImage(image: MSImageData): void;
}
declare const MSImmutableBitmapLayer: {
  alloc(): MSImmutableBitmapLayerAllocator;
}

interface MSImmutableCurvePointAllocator<InitializedType = MSImmutableCurvePoint> extends _MSImmutableCurvePointAllocator<MSImmutableCurvePoint> {}
interface MSImmutableCurvePoint extends _MSImmutableCurvePoint, IMSCurvePoint {

  isStraight(): boolean;
  isRounded(): boolean;
  isEffectivelyStraight(): boolean;
}
declare const MSImmutableCurvePoint: {
  alloc(): MSImmutableCurvePointAllocator;
}

interface MSImmutableDocumentDataAllocator<InitializedType = MSImmutableDocumentData> extends _MSImmutableDocumentDataAllocator<MSImmutableDocumentData> {}
interface MSImmutableDocumentData extends _MSImmutableDocumentData, IMSDocumentData {
  defaultPagesArray(): NSArray<any>;
  usedFontNames(): NSSet<any>;
  pageWithID(pageID: NSString | string): MSImmutablePage;
  symbolWithID(objectID: NSString | string): MSImmutableSymbolMaster;
  artboardWithID(objectID: NSString | string | null): MSImmutableArtboardGroup;
  textStyleWithID(sharedStyleID: NSString | string | null): MSImmutableSharedStyle;
  layerStyleWithID(sharedStyleID: NSString | string | null): MSImmutableSharedStyle;
  artboardWithID_page(objectID: NSString | string, pageOut: MSImmutablePage): MSImmutableArtboardGroup;
  wasSavedByOldVersion(): boolean;
  wasSavedByTestVersion(): boolean;
  allArtboards(): NSArray<any>;
  allSymbols(): NSArray<any>;
  pagesAndArtboardsMetadata(): NSDictionary<any, any>;
  findFrequentColorsForUse_maximumColorCount_ignoreAlpha_excludeForeignSymbols_completionHandler(colorUse: MSColorUse, maxCount: NSUInteger, ignoreAlpha: boolean, excludeForeignSymbols: boolean, block: MSColorFinderCompletionBlock): void;
  trackColors_excludeForeignSymbols(tracker: MSFrequentColorTracker, excludeForeignSymbols: boolean): void;
  symbolsChangedSincePreviousDocument(lastImmutable: MSImmutableDocumentData): boolean;

  metadata(): NSDictionary<any, any>;
  currentPage(): MSImmutablePage;
  selectedOverrides(): NSArray<any>;
  fontNames(): NSSet<any>;
  unavailableFontNames(): NSSet<any>;
  containsUnavailableFontNames(): boolean;
}
declare const MSImmutableDocumentData: {
  alloc(): MSImmutableDocumentDataAllocator;  loadDocumentDataWithMetadata_loadBlock(metadata: NSDictionary<any, any> | {[key: string]: any}, loadBlock: Block): MSImmutableDocumentData;

}

interface MSImmutableExportFormatAllocator<InitializedType = MSImmutableExportFormat> extends _MSImmutableExportFormatAllocator<MSImmutableExportFormat> {}
interface MSImmutableExportFormat extends _MSImmutableExportFormat {
  exportScaleInRect(rect: NSRect): CGFloat;
  isVectorExport(): boolean;
}
declare const MSImmutableExportFormat: {
  alloc(): MSImmutableExportFormatAllocator;  defaultNameForScale(scale: CGFloat): NSString;

}

interface MSImmutableExportOptionsAllocator<InitializedType = MSImmutableExportOptions> extends _MSImmutableExportOptionsAllocator<MSImmutableExportOptions> {}
interface MSImmutableExportOptions extends _MSImmutableExportOptions {
  firstFormat(): NSString;
}
declare const MSImmutableExportOptions: {
  alloc(): MSImmutableExportOptionsAllocator;
}

interface MSImmutableExportPresetAllocator<InitializedType = MSImmutableExportPreset> extends _MSImmutableExportPresetAllocator<MSImmutableExportPreset> {}
interface MSImmutableExportPreset extends _MSImmutableExportPreset {
}
declare const MSImmutableExportPreset: {
  alloc(): MSImmutableExportPresetAllocator;
}

interface MSImmutableFlowConnectionAllocator<InitializedType = MSImmutableFlowConnection> extends _MSImmutableFlowConnectionAllocator<MSImmutableFlowConnection> {}
interface MSImmutableFlowConnection extends _MSImmutableFlowConnection {
  flowTypeForTransitionFromParentLayer_toArtboard(layer: MSImmutableLayerAncestry, artboard: MSImmutableLayerAncestry): MSFlowType;
  bezierPathForRenderingFlowFromParentLayer_toArtboard_zoomLevel(layer: MSImmutableLayerAncestry, destinationArtboard: MSImmutableLayerAncestry, zoomLevel: CGFloat): NSBezierPath;
  isValidFlowConnectionInDocumentData(documentData: MSImmutableDocumentData): boolean;

  isBackAction(): boolean;
}
declare const MSImmutableFlowConnection: {
  alloc(): MSImmutableFlowConnectionAllocator;
}

interface MSImmutableForeignLayerStyleAllocator<InitializedType = MSImmutableForeignLayerStyle> extends _MSImmutableForeignLayerStyleAllocator<MSImmutableForeignLayerStyle> {}
interface MSImmutableForeignLayerStyle extends _MSImmutableForeignLayerStyle {
}
declare const MSImmutableForeignLayerStyle: {
  alloc(): MSImmutableForeignLayerStyleAllocator;
}

interface MSImmutableForeignObjectAllocator<InitializedType = MSImmutableForeignObject> extends _MSImmutableForeignObjectAllocator<MSImmutableForeignObject> {}
interface MSImmutableForeignObject extends _MSImmutableForeignObject {
}
declare const MSImmutableForeignObject: {
  alloc(): MSImmutableForeignObjectAllocator;
}

interface MSImmutableForeignStyleAllocator<InitializedType = MSImmutableForeignStyle> extends _MSImmutableForeignStyleAllocator<MSImmutableForeignStyle> {}
interface MSImmutableForeignStyle extends _MSImmutableForeignStyle {
}
declare const MSImmutableForeignStyle: {
  alloc(): MSImmutableForeignStyleAllocator;
}

interface MSImmutableForeignSymbolAllocator<InitializedType = MSImmutableForeignSymbol> extends _MSImmutableForeignSymbolAllocator<MSImmutableForeignSymbol> {}
interface MSImmutableForeignSymbol extends _MSImmutableForeignSymbol {
}
declare const MSImmutableForeignSymbol: {
  alloc(): MSImmutableForeignSymbolAllocator;
}

interface MSImmutableForeignTextStyleAllocator<InitializedType = MSImmutableForeignTextStyle> extends _MSImmutableForeignTextStyleAllocator<MSImmutableForeignTextStyle> {}
interface MSImmutableForeignTextStyle extends _MSImmutableForeignTextStyle {
}
declare const MSImmutableForeignTextStyle: {
  alloc(): MSImmutableForeignTextStyleAllocator;
}

interface MSImmutableGradientAllocator<InitializedType = MSImmutableGradient> extends _MSImmutableGradientAllocator<MSImmutableGradient> {}
interface MSImmutableGradient extends _MSImmutableGradient {
  defaultStopsArray(): NSArray<any>;
  conditionedEllipseLength(): CGFloat;
  pointAtIndex(index: NSUInteger): NSPoint;
  newCGGradientForColorSpace(colorSpace: CGColorSpaceRef): CGGradientRef;
  newCGGradientForColorSpace_colorConverter(colorSpace: CGColorSpaceRef, colorConverter: Block): CGGradientRef;
  NSGradientWithColorSpace(colorSpace: NSColorSpace): NSGradient;
  ellipseTransformInRect(aRect: NSRect): CGAffineTransform;
  angularGradientImageInRect_colorSpace(rect: CGRect, colorSpace: NSColorSpace): NSBitmapImageRep;
  drawFillInRect_forBorderThickness_context_cacheKey(rect: NSRect, thickness: CGFloat, context: MSRenderingContext, cacheKey: MSModelObjectCacheGeneration): void;

  hasOpacity(): boolean;
}
declare const MSImmutableGradient: {
  alloc(): MSImmutableGradientAllocator;  defaultGradientStops(): NSArray<any>;

}

interface MSImmutableGradientStopAllocator<InitializedType = MSImmutableGradientStop> extends _MSImmutableGradientStopAllocator<MSImmutableGradientStop> {
  initWithPosition_color(position: CGFloat, color: MSImmutableColor): InitializedType;
}
interface MSImmutableGradientStop extends _MSImmutableGradientStop {
}
declare const MSImmutableGradientStop: {
  alloc(): MSImmutableGradientStopAllocator;
}

interface MSImmutableGraphicsContextSettingsAllocator<InitializedType = MSImmutableGraphicsContextSettings> extends _MSImmutableGraphicsContextSettingsAllocator<MSImmutableGraphicsContextSettings> {}
interface MSImmutableGraphicsContextSettings extends _MSImmutableGraphicsContextSettings {
  shouldChangeGraphicsContext(): boolean;
  CGBlendMode(): CGBlendMode;
}
declare const MSImmutableGraphicsContextSettings: {
  alloc(): MSImmutableGraphicsContextSettingsAllocator;
}

interface MSImmutableImageCollectionAllocator<InitializedType = MSImmutableImageCollection> extends _MSImmutableImageCollectionAllocator<MSImmutableImageCollection> {}
interface MSImmutableImageCollection extends _MSImmutableImageCollection {
  imageWithSHA1(sha1: NSData): MSImageData;
}
declare const MSImmutableImageCollection: {
  alloc(): MSImmutableImageCollectionAllocator;
}

interface MSImmutableSymbolInstanceAllocator<InitializedType = MSImmutableSymbolInstance> extends _MSImmutableSymbolInstanceAllocator<MSImmutableSymbolInstance> {
  initWithGroupForMigration(group: MSImmutableLayerGroup): InitializedType;
}
interface MSImmutableSymbolInstance extends _MSImmutableSymbolInstance {
  isScaled(): boolean;
  availableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;
  cachedModifiedSymbolForMaster_document_cache(originalSymbol: MSImmutableSymbolMaster, doc: MSImmutableDocumentData, cache: BCCache): MSImmutableSymbolMaster;
  updateOverridesWithObjectIDMapping_afterChangingSymbolMasterWithID(objectIDMapping: NSDictionary<any, any> | {[key: string]: any}, symbolID: NSString | string): void;
  overridesWithGridIndexRemoved(overrides: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  overridePointsInDocument(document: MSImmutableDocumentData): NSArray<any>;
  calculateAvailableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;
  cachedModifiedSymbolForMaster_inContext(originalSymbol: MSImmutableSymbolMaster, context: MSRenderingContext): MSImmutableSymbolMaster;

  modifiedMasterCacheKey(): any;
  masterRefreshCounter(): NSUInteger;
  overrides(): NSDictionary<any, any>;
}
declare const MSImmutableSymbolInstance: {
  alloc(): MSImmutableSymbolInstanceAllocator;
}

interface IMSFlowContainmentCheck {
  firstFlowWithSymbolsFromDocument(document: MSImmutableDocumentData): MSImmutableFlowConnection;
  containsFlowWithSymbolsFromDocument(document: MSImmutableDocumentData): boolean;
}

interface MSImmutableLayoutGridAllocator<InitializedType = MSImmutableLayoutGrid> extends _MSImmutableLayoutGridAllocator<MSImmutableLayoutGrid> {}
interface MSImmutableLayoutGrid extends _MSImmutableLayoutGrid {
}
declare const MSImmutableLayoutGrid: {
  alloc(): MSImmutableLayoutGridAllocator;
}

interface MSImmutableModelObjectAllocator<InitializedType = MSImmutableModelObject> extends MSModelObjectCommonAllocator<MSImmutableModelObject> {
  initWithMutableModelObject(object: MSModelObject): InitializedType;
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): InitializedType;
}
interface MSImmutableModelObject extends MSModelObjectCommon, IMSModelObject, IMSCoding {
  differsFromObject(object: MSImmutableModelObject): boolean;
  shouldDiffSubObjectsForDifferingObject(objet: MSImmutableModelObject): boolean;
  newMutableCounterpart(): any;
  isEqualForDiffToObject(otherObject: any): boolean;
  keysDifferingFromObject(object: MSImmutableModelObject): NSSet<any>;
  encodePropertiesWithCoder(coder: MSBaseArchiver): void;
  decodePropertiesWithUnarchiver(coder: MSBaseUnarchiver): void;
  performInitWithMutableModelObject(object: MSModelObject): void;
  performInitWithUnarchiver(coder: MSBaseUnarchiver): void;

  subObjectsForTreeDiff(): NSArray<any>;
}
declare const MSImmutableModelObject: {
  alloc(): MSImmutableModelObjectAllocator;  mutableClass(): any;
  traitsForPropertyName(name: NSString | string): MSPropertyTraits;

}

declare enum MSPropertyTraits {
  MSPropertyTraitNone = 0,
  MSPropertyTraitInfluencesContentRender = 1<<1,
  MSPropertyTraitInfluencesOverlayRender = 1<<2,
  MSPropertyTraitChangesHistory = 1<<3,
  MSPropertyTraitAmendsHistory = 1<<4,
  MSPropertyTraitInfluencesLayerStructure = 1<<5,
  MSPropertyTraitInfluencesMirror = 1<<6,
  MSPropertyTraitRequiresFullContentRefresh = 1<<7,
  MSPropertyTraitInfluencesLayerListPreview = 1<<8,
  MSPropertyTraitSharedObjectUpdated = 1<<9,
  MSPropertyTraitAll,
}

interface MSImmutableOvalShapeAllocator<InitializedType = MSImmutableOvalShape> extends _MSImmutableOvalShapeAllocator<MSImmutableOvalShape> {}
interface MSImmutableOvalShape extends _MSImmutableOvalShape {
}
declare const MSImmutableOvalShape: {
  alloc(): MSImmutableOvalShapeAllocator;
}

interface MSImmutableOverrideValueAllocator<InitializedType = MSImmutableOverrideValue> extends _MSImmutableOverrideValueAllocator<MSImmutableOverrideValue> {
  initWithName_value(name: NSString | string, value: NSObject): InitializedType;
}
interface MSImmutableOverrideValue extends _MSImmutableOverrideValue {

  attributeName(): NSString;
  path(): NSString;
}
declare const MSImmutableOverrideValue: {
  alloc(): MSImmutableOverrideValueAllocator;  overrideValuesFromDictionary(dict: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  dictionaryFromOverrideValues(overrideValues: NSArray<any> | any[] | null): NSDictionary<any, any>;

}

interface MSImmutablePersistentAssetCollectionAllocator<InitializedType = MSImmutablePersistentAssetCollection> extends MSImmutableAssetCollectionAllocator<MSImmutablePersistentAssetCollection> {}
interface MSImmutablePersistentAssetCollection extends MSImmutableAssetCollection {
}
declare const MSImmutablePersistentAssetCollection: {
  alloc(): MSImmutablePersistentAssetCollectionAllocator;
}

interface MSImmutablePolygonShapeAllocator<InitializedType = MSImmutablePolygonShape> extends _MSImmutablePolygonShapeAllocator<MSImmutablePolygonShape> {}
interface MSImmutablePolygonShape extends _MSImmutablePolygonShape {
}
declare const MSImmutablePolygonShape: {
  alloc(): MSImmutablePolygonShapeAllocator;
}

interface MSImmutableRectAllocator<InitializedType = MSImmutableRect> extends _MSImmutableRectAllocator<MSImmutableRect> {
  initWithRect(aRect: NSRect): InitializedType;
  initWithRect_constrainProportions(aRect: NSRect, constraintProportions: boolean): InitializedType;
}
interface MSImmutableRect extends _MSImmutableRect, IMSRect {
}
declare const MSImmutableRect: {
  alloc(): MSImmutableRectAllocator;
}

interface MSImmutableRectangleShapeAllocator<InitializedType = MSImmutableRectangleShape> extends _MSImmutableRectangleShapeAllocator<MSImmutableRectangleShape> {}
interface MSImmutableRectangleShape extends _MSImmutableRectangleShape {
}
declare const MSImmutableRectangleShape: {
  alloc(): MSImmutableRectangleShapeAllocator;
}

interface MSImmutableRulerDataAllocator<InitializedType = MSImmutableRulerData> extends _MSImmutableRulerDataAllocator<MSImmutableRulerData> {}
interface MSImmutableRulerData extends _MSImmutableRulerData {
}
declare const MSImmutableRulerData: {
  alloc(): MSImmutableRulerDataAllocator;
}

interface MSImmutableShapePathAllocator<InitializedType = MSImmutableShapePath> extends _MSImmutableShapePathAllocator<MSImmutableShapePath> {}
interface MSImmutableShapePath extends _MSImmutableShapePath {
}
declare const MSImmutableShapePath: {
  alloc(): MSImmutableShapePathAllocator;
}

interface MSImmutableSharedObjectAllocator<InitializedType = MSImmutableSharedObject> extends _MSImmutableSharedObjectAllocator<MSImmutableSharedObject> {}
interface MSImmutableSharedObject extends _MSImmutableSharedObject {
}
declare const MSImmutableSharedObject: {
  alloc(): MSImmutableSharedObjectAllocator;
}

interface MSImmutableSharedObjectContainerAllocator<InitializedType = MSImmutableSharedObjectContainer> extends _MSImmutableSharedObjectContainerAllocator<MSImmutableSharedObjectContainer> {}
interface MSImmutableSharedObjectContainer extends _MSImmutableSharedObjectContainer {
}
declare const MSImmutableSharedObjectContainer: {
  alloc(): MSImmutableSharedObjectContainerAllocator;
}

interface MSImmutableSharedStyleAllocator<InitializedType = MSImmutableSharedStyle> extends _MSImmutableSharedStyleAllocator<MSImmutableSharedStyle> {}
interface MSImmutableSharedStyle extends _MSImmutableSharedStyle {
}
declare const MSImmutableSharedStyle: {
  alloc(): MSImmutableSharedStyleAllocator;
}

interface MSImmutableSharedStyleContainerAllocator<InitializedType = MSImmutableSharedStyleContainer> extends _MSImmutableSharedStyleContainerAllocator<MSImmutableSharedStyleContainer> {}
interface MSImmutableSharedStyleContainer extends _MSImmutableSharedStyleContainer {
}
declare const MSImmutableSharedStyleContainer: {
  alloc(): MSImmutableSharedStyleContainerAllocator;
}

interface MSImmutableSharedTextStyleContainerAllocator<InitializedType = MSImmutableSharedTextStyleContainer> extends _MSImmutableSharedTextStyleContainerAllocator<MSImmutableSharedTextStyleContainer> {}
interface MSImmutableSharedTextStyleContainer extends _MSImmutableSharedTextStyleContainer {
}
declare const MSImmutableSharedTextStyleContainer: {
  alloc(): MSImmutableSharedTextStyleContainerAllocator;
}

interface MSImmutableSimpleGridAllocator<InitializedType = MSImmutableSimpleGrid> extends _MSImmutableSimpleGridAllocator<MSImmutableSimpleGrid> {}
interface MSImmutableSimpleGrid extends _MSImmutableSimpleGrid {
}
declare const MSImmutableSimpleGrid: {
  alloc(): MSImmutableSimpleGridAllocator;
}

interface MSImmutableStarShapeAllocator<InitializedType = MSImmutableStarShape> extends _MSImmutableStarShapeAllocator<MSImmutableStarShape> {}
interface MSImmutableStarShape extends _MSImmutableStarShape {
}
declare const MSImmutableStarShape: {
  alloc(): MSImmutableStarShapeAllocator;
}

interface MSImmutableStyleAllocator<InitializedType = MSImmutableStyle> extends _MSImmutableStyleAllocator<MSImmutableStyle> {}
interface MSImmutableStyle extends _MSImmutableStyle {
  clearTextStyle(): void;
  boundingBoxForBiggestShadowSpreadForLayer(layer: MSImmutableLayer): NSRect;
  boundsForPath(path: MSPath): CGRect;
  renderBitmapEffects_bounds_parentCoordinateTransform(image: CIImage, bounds: CGRect, parentCoordinateTransform: CGAffineTransform): CIImage;
  requiresPathDefinition(exporter: SketchSVGExporter): boolean;
  numberOfElementsWithExporter(exporter: SketchSVGExporter): NSUInteger;
  addSVGAttributes_exporter_elementPosition(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter, position: NSUInteger): void;
  borderAtElementPosition_exporter(position: NSInteger, exporter: SketchSVGExporter): MSImmutableStyleBorder;
  fillAtElementPosition_exporter(position: NSInteger, exporter: SketchSVGExporter): MSImmutableStyleFill;

  hasMarkers(): boolean;
  hasMoreThanOneEnabledFill(): boolean;
  hasEnabledShadow(): boolean;
  hasEnabledInnerShadow(): boolean;
  hasEnabledBorder(): boolean;
  hasEnabledFill(): boolean;
  hasBlending(): boolean;
  thickestStroke(): CGFloat;
  thickestInnerStroke(): CGFloat;
  outerPaddingForBiggestStroke(): CGFloat;
  outerPaddingForBiggestShadowSpread(): CGFloat;
  hasEnabledBackgroundBlur(): boolean;
  shadowType(): MSShadowType;
  shadowStrokeType(): MSShadowBorderType;
  firstEnabledShadow(): MSImmutableStyleShadow;
  firstEnabledInnerShadow(): MSImmutableStyleInnerShadow;
  firstEnabledFill(): MSImmutableStyleFill;
  firstEnabledBorder(): MSImmutableStyleBorder;
  enabledFills(): NSArray<any>;
  enabledBorders(): NSArray<any>;
  enabledShadows(): NSArray<any>;
  enabledInnerShadows(): NSArray<any>;
  hasEnabledOpaqueFill(): boolean;
  renderableFills(): NSArray<any>;
}
declare const MSImmutableStyle: {
  alloc(): MSImmutableStyleAllocator;
}

interface MSImmutableStyleBasicFillAllocator<InitializedType = MSImmutableStyleBasicFill> extends _MSImmutableStyleBasicFillAllocator<MSImmutableStyleBasicFill> {}
interface MSImmutableStyleBasicFill extends _MSImmutableStyleBasicFill {

  hasOpacity(): boolean;
}
declare const MSImmutableStyleBasicFill: {
  alloc(): MSImmutableStyleBasicFillAllocator;
}

interface MSImmutableStyleBlurAllocator<InitializedType = MSImmutableStyleBlur> extends _MSImmutableStyleBlurAllocator<MSImmutableStyleBlur> {}
interface MSImmutableStyleBlur extends _MSImmutableStyleBlur {
  cropRadius(): CGFloat;
  renderBitmapEffects_bounds_parentCoordinateTransform(image: CIImage, bounds: CGRect, parentCoordinateTransform: CGAffineTransform): CIImage;
  shouldUseCoreImageForEffect(): boolean;
  addFilterWithExporter(exporter: SketchSVGExporter): void;
}
declare const MSImmutableStyleBlur: {
  alloc(): MSImmutableStyleBlurAllocator;
}

interface MSImmutableStyleBorderAllocator<InitializedType = MSImmutableStyleBorder> extends _MSImmutableStyleBorderAllocator<MSImmutableStyleBorder> {}
interface MSImmutableStyleBorder extends _MSImmutableStyleBorder {
  drawBorder_advancedOptions_context(path: MSPath, advanced: MSImmutableStyleBorderOptions, context: MSRenderingContext): void;
  drawGradientBorder_advancedOptions_originalPath_isArtistic_frame_context(path: MSPath, advanced: MSImmutableStyleBorderOptions, original: MSPath, isArtistic: boolean, rect: NSRect, context: MSRenderingContext): void;
  pathWithExporter(exporter: SketchSVGExporter): MSPath;
  requiresMask(borderOptions: MSImmutableStyleBorderOptions): boolean;
  needsOutlinePath(borderOptions: MSImmutableStyleBorderOptions): boolean;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  borderInset(): CGFloat;
}
declare const MSImmutableStyleBorder: {
  alloc(): MSImmutableStyleBorderAllocator;
}

interface MSImmutableStyleBorderOptionsAllocator<InitializedType = MSImmutableStyleBorderOptions> extends _MSImmutableStyleBorderOptionsAllocator<MSImmutableStyleBorderOptions> {}
interface MSImmutableStyleBorderOptions extends _MSImmutableStyleBorderOptions {
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  CGLineJoin(): CGLineJoin;
  CGLineCap(): CGLineCap;
  hasDashPattern(): boolean;
}
declare const MSImmutableStyleBorderOptions: {
  alloc(): MSImmutableStyleBorderOptionsAllocator;
}

interface MSImmutableStyleColorControlsAllocator<InitializedType = MSImmutableStyleColorControls> extends _MSImmutableStyleColorControlsAllocator<MSImmutableStyleColorControls> {}
interface MSImmutableStyleColorControls extends _MSImmutableStyleColorControls {
  renderBitmapEffects(image: CIImage): CIImage;
}
declare const MSImmutableStyleColorControls: {
  alloc(): MSImmutableStyleColorControlsAllocator;
}

interface MSImmutableStyleFillAllocator<InitializedType = MSImmutableStyleFill> extends _MSImmutableStyleFillAllocator<MSImmutableStyleFill> {}
interface MSImmutableStyleFill extends _MSImmutableStyleFill {
  NSImage(): NSImage;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  hasOpacity(): boolean;
}
declare const MSImmutableStyleFill: {
  alloc(): MSImmutableStyleFillAllocator;
}

interface MSImmutableStyleInnerShadowAllocator<InitializedType = MSImmutableStyleInnerShadow> extends _MSImmutableStyleInnerShadowAllocator<MSImmutableStyleInnerShadow> {}
interface MSImmutableStyleInnerShadow extends _MSImmutableStyleInnerShadow {
}
declare const MSImmutableStyleInnerShadow: {
  alloc(): MSImmutableStyleInnerShadowAllocator;
}

interface MSImmutableStylePartAllocator<InitializedType = MSImmutableStylePart> extends _MSImmutableStylePartAllocator<MSImmutableStylePart> {}
interface MSImmutableStylePart extends _MSImmutableStylePart, IMSStylePart {
}
declare const MSImmutableStylePart: {
  alloc(): MSImmutableStylePartAllocator;
}

interface MSImmutableStyleShadowAllocator<InitializedType = MSImmutableStyleShadow> extends _MSImmutableStyleShadowAllocator<MSImmutableStyleShadow> {}
interface MSImmutableStyleShadow extends _MSImmutableStyleShadow {
  addSpread_withInput_output_filter(spread: CGFloat, input: NSString | string, output: NSString | string, filter: MSSVGFilter): MSSVGMorphology;
  addBlurWithRadius_input_output_filter(radius: CGFloat, input: NSString | string, output: NSString | string, filter: MSSVGFilter): MSSVGGaussianBlur;
  addCompositeMask_mask_output_filter(src: NSString | string, mask: NSString | string, output: NSString | string, filter: MSSVGFilter): MSSVGComposite;
  addOffsetTo_dx_dy_output_filter(input: NSString | string, dx: CGFloat, dy: CGFloat, output: NSString | string, filter: MSSVGFilter): MSSVGOffset;
  addColorMatrix_color_output_filter(input: NSString | string, color: MSImmutableColor, output: NSString | string, filter: MSSVGFilter): MSSVGColorMatrix;
  addSVGFilterWithParent_exporter_index(parent: MSImmutableStyle, exporter: SketchSVGExporter, index: NSUInteger): void;
}
declare const MSImmutableStyleShadow: {
  alloc(): MSImmutableStyleShadowAllocator;
}

declare enum MSShadowType {
  MSShadowFill = 1 << 0,
  MSShadowStroke = 1 << 1,
}

declare enum MSShadowBorderType {
  MSShadowBorderCenter = 0,
  MSShadowBorderInside = 1,
  MSShadowBorderOutside = 2,
}

interface MSImmutableSymbolAllocator<InitializedType = MSImmutableSymbol> extends _MSImmutableSymbolAllocator<MSImmutableSymbol> {}
interface MSImmutableSymbol extends _MSImmutableSymbol {
  masterInstance(): MSImmutableLayerGroup;
}
declare const MSImmutableSymbol: {
  alloc(): MSImmutableSymbolAllocator;
}

interface MSImmutableSymbolContainerAllocator<InitializedType = MSImmutableSymbolContainer> extends _MSImmutableSymbolContainerAllocator<MSImmutableSymbolContainer> {}
interface MSImmutableSymbolContainer extends _MSImmutableSymbolContainer {
}
declare const MSImmutableSymbolContainer: {
  alloc(): MSImmutableSymbolContainerAllocator;
}

interface MSImmutableSymbolMasterAllocator<InitializedType = MSImmutableSymbolMaster> extends _MSImmutableSymbolMasterAllocator<MSImmutableSymbolMaster> {}
interface MSImmutableSymbolMaster extends _MSImmutableSymbolMaster {
  modifiedMasterByApplyingInstance_inDocument(instance: MSImmutableSymbolInstance, document: MSImmutableDocumentData): MSImmutableSymbolMaster;
  influenceRectPaddingForInstancesInDocument_visitedSymbols(doc: MSImmutableDocumentData, visitedSymbols: NSSet<any>): BCEdgePaddings;
  availableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;
  calculateAvailableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;

  changeIdentifier(): NSInteger;
}
declare const MSImmutableSymbolMaster: {
  alloc(): MSImmutableSymbolMasterAllocator;
}

interface MSImmutableTextLayerAllocator<InitializedType = MSImmutableTextLayer> extends _MSImmutableTextLayerAllocator<MSImmutableTextLayer> {}
interface MSImmutableTextLayer extends _MSImmutableTextLayer, IMSFirstLineTypesetterDelegate {
  defaultLineHeight(layoutManager: NSLayoutManager): CGFloat;
  startingPositionOnPath(shape: NSBezierPath): CGFloat;
  textContainerSize(): NSSize;
  shapeToUseForTextOnPathWithParentGroup(parentGroup: MSImmutableLayerGroup): MSImmutableStyledLayer;
  firstUnderlyingShapePathWithParentGroup(parentGroup: MSImmutableLayerGroup): NSBezierPath;
  bezierPathFromGlyphsInBoundsWithParentGroup_layoutManager(parentGroup: MSImmutableLayerGroup | null, layoutManager: NSLayoutManager): NSBezierPath;
  usedFontNames(): NSSet<any>;
  drawingPointForText(): NSPoint;
  createTextStorage(): NSTextStorage;
  textStoragePoolInCache(cache: BCCache): MSTextStoragePool;

  fontSize(): CGFloat;
  stringValue(): NSString;
  attributedStringValue(): NSAttributedString;
  textAlignment(): NSTextAlignment;
  drawingPointForText(): NSPoint;
  textLayout(): MSTextLayout;
  transientGlyphBoundsValue(): NSValue;
  setTransientGlyphBoundsValue(transientGlyphBoundsValue: NSValue): void;
  capHeightBounds(): CGRect;
  shouldUseBezierRepresentationForRendering(): boolean;
  isEditingText(): boolean;
}
declare const MSImmutableTextLayer: {
  alloc(): MSImmutableTextLayerAllocator;
}

interface MSImmutableTextStyleAllocator<InitializedType = MSImmutableTextStyle> extends _MSImmutableTextStyleAllocator<MSImmutableTextStyle> {}
interface MSImmutableTextStyle extends _MSImmutableTextStyle {

  attributes(): NSDictionary<any, any>;
}
declare const MSImmutableTextStyle: {
  alloc(): MSImmutableTextStyleAllocator;
}

interface MSImmutableTriangleShapeAllocator<InitializedType = MSImmutableTriangleShape> extends _MSImmutableTriangleShapeAllocator<MSImmutableTriangleShape> {}
interface MSImmutableTriangleShape extends _MSImmutableTriangleShape {
}
declare const MSImmutableTriangleShape: {
  alloc(): MSImmutableTriangleShapeAllocator;
}

interface MSAbsoluteRectAllocator<InitializedType = MSAbsoluteRect> extends BCRectAllocator<MSAbsoluteRect> {
  initWithLayer(layer: MSLayer): InitializedType;
}
interface MSAbsoluteRect extends BCRect {
  boundsContainsPoint(mouse: NSPoint): boolean;

  rulerOrigin(): CGPoint;
  setRulerOrigin(rulerOrigin: CGPoint): void;
}
declare const MSAbsoluteRect: {
  alloc(): MSAbsoluteRectAllocator;
}

interface MSAdaptableColorAllocator<InitializedType = MSAdaptableColor> extends NSColorAllocator<MSAdaptableColor> {}
interface MSAdaptableColor extends NSColor {
}
declare const MSAdaptableColor: {
  alloc(): MSAdaptableColorAllocator;
}

interface MSApplicationMetadataAllocator<InitializedType = MSApplicationMetadata> extends NSObjectAllocator<MSApplicationMetadata> {}
interface MSApplicationMetadata extends NSObject {
}
declare const MSApplicationMetadata: {
  alloc(): MSApplicationMetadataAllocator;  metadata(): NSDictionary<any, any>;
  applicationKeys(): NSArray<any>;

}

interface MSArchiveHeaderAllocator<InitializedType = MSArchiveHeader> extends NSObjectAllocator<MSArchiveHeader> {
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): InitializedType;
}
interface MSArchiveHeader extends NSObject, IMSCoding {

  version(): NSInteger;
  setVersion(version: NSInteger): void;
  compatibilityVersion(): NSInteger;
  setCompatibilityVersion(compatibilityVersion: NSInteger): void;
  metadata(): NSDictionary<any, any>;
  setMetadata(metadata: NSDictionary<any, any> | {[key: string]: any}): void;
  root(): any;
  setRoot(root: any): void;
}
declare const MSArchiveHeader: {
  alloc(): MSArchiveHeaderAllocator;  metadataForNewHeader(): NSDictionary<any, any>;

}

interface IMSArtboardGroup {
}

interface MSArtboardPresetAllocator<InitializedType = MSArtboardPreset> extends NSObjectAllocator<MSArtboardPreset> {
  initWithName_size_imageName(name: NSString | string, size: NSSize, imageName: NSString | string | null): InitializedType;
  initWithDictionaryRepresentation(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface MSArtboardPreset extends NSObject, INSCopying {
  oppositeOrientationPreset(): MSArtboardPreset;

  name(): NSString;
  setName(name: NSString | string): void;
  layerName(): NSString;
  size(): NSSize;
  setSize(size: NSSize): void;
  sizeDescription(): NSString;
  offersLandscapeVariant(): boolean;
  allowResizedMatching(): boolean;
  imageName(): NSString;
  image(): NSImage;
  tooltip(): NSString;
  isSizeToFit(): boolean;
  isNew(): boolean;
  dictionaryRepresentation(): NSDictionary<any, any>;
}
declare const MSArtboardPreset: {
  alloc(): MSArtboardPresetAllocator;  sizeToFitPresetWithName_size(name: NSString | string, size: NSSize): MSArtboardPreset;

}

interface MSArtboardPresetStoreAllocator<InitializedType = MSArtboardPresetStore> extends NSObjectAllocator<MSArtboardPresetStore> {}
interface MSArtboardPresetStore extends NSObject {
  presetWithSize_preferredCategory(size: NSSize, preferredCategory: MSArtboardPresetsCategory | null): MSArtboardPreset;
  resizablePresetMatchingSize_preferredCategory(size: NSSize, preferredCategory: MSArtboardPresetsCategory | null): MSArtboardPreset;
  savePreset_error(newPreset: MSArtboardPreset, error: NSError): boolean;
  removePreset_error(aPreset: MSArtboardPreset, error: NSError): boolean;
  suggestedNameForUserPreset(): NSString;
  systemCategories(): NSArray<any>;

  categories(): NSArray<any>;
  customPresetsCategory(): MSArtboardPresetsCategory;
}
declare const MSArtboardPresetStore: {
  alloc(): MSArtboardPresetStoreAllocator;
  indexOfLastSelectedCategory(): NSUInteger;
  setIndexOfLastSelectedCategory(indexOfLastSelectedCategory: NSUInteger): void;

}

interface MSArtboardPresetsCategoryAllocator<InitializedType = MSArtboardPresetsCategory> extends NSObjectAllocator<MSArtboardPresetsCategory> {
  initWithName_sections(name: NSString | string, sections: NSArray<any> | any[]): InitializedType;
  initWithDictionaryRepresentation(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface MSArtboardPresetsCategory extends NSObject {

  name(): NSString;
  sections(): NSArray<any>;
}
declare const MSArtboardPresetsCategory: {
  alloc(): MSArtboardPresetsCategoryAllocator;  categoriesWithContentsOfURL(url: NSURL): NSArray<any>;

}

interface MSArtboardPresetsSectionAllocator<InitializedType = MSArtboardPresetsSection> extends NSObjectAllocator<MSArtboardPresetsSection> {
  initWithName_presets(name: NSString | string | null, presets: NSArray<any> | any[]): InitializedType;
  initWithDictionaryRepresentation(dictionary: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface MSArtboardPresetsSection extends NSObject {

  name(): NSString;
  presets(): NSArray<any>;
  dictionaryRepresentation(): NSDictionary<any, any>;
}
declare const MSArtboardPresetsSection: {
  alloc(): MSArtboardPresetsSectionAllocator;  sectionsWithContentsOfURL(url: NSURL): NSArray<any>;
  writeSections_toURL_error(collections: NSArray<any> | any[], url: NSURL, error: NSError): boolean;

}

interface MSAssetCollectionAllocator<InitializedType = MSAssetCollection> extends _MSAssetCollectionAllocator<MSAssetCollection> {}
interface MSAssetCollection extends _MSAssetCollection {
  numberOfAssetsOfType(type: MSAsset): NSUInteger;
  addAsset(asset: any): void;
  assetAtIndex_ofType(index: NSUInteger, type: MSAsset): any;
  removeAssetAtIndex_ofType(index: NSUInteger, type: MSAsset): void;
  indexesOfAsset(asset: any): NSIndexSet;
  moveAssetAtIndex_beforeObjectAtIndex_ofType(fromIndex: NSUInteger, toIndex: NSUInteger, type: MSAsset): boolean;
}
declare const MSAssetCollection: {
  alloc(): MSAssetCollectionAllocator;
}

interface MSColorAllocator<InitializedType = MSColor> extends _MSColorAllocator<MSColor> {
  initWithImmutableObject(immutableColor: MSImmutableColor): InitializedType;
}
interface MSColor extends _MSColor, IMSColor {
  RGBADictionary(): NSDictionary<any, any>;
  scaledColor(scale: CGFloat): MSColor;
  colorWithAlphaComponent(alpha: CGFloat): MSColor;
  NSColorWithColorSpace(space: NSColorSpace): NSColor;
  fuzzyIsEqual(other: MSColor): boolean;
  fuzzyIsEqual_precision(other: MSColor, precision: CGFloat): boolean;
  fuzzyIsEqualExcludingAlpha(other: MSColor): boolean;
  fuzzyIsEqualExcludingAlpha_precision(other: MSColor, precision: CGFloat): boolean;
}
declare const MSColor: {
  alloc(): MSColorAllocator;  colorWithRGBADictionary(dict: NSDictionary<any, any> | {[key: string]: any}): any;
  colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): MSColor;
  colorWithHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): MSColor;
  colorWithNSColor(color: NSColor): MSColor;
  whiteColor(): MSColor;
  blackColor(): MSColor;

}

interface MSGradientAllocator<InitializedType = MSGradient> extends _MSGradientAllocator<MSGradient> {
  initBlankGradient(): InitializedType;
  initWithNSGradient(nsGradient: NSGradient): InitializedType;
}
interface MSGradient extends _MSGradient {
  NSGradientWithColorSpace(colorSpace: NSColorSpace): NSGradient;
  conditionedEllipseLength(): CGFloat;
  pointAtIndex(index: NSUInteger): NSPoint;
  setPoint_atIndex(point: NSPoint, index: NSUInteger): void;
  colorAtIndex(index: NSUInteger): MSColor;
  setColor_atIndex(color: MSColor, index: NSUInteger): void;
  addStopAtPosition(relativePoint: NSPoint): NSInteger;
  addStopAtLength(position: CGFloat): NSUInteger;
  removeStopAtIndex(index: NSUInteger): void;
  convertPointToPosition(p: NSPoint): CGFloat;
  stopAtIndex(index: NSUInteger): MSGradientStop;
  invert(): void;
  rotatePointsBy(degrees: CGFloat): void;
  hasOpacity(): boolean;
  CSSAttributeStringWithMasterAlpha(masterAlpha: CGFloat): NSString;

  svgPositionIsAbsolute(): boolean;
  setSvgPositionIsAbsolute(svgPositionIsAbsolute: boolean): void;
}
declare const MSGradient: {
  alloc(): MSGradientAllocator;
}

interface MSImageDataAllocator<InitializedType = MSImageData> extends NSObjectAllocator<MSImageData> {
  initWithImage(image: NSImage): InitializedType;
  initWithData_sha(data: NSData, sha1: NSData | null): InitializedType;
  initWithLegacyHash(sha1: NSData): InitializedType;
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): InitializedType;
}
interface MSImageData extends NSObject, INSCopying, IMSCoding, IMSJSONArchiverAlternativeFileReference {
  CGImageSuitableForDrawingWithSize(size: CGSize): CGImageRef;
  isLegacy(): boolean;
  correctInvalidGamma(): void;

  data(): NSData;
  sha1(): NSData;
  image(): NSImage;
  cgImage(): CGImageRef;
}
declare const MSImageData: {
  alloc(): MSImageDataAllocator;
}

interface MSExportPresetAllocator<InitializedType = MSExportPreset> extends _MSExportPresetAllocator<MSExportPreset> {
  initWithName_formats(name: NSString | string, formats: NSArray<any> | any[]): InitializedType;
}
interface MSExportPreset extends _MSExportPreset, IMSExportFormatContainer {
}
declare const MSExportPreset: {
  alloc(): MSExportPresetAllocator;
}

interface IMSAsset {
  assetType(): MSAsset;
  isAssetEqual(object: any): boolean;
}

declare enum MSAsset {
  MSAssetColor,
  MSAssetGradient,
  MSAssetImage,
  MSAssetSymbol,
  MSAssetExportPreset,
}

interface MSAttributedStringAllocator<InitializedType = MSAttributedString> extends NSObjectAllocator<MSAttributedString> {
  initWithAttributedString_colorSpace_convert(attributedString: NSAttributedString, colorSpace: NSColorSpace, convert: boolean): InitializedType;
  initWithAttributedString_documentColorSpace(attributedString: NSAttributedString, colorSpace: NSColorSpace): InitializedType;
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): InitializedType;
}
interface MSAttributedString extends NSObject, IMSCoding, INSCopying {
  attributedStringByReplacingFontNames(fontNames: NSDictionary<any, any> | {[key: string]: any}): MSAttributedString;
  resetComputedProperties(): void;

  attributedString(): NSAttributedString;
  transformedAttributedString(): NSAttributedString;
  fontDescriptors(): NSSet<any>;
  fontNames(): NSSet<any>;
  unavailableFontNames(): NSSet<any>;
  areRequiredFontsAvailable(): boolean;
  string(): NSString;
}
declare const MSAttributedString: {
  alloc(): MSAttributedStringAllocator;  encodeAttributesInDictionary(attrs: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  decodeAttributesInDictionary(attrs: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  isRequiredFontAvailableInDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): boolean;
  fontDescriptorInDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): NSFontDescriptor;

}

declare enum MSAttributedStringTextTransform {
  MSAttributedStringTextTransformNone = 0,
  MSAttributedStringTextTransformUppercase,
  MSAttributedStringTextTransformLowercase,
}

interface MSAttributedStringAttributeAllocator<InitializedType = MSAttributedStringAttribute> extends NSObjectAllocator<MSAttributedStringAttribute> {
  initWithJSONDecoder(decoder: BCJSONDecoder): InitializedType;
}
interface MSAttributedStringAttribute extends NSObject, IBCJSONEncoding {

  range(): NSRange;
  setRange(range: NSRange): void;
  attributeDictionary(): NSDictionary<any, any>;
  setAttributeDictionary(attributeDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const MSAttributedStringAttribute: {
  alloc(): MSAttributedStringAttributeAllocator;
}

interface MSAvailableOverrideAllocator<InitializedType = MSAvailableOverride> extends NSObjectAllocator<MSAvailableOverride> {}
interface MSAvailableOverride extends NSObject {

  parent(): MSAvailableOverride;
  master(): MSImmutableSymbolMaster;
  affectedLayer(): MSImmutableLayer;
  overridePoint(): MSOverridePoint;
  children(): NSArray<any>;
  overrideValue(): any;
  currentValue(): any;
  defaultValue(): any;
  hasOverride(): boolean;
  isEditable(): boolean;
}
declare const MSAvailableOverride: {
  alloc(): MSAvailableOverrideAllocator;  availableOverrideWithOverridePoint_master_overrideValue_otherOverrides_inParent_document(overridePoint: MSOverridePoint, master: MSImmutableSymbolMaster, overrideValue: MSOverrideValue | null, otherOverrides: NSArray<any> | any[], parent: MSAvailableOverride | null, document: MSImmutableDocumentData): MSAvailableOverride;
  enumerateOverrides_withBlock(overrides: NSArray<any> | any[], block: Block): void;
  flattenAvailableOverrides(overrides: NSArray<any> | any[]): NSArray<any>;

}

interface MSBaseArchiverAllocator<InitializedType = MSBaseArchiver> extends NSObjectAllocator<MSBaseArchiver> {}
interface MSBaseArchiver extends NSObject {
  archiveRootObject(root: NSObject): void;
  shouldEncodeAsReference(object: NSObject | null): boolean;
  referenceObjectForObject(object: NSObject): NSObject;
  archivedDataWithRootObject_error(root: NSObject, error: NSError): NSData;
  encodeObject_forKey(object: NSObject | null, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeRect_forKey(rect: CGRect, key: NSString | string): void;
  encodePoint_forKey(point: CGPoint, key: NSString | string): void;
  encodeInteger_forKey(value: NSInteger, key: NSString | string): void;
  encodeSize_forKey(size: NSSize, key: NSString | string): void;

  archiveObjectIDs(): boolean;
  setArchiveObjectIDs(archiveObjectIDs: boolean): void;
}
declare const MSBaseArchiver: {
  alloc(): MSBaseArchiverAllocator;  archivedDataWithHeaderAndRootObject(root: NSObject): NSData;

}

interface MSBaseUnarchiverAllocator<InitializedType = MSBaseUnarchiver> extends NSObjectAllocator<MSBaseUnarchiver> {}
interface MSBaseUnarchiver extends NSObject {
  unarchiveObjectAsVersion_corruptionDetected_error(version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;
  decodeObjectOfClass_forKey(className: any, key: NSString | string): any;
  decodeObjectOfClasses_forKey(classes: NSSet<any> | null, key: NSString | string): any;
  instanciateObject(object: NSObject): any;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeDoubleForKey_withDefault(key: NSString | string, defaultValue: number): number;
  decodeBoolForKey_withDefault(key: NSString | string, defaultValue: boolean): boolean;
  decodeRectForKey_withDefault(key: NSString | string, defaultValue: CGRect): CGRect;
  decodePointForKey_withDefault(key: NSString | string, defaultValue: CGPoint): CGPoint;
  decodeIntegerForKey_withDefault(key: NSString | string, defaultValue: NSInteger): NSInteger;
  decodeSizeForKey_withDefault(key: NSString | string, defaultValue: CGSize): CGSize;

  currentVersion(): NSInteger;
  setCurrentVersion(currentVersion: NSInteger): void;
  archiveVersion(): NSInteger;
  setArchiveVersion(archiveVersion: NSInteger): void;
  corruptionDetected(): boolean;
  setCorruptionDetected(corruptionDetected: boolean): void;
  actualSymbolIDs(): NSArray<any>;
  setActualSymbolIDs(actualSymbolIDs: NSArray<any> | any[]): void;
}
declare const MSBaseUnarchiver: {
  alloc(): MSBaseUnarchiverAllocator;  unarchiveObjectWithData(data: NSData): any;
  unarchiveObjectWithData_actualVersion_error(data: NSData, actualVersion: MSDocumentVersion | null, error: NSError): any;
  unarchiveObjectWithData_asVersion_corruptionDetected_error(data: NSData, version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;

}

interface MSBezierBuilderAllocator<InitializedType = MSBezierBuilder> extends NSObjectAllocator<MSBezierBuilder> {
  initWithPointRadiusBehavior(pointRadiusBehaviour: MSPointRadiusBehaviour): InitializedType;
}
interface MSBezierBuilder extends NSObject {
  bezierPath(): NSBezierPath;
  path(): MSPath;
  _bezierPath(): NSBezierPath;

  pointRadiusBehaviour(): MSPointRadiusBehaviour;
}
declare const MSBezierBuilder: {
  alloc(): MSBezierBuilderAllocator;  bezierPathWithPoints_inRect_shouldClose_pointRadiusBehaviour(points: NSArray<any> | any[], rect: NSRect, shouldClose: boolean, pointRadiusBehaviour: MSPointRadiusBehaviour): NSBezierPath;
  pathWithPoints_inRect_shouldClose_pointRadiusBehaviour(points: NSArray<any> | any[], rect: NSRect, shouldClose: boolean, pointRadiusBehaviour: MSPointRadiusBehaviour): MSPath;
  bezierPathForSegmentAtIndex_inPath_inRect(index: NSUInteger, shapePath: MSShapePathLayer, rect: NSRect): NSBezierPath;

}

interface MSBezierContourAllocator<InitializedType = MSBezierContour> extends NSObjectAllocator<MSBezierContour> {
  initWithSegments_closed(segments: NSArray<any> | any[], isClosed: boolean): InitializedType;
}
interface MSBezierContour extends NSObject {
  reversedContour(): MSBezierContour;
  closedContour(): MSBezierContour;
  contourWithInset(inset: CGFloat): MSBezierContour;
  contourWithInset_joinStrategy(inset: CGFloat, strategy: MSBezierJoinStrategy): MSBezierContour;
  segmentBefore(segment: MSBezierSegment): MSBezierSegment;
  segmentAfter(segment: MSBezierSegment): MSBezierSegment;
  intersectionsWithSegment(segment: MSBezierSegment): NSSet<any>;

  closed(): boolean;
  clockwise(): boolean;
  segments(): NSArray<any>;
  bounds(): CGRect;
  path(): MSPath;
  isRectangular(): boolean;
}
declare const MSBezierContour: {
  alloc(): MSBezierContourAllocator;  contourWithRect(rect: CGRect): MSBezierContour;
  contourWithPolygonAtPoint_radius_sides(center: CGPoint, radius: CGFloat, sides: NSUInteger): MSBezierContour;

}

interface MSBezierCurveCurveJoinAllocator<InitializedType = MSBezierCurveCurveJoin> extends MSBezierLineCurveJoinAllocator<MSBezierCurveCurveJoin> {}
interface MSBezierCurveCurveJoin extends MSBezierLineCurveJoin {
}
declare const MSBezierCurveCurveJoin: {
  alloc(): MSBezierCurveCurveJoinAllocator;
}

interface MSBezierFilletAllocator<InitializedType = MSBezierFillet> extends NSObjectAllocator<MSBezierFillet> {
  initWithSegment1_segment2_segment1Offset_segment2Offset_arcEndPoint1_arcEndPoint2_arcCenter_arcRadius(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat, segment2Offset: CGFloat, arcEndPoint1: CGPoint, arcEndPoint2: CGPoint, arcCenter: CGPoint, arcRadius: CGFloat): InitializedType;
}
interface MSBezierFillet extends NSObject {
  reversedFillet(): MSBezierFillet;
  arcSegments(): NSArray<any>;
  addArcToBezierPath_orCGPath(bezierPath: NSBezierPath, pathRef: CGMutablePathRef): void;

  segment1(): MSBezierSegment;
  segment2(): MSBezierSegment;
  segment1Offset(): CGFloat;
  segment2Offset(): CGFloat;
  arcRadius(): CGFloat;
  arcEndPoint1(): CGPoint;
  arcEndPoint2(): CGPoint;
  arcCenter(): CGPoint;
  startAngle(): CGFloat;
  endAngle(): CGFloat;
  clockwise(): boolean;
}
declare const MSBezierFillet: {
  alloc(): MSBezierFilletAllocator;  bezierFilletWithSegment1_segment2_segment1Offset(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat): MSBezierFillet;
  bezierFilletWithSegment1_segment2_filletRadius(segment1: MSBezierSegment, segment2: MSBezierSegment, filletRadius: CGFloat): MSBezierFillet;
  zeroRadiusFilletWithSegment1_segment2(segment1: MSBezierSegment, segment2: MSBezierSegment): MSBezierFillet;

}

interface MSBezierInterpreterAllocator<InitializedType = MSBezierInterpreter> extends NSObjectAllocator<MSBezierInterpreter> {}
interface MSBezierInterpreter extends NSObject {
  points(): NSArray<any>;

  bezierPath(): NSBezierPath;
  setBezierPath(bezierPath: NSBezierPath): void;
  rect(): NSRect;
  setRect(rect: NSRect): void;
}
declare const MSBezierInterpreter: {
  alloc(): MSBezierInterpreterAllocator;  pointsFromBezierPath_inRect(bezierPath: NSBezierPath, rect: NSRect): NSArray<any>;

}

interface MSBezierIntersectionAllocator<InitializedType = MSBezierIntersection> extends NSObjectAllocator<MSBezierIntersection> {
  initWithSegment1_segment2_segment1Offset_segment2Offset(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat, segment2Offset: CGFloat): InitializedType;
}
interface MSBezierIntersection extends NSObject {

  segment1(): MSBezierSegment;
  segment2(): MSBezierSegment;
  segment1Offset(): CGFloat;
  segment2Offset(): CGFloat;
}
declare const MSBezierIntersection: {
  alloc(): MSBezierIntersectionAllocator;  intersectionWithSegment1_segment2_segment1Offset_segment2Offset(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat, segment2Offset: CGFloat): MSBezierIntersection;

}

interface MSBezierJoinAllocator<InitializedType = MSBezierJoin> extends NSObjectAllocator<MSBezierJoin> {
  initWithSegment1_segment2_joinedSegments(segment1: MSBezierSegment, segment2: MSBezierSegment, joinedSegments: NSArray<any> | any[] | null): InitializedType;
}
interface MSBezierJoin extends NSObject {

  segment1(): MSBezierSegment;
  segment2(): MSBezierSegment;
  joinedSegments(): NSArray<any>;
}
declare const MSBezierJoin: {
  alloc(): MSBezierJoinAllocator;  joinWithSegment1_segment2(segment1: MSBezierSegment, segment2: MSBezierSegment): MSBezierJoin;
  joinWithSegment1_segment2_strategy(segment1: MSBezierSegment, segment2: MSBezierSegment, strategy: MSBezierJoinStrategy): MSBezierJoin;
  segmentsByJoiningSegment1_segment2(segment1: MSBezierSegment, segment2: MSBezierSegment): NSArray<any>;

}

declare enum MSBezierJoinStrategy {
  MSBezierJoinStrategyNone = 1<<0,
  MSBezierJoinStrategyConnectEndpoints = 1<<1,
  MSBezierJoinStrategyIntersect = 1<<2,
  MSBezierJoinStrategyExtend = 1<<3,
  MSBezierJoinStrategyMirror = 1<<4,
  MSBezierJoinStrategyExtendTangent = 1<<5,
  MSBezierJoinStrategyArc = 1<<6,
  MSBezierJoinStrategyAny,
  MSBezierJoinStrategyDefault,
}

interface MSBezierLineCurveJoinAllocator<InitializedType = MSBezierLineCurveJoin> extends MSBezierJoinAllocator<MSBezierLineCurveJoin> {}
interface MSBezierLineCurveJoin extends MSBezierJoin {
}
declare const MSBezierLineCurveJoin: {
  alloc(): MSBezierLineCurveJoinAllocator;
}

interface MSBezierLineLineJoinAllocator<InitializedType = MSBezierLineLineJoin> extends MSBezierJoinAllocator<MSBezierLineLineJoin> {}
interface MSBezierLineLineJoin extends MSBezierJoin {
}
declare const MSBezierLineLineJoin: {
  alloc(): MSBezierLineLineJoinAllocator;
}

interface MSBezierSegmentAllocator<InitializedType = MSBezierSegment> extends NSObjectAllocator<MSBezierSegment> {
  initWithEndPoint1_endPoint2(endPoint1: CGPoint, endPoint2: CGPoint): InitializedType;
  initWithEndPoint1_endPoint2_controlPoint(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint: CGPoint): InitializedType;
  initWithEndPoint1_endPoint2_controlPoint1_controlPoint2(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): InitializedType;
}
interface MSBezierSegment extends NSObject {
  segmentWithEndPoint1(endPoint1: CGPoint): MSBezierSegment;
  segmentWithEndPoint2(endPoint2: CGPoint): MSBezierSegment;
  segmentMirroredAtOffset(offset: CGFloat): MSBezierSegment;
  tanget_andPoint_atOffset(tangent: MSLine, point: CGPoint, offset: CGFloat): void;
  tangentAtOffset(offset: CGFloat): MSLine;
  pointAtOffset(offset: CGFloat): CGPoint;
  curvatureAtOffset(offset: CGFloat): CGFloat;
  segmentToOffset(offset: CGFloat): MSBezierSegment;
  segmentFromOffset(offset: CGFloat): MSBezierSegment;
  segmentByMovingPointAtOffset_toLocation(offset: CGFloat, location: CGPoint): MSBezierSegment;
  segmentWithTransform(transform: CGAffineTransform): MSBezierSegment;
  segmentWithInset(inset: CGFloat): MSBezierSegment;
  segmentsWithFlatness(flatness: CGFloat): NSArray<any>;
  offsetForNormalToPoint(point: CGPoint): CGFloat;
  offsetsOfIntersectionsWithTangent(tangent: MSLine): NSSet<any>;
  intersectionsWithSegment(segment: MSBezierSegment): NSSet<any>;
  lineRepresentation(): MSBezierSegment;
  quadraticRepresentation(): MSBezierSegment;
  cubicRepresentation(): MSBezierSegment;
  representationUsingType(type: MSBezierSegmentType): MSBezierSegment;
  reversedSegment(): MSBezierSegment;
  isEqualToBezierSegment(object: MSBezierSegment): boolean;
  derivative(): MSBezierSegment;
  bounds(): CGRect;
  bezierPath(): NSBezierPath;

  segmentType(): MSBezierSegmentType;
  endPoint1(): CGPoint;
  endPoint2(): CGPoint;
  lineLength(): CGFloat;
  arcLength(): CGFloat;
  controlPoint1(): CGPoint;
  controlPoint2(): CGPoint;
  looksLikeALine(): boolean;
  isAPoint(): boolean;
  lineSegment(): MSLineSegment;
  xAxisRoots(): NSSet<any>;
  yAxisRoots(): NSSet<any>;
  inflectionOffsets(): NSSet<any>;
  curviness(): CGFloat;
  flatness(): CGFloat;
  transformForXAxisAlignment(): CGAffineTransform;
}
declare const MSBezierSegment: {
  alloc(): MSBezierSegmentAllocator;  lineSegmentWithEndPoint1_endPoint2(endPoint1: CGPoint, endPoint2: CGPoint): MSBezierSegment;
  quadraticSegmentWithEndPoint1_endPoint2_controlPoint(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint: CGPoint): MSBezierSegment;
  cubicSegmentWithEndPoint1_endPoint2_controlPoint1_controlPoint2(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): MSBezierSegment;

}

declare enum MSBezierSegmentType {
  MSBezierSegmentTypeLine = 0,
  MSBezierSegmentTypeQuadratic,
  MSBezierSegmentTypeCubic,
}

interface MSBitmapLayerAllocator<InitializedType = MSBitmapLayer> extends _MSBitmapLayerAllocator<MSBitmapLayer> {
  initWithFrame_image(frame: NSRect, image: MSImageData): InitializedType;
}
interface MSBitmapLayer extends _MSBitmapLayer, IMSImageOwner {
  replaceImageWithImage(image: NSImage): void;
  NSImage(): NSImage;
  isAtOriginalSize(): boolean;
  resizeToOriginalSize(): void;
  correctInvalidGamma(): void;
}
declare const MSBitmapLayer: {
  alloc(): MSBitmapLayerAllocator;
}

declare enum MSBlendMode {
  MSBlendModeNormal = 0,
  MSBlendModeDarken = 1,
  MSBlendModeMultiply = 2,
  MSBlendModeColorBurn = 3,
  MSBlendModeLighten = 4,
  MSBlendModeScreen = 5,
  MSBlendModeColorDodge = 6,
  MSBlendModeOverlay = 7,
  MSBlendModeSoftLight = 8,
  MSBlendModeHardLight = 9,
  MSBlendModeDifference = 10,
  MSBlendModeExclusion = 11,
  MSBlendModeHue = 12,
  MSBlendModeSaturation = 13,
  MSBlendModeColor = 14,
  MSBlendModeLuminosity = 15,
  MSBlendModePlusDarker = 16,
  MSBlendModePlusLighter = 17,
}

interface MSBooleanOperationChainAllocator<InitializedType = MSBooleanOperationChain> extends NSObjectAllocator<MSBooleanOperationChain> {
  initWithSubjectPath(subject: MSPath): InitializedType;
}
interface MSBooleanOperationChain extends NSObject {
  addClippingPath_forBooleanOperation(subject: MSPath, operation: MSBooleanOperation): void;
  resultPath(): MSPath;
}
declare const MSBooleanOperationChain: {
  alloc(): MSBooleanOperationChainAllocator;  booleanOperationChainWithSubjectPath(subject: MSPath): MSBooleanOperationChain;

}

interface IMSCoding {
  encodeWithArchiver(archiver: MSBaseArchiver): void;

  archiveReferenceIdentifier_bc(): NSString;
}

interface IMSColor {
}

interface MSColorArchivingFactoryAllocator<InitializedType = MSColorArchivingFactory> extends NSObjectAllocator<MSColorArchivingFactory> {}
interface MSColorArchivingFactory extends NSObject {
}
declare const MSColorArchivingFactory: {
  alloc(): MSColorArchivingFactoryAllocator;  colorForEncodingColor(color: MSColor): MSColor;

}

interface IMSColorConverter {
  convertColor(color: MSColor): MSColor;
  convertImmutableColor(color: MSImmutableColor): MSImmutableColor;
  shouldConvertColor(color: MSColor): boolean;
  shouldConvertImmutableColor(color: MSImmutableColor): boolean;
}

interface IMSColorConvertible {
  convertColorsUsing(converter: any): void;
}

interface MSColorCounterAllocator<InitializedType = MSColorCounter> extends NSObjectAllocator<MSColorCounter> {}
interface MSColorCounter extends NSObject {
  countSource(source: any): void;
  compare(otherCounter: MSColorCounter): NSComparisonResult;
  compare_byColorUse(otherCounter: MSColorCounter, use: MSColorUse): NSComparisonResult;

  immutableColor(): MSImmutableColor;
  setImmutableColor(immutableColor: MSImmutableColor): void;
  color(): MSColor;
  totalCount(): NSUInteger;
  title(): NSString;
}
declare const MSColorCounter: {
  alloc(): MSColorCounterAllocator;
}

declare enum MSColorSpace {
  MSColorSpaceUnmanaged = 0,
  MSColorSpaceSRGB = 1,
  MSColorSpaceDisplayP3 = 2,
}

interface IMSColorUser {
  updateColorCounter(color: MSColorCounter): void;
}

declare enum MSColorUse {
  MSColorUseAll = 0,
  MSColorUseFill = 1,
  MSColorUseBorder = 2,
  MSColorUseShadow = 3,
  MSColorUseInnerShadow = 4,
  MSColorUseText = 5,
  MSColorUseArtboard = 6,
}

interface MSConstantBaselineLayoutManagerAllocator<InitializedType = MSConstantBaselineLayoutManager> extends NSLayoutManagerAllocator<MSConstantBaselineLayoutManager> {}
interface MSConstantBaselineLayoutManager extends NSLayoutManager {

  constantBaselineTypesetter(): MSConstantBaselineTypesetter;
  setConstantBaselineTypesetter(constantBaselineTypesetter: MSConstantBaselineTypesetter): void;
}
declare const MSConstantBaselineLayoutManager: {
  alloc(): MSConstantBaselineLayoutManagerAllocator;
}

interface MSConstantBaselineTypesetterAllocator<InitializedType = MSConstantBaselineTypesetter> extends NSATSTypesetterAllocator<MSConstantBaselineTypesetter> {}
interface MSConstantBaselineTypesetter extends NSATSTypesetter {
  constantBaselineGlyphRangeForGlyphLocation(location: NSUInteger): NSRange;
  invalidateLayoutFromGlyphLocation(location: NSUInteger): void;
}
declare const MSConstantBaselineTypesetter: {
  alloc(): MSConstantBaselineTypesetterAllocator;
}

declare enum MSCurveMode {
  MSCurveModeUndefined = 0,
  MSCurveModeStraight = 1,
  MSCurveModeMirrored = 2,
  MSCurveModeAsymmetric = 3,
  MSCurveModeDisconnected = 4,
}

interface MSCurvePointAllocator<InitializedType = MSCurvePoint> extends _MSCurvePointAllocator<MSCurvePoint> {
  initWithPoint(p: NSPoint): InitializedType;
  initWithPoint_curveTo_curveFrom(p: NSPoint, p2: NSPoint, p1: NSPoint): InitializedType;
}
interface MSCurvePoint extends _MSCurvePoint, IMSCurvePoint, INSCopying {
  changeCurveModeTo_usingPoint(m: MSCurveMode, pointType: MSPointType): void;
  isRounded(): boolean;
  inferCurveMode(): void;
  locationOfPoint(pointType: MSPointType): NSPoint;
  movePointTo(p: NSPoint): void;
  moveCurveFromTo(p: NSPoint): void;
  moveCurveToTo(p: NSPoint): void;
  multiplyBy(amount: CGFloat): void;

  isStraight(): boolean;
  isEffectivelyStraight(): boolean;
}
declare const MSCurvePoint: {
  alloc(): MSCurvePointAllocator;  point(): MSCurvePoint;
  pointWithPoint(p: NSPoint): MSCurvePoint;
  pointWithPoint_curveTo_curveFrom(p: NSPoint, p2: NSPoint, p1: NSPoint): MSCurvePoint;

}

interface IMSCurvePoint {
}

declare enum MSPointType {
  MSPointTypeMain = 0,
  MSPointTypeControl1 = 1,
  MSPointTypeControl2 = 2,
}

declare enum MSCurveMoveOptions {
  MSCurveMoveIndependently = 1 << 0,
}

interface MSCurvePointAsymmetricBehaviourAllocator<InitializedType = MSCurvePointAsymmetricBehaviour> extends MSCurvePointBehaviourAllocator<MSCurvePointAsymmetricBehaviour> {}
interface MSCurvePointAsymmetricBehaviour extends MSCurvePointBehaviour {
}
declare const MSCurvePointAsymmetricBehaviour: {
  alloc(): MSCurvePointAsymmetricBehaviourAllocator;
}

interface MSCurvePointBehaviourAllocator<InitializedType = MSCurvePointBehaviour> extends NSObjectAllocator<MSCurvePointBehaviour> {}
interface MSCurvePointBehaviour extends NSObject {
}
declare const MSCurvePointBehaviour: {
  alloc(): MSCurvePointBehaviourAllocator;  didAssignBehaviorToHandle_ofPoint_previousMode(handle: MSPointType, point: MSCurvePoint, oldMode: MSCurveMode): void;
  curveFromChangedInPoint(point: MSCurvePoint): void;
  curveToChangedInPoint(point: MSCurvePoint): void;

}

interface MSCurvePointDisconnectedBehaviourAllocator<InitializedType = MSCurvePointDisconnectedBehaviour> extends MSCurvePointBehaviourAllocator<MSCurvePointDisconnectedBehaviour> {}
interface MSCurvePointDisconnectedBehaviour extends MSCurvePointBehaviour {
}
declare const MSCurvePointDisconnectedBehaviour: {
  alloc(): MSCurvePointDisconnectedBehaviourAllocator;
}

interface MSCurvePointMirroredBehaviourAllocator<InitializedType = MSCurvePointMirroredBehaviour> extends MSCurvePointBehaviourAllocator<MSCurvePointMirroredBehaviour> {}
interface MSCurvePointMirroredBehaviour extends MSCurvePointBehaviour {
}
declare const MSCurvePointMirroredBehaviour: {
  alloc(): MSCurvePointMirroredBehaviourAllocator;
}

interface MSCurvePointStraightBehaviourAllocator<InitializedType = MSCurvePointStraightBehaviour> extends MSCurvePointBehaviourAllocator<MSCurvePointStraightBehaviour> {}
interface MSCurvePointStraightBehaviour extends MSCurvePointBehaviour {
}
declare const MSCurvePointStraightBehaviour: {
  alloc(): MSCurvePointStraightBehaviourAllocator;
}

interface MSDefaultArchiveAllocator<InitializedType = MSDefaultArchive> extends BCSingletonAllocator<MSDefaultArchive> {}
interface MSDefaultArchive extends BCSingleton {
  archivesNeedingMigration(): NSArray<any>;
  oldDefaultsName(): NSString;
  filename(): NSString;
  defaultClass(): any;
  newObject(): any;

  defaultObject(): any;
  setDefaultObject(defaultObject: any): void;
}
declare const MSDefaultArchive: {
  alloc(): MSDefaultArchiveAllocator;
}

interface MSDefaultGridAllocator<InitializedType = MSDefaultGrid> extends MSDefaultArchiveAllocator<MSDefaultGrid> {}
interface MSDefaultGrid extends MSDefaultArchive {
}
declare const MSDefaultGrid: {
  alloc(): MSDefaultGridAllocator;
  defaultGrid(): MSSimpleGrid;
  setDefaultGrid(defaultGrid: MSSimpleGrid): void;

}

interface MSDefaultLayoutGridAllocator<InitializedType = MSDefaultLayoutGrid> extends MSDefaultArchiveAllocator<MSDefaultLayoutGrid> {}
interface MSDefaultLayoutGrid extends MSDefaultArchive {
}
declare const MSDefaultLayoutGrid: {
  alloc(): MSDefaultLayoutGridAllocator;
  defaultLayout(): MSLayoutGrid;
  setDefaultLayout(defaultLayout: MSLayoutGrid): void;

}

interface MSDefaultStyleAllocator<InitializedType = MSDefaultStyle> extends MSDefaultArchiveAllocator<MSDefaultStyle> {}
interface MSDefaultStyle extends MSDefaultArchive {
}
declare const MSDefaultStyle: {
  alloc(): MSDefaultStyleAllocator;
  defaultStyle(): MSStyle;
  setDefaultStyle(defaultStyle: MSStyle): void;

}

interface MSDefaultTextStyleAllocator<InitializedType = MSDefaultTextStyle> extends MSDefaultArchiveAllocator<MSDefaultTextStyle> {}
interface MSDefaultTextStyle extends MSDefaultArchive {
}
declare const MSDefaultTextStyle: {
  alloc(): MSDefaultTextStyleAllocator;  recordTextStyleForLayer(layer: MSTextLayer): void;

  defaultTextStyle(): NSDictionary<any, any>;
  setDefaultTextStyle(defaultTextStyle: NSDictionary<any, any> | {[key: string]: any}): void;

}

interface MSDiffAllocator<InitializedType = MSDiff> extends NSObjectAllocator<MSDiff> {
  initWithFirstObjectRoot_secondObjectRoot(first: MSSubtreeRoot, second: MSSubtreeRoot): InitializedType;
}
interface MSDiff extends NSObject {
  contentDirtyDiffRect(): NSRect;
  overlayDirtyDiffRect(): NSRect;

  firstObjectRoot(): MSSubtreeRoot;
  secondObjectRoot(): MSSubtreeRoot;
}
declare const MSDiff: {
  alloc(): MSDiffAllocator;
}

interface IMSDocumentData {

  pages(): NSArray<any>;
}

interface IMSDocumentDataDelegate {
  documentData_didChangeToPage(data: MSDocumentData, newPage: MSPage): void;
  documentData_temporarilyHideSelectionForLayers(data: MSDocumentData, layers: NSArray<any> | any[]): void;
  documentDataImmediatelyShowSelectionForAllLayers(data: MSDocumentData): void;
  documentDidChange(document: MSDocumentData): void;
  documentData_storeMetadata_forKey_object(data: MSDocumentData, metadata: any, key: NSString | string, object: MSModelObject): void;
  documentData_metadataForKey_object(data: MSDocumentData, key: NSString | string, object: MSModelObject): any;
  layerTreeLayoutDidChange(): void;
  refreshOverlayInRect(rect: NSRect): void;
  refreshOverlay(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  visibleCanvasRectForDocumentData(data: MSDocumentData): CGRect;
}

interface MSDocumentErrorAllocator<InitializedType = MSDocumentError> extends NSErrorAllocator<MSDocumentError> {}
interface MSDocumentError extends NSError {
}
declare const MSDocumentError: {
  alloc(): MSDocumentErrorAllocator;  errorWithCode(code: MSDocumentErrorCode): MSDocumentError;

}

declare enum MSDocumentErrorCode {
  MSDocumentNoError,
  MSDocumentWrongType,
  MSDocumentMissingMetadata,
  MSDocumentCorruptMetadata,
  MSDocumentTooNew,
  MSDocumentCorruptDocument,
  MSDocumentMissingFonts,
  MSDocumentMissingWrapper,
  MSDocumentWrongSize,
  MSDocumentCouldntLoadData,
  MSDocumentNeedsMigrationService,
  MSDocumentUnarchivingError,
  MSDocumentUnknownError,
}

interface IMSDocumentPreviewGeneration {
  generatePreviewsForDocument(documentData: MSImmutableDocumentData): NSDictionary<any, any>;
}

interface MSDocumentReaderAllocator<InitializedType = MSDocumentReader> extends NSObjectAllocator<MSDocumentReader> {}
interface MSDocumentReader extends NSObject {
  repair(): void;
  readDataWithCorruptionDetected_error(corruptionDetected: boolean, error: NSError): MSDocumentData;
  open(error: NSError): boolean;
  previewImageWithMaximumSize(size: NSSize): NSImage;
  validate(): MSDocumentErrorCode;
  readImmutableDataWithCorruptionDetected_error(corruptionDetected: boolean, errorOut: NSError): MSImmutableDocumentData;

  documentWasMigrated(): boolean;
  missingFonts(): NSArray<any>;
  UIMetadata(): NSDictionary<any, any>;
  containsPreviewImage(): boolean;
  previewImage(): NSImage;
  libraryPreviewImage(): NSImage;
  version(): MSDocumentVersion;
  compatibilityVersion(): MSDocumentVersion;
  metadata(): NSDictionary<any, any>;
}
declare const MSDocumentReader: {
  alloc(): MSDocumentReaderAllocator;  readerForDocumentAtURL(url: NSURL): MSDocumentReader;
  readerForDocumentAtURL_engine(url: NSURL, engine: ECCommandLineEngine): MSDocumentReader;

}

interface MSDocumentTreeAllocator<InitializedType = MSDocumentTree> extends NSObjectAllocator<MSDocumentTree> {
  initWithDocumentData(documentData: MSImmutableDocumentData): InitializedType;
}
interface MSDocumentTree extends NSObject {
  parentForObject(object: MSImmutableModelObject): any;
  ancestorsOfObject(object: MSImmutableModelObject): NSArray<any>;
  ancestorLayersOfObject(object: MSImmutableLayer): NSArray<any>;

  documentData(): MSImmutableDocumentData;
  cache(): BCCache;
}
declare const MSDocumentTree: {
  alloc(): MSDocumentTreeAllocator;
}

declare enum MSDocumentVersion {
  MSDocumentUnknownVersion = -1,
  MSDocumentEarlyVersion = 0,
  MSDocument211to212Version = 2,
  MSDocument213to214Version = 3,
  MSDocument220Version = 4,
  MSDocument221Version = 8,
  MSDocument222to223Version = 9,
  MSDocument224to23Version = 10,
  MSDocumentFirstComaVersion = 14,
  MSDocumentAKArrayRenamedVersion = 16,
  MSDocumentDontStoreDefaultsAndOptimiseColors = 17,
  MSDocumentArchiveColorsAsDoubles = 18,
  MSDocumentMigrationTest = 19,
  MSDocumentSymbols = 20,
  MSDocumentDontSyncFlagOnText = 21,
  MSDocumentRemovedSliceContainers = 22,
  MSDocumentAddedExportOptions = 23,
  MSDocumentUnifiedTextStyleSymbols = 24,
  MSDocumentMigrateArtboardAssociatedSlice = 25,
  MSDocumentMergeLayerContainers = 26,
  MSDocumentColorControlsLoadingFix = 27,
  MSDocumentAddedWindingRule = 28,
  MSDocumentClearStylesOnArtboards = 29,
  MSDocumentOriginalObjectIDOnLayers = 30,
  MSDocumentDeprecateAdaptableColor = 31,
  MSDocumentNoiseAsSeparateFill = 32,
  MSDocumentImageCollection = 33,
  MSDocumentExportableLayers = 34,
  MSDocumentStripUnsupportedAttributes = 35,
  MSDocumentMergeStraightAndRoundedCornerEnums = 36,
  MSDocumentSplitGridAndLayout = 37,
  MSDocumentStructuredFile = 40,
  MSDocumentPatternsUsesImageCollection = 41,
  MSDocumentPatternsImagePropertyRemoved = 42,
  MSDocumentImageNameRemoved = 43,
  MSDocumentDontEncodeArchivedColor = 44,
  MSDocumentTextHeightIsClippedProperty = 45,
  MSDocumentNewLineSpacingBehaviour = 46,
  MSDocumentPersistentLayerListFolding = 47,
  MSDocumentDefaultStyleIncludesPatternImages = 48,
  MSDocumentArtisticStrokeRemoved = 49,
  MSDocumentDecorationsRemoved = 50,
  MSDocumentAddedLayerUserInfo = 51,
  MSDocumentArrowMoveToStyle = 52,
  MSDocumentColorControlsHue = 53,
  MSDocumentLocalAssets = 54,
  MSDocumentImagesStoredInLocalAssets = 55,
  MSDocumentSaveImmutableVariants = 56,
  MSDocumentSaveImageWrappersThemselves = 57,
  MSDocumentArtboardsOnFullPixels = 58,
  MSDocumentRemoveHasDashPatternProperty = 59,
  MSDocumentNineSliceScaleAdded = 60,
  MSDocumentFillReplacesImage = 61,
  MSDocumentNineSliceScaleBugFix = 62,
  MSDocumentSharedStylesOnInappropriateLayersBugFix = 63,
  MSDocumentRestoreImmutableVariants = 70,
  MSDocumentCloudShareIDSupport = 71,
  MSDocumentRenameSharedLayerToSymbol = 72,
  MSDocumentRenamedExportSizeToExportFormat = 73,
  MSDocumentRetinaCanvasAndDefaultZoomValueRemoved = 74,
  MSDocumentImageCollectionDeprecated = 75,
  MSDocumentImageCollectionCleared = 76,
  MSDocumentConsistentBaselineTypesetter = 77,
  MSDocumentTextLayerGlyphBounds = 78,
  MSDocumentSymbolsAsArtboards = 79,
  MSDocumentCloudExport = 80,
  MSDocumentRemoveNSTextStorage = 81,
  MSDocumentRemoveNSFontFromMSTextStyle = 82,
  MSDocumentHistoryBasedUndoIntroduced = 83,
  MSDocumentDataUserInfoAdded = 84,
  MSDocumentRepairSymbolOverrideMissingRootDictionary = 85,
  MSDocumentReplaceMSArray = 86,
  MSDocumentLayerResizing = 87,
  MSDocumentZippedJSON = 88,
  MSDocumentShapeLayerPointRadiusType = 89,
  MSDocumentRemoveGridIndex = 90,
  MSDocumentResizingMask = 91,
  MSDocumentDuplicateIDFix = 92,
  MSDocumentVerticalAlignmentAsComaProperty = 93,
  MSDocumentSmoothPointRadiusBehaviour = 94,
  MSDocumentColorManagementThatDidntShip = 95,
  MSDocumentColorManagementForReal = 96,
  MSDocumentOverrideValues = 97,
  MSDocumentRefactorBCTextBehaviour = 98,
  MSDocumentMSAttributedStringJSON = 99,
  MSDocumentRemoveShapePathClass = 100,
  MSDocumentPersistentArtboardPresets = 101,
  MSDocumentForeignStyles = 102,
  MSDocumentUseGenericDocumentMetadataKey = 103,
  MSDocumentRefactorWindingRule = 104,
  MSDocumentFancyArrowHeads = 105,
  MSDocumentPlusLigherPlusDarkerBlendModes = 106,
  MSDocumentBackgroundBlurSaturation = 107,
  MSDocumentNestedBooleanOperations = 110,
  MSDocumentZoomBlurCoordinateSystem = 111,
  MSDocumentNextVersion,
  MSDocumentCurrentVersion,
  MSDocumentCompatibilityVersion,
  MSDocumentNewestVersionRequiringMigration,
}

interface MSDocumentWriterAllocator<InitializedType = MSDocumentWriter> extends NSObjectAllocator<MSDocumentWriter> {
  initWithFileURL(url: NSURL): InitializedType;
}
interface MSDocumentWriter extends NSObject {
  writeDocumentData_isAutosave_error(data: MSImmutableDocumentData, isAutosave: boolean, error: NSError): boolean;

  UIMetadata(): NSDictionary<any, any>;
  setUIMetadata(UIMetadata: NSDictionary<any, any> | {[key: string]: any}): void;
  previewGenerationBlock(): imageGenerationBlock;
  setPreviewGenerationBlock(previewGenerationBlock: imageGenerationBlock): void;
}
declare const MSDocumentWriter: {
  alloc(): MSDocumentWriterAllocator;  metadataForNewFile(): NSDictionary<any, any>;

}

interface MSDocumentZippedJSONReaderAllocator<InitializedType = MSDocumentZippedJSONReader> extends MSDocumentReaderAllocator<MSDocumentZippedJSONReader> {
  initWithFileURL(url: NSURL): InitializedType;
}
interface MSDocumentZippedJSONReader extends MSDocumentReader {
}
declare const MSDocumentZippedJSONReader: {
  alloc(): MSDocumentZippedJSONReaderAllocator;
}

interface MSExportFormatAllocator<InitializedType = MSExportFormat> extends _MSExportFormatAllocator<MSExportFormat> {}
interface MSExportFormat extends _MSExportFormat {
  container(): any;
  parentLayer(): MSLayer;
  remove(): void;
  isScalableExport(): boolean;
}
declare const MSExportFormat: {
  alloc(): MSExportFormatAllocator;  formatWithScale_name_fileFormat(scale: CGFloat, name: NSString | string, format: NSString | string): MSExportFormat;
  formatWithScale_name_fileFormat_absoluteSize_namingScheme(scale: CGFloat, name: NSString | string, format: NSString | string, absoluteSize: CGFloat, namingScheme: MSExportFormatNamingScheme): MSExportFormat;
  validFormats(): NSSet<any>;
  exportableFilenameBodyForLayerName_exportFormat(layerName: NSString | string, format: MSImmutableExportFormat): NSString;
  exportableFilenameForLayerName_exportFormat(layerName: NSString | string, format: MSImmutableExportFormat): NSString;

}

interface IMSExportFormatContainer {
  containingLayer(): MSLayer;
  exportFormats(): NSArray<any>;
  removeExportFormat(exportFormat: MSExportFormat): void;
}

declare enum MSExportFormatNamingScheme {
  MSExportFormatNamingSchemeSuffix = 0,
  MSExportFormatNamingSchemePrefix = 1,
}

declare enum MSExportLayerOptions {
  MSExportLayersAll = 0,
  MSExportLayersSelected = 1,
  MSExportLayersInGroup = 2,
}

interface MSExportOptionsAllocator<InitializedType = MSExportOptions> extends _MSExportOptionsAllocator<MSExportOptions> {}
interface MSExportOptions extends _MSExportOptions, IMSExportFormatContainer {
  addExportFormat(): MSExportFormat;
}
declare const MSExportOptions: {
  alloc(): MSExportOptionsAllocator;  nextMostAppropriateExportFormatToAdd(existingExportFormats: NSArray<any> | any[]): MSExportFormat;

}

interface MSFeatureAvailabilityAllocator<InitializedType = MSFeatureAvailability> extends NSObjectAllocator<MSFeatureAvailability> {}
interface MSFeatureAvailability extends NSObject {
}
declare const MSFeatureAvailability: {
  alloc(): MSFeatureAvailabilityAllocator;  enableFeatureAvailability(): void;

  libraryStylesEnabled(): boolean;
  setLibraryStylesEnabled(libraryStylesEnabled: boolean): void;
  feature14414Enabled(): boolean;
  setFeature14414Enabled(feature14414Enabled: boolean): void;
  dataSuppliersEnabled(): boolean;
  setDataSuppliersEnabled(dataSuppliersEnabled: boolean): void;
  isComponentsPanelEnabled(): boolean;
  setIsComponentsPanelEnabled(isComponentsPanelEnabled: boolean): void;
  builtInRemoteLibrariesEnabled(): boolean;
  setBuiltInRemoteLibrariesEnabled(builtInRemoteLibrariesEnabled: boolean): void;
  cloudDocumentsEnabled(): boolean;
  setCloudDocumentsEnabled(cloudDocumentsEnabled: boolean): void;

}

interface MSFirstLineHeightTypesetterAllocator<InitializedType = MSFirstLineHeightTypesetter> extends NSATSTypesetterAllocator<MSFirstLineHeightTypesetter> {}
interface MSFirstLineHeightTypesetter extends NSATSTypesetter {

  forcedBaselineOffset(): CGFloat;
  setForcedBaselineOffset(forcedBaselineOffset: CGFloat): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSFirstLineHeightTypesetter: {
  alloc(): MSFirstLineHeightTypesetterAllocator;
}

interface IMSFirstLineTypesetterDelegate {
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;
}

interface MSFlowConnectionAllocator<InitializedType = MSFlowConnection> extends _MSFlowConnectionAllocator<MSFlowConnection> {}
interface MSFlowConnection extends _MSFlowConnection {
  bezierPathForRenderingFlowAtZoomLevel(zoomLevel: CGFloat): NSBezierPath;

  isBackAction(): boolean;
  setIsBackAction(isBackAction: boolean): void;
  isValidFlowConnection(): boolean;
  sendingLayer(): MSLayer;
  destinationArtboard(): MSArtboardGroup;
}
declare const MSFlowConnection: {
  alloc(): MSFlowConnectionAllocator;  flowConnectionTo_ofType(to: MSArtboardGroup, type: MSFlowAnimationType): MSFlowConnection;
  flowConnectionBack(): MSFlowConnection;
  defaultAnimationType(): MSFlowAnimationType;

}

declare enum MSFlowAnimationType {
  MSFlowAnimationNone = -1,
  MSFlowAnimationSlideFromRight = 0,
  MSFlowAnimationSlideFromLeft,
  MSFlowAnimationSlideFromBottom,
  MSFlowAnimationSlideFromTop,
}

declare type MSFlowEndpoint = {
  edge: BCEdge
  rect: NSRect
}

declare type MSFlowInfo = {
  from: MSFlowEndpoint
  to: MSFlowEndpoint
  type: MSFlowType
}

declare enum MSFlowType {
  MSFlowTypeRegularTranstion,
  MSFlowTypeBackTransition,
  MSFlowTypeTransitionToParent,
  MSFlowTypeOtherPageTransition,
}

interface MSFontListAllocator<InitializedType = MSFontList> extends NSObjectAllocator<MSFontList> {
  initWithDocumentData(documentData: MSDocumentData): InitializedType;
}
interface MSFontList extends NSObject {
  reloadFonts(): void;
  numberOfFontFamilies(): NSUInteger;
  nameOfFontFamilyAtIndex(index: NSUInteger): NSString;
  fontForFontFamilyAtIndex(index: NSUInteger): NSFont;
  filter(filter: NSString | string): void;
  clearFilter(): void;
  startCachingFonts(): void;
  prepareForDealloc(): void;

  documentFontFamilyNames(): NSArray<any>;
  documentData(): MSDocumentData;
}
declare const MSFontList: {
  alloc(): MSFontListAllocator;
}

interface MSForeignLayerStyleAllocator<InitializedType = MSForeignLayerStyle> extends _MSForeignLayerStyleAllocator<MSForeignLayerStyle> {}
interface MSForeignLayerStyle extends _MSForeignLayerStyle {
}
declare const MSForeignLayerStyle: {
  alloc(): MSForeignLayerStyleAllocator;
}

interface MSForeignObjectAllocator<InitializedType = MSForeignObject> extends _MSForeignObjectAllocator<MSForeignObject> {
  initWithOriginalObject_inLibrary(original: MSModelObject, library: any): InitializedType;
}
interface MSForeignObject extends _MSForeignObject {
  isOutOfDateWithLibrary(library: any): boolean;
  syncWithRemote(remote: MSModelObject): void;
  unlinkFromRemote(): MSModelObject;
  masterFromLibrary(library: any): MSModelObject;
  masterFromDocument(doc: MSDocumentData): MSModelObject;
  matchingForeignObjectInDocument(doc: MSDocumentData): MSForeignObject;
  isLocalToDocument(doc: MSDocumentData): boolean;

  localObject(): MSModelObject;
  setLocalObject(localObject: MSModelObject): void;
  remoteShareID(): NSString;
}
declare const MSForeignObject: {
  alloc(): MSForeignObjectAllocator;
}

interface MSModelObjectAllocator<InitializedType = MSModelObject> extends MSModelObjectCommonAllocator<MSModelObject> {
  initWithImmutableModelObject(immutableBase: MSImmutableModelObject): InitializedType;
}
interface MSModelObject extends MSModelObjectCommon, IMSModelObject {
  cachedValueForKey(key: any): any;
  cachedValueForKey_setUsingBlock(key: any, block: BCCacheCreateObjectBlock): any;
  updateCachedValue_forKey(value: any, key: any): void;
  clearCachedValueForKey(key: any): void;
  clearCache(): void;
  storeMetadata_forKey(toStore: any, key: NSString | string): void;
  metadataForKey(key: NSString | string): any;
  performInitWithImmutableModelObject(immutableObject: MSImmutableModelObject): void;
  object_didChangeProperty(object: MSModelObject, propertyName: NSString | string): void;
  invalidateModelCacheGeneration(): void;
  invalidateImmutableObject(): void;
  invalidateImmutableObjectAndAncestors(): void;
  setAsParentOnChildren(): void;
  parentGroup(): MSLayerGroup;
  fireFault(): void;
  fireFaultIfNecessary(): void;
  undoManager(): NSUndoManager;
  setUndoActionName(name: NSString | string): void;
  setUndoActionSenderAndName(name: NSString | string): void;
  isUndoing(): boolean;
  registerUndoNamed_action(name: NSString | string, action: MSUndoActionBlock): void;
  copyPropertiesToObject_options(objectCopy: any, options: MSModelCopyOptions): void;
  syncPropertiesFromObject(object: any): void;

  foreignObject(): MSModelObject;
  isForeign(): boolean;
  UIMetadataKey(): NSString;
  cachedImmutableModelObject(): any;
  setCachedImmutableModelObject(cachedImmutableModelObject: any): void;
  documentData(): MSDocumentData;
  parentObject(): MSModelObject;
  setParentObject(parentObject: MSModelObject): void;
  immutableModelObject(): any;
  isFault(): boolean;
}
declare const MSModelObject: {
  alloc(): MSModelObjectAllocator;  immutableClass(): any;
  allowsFaulting(): boolean;

}

interface MSForeignStyleAllocator<InitializedType = MSForeignStyle> extends _MSForeignStyleAllocator<MSForeignStyle> {}
interface MSForeignStyle extends _MSForeignStyle {
}
declare const MSForeignStyle: {
  alloc(): MSForeignStyleAllocator;
}

interface MSForeignSymbolAllocator<InitializedType = MSForeignSymbol> extends _MSForeignSymbolAllocator<MSForeignSymbol> {}
interface MSForeignSymbol extends _MSForeignSymbol {

  remoteSymbolID(): NSString;
}
declare const MSForeignSymbol: {
  alloc(): MSForeignSymbolAllocator;  foreignSymbolWithMaster_inLibrary(master: MSSymbolMaster, library: any): MSForeignSymbol;

}

interface MSModelObjectCommonAllocator<InitializedType = MSModelObjectCommon> extends NSObjectAllocator<MSModelObjectCommon> {
  initializeUnsetObjectPropertiesWithDefaults(): InitializedType;
  init(): InitializedType;
  initWithBlock(block: Block): InitializedType;
  initWithMinimalSetup(): InitializedType;
}
interface MSModelObjectCommon extends NSObject, IMSModelObjectCommon {
  isContainedByInstanceOfForeignSymbol(ancestors: NSArray<any> | any[]): boolean;
  treeStructure(): NSString;
  simpleTreeStructure(): NSString;
  treeAsDictionary(): any;
  performInitEmptyObject(): void;
  objectDidInit(): void;
  enumerateProperties(enumerator: MSDataPropertyEnumerator): void;
  performMigrationsWithUnarchiver(coder: MSBaseUnarchiver): void;
  hasObjectID(): boolean;
  primitiveObjectID(): NSString;
  recursivelyGenerateObjectID(): any;
  enumerateChildProperties(enumerator: MSDataPropertyEnumerator): void;
  enumerateDescendants(enumerator: MSDescendantEnumerator): void;

  objectID(): NSString;
  setObjectID(objectID: NSString | string): void;
  modelObjectCacheGeneration(): MSModelObjectCacheGeneration;
  hasModelObjectCacheGeneration(): boolean;
}
declare const MSModelObjectCommon: {
  alloc(): MSModelObjectCommonAllocator;  generateObjectID(): any;
  defaultName(): NSString;

}

interface MSForeignTextStyleAllocator<InitializedType = MSForeignTextStyle> extends _MSForeignTextStyleAllocator<MSForeignTextStyle> {}
interface MSForeignTextStyle extends _MSForeignTextStyle {
}
declare const MSForeignTextStyle: {
  alloc(): MSForeignTextStyleAllocator;
}

interface MSFrequentColorTrackerAllocator<InitializedType = MSFrequentColorTracker> extends NSObjectAllocator<MSFrequentColorTracker> {
  initWithColorUse_maximumColorCount_ignoreAlpha(colorUse: MSColorUse, maxCount: NSUInteger, ignoreAlpha: boolean): InitializedType;
}
interface MSFrequentColorTracker extends NSObject {
  registerColor_fromSource(color: MSImmutableColor, source: any): void;
  registerColors_fromSource(colors: NSArray<any> | any[], source: any): void;
  frequentColors(): NSArray<any>;

  colorUse(): MSColorUse;
  maximumColorCount(): NSUInteger;
  shouldIgnoreAlpha(): boolean;
}
declare const MSFrequentColorTracker: {
  alloc(): MSFrequentColorTrackerAllocator;
}

interface MSGradientPointArrayAllocator<InitializedType = MSGradientPointArray> extends MSPointArrayAllocator<MSGradientPointArray> {}
interface MSGradientPointArray extends MSPointArray {

  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSGradientPointArray: {
  alloc(): MSGradientPointArrayAllocator;
}

interface IMSGradientPointArrayDelegate {
  gradientPointArray_didReplacePointAtIndex_withPoint(array: MSGradientPointArray, i: NSUInteger, aPoint: NSPoint): void;
}

interface MSGradientStopAllocator<InitializedType = MSGradientStop> extends _MSGradientStopAllocator<MSGradientStop> {
  initWithPosition_color(pos: CGFloat, aColor: MSColor): InitializedType;
}
interface MSGradientStop extends _MSGradientStop, IMSColorConvertible {
}
declare const MSGradientStop: {
  alloc(): MSGradientStopAllocator;  stopWithPosition_color(pos: CGFloat, aColor: MSColor): any;

}

declare enum MSGradientType {
  MSGradientTypeLinear = 0,
  MSGradientTypeRadial = 1,
  MSGradientTypeAngular = 2,
}

interface MSGraphicsContextSettingsAllocator<InitializedType = MSGraphicsContextSettings> extends _MSGraphicsContextSettingsAllocator<MSGraphicsContextSettings> {}
interface MSGraphicsContextSettings extends _MSGraphicsContextSettings {
}
declare const MSGraphicsContextSettings: {
  alloc(): MSGraphicsContextSettingsAllocator;
}

interface MSImageCollectionAllocator<InitializedType = MSImageCollection> extends _MSImageCollectionAllocator<MSImageCollection> {}
interface MSImageCollection extends _MSImageCollection {
}
declare const MSImageCollection: {
  alloc(): MSImageCollectionAllocator;
}

interface IMSImageOwner {
  setReducedImage(image: MSImageData): void;

  image(): MSImageData;
  setImage(image: MSImageData): void;
  targetSizeForReduction(): NSSize;
  canReduceImageSize(): boolean;
}

interface MSImmutableLayerAncestryAllocator<InitializedType = MSImmutableLayerAncestry> extends NSObjectAllocator<MSImmutableLayerAncestry> {
  initWithLayer_document(layer: MSImmutableLayer, doc: MSImmutableDocumentData): InitializedType;
  initWithLayer_ancestors_document(layer: MSImmutableLayer, ancestors: NSArray<any> | any[], doc: MSImmutableDocumentData): InitializedType;
  initWithMSLayer(layer: MSLayer): InitializedType;
}
interface MSImmutableLayerAncestry extends NSObject {
  absoluteRect(): NSRect;

  layer(): MSImmutableLayer;
  document(): MSImmutableDocumentData;
  page(): MSImmutablePage;
  parentGroup(): MSImmutableLayerGroup;
  artboard(): MSImmutableArtboardGroup;
  ancestors(): NSArray<any>;
  ancestorsAndSelf(): NSArray<any>;
}
declare const MSImmutableLayerAncestry: {
  alloc(): MSImmutableLayerAncestryAllocator;  ancestryWithMSLayer(layer: MSLayer): MSImmutableLayerAncestry;

}

interface MSJSONArchiveReferenceAllocator<InitializedType = MSJSONArchiveReference> extends NSObjectAllocator<MSJSONArchiveReference> {
  initWithReferenceObject(object: NSObject): InitializedType;
  initWithJSONDecoder(decoder: BCJSONDecoder): InitializedType;
}
interface MSJSONArchiveReference extends NSObject, IBCJSONEncoding {
}
declare const MSJSONArchiveReference: {
  alloc(): MSJSONArchiveReferenceAllocator;
}

interface MSJSONOriginalFileReferenceAllocator<InitializedType = MSJSONOriginalFileReference> extends MSJSONArchiveReferenceAllocator<MSJSONOriginalFileReference> {}
interface MSJSONOriginalFileReference extends MSJSONArchiveReference {
}
declare const MSJSONOriginalFileReference: {
  alloc(): MSJSONOriginalFileReferenceAllocator;
}

interface MSJSONFileReferenceAllocator<InitializedType = MSJSONFileReference> extends MSJSONArchiveReferenceAllocator<MSJSONFileReference> {}
interface MSJSONFileReference extends MSJSONArchiveReference {
}
declare const MSJSONFileReference: {
  alloc(): MSJSONFileReferenceAllocator;
}

interface MSJSONDataReferenceAllocator<InitializedType = MSJSONDataReference> extends MSJSONArchiveReferenceAllocator<MSJSONDataReference> {}
interface MSJSONDataReference extends MSJSONArchiveReference {
}
declare const MSJSONDataReference: {
  alloc(): MSJSONDataReferenceAllocator;
}

interface MSJSONOriginalDataReferenceAllocator<InitializedType = MSJSONOriginalDataReference> extends MSJSONDataReferenceAllocator<MSJSONOriginalDataReference> {}
interface MSJSONOriginalDataReference extends MSJSONDataReference {
}
declare const MSJSONOriginalDataReference: {
  alloc(): MSJSONOriginalDataReferenceAllocator;
}

interface MSJSONArchiverAllocator<InitializedType = MSJSONArchiver> extends MSBaseArchiverAllocator<MSJSONArchiver> {}
interface MSJSONArchiver extends MSBaseArchiver {
  replacementObjectForObject(object: NSObject): NSObject;
}
declare const MSJSONArchiver: {
  alloc(): MSJSONArchiverAllocator;  archiverFromCoder(coder: BCJSONEncoder): MSJSONArchiver;
  archiveObject_coder(object: NSObject, coder: BCJSONEncoder): void;

}

interface MSJSONDataArchiverAllocator<InitializedType = MSJSONDataArchiver> extends MSJSONArchiverAllocator<MSJSONDataArchiver> {}
interface MSJSONDataArchiver extends MSJSONArchiver {
}
declare const MSJSONDataArchiver: {
  alloc(): MSJSONDataArchiverAllocator;  archiveStringWithRootObject_error(root: NSObject, error: NSError): NSString;

}

interface MSJSONDataUnarchiverAllocator<InitializedType = MSJSONDataUnarchiver> extends MSJSONUnarchiverAllocator<MSJSONDataUnarchiver> {}
interface MSJSONDataUnarchiver extends MSJSONUnarchiver {
}
declare const MSJSONDataUnarchiver: {
  alloc(): MSJSONDataUnarchiverAllocator;  unarchiveObjectWithString_asVersion_corruptionDetected_error(jsonString: NSString | string, version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;

}

interface MSJSONDictionaryUnarchiverAllocator<InitializedType = MSJSONDictionaryUnarchiver> extends MSJSONUnarchiverAllocator<MSJSONDictionaryUnarchiver> {}
interface MSJSONDictionaryUnarchiver extends MSJSONUnarchiver {
}
declare const MSJSONDictionaryUnarchiver: {
  alloc(): MSJSONDictionaryUnarchiverAllocator;  unarchiveObjectFromDictionary_asVersion_corruptionDetected_error(dict: NSDictionary<any, any> | {[key: string]: any}, version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;

}

interface MSJSONUnarchiverAllocator<InitializedType = MSJSONUnarchiver> extends MSBaseUnarchiverAllocator<MSJSONUnarchiver> {}
interface MSJSONUnarchiver extends MSBaseUnarchiver {
  decodeReferenceObjectOfClass_withIdentifier(className: NSString | string | null, identifier: NSString | string | null): any;
  referenceObjectWithIdentifier(identifier: NSString | string | null): any;
  addReference_withIdentifier(reference: any, identifier: NSString | string): void;
}
declare const MSJSONUnarchiver: {
  alloc(): MSJSONUnarchiverAllocator;
}

interface MSJSONZippedArchiverAllocator<InitializedType = MSJSONZippedArchiver> extends MSJSONArchiverAllocator<MSJSONZippedArchiver> {
  initWithURL(url: NSURL): InitializedType;
}
interface MSJSONZippedArchiver extends MSJSONArchiver {
  encodeObject_toSubpath_error(root: NSObject, path: NSString | string, error: NSError): boolean;
  encodeRawData_toSubpath_error(data: NSData, path: NSString | string, error: NSError): boolean;
  finishEncodingError(error: NSError): boolean;
}
declare const MSJSONZippedArchiver: {
  alloc(): MSJSONZippedArchiverAllocator;
}

interface IMSJSONArchiverAlternativeFileReference {
  encodeReferenceInJSONZipArchive(encoder: BCJSONZippedEncoder): void;

  archiveReferenceIdentifier_bc(): NSString;
}

interface MSJSONZippedUnarchiverAllocator<InitializedType = MSJSONZippedUnarchiver> extends MSJSONUnarchiverAllocator<MSJSONZippedUnarchiver> {
  initWithURL(url: NSURL): InitializedType;
}
interface MSJSONZippedUnarchiver extends MSJSONUnarchiver {
  unarchiveObjectAtSubpath_error(path: NSString | string, error: NSError): any;
  unarchiveRawDataAtSubpath_error(path: NSString | string, error: NSError): NSData;
  containsFileAtSubpath(path: NSString | string): boolean;
}
declare const MSJSONZippedUnarchiver: {
  alloc(): MSJSONZippedUnarchiverAllocator;
}

interface MSKeyedArchiverAllocator<InitializedType = MSKeyedArchiver> extends MSBaseArchiverAllocator<MSKeyedArchiver> {}
interface MSKeyedArchiver extends MSBaseArchiver {
}
declare const MSKeyedArchiver: {
  alloc(): MSKeyedArchiverAllocator;
}

interface MSKeyedArchiverHelperAllocator<InitializedType = MSKeyedArchiverHelper> extends NSKeyedArchiverAllocator<MSKeyedArchiverHelper> {}
interface MSKeyedArchiverHelper extends NSKeyedArchiver {

  archiver(): MSBaseArchiver;
  setArchiver(archiver: MSBaseArchiver): void;
}
declare const MSKeyedArchiverHelper: {
  alloc(): MSKeyedArchiverHelperAllocator;
}

interface MSKeyedUnarchiverAllocator<InitializedType = MSKeyedUnarchiver> extends MSBaseUnarchiverAllocator<MSKeyedUnarchiver> {}
interface MSKeyedUnarchiver extends MSBaseUnarchiver {

  legacyImages(): NSDictionary<any, any>;
  setLegacyImages(legacyImages: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const MSKeyedUnarchiver: {
  alloc(): MSKeyedUnarchiverAllocator;  unarchiveObjectFromURL_error(url: NSURL, error: NSError): any;

}

interface MSStyleFillAllocator<InitializedType = MSStyleFill> extends _MSStyleFillAllocator<MSStyleFill> {}
interface MSStyleFill extends _MSStyleFill, IMSImageOwner {
  CSSAttributeString(): NSString;
  hasOpacity(): boolean;
  setOpacity(opacity: CGFloat): void;
  NSImage(): NSImage;

  interfaceOpacity(): CGFloat;
  setInterfaceOpacity(interfaceOpacity: CGFloat): void;
}
declare const MSStyleFill: {
  alloc(): MSStyleFillAllocator;
}

interface MSStyleBorderAllocator<InitializedType = MSStyleBorder> extends _MSStyleBorderAllocator<MSStyleBorder> {}
interface MSStyleBorder extends _MSStyleBorder, IMSColorConvertible {
  CSSAttributeString(): NSString;
  supportsAdvancedBorderSettings(): boolean;
}
declare const MSStyleBorder: {
  alloc(): MSStyleBorderAllocator;
}

interface MSStyleShadowAllocator<InitializedType = MSStyleShadow> extends _MSStyleShadowAllocator<MSStyleShadow> {}
interface MSStyleShadow extends _MSStyleShadow, IMSColorConvertible {
  CSSAttributeString(): NSString;
}
declare const MSStyleShadow: {
  alloc(): MSStyleShadowAllocator;
}

interface MSStyleInnerShadowAllocator<InitializedType = MSStyleInnerShadow> extends _MSStyleInnerShadowAllocator<MSStyleInnerShadow> {}
interface MSStyleInnerShadow extends _MSStyleInnerShadow {
}
declare const MSStyleInnerShadow: {
  alloc(): MSStyleInnerShadowAllocator;
}

interface MSHitTestResultAllocator<InitializedType = MSHitTestResult> extends NSObjectAllocator<MSHitTestResult> {}
interface MSHitTestResult extends NSObject {

  layer(): MSLayer;
  overrideRepresentation(): MSOverrideRepresentation;
}
declare const MSHitTestResult: {
  alloc(): MSHitTestResultAllocator;
}

interface MSSymbolInstanceAllocator<InitializedType = MSSymbolInstance> extends _MSSymbolInstanceAllocator<MSSymbolInstance> {}
interface MSSymbolInstance extends _MSSymbolInstance {
  symbolMaster(): MSSymbolMaster;
  isInstanceForMaster(symbolMaster: MSSymbolMaster): boolean;
  changeInstanceToSymbol(symbol: MSSymbolMaster): void;
  numberOfVisibleCells(): NSUInteger;
  detachByReplacingWithGroup(): MSLayerGroup;
  resizeInstanceToFitSymbol(symbol: MSSymbolMaster): void;
  resetSizeToMaster(): void;
  setValue_forOverridePoint(value: any | null, point: MSOverridePoint): void;
  updateOverridesWithObjectIDMap(idMap: NSDictionary<any, any> | {[key: string]: any}): void;
  invalidateIfAffectedBySymbolMastersIn(modifiedSymbols: NSSet<any>): boolean;
  removeShareableObjectsFromOverrides(removed: NSSet<any>): void;

  overridePoints(): NSArray<any>;
  availableOverrides(): NSArray<any>;
  overrides(): NSDictionary<any, any>;
  setOverrides(overrides: NSDictionary<any, any> | {[key: string]: any}): void;
  masterRefreshCounter(): NSInteger;
  setMasterRefreshCounter(masterRefreshCounter: NSInteger): void;
  overrideContainer(): MSOverrideRepresentationContainer;
  influencingSymbolIDs(): NSSet<any>;
}
declare const MSSymbolInstance: {
  alloc(): MSSymbolInstanceAllocator;
}

interface IMSLayerChangeObserver {
  layerDidChange(layer: MSLayer): void;
}

declare type MSLayerAbsolutePosition = NSPoint

declare enum MSAlignmentRectOptions {
  MSAlignmentRectTextBaselineAndCapHeight = 1 << 0,
  MSAlignmentRectTextXHeight = 2 << 0,
}

declare enum MSLayerRenameOptions {
  MSLayerRenameNumbersOnly = 0,
  MSLayerRenameIncludeCopy = 1,
}

declare enum MSLayerSelectionOptions {
  MSLayerSelectionClickThroughAllGroups = 1 << 1,
  MSLayerSelectionIgnoreSlices = 1 << 2,
  MSLayerSelectionIgnoreHotspots = 1 << 3,
  MSLayerSelectionSlicesAsOutlines = 1 << 4,
  MSLayerSelectionHotspotsAsOutlines = 1 <<5,
  MSLayerSelectionPreferSecondMatch = 1 << 6,
  MSLayerSelectionFullyContained = 1 << 7,
  MSLayerSelectionAllArtboards = 1 << 8,
}

interface MSLayerBuilderAllocator<InitializedType = MSLayerBuilder> extends NSObjectAllocator<MSLayerBuilder> {}
interface MSLayerBuilder extends NSObject {
}
declare const MSLayerBuilder: {
  alloc(): MSLayerBuilderAllocator;  layerTreeWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): any;
  layerTreeWithJSON_relativeToURL_error(json: NSString | string, url: NSURL, error: NSError): any;
  layerTreeWithContentsOfURL_error(url: NSURL, error: NSError): any;

}

interface IMSLayerContainment {
  containedLayers(): NSArray<any>;
  containedLayersCount(): NSUInteger;
  firstLayer(): any;
  lastLayer(): any;
  containsNoOrOneLayers(): boolean;
  containsLayers(): boolean;
  containsOneLayer(): boolean;
  containsMultipleLayers(): boolean;
  layerAtIndex(i: NSUInteger): any;
  indexOfLayer(aLayer: any): NSUInteger;
  enumerateLayers(block: MSLayerSimpleEnumeratorBlock): void;
  enumerateLayersWithOptions_block(options: MSLayerEnumeratorOptions, block: MSLayerEnumeratorBlock): boolean;
}

declare type MSLayerEnumeratorOptions = NSUInteger

declare enum MSLayerEnumeratorFlags {
  MSLEDefault = 0,
  MSLEIncludeSelf = 1<<0,
  MSLEBackwards = 1<<1,
  MSLERecursive = 1<<2,
  MSLESkipHidden = 1<<3,
  MSLEMutates = 1<<4,
  MSLETraitsMatchOr = 1<<5,
  MSLEAllOptions,
}

interface IMSLayerCoordinateSpace {
  convertPoint_toCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertPoint_fromCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertRect_toCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertRect_fromCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertVector_toCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  convertVector_fromCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  transformForConvertingToCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  transformForConvertingFromCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;

  bounds(): CGRect;
  parentCoordinateSpace(): any;
  transformForConvertingToParentCoordinateSpace(): CGAffineTransform;
  transformForConvertingFromParentCoordinateSpace(): CGAffineTransform;
}

interface MSLayerEnumeratorAllocator<ObjectType, InitializedType = MSLayerEnumerator<ObjectType>> extends NSEnumeratorAllocator<ObjectType, MSLayerEnumerator<ObjectType>> {}
interface MSLayerEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
  skipDescendants(): void;
}
declare const MSLayerEnumerator: {
  alloc<ObjectType>(): MSLayerEnumeratorAllocator<ObjectType>;
}

interface IMSLayerGroup {

  layers(): NSArray<any>;
}

declare enum MSLayerGroupResizeOption {
  MSLayerGroupResizeOptionLayerOnly = 0,
  MSLayerGroupResizeOptionResizeParentUponRectChange = 1 << 0,
}

declare enum MSLayerListStatus {
  MSLayerListStatusUndecided = 0,
  MSLayerListStatusCollapsed = 1,
  MSLayerListStatusExpanded = 2,
}

interface MSLayerMovementAllocator<InitializedType = MSLayerMovement> extends NSObjectAllocator<MSLayerMovement> {}
interface MSLayerMovement extends NSObject {
}
declare const MSLayerMovement: {
  alloc(): MSLayerMovementAllocator;  moveForward(layers: NSArray<any> | any[]): void;
  moveBackward(layers: NSArray<any> | any[]): void;
  canMoveLayerUpHierarchy(layer: MSLayer): boolean;
  moveUpHierarchy(layers: NSArray<any> | any[]): void;
  canMoveLayerToTopOfHierarchy(layer: MSLayer): boolean;
  moveToTopOfHierarchy(layers: NSArray<any> | any[]): void;
  canMoveLayersForward(layers: NSArray<any> | any[]): boolean;
  canMoveLayersBackward(layers: NSArray<any> | any[]): boolean;
  moveToFront(layers: NSArray<any> | any[]): void;
  moveToBack(layers: NSArray<any> | any[]): void;

}

interface MSLayerPasterAllocator<InitializedType = MSLayerPaster> extends NSObjectAllocator<MSLayerPaster> {}
interface MSLayerPaster extends NSObject {
}
declare const MSLayerPaster: {
  alloc(): MSLayerPasterAllocator;  insertPasteboardData_onPage_withHint_viewPort(pboardData: MSPasteboardLayers, page: MSPage, destinationHint: MSLayer | null, viewport: MSPastingViewport): MSPastingViewport;
  insertPasteboardData_intoParent_atPosition_afterLayer_viewport_fitToParent(pboardData: MSPasteboardLayers, parent: MSLayerGroup, position: NSPoint, afterLayer: any, viewport: MSPastingViewport, fitToParent: boolean): MSLayerArray;
  insertPasteboardData_intoParent_beforeLayer(pboardData: MSPasteboardLayers, parent: MSLayerGroup, beforeLayer: any): MSLayerArray;
  insertPagePasteboardData_intoDocument_afterPage(pboardData: MSPasteboardLayers, document: MSDocumentData, afterPage: MSPage): MSLayerArray;
  parentForData_hint_page_viewPort(pboardData: MSPasteboardLayers, hint: MSLayer | null, page: MSPage, viewport: MSPastingViewport): MSLayerGroup;
  parentForData_hint_page(pboardData: MSPasteboardLayers, hint: MSLayer | null, page: MSPage): MSLayerGroup;
  duplicateLayers(layers: MSPasteboardLayers): MSPasteboardLayers;

}

declare enum MSLayerResizingType {
  MSLayerResizingStretch = 0,
  MSLayerResizingPinToEdge = 1,
  MSLayerResizingResize = 2,
  MSLayerResizingFloat = 3,
}

interface IMSLayerTraits {
  traits(): MSTraits;
}

declare enum MSTraits {
  MSTraitStyled = 1<<8,
  MSTraitText = 1<<9,
  MSTraitImage = 1<<10,
  MSTraitSlice = 1<<11,
  MSTraitGroup = 1<<12,
  MSTraitArtboard = 1<<13,
  MSTraitShape = 1<<14,
  MSTraitPage = 1<<15,
  MSTraitContainer = 1<<16,
  MSTraitRoot = 1<<17,
  MSTraitPath = 1<<18,
  MSTraitSymbolInstance = 1<<19,
  MSTraitSymbolMaster = 1<<20,
  MSTraitHotspot = 1<<21,
  MSTraitExportable = 1<<22,
  MSTraitShapeOrPath = 1<<23,
  MSTraitAllTraits,
}

interface IMSLayerWithBackgroundColor {
  immutableBackgroundColor(): MSImmutableColor;

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
}

interface IMSLayerWithMutableBackgroundColor {

  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
}

declare enum MSLayoutGridStyle {
  MSLayoutGridStyleFill,
  MSLayoutGridStyleBorder,
}

interface MSLegacyDocumentReaderAllocator<InitializedType = MSLegacyDocumentReader> extends MSDocumentReaderAllocator<MSLegacyDocumentReader> {
  initWithFileURL(url: NSURL | null): InitializedType;
}
interface MSLegacyDocumentReader extends MSDocumentReader {
}
declare const MSLegacyDocumentReader: {
  alloc(): MSLegacyDocumentReaderAllocator;
}

interface IMSLibraryObject {

  name(): NSString;
  libraryID(): NSString;
  document(): MSDocumentData;
}

declare type MSLine = {
  A: CGFloat
  B: CGFloat
  C: CGFloat
}

declare type MSLineSegment = {
  p0: CGPoint
  p1: CGPoint
}

declare enum MSMarkerType {
  MSMarkerTypeNone = 0,
  MSMarkerTypeOpenArrow = 1,
  MSMarkerTypeFilledArrow = 2,
  MSMarkerTypeLine = 3,
  MSMarkerTypeOpenCircle = 4,
  MSMarkerTypeFilledCircle = 5,
  MSMarkerTypeOpenSquare = 6,
  MSMarkerTypeFilledSquare = 7,
  MSMarkerTypeFilledArrowRounded,
  MSMarkerTypeFilledSquareRounded,
}

declare enum MSSharedStyleType {
  MSSharedStyleTypeLayerStyles = 1,
  MSSharedStyleTypeTextStyles,
  MSSharedStyleTypeUnknown,
}

interface IMSModelObject {
}

declare enum MSModelCopyOptions {
  MSModelCopyNormal = 0x0000,
  MSModelPreserveIDs = 0x0001,
}

interface MSModelObjectCacheGenerationAllocator<InitializedType = MSModelObjectCacheGeneration> extends NSObjectAllocator<MSModelObjectCacheGeneration> {}
interface MSModelObjectCacheGeneration extends NSObject {
}
declare const MSModelObjectCacheGeneration: {
  alloc(): MSModelObjectCacheGenerationAllocator;
}

interface IMSModelObjectCommon {

  objectID(): NSString;
}

declare enum MSRootObjectMessage {
  MSRootObjectMessageRulersChangedUsingUndo,
}

interface MSModelResourcesAllocator<InitializedType = MSModelResources> extends BCSingletonAllocator<MSModelResources> {}
interface MSModelResources extends BCSingleton {
  preloadResources(): void;
  URLForImageResource(resource: NSString | string): NSURL;
  URLForResource_withExtension(name: NSString | string, ext: NSString | string): NSURL;
  resourcesNeedingMigration(): NSArray<any>;

  bundle(): NSBundle;
  setBundle(bundle: NSBundle): void;
  noiseImages(): NSArray<any>;
  setNoiseImages(noiseImages: NSArray<any> | any[]): void;
  errorPattern(): NSBitmapImageRep;
}
declare const MSModelResources: {
  alloc(): MSModelResourcesAllocator;
}

interface MSOvalShapeAllocator<InitializedType = MSOvalShape> extends _MSOvalShapeAllocator<MSOvalShape> {}
interface MSOvalShape extends _MSOvalShape {
}
declare const MSOvalShape: {
  alloc(): MSOvalShapeAllocator;
}

interface MSOverrideMappingAllocator<InitializedType = MSOverrideMapping> extends NSObjectAllocator<MSOverrideMapping> {}
interface MSOverrideMapping extends NSObject {
  removeOverridePoint(overridePoint: MSOverridePoint): void;

  score(): NSInteger;
  overridePoint(): MSOverridePoint;
  oldOverridePoint(): MSOverridePoint;
}
declare const MSOverrideMapping: {
  alloc(): MSOverrideMappingAllocator;  overrideMappingFor_withOldOverrides(overridePoint: MSOverridePoint, oldOverridePoints: NSArray<any> | any[]): MSOverrideMapping;
  consolidateAndFindNextMappingFrom(mappings: NSMutableArray<any> | any[]): MSOverrideMapping;

}

interface MSOverridePointAllocator<InitializedType = MSOverridePoint> extends NSObjectAllocator<MSOverridePoint> {
  initWithLayer_property_parent(layer: MSImmutableLayer, property: NSString | string, parent: MSOverridePoint | null): InitializedType;
}
interface MSOverridePoint extends NSObject {
  comparisonScoreAgainst(point: MSOverridePoint): NSInteger;
  distanceToOverridePoint(point: MSOverridePoint): NSUInteger;

  layerID(): NSString;
  property(): NSString;
  name(): NSString;
  path(): NSString;
  isSymbolOverride(): boolean;
  isStyleOverride(): boolean;
}
declare const MSOverridePoint: {
  alloc(): MSOverridePointAllocator;
}

interface MSOverrideValueAllocator<InitializedType = MSOverrideValue> extends _MSOverrideValueAllocator<MSOverrideValue> {
  initWithName_value(name: NSString | string, value: NSObject): InitializedType;
}
interface MSOverrideValue extends _MSOverrideValue {
  addPredecessor(predecessor: MSOverrideValue): void;

  isInherited(): boolean;
  setIsInherited(isInherited: boolean): void;
  predecessor(): MSOverrideValue;
  attributeName(): NSString;
}
declare const MSOverrideValue: {
  alloc(): MSOverrideValueAllocator;
}

interface MSPasteboardLayersAllocator<InitializedType = MSPasteboardLayers> extends NSObjectAllocator<MSPasteboardLayers> {}
interface MSPasteboardLayers extends NSObject, IMSLayerTraits {
  insertOnPage_viewport_hint(page: MSPage, viewport: MSPastingViewport, destinationHint: MSLayer | null): MSPastingViewport;
  insertInGroup_atPosition_afterLayer_viewport_fitToParent(group: MSLayerGroup, position: NSPoint, afterLayer: any, viewport: MSPastingViewport | null, fitToParent: boolean): MSLayerArray;
  traits(): MSTraits;
  canBeContainedInLayer(layer: MSLayer): boolean;
  unionSize(): NSSize;
  layerPositionsRelativeToUnion(): NSArray<any>;
  suggestedRect(): NSRect;

  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  sharedStyles(): NSArray<any>;
  setSharedStyles(sharedStyles: NSArray<any> | any[]): void;
  localSymbols(): NSDictionary<any, any>;
  setLocalSymbols(localSymbols: NSDictionary<any, any> | {[key: string]: any}): void;
  foreignSymbols(): NSDictionary<any, any>;
  setForeignSymbols(foreignSymbols: NSDictionary<any, any> | {[key: string]: any}): void;
  suggestedPosition(): NSPoint;
  setSuggestedPosition(suggestedPosition: NSPoint): void;
  parentTraits(): MSTraits;
  setParentTraits(parentTraits: MSTraits): void;
}
declare const MSPasteboardLayers: {
  alloc(): MSPasteboardLayersAllocator;  pasteboardLayersWithLayers(layers: NSArray<any> | any[]): MSPasteboardLayers;
  pasteboardLayersWithForeignLayers(layers: NSArray<any> | any[]): MSPasteboardLayers;

}

interface MSPasteboardLayersBaseAllocator<InitializedType = MSPasteboardLayersBase> extends NSObjectAllocator<MSPasteboardLayersBase> {}
interface MSPasteboardLayersBase extends NSObject {
}
declare const MSPasteboardLayersBase: {
  alloc(): MSPasteboardLayersBaseAllocator;  dictionaryFromPasteboardLayers(pasteboardLayers: MSPasteboardLayers): NSDictionary<any, any>;
  dataFromPasteboardDictionary(dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  pasteboardDataFromData(data: NSData | null): MSPasteboardLayers;

}

declare enum MSPasteboardVersion {
  MSPasteboardVersionUnknown = 0,
  MSPasteboardVersion34 = 1,
  MSPasteboardVersion34WithSeparateLayersArchiving = 2,
  MSPasteboardVersion36 = 3,
  MSPasteboardUsingJSON = 4,
  MSPasteboardForeignObjects = 5,
  MSPasteboardArchiveObjectIDs = 6,
  MSPasteboardForeignStyles = 7,
  MSPasteboardNextVersion,
  MSPasteboardCurrentVersion,
}

interface MSPasteboardLayersReaderWriterAllocator<InitializedType = MSPasteboardLayersReaderWriter> extends NSObjectAllocator<MSPasteboardLayersReaderWriter> {}
interface MSPasteboardLayersReaderWriter extends NSObject, IMSPasteboardReader, IMSPasteboardWriter {
}
declare const MSPasteboardLayersReaderWriter: {
  alloc(): MSPasteboardLayersReaderWriterAllocator;
}

interface MSPasteboardLayerListReaderWriterAllocator<InitializedType = MSPasteboardLayerListReaderWriter> extends MSPasteboardLayersReaderWriterAllocator<MSPasteboardLayerListReaderWriter> {}
interface MSPasteboardLayerListReaderWriter extends MSPasteboardLayersReaderWriter {
}
declare const MSPasteboardLayerListReaderWriter: {
  alloc(): MSPasteboardLayerListReaderWriterAllocator;
}

interface MSPasteboardPageListReaderWriterAllocator<InitializedType = MSPasteboardPageListReaderWriter> extends MSPasteboardLayersReaderWriterAllocator<MSPasteboardPageListReaderWriter> {}
interface MSPasteboardPageListReaderWriter extends MSPasteboardLayersReaderWriter {
}
declare const MSPasteboardPageListReaderWriter: {
  alloc(): MSPasteboardPageListReaderWriterAllocator;
}

interface MSPasteboardManagerAllocator<InitializedType = MSPasteboardManager> extends NSObjectAllocator<MSPasteboardManager> {}
interface MSPasteboardManager extends NSObject {
  registerDefaultReadersAndWriters(): void;
}
declare const MSPasteboardManager: {
  alloc(): MSPasteboardManagerAllocator;  readPasteboardLayersFromPasteboard_colorSpace_options(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions): MSPasteboardLayers;
  readPasteboardLayersFromDrag_colorSpace(dragInfo: any, colorSpace: NSColorSpace): MSPasteboardLayers;
  writePasteboardLayers_toPasteboard(layers: MSPasteboardLayers, pasteboard: NSPasteboard): void;
  registerReader(reader: any): void;
  registerWriter(writer: any): void;
  registerViewForSupportedDraggedTypes(view: NSView): void;

}

interface IMSPasteboardReader {
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
}

declare enum MSPasteboardReaderOptions {
  MSPasteboardReaderOptionsNone = 0,
  MSPasteboardReaderOptionsStripTextStyle = 1<<0,
  MSPasteboardReaderOptionsDefault,
}

interface IMSPasteboardWriter {
  canWriteDataToPasteboard(pasteboard: NSPasteboard): boolean;
  supportedPasteboardTypes(): NSArray<any>;
  writeData_toPasteboard(data: MSPasteboardLayers, pasteboard: NSPasteboard): void;
}

interface MSPastingViewportAllocator<InitializedType = MSPastingViewport> extends NSObjectAllocator<MSPastingViewport> {}
interface MSPastingViewport extends NSObject {
  viewportContainingLayers(layers: MSLayerArray): MSPastingViewport;

  zoomValue(): CGFloat;
  visibleRect(): NSRect;
}
declare const MSPastingViewport: {
  alloc(): MSPastingViewportAllocator;  viewportWithVisibleRect_zoom(visibleRect: NSRect, zoom: CGFloat): MSPastingViewport;

}

interface MSPathAllocator<InitializedType = MSPath> extends NSObjectAllocator<MSPath> {
  initWithCGPath(pathRef: CGPathRef): InitializedType;
  initWithContours(contours: NSArray<any> | any[]): InitializedType;
  initWithRect(rect: CGRect): InitializedType;
  initWithRoundedRect_radius(rect: CGRect, radius: CGFloat): InitializedType;
  initWithSquircleInRect_radius(rect: CGRect, radius: CGFloat): InitializedType;
  initWithEllipseInRect(rect: CGRect): InitializedType;
  initWithLineFrom_to(point1: CGPoint, point2: CGPoint): InitializedType;
  initWithCurveFromPoint_to_controlPoint1_controlPoint2(point: CGPoint, to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): InitializedType;
  initWithPoints_pointCount_close(points: CGPoint, pointCount: number, close: boolean): InitializedType;
  initWithBezierPath(bezierPath: NSBezierPath): InitializedType;
}
interface MSPath extends NSObject, INSCopying {
  booleanOp_withPath(op: MSBooleanOperation, otherPath: MSPath): MSPath;
  booleanUnionWith(otherPath: MSPath): MSPath;
  booleanIntersectWith(otherPath: MSPath): MSPath;
  booleanSubtractWith(otherPath: MSPath): MSPath;
  booleanExclusiveOrWith(otherPath: MSPath): MSPath;
  shadowPathForStrokeType_lineWidth(strokeType: MSShadowBorderType, lineWidth: CGFloat): MSPath;
  shadowPathWithSpread(spread: CGFloat): MSPath;
  shadowPathWithSpread_borderOptions_strokeType_lineWidth(spread: CGFloat, borderOptions: MSImmutableStyleBorderOptions, strokeType: MSShadowBorderType, lineWidth: CGFloat): MSPath;
  copyWithZone(zone: NSZone): MSPath;
  transformedPathUsingAffineTransform(transform: CGAffineTransform): MSPath;
  transformedPathUsingMapBlock(map: Block): MSPath;
  pathWithInset(inset: CGFloat): MSPath;
  pathWithInset_joinStrategy(inset: CGFloat, strategy: MSBezierJoinStrategy): MSPath;
  outlinePathWithWidth(width: CGFloat): MSPath;
  outlinePathWithWidth_lineCap_lineJoin(width: CGFloat, lineCap: CGLineCap, lineJoin: CGLineJoin): MSPath;
  pathByRemovingSubsequentMoveToComponents(): MSPath;
  pathByCuttingBeforeIndex(index: NSUInteger): MSPath;
  pathByScalingToBounds(bounds: CGRect): MSPath;
  reversedPath(): MSPath;
  pathByJoiningWithPath(path: MSPath): MSPath;
  pointAtIndex(index: NSUInteger): CGPoint;
  pointOnPathAtLength(length: CGFloat): CGPoint;
  length(): CGFloat;
  startPoint(): CGPoint;
  endPoint(): CGPoint;
  bezierIndexForPoint_tolerance(point: CGPoint, tolerance: CGFloat): NSUInteger;
  containsPoint(point: CGPoint): boolean;
  isClosed(): boolean;
  pointsInRect(rect: NSRect): NSArray<any>;
  elementAtIndex(index: NSUInteger): MSCGPathElement;
  isEqualToPath(path: MSPath): boolean;
  isEqualToPath_epsilon(path: MSPath, epsilon: CGFloat): boolean;
  clipContext_windingRule_inBlock(context: CGContextRef, windingRule: NSWindingRule, block: Block): void;
  addClipForWindingRule_context(windingRule: NSWindingRule, context: CGContextRef): void;
  pathWithDashPattern(dashPattern: NSArray<any> | any[]): MSPath;
  outerPathWithRect(rect: CGRect): MSPath;
  pathWithOuterPathOfSize(amount: CGFloat): MSPath;
  insetPathBy(inset: CGFloat): MSPath;
  insetPathBy_borderOptions(size: CGFloat, options: MSImmutableStyleBorderOptions): MSPath;
  pathByGrowingBy(offset: CGFloat): MSPath;
  outlinePathWithLineWidth_borderOptions(lineWidth: CGFloat, borderOptions: MSImmutableStyleBorderOptions): MSPath;
  shadowPathForStrokeType_lineWidth_cacheObject_context(strokeType: MSShadowBorderType, lineWidth: CGFloat, cacheObject: MSModelObjectCommon, context: MSRenderingContext): MSPath;
  shadowPathWithSpread_cacheObject_context(spread: CGFloat, cacheObject: MSModelObjectCommon, context: MSRenderingContext): MSPath;
  shadowPathWithSpread_borderOptions_strokeType_lineWidth_cacheObject_context(spread: CGFloat, borderOptions: MSImmutableStyleBorderOptions, strokeType: MSShadowBorderType, lineWidth: CGFloat, cacheObject: MSModelObjectCommon, context: MSRenderingContext): MSPath;

  CGPath(): CGPathRef;
  isEmpty(): boolean;
  elementCount(): NSUInteger;
  contours(): NSArray<any>;
  isRectangular(): boolean;
  bounds(): CGRect;
  controlPointBounds(): CGRect;
  safeBounds(): CGRect;
  subpaths(): NSArray<any>;
}
declare const MSPath: {
  alloc(): MSPathAllocator;  pathWithSubpaths(subpaths: NSArray<any> | any[]): MSPath;
  pathWithContours(contours: NSArray<any> | any[]): MSPath;
  pathWithRect(rect: CGRect): MSPath;
  pathWithEllipseInRect(rect: CGRect): MSPath;
  pathWithCGPath(pathRef: CGPathRef): MSPath;
  pathWithBezierPath(bezierPath: NSBezierPath): MSPath;
  pathWithLineFrom_to(point1: CGPoint, point2: CGPoint): MSPath;
  pathWithCurveFromPoint_to_controlPoint1_controlPoint2(point: CGPoint, to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): MSPath;
  pathWithPoints_pointCount_close(points: CGPoint, pointCount: number, close: boolean): MSPath;

}

declare type MSCGPathElement = {
  type: CGPathElementType
  controlPoints: [CGPoint, CGPoint]
  toPoint: CGPoint
}

interface IMSPathLayer {
  simplify(): void;
  reversePath(): void;

  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  edited(): boolean;
  setEdited(edited: boolean): void;
  pathInFrame(): MSPath;
  setPathInFrame(pathInFrame: MSPath): void;
}

interface IMSImmutablePathLayer {

  decoratedPathInBounds(): MSPath;
  hasMarkers(): boolean;
  style(): MSImmutableStyle;
}

declare enum MSPatternFillType {
  MSPatternFillTypeTile = 0,
  MSPatternFillTypeFill = 1,
  MSPatternFillTypeStretch = 2,
  MSPatternFillTypeFit = 3,
}

interface MSPersistentAssetCollectionAllocator<InitializedType = MSPersistentAssetCollection> extends MSAssetCollectionAllocator<MSPersistentAssetCollection> {}
interface MSPersistentAssetCollection extends MSAssetCollection {
  save(): void;
  resourceNeedingMigration(): NSArray<any>;
  cleanupAfterTesting(): void;
}
declare const MSPersistentAssetCollection: {
  alloc(): MSPersistentAssetCollectionAllocator;  assetCollectionWithName(name: NSString | string): MSPersistentAssetCollection;
  assetCollectionByMigratingPresetsFromSources(sources: MSAssetMigrationSources): MSPersistentAssetCollection;
  defaultMigrationSources(): MSAssetMigrationSources;
  defaultExportPresets(): NSArray<any>;

}

interface MSAssetMigrationSourcesAllocator<InitializedType = MSAssetMigrationSources> extends NSObjectAllocator<MSAssetMigrationSources> {}
interface MSAssetMigrationSources extends NSObject {

  imageURL(): NSURL;
  setImageURL(imageURL: NSURL): void;
}
declare const MSAssetMigrationSources: {
  alloc(): MSAssetMigrationSourcesAllocator;
}

interface MSPointArrayAllocator<InitializedType = MSPointArray> extends NSObjectAllocator<MSPointArray> {}
interface MSPointArray extends NSObject, INSCopying {
  addPoint(aPoint: NSPoint): void;
  insertPoint_atIndex(aPoint: NSPoint, i: NSUInteger): void;
  pointAtIndex(i: NSUInteger): NSPoint;
  removePointAtIndex(i: NSUInteger): void;
  countOfPoints(): NSUInteger;
  replacePointAtIndex_withPoint(i: NSUInteger, aPoint: NSPoint): void;
}
declare const MSPointArray: {
  alloc(): MSPointArrayAllocator;
}

declare enum MSPointRadiusBehaviour {
  MSPointRadiusBehaviourV0 = 0,
  MSPointRadiusBehaviourV1 = 1,
  MSPointRadiusBehaviourV1Smooth = 2,
  MSPointRadiusBehaviourDisabled = -1,
  MSPointRadiusBehaviourLegacy,
  MSPointRadiusBehaviourCurrent,
}

interface MSPolygonShapeAllocator<InitializedType = MSPolygonShape> extends _MSPolygonShapeAllocator<MSPolygonShape> {}
interface MSPolygonShape extends _MSPolygonShape {
}
declare const MSPolygonShape: {
  alloc(): MSPolygonShapeAllocator;
}

interface MSRectAllocator<InitializedType = MSRect> extends _MSRectAllocator<MSRect> {
  initWithX_y_width_height(x: CGFloat, y: CGFloat, w: CGFloat, h: CGFloat): InitializedType;
  initWithRect(rect: NSRect): InitializedType;
}
interface MSRect extends _MSRect, IMSRect {
  calculateProportions(): void;
  performUpdatesWithUnconstrainedProportions(block: Block): void;
  setRectByIgnoringProportions(newRect: NSRect): void;
  shouldConstrainProportions(): boolean;
  containsPoint(p: NSPoint): boolean;
  isIntegral(): boolean;
  makeOriginIntegral(): void;
  makeRectIntegral(): void;
  log(): void;

  rect(): NSRect;
  setRect(rect: NSRect): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  origin(): NSPoint;
  setOrigin(origin: NSPoint): void;
  mid(): NSPoint;
  setMid(mid: NSPoint): void;
  primitiveConstrainProportions(): boolean;
  setPrimitiveConstrainProportions(primitiveConstrainProportions: boolean): void;
  proportions(): CGFloat;
  setProportions(proportions: CGFloat): void;
}
declare const MSRect: {
  alloc(): MSRectAllocator;  rectWithX_y_width_height(x: CGFloat, y: CGFloat, w: CGFloat, h: CGFloat): any;
  rectWithRect(rect: NSRect): any;
  rectWithUnionOfRects(rects: NSArray<any> | any[]): any;

}

interface IMSRect {

  rect(): NSRect;
  size(): NSSize;
  origin(): NSPoint;
}

interface IMSRectDelegate {
  rect_didChangeFromRect(rect: MSRect, oldRect: NSRect): void;
}

interface IMSRootLayer {

  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  rulerBase(): NSPoint;
  setRulerBase(rulerBase: NSPoint): void;
  contentBounds(): NSRect;
  rect(): CGRect;
}

interface IMSImmutableRootLayer {
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;

  grid(): MSImmutableSimpleGrid;
  layout(): MSImmutableLayoutGrid;
}

interface MSRulerCoordinateSpaceAllocator<InitializedType = MSRulerCoordinateSpace> extends NSObjectAllocator<MSRulerCoordinateSpace> {
  initWithLayer(layer: MSLayer): InitializedType;
}
interface MSRulerCoordinateSpace extends NSObject, IMSLayerCoordinateSpace {

  layer(): MSLayer;
}
declare const MSRulerCoordinateSpace: {
  alloc(): MSRulerCoordinateSpaceAllocator;
}

interface MSRulerDataAllocator<InitializedType = MSRulerData> extends _MSRulerDataAllocator<MSRulerData> {}
interface MSRulerData extends _MSRulerData {
  addGuide(): void;
  addGuideWithValue(value: CGFloat): void;
  addGuide(guide: NSNumber | number): void;
  removeGuideAtIndex(index: NSUInteger): void;
  removeGuide(guide: NSNumber | number): void;
  removeAllGuides(): void;
  numberOfGuides(): NSUInteger;
  guideAtIndex(index: NSUInteger): CGFloat;
  setValue_forGuideAtIndex(value: CGFloat, index: NSUInteger): void;
}
declare const MSRulerData: {
  alloc(): MSRulerDataAllocator;
}

interface IMSShapeGroup {

  hasMarkers(): boolean;
  isPartOfClippingMask(): boolean;
}

declare enum MSClippingMaskMode {
  MSClippingMaskOutline,
  MSClippingMaskAlpha,
}

interface MSShapePathAllocator<InitializedType = MSShapePath> extends _MSShapePathAllocator<MSShapePath> {}
interface MSShapePath extends _MSShapePath {
}
declare const MSShapePath: {
  alloc(): MSShapePathAllocator;
}

interface MSSharedObjectAllocator<InitializedType = MSSharedObject> extends _MSSharedObjectAllocator<MSSharedObject> {
  initWithName_firstInstance(name: NSString | string, firstInstance: MSSharedObjectInstance): InitializedType;
  initWithName_sharedObjectID_value(name: NSString | string, sharedObjectID: NSString | string, value: MSSharedObjectInstance): InitializedType;
}
interface MSSharedObject extends _MSSharedObject, IBCSortable {
  registerInstance(instance: MSSharedObjectInstance): void;
  unregisterInstance(instance: MSSharedObjectInstance): void;
  isSharedObjectForInstance(instance: MSSharedObjectInstance): boolean;
  newInstance(): MSSharedObjectInstance;
  isOutOfSyncWithInstance(instance: MSSharedObjectInstance): boolean;
}
declare const MSSharedObject: {
  alloc(): MSSharedObjectAllocator;
}

interface IMSSharedObjectInstance {
  type(): MSSharedStyleType;
  syncWithTemplateInstance(instance: any): void;

  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
}

declare type MSSharedObjectInstance = MSModelObject

interface MSSharedObjectContainerAllocator<InitializedType = MSSharedObjectContainer> extends _MSSharedObjectContainerAllocator<MSSharedObjectContainer> {}
interface MSSharedObjectContainer extends _MSSharedObjectContainer {
  removeSharedObject(sharedObject: MSSharedObject): void;
  removeSharedObjects(sharedObjects: NSArray<any> | any[]): void;
  instancesOf_inContainer(sharedObjectIDs: NSSet<any>, container: any): NSArray<any>;
  isSharedObjectForInstance(instance: MSSharedObjectInstance): boolean;
  sharedObjectForInstance(instance: MSSharedObjectInstance): MSSharedObject;
  sharedObjectWithID(sharedObjectID: NSString | string): MSSharedObject;
  sharedObjectAtIndex(index: NSUInteger): MSSharedObject;
  indexOfSharedObject(sharedObject: MSSharedObject): NSInteger;
  numberOfSharedObjects(): NSUInteger;
  registerInstance_withSharedObject(instance: MSSharedObjectInstance, sharedObject: MSSharedObject): void;
  unregisterInstance(instance: MSSharedObjectInstance): void;
  sharedObjectsInLayers(layers: MSLayerArray): NSDictionary<any, any>;
  objectsSortedByName(): NSArray<any>;
}
declare const MSSharedObjectContainer: {
  alloc(): MSSharedObjectContainerAllocator;
}

interface IMSSharedStylePasting {
  handlePasteIntoDocument(document: MSDocumentData): NSString;

  currentObjectID_MSSharedStylePasting(): NSString;
}

interface MSSharedStyleContainerAllocator<InitializedType = MSSharedStyleContainer> extends _MSSharedStyleContainerAllocator<MSSharedStyleContainer> {}
interface MSSharedStyleContainer extends _MSSharedStyleContainer {
  removeSharedStyle(sharedStyle: MSSharedStyle): void;
  isSharedStyleForInstance(instance: MSStyle): boolean;
  sharedStyleForInstance(instance: MSStyle): MSSharedStyle;
  sharedStyleWithID(sharedStyleID: NSString | string): MSSharedStyle;
  sharedStyleAtIndex(index: NSUInteger): MSSharedStyle;
  indexOfSharedStyle(sharedStyle: MSSharedStyle): NSInteger;
  numberOfSharedStyles(): NSUInteger;
  registerInstance_withSharedStyle(instance: MSStyle, sharedObject: MSSharedStyle): void;
  validStyleType(): MSSharedStyleType;
  sharedStyles(): NSArray<any>;
}
declare const MSSharedStyleContainer: {
  alloc(): MSSharedStyleContainerAllocator;
}

interface MSSharedTextStyleContainerAllocator<InitializedType = MSSharedTextStyleContainer> extends _MSSharedTextStyleContainerAllocator<MSSharedTextStyleContainer> {}
interface MSSharedTextStyleContainer extends _MSSharedTextStyleContainer {
}
declare const MSSharedTextStyleContainer: {
  alloc(): MSSharedTextStyleContainerAllocator;
}

interface MSSmoothBezierFilletAllocator<InitializedType = MSSmoothBezierFillet> extends MSBezierFilletAllocator<MSSmoothBezierFillet> {}
interface MSSmoothBezierFillet extends MSBezierFillet {
}
declare const MSSmoothBezierFillet: {
  alloc(): MSSmoothBezierFilletAllocator;  smoothBezierFilletWithLineSegment1_lineSegment2_filletRadius(segment1: MSBezierSegment, segment2: MSBezierSegment, filletRadius: CGFloat): MSSmoothBezierFillet;

}

interface MSStarShapeAllocator<InitializedType = MSStarShape> extends _MSStarShapeAllocator<MSStarShape> {}
interface MSStarShape extends _MSStarShape {
}
declare const MSStarShape: {
  alloc(): MSStarShapeAllocator;
}

declare enum MSStylePartType {
  MSStylePartFill,
  MSStylePartBorder,
  MSStylePartShadow,
  MSStylePartInnerShadow,
}

interface MSStyleBasicFillAllocator<InitializedType = MSStyleBasicFill> extends _MSStyleBasicFillAllocator<MSStyleBasicFill> {}
interface MSStyleBasicFill extends _MSStyleBasicFill, IMSColorConvertible {
  previewImageOfSize_colorSpace_clippingAsBorder_borderWidth(size: NSSize, colorSpace: NSColorSpace, clipBorder: boolean, borderWidth: CGFloat): NSImage;
}
declare const MSStyleBasicFill: {
  alloc(): MSStyleBasicFillAllocator;  defaultFillColor(): NSColor;
  drawBasicFill_colorSpace_enabled_inRect(basicFill: MSStyleBasicFill, colorSpace: NSColorSpace, enabled: boolean, frame: NSRect): void;
  drawCheckerboardBackgroundInRect(r: NSRect): void;
  drawColor_enabled_inRect(color: NSColor, enabled: boolean, frame: NSRect): void;

}

interface MSStyleBlurAllocator<InitializedType = MSStyleBlur> extends _MSStyleBlurAllocator<MSStyleBlur> {}
interface MSStyleBlur extends _MSStyleBlur {
  cropRadius(): CGFloat;
}
declare const MSStyleBlur: {
  alloc(): MSStyleBlurAllocator;
}

declare enum MSStyleBlurType {
  MSStyleBlurGaussian = 0,
  MSStyleBlurMotion = 1,
  MSStyleBlurZoom = 2,
  MSStyleBlurBackground = 3,
}

interface MSStyleBorderOptionsAllocator<InitializedType = MSStyleBorderOptions> extends _MSStyleBorderOptionsAllocator<MSStyleBorderOptions> {}
interface MSStyleBorderOptions extends _MSStyleBorderOptions {

  hasDashPattern(): boolean;
}
declare const MSStyleBorderOptions: {
  alloc(): MSStyleBorderOptionsAllocator;
}

interface MSStyleColorControlsAllocator<InitializedType = MSStyleColorControls> extends _MSStyleColorControlsAllocator<MSStyleColorControls> {}
interface MSStyleColorControls extends _MSStyleColorControls {
  hasDefaultColorControlsValues(): boolean;
  resetToDefaultValues(): void;
}
declare const MSStyleColorControls: {
  alloc(): MSStyleColorControlsAllocator;
}

declare enum BCFillType {
  BCFillTypeColor = 0,
  BCFillTypeGradient = 1,
  BCFillTypePattern = 4,
  BCFillTypeNoise = 5,
}

declare enum MSBorderPositionType {
  MSBorderPositionCenter = 0,
  MSBorderPositionInside = 1,
  MSBorderPositionOutside = 2,
}

interface IMSStylePart {

  isEnabled(): boolean;
}

interface IMSStyledLayer {
}

interface MSSymbolAllocator<InitializedType = MSSymbol> extends _MSSymbolAllocator<MSSymbol> {}
interface MSSymbol extends _MSSymbol {
}
declare const MSSymbol: {
  alloc(): MSSymbolAllocator;
}

interface MSSymbolContainerAllocator<InitializedType = MSSymbolContainer> extends _MSSymbolContainerAllocator<MSSymbolContainer> {}
interface MSSymbolContainer extends _MSSymbolContainer {
}
declare const MSSymbolContainer: {
  alloc(): MSSymbolContainerAllocator;
}

interface IMSTextLayerEditingDelegate {
  adjustTextViewFrame(): void;
  adjustForegroundColor(): void;
}

interface MSTextLayoutAllocator<InitializedType = MSTextLayout> extends NSObjectAllocator<MSTextLayout> {}
interface MSTextLayout extends NSObject {

  baselineOffsets(): NSArray<any>;
  lineFragmentRectangles(): NSArray<any>;
  firstBaselineOffset(): CGFloat;
  lastBaselineOffset(): CGFloat;
  lineFragmentBounds(): CGRect;
  firstLineCapOffset(): CGFloat;
}
declare const MSTextLayout: {
  alloc(): MSTextLayoutAllocator;  textLayoutForLayoutManager(layoutManager: NSLayoutManager): MSTextLayout;

}

interface MSTrailingLayersMoverAllocator<InitializedType = MSTrailingLayersMover> extends NSObjectAllocator<MSTrailingLayersMover> {}
interface MSTrailingLayersMover extends NSObject {
}
declare const MSTrailingLayersMover: {
  alloc(): MSTrailingLayersMoverAllocator;  changeFrameForLayers_inBlock(layers: NSArray<any> | any[], block: BCVoidBlock): void;

}

interface MSTreeDiffAllocator<InitializedType = MSTreeDiff> extends NSObjectAllocator<MSTreeDiff> {
  initWithFirstDocument_secondDocument(firstDoc: MSImmutableDocumentData, secondDoc: MSImmutableDocumentData): InitializedType;
}
interface MSTreeDiff extends NSObject {
  diffs(): NSArray<any>;
  contentDirtyDiffRect(): NSRect;
  overlayDirtyDiffRect(): NSRect;
  changedPropertiesAllExhibitTrait_allKeysWereCompared(trait: MSPropertyTraits, allKeysWereCompared: boolean): boolean;
  someChangedPropertiesExhibitTrait_allKeysWereCompared(targetTrait: MSPropertyTraits, allKeysWereCompared: boolean): boolean;
  containsLayerWithTraits(traits: MSTraits): boolean;
}
declare const MSTreeDiff: {
  alloc(): MSTreeDiffAllocator;
}

interface MSTriangleShapeAllocator<InitializedType = MSTriangleShape> extends _MSTriangleShapeAllocator<MSTriangleShape> {}
interface MSTriangleShape extends _MSTriangleShape {
}
declare const MSTriangleShape: {
  alloc(): MSTriangleShapeAllocator;
}

interface MSUnitCoordinateSpaceAllocator<InitializedType = MSUnitCoordinateSpace> extends NSObjectAllocator<MSUnitCoordinateSpace> {}
interface MSUnitCoordinateSpace extends NSObject, IMSLayerCoordinateSpace {

  parentCoordinateSpace(): any;
  setParentCoordinateSpace(parentCoordinateSpace: any): void;
}
declare const MSUnitCoordinateSpace: {
  alloc(): MSUnitCoordinateSpaceAllocator;  convertPoint_fromBounds(point: CGPoint, bounds: CGRect): CGPoint;
  convertPoint_toBounds(point: CGPoint, bounds: CGRect): CGPoint;

}

declare enum MSUserVisibleScaleType {
  MSUserVisibleScaleTypeScale = 0,
  MSUserVisibleScaleTypeWidth = 1,
  MSUserVisibleScaleTypeHeight = 2,
}

interface MSVersionedArchiveAllocator<InitializedType = MSVersionedArchive> extends NSObjectAllocator<MSVersionedArchive> {
  initWithURL_version(url: NSURL, version: MSDocumentVersion): InitializedType;
}
interface MSVersionedArchive extends NSObject {
  unarchiveRootObjectVersion_error(version: MSDocumentVersion, error: NSError): any;
  archiveRootObject_error(rootObject: any, error: NSError): boolean;
  URLNeedingMigration(): NSURL;
  exists(): boolean;
  cleanupAfterTesting(): void;
}
declare const MSVersionedArchive: {
  alloc(): MSVersionedArchiveAllocator;  globalArchiveWithName_extension_version(name: NSString | string, extension: NSString | string, version: MSDocumentVersion): MSVersionedArchive;
  versionedURLWithBase_extension_version(base: NSURL, extension: NSString | string, version: NSUInteger): NSURL;

}

declare enum MSBooleanOperation {
  MSBooleanOperationNone = -1,
  MSBooleanOperationUnion = 0,
  MSBooleanOperationSubtract = 1,
  MSBooleanOperationIntersect = 2,
  MSBooleanOperationDifference = 3,
}

interface NSBezierPathEnumeratorAllocator<InitializedType = NSBezierPathEnumerator> extends NSObjectAllocator<NSBezierPathEnumerator> {}
interface NSBezierPathEnumerator extends NSObject, INSFastEnumeration {
  objectAtIndex(index: NSUInteger): any;

  pathItems(): NSArray<any>;
  bezierPath(): NSBezierPath;
  setBezierPath(bezierPath: NSBezierPath): void;
  reverse(): boolean;
  setReverse(reverse: boolean): void;
}
declare const NSBezierPathEnumerator: {
  alloc(): NSBezierPathEnumeratorAllocator;
}

interface NSBezierPathItemAllocator<InitializedType = NSBezierPathItem> extends NSObjectAllocator<NSBezierPathItem> {}
interface NSBezierPathItem extends NSObject {
  points(): NSPoint;
  setPoints(p: NSPoint): void;
  bezierPathStartingAtPoint(point: NSPoint): NSBezierPath;
  isEqual_withAccuracy(other: NSBezierPathItem, accuracy: CGFloat): boolean;

  type(): NSBezierPathElement;
  setType(type: NSBezierPathElement): void;
}
declare const NSBezierPathItem: {
  alloc(): NSBezierPathItemAllocator;
}

interface CMapParserAllocator<InitializedType = CMapParser> extends NSObjectAllocator<CMapParser> {
  initWithStream(stream: PDFStream): InitializedType;
  initWithData(data: NSData): InitializedType;
}
interface CMapParser extends NSObject {

  map(): NSMutableDictionary<any, any>;
  setMap(map: NSMutableDictionary<any, any> | {[key: string]: any}): void;
}
declare const CMapParser: {
  alloc(): CMapParserAllocator;
}

interface EPSConverterAllocator<InitializedType = EPSConverter> extends NSObjectAllocator<EPSConverter> {}
interface EPSConverter extends NSObject {
  convertEPSAtURL_progressBlock(source: NSURL, progress: ProgressBlock): NSData;
  convertEPSData_progressBlock(data: NSData, progress: ProgressBlock): NSData;
  convertEPSAtURL_toURL_progressBlock(source: NSURL, destination: NSURL, progress: ProgressBlock): void;
}
declare const EPSConverter: {
  alloc(): EPSConverterAllocator;
}

interface EPSParserAllocator<InitializedType = EPSParser> extends NSObjectAllocator<EPSParser> {
  initWithScanner(scanner: PDFScanner): InitializedType;
}
interface EPSParser extends NSObject, IPDFParser {
}
declare const EPSParser: {
  alloc(): EPSParserAllocator;
}

interface MSPDFScannerAllocator<InitializedType = MSPDFScanner> extends PDFScannerAllocator<MSPDFScanner> {}
interface MSPDFScanner extends PDFScanner {

  rootLayer(): MSLayerGroup;
  setRootLayer(rootLayer: MSLayerGroup): void;
  substituteFontName(): NSString;
  setSubstituteFontName(substituteFontName: NSString | string): void;
}
declare const MSPDFScanner: {
  alloc(): MSPDFScannerAllocator;
}

interface MSPDFStateAllocator<InitializedType = MSPDFState> extends NSObjectAllocator<MSPDFState> {
  initWithScanner(scanner: MSPDFScanner): InitializedType;
}
interface MSPDFState extends NSObject, INSCopying {
  addLayer(layer: MSLayer): void;
  layerWithEnclosingGroup(enclosingGroup: boolean): MSLayer;
  makeArtboardGroup(): MSArtboardGroup;
  optimiseClipLayerInGroup(group: MSLayerGroup): boolean;
  lastLayer(): MSLayer;
  resetTransform(transform: NSAffineTransform): void;
  appendTransform(transform: NSAffineTransform): void;
  transformPoint(aPoint: NSPoint): NSPoint;
  transformSize(aSize: NSSize): NSSize;
  transformStruct(): NSAffineTransformStruct;
  transformBezierPath(aPath: NSBezierPath): NSBezierPath;
  stringFromTransform(transform: NSAffineTransform): NSString;
  updateClipping(): void;
  updateClippingWithTextPath(path: NSBezierPath): void;
  transformedClippingPath(): NSBezierPath;

  borderAlphaConstant(): CGFloat;
  setBorderAlphaConstant(borderAlphaConstant: CGFloat): void;
  borderColor(): NSColor;
  setBorderColor(borderColor: NSColor): void;
  borderColorSpace(): NSColorSpace;
  setBorderColorSpace(borderColorSpace: NSColorSpace): void;
  borderColorSpaceMapping(): PDFFunction;
  setBorderColorSpaceMapping(borderColorSpaceMapping: PDFFunction): void;
  borderDashes(): NSArray<any>;
  setBorderDashes(borderDashes: NSArray<any> | any[]): void;
  borderCapStyle(): NSLineCapStyle;
  setBorderCapStyle(borderCapStyle: NSLineCapStyle): void;
  borderGradient(): PDFPattern;
  setBorderGradient(borderGradient: PDFPattern): void;
  borderJoinStyle(): NSLineJoinStyle;
  setBorderJoinStyle(borderJoinStyle: NSLineJoinStyle): void;
  borderThickness(): CGFloat;
  setBorderThickness(borderThickness: CGFloat): void;
  clippingMode(): ClippingMode;
  setClippingMode(clippingMode: ClippingMode): void;
  clippingPath(): NSBezierPath;
  setClippingPath(clippingPath: NSBezierPath): void;
  clippingUpdated(): boolean;
  setClippingUpdated(clippingUpdated: boolean): void;
  containsClippedItems(): boolean;
  setContainsClippedItems(containsClippedItems: boolean): void;
  currentPoint(): NSPoint;
  setCurrentPoint(currentPoint: NSPoint): void;
  fillAlphaConstant(): CGFloat;
  setFillAlphaConstant(fillAlphaConstant: CGFloat): void;
  fillColor(): NSColor;
  setFillColor(fillColor: NSColor): void;
  fillColorSpace(): NSColorSpace;
  setFillColorSpace(fillColorSpace: NSColorSpace): void;
  fillColorSpaceMapping(): PDFFunction;
  setFillColorSpaceMapping(fillColorSpaceMapping: PDFFunction): void;
  fillGradient(): PDFPattern;
  setFillGradient(fillGradient: PDFPattern): void;
  layers(): NSMutableArray<any>;
  setLayers(layers: NSMutableArray<any> | any[]): void;
  path(): NSBezierPath;
  setPath(path: NSBezierPath): void;
  pathClosed(): boolean;
  setPathClosed(pathClosed: boolean): void;
  pathUsed(): boolean;
  setPathUsed(pathUsed: boolean): void;
  pathWasRect(): boolean;
  setPathWasRect(pathWasRect: boolean): void;
  renderingIntent(): CGColorRenderingIntent;
  setRenderingIntent(renderingIntent: CGColorRenderingIntent): void;
  text(): MSPDFTextState;
  setText(text: MSPDFTextState): void;
  transformedPath(): NSBezierPath;
  setTransformedPath(transformedPath: NSBezierPath): void;
  scanner(): MSPDFScanner;
  setScanner(scanner: MSPDFScanner): void;
}
declare const MSPDFState: {
  alloc(): MSPDFStateAllocator;
}

declare enum ClippingMode {
  ClippingModeNonZeroWinding,
  ClippingModeWithEvenOddWindow,
  ClippingModeDontClip,
}

interface MSPDFTextStateAllocator<InitializedType = MSPDFTextState> extends NSObjectAllocator<MSPDFTextState> {}
interface MSPDFTextState extends NSObject, INSCopying {
  shouldFill(): boolean;
  shouldStroke(): boolean;
  shouldClip(): boolean;
  setTransform_resettingLineTransform(transform: NSAffineTransform, resettingLineTransform: boolean): void;
  resetRenderingTransform(): void;
  appendText(text: NSString | string): void;
  attributes(): NSDictionary<any, any>;

  characterSpacing(): CGFloat;
  setCharacterSpacing(characterSpacing: CGFloat): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  fontName(): NSString;
  setFontName(fontName: NSString | string): void;
  fontInfo(): NSDictionary<any, any>;
  setFontInfo(fontInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  leading(): CGFloat;
  setLeading(leading: CGFloat): void;
  lineTransform(): NSAffineTransform;
  setLineTransform(lineTransform: NSAffineTransform): void;
  mode(): NSUInteger;
  setMode(mode: NSUInteger): void;
  offset(): CGFloat;
  setOffset(offset: CGFloat): void;
  renderingTransform(): NSAffineTransform;
  setRenderingTransform(renderingTransform: NSAffineTransform): void;
  rise(): CGFloat;
  setRise(rise: CGFloat): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  size(): CGFloat;
  setSize(size: CGFloat): void;
  state(): MSPDFState;
  setState(state: MSPDFState): void;
  text(): NSMutableAttributedString;
  setText(text: NSMutableAttributedString): void;
  transform(): NSAffineTransform;
  setTransform(transform: NSAffineTransform): void;
  wordSpacing(): CGFloat;
  setWordSpacing(wordSpacing: CGFloat): void;
}
declare const MSPDFTextState: {
  alloc(): MSPDFTextStateAllocator;  textStateWithState(state: MSPDFState): MSPDFTextState;

}

interface PDFFunctionAllocator<InitializedType = PDFFunction> extends NSObjectAllocator<PDFFunction> {
  initWithInfo(info: any): InitializedType;
}
interface PDFFunction extends NSObject {
  mapInputs_toOutputs(inputs: PDFFunctionInput, outputs: PDFFunctionOutput): void;

  samples(): NSData;
  parameters(): NSDictionary<any, any>;
  numberOfInputComponents(): NSUInteger;
  numberOfOutputComponents(): NSUInteger;
  bitsPerSample(): NSUInteger;
  bytesPerSampleComponent(): NSUInteger;
  bytesPerSample(): NSUInteger;
  numberOfSamples(): NSUInteger;
  domain(): NSArray<any>;
  setDomain(domain: NSArray<any> | any[]): void;
}
declare const PDFFunction: {
  alloc(): PDFFunctionAllocator;  functionWithInfo(info: any): PDFFunction;

}

declare type PDFFunctionInput = CGFloat[]

declare type PDFFunctionOutput = CGFloat[]

interface PDFOperatorInfoAllocator<InitializedType = PDFOperatorInfo> extends NSObjectAllocator<PDFOperatorInfo> {}
interface PDFOperatorInfo extends NSObject {

  selector(): string;
  setSelector(selector: string): void;
  callback(): CGPDFOperatorCallback;
  setCallback(callback: CGPDFOperatorCallback): void;
  operatorName(): NSString;
  setOperatorName(operatorName: NSString | string): void;
  methodName(): NSString;
  setMethodName(methodName: NSString | string): void;
}
declare const PDFOperatorInfo: {
  alloc(): PDFOperatorInfoAllocator;
}

interface PDFParserAllocator<InitializedType = PDFParser> extends NSObjectAllocator<PDFParser> {
  initWithScanner(scanner: PDFScanner): InitializedType;
}
interface PDFParser extends NSObject, IPDFParser {

  name(): NSString;
  setName(name: NSString | string): void;
}
declare const PDFParser: {
  alloc(): PDFParserAllocator;
}

interface IPDFParser extends NSObject {
  loadDocumentFromURL(url: NSURL): void;
  loadDocumentFromData(data: NSData): void;
  parseWithProgress(progress: BCVoidBlock): void;
  parsePastedDocument(): void;
  pageCount(): NSUInteger;
  name(): NSString;
}

interface PDFPatternAllocator<InitializedType = PDFPattern> extends NSObjectAllocator<PDFPattern> {
  initWithResource(resource: any): InitializedType;
}
interface PDFPattern extends NSObject {

  shadingType(): ShadingType;
  function(): PDFFunction;
  space(): any;
  coords(): NSArray<any>;
}
declare const PDFPattern: {
  alloc(): PDFPatternAllocator;  patternWithResource(resource: any): PDFPattern;

}

declare enum ShadingType {
  ShadingTypeFunction = 1,
  ShadingTypeLinear,
  ShadingTypeRadial,
  ShadingTypeGouraudTriange,
  ShadingTypeGouraudLattice,
  ShadingTypeCoonsPatchMesh,
  ShadingTypeTensorProductPatchMesh,
}

interface PDFScannerAllocator<InitializedType = PDFScanner> extends NSObjectAllocator<PDFScanner> {
  init(): InitializedType;
}
interface PDFScanner extends NSObject {
  scanPage_parser_isPasted(page: CGPDFPageRef, parser: PDFParser, isPasted: boolean): void;
  scanStream_dictionary(stream: CGPDFContentStreamRef, dictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  popBool(): boolean;
  popDouble(): CGFloat;
  popInteger(): NSInteger;
  popRGBColor(): NSColor;
  popCMYKColor(): NSColor;
  popNumber(): NSNumber;
  popPoint(): NSPoint;
  popString(): PDFString;
  popName(): NSString;
  popTransform(): NSAffineTransform;
  popArray(): NSArray<any>;
  popObject(): any;
  colorSpaceWithInfo_mapping(info: any, mapping: PDFFunction): NSColorSpace;
  gradientForPattern(pattern: PDFPattern): NSGradient;
  currentPoint(): NSPoint;
  currentLeading(): CGFloat;
  currentFillColorSpace(): NSColorSpace;
  currentFillColorSpaceMapping(): PDFFunction;
  currentStrokeColorSpace(): NSColorSpace;
  currentStrokeColorSpaceMapping(): PDFFunction;
  currentFont(): NSDictionary<any, any>;
  moveTo(point: NSPoint): void;
  lineTo(point: NSPoint): void;
  curveTo_control1_control2(point: NSPoint, control1: NSPoint, control2: NSPoint): void;
  closePath(): void;
  endPath(): void;
  appendRectangle(rectangle: NSRect): void;
  defineMarkedPoint(): void;
  processXObject(object: PDFStream): void;
  processForm(form: PDFStream): void;
  processImage_info(image: NSImage, info: NSDictionary<any, any> | {[key: string]: any}): void;
  concatMatrix(transform: NSAffineTransform): void;
  saveGraphicState(): void;
  restoreGraphicState(): void;
  setLineWidth(width: CGFloat): void;
  setLineJoin(join: NSUInteger): void;
  setLineCap(cap: NSUInteger): void;
  setLineDash_phase(dashes: NSArray<any> | any[], phase: NSInteger): void;
  setMitreLimit(limit: CGFloat): void;
  setStrokeColourSpace_mapping(space: NSColorSpace, mapping: PDFFunction): void;
  setFillColourSpace_mapping(space: NSColorSpace, mapping: PDFFunction): void;
  setColourRenderingIntent(intent: CGColorRenderingIntent): void;
  setFillColour(colour: NSColor): void;
  setStrokeColour(colour: NSColor): void;
  setFillPattern(pattern: PDFPattern): void;
  setStrokePattern(pattern: PDFPattern): void;
  setFillAlphaConstant(alpha: CGFloat): void;
  setStrokeAlphaConstant(alpha: CGFloat): void;
  clipWithWinding(winding: NSWindingRule): void;
  fillWithWinding(winding: NSWindingRule): void;
  fillWithShadingPattern(pattern: PDFPattern): void;
  strokeWithWinding(winding: NSWindingRule): void;
  beginCompatibility(): void;
  endCompatibility(): void;
  beginMarkedContentWithProperty(): void;
  beginMarkedContent(): void;
  endMarkedContent(): void;
  beginImage(): void;
  setOverprintMode(mode: NSInteger): void;
  beginText(): void;
  setFontName_size_info(name: NSString | string, size: CGFloat, info: NSDictionary<any, any> | {[key: string]: any}): void;
  setTextCharacterSpacing(spacing: CGFloat): void;
  setTextWordSpacing(spacing: CGFloat): void;
  setTextLeading(spacing: CGFloat): void;
  setTextRise(spacing: CGFloat): void;
  setTextScale(spacing: CGFloat): void;
  setTextMode(mode: NSUInteger): void;
  setTextMatrix(matrix: NSAffineTransform): void;
  offset(offset: CGFloat): void;
  nextLineWithOffset(point: NSPoint): void;
  appendText(string: NSString | string): void;
  endText(): void;
  declareGlyph(): void;
  glyphBounds(): void;

  dictionary(): NSDictionary<any, any>;
  setDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): void;
}
declare const PDFScanner: {
  alloc(): PDFScannerAllocator;  convertObject(object: CGPDFObjectRef): any;
  convertArray(array: CGPDFArrayRef): NSArray<any>;
  convertDictionary(dictionary: CGPDFDictionaryRef): NSDictionary<any, any>;

}

interface PDFStreamAllocator<InitializedType = PDFStream> extends NSObjectAllocator<PDFStream> {
  initWithStream(stream: CGPDFStreamRef): InitializedType;
}
interface PDFStream extends NSObject {
  dictionary(): NSDictionary<any, any>;

  stream(): CGPDFStreamRef;
  format(): CGPDFDataFormat;
  data(): NSData;
  dictionary(): NSDictionary<any, any>;
}
declare const PDFStream: {
  alloc(): PDFStreamAllocator;
}

interface PDFStringAllocator<InitializedType = PDFString> extends NSObjectAllocator<PDFString> {
  initWithStringRef(stringRef: CGPDFStringRef): InitializedType;
}
interface PDFString extends NSObject {
  string(): NSString;
  data(): NSData;
  stringWithMap(map: NSDictionary<any, any> | {[key: string]: any}): NSString;
}
declare const PDFString: {
  alloc(): PDFStringAllocator;
}

interface PDFLoggingScannerAllocator<InitializedType = PDFLoggingScanner> extends PDFScannerAllocator<PDFLoggingScanner> {}
interface PDFLoggingScanner extends PDFScanner {
  log_method(string: NSString | string, method: string): void;
}
declare const PDFLoggingScanner: {
  alloc(): PDFLoggingScannerAllocator;
}

interface MSPluginBundleAllocator<InitializedType = MSPluginBundle> extends NSObjectAllocator<MSPluginBundle> {
  initPluginBundleWithURL(url: NSURL): InitializedType;
  initWithName_identifier_commands_icon(name: NSString | string, identifier: NSString | string, commands: NSArray<any> | any[], icon: NSImage): InitializedType;
}
interface MSPluginBundle extends NSObject {
  writeToURL(url: NSURL): boolean;
  urlForResourceNamed(resourceName: NSString | string): NSURL;

  url(): NSURL;
  commands(): NSDictionary<any, any>;
  version(): NSString;
  name(): NSString;
  icon(): NSImage;
  alertIcon(): NSImage;
  identifier(): NSString;
  versionedIdentifier(): NSString;
  pluginDescription(): NSString;
  suppliesData(): boolean;
  menuDescription(): NSDictionary<any, any>;
  setMenuDescription(menuDescription: NSDictionary<any, any> | {[key: string]: any}): void;
  homepageURL(): NSURL;
  author(): NSString;
  authorEmail(): NSString;
  appcastURL(): NSURL;
  compatibleVersion(): NSString;
  maximumCompatibleVersion(): NSString;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  compatible(): boolean;
  disableCocoaScriptPreprocessor(): boolean;
  setDisableCocoaScriptPreprocessor(disableCocoaScriptPreprocessor: boolean): void;
}
declare const MSPluginBundle: {
  alloc(): MSPluginBundleAllocator;  pluginBundleWithURL(url: NSURL): MSPluginBundle;

}

interface MSPluginCommandAllocator<InitializedType = MSPluginCommand> extends NSObjectAllocator<MSPluginCommand> {
  initWithScript_identifier_name_handlers_shortcut_scope(script: MSPluginScript, identifier: NSString | string, name: NSString | string, handlers: NSDictionary<any, any> | {[key: string]: any}, shortcut: NSString | string, scope: MSPluginCommandScope): InitializedType;
  initWithScript_identifier_name_runHandler_scope(script: MSPluginScript, identifier: NSString | string, name: NSString | string, runHandler: NSString | string, scope: MSPluginCommandScope): InitializedType;
}
interface MSPluginCommand extends NSObject, ICOPrintController {
  runHandlerWithKey_context_manager(handlerKey: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager): NSString;
  runHandlerWithKey_context_manager_onComplete(handlerKey: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager, callback: Block): NSString;
  runHandler_context_manager(handler: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager): NSString;
  runHandler_context_manager_onComplete(handler: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager, callback: Block): NSString;
  run_manager(context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager): NSString;
  run_manager_onComplete(context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager, callback: Block): NSString;
  tearDownIfFinished(): boolean;
  hasRunHandler(): boolean;
  menuItemWithAction(selector: string): NSMenuItem;
  metadata(): NSDictionary<any, any>;
  print(value: any): void;
  logString(): NSString;
  valueForKey_onLayer_forPluginIdentifier(key: NSString | string, layer: MSLayer, identifier: NSString | string): any;
  setValue_forKey_onLayer_forPluginIdentifier(value: any, key: NSString | string, layer: MSLayer, identifier: NSString | string): void;
  valueForKey_onLayer(key: NSString | string, layer: MSLayer): any;
  setValue_forKey_onLayer(value: any, key: NSString | string, layer: MSLayer): void;
  valueForKey_onDocument_forPluginIdentifier(key: NSString | string, document: MSDocumentData, identifier: NSString | string): any;
  setValue_forKey_onDocument_forPluginIdentifier(value: any, key: NSString | string, document: MSDocumentData, identifier: NSString | string): void;
  valueForKey_onDocument(key: NSString | string, document: MSDocumentData): any;
  setValueForKey_forKey_onDocument(value: any, key: NSString | string, document: MSDocumentData): void;

  identifier(): NSString;
  commandSpecifier(): MSPluginCommandSpecifier;
  script(): MSPluginScript;
  name(): NSString;
  shortcut(): NSString;
  pluginBundle(): MSPluginBundle;
  setPluginBundle(pluginBundle: MSPluginBundle): void;
  scope(): MSPluginCommandScope;
  stayRunning(): boolean;
  setStayRunning(stayRunning: boolean): void;
  disableCocoaScriptPreprocessor(): boolean;
  setDisableCocoaScriptPreprocessor(disableCocoaScriptPreprocessor: boolean): void;
}
declare const MSPluginCommand: {
  alloc(): MSPluginCommandAllocator;  commandWithJSON_scripts_scriptsURL(commandJSON: any, scripts: NSMutableDictionary<any, any> | {[key: string]: any}, scriptsURL: NSURL): MSPluginCommand;

}

declare enum MSPluginCommandScope {
  MSPluginCommandScopeDocument,
  MSPluginCommandScopeApplication,
}

interface MSPluginCommandSpecifierAllocator<InitializedType = MSPluginCommandSpecifier> extends NSObjectAllocator<MSPluginCommandSpecifier> {
  initWithPluginBundleIdentifier_commandIdentifier(pluginBundleIdentifier: NSString | string, commandIdentifier: NSString | string): InitializedType;
}
interface MSPluginCommandSpecifier extends NSObject, INSCopying {
  isEqualToCommandSpecifier(specifier: MSPluginCommandSpecifier): boolean;
  stringValue(): NSString;

  pluginBundleIdentifier(): NSString;
  commandIdentifier(): NSString;
}
declare const MSPluginCommandSpecifier: {
  alloc(): MSPluginCommandSpecifierAllocator;
}

interface MSPluginDebugControllerAllocator<InitializedType = MSPluginDebugController> extends NSObjectAllocator<MSPluginDebugController> {}
interface MSPluginDebugController extends NSObject, ICODebugController {
}
declare const MSPluginDebugController: {
  alloc(): MSPluginDebugControllerAllocator;
}

interface MSPluginManagerAllocator<InitializedType = MSPluginManager> extends NSObjectAllocator<MSPluginManager> {
  initialisePlugins(): InitializedType;
  initWithPluginsFolderURLs_updater_pluginStateManager(pluginsFolderURLs: NSArray<any> | any[] | null, updater: any | null, stateManager: MSPluginManagingState | null): InitializedType;
}
interface MSPluginManager extends NSObject {
  enablePlugin(pluginBundle: MSPluginBundle): void;
  disablePlugin(pluginBundle: MSPluginBundle): void;
  enabledPlugins(): NSArray<any>;
  disabledPlugins(): NSArray<any>;
  versionsForPlugin(pluginBundle: MSPluginBundle): MSPluginVersions;
  reloadPlugins(): void;
  commandWithSpecifier(specifier: MSPluginCommandSpecifier): MSPluginCommand;
  addPluginsToMenu_selector(menu: NSMenu, selector: string | null): void;
  stopTrackingLongRunningCommandWithSpecifier(specifier: MSPluginCommandSpecifier): MSPluginCommand;
  trackLongRunningCommand_onComplete(command: MSPluginCommand, callback: Block): void;
  editBundle(bundle: MSPluginBundle | null): void;
  runHandlerWithKey_fromCommand_inPlugin_withContext(handlerKey: NSString | string, commandIdentifier: NSString | string, pluginIdentifier: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}): void;
  checkForPluginUpdatesWithHandler_completionHandler(handler: Block, completionHandler: Block | null): void;
  checkForPluginUpdates_handler_completionHandler(plugins: NSArray<any> | any[], handler: Block, completionHandler: Block | null): void;
  downloadCompatiblePluginUpdatesWithCompletionHandler(completionHandler: Block): void;
  downloadLatestPluginUpdatesWithCompletionHandler(completionHandler: Block): void;
  downloadPluginUpdates_withCompletionHandler(updates: NSDictionary<any, any> | {[key: string]: any}, completionHandler: Block): void;
  isPluginUpdateDownloadedWithIdentifier_version(identifier: NSString | string, version: NSString | string): boolean;
  downloadPluginUpdate_withVersion_completionHandler(pluginIdentifier: NSString | string, pluginVersion: NSString | string, downloadCompletionHandler: Block): void;
  downloadAndInstallPluginWithIdentifier_version_downloadCompletionHandler(identifier: NSString | string, version: NSString | string, downloadCompletionHandler: Block): void;
  installPluginWithIdentifier_version_error(identifier: NSString | string, version: NSString | string, error: NSError): boolean;
  isPluginWithIdentifier_incompatibleWithVersion(identifier: NSString | string, version: NSString | string): boolean;
  cancelDownloadingPluginVersions(): void;
  clearPluginsCache(): void;
  clearFolderMonitors(): void;
  registerIncompatiblePlugins(): void;
  downloadRemotePluginsBlacklist(): void;

  pluginsFolderURLs(): NSArray<any>;
  mainPluginsFolderURL(): NSURL;
  plugins(): NSDictionary<any, any>;
  numberOfPluginsWithUpdates(): NSInteger;
  numberOfPluginsWithSketchCompatibleUpdates(): NSInteger;
  numberOfIncompatiblePluginsDisabled(): NSInteger;
  setNumberOfIncompatiblePluginsDisabled(numberOfIncompatiblePluginsDisabled: NSInteger): void;
  incompatiblePluginsWithCompatibleUpdates(): NSDictionary<any, any>;
  pluginsWithSketchCompatipleUpdates(): NSArray<any>;
  setPluginsWithSketchCompatipleUpdates(pluginsWithSketchCompatipleUpdates: NSArray<any> | any[]): void;
  updatesAddedToWarehouse(): NSInteger;
  setUpdatesAddedToWarehouse(updatesAddedToWarehouse: NSInteger): void;
  disableAllPlugins(): boolean;
  setDisableAllPlugins(disableAllPlugins: boolean): void;
  logAction(): any;
  setLogAction(logAction: any): void;
}
declare const MSPluginManager: {
  alloc(): MSPluginManagerAllocator;  mainPluginsFolderURL(): NSURL;
  defaultPluginURL(): NSURL;
  pluginsURLs(): NSArray<any>;
  warehousePluginFolderForIdentifier_withVersion(identifier: NSString | string, version: NSString | string): NSURL;

  pluginsWarehouseURL(): NSURL;

}

interface IMSPluginLogAction {
  log(sender: NSDictionary<any, any> | {[key: string]: any}): void;
  clearLog(): void;
  logString(): NSString;
}

interface MSPluginManagingStateAllocator<InitializedType = MSPluginManagingState> extends NSObjectAllocator<MSPluginManagingState> {
  initWithMetadataURL_incompatiblePlugins(metadataURL: NSURL, incompatiblePlugins: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
}
interface MSPluginManagingState extends NSObject {
  setEnabled_forPluginIdentifier_withVersion(enable: boolean, identifier: NSString | string, version: NSString | string): void;
  shouldEnablePluginIdentifier_withVersion(identifier: NSString | string, version: NSString | string): boolean;
  updateMetadataWithPluginIndentifiers(identifiers: NSArray<any> | any[]): void;
  isPluginWithIdentifier_incompatibleWithVersion(identifier: NSString | string, version: NSString | string): boolean;
  registerPluginIncompatibilityForVersions(pluginsDictionary: NSDictionary<any, any> | {[key: string]: any}): NSInteger;
  resetIncompatiblePluginMetadata(): void;
}
declare const MSPluginManagingState: {
  alloc(): MSPluginManagingStateAllocator;
  incompatiblePlugins(): NSDictionary<any, any>;
  existingDownloadededBlacklistURL(): NSURL;

}

interface MSPluginScriptAllocator<InitializedType = MSPluginScript> extends NSObjectAllocator<MSPluginScript> {
  initWithURL_error(URL: NSURL, error: NSError): InitializedType;
  initWithString_filename(string: NSString | string, filename: NSString | string): InitializedType;
}
interface MSPluginScript extends NSObject {
  reload(): void;

  URL(): NSURL;
  filename(): NSString;
  script(): NSString;
}
declare const MSPluginScript: {
  alloc(): MSPluginScriptAllocator;
}

interface IMSPluginUpdater {

  downloadingAppcastsStatus(): MSUpdaterStatus;
  downloadingPluginVersionsStatus(): MSUpdaterStatus;
}

declare enum MSUpdaterStatus {
  MSUpdaterNotUpdating,
  MSUpdaterActive,
  MSUpdaterCancelling,
  MSUpdaterFinished,
}

interface MSPluginUpdaterImplementationAllocator<InitializedType = MSPluginUpdaterImplementation> {}
interface MSPluginUpdaterImplementation {
}
declare const MSPluginUpdaterImplementation: {
  alloc(): MSPluginUpdaterImplementationAllocator;
}

interface MSPluginVersionsAllocator<InitializedType = MSPluginVersions> extends NSObjectAllocator<MSPluginVersions> {
  initWithIdentifier_appcastURL(identifier: NSString | string, appcastURL: NSURL): InitializedType;
}
interface MSPluginVersions extends NSObject {
  addVersions(versionsDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  downloadURLForVersion(version: NSString | string): NSURL;
  isVersionDownloaded(version: NSString | string): boolean;
  isVersionListed(version: NSString | string): boolean;
  isUpdateAvailableForVersion(version: NSString | string): boolean;

  identifier(): NSString;
  appcastURL(): NSURL;
  versions(): NSArray<any>;
  versionsDictionary(): NSDictionary<any, any>;
  latestVersionAvailable(): NSString;
}
declare const MSPluginVersions: {
  alloc(): MSPluginVersionsAllocator;
}

interface MSArtboardRendererCGAllocator<InitializedType = MSArtboardRendererCG> extends MSGroupRendererCGAllocator<MSArtboardRendererCG> {}
interface MSArtboardRendererCG extends MSGroupRendererCG {
  renderSubLayersOfGroup_ignoreDrawingArea_context(group: MSImmutableLayerGroup, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}
declare const MSArtboardRendererCG: {
  alloc(): MSArtboardRendererCGAllocator;
}

interface MSBackgroundBlurRendererCGAllocator<InitializedType = MSBackgroundBlurRendererCG> extends NSObjectAllocator<MSBackgroundBlurRendererCG> {}
interface MSBackgroundBlurRendererCG extends NSObject, IMSBackgroundBlurRenderer {
}
declare const MSBackgroundBlurRendererCG: {
  alloc(): MSBackgroundBlurRendererCGAllocator;
}

interface MSBitmapBackedRenderingAllocator<InitializedType = MSBitmapBackedRendering> extends NSObjectAllocator<MSBitmapBackedRendering> {}
interface MSBitmapBackedRendering extends NSObject {
}
declare const MSBitmapBackedRendering: {
  alloc(): MSBitmapBackedRenderingAllocator;  imageToCacheForLayer_context(layer: MSImmutableLayer, context: MSRenderingContextCG): MSLayerCachedImage;

}

interface MSBitmapRendererCGAllocator<InitializedType = MSBitmapRendererCG> extends MSLayerRendererCGAllocator<MSBitmapRendererCG> {}
interface MSBitmapRendererCG extends MSLayerRendererCG {
}
declare const MSBitmapRendererCG: {
  alloc(): MSBitmapRendererCGAllocator;
}

interface MSBitmapShadowRendererCGAllocator<InitializedType = MSBitmapShadowRendererCG> extends NSObjectAllocator<MSBitmapShadowRendererCG> {}
interface MSBitmapShadowRendererCG extends NSObject, IMSShadowRenderer {
}
declare const MSBitmapShadowRendererCG: {
  alloc(): MSBitmapShadowRendererCGAllocator;
}

declare enum MSBlurredImageOptions {
  MSBlurredImageOptionsNone = 0,
  MSBlurredImageOptionsWhiteBackground = 1<<1,
  MSBlurredImageOptionsBlurTwice = 1<<2,
}

interface MSCGContextPoolAllocator<InitializedType = MSCGContextPool> extends BCObjectPoolAllocator<MSCGContextPool> {
  initWithSize_colorSpace(contextSize: CGSize, colorSpace: CGColorSpaceRef): InitializedType;
}
interface MSCGContextPool extends BCObjectPool {
  vendsSize_colorSpace(size: CGSize, colorSpace: CGColorSpaceRef): boolean;
  recycleContext(context: CGContextRef): void;
}
declare const MSCGContextPool: {
  alloc(): MSCGContextPoolAllocator;
}

interface MSCacheManagerAllocator<InitializedType = MSCacheManager> extends NSObjectAllocator<MSCacheManager> {
  init(): InitializedType;
  initWithZoomIndependentCache(zoomIndependentCache: BCCache): InitializedType;
}
interface MSCacheManager extends NSObject, IMSRenderingContextCacheProvider {
  clearCachesExceptForOwners(ownersToKeep: NSSet<any>): void;
  clearAllCaches(): void;

  modelCache(): BCCache;
}
declare const MSCacheManager: {
  alloc(): MSCacheManagerAllocator;
}

declare type MSColorTriangleVertex = {
  x: number
  y: number
  z: number
  w: number
  r: number
  g: number
  b: number
  a: number
}

declare type MSColorTriangleMesh = {
  vertices: MSColorTriangleVertex
  count: number
  capacity: number
}

interface MSCoreImageQueueAllocator<InitializedType = MSCoreImageQueue> extends NSObjectAllocator<MSCoreImageQueue> {}
interface MSCoreImageQueue extends NSObject {
}
declare const MSCoreImageQueue: {
  alloc(): MSCoreImageQueueAllocator;  drawImage_withEffect_inRect_fromObject_context_colorSpace_options(imageRef: CGImageRef, effect: MSCoreImageEffect, rect: CGRect, source: any, contextRef: CGContextRef, colorSpace: CGColorSpaceRef, options: MSRenderingRequestOptions): void;
  cachedImage_withEffect_fromObject_colorSpace(imageRef: CGImageRef, effect: MSCoreImageEffect, source: any, colorSpace: CGColorSpaceRef): MSLayerCachedImage;
  averageLuminanceOfImage(inputImage: CGImageRef): CGFloat;

}

declare enum MSCoreImageEffect {
  MSCoreImageEffectDefault,
  MSCoreImageEffectPerspective,
  MSCoreImageEffectAverageLuminance,
  MSCoreImageEffectSaturation,
}

interface MSEPSExporterAllocator<InitializedType = MSEPSExporter> extends MSExporterAllocator<MSEPSExporter> {}
interface MSEPSExporter extends MSExporter {
}
declare const MSEPSExporter: {
  alloc(): MSEPSExporterAllocator;
}

interface MSExportRenderingContextAllocator<InitializedType = MSExportRenderingContext> extends MSRenderingContextCGAllocator<MSExportRenderingContext> {}
interface MSExportRenderingContext extends MSRenderingContextCG {

  exportRequest(): MSExportRequest;
  setExportRequest(exportRequest: MSExportRequest): void;
}
declare const MSExportRenderingContext: {
  alloc(): MSExportRenderingContextAllocator;
}

interface MSExporterAllocator<InitializedType = MSExporter> extends NSObjectAllocator<MSExporter> {}
interface MSExporter extends NSObject {
  data(): NSData;
  image(): NSImage;
  previewImage(): NSImage;
  drawRect_context(dirtyRect: NSRect, contextRef: CGContextRef): void;
  exportToFileURL(fileURL: NSURL): boolean;
  bitmapImageRep(): NSBitmapImageRep;
  basicBitmapImageRep(): NSBitmapImageRep;
  boundsForVectorRender(): NSRect;

  request(): MSExportRequest;
  setRequest(request: MSExportRequest): void;
  isPrinting(): boolean;
  setIsPrinting(isPrinting: boolean): void;
  driver(): MSRenderingDriver;
  colorSpace(): NSColorSpace;
}
declare const MSExporter: {
  alloc(): MSExporterAllocator;  exporterForRequest_colorSpace(request: MSExportRequest, colorSpace: NSColorSpace | null): MSExporter;
  exporterForRequest_colorSpace_driver(request: MSExportRequest, colorSpace: NSColorSpace, driver: MSRenderingDriver): MSExporter;

}

interface MSExporterViewAllocator<InitializedType = MSExporterView> extends NSViewAllocator<MSExporterView> {}
interface MSExporterView extends NSView {

  renderer(): MSExporter;
  setRenderer(renderer: MSExporter): void;
}
declare const MSExporterView: {
  alloc(): MSExporterViewAllocator;  exportViewWithRenderer(renderer: MSExporter): MSExporterView;

}

interface MSFillRendererCGAllocator<InitializedType = MSFillRendererCG> extends NSObjectAllocator<MSFillRendererCG> {}
interface MSFillRendererCG extends NSObject, IMSFillRenderer {
}
declare const MSFillRendererCG: {
  alloc(): MSFillRendererCGAllocator;
}

interface MSFlowRendererAllocator<InitializedType = MSFlowRenderer> extends MSOverlayRendererAllocator<MSFlowRenderer> {}
interface MSFlowRenderer extends MSOverlayRenderer {
  drawRect_context_selectedLayerIDs(dirtyRect: NSRect, context: MSRenderingContext, selectedLayerIDs: NSArray<any> | any[]): void;

  flowInfluencingLayerIDs(): NSArray<any>;
  setFlowInfluencingLayerIDs(flowInfluencingLayerIDs: NSArray<any> | any[]): void;
  shouldDrawSourceLayerBounds(): boolean;
  setShouldDrawSourceLayerBounds(shouldDrawSourceLayerBounds: boolean): void;
  sourceLayerBounds(): CGRect;
  setSourceLayerBounds(sourceLayerBounds: CGRect): void;
  flowType(): MSFlowType;
  setFlowType(flowType: MSFlowType): void;
  flowPath(): NSBezierPath;
  setFlowPath(flowPath: NSBezierPath): void;
  flowClipPath(): NSBezierPath;
  setFlowClipPath(flowClipPath: NSBezierPath): void;
}
declare const MSFlowRenderer: {
  alloc(): MSFlowRendererAllocator;
}

interface MSFlowRendererCollectorAllocator<InitializedType = MSFlowRendererCollector> extends NSObjectAllocator<MSFlowRendererCollector> {
  initWithLayers_onPage_document_zoomLevel_cache(layers: MSLayerArray, page: MSImmutablePage, doc: MSImmutableDocumentData, zoomLevel: CGFloat, cache: BCCache | null): InitializedType;
}
interface MSFlowRendererCollector extends NSObject {
  shouldInvalidateCollectedFlowsWithDiff(diff: MSTreeDiff): boolean;

  flowRenderers(): NSArray<any>;
}
declare const MSFlowRendererCollector: {
  alloc(): MSFlowRendererCollectorAllocator;
}

interface MSGPUArtboardShadowAllocator<InitializedType = MSGPUArtboardShadow> extends NSObjectAllocator<MSGPUArtboardShadow> {
  initWithRenderer(renderer: any): InitializedType;
}
interface MSGPUArtboardShadow extends NSObject {
  minimumArtboardSizeForDrawingShadow(): CGFloat;
  cornerSize(): CGFloat;
  cornerSourceSize(): CGFloat;

  texture(): any;
  selectedTexture(): any;
}
declare const MSGPUArtboardShadow: {
  alloc(): MSGPUArtboardShadowAllocator;
}

interface IMSGPURenderer {
  scheduleDrawBlock(renderBlock: Block): void;
  beginFrameWithClearColor_drawableSize_backingScaleFactor_colorSpace(color: NSColor, drawableSize: CGSize, backingScaleFactor: CGFloat, colorSpace: CGColorSpaceRef): boolean;
  endFrame(): void;
  drawColorQuadInRect_color(rect: CGRect, color: MSRGBAColor): void;
  drawColorTriangleMesh(mesh: MSColorTriangleMesh): void;
  drawTexturedQuadInDestinationRect_sourceTexture_bilinearFilter(destinationRect: CGRect, sourceTexture: any, bilinearFilter: boolean): void;
  drawTexturedQuadInDestinationRect_sourceTexture_sourceRect_bilinearFilter(destinationRect: CGRect, sourceTexture: any, sourceRect: CGRect, bilinearFilter: boolean): void;
  drawShadowForArtboardInRect_selected_shadow(rect: CGRect, selected: boolean, shadow: MSGPUArtboardShadow): void;
  setScissorRectWithX_y_width_height(x: number, y: number, width: number, height: number): void;
  resetScissorRect(): void;
  createTextureWithWidth_height(width: NSUInteger, height: NSUInteger): any;
  layer(): CALayer;
  requiresSynchronousRendering(): boolean;
}

interface IMSGPUTexture {
  replaceRegion_bytesPerRow_pixels(region: BCIntRect, bytesPerRow: NSUInteger, pixels: void): void;
  width(): NSUInteger;
  height(): NSUInteger;
}

interface MSGridRendererCGAllocator<InitializedType = MSGridRendererCG> extends NSObjectAllocator<MSGridRendererCG> {
  initWithLightColor_darkColor(lightColor: CGColorRef, darkColor: CGColorRef): InitializedType;
}
interface MSGridRendererCG extends NSObject, IMSGridRenderer {

  lightColor(): CGColorRef;
  darkColor(): CGColorRef;
}
declare const MSGridRendererCG: {
  alloc(): MSGridRendererCGAllocator;
}

interface MSGroupRendererCGAllocator<InitializedType = MSGroupRendererCG> extends MSLayerRendererCGAllocator<MSGroupRendererCG> {}
interface MSGroupRendererCG extends MSLayerRendererCG {
  renderSubLayersOfGroup_ignoreDrawingArea_context(group: MSImmutableLayerGroup, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}
declare const MSGroupRendererCG: {
  alloc(): MSGroupRendererCGAllocator;
}

interface MSHighLevelExporterAllocator<InitializedType = MSHighLevelExporter> extends NSObjectAllocator<MSHighLevelExporter> {
  initWithDelegate(delegate: any): InitializedType;
  initWithDelegate_driver(delegate: any, driver: MSRenderingDriver): InitializedType;
}
interface MSHighLevelExporter extends NSObject {
  formatsToExport(): NSArray<any>;
  exportLayers(layers: NSArray<any> | any[]): boolean;
  exportPage(page: MSPage): boolean;

  delegate(): any;
}
declare const MSHighLevelExporter: {
  alloc(): MSHighLevelExporterAllocator;  exporterWithDelgate(delegate: any): MSHighLevelExporter;

}

interface IMSHighLevelExportDelegate {
}

interface MSJPGExporterAllocator<InitializedType = MSJPGExporter> extends MSExporterAllocator<MSJPGExporter> {}
interface MSJPGExporter extends MSExporter {
}
declare const MSJPGExporter: {
  alloc(): MSJPGExporterAllocator;
}

interface MSLayerAnnotationsRendererAllocator<InitializedType = MSLayerAnnotationsRenderer> extends MSOptionalRendererAllocator<MSLayerAnnotationsRenderer> {}
interface MSLayerAnnotationsRenderer extends MSOptionalRenderer {
}
declare const MSLayerAnnotationsRenderer: {
  alloc(): MSLayerAnnotationsRendererAllocator;
}

interface MSLayerCachedImageAllocator<InitializedType = MSLayerCachedImage> extends NSObjectAllocator<MSLayerCachedImage> {}
interface MSLayerCachedImage extends NSObject {

  rect(): NSRect;
  setRect(rect: NSRect): void;
  image(): CGImageRef;
  setImage(image: CGImageRef): void;
}
declare const MSLayerCachedImage: {
  alloc(): MSLayerCachedImageAllocator;
}

interface MSLayerRendererCGAllocator<InitializedType = MSLayerRendererCG> extends NSObjectAllocator<MSLayerRendererCG> {}
interface MSLayerRendererCG extends NSObject, IMSLayerRenderer {
}
declare const MSLayerRendererCG: {
  alloc(): MSLayerRendererCGAllocator;
}

interface MSMemoryBufferAllocator<InitializedType = MSMemoryBuffer> extends NSObjectAllocator<MSMemoryBuffer> {
  initWithSize(size: size_t): InitializedType;
}
interface MSMemoryBuffer extends NSObject {
  zerofill(bytesToFill: size_t): void;

  size(): size_t;
  bytes(): void;
}
declare const MSMemoryBuffer: {
  alloc(): MSMemoryBufferAllocator;
}

interface MSMetalRendererAllocator<InitializedType = MSMetalRenderer> extends NSObjectAllocator<MSMetalRenderer> {}
interface MSMetalRenderer extends NSObject, IMSGPURenderer {
}
declare const MSMetalRenderer: {
  alloc(): MSMetalRendererAllocator;  createWithCompletionHandler(handler: Block): MSMetalRenderer;

}

interface MSMetalTextureAllocator<InitializedType = MSMetalTexture> extends NSObjectAllocator<MSMetalTexture> {
  initWithMetalTexture(texture: any): InitializedType;
}
interface MSMetalTexture extends NSObject, IMSGPUTexture {

  metalTexture(): any;
}
declare const MSMetalTexture: {
  alloc(): MSMetalTextureAllocator;
}

interface MSNoiseAllocator<InitializedType = MSNoise> extends NSObjectAllocator<MSNoise> {}
interface MSNoise extends NSObject {
}
declare const MSNoise: {
  alloc(): MSNoiseAllocator;  noiseIsOpaqueForType(type: NSInteger): boolean;
  drawWithIntensity_ofType_inRect_zoomValue_context(intensity: CGFloat, type: NSInteger, rect: NSRect, zoomValue: CGFloat, context: CGContextRef): void;
  drawWithIntensity_ofType_inPath_windingRule_zoomValue_context(intensity: CGFloat, type: NSInteger, path: MSPath, windingRule: NSWindingRule, zoomValue: CGFloat, context: CGContextRef): void;

}

interface MSOpenGLLayerAllocator<InitializedType = MSOpenGLLayer> extends NSOpenGLLayerAllocator<MSOpenGLLayer> {}
interface MSOpenGLLayer extends NSOpenGLLayer {
}
declare const MSOpenGLLayer: {
  alloc(): MSOpenGLLayerAllocator;
}

interface MSOpenGLOffscreenBufferAllocator<InitializedType = MSOpenGLOffscreenBuffer> extends NSObjectAllocator<MSOpenGLOffscreenBuffer> {}
interface MSOpenGLOffscreenBuffer extends NSObject {
  beginRendering_height(width: number, height: number): void;
  endRendering(): void;

  context(): NSOpenGLContext;
  setContext(context: NSOpenGLContext): void;
  colorspace(): CGColorSpaceRef;
  setColorspace(colorspace: CGColorSpaceRef): void;
}
declare const MSOpenGLOffscreenBuffer: {
  alloc(): MSOpenGLOffscreenBufferAllocator;
}

interface MSOpenGLRendererAllocator<InitializedType = MSOpenGLRenderer> extends NSObjectAllocator<MSOpenGLRenderer> {}
interface MSOpenGLRenderer extends NSObject, IMSGPURenderer {
}
declare const MSOpenGLRenderer: {
  alloc(): MSOpenGLRendererAllocator;  createWithCompletionHandler(handler: Block): MSOpenGLRenderer;

}

interface MSOpenGLTextureAllocator<InitializedType = MSOpenGLTexture> extends NSObjectAllocator<MSOpenGLTexture> {
  initWithTextureID_width_height(textureID: GLuint, width: NSUInteger, height: NSUInteger): InitializedType;
}
interface MSOpenGLTexture extends NSObject, IMSGPUTexture {

  textureID(): GLuint;
  filter(): MSOpenGLTextureFilter;
  setFilter(filter: MSOpenGLTextureFilter): void;
}
declare const MSOpenGLTexture: {
  alloc(): MSOpenGLTextureAllocator;
}

declare enum MSOpenGLTextureFilter {
  MSOpenGLTextureFilterPoint = 0,
  MSOpenGLTextureFilterLinear,
}

interface MSOptionalRendererAllocator<InitializedType = MSOptionalRenderer> extends NSObjectAllocator<MSOptionalRenderer> {
  initWithBaseRenderer_disableSetting(baseRenderer: any, setting: NSString | string): InitializedType;
}
interface MSOptionalRenderer extends NSObject {

  baseRenderer(): any;
  enabled(): boolean;
}
declare const MSOptionalRenderer: {
  alloc(): MSOptionalRendererAllocator;
}

interface MSOverlayColorSettingsAllocator<InitializedType = MSOverlayColorSettings> extends NSObjectAllocator<MSOverlayColorSettings> {}
interface MSOverlayColorSettings extends NSObject {

  canvasBackgroundColor(): NSColor;
  setCanvasBackgroundColor(canvasBackgroundColor: NSColor): void;
  pageBackgroundColor(): NSColor;
  setPageBackgroundColor(pageBackgroundColor: NSColor): void;
  pixelGridColor(): NSColor;
  setPixelGridColor(pixelGridColor: NSColor): void;
  sliceOutlineColor(): NSColor;
  setSliceOutlineColor(sliceOutlineColor: NSColor): void;
  artboardTitleColor(): NSColor;
  setArtboardTitleColor(artboardTitleColor: NSColor): void;
  symbolTitleColor(): NSColor;
  setSymbolTitleColor(symbolTitleColor: NSColor): void;
}
declare const MSOverlayColorSettings: {
  alloc(): MSOverlayColorSettingsAllocator;  colorSettings(): MSOverlayColorSettings;

}

interface MSOverlayRendererAllocator<InitializedType = MSOverlayRenderer> extends NSObjectAllocator<MSOverlayRenderer> {}
interface MSOverlayRenderer extends NSObject {
  drawRect_context(dirtyRect: NSRect, context: MSRenderingContext): void;
  setNeedsDisplayInRect(rect: NSRect): void;

  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  hostView(): any;
  setHostView(hostView: any): void;
}
declare const MSOverlayRenderer: {
  alloc(): MSOverlayRendererAllocator;
}

interface MSPDFExporterAllocator<InitializedType = MSPDFExporter> extends MSExporterAllocator<MSPDFExporter> {}
interface MSPDFExporter extends MSExporter {
}
declare const MSPDFExporter: {
  alloc(): MSPDFExporterAllocator;
}

interface MSPDFPageAllocator<InitializedType = MSPDFPage> extends NSObjectAllocator<MSPDFPage> {
  initWithPDFData(PDFData: NSData): InitializedType;
}
interface MSPDFPage extends NSObject {

  pageRef(): CGPDFPageRef;
  size(): CGSize;
}
declare const MSPDFPage: {
  alloc(): MSPDFPageAllocator;
}

interface MSPNGExporterAllocator<InitializedType = MSPNGExporter> extends MSExporterAllocator<MSPNGExporter> {}
interface MSPNGExporter extends MSExporter {
}
declare const MSPNGExporter: {
  alloc(): MSPNGExporterAllocator;
}

interface MSPathRendererCGAllocator<InitializedType = MSPathRendererCG> extends NSObjectAllocator<MSPathRendererCG> {}
interface MSPathRendererCG extends NSObject, IMSPathRenderer {
}
declare const MSPathRendererCG: {
  alloc(): MSPathRendererCGAllocator;
}

interface MSPerspectiveInstructionsAllocator<InitializedType = MSPerspectiveInstructions> extends NSObjectAllocator<MSPerspectiveInstructions> {}
interface MSPerspectiveInstructions extends NSObject {
  applyToImage(image: CIImage): CIImage;

  rect(): NSRect;
  setRect(rect: NSRect): void;
}
declare const MSPerspectiveInstructions: {
  alloc(): MSPerspectiveInstructionsAllocator;
}

declare type MSRGBAColor = {
  red: number
  green: number
  blue: number
  alpha: number
}

declare type MSRegionRunHead = {
  _refCnt: number
  _runCount: number
  _ySpanCount: number
  _intervalCount: number
}

declare type MSRegion = {
  _bounds: BCIntRect
  _runHead: MSRegionRunHead
}

declare type MSRegionIterator = {
  _runs: number
  _rect: BCIntRect
  _done: boolean
}

declare enum MSRegionOp {
  MSDifferenceOp,
  MSIntersectOp,
  MSUnionOp,
  MSXOROp,
}

interface MSRenderingContextAllocator<InitializedType = MSRenderingContext> extends NSObjectAllocator<MSRenderingContext> {
  initWithName_driver_renderingRequest(name: NSString | string, driver: MSRenderingDriver, renderingRequest: MSRenderingRequest): InitializedType;
}
interface MSRenderingContext extends NSObject {
  renderLayer_ignoreCacheAndDrawingArea(layer: MSImmutableLayer, ignoreCacheAndDrawingArea: boolean): void;
  renderRect_withStyle(rect: CGRect, style: MSImmutableStyle): void;
  renderInBlock(block: BCVoidBlock): void;
  setUp(): void;
  tearDown(): void;
  setCachedValue_forModelObject_key_zoomIndependent(value: any, modelObject: MSModelObjectCommon, key: any, zoomIndependent: boolean): void;
  cachedValueForModelObject_key_zoomIndependent_orCreateWithBlock(object: MSModelObjectCommon, key: any, zoomIndependent: boolean, block: BCCacheCreateObjectBlock): any;
  concatTransform(transform: CGAffineTransform): void;
  accumulatedTransform(): CGAffineTransform;
  accumulatedRotateFlipTransform(): CGAffineTransform;
  pushGraphicsState(): void;
  popGraphicsState(): void;
  pushParentGroup(layerGroup: MSImmutableLayerGroup): void;
  popParentGroup(): MSImmutableLayerGroup;
  parentGroupForLayer(layer: any): MSImmutableLayerGroup;
  cancel(): void;
  transparencyLayerInBlock(block: BCVoidBlock): void;
  transparencyLayerInRect_inBlock(rect: CGRect, block: BCVoidBlock): void;
  beginTransparencyLayerInRect(aRect: CGRect): CGFloat;
  beginTransparencyLayerInRect_inheritClip(aRect: CGRect, inheritClip: boolean): CGFloat;
  beginTransparencyLayer(): CGFloat;
  endTransparencyLayer(oldAlpha: CGFloat): void;
  multiplyAlphaBy(alpha: CGFloat): CGFloat;
  setAlpha(oldAlpha: CGFloat): CGFloat;
  setBlendMode(blendMode: CGBlendMode): CGBlendMode;
  prepareLayerDrawing_inBlock(layer: MSImmutableStyledLayer, block: BCVoidBlock): void;
  applySettings_withOptions_inBlock(settings: MSImmutableGraphicsContextSettings, options: NSInteger, block: BCVoidBlock): void;
  applyLayerTransform_inBlock(layer: MSImmutableLayer, block: BCVoidBlock): void;
  shouldDrawLayer_withMaskingShapeGroup_ignoreDrawingArea(layer: MSImmutableLayer, mask: MSImmutableShapeGroup | null, ignoreDrawingArea: boolean): boolean;
  clipToRect(rect: CGRect): void;
  applyFillColor(color: MSImmutableColor): void;
  applyStrokeColor(color: MSImmutableColor): void;
  applyShadow(shadow: MSImmutableStyleShadow): void;
  canDrawSymbolMasterWithoutRiskingRecursion(master: MSImmutableSymbolMaster): boolean;
  isDrawingSymbol(): boolean;
  isDrawingSymbolInstance(): boolean;
  drawSymbolMaster_inBlock(master: MSImmutableSymbolMaster, block: BCVoidBlock): void;
  drawSymbolInstance_inBlock(instance: MSImmutableSymbolInstance, block: BCVoidBlock): void;
  shouldSkipDrawingShadow(shadow: MSImmutableStyleShadow): boolean;
  shouldLog(): boolean;

  renderingRequest(): MSRenderingRequest;
  rootLayer(): MSImmutableLayerGroup;
  cancelled(): boolean;
  drawingArea(): CGRect;
  setDrawingArea(drawingArea: CGRect): void;
  driver(): MSRenderingDriver;
  name(): NSString;
  setName(name: NSString | string): void;
  zoomLevelForShadows(): CGFloat;
  rotateFlipTransform(): CGAffineTransform;
}
declare const MSRenderingContext: {
  alloc(): MSRenderingContextAllocator;
}

declare enum MSGraphicsContextSettingMode {
  MSGraphicsSettingBlending = 1,
  MSGraphicsSettingOpacity = 2,
}

declare enum MSTransparencyOption {
  MSTransparencyDontUseLayer,
  MSTransparencyUseLayer,
}

declare enum MSTransparencyOptimiseOption {
  MSTransparencyDontOptimise,
  MSTransparencyCanOptimise,
}

declare enum MSTransparencyRectangleOption {
  MSTransparencyDontUseRectangle,
  MSTransparencyUseRectangle,
}

interface MSRenderingContextCGAllocator<InitializedType = MSRenderingContextCG> extends MSRenderingContextAllocator<MSRenderingContextCG> {
  initWithName_driver_context_renderingRequest(name: NSString | string, driver: MSRenderingDriver, cgContext: CGContextRef, renderingRequest: MSRenderingRequest): InitializedType;
  initWithName_driver_cgContext_contextIsVectorBacked_renderingRequest(name: NSString | string, driver: MSRenderingDriver, cgContext: CGContextRef, vectorBacked: boolean, renderingRequest: MSRenderingRequest): InitializedType;
}
interface MSRenderingContextCG extends MSRenderingContext {
  subContextWithCGContext_contextIsVectorBacked_pointScale_zoomLevel_options(cgContext: CGContextRef, vectorBacked: boolean, pointScale: CGFloat, zoomLevel: CGFloat, options: MSRenderingRequestOptions): MSRenderingContextCG;
  blurSubContextWithCGContext_backgroundBlurLayer_pointScale_rect(cgContext: CGContextRef, layer: MSImmutableLayer | null, pointScale: CGFloat, rect: CGRect): MSRenderingContextCG;
  applyShadow_withXOffset(shadow: MSImmutableStyleShadow, offset: CGFloat): void;
  applyShadow_respectFlipped(shadow: MSImmutableStyleShadow, respectFlipped: boolean): void;
  shouldDisableSubpixelQuantization(): boolean;
  doNotClipFillsInBlock(block: BCVoidBlock): void;
  shouldClipFills(): boolean;
  ifCondition_skipDrawingFillsInBlock(condition: boolean, block: BCVoidBlock): void;
  shouldDrawFills(): boolean;

  contextIsVectorBacked(): boolean;
  contextRef(): CGContextRef;
  contextPool(): MSCGContextPool;
  setContextPool(contextPool: MSCGContextPool): void;
  graphicsContext(): NSGraphicsContext;
}
declare const MSRenderingContextCG: {
  alloc(): MSRenderingContextCGAllocator;
}

interface IMSRenderingContextCacheProvider {
  cacheForZoomLevel(zoomLevel: CGFloat): BCCache;

  zoomIndependentCache(): BCCache;
}

interface MSRenderingDriverAllocator<InitializedType = MSRenderingDriver> extends NSObjectAllocator<MSRenderingDriver> {
  initWithSettings(settings: MSRenderingDriverSettings): InitializedType;
}
interface MSRenderingDriver extends NSObject {
  setupRendererMap(): NSMapTable<any, any>;
  rendererForObject_protocol(object: any, protocol: Protocol): any;
  contextWithName_forCGContext_renderingRequest(name: NSString | string, contextRef: CGContextRef, renderingRequest: MSRenderingRequest): MSRenderingContext;

  settings(): MSRenderingDriverSettings;
}
declare const MSRenderingDriver: {
  alloc(): MSRenderingDriverAllocator;
}

interface MSRenderingDriverCGAllocator<InitializedType = MSRenderingDriverCG> extends MSRenderingDriverAllocator<MSRenderingDriverCG> {}
interface MSRenderingDriverCG extends MSRenderingDriver {
}
declare const MSRenderingDriverCG: {
  alloc(): MSRenderingDriverCGAllocator;
}

interface MSRenderingDriverCGDebugAllocator<InitializedType = MSRenderingDriverCGDebug> extends MSRenderingDriverCGAllocator<MSRenderingDriverCGDebug> {}
interface MSRenderingDriverCGDebug extends MSRenderingDriverCG {
}
declare const MSRenderingDriverCGDebug: {
  alloc(): MSRenderingDriverCGDebugAllocator;
}

interface MSRenderingDriverCGProfilingAllocator<InitializedType = MSRenderingDriverCGProfiling> extends MSRenderingDriverCGAllocator<MSRenderingDriverCGProfiling> {
  initWithDelegate(delegate: any): InitializedType;
}
interface MSRenderingDriverCGProfiling extends MSRenderingDriverCG {
}
declare const MSRenderingDriverCGProfiling: {
  alloc(): MSRenderingDriverCGProfilingAllocator;
}

interface MSRenderingDriverExportAllocator<InitializedType = MSRenderingDriverExport> extends MSRenderingDriverCGAllocator<MSRenderingDriverExport> {}
interface MSRenderingDriverExport extends MSRenderingDriverCG {
}
declare const MSRenderingDriverExport: {
  alloc(): MSRenderingDriverExportAllocator;
}

interface MSRenderingDriverSettingsAllocator<InitializedType = MSRenderingDriverSettings> extends NSObjectAllocator<MSRenderingDriverSettings> {
  initWithGridLightColor_gridDarkColor_layoutGridStyle_flowColor_flowTipImage_flowBackImage_flowOtherPageImage(gridLightColor: CGColorRef, gridDarkColor: CGColorRef, layoutGridStyle: MSLayoutGridStyle, flowColor: CGColorRef, tipImage: CGImageRef | null, backImage: CGImageRef | null, otherPageImage: CGImageRef | null): InitializedType;
}
interface MSRenderingDriverSettings extends NSObject {
  flowTipImage(): CGImageRef;
  flowBackImage(): CGImageRef;
  flowOtherPageImage(): CGImageRef;
  flowColor(): CGColorRef;

  layoutGridStyle(): MSLayoutGridStyle;
  gridLightColor(): CGColorRef;
  gridDarkColor(): CGColorRef;
}
declare const MSRenderingDriverSettings: {
  alloc(): MSRenderingDriverSettingsAllocator;
}

interface IMSRenderer extends NSObject {
}

interface IMSLayerRenderer extends IMSRenderer {
  renderLayer_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
  renderLayerUncached_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}

interface IMSPathRenderer extends IMSRenderer {
  renderPath_style_layer_inRect_fallbackColor_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, fillColor: CGColorRef | null, context: MSRenderingContext): void;
  renderFillsForPath_style_layer_rect_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, context: MSRenderingContext): void;
  renderBordersForPath_style_rect_context(path: MSPath, style: MSImmutableStyle, rect: CGRect, context: MSRenderingContext): void;
}

interface IMSFillRenderer extends IMSRenderer {
  renderFill_path_layer_index_rect_hasInnerStroke_context(fill: MSImmutableStyleFill, path: MSPath, layer: MSImmutableStyledLayer, index: NSInteger, rect: CGRect, hasInnerStroke: boolean, context: MSRenderingContext): void;
}

interface IMSBackgroundBlurRenderer extends IMSRenderer {
  renderBackgroundBlurBehindLayer_context_clippedToPath(shape: MSImmutableStyledLayer, context: MSRenderingContext, path: MSPath): void;
}

interface IMSShadowRenderer extends IMSRenderer {
  renderShadow_path_cacheObject_windingRule_options_type_strokeType_fillShouldClip_lineWidth_context(shadow: MSImmutableStyleShadow, path: MSPath, cacheObject: MSModelObjectCommon, windingRule: NSWindingRule, options: MSImmutableStyleBorderOptions, shadowType: MSShadowType, strokeType: MSShadowBorderType, fillShouldClip: boolean, width: CGFloat, context: MSRenderingContext): void;
  renderShadow_rect_context_block(shadow: MSImmutableStyleShadow, rect: CGRect, context: MSRenderingContext, block: BCVoidBlock): void;
  renderInnerShadow_path_windingRule_context_cacheObject(shadow: MSImmutableStyleInnerShadow, path: MSPath, windingRule: NSWindingRule, context: MSRenderingContext, cacheObject: MSModelObjectCommon): void;
}

interface IMSGridRenderer extends IMSRenderer {
  renderGrid_in_origin_context(grid: MSImmutableBaseGrid, rect: CGRect, origin: CGPoint, context: MSRenderingContext): void;
}

declare enum MSPageOverlayRenderOptions {
  MSPageOverlayRenderTitles = 0x01,
  MSPageOverlayRenderShadows = 0x02,
  MSPageOverlayRenderGrids = 0x04,
  MSPageOverlayRenderPixels = 0x08,
  MSPageOverlayRenderSlices = 0x10,
  MSPageOverlayRenderFlows = 0x20,
}

interface MSRenderingRequestAllocator<InitializedType = MSRenderingRequest> extends NSObjectAllocator<MSRenderingRequest> {
  initWithDocument_colorSpace_pointScale_zoomLevel_cacheProvider_backgroundBlurLayer_options(document: MSImmutableDocumentData, colorSpace: CGColorSpaceRef, pointScale: CGFloat, zoomLevel: CGFloat, cacheProvider: any | null, backgroundBlurLayer: MSImmutableLayer | null, options: MSRenderingRequestOptions): InitializedType;
  initWithDocument_colorSpace_pointScale_zoomLevel_cacheProvider_options(document: MSImmutableDocumentData, colorSpace: CGColorSpaceRef, pointScale: CGFloat, zoomLevel: CGFloat, cacheProvider: any | null, options: MSRenderingRequestOptions): InitializedType;
}
interface MSRenderingRequest extends NSObject {
  requestWithOptions(options: MSRenderingRequestOptions): MSRenderingRequest;

  cacheProvider(): any;
  setCacheProvider(cacheProvider: any): void;
  colorSpace(): CGColorSpaceRef;
  document(): MSImmutableDocumentData;
  pointScale(): CGFloat;
  zoomLevel(): CGFloat;
  backgroundBlurLayer(): MSImmutableLayer;
  options(): MSRenderingRequestOptions;
  exporting(): boolean;
  drawingMask(): boolean;
  drawingPixelated(): boolean;
  willDrawPixelated(): boolean;
  includeArtboardBackground(): boolean;
  printing(): boolean;
  skipLayerInclusionTests(): boolean;
  shouldFlipShadows(): boolean;
}
declare const MSRenderingRequest: {
  alloc(): MSRenderingRequestAllocator;
}

declare enum MSRenderingRequestOptions {
  MSRenderingRequestOptionsNone = 0,
  MSRenderingRequestOptionsExporting = 1 << 0,
  MSRenderingRequestOptionsDrawingMask = 1 << 1,
  MSRenderingRequestOptionsDrawingPixelated = 1 << 2,
  MSRenderingRequestOptionsIncludeArtboardBackground = 1 << 3,
  MSRenderingRequestOptionsPrinting = 1 << 4,
  MSRenderingRequestOptionsFlipShadows = 1 << 5,
  MSRenderingRequestOptionsSkipLayerInclusionTests = 1 << 6,
  MSRenderingRequestOptionsVectorBacked = 1 << 7,
  MSRenderingRequestOptionsDefault,
}

interface MSSelfContainedHighLevelExporterAllocator<InitializedType = MSSelfContainedHighLevelExporter> extends MSHighLevelExporterAllocator<MSSelfContainedHighLevelExporter> {
  initWithOptions(options: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithOptions_driver(options: NSDictionary<any, any> | {[key: string]: any}, driver: MSRenderingDriver): InitializedType;
}
interface MSSelfContainedHighLevelExporter extends MSHighLevelExporter, IMSHighLevelExportDelegate {

  results(): NSDictionary<any, any>;
}
declare const MSSelfContainedHighLevelExporter: {
  alloc(): MSSelfContainedHighLevelExporterAllocator;
}

interface MSShadowRendererCGAllocator<InitializedType = MSShadowRendererCG> extends NSObjectAllocator<MSShadowRendererCG> {}
interface MSShadowRendererCG extends NSObject, IMSShadowRenderer {
}
declare const MSShadowRendererCG: {
  alloc(): MSShadowRendererCGAllocator;
}

interface MSShapeRendererCGAllocator<InitializedType = MSShapeRendererCG> extends MSGroupRendererCGAllocator<MSShapeRendererCG> {}
interface MSShapeRendererCG extends MSGroupRendererCG {
}
declare const MSShapeRendererCG: {
  alloc(): MSShapeRendererCGAllocator;
}

interface MSSliceTrimmingAllocator<InitializedType = MSSliceTrimming> extends NSObjectAllocator<MSSliceTrimming> {}
interface MSSliceTrimming extends NSObject {
}
declare const MSSliceTrimming: {
  alloc(): MSSliceTrimmingAllocator;  trimmedRectForLayerAncestry(ancestry: MSImmutableLayerAncestry): NSRect;
  simpleSafeRectFromLayerAncestry(ancestry: MSImmutableLayerAncestry): NSRect;

}

interface MSSymbolMasterRendererCGAllocator<InitializedType = MSSymbolMasterRendererCG> extends MSArtboardRendererCGAllocator<MSSymbolMasterRendererCG> {}
interface MSSymbolMasterRendererCG extends MSArtboardRendererCG {
}
declare const MSSymbolMasterRendererCG: {
  alloc(): MSSymbolMasterRendererCGAllocator;
}

interface MSSymbolRendererCGAllocator<InitializedType = MSSymbolRendererCG> extends MSArtboardRendererCGAllocator<MSSymbolRendererCG> {}
interface MSSymbolRendererCG extends MSArtboardRendererCG {
}
declare const MSSymbolRendererCG: {
  alloc(): MSSymbolRendererCGAllocator;
}

interface MSTextRendererCGAllocator<InitializedType = MSTextRendererCG> extends MSLayerRendererCGAllocator<MSTextRendererCG> {}
interface MSTextRendererCG extends MSLayerRendererCG {
}
declare const MSTextRendererCG: {
  alloc(): MSTextRendererCGAllocator;
}

interface MSTextStoragePoolAllocator<InitializedType = MSTextStoragePool> extends BCObjectPoolAllocator<MSTextStoragePool> {
  initWithTextLayer(textLayer: MSImmutableTextLayer): InitializedType;
}
interface MSTextStoragePool extends BCObjectPool {
  vendTextStorage(): NSTextStorage;
  recycleTextStorage(textStorage: NSTextStorage): void;
}
declare const MSTextStoragePool: {
  alloc(): MSTextStoragePoolAllocator;
}

declare type MSTexturedVertex = {
  x: number
  y: number
  textureX: number
  textureY: number
}

interface MSTiffExporterAllocator<InitializedType = MSTiffExporter> extends MSExporterAllocator<MSTiffExporter> {}
interface MSTiffExporter extends MSExporter {
}
declare const MSTiffExporter: {
  alloc(): MSTiffExporterAllocator;
}

interface MSTileAllocator<InitializedType = MSTile> extends NSObjectAllocator<MSTile> {
  initWithRenderer_point(renderer: any, point: BCIntPoint): InitializedType;
}
interface MSTile extends NSObject {
  replaceRegion_withBytes_bytesPerRow(region: BCIntRect, bytes: void, bytesPerRow: NSUInteger): void;

  texture(): any;
  point(): BCIntPoint;
  rectWithImageFragment(): BCIntRect;
}
declare const MSTile: {
  alloc(): MSTileAllocator;
}

interface MSTileMipLevelAllocator<InitializedType = MSTileMipLevel> extends NSObjectAllocator<MSTileMipLevel> {
  initWithScaleRangeMax(max: CGFloat): InitializedType;
}
interface MSTileMipLevel extends NSObject {
  enqueueRenderableTilesForVisibleRect(visibleRect: NSRect): NSArray<any>;
  countExistingTilesForVisibleRect(visibleRect: NSRect): NSUInteger;
  findWritableTileAt(point: BCIntPoint): MSTile;
  addTile(tile: MSTile): void;
  removeAllTiles(): void;
  removeAllTilesAndClearDirtyRegion(): void;
  removeAllTilesAndResetDirtyRegionToRect(rect: BCIntRect): void;
  isCurrentColorSpaceEqualTo(colorSpace: CGColorSpaceRef): boolean;
  uniteDirtyRect(rect: NSRect): void;
  subtractDirtyRect(rect: BCIntRect): void;

  scaleRangeMax(): CGFloat;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  currentColorSpace(): CGColorSpaceRef;
  setCurrentColorSpace(currentColorSpace: CGColorSpaceRef): void;
  clearBeforeUpload(): boolean;
  setClearBeforeUpload(clearBeforeUpload: boolean): void;
  dirtyRegion(): MSRegion;
  tileCount(): NSUInteger;
}
declare const MSTileMipLevel: {
  alloc(): MSTileMipLevelAllocator;  tileMipLevelWithScaleRangeMax(rangeMax: CGFloat): MSTileMipLevel;

}

interface MSTileRasterisationOperationAllocator<InitializedType = MSTileRasterisationOperation> extends NSOperationAllocator<MSTileRasterisationOperation> {}
interface MSTileRasterisationOperation extends NSOperation {
}
declare const MSTileRasterisationOperation: {
  alloc(): MSTileRasterisationOperationAllocator;  operationWithMemory_bytesPerRow_rect_zoomValue_backingScaleFactor_page_document_driver_contextPool_cacheProvider_colorSpace(memory: void, bytesPerRow: size_t, rect: BCIntRect, zoomValue: CGFloat, backingScaleFactor: CGFloat, page: MSImmutablePage, document: MSImmutableDocumentData, driver: MSRenderingDriver, contextPool: MSCGContextPool | null, cacheProvider: any | null, colorSpace: CGColorSpaceRef): MSTileRasterisationOperation;

}

interface MSTileRenderPassAllocator<InitializedType = MSTileRenderPass> extends NSObjectAllocator<MSTileRenderPass> {}
interface MSTileRenderPass extends NSObject {
}
declare const MSTileRenderPass: {
  alloc(): MSTileRenderPassAllocator;  tileRenderPassWithPage_inDocument_dirtyRect_zoomValue(page: MSImmutablePage, documentData: MSImmutableDocumentData, dirtyRect: CGRect, zoomValue: CGFloat): MSTileRenderPass;

}

interface MSTileRenderOperationAllocator<InitializedType = MSTileRenderOperation> extends NSOperationAllocator<MSTileRenderOperation> {}
interface MSTileRenderOperation extends NSOperation {

  renderedImage(): NSBitmapImageRep;
}
declare const MSTileRenderOperation: {
  alloc(): MSTileRenderOperationAllocator;  bitmapImageRenderForPage_inDocument_visibleContentRect_backingScaleFactor_pixelViewSize_zoomValue_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(page: MSImmutablePage, documentData: MSImmutableDocumentData, visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, zoomValue: CGFloat, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): NSBitmapImageRep;
  bitmapImageFromRenderPasses_visibleContentRect_backingScaleFactor_pixelViewSize_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(renderPasses: NSArray<any> | any[], visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): NSBitmapImageRep;
  renderOperationWithPage_inDocument_visibleContentRect_backingScaleFactor_pixelViewSize_zoomValue_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(page: MSImmutablePage, documentData: MSImmutableDocumentData, visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, zoomValue: CGFloat, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): MSTileRenderOperation;
  renderOperationWithRenderPasses_visibleContentRect_backingScaleFactor_pixelViewSize_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(renderPasses: NSArray<any> | any[], visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): MSTileRenderOperation;

}

interface MSTiledRendererAllocator<InitializedType = MSTiledRenderer> extends NSObjectAllocator<MSTiledRenderer> {
  initWithCompletionHandler(handler: Block): InitializedType;
}
interface MSTiledRenderer extends NSObject {
  updateContentInRect_forPage_document_visibleImageRect_backingScaleFactor_pixelViewSize_zoomValue_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace_renderContentSynchronously_overlayColors(dirtyRect: NSRect, page: MSImmutablePage, document: MSImmutableDocumentData, visibleImageRect: NSRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, zoomValue: CGFloat, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any | null, canvasColorSpace: NSColorSpace, renderContentSynchronously: boolean, colors: MSOverlayColorSettings | null): void;
  beginFastZooming(): void;

  layer(): CALayer;
  renderingCacheProvider(): any;
  setRenderingCacheProvider(renderingCacheProvider: any): void;
  overlayRenderingDelegate(): any;
  setOverlayRenderingDelegate(overlayRenderingDelegate: any): void;
  hostView(): NSView;
  setHostView(hostView: NSView): void;
  hideOverlay(): boolean;
  setHideOverlay(hideOverlay: boolean): void;
}
declare const MSTiledRenderer: {
  alloc(): MSTiledRendererAllocator;
}

interface IMSOverlayRenderingDelegate {
  renderOverlayInRect_context_pageOverlayRenderOptions(rect: NSRect, context: CGContextRef, pageOverlayRenderOptions: MSPageOverlayRenderOptions): void;
}

interface IMSTiledRendererHostView {
  scheduleRedraw(): void;
  driver(): MSRenderingDriver;
}

interface MSWebPExporterAllocator<InitializedType = MSWebPExporter> extends MSExporterAllocator<MSWebPExporter> {}
interface MSWebPExporter extends MSExporter {
}
declare const MSWebPExporter: {
  alloc(): MSWebPExporterAllocator;
}

interface DrawingViewAllocator<InitializedType = DrawingView> extends NSViewAllocator<DrawingView> {}
interface DrawingView extends NSView {
}
declare const DrawingView: {
  alloc(): DrawingViewAllocator;
}

interface DataProtocolAllocator<InitializedType = DataProtocol> extends NSURLProtocolAllocator<DataProtocol> {}
interface DataProtocol extends NSURLProtocol {
}
declare const DataProtocol: {
  alloc(): DataProtocolAllocator;  dataFromLink_type_encoding(link: NSString | string, typeOut: NSString | string, encodingOut: NSString | string): NSData;

}

interface _SVGBasicShapeAllocator<InitializedType = _SVGBasicShape> extends SVGDrawableElementAllocator<_SVGBasicShape> {}
interface _SVGBasicShape extends SVGDrawableElement {
}
declare const _SVGBasicShape: {
  alloc(): _SVGBasicShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGCircleShapeAllocator<InitializedType = _SVGCircleShape> extends SVGBasicShapeAllocator<_SVGCircleShape> {}
interface _SVGCircleShape extends SVGBasicShape {

  cx(): number;
  setCx(cx: number): void;
  cy(): number;
  setCy(cy: number): void;
  r(): number;
  setR(r: number): void;
}
declare const _SVGCircleShape: {
  alloc(): _SVGCircleShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGClipPathAllocator<InitializedType = _SVGClipPath> extends SVGGroupElementAllocator<_SVGClipPath> {}
interface _SVGClipPath extends SVGGroupElement {
  primitiveAddClippingObject(object: any): void;
  primitiveRemoveClippingObject(object: any): void;

  clipping(): NSSet<any>;
  setClipping(clipping: NSSet<any>): void;
}
declare const _SVGClipPath: {
  alloc(): _SVGClipPathAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGDrawableElementAllocator<InitializedType = _SVGDrawableElement> extends SVGElementAllocator<_SVGDrawableElement> {}
interface _SVGDrawableElement extends SVGElement {
  primitiveSetClip(clip: any): void;
  primitiveSetFill(fill: any): void;
  primitiveSetFont(font: any): void;
  primitiveSetMask(mask: any): void;
  primitiveSetStroke(stroke: any): void;

  blendMode(): NSString;
  setBlendMode(blendMode: NSString | string): void;
  clips(): boolean;
  setClips(clips: boolean): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  opacity(): number;
  setOpacity(opacity: number): void;
  rect(): NSRect;
  setRect(rect: NSRect): void;
  transform(): NSAffineTransform;
  setTransform(transform: NSAffineTransform): void;
  clip(): SVGClipPath;
  setClip(clip: SVGClipPath): void;
  fill(): SVGFill;
  setFill(fill: SVGFill): void;
  font(): SVGFont;
  setFont(font: SVGFont): void;
  mask(): SVGMask;
  setMask(mask: SVGMask): void;
  stroke(): SVGStroke;
  setStroke(stroke: SVGStroke): void;
}
declare const _SVGDrawableElement: {
  alloc(): _SVGDrawableElementAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGElementAllocator<InitializedType = _SVGElement> extends NSObjectAllocator<_SVGElement> {}
interface _SVGElement extends NSObject {
  primitiveAddChildrenObject(object: any): void;
  primitiveRemoveChildrenObject(object: any): void;
  primitiveAddLinkedObject(object: any): void;
  primitiveRemoveLinkedObject(object: any): void;
  primitiveSetParent(parent: any): void;

  desc(): NSString;
  setDesc(desc: NSString | string): void;
  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  index(): number;
  setIndex(index: number): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  type(): NSString;
  setType(type: NSString | string): void;
  children(): NSSet<any>;
  setChildren(children: NSSet<any>): void;
  linked(): NSSet<any>;
  setLinked(linked: NSSet<any>): void;
  parent(): SVGElement;
  setParent(parent: SVGElement): void;
}
declare const _SVGElement: {
  alloc(): _SVGElementAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGEllipseShapeAllocator<InitializedType = _SVGEllipseShape> extends SVGBasicShapeAllocator<_SVGEllipseShape> {}
interface _SVGEllipseShape extends SVGBasicShape {

  cx(): number;
  setCx(cx: number): void;
  cy(): number;
  setCy(cy: number): void;
  rx(): number;
  setRx(rx: number): void;
  ry(): number;
  setRy(ry: number): void;
}
declare const _SVGEllipseShape: {
  alloc(): _SVGEllipseShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGFillAllocator<InitializedType = _SVGFill> extends SVGElementAllocator<_SVGFill> {}
interface _SVGFill extends SVGElement {
  primitiveSetGradient(gradient: any): void;
  primitiveSetPattern(pattern: any): void;
  primitiveAddUsedByObject(object: any): void;
  primitiveRemoveUsedByObject(object: any): void;

  color(): MSImmutableColor;
  setColor(color: MSImmutableColor): void;
  opacity(): number;
  setOpacity(opacity: number): void;
  windingrule(): NSString;
  setWindingrule(windingrule: NSString | string): void;
  gradient(): SVGGradient;
  setGradient(gradient: SVGGradient): void;
  pattern(): SVGPattern;
  setPattern(pattern: SVGPattern): void;
  usedBy(): NSSet<any>;
  setUsedBy(usedBy: NSSet<any>): void;
}
declare const _SVGFill: {
  alloc(): _SVGFillAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGFontAllocator<InitializedType = _SVGFont> extends SVGElementAllocator<_SVGFont> {}
interface _SVGFont extends SVGElement {
  primitiveAddUsedByObject(object: any): void;
  primitiveRemoveUsedByObject(object: any): void;

  family(): NSString;
  setFamily(family: NSString | string): void;
  size(): number;
  setSize(size: number): void;
  style(): NSString;
  setStyle(style: NSString | string): void;
  variant(): NSString;
  setVariant(variant: NSString | string): void;
  weight(): number;
  setWeight(weight: number): void;
  usedBy(): NSSet<any>;
  setUsedBy(usedBy: NSSet<any>): void;
}
declare const _SVGFont: {
  alloc(): _SVGFontAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGGradientAllocator<InitializedType = _SVGGradient> extends SVGElementAllocator<_SVGGradient> {}
interface _SVGGradient extends SVGElement {
  primitiveAddLinkedFromObject(object: any): void;
  primitiveRemoveLinkedFromObject(object: any): void;
  primitiveSetLinkedTo(linkedTo: any): void;
  primitiveAddUsedByFillsObject(object: any): void;
  primitiveRemoveUsedByFillsObject(object: any): void;
  primitiveAddUsedByStrokesObject(object: any): void;
  primitiveRemoveUsedByStrokesObject(object: any): void;

  fromX(): number;
  setFromX(fromX: number): void;
  fromY(): number;
  setFromY(fromY: number): void;
  radial(): boolean;
  setRadial(radial: boolean): void;
  toX(): number;
  setToX(toX: number): void;
  toY(): number;
  setToY(toY: number): void;
  transform(): NSAffineTransform;
  setTransform(transform: NSAffineTransform): void;
  linkedFrom(): NSSet<any>;
  setLinkedFrom(linkedFrom: NSSet<any>): void;
  linkedTo(): SVGGradient;
  setLinkedTo(linkedTo: SVGGradient): void;
  usedByFills(): NSSet<any>;
  setUsedByFills(usedByFills: NSSet<any>): void;
  usedByStrokes(): NSSet<any>;
  setUsedByStrokes(usedByStrokes: NSSet<any>): void;
}
declare const _SVGGradient: {
  alloc(): _SVGGradientAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGGradientStopAllocator<InitializedType = _SVGGradientStop> extends SVGElementAllocator<_SVGGradientStop> {}
interface _SVGGradientStop extends SVGElement {

  color(): MSImmutableColor;
  setColor(color: MSImmutableColor): void;
  position(): number;
  setPosition(position: number): void;
}
declare const _SVGGradientStop: {
  alloc(): _SVGGradientStopAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGGroupElementAllocator<InitializedType = _SVGGroupElement> extends SVGDrawableElementAllocator<_SVGGroupElement> {}
interface _SVGGroupElement extends SVGDrawableElement {
}
declare const _SVGGroupElement: {
  alloc(): _SVGGroupElementAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGImageAllocator<InitializedType = _SVGImage> extends SVGDrawableElementAllocator<_SVGImage> {}
interface _SVGImage extends SVGDrawableElement {

  image(): NSImage;
  setImage(image: NSImage): void;
}
declare const _SVGImage: {
  alloc(): _SVGImageAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGLineShapeAllocator<InitializedType = _SVGLineShape> extends SVGBasicShapeAllocator<_SVGLineShape> {}
interface _SVGLineShape extends SVGBasicShape {

  x1(): number;
  setX1(x1: number): void;
  x2(): number;
  setX2(x2: number): void;
  y1(): number;
  setY1(y1: number): void;
  y2(): number;
  setY2(y2: number): void;
}
declare const _SVGLineShape: {
  alloc(): _SVGLineShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGLinkAllocator<InitializedType = _SVGLink> extends SVGDrawableElementAllocator<_SVGLink> {}
interface _SVGLink extends SVGDrawableElement {
  primitiveSetLink(link: any): void;

  link(): SVGElement;
  setLink(link: SVGElement): void;
}
declare const _SVGLink: {
  alloc(): _SVGLinkAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGMaskAllocator<InitializedType = _SVGMask> extends SVGGroupElementAllocator<_SVGMask> {}
interface _SVGMask extends SVGGroupElement {
  primitiveAddMaskingObject(object: any): void;
  primitiveRemoveMaskingObject(object: any): void;

  masking(): NSSet<any>;
  setMasking(masking: NSSet<any>): void;
}
declare const _SVGMask: {
  alloc(): _SVGMaskAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGPathShapeAllocator<InitializedType = _SVGPathShape> extends SVGDrawableElementAllocator<_SVGPathShape> {}
interface _SVGPathShape extends SVGDrawableElement {

  closed(): boolean;
  setClosed(closed: boolean): void;
  path(): NSBezierPath;
  setPath(path: NSBezierPath): void;
}
declare const _SVGPathShape: {
  alloc(): _SVGPathShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGPatternAllocator<InitializedType = _SVGPattern> extends SVGElementAllocator<_SVGPattern> {}
interface _SVGPattern extends SVGElement {
  primitiveAddUsedByFillsObject(object: any): void;
  primitiveRemoveUsedByFillsObject(object: any): void;
  primitiveAddUsedByStrokesObject(object: any): void;
  primitiveRemoveUsedByStrokesObject(object: any): void;

  height(): number;
  setHeight(height: number): void;
  patternUnits(): NSString;
  setPatternUnits(patternUnits: NSString | string): void;
  width(): number;
  setWidth(width: number): void;
  x(): number;
  setX(x: number): void;
  y(): number;
  setY(y: number): void;
  usedByFills(): NSSet<any>;
  setUsedByFills(usedByFills: NSSet<any>): void;
  usedByStrokes(): NSSet<any>;
  setUsedByStrokes(usedByStrokes: NSSet<any>): void;
}
declare const _SVGPattern: {
  alloc(): _SVGPatternAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGPolygonShapeAllocator<InitializedType = _SVGPolygonShape> extends SVGPathShapeAllocator<_SVGPolygonShape> {}
interface _SVGPolygonShape extends SVGPathShape {
}
declare const _SVGPolygonShape: {
  alloc(): _SVGPolygonShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGRectangleShapeAllocator<InitializedType = _SVGRectangleShape> extends SVGBasicShapeAllocator<_SVGRectangleShape> {}
interface _SVGRectangleShape extends SVGBasicShape {

  cornerRadius(): number;
  setCornerRadius(cornerRadius: number): void;
}
declare const _SVGRectangleShape: {
  alloc(): _SVGRectangleShapeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGRootElementAllocator<InitializedType = _SVGRootElement> extends SVGGroupElementAllocator<_SVGRootElement> {}
interface _SVGRootElement extends SVGGroupElement {

  height(): number;
  setHeight(height: number): void;
  width(): number;
  setWidth(width: number): void;
}
declare const _SVGRootElement: {
  alloc(): _SVGRootElementAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGStrokeAllocator<InitializedType = _SVGStroke> extends SVGElementAllocator<_SVGStroke> {}
interface _SVGStroke extends SVGElement {
  primitiveSetGradient(gradient: any): void;
  primitiveSetPattern(pattern: any): void;
  primitiveAddUsedByObject(object: any): void;
  primitiveRemoveUsedByObject(object: any): void;

  color(): MSImmutableColor;
  setColor(color: MSImmutableColor): void;
  dashes(): NSArray<any>;
  setDashes(dashes: NSArray<any> | any[]): void;
  linecap(): NSString;
  setLinecap(linecap: NSString | string): void;
  linejoin(): NSString;
  setLinejoin(linejoin: NSString | string): void;
  width(): number;
  setWidth(width: number): void;
  gradient(): SVGGradient;
  setGradient(gradient: SVGGradient): void;
  pattern(): SVGPattern;
  setPattern(pattern: SVGPattern): void;
  usedBy(): NSSet<any>;
  setUsedBy(usedBy: NSSet<any>): void;
}
declare const _SVGStroke: {
  alloc(): _SVGStrokeAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGSymbolElementAllocator<InitializedType = _SVGSymbolElement> extends SVGGroupElementAllocator<_SVGSymbolElement> {}
interface _SVGSymbolElement extends SVGGroupElement {
}
declare const _SVGSymbolElement: {
  alloc(): _SVGSymbolElementAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface _SVGTextAllocator<InitializedType = _SVGText> extends SVGDrawableElementAllocator<_SVGText> {}
interface _SVGText extends SVGDrawableElement {

  adjustSpacingAndGlyphs(): boolean;
  setAdjustSpacingAndGlyphs(adjustSpacingAndGlyphs: boolean): void;
  anchor(): number;
  setAnchor(anchor: number): void;
  dx(): number;
  setDx(dx: number): void;
  dy(): number;
  setDy(dy: number): void;
  length(): number;
  setLength(length: number): void;
  rotate(): number;
  setRotate(rotate: number): void;
  text(): NSString;
  setText(text: NSString | string): void;
  x(): number;
  setX(x: number): void;
  y(): number;
  setY(y: number): void;
}
declare const _SVGText: {
  alloc(): _SVGTextAllocator;  propertyNames(): NSArray<any>;
  relationshipNames(): NSArray<any>;
  attributeNames(): NSArray<any>;

}

interface SVGBasicShapeAllocator<InitializedType = SVGBasicShape> extends _SVGBasicShapeAllocator<SVGBasicShape> {}
interface SVGBasicShape extends _SVGBasicShape {
  shapeGroupForLayer(layer: MSLayer): MSShapeGroup;
}
declare const SVGBasicShape: {
  alloc(): SVGBasicShapeAllocator;
}

interface SVGCircleShapeAllocator<InitializedType = SVGCircleShape> extends _SVGCircleShapeAllocator<SVGCircleShape> {}
interface SVGCircleShape extends _SVGCircleShape {
}
declare const SVGCircleShape: {
  alloc(): SVGCircleShapeAllocator;
}

interface SVGClipPathAllocator<InitializedType = SVGClipPath> extends _SVGClipPathAllocator<SVGClipPath> {}
interface SVGClipPath extends _SVGClipPath {
}
declare const SVGClipPath: {
  alloc(): SVGClipPathAllocator;
}

interface SVGDrawableElementAllocator<InitializedType = SVGDrawableElement> extends _SVGDrawableElementAllocator<SVGDrawableElement> {}
interface SVGDrawableElement extends _SVGDrawableElement {
  dontCollapse(): boolean;
  processStyles_parent(xml: NSXMLElement, parent: SVGDrawableElement): void;
  emptyLayerWithParentLayer(parentLayer: MSLayerGroup): MSLayer;
  applyEffectsToLayer(layer: MSLayer): void;

  deferredClipping(): NSXMLElement;
  setDeferredClipping(deferredClipping: NSXMLElement): void;
}
declare const SVGDrawableElement: {
  alloc(): SVGDrawableElementAllocator;
}

interface SVGElementAllocator<InitializedType = SVGElement> extends _SVGElementAllocator<SVGElement> {
  initWithImporter_xml(importer: SVGImporter, xml: NSXMLElement): InitializedType;
}
interface SVGElement extends _SVGElement {
  elementOfType_xml_parent(type: NSString | string, xml: NSXMLElement, parent: SVGElement): SVGElement;
  process(): void;
  processSelf(xml: NSXMLElement): void;
  processIdentifier(xml: NSXMLElement): void;
  processStyles(): void;
  processChildren(xml: NSXMLElement): void;
  processChildren_startingAtIndex(xml: NSXMLElement, index: NSUInteger): void;
  processChild_index(xml: NSXMLElement, index: NSUInteger): NSUInteger;
  svgDescription(): NSString;
  svgAttributesDescription(): NSString;
  addReferenceToIdentifier_type_property(identifier: NSString | string, type: NSString | string, property: NSString | string): void;
  resolvedValue_forProperty(value: SVGElement, property: NSString | string): void;
  name(): NSString;
  containsDrawables(): boolean;
  drawableParent(): SVGDrawableElement;
  clippingParent(): SVGDrawableElement;
  relativeURLForLink(link: NSString | string): NSURL;
  styleAttributesForElement_defaults(xml: NSXMLElement, defaults: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  isDescendantOf(element: SVGElement): boolean;
  makeLayerWithParentLayer_progress(parentLayer: MSLayerGroup, progress: BCVoidBlock): MSLayer;
  nameLayer(layer: MSLayer): void;
  adjustSizeForChildrenOfLayer(layer: MSLayer): void;

  xml(): NSXMLElement;
  setXml(xml: NSXMLElement): void;
  importer(): SVGImporter;
  effectiveLayerName(): NSString;
}
declare const SVGElement: {
  alloc(): SVGElementAllocator;  elementOfType_xml_importer_parent(type: NSString | string, xml: NSXMLElement, importer: SVGImporter, parent: SVGElement): SVGElement;

}

interface SVGEllipseShapeAllocator<InitializedType = SVGEllipseShape> extends _SVGEllipseShapeAllocator<SVGEllipseShape> {}
interface SVGEllipseShape extends _SVGEllipseShape {
}
declare const SVGEllipseShape: {
  alloc(): SVGEllipseShapeAllocator;
}

interface SVGFillAllocator<InitializedType = SVGFill> extends _SVGFillAllocator<SVGFill> {}
interface SVGFill extends _SVGFill {
}
declare const SVGFill: {
  alloc(): SVGFillAllocator;  fillForXML_element_parent(xml: NSXMLElement, element: SVGElement, parent: SVGDrawableElement): SVGFill;

}

interface SVGFontAllocator<InitializedType = SVGFont> extends _SVGFontAllocator<SVGFont> {}
interface SVGFont extends _SVGFont {
  representedFont(): NSFont;
}
declare const SVGFont: {
  alloc(): SVGFontAllocator;  fontForXML_element_parent(xml: NSXMLElement, element: SVGElement, parent: SVGDrawableElement): SVGFont;

}

interface SVGGradientAllocator<InitializedType = SVGGradient> extends _SVGGradientAllocator<SVGGradient> {}
interface SVGGradient extends _SVGGradient {
  from(): NSPoint;
  to(): NSPoint;
  stopsElements(): NSArray<any>;

  usesAbsoluteUnits(): boolean;
}
declare const SVGGradient: {
  alloc(): SVGGradientAllocator;
}

interface SVGGradientStopAllocator<InitializedType = SVGGradientStop> extends _SVGGradientStopAllocator<SVGGradientStop> {}
interface SVGGradientStop extends _SVGGradientStop {
}
declare const SVGGradientStop: {
  alloc(): SVGGradientStopAllocator;
}

interface SVGGroupElementAllocator<InitializedType = SVGGroupElement> extends _SVGGroupElementAllocator<SVGGroupElement> {}
interface SVGGroupElement extends _SVGGroupElement {
}
declare const SVGGroupElement: {
  alloc(): SVGGroupElementAllocator;
}

interface SVGImageAllocator<InitializedType = SVGImage> extends _SVGImageAllocator<SVGImage> {}
interface SVGImage extends _SVGImage {
}
declare const SVGImage: {
  alloc(): SVGImageAllocator;
}

interface SVGLineShapeAllocator<InitializedType = SVGLineShape> extends _SVGLineShapeAllocator<SVGLineShape> {}
interface SVGLineShape extends _SVGLineShape {
}
declare const SVGLineShape: {
  alloc(): SVGLineShapeAllocator;
}

interface SVGLinkAllocator<InitializedType = SVGLink> extends _SVGLinkAllocator<SVGLink> {}
interface SVGLink extends _SVGLink {
}
declare const SVGLink: {
  alloc(): SVGLinkAllocator;
}

interface SVGMaskAllocator<InitializedType = SVGMask> extends _SVGMaskAllocator<SVGMask> {}
interface SVGMask extends _SVGMask {
}
declare const SVGMask: {
  alloc(): SVGMaskAllocator;
}

interface SVGPathShapeAllocator<InitializedType = SVGPathShape> extends _SVGPathShapeAllocator<SVGPathShape> {}
interface SVGPathShape extends _SVGPathShape {
}
declare const SVGPathShape: {
  alloc(): SVGPathShapeAllocator;
}

interface SVGPolygonShapeAllocator<InitializedType = SVGPolygonShape> extends _SVGPolygonShapeAllocator<SVGPolygonShape> {}
interface SVGPolygonShape extends _SVGPolygonShape {
}
declare const SVGPolygonShape: {
  alloc(): SVGPolygonShapeAllocator;
}

interface SVGRectangleShapeAllocator<InitializedType = SVGRectangleShape> extends _SVGRectangleShapeAllocator<SVGRectangleShape> {}
interface SVGRectangleShape extends _SVGRectangleShape {
}
declare const SVGRectangleShape: {
  alloc(): SVGRectangleShapeAllocator;
}

interface SVGRootElementAllocator<InitializedType = SVGRootElement> extends _SVGRootElementAllocator<SVGRootElement> {}
interface SVGRootElement extends _SVGRootElement {
}
declare const SVGRootElement: {
  alloc(): SVGRootElementAllocator;
}

interface SVGStrokeAllocator<InitializedType = SVGStroke> extends _SVGStrokeAllocator<SVGStroke> {}
interface SVGStroke extends _SVGStroke {
}
declare const SVGStroke: {
  alloc(): SVGStrokeAllocator;  strokeForXML_element_parent(xml: NSXMLElement, element: SVGElement, parent: SVGDrawableElement): SVGStroke;

}

interface SVGSymbolElementAllocator<InitializedType = SVGSymbolElement> extends _SVGSymbolElementAllocator<SVGSymbolElement> {}
interface SVGSymbolElement extends _SVGSymbolElement {
}
declare const SVGSymbolElement: {
  alloc(): SVGSymbolElementAllocator;
}

interface SVGTextAllocator<InitializedType = SVGText> extends _SVGTextAllocator<SVGText> {}
interface SVGText extends _SVGText {
}
declare const SVGText: {
  alloc(): SVGTextAllocator;
}

interface SVGCSSParserAllocator<InitializedType = SVGCSSParser> extends NSObjectAllocator<SVGCSSParser> {}
interface SVGCSSParser extends NSObject {
}
declare const SVGCSSParser: {
  alloc(): SVGCSSParserAllocator;  parseCSSAttributeList(cssAttributes: NSString | string): NSDictionary<any, any>;
  mergeStylesheet_withExisting(styleSheet: NSString | string, existing: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;

}

interface SVGDescriptionAllocator<InitializedType = SVGDescription> extends SVGElementAllocator<SVGDescription> {}
interface SVGDescription extends SVGElement {
}
declare const SVGDescription: {
  alloc(): SVGDescriptionAllocator;
}

declare enum SVGExportOptions {
  SVGExportOptionsIncludeHeader = 1,
  SVGExportOptionsCompact = 0,
  SVGExportOptionsDefault,
}

interface SVGImporterAllocator<InitializedType = SVGImporter> extends NSObjectAllocator<SVGImporter> {
  initWithURL(url: NSURL): InitializedType;
  initWithData(data: NSData): InitializedType;
  initWithXMLString(string: NSString | string): InitializedType;
}
interface SVGImporter extends NSObject {
  importObjectGraph(): SVGElement;
  addedDrawableElement(element: SVGDrawableElement): void;
  drawableElementCount(): NSUInteger;
  elementOfType_xml_parent(type: NSString | string, xml: NSXMLElement, parent: SVGElement): SVGElement;
  registerElementWithIdentifier_type_element(identifier: NSString | string, type: NSString | string, element: SVGElement): void;
  addReferenceToIdentifier_type_target_property(identifier: NSString | string, type: NSString | string, target: any, property: NSString | string): void;
  relativeURLForLink(link: NSString | string): NSURL;
  registerStylesheet(stylesheet: NSString | string): void;
  styleAttributesForElement_defaults(xml: NSXMLElement, defaults: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;

  documentWidth(): CGFloat;
  documentHeight(): CGFloat;
  scaleValue(): CGFloat;
  setScaleValue(scaleValue: CGFloat): void;
}
declare const SVGImporter: {
  alloc(): SVGImporterAllocator;
}

interface SVGPathInterpreterAllocator<InitializedType = SVGPathInterpreter> extends NSObjectAllocator<SVGPathInterpreter> {}
interface SVGPathInterpreter extends NSObject {
  bezierPathFromCommands_isPathClosed(commands: NSString | string, isClosed: boolean): NSBezierPath;
  bezierPathFromPoints(points: NSString | string): NSBezierPath;
}
declare const SVGPathInterpreter: {
  alloc(): SVGPathInterpreterAllocator;
}

interface SVGPathScannerAllocator<InitializedType = SVGPathScanner> extends NSObjectAllocator<SVGPathScanner> {
  initWithString(string: NSString | string): InitializedType;
}
interface SVGPathScanner extends NSObject {
  nextCommand(): string;
  nextFloat(): CGFloat;

  scanner(): NSScanner;
  setScanner(scanner: NSScanner): void;
}
declare const SVGPathScanner: {
  alloc(): SVGPathScannerAllocator;
}

interface SVGStyleAllocator<InitializedType = SVGStyle> extends SVGElementAllocator<SVGStyle> {}
interface SVGStyle extends SVGElement {
}
declare const SVGStyle: {
  alloc(): SVGStyleAllocator;
}

interface SVGTitleAllocator<InitializedType = SVGTitle> extends SVGElementAllocator<SVGTitle> {}
interface SVGTitle extends SVGElement {
}
declare const SVGTitle: {
  alloc(): SVGTitleAllocator;
}

interface SVGTransformImporterAllocator<InitializedType = SVGTransformImporter> extends NSObjectAllocator<SVGTransformImporter> {}
interface SVGTransformImporter extends NSObject {
}
declare const SVGTransformImporter: {
  alloc(): SVGTransformImporterAllocator;  transformFromString(aString: NSString | string): NSAffineTransform;
  transformFromName_components(name: NSString | string, paramString: NSString | string): NSAffineTransform;
  translateTransformFromComponents(params: NSArray<any> | any[]): NSAffineTransform;
  rotateTransformFromComponents(params: NSArray<any> | any[]): NSAffineTransform;
  matrixTransformFromComponents(params: NSArray<any> | any[]): NSAffineTransform;

}

interface MSExportRendererWithSVGSupportAllocator<InitializedType = MSExportRendererWithSVGSupport> extends MSExporterAllocator<MSExportRendererWithSVGSupport> {}
interface MSExportRendererWithSVGSupport extends MSExporter {
}
declare const MSExportRendererWithSVGSupport: {
  alloc(): MSExportRendererWithSVGSupportAllocator;
}

interface MSSVGBlendModeAllocator<InitializedType = MSSVGBlendMode> extends NSObjectAllocator<MSSVGBlendMode> {}
interface MSSVGBlendMode extends NSObject {
}
declare const MSSVGBlendMode: {
  alloc(): MSSVGBlendModeAllocator;  sketchBlendModeFromSVG(svgValue: NSString | string): MSBlendMode;
  svgFromSketchBlendMode(blendMode: MSBlendMode): NSString;

}

interface MSSVGColorMatrixAllocator<InitializedType = MSSVGColorMatrix> extends MSSVGfeFilterPrimitiveAllocator<MSSVGColorMatrix> {}
interface MSSVGColorMatrix extends MSSVGfeFilterPrimitive {

  in(): NSString;
  setIn(in_: NSString | string): void;
  type(): NSString;
  setType(type: NSString | string): void;
  values(): NSString;
  setValues(values: NSString | string): void;
}
declare const MSSVGColorMatrix: {
  alloc(): MSSVGColorMatrixAllocator;  colorMatrixForColor(color: MSImmutableColor): MSSVGColorMatrix;

}

interface MSSVGCompositeAllocator<InitializedType = MSSVGComposite> extends MSSVGfeFilterPrimitiveAllocator<MSSVGComposite> {}
interface MSSVGComposite extends MSSVGfeFilterPrimitive {

  in(): NSString;
  setIn(in_: NSString | string): void;
  in2(): NSString;
  setIn2(in2: NSString | string): void;
  operator(): NSString;
  setOperator(operator: NSString | string): void;
  k1(): CGFloat;
  setK1(k1: CGFloat): void;
  k2(): CGFloat;
  setK2(k2: CGFloat): void;
  k3(): CGFloat;
  setK3(k3: CGFloat): void;
  k4(): CGFloat;
  setK4(k4: CGFloat): void;
}
declare const MSSVGComposite: {
  alloc(): MSSVGCompositeAllocator;
}

interface MSSVGFilterAllocator<InitializedType = MSSVGFilter> extends MSXMLElementWrapperAllocator<MSSVGFilter> {}
interface MSSVGFilter extends MSXMLElementWrapper {
  addFilterItem(filterItem: NSXMLElement): void;
  addFilterOutput(string: NSString | string): void;
  close(): void;

  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  filterRes(): NSString;
  setFilterRes(filterRes: NSString | string): void;
  filterUnits(): NSString;
  setFilterUnits(filterUnits: NSString | string): void;
  primitiveUnits(): NSString;
  setPrimitiveUnits(primitiveUnits: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}
declare const MSSVGFilter: {
  alloc(): MSSVGFilterAllocator;  filter(): MSSVGFilter;

}

interface MSSVGGaussianBlurAllocator<InitializedType = MSSVGGaussianBlur> extends MSSVGfeFilterPrimitiveAllocator<MSSVGGaussianBlur> {}
interface MSSVGGaussianBlur extends MSSVGfeFilterPrimitive {

  in(): NSString;
  setIn(in_: NSString | string): void;
  stdDeviation(): NSString;
  setStdDeviation(stdDeviation: NSString | string): void;
}
declare const MSSVGGaussianBlur: {
  alloc(): MSSVGGaussianBlurAllocator;
}

interface MSSVGImageWrapperAllocator<InitializedType = MSSVGImageWrapper> extends MSXMLElementWrapperAllocator<MSSVGImageWrapper> {}
interface MSSVGImageWrapper extends MSXMLElementWrapper {

  externalResourcesRequired(): NSString;
  setExternalResourcesRequired(externalResourcesRequired: NSString | string): void;
  preserveAspectRatio(): NSString;
  setPreserveAspectRatio(preserveAspectRatio: NSString | string): void;
  transform(): NSString;
  setTransform(transform: NSString | string): void;
  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}
declare const MSSVGImageWrapper: {
  alloc(): MSSVGImageWrapperAllocator;
}

interface MSSVGMergeAllocator<InitializedType = MSSVGMerge> extends MSSVGfeFilterPrimitiveAllocator<MSSVGMerge> {}
interface MSSVGMerge extends MSSVGfeFilterPrimitive {
  addMergeNodeNamed(name: NSString | string): void;
}
declare const MSSVGMerge: {
  alloc(): MSSVGMergeAllocator;
}

interface MSSVGMergeNodeAllocator<InitializedType = MSSVGMergeNode> extends MSXMLElementWrapperAllocator<MSSVGMergeNode> {}
interface MSSVGMergeNode extends MSXMLElementWrapper {

  in(): NSString;
  setIn(in_: NSString | string): void;
}
declare const MSSVGMergeNode: {
  alloc(): MSSVGMergeNodeAllocator;  mergeNodeNamed(nodeName: NSString | string): MSSVGMergeNode;

}

interface MSSVGMorphologyAllocator<InitializedType = MSSVGMorphology> extends MSSVGfeFilterPrimitiveAllocator<MSSVGMorphology> {}
interface MSSVGMorphology extends MSSVGfeFilterPrimitive {

  in(): NSString;
  setIn(in_: NSString | string): void;
  operator(): NSString;
  setOperator(operator: NSString | string): void;
  radius(): CGFloat;
  setRadius(radius: CGFloat): void;
}
declare const MSSVGMorphology: {
  alloc(): MSSVGMorphologyAllocator;
}

interface MSSVGOffsetAllocator<InitializedType = MSSVGOffset> extends MSSVGfeFilterPrimitiveAllocator<MSSVGOffset> {}
interface MSSVGOffset extends MSSVGfeFilterPrimitive {

  in(): NSString;
  setIn(in_: NSString | string): void;
  dx(): CGFloat;
  setDx(dx: CGFloat): void;
  dy(): CGFloat;
  setDy(dy: CGFloat): void;
}
declare const MSSVGOffset: {
  alloc(): MSSVGOffsetAllocator;
}

interface MSSVGPatternWrapperAllocator<InitializedType = MSSVGPatternWrapper> extends MSXMLElementWrapperAllocator<MSSVGPatternWrapper> {}
interface MSSVGPatternWrapper extends MSXMLElementWrapper {

  preserveAspectRatio(): NSString;
  setPreserveAspectRatio(preserveAspectRatio: NSString | string): void;
  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  patternUnits(): NSString;
  setPatternUnits(patternUnits: NSString | string): void;
  patternContentUnits(): NSString;
  setPatternContentUnits(patternContentUnits: NSString | string): void;
  patternTransform(): NSString;
  setPatternTransform(patternTransform: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}
declare const MSSVGPatternWrapper: {
  alloc(): MSSVGPatternWrapperAllocator;
}

interface MSSVGUseWrapperAllocator<InitializedType = MSSVGUseWrapper> extends MSXMLElementWrapperAllocator<MSSVGUseWrapper> {}
interface MSSVGUseWrapper extends MSXMLElementWrapper {

  externalResourcesRequired(): NSString;
  setExternalResourcesRequired(externalResourcesRequired: NSString | string): void;
  transform(): NSString;
  setTransform(transform: NSString | string): void;
  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}
declare const MSSVGUseWrapper: {
  alloc(): MSSVGUseWrapperAllocator;
}

interface MSSVGfeFilterPrimitiveAllocator<InitializedType = MSSVGfeFilterPrimitive> extends MSXMLElementWrapperAllocator<MSSVGfeFilterPrimitive> {}
interface MSSVGfeFilterPrimitive extends MSXMLElementWrapper {

  result(): NSString;
  setResult(result: NSString | string): void;
}
declare const MSSVGfeFilterPrimitive: {
  alloc(): MSSVGfeFilterPrimitiveAllocator;  filter(): MSSVGfeFilterPrimitive;

}

interface MSXMLElementWrapperAllocator<InitializedType = MSXMLElementWrapper> extends NSObjectAllocator<MSXMLElementWrapper> {
  initWithName(elementName: NSString | string): InitializedType;
  initWithElement(element: NSXMLElement): InitializedType;
}
interface MSXMLElementWrapper extends NSObject {
  attributeStringForKey(key: NSString | string): NSString;
  setAttributeString_forKey(value: NSString | string, key: NSString | string): void;
  addChild(child: NSXMLNode): void;
  addChildWrapper(child: MSXMLElementWrapper): void;

  element(): NSXMLElement;
  svgId(): NSString;
  setSvgId(svgId: NSString | string): void;
  svgClass(): NSString;
  setSvgClass(svgClass: NSString | string): void;
  style(): NSString;
  setStyle(style: NSString | string): void;
}
declare const MSXMLElementWrapper: {
  alloc(): MSXMLElementWrapperAllocator;  elementName(): NSString;
  element(): MSXMLElementWrapper;

}

interface SVGPatternAllocator<InitializedType = SVGPattern> extends _SVGPatternAllocator<SVGPattern> {}
interface SVGPattern extends _SVGPattern {

  imageData(): MSImageData;
  scale(): CGFloat;
  sketchPatternFillType(): MSPatternFillType;
}
declare const SVGPattern: {
  alloc(): SVGPatternAllocator;
}

interface SketchSVGExporterAllocator<InitializedType = SketchSVGExporter> extends NSObjectAllocator<SketchSVGExporter> {
  initWithImmutableDocument_exportRect_layerIDs_includeBackground(immutableDocument: MSImmutableDocumentData, exportRect: NSRect, layerIDs: NSSet<any>, includeBackground: boolean): InitializedType;
  initWithName_exportRequest(name: NSString | string, request: MSExportRequest): InitializedType;
}
interface SketchSVGExporter extends NSObject {
  exportLayers(layers: NSArray<any> | any[]): NSData;
  pushParent(layer: MSImmutableLayer): void;
  popParent(): MSImmutableLayer;
  parentForLayer(layer: any): MSImmutableLayer;
  performWithParent_block(layer: MSImmutableLayer, block: BCVoidBlock): void;
  ancestorsForLayer(layer: any): NSArray<any>;
  drawSymbolInstance_inBlock(instance: MSImmutableSymbolInstance, block: BCVoidBlock): void;
  isDrawingSymbol(): boolean;
  addDefinitionWithName_children_attributes(name: NSString | string, children: NSArray<any> | any[], attributes: NSArray<any> | any[]): NSXMLElement;
  addGradient_inRect(gradient: MSImmutableGradient, rect: MSImmutableRect): void;
  gradientElement_inRect(gradient: MSImmutableGradient, rect: MSImmutableRect): NSXMLElement;
  uniqueIDForElementWithName(name: NSString | string): NSString;
  beginFilterGroup(): MSSVGFilter;
  endFilterGroup(): boolean;
  layerIsIncluded(layer: MSImmutableLayer): boolean;

  exportBounds(): NSRect;
  mask(): NSString;
  setMask(mask: NSString | string): void;
  currentShapeDef(): NSString;
  setCurrentShapeDef(currentShapeDef: NSString | string): void;
  document(): MSImmutableDocumentData;
  currentFilterGroup(): MSSVGFilter;
  currentSymbolInstance(): MSImmutableSymbolInstance;
  includeArtboardBackground(): boolean;
}
declare const SketchSVGExporter: {
  alloc(): SketchSVGExporterAllocator;
}

interface BCSketchToolRunnerAllocator<InitializedType = BCSketchToolRunner> extends BCToolRunnerAllocator<BCSketchToolRunner> {
  initWithSketchToolURL_maximumConcurrentOperations(toolURL: NSURL, maxConcurrency: NSInteger): InitializedType;
}
interface BCSketchToolRunner extends BCToolRunner {
  exportPreviewImageForDocumentAtURL_additionalArguments_intoURL_completionHandler(url: NSURL, additionalArguments: NSArray<any> | any[], previewImageURL: NSURL, handler: MSDocumentPreviewImageHandler): void;

  sketchToolURL(): NSURL;
}
declare const BCSketchToolRunner: {
  alloc(): BCSketchToolRunnerAllocator;
}

interface BCSTCommandAllocator<InitializedType = BCSTCommand> extends ECCommandLineCommandAllocator<BCSTCommand> {}
interface BCSTCommand extends ECCommandLineCommand {
  processDocumentsAtPaths_engine(paths: NSArray<any> | any[], engine: ECCommandLineEngine): ECCommandLineResult;
  processDocumentURL_engine(documentURL: NSURL, engine: ECCommandLineEngine): ECCommandLineResult;
  processItemsForPage_engine(page: MSPage, engine: ECCommandLineEngine): ECCommandLineResult;
  documentDataForURL_engine(url: NSURL, engine: ECCommandLineEngine): MSDocumentData;
  documentForURL_engine(url: NSURL, engine: ECCommandLineEngine): MSDocumentReader;
  pagesForURL_engine(url: NSURL, engine: ECCommandLineEngine): NSArray<any>;
  scalesToUseForSlice_scales(slice: MSSliceLayer, scales: NSArray<any> | any[]): NSArray<any>;
  suffixForScale(scale: CGFloat): NSString;
  specifiedItemsWithEngine(engine: ECCommandLineEngine): NSArray<any>;
  filteredArtboardsForPage_engine(page: MSPage, engine: ECCommandLineEngine): NSArray<any>;
}
declare const BCSTCommand: {
  alloc(): BCSTCommandAllocator;
}

declare enum BCSTErrorCode {
  BCSTNoError,
  BCSTExportFailed,
  BCSTBadBoundsFormat,
  BCSTDocumentTooNew,
  BCSTUnknownFolderType,
  BCSTMissingReleaseNotes,
  BCSTFailedToLaunchSketch,
  BCSTTimedOutWaitingForSketch,
}

interface BCSTDumpCommandAllocator<InitializedType = BCSTDumpCommand> extends BCSTCommandAllocator<BCSTDumpCommand> {}
interface BCSTDumpCommand extends BCSTCommand {
}
declare const BCSTDumpCommand: {
  alloc(): BCSTDumpCommandAllocator;
}

interface BCSTEngineDelegateAllocator<InitializedType = BCSTEngineDelegate> extends NSObjectAllocator<BCSTEngineDelegate> {}
interface BCSTEngineDelegate extends NSObject, IECCommandLineEngineDelegate {

  resources(): NSBundle;
  setResources(resources: NSBundle): void;
}
declare const BCSTEngineDelegate: {
  alloc(): BCSTEngineDelegateAllocator;
}

interface BCSTExportArtboardsCommandAllocator<InitializedType = BCSTExportArtboardsCommand> extends BCSTCommandAllocator<BCSTExportArtboardsCommand> {}
interface BCSTExportArtboardsCommand extends BCSTCommand {
}
declare const BCSTExportArtboardsCommand: {
  alloc(): BCSTExportArtboardsCommandAllocator;
}

interface BCSTExportLayersCommandAllocator<InitializedType = BCSTExportLayersCommand> extends BCSTExportSlicesCommandAllocator<BCSTExportLayersCommand> {}
interface BCSTExportLayersCommand extends BCSTExportSlicesCommand {
}
declare const BCSTExportLayersCommand: {
  alloc(): BCSTExportLayersCommandAllocator;
}

interface BCSTExportPagesCommandAllocator<InitializedType = BCSTExportPagesCommand> extends BCSTCommandAllocator<BCSTExportPagesCommand> {}
interface BCSTExportPagesCommand extends BCSTCommand {
}
declare const BCSTExportPagesCommand: {
  alloc(): BCSTExportPagesCommandAllocator;
}

interface BCSTExportPreviewCommandAllocator<InitializedType = BCSTExportPreviewCommand> extends BCSTExportPagesCommandAllocator<BCSTExportPreviewCommand> {}
interface BCSTExportPreviewCommand extends BCSTExportPagesCommand {
}
declare const BCSTExportPreviewCommand: {
  alloc(): BCSTExportPreviewCommandAllocator;
}

interface BCSTExportSlicesCommandAllocator<InitializedType = BCSTExportSlicesCommand> extends BCSTCommandAllocator<BCSTExportSlicesCommand> {}
interface BCSTExportSlicesCommand extends BCSTCommand {
}
declare const BCSTExportSlicesCommand: {
  alloc(): BCSTExportSlicesCommandAllocator;
}

interface BCSTListArtboardsCommandAllocator<InitializedType = BCSTListArtboardsCommand> extends BCSTListCommandAllocator<BCSTListArtboardsCommand> {}
interface BCSTListArtboardsCommand extends BCSTListCommand {
}
declare const BCSTListArtboardsCommand: {
  alloc(): BCSTListArtboardsCommandAllocator;
}

interface BCSTListCommandAllocator<InitializedType = BCSTListCommand> extends BCSTCommandAllocator<BCSTListCommand> {}
interface BCSTListCommand extends BCSTCommand {
  itemsName(): NSString;
  itemsToListFromPages_engine(pages: NSArray<any> | any[], engine: ECCommandLineEngine): NSArray<any>;
  itemsToListFromPage_engine(page: MSPage, engine: ECCommandLineEngine): NSArray<any>;
  infoForPage_engine(page: MSPage, engine: ECCommandLineEngine): any;
  infoForItem_engine(item: any, engine: ECCommandLineEngine): NSDictionary<any, any>;
  safeName(name: NSString | string): NSString;
  rectDictionary(rect: NSRect): NSDictionary<any, any>;
  supportedFormats(): NSArray<any>;
}
declare const BCSTListCommand: {
  alloc(): BCSTListCommandAllocator;
}

interface BCSTListFormatsCommandAllocator<InitializedType = BCSTListFormatsCommand> extends BCSTListCommandAllocator<BCSTListFormatsCommand> {}
interface BCSTListFormatsCommand extends BCSTListCommand {
}
declare const BCSTListFormatsCommand: {
  alloc(): BCSTListFormatsCommandAllocator;
}

interface BCSTListLayersCommandAllocator<InitializedType = BCSTListLayersCommand> extends BCSTListSlicesCommandAllocator<BCSTListLayersCommand> {}
interface BCSTListLayersCommand extends BCSTListSlicesCommand {
}
declare const BCSTListLayersCommand: {
  alloc(): BCSTListLayersCommandAllocator;
}

interface BCSTListPagesCommandAllocator<InitializedType = BCSTListPagesCommand> extends BCSTListCommandAllocator<BCSTListPagesCommand> {}
interface BCSTListPagesCommand extends BCSTListCommand {
}
declare const BCSTListPagesCommand: {
  alloc(): BCSTListPagesCommandAllocator;
}

interface BCSTListSlicesCommandAllocator<InitializedType = BCSTListSlicesCommand> extends BCSTListCommandAllocator<BCSTListSlicesCommand> {}
interface BCSTListSlicesCommand extends BCSTListCommand {
}
declare const BCSTListSlicesCommand: {
  alloc(): BCSTListSlicesCommandAllocator;
}

interface BCSTMetadataCommandAllocator<InitializedType = BCSTMetadataCommand> extends BCSTCommandAllocator<BCSTMetadataCommand> {}
interface BCSTMetadataCommand extends BCSTCommand {
}
declare const BCSTMetadataCommand: {
  alloc(): BCSTMetadataCommandAllocator;
}

interface BCSTRunCommandAllocator<InitializedType = BCSTRunCommand> extends BCSTCommandAllocator<BCSTRunCommand> {}
interface BCSTRunCommand extends BCSTCommand {

  waitForTermination(): boolean;
  setWaitForTermination(waitForTermination: boolean): void;
}
declare const BCSTRunCommand: {
  alloc(): BCSTRunCommandAllocator;
}

interface BCSTShowCommandAllocator<InitializedType = BCSTShowCommand> extends BCSTCommandAllocator<BCSTShowCommand> {}
interface BCSTShowCommand extends BCSTCommand {
}
declare const BCSTShowCommand: {
  alloc(): BCSTShowCommandAllocator;
}

interface TerminationListenerAllocator<InitializedType = TerminationListener> extends NSObjectAllocator<TerminationListener> {
  initWithProcessIdentifier(processIdentifier: NSNumber | number): InitializedType;
}
interface TerminationListener extends NSObject {
  startListeningWithCompletion(completionBlock: Block): void;

  terminated(): boolean;
}
declare const TerminationListener: {
  alloc(): TerminationListenerAllocator;
}

interface SUAppcastAllocator<InitializedType = SUAppcast> extends NSObjectAllocator<SUAppcast> {}
interface SUAppcast extends NSObject, INSURLDownloadDelegate {
  fetchAppcastFromURL_inBackground_completionBlock(url: NSURL, bg: boolean, err: Block): void;
  copyWithoutDeltaUpdates(): SUAppcast;
  parseAppcastItemsFromXMLFile_error(appcastFile: NSURL, errorp: NSError): NSArray<any>;

  userAgentString(): NSString;
  setUserAgentString(userAgentString: NSString | string): void;
  httpHeaders(): NSDictionary<any, any>;
  setHttpHeaders(httpHeaders: NSDictionary<any, any> | {[key: string]: any}): void;
  items(): NSArray<any>;
}
declare const SUAppcast: {
  alloc(): SUAppcastAllocator;
}

interface SUAppcastItemAllocator<InitializedType = SUAppcastItem> extends NSObjectAllocator<SUAppcastItem> {
  initWithDictionary(dict: NSDictionary<any, any> | {[key: string]: any}): InitializedType;
  initWithDictionary_failureReason(dict: NSDictionary<any, any> | {[key: string]: any}, error: NSString | string): InitializedType;
}
interface SUAppcastItem extends NSObject {
  infoURL(): NSURL;

  title(): NSString;
  dateString(): NSString;
  itemDescription(): NSString;
  releaseNotesURL(): NSURL;
  DSASignature(): NSString;
  minimumSystemVersion(): NSString;
  maximumSystemVersion(): NSString;
  fileURL(): NSURL;
  contentLength(): number;
  versionString(): NSString;
  osString(): NSString;
  displayVersionString(): NSString;
  deltaUpdates(): NSDictionary<any, any>;
  infoURL(): NSURL;
  deltaUpdate(): boolean;
  criticalUpdate(): boolean;
  macOsUpdate(): boolean;
  informationOnlyUpdate(): boolean;
  propertiesDictionary(): NSDictionary<any, any>;
}
declare const SUAppcastItem: {
  alloc(): SUAppcastItemAllocator;
}

interface SUApplicationInfoAllocator<InitializedType = SUApplicationInfo> extends NSObjectAllocator<SUApplicationInfo> {}
interface SUApplicationInfo extends NSObject {
}
declare const SUApplicationInfo: {
  alloc(): SUApplicationInfoAllocator;  isBackgroundApplication(application: NSApplication): boolean;
  bestIconForHost(host: SUHost): NSImage;

}

interface SUAutomaticUpdateAlertAllocator<InitializedType = SUAutomaticUpdateAlert> extends NSWindowControllerAllocator<SUAutomaticUpdateAlert> {
  initWithAppcastItem_host_completionBlock(item: SUAppcastItem, hostBundle: SUHost, c: Block): InitializedType;
}
interface SUAutomaticUpdateAlert extends NSWindowController {
  installNowsender(): IBAction;
  installLatersender(): IBAction;
  doNotInstallsender(): IBAction;
}
declare const SUAutomaticUpdateAlert: {
  alloc(): SUAutomaticUpdateAlertAllocator;
}

declare enum SUAutomaticInstallationChoice {
  SUInstallNowChoice,
  SUInstallLaterChoice,
  SUDoNotInstallChoice,
}

interface SUAutomaticUpdateDriverAllocator<InitializedType = SUAutomaticUpdateDriver> extends SUBasicUpdateDriverAllocator<SUAutomaticUpdateDriver> {}
interface SUAutomaticUpdateDriver extends SUBasicUpdateDriver {
}
declare const SUAutomaticUpdateDriver: {
  alloc(): SUAutomaticUpdateDriverAllocator;
}

interface SUBasicUpdateDriverAllocator<InitializedType = SUBasicUpdateDriver> extends SUUpdateDriverAllocator<SUBasicUpdateDriver> {}
interface SUBasicUpdateDriver extends SUUpdateDriver, INSURLDownloadDelegate {
  checkForUpdatesAtURL_host(URL: NSURL, host: SUHost): void;
  isItemNewer(ui: SUAppcastItem): boolean;
  itemContainsSkippedVersion(ui: SUAppcastItem): boolean;
  itemContainsValidUpdate(ui: SUAppcastItem): boolean;
  appcastDidFinishLoading(ac: SUAppcast): void;
  didFindValidUpdate(): void;
  didNotFindUpdate(): void;
  downloadUpdate(): void;
  download_decideDestinationWithSuggestedFilename(d: NSURLDownload, name: NSString | string): void;
  downloadDidFinish(d: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
  extractUpdate(): void;
  failedToApplyDeltaUpdate(): void;
  unarchiver_extractedProgress(ua: any, progress: number): void;
  unarchiverDidFinish(ua: any): void;
  installWithToolAndRelaunch(relaunch: boolean): void;
  installWithToolAndRelaunch_displayingUserInterface(relaunch: boolean, showUI: boolean): void;
  installerForHost_failedWithError(host: SUHost, error: NSError): void;
  cleanUpDownload(): void;
  abortUpdate(): void;
  abortUpdateWithError(error: NSError): void;
  terminateApp(): void;

  updateItem(): SUAppcastItem;
  download(): NSURLDownload;
  downloadPath(): NSString;
}
declare const SUBasicUpdateDriver: {
  alloc(): SUBasicUpdateDriverAllocator;  hostSupportsItem(ui: SUAppcastItem): boolean;
  bestItemFromAppcastItems_getDeltaItem_withHostVersion_comparator(appcastItems: NSArray<any> | any[], deltaItem: SUAppcastItem, hostVersion: NSString | string, comparator: any): SUAppcastItem;

}

declare enum SUBinaryDeltaMajorVersion {
  SUAzureMajorVersion = 1,
  SUBeigeMajorVersion = 2,
}

interface SUBinaryDeltaUnarchiverAllocator<InitializedType = SUBinaryDeltaUnarchiver> extends NSObjectAllocator<SUBinaryDeltaUnarchiver> {
  initWithArchivePath_updateHostBundlePath(archivePath: NSString | string, updateHostBundlePath: NSString | string): InitializedType;
}
interface SUBinaryDeltaUnarchiver extends NSObject, ISUUnarchiverProtocol {
}
declare const SUBinaryDeltaUnarchiver: {
  alloc(): SUBinaryDeltaUnarchiverAllocator;  updateSpotlightImportersAtBundlePath(targetPath: NSString | string): void;

}

interface SUBundleIconAllocator<InitializedType = SUBundleIcon> extends NSObjectAllocator<SUBundleIcon> {}
interface SUBundleIcon extends NSObject {
}
declare const SUBundleIcon: {
  alloc(): SUBundleIconAllocator;  iconURLForHost(host: SUHost): NSURL;

}

interface SUCodeSigningVerifierAllocator<InitializedType = SUCodeSigningVerifier> extends NSObjectAllocator<SUCodeSigningVerifier> {}
interface SUCodeSigningVerifier extends NSObject {
}
declare const SUCodeSigningVerifier: {
  alloc(): SUCodeSigningVerifierAllocator;  codeSignatureAtBundleURL_matchesSignatureAtBundleURL_error(oldBundlePath: NSURL, newBundlePath: NSURL, error: NSError): boolean;
  codeSignatureIsValidAtBundleURL_error(bundlePath: NSURL, error: NSError): boolean;
  bundleAtURLIsCodeSigned(bundlePath: NSURL): boolean;

}

interface SUDSAVerifierAllocator<InitializedType = SUDSAVerifier> extends NSObjectAllocator<SUDSAVerifier> {
  initWithPublicKeyData(data: NSData): InitializedType;
}
interface SUDSAVerifier extends NSObject {
  verifyFileAtPath_signature(path: NSString | string, signature: NSData): boolean;
  verifyStream_signature(stream: NSInputStream, signature: NSData): boolean;
}
declare const SUDSAVerifier: {
  alloc(): SUDSAVerifierAllocator;  validatePath_withEncodedDSASignature_withPublicDSAKey(path: NSString | string, encodedSignature: NSString | string, pkeyString: NSString | string): boolean;

}

interface SUDiskImageUnarchiverAllocator<InitializedType = SUDiskImageUnarchiver> extends NSObjectAllocator<SUDiskImageUnarchiver> {
  initWithArchivePath_decryptionPassword(archivePath: NSString | string, decryptionPassword: NSString | string | null): InitializedType;
}
interface SUDiskImageUnarchiver extends NSObject, ISUUnarchiverProtocol {
}
declare const SUDiskImageUnarchiver: {
  alloc(): SUDiskImageUnarchiverAllocator;
}

declare enum SUError {
  SUAppcastParseError = 1000,
  SUNoUpdateError = 1001,
  SUAppcastError = 1002,
  SURunningFromDiskImageError = 1003,
  SUTemporaryDirectoryError = 2000,
  SUDownloadError = 2001,
  SUUnarchivingError = 3000,
  SUSignatureError = 3001,
  SUFileCopyFailure = 4000,
  SUAuthenticationFailure = 4001,
  SUMissingUpdateError = 4002,
  SUMissingInstallerToolError = 4003,
  SURelaunchError = 4004,
  SUInstallationError = 4005,
  SUDowngradeError = 4006,
  SUInstallationCancelledError = 4007,
  SUSystemPowerOffError = 5000,
}

interface SUFileManagerAllocator<InitializedType = SUFileManager> extends NSObjectAllocator<SUFileManager> {}
interface SUFileManager extends NSObject {
  fileManagerByPreservingAuthorizationRights(): SUFileManager;
  makeTemporaryDirectoryWithPreferredName_appropriateForDirectoryURL_error(preferredName: NSString | string, appropriateURL: NSURL, error: NSError): NSURL;
  makeDirectoryAtURL_error(targetURL: NSURL, error: NSError): boolean;
  moveItemAtURL_toURL_error(sourceURL: NSURL, destinationURL: NSURL, error: NSError): boolean;
  copyItemAtURL_toURL_error(sourceURL: NSURL, destinationURL: NSURL, error: NSError): boolean;
  removeItemAtURL_error(url: NSURL, error: NSError): boolean;
  changeOwnerAndGroupOfItemAtRootURL_toMatchURL_error(targetURL: NSURL, matchURL: NSURL, error: NSError): boolean;
  updateModificationAndAccessTimeOfItemAtURL_error(targetURL: NSURL, error: NSError): boolean;
  releaseItemFromQuarantineAtRootURL_error(rootURL: NSURL, error: NSError): boolean;
  executePackageAtURL_progressBlock_error(packageURL: NSURL, progressBlock: Block | null, error: NSError): boolean;
  _acquireAuthorizationWithError(error: NSError): boolean;
  _itemExistsAtURL(fileURL: NSURL): boolean;
  _itemExistsAtURL_isDirectory(fileURL: NSURL, isDirectory: boolean | null): boolean;
}
declare const SUFileManager: {
  alloc(): SUFileManagerAllocator;  defaultManager(): SUFileManager;
  fileManagerWithAuthorizationToolPath(authorizationToolPath: NSString | string): SUFileManager;

}

interface SUGuidedPackageInstallerAllocator<InitializedType = SUGuidedPackageInstaller> extends NSObjectAllocator<SUGuidedPackageInstaller> {
  initWithPackagePath_installationPath_fileOperationToolPath(packagePath: NSString | string, installationPath: NSString | string, fileOperationToolPath: NSString | string): InitializedType;
}
interface SUGuidedPackageInstaller extends NSObject, ISUInstallerProtocol {
}
declare const SUGuidedPackageInstaller: {
  alloc(): SUGuidedPackageInstallerAllocator;
}

interface SUHostAllocator<InitializedType = SUHost> extends NSObjectAllocator<SUHost> {
  initWithBundle(aBundle: NSBundle): InitializedType;
}
interface SUHost extends NSObject {
  objectForInfoDictionaryKey(key: NSString | string): any;
  boolForInfoDictionaryKey(key: NSString | string): boolean;
  objectForUserDefaultsKey(defaultName: NSString | string): any;
  setObject_forUserDefaultsKey(value: any, defaultName: NSString | string): void;
  boolForUserDefaultsKey(defaultName: NSString | string): boolean;
  setBool_forUserDefaultsKey(value: boolean, defaultName: NSString | string): void;
  objectForKey(key: NSString | string): any;
  boolForKey(key: NSString | string): boolean;

  bundle(): NSBundle;
  bundlePath(): NSString;
  name(): NSString;
  version(): NSString;
  displayVersion(): NSString;
  runningOnReadOnlyVolume(): boolean;
  publicDSAKey(): NSString;
  publicDSAKeyFileKey(): NSString;
}
declare const SUHost: {
  alloc(): SUHostAllocator;
}

interface SUInstallerAllocator<InitializedType = SUInstaller> extends NSObjectAllocator<SUInstaller> {}
interface SUInstaller extends NSObject {
}
declare const SUInstaller: {
  alloc(): SUInstallerAllocator;  installerForHost_fileOperationToolPath_updateDirectory_error(host: SUHost, fileOperationToolPath: NSString | string, updateDirectory: NSString | string, error: NSError): any;
  installSourcePathInUpdateFolder_forHost_isPackage_isGuided(inUpdateFolder: NSString | string, host: SUHost, isPackagePtr: boolean, isGuidedPtr: boolean | null): NSString;

}

interface ISUInstallerProtocol {
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
}

declare enum SULogLevel {
  SULogLevelDefault,
  SULogLevelError,
}

interface SUOperatingSystemAllocator<InitializedType = SUOperatingSystem> extends NSObjectAllocator<SUOperatingSystem> {}
interface SUOperatingSystem extends NSObject {
}
declare const SUOperatingSystem: {
  alloc(): SUOperatingSystemAllocator;  operatingSystemVersion(): NSOperatingSystemVersion;
  isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
  systemVersionString(): NSString;

}

interface SUPackageInstallerAllocator<InitializedType = SUPackageInstaller> extends NSObjectAllocator<SUPackageInstaller> {
  initWithPackagePath_installationPath(packagePath: NSString | string, installationPath: NSString | string): InitializedType;
}
interface SUPackageInstaller extends NSObject, ISUInstallerProtocol {
}
declare const SUPackageInstaller: {
  alloc(): SUPackageInstallerAllocator;
}

interface SUPipedUnarchiverAllocator<InitializedType = SUPipedUnarchiver> extends NSObjectAllocator<SUPipedUnarchiver> {
  initWithArchivePath(archivePath: NSString | string): InitializedType;
}
interface SUPipedUnarchiver extends NSObject, ISUUnarchiverProtocol {
}
declare const SUPipedUnarchiver: {
  alloc(): SUPipedUnarchiverAllocator;
}

interface SUPlainInstallerAllocator<InitializedType = SUPlainInstaller> extends NSObjectAllocator<SUPlainInstaller> {
  initWithHost_bundlePath_installationPath_fileOperationToolPath(host: SUHost, bundlePath: NSString | string, installationPath: NSString | string, fileOperationToolPath: NSString | string): InitializedType;
}
interface SUPlainInstaller extends NSObject, ISUInstallerProtocol {
}
declare const SUPlainInstaller: {
  alloc(): SUPlainInstallerAllocator;
}

interface SUProbingUpdateDriverAllocator<InitializedType = SUProbingUpdateDriver> extends SUBasicUpdateDriverAllocator<SUProbingUpdateDriver> {}
interface SUProbingUpdateDriver extends SUBasicUpdateDriver {
}
declare const SUProbingUpdateDriver: {
  alloc(): SUProbingUpdateDriverAllocator;
}

interface SUScheduledUpdateDriverAllocator<InitializedType = SUScheduledUpdateDriver> extends SUUIBasedUpdateDriverAllocator<SUScheduledUpdateDriver> {}
interface SUScheduledUpdateDriver extends SUUIBasedUpdateDriver {
}
declare const SUScheduledUpdateDriver: {
  alloc(): SUScheduledUpdateDriverAllocator;
}

interface SUStandardVersionComparatorAllocator<InitializedType = SUStandardVersionComparator> extends NSObjectAllocator<SUStandardVersionComparator> {
  init(): InitializedType;
}
interface SUStandardVersionComparator extends NSObject, ISUVersionComparison {
  compareVersion_toVersion(versionA: NSString | string, versionB: NSString | string): NSComparisonResult;
}
declare const SUStandardVersionComparator: {
  alloc(): SUStandardVersionComparatorAllocator;  defaultComparator(): SUStandardVersionComparator;

}

interface SUStatusControllerAllocator<InitializedType = SUStatusController> extends NSWindowControllerAllocator<SUStatusController> {
  initWithHost(host: SUHost): InitializedType;
}
interface SUStatusController extends NSWindowController {
  beginActionWithTitle_maxProgressValue_statusText(title: NSString | string, maxProgressValue: number, statusText: NSString | string): void;
  setButtonTitle_target_action_isDefault(buttonTitle: NSString | string, target: any, action: string, isDefault: boolean): void;

  actionButton(): NSButton;
  setActionButton(actionButton: NSButton): void;
  progressBar(): NSProgressIndicator;
  setProgressBar(progressBar: NSProgressIndicator): void;
  statusTextField(): NSTextField;
  setStatusTextField(statusTextField: NSTextField): void;
  statusText(): NSString;
  setStatusText(statusText: NSString | string): void;
  progressValue(): number;
  setProgressValue(progressValue: number): void;
  maxProgressValue(): number;
  setMaxProgressValue(maxProgressValue: number): void;
  buttonEnabled(): boolean;
  setButtonEnabled(buttonEnabled: boolean): void;
}
declare const SUStatusController: {
  alloc(): SUStatusControllerAllocator;
}

interface SUSystemProfilerAllocator<InitializedType = SUSystemProfiler> extends NSObjectAllocator<SUSystemProfiler> {}
interface SUSystemProfiler extends NSObject {
}
declare const SUSystemProfiler: {
  alloc(): SUSystemProfilerAllocator;  systemProfileArrayForHost(host: SUHost): NSArray<any>;

}

interface SUSystemUpdateInfoAllocator<InitializedType = SUSystemUpdateInfo> extends NSObjectAllocator<SUSystemUpdateInfo> {}
interface SUSystemUpdateInfo extends NSObject {
}
declare const SUSystemUpdateInfo: {
  alloc(): SUSystemUpdateInfoAllocator;  systemAllowsAutomaticUpdatesForHost(host: SUHost): boolean;

}

interface SUTouchBarButtonGroupAllocator<InitializedType = SUTouchBarButtonGroup> extends NSViewControllerAllocator<SUTouchBarButtonGroup> {
  initByReferencingButtons(buttons: NSArray<any> | any[]): InitializedType;
}
interface SUTouchBarButtonGroup extends NSViewController {

  buttons(): NSArray<any>;
}
declare const SUTouchBarButtonGroup: {
  alloc(): SUTouchBarButtonGroupAllocator;
}

interface SUUIBasedUpdateDriverAllocator<InitializedType = SUUIBasedUpdateDriver> extends SUBasicUpdateDriverAllocator<SUUIBasedUpdateDriver> {}
interface SUUIBasedUpdateDriver extends SUBasicUpdateDriver {
  showAlert(alert: NSAlert): void;
  cancelDownload(sender: any): IBAction;
  installAndRestart(sender: any): void;

  showErrors(): boolean;
  setShowErrors(showErrors: boolean): void;
}
declare const SUUIBasedUpdateDriver: {
  alloc(): SUUIBasedUpdateDriverAllocator;
}

interface SUUnarchiverAllocator<InitializedType = SUUnarchiver> extends NSObjectAllocator<SUUnarchiver> {}
interface SUUnarchiver extends NSObject {
}
declare const SUUnarchiver: {
  alloc(): SUUnarchiverAllocator;  unarchiverForPath_updatingHostBundlePath_decryptionPassword(path: NSString | string, hostPath: NSString | string | null, decryptionPassword: NSString | string | null): any;

}

interface SUUnarchiverNotifierAllocator<InitializedType = SUUnarchiverNotifier> extends NSObjectAllocator<SUUnarchiverNotifier> {
  initWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): InitializedType;
}
interface SUUnarchiverNotifier extends NSObject {
  notifySuccess(): void;
  notifyFailureWithError(reason: NSError): void;
  notifyProgress(progress: number): void;
}
declare const SUUnarchiverNotifier: {
  alloc(): SUUnarchiverNotifierAllocator;
}

interface ISUUnarchiverProtocol {
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
}

interface SUUpdateAlertAllocator<InitializedType = SUUpdateAlert> extends NSWindowControllerAllocator<SUUpdateAlert> {
  initWithAppcastItem_host_completionBlock(item: SUAppcastItem, host: SUHost, c: Block): InitializedType;
}
interface SUUpdateAlert extends NSWindowController {
  installUpdatesender(): IBAction;
  skipThisVersionsender(): IBAction;
  remindMeLatersender(): IBAction;
  disableKeyboardShortcutForInstallButton(): void;

  versionDisplayer(): any;
  setVersionDisplayer(versionDisplayer: any): void;
}
declare const SUUpdateAlert: {
  alloc(): SUUpdateAlertAllocator;
}

declare enum SUUpdateAlertChoice {
  SUInstallUpdateChoice,
  SURemindMeLaterChoice,
  SUSkipThisVersionChoice,
  SUOpenInfoURLChoice,
}

interface SUUpdateDriverAllocator<InitializedType = SUUpdateDriver> extends NSObjectAllocator<SUUpdateDriver> {
  initWithUpdater(updater: any): InitializedType;
}
interface SUUpdateDriver extends NSObject, INSURLDownloadDelegate {
  checkForUpdatesAtURL_host(URL: NSURL, host: SUHost): void;
  abortUpdate(): void;
  resumeUpdateInteractively(): boolean;
  showAlert(alert: NSAlert): void;

  updater(): SUUpdater;
  host(): SUHost;
  setHost(host: SUHost): void;
  interruptible(): boolean;
  finished(): boolean;
  downloadsAppcastInBackground(): boolean;
  downloadsUpdatesInBackground(): boolean;
  automaticallyInstallUpdates(): boolean;
  setAutomaticallyInstallUpdates(automaticallyInstallUpdates: boolean): void;
}
declare const SUUpdateDriver: {
  alloc(): SUUpdateDriverAllocator;
}

interface SUUpdatePermissionPromptAllocator<InitializedType = SUUpdatePermissionPrompt> extends NSWindowControllerAllocator<SUUpdatePermissionPrompt> {}
interface SUUpdatePermissionPrompt extends NSWindowController {
  toggleMoreInfo(sender: any): IBAction;
  finishPrompt(sender: any): IBAction;
}
declare const SUUpdatePermissionPrompt: {
  alloc(): SUUpdatePermissionPromptAllocator;  promptWithHost_systemProfile_reply(host: SUHost, profile: NSArray<any> | any[], reply: Block): void;

}

declare enum SUPermissionPromptResult {
  SUAutomaticallyCheck,
  SUDoNotAutomaticallyCheck,
}

interface SUUpdatePermissionResponseAllocator<InitializedType = SUUpdatePermissionResponse> extends NSObjectAllocator<SUUpdatePermissionResponse> {
  initWithAutomaticUpdateChecks_sendSystemProfile(automaticUpdateChecks: boolean, sendSystemProfile: boolean): InitializedType;
}
interface SUUpdatePermissionResponse extends NSObject {

  automaticUpdateChecks(): boolean;
  sendSystemProfile(): boolean;
}
declare const SUUpdatePermissionResponse: {
  alloc(): SUUpdatePermissionResponseAllocator;
}

interface SUUpdateValidatorAllocator<InitializedType = SUUpdateValidator> extends NSObjectAllocator<SUUpdateValidator> {
  initWithDownloadPath_dsaSignature_host_performingPrevalidation(downloadPath: NSString | string, dsaSignature: NSString | string, host: SUHost, performingPrevalidation: boolean): InitializedType;
}
interface SUUpdateValidator extends NSObject {
  validateWithUpdateDirectory(updateDirectory: NSString | string): boolean;

  canValidate(): boolean;
}
declare const SUUpdateValidator: {
  alloc(): SUUpdateValidatorAllocator;
}

interface SUUpdaterAllocator<InitializedType = SUUpdater> extends NSObjectAllocator<SUUpdater> {
  initForBundle(bundle: NSBundle): InitializedType;
}
interface SUUpdater extends NSObject {
  checkForUpdates(sender: any): IBAction;
  validateMenuItem(menuItem: NSMenuItem): boolean;
  checkForUpdatesInBackground(): void;
  checkForUpdateInformation(): void;
  installUpdatesIfAvailable(): void;
  resetUpdateCycle(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  automaticallyChecksForUpdates(): boolean;
  setAutomaticallyChecksForUpdates(automaticallyChecksForUpdates: boolean): void;
  automaticallyDownloadsUpdates(): boolean;
  setAutomaticallyDownloadsUpdates(automaticallyDownloadsUpdates: boolean): void;
  updateCheckInterval(): NSTimeInterval;
  setUpdateCheckInterval(updateCheckInterval: NSTimeInterval): void;
  feedURL(): NSURL;
  setFeedURL(feedURL: NSURL): void;
  hostBundle(): NSBundle;
  sparkleBundle(): NSBundle;
  userAgentString(): NSString;
  setUserAgentString(userAgentString: NSString | string): void;
  httpHeaders(): NSDictionary<any, any>;
  setHttpHeaders(httpHeaders: NSDictionary<any, any> | {[key: string]: any}): void;
  sendsSystemProfile(): boolean;
  setSendsSystemProfile(sendsSystemProfile: boolean): void;
  decryptionPassword(): NSString;
  setDecryptionPassword(decryptionPassword: NSString | string): void;
  lastUpdateCheckDate(): NSDate;
  updateInProgress(): boolean;
}
declare const SUUpdater: {
  alloc(): SUUpdaterAllocator;  sharedUpdater(): SUUpdater;
  updaterForBundle(bundle: NSBundle): SUUpdater;

}

interface SUUserInitiatedUpdateDriverAllocator<InitializedType = SUUserInitiatedUpdateDriver> extends SUUIBasedUpdateDriverAllocator<SUUserInitiatedUpdateDriver> {}
interface SUUserInitiatedUpdateDriver extends SUUIBasedUpdateDriver {
}
declare const SUUserInitiatedUpdateDriver: {
  alloc(): SUUserInitiatedUpdateDriverAllocator;
}

interface ISUVersionComparison {
  compareVersion_toVersion(versionA: NSString | string, versionB: NSString | string): NSComparisonResult;
}

interface ISUVersionDisplay {
  formatVersion_andVersion(inOutVersionA: NSString | string, inOutVersionB: NSString | string): void;
}

interface SUTestApplicationDelegateAllocator<InitializedType = SUTestApplicationDelegate> extends NSObjectAllocator<SUTestApplicationDelegate> {}
interface SUTestApplicationDelegate extends NSObject, INSApplicationDelegate {
}
declare const SUTestApplicationDelegate: {
  alloc(): SUTestApplicationDelegateAllocator;
}

interface SUTestWebServerAllocator<InitializedType = SUTestWebServer> extends NSObjectAllocator<SUTestWebServer> {
  initWithPort_workingDirectory(port: number, workingDirectory: NSString | string): InitializedType;
}
interface SUTestWebServer extends NSObject {
  close(): void;
}
declare const SUTestWebServer: {
  alloc(): SUTestWebServerAllocator;
}

interface SUUpdateSettingsWindowControllerAllocator<InitializedType = SUUpdateSettingsWindowController> extends NSWindowControllerAllocator<SUUpdateSettingsWindowController> {}
interface SUUpdateSettingsWindowController extends NSWindowController {
}
declare const SUUpdateSettingsWindowController: {
  alloc(): SUUpdateSettingsWindowControllerAllocator;
}

interface TestFlightAllocator<InitializedType = TestFlight> extends NSObjectAllocator<TestFlight> {}
interface TestFlight extends NSObject {
}
declare const TestFlight: {
  alloc(): TestFlightAllocator;  manuallyStartSession(): void;
  manuallyEndSession(): void;
  addCustomEnvironmentInformation_forKey(information: NSString | string, key: NSString | string): void;
  takeOff(applicationToken: NSString | string): void;
  setOptions(options: NSDictionary<any, any> | {[key: string]: any}): void;
  passCheckpoint(checkpointName: NSString | string): void;
  submitFeedback(feedback: NSString | string): void;

}

interface BCBooleanViewAllocator<InitializedType = BCBooleanView> extends NSViewAllocator<BCBooleanView> {}
interface BCBooleanView extends NSView, INSTableViewDataSource, INSTableViewDelegate, INSPathControlDelegate {
  onPathControl(sender: any): IBAction;
  onZoom(sender: any): IBAction;
  onDebugIntersections(sender: any): IBAction;
  onDebugCrossings(sender: any): IBAction;
  onDebugLeftContainment(sender: any): IBAction;
  onDebugRightContainment(sender: any): IBAction;
  onDebugOperation(sender: any): IBAction;
  onDebugCrossingContainment(sender: any): IBAction;
  onDebugCrossingContainmentIntersection(sender: any): IBAction;
  onDebugWhyIntersectionIsntExternalCrossing(sender: any): IBAction;
  onDebugCrossingContainmentRayWithEdge(sender: any): IBAction;
  onShowIntersectionType(sender: any): IBAction;
  onShowOverlaps(sender: any): IBAction;
  onShowContainmentRays(sender: any): IBAction;
  onShowWindingRuleContainmentRays(sender: any): IBAction;
  onShowCrossingContainmentRays(sender: any): IBAction;
  onShowExpandedXor(sender: any): IBAction;
  onShowContourJoints(sender: any): IBAction;
  onShowSuspiciousSelfCrossings(sender: any): IBAction;
  onShowWindingRuleContainmentRaysForSelection(sender: any): IBAction;
  onConvertToXor(sender: any): IBAction;
  onToggleAnimation(sender: any): IBAction;
  onPrescale(sender: any): IBAction;

  examplesTableView(): NSTableView;
  setExamplesTableView(examplesTableView: NSTableView): void;
  examplesPathControl(): NSPathControl;
  setExamplesPathControl(examplesPathControl: NSPathControl): void;
}
declare const BCBooleanView: {
  alloc(): BCBooleanViewAllocator;
}

interface FBBezierContourAllocator<InitializedType = FBBezierContour> extends NSObjectAllocator<FBBezierContour> {}
interface FBBezierContour extends NSObject, INSCopying {
  addCurve(curve: FBBezierCurve): void;
  addCurveFrom_to(startCrossing: FBEdgeCrossing, endCrossing: FBEdgeCrossing): void;
  addReverseCurve(curve: FBBezierCurve): void;
  addReverseCurveFrom_to(startCrossing: FBEdgeCrossing, endCrossing: FBEdgeCrossing): void;
  intersectionsWithRay_withBlock(testEdge: FBBezierCurve, block: Block): void;
  numberOfIntersectionsWithRay(testEdge: FBBezierCurve): NSUInteger;
  containsPoint(point: FBPoint): boolean;
  markCrossingsAsEntryOrExitWithContour_markInside(otherContour: FBBezierContour, markInside: boolean): void;
  containsPointUsingNonZeroWindingRule(point: FBPoint): boolean;
  containsCrossingUsingNonZeroWindingRule(testIntersection: FBBezierIntersection): boolean;
  bezierPath(): FBBezierPath;
  close(): void;
  bezierPathFromEdge_toEdge(curve1: FBBezierCurve, curve2: FBBezierCurve): FBBezierPath;
  reversedContour(): FBBezierContour;
  contourMadeClockwiseIfNecessary(): FBBezierContour;
  contourWithTransform(t: CGAffineTransform): FBBezierContour;
  contourByMergingLinearRuns(): FBBezierContour;
  addOverlap(overlap: FBContourOverlap): void;
  removeAllOverlaps(): void;
  isEquivalent(other: FBBezierContour): boolean;
  startEdge(): FBBezierCurve;
  testRayForContainment(bounds: FBRect): FBBezierCurve;
  closestLocationToPoint(point: FBPoint): FBCurveLocation;
  clone(): FBBezierContour;
  crossesOwnContour(contour: FBBezierContour): boolean;
  contourWithFlatness(flatness: CGFloat): FBBezierContour;
  markSelfCrossingsAsEntryOrExit(): void;
  sortCoincidentCrossings(): void;
  crossingContainmentRay(testPoint: FBPoint): FBBezierCurve;
  debugPathForIntersectionType_withTransform_andSizeTransform(itersectionType: NSInteger, transform: CGAffineTransform, sizeTransform: CGAffineTransform): FBBezierPath;
  debugPathForJointsWithTransform_andSizeTransform(transform: CGAffineTransform, sizeTransform: CGAffineTransform): FBBezierPath;
  debugPathForContainmentOfCrossing_transform(testIntersection: FBBezierIntersection, transform: CGAffineTransform): FBBezierPath;
  debugPathForWindingRuleContainmentWithTransform_andSizeTransform(transform: CGAffineTransform, sizeTransform: CGAffineTransform): FBBezierPath;
  forEachEdgeOverlapDo(block: Block): void;
  doesOverlapContainCrossing(crossing: FBEdgeCrossing): boolean;
  doesOverlapContainParameter_onEdge(parameter: FBFloat, edge: FBBezierCurve): boolean;
  debugDrawColor_scale(color: NSColor, scale: CGFloat): void;

  edges(): NSArray<any>;
  nonPointEdges(): NSArray<any>;
  bounds(): FBRect;
  boundingRect(): FBRect;
  firstPoint(): FBPoint;
  inside(): FBContourInside;
  setInside(inside: FBContourInside): void;
  intersectingContours(): NSArray<any>;
  isEmpty(): boolean;
  isClosed(): boolean;
  direction(): FBContourDirection;
  CGPath(): CGPathRef;
  overlaps(): NSArray<any>;
  crossings(): NSArray<any>;
}
declare const FBBezierContour: {
  alloc(): FBBezierContourAllocator;  bezierContourWithCurve(curve: FBBezierCurve): FBBezierContour;

}

declare enum FBContourDirection {
  FBContourClockwise,
  FBContourAntiClockwise,
}

interface FBBezierCurveAllocator<InitializedType = FBBezierCurve> extends NSObjectAllocator<FBBezierCurve> {
  initWithEndPoint1_controlPoint1_controlPoint2_endPoint2_contour(endPoint1: FBPoint, controlPoint1: FBPoint, controlPoint2: FBPoint, endPoint2: FBPoint, contour: FBBezierContour): InitializedType;
  initWithLineStartPoint_endPoint_contour(startPoint: FBPoint, endPoint: FBPoint, contour: FBBezierContour): InitializedType;
}
interface FBBezierCurve extends NSObject {
  checkForLine(): void;
  doesHaveIntersectionsWithBezierCurve(curve: FBBezierCurve): boolean;
  intersectionsWithBezierCurve_overlapRange_withBlock(curve: FBBezierCurve, intersectRange: FBBezierIntersectRange, block: FBCurveIntersectionBlock): void;
  pointAtParameter(parameter: FBFloat): FBPoint;
  pointAtParameter_leftBezierCurve_rightBezierCurve(parameter: FBFloat, leftBezierCurve: FBBezierCurve, rightBezierCurve: FBBezierCurve): FBPoint;
  subcurveWithRange(range: FBRange): FBBezierCurve;
  splitSubcurvesWithRange_left_middle_right(range: FBRange, leftCurve: FBBezierCurve, middleCurve: FBBezierCurve, rightCurve: FBBezierCurve): void;
  lengthAtParameter(parameter: FBFloat): FBFloat;
  length(): FBFloat;
  pointFromRightOffset(offset: FBFloat): FBPoint;
  pointFromLeftOffset(offset: FBFloat): FBPoint;
  tangentFromRightOffset(offset: FBFloat): FBPoint;
  tangentFromLeftOffset(offset: FBFloat): FBPoint;
  tangentAtParameter(parameter: FBFloat): FBPoint;
  closestLocationToPoint(point: FBPoint): FBBezierCurveLocation;
  reversedCurve(): FBBezierCurve;
  curveWithTransform(t: CGAffineTransform): FBBezierCurve;
  bezierPath(): FBBezierPath;
  clone(): FBBezierCurve;
  edgesWithFlatness(flatness: CGFloat): NSArray<any>;
  mightIntersectWith(curve: FBBezierCurve): boolean;
  firstCrossingUsingNonself(useNonself: boolean): FBEdgeCrossing;
  lastCrossingUsingNonself(useNonself: boolean): FBEdgeCrossing;
  hasCrossingsUsingNonself(useNonself: boolean): boolean;
  crossingsWithBlock(block: Block): void;
  crossingsCopyWithBlock(block: Block): void;
  removeCrossingsInNonCrossingOverlapRuns(): void;
  nextCrossing(crossing: FBEdgeCrossing): FBEdgeCrossing;
  previousCrossing(crossing: FBEdgeCrossing): FBEdgeCrossing;
  intersectingEdgesWithBlock(block: Block): void;
  selfIntersectingEdgesWithBlock(block: Block): void;
  addCrossing(crossing: FBEdgeCrossing): void;
  removeCrossing(crossing: FBEdgeCrossing): void;
  removeDuplicateCrossings(): void;
  removeAllCrossings(): void;
  reorderCoincidentCrossingA_crossingB(crossingA: FBEdgeCrossing, crossingB: FBEdgeCrossing): void;
  crossesEdge_atIntersection(edge2: FBBezierCurve, intersection: FBBezierIntersection): boolean;
  crossesEdge_atIntersectRange(edge2: FBBezierCurve, intersectRange: FBBezierIntersectRange): boolean;
  isNext(other: FBBezierCurve): boolean;
  debugDrawColor_controlPointColor_scale(color: NSColor, controlPointColor: NSColor, scale: CGFloat): void;

  endPoint1(): FBPoint;
  controlPoint1(): FBPoint;
  controlPoint2(): FBPoint;
  endPoint2(): FBPoint;
  isStraightLine(): boolean;
  bounds(): FBRect;
  boundingRect(): FBRect;
  flatness(): FBFloat;
  point(): boolean;
  isPointOrHorizontalLine(): boolean;
  isStartHorizontal(): boolean;
  isEndHorizontal(): boolean;
  isHorizontalLine(): boolean;
  looksLikeLine(): boolean;
  contour(): FBBezierContour;
  setContour(contour: FBBezierContour): void;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
  startShared(): boolean;
  setStartShared(startShared: boolean): void;
  next(): FBBezierCurve;
  previous(): FBBezierCurve;
  nextNonpoint(): FBBezierCurve;
  previousNonpoint(): FBBezierCurve;
  nextNonpointNonHorizontalLine(): FBBezierCurve;
  previousNonpointNonHorizontalLine(): FBBezierCurve;
  firstCrossing(): FBEdgeCrossing;
  lastCrossing(): FBEdgeCrossing;
  crossings(): NSArray<any>;
  hasCrossings(): boolean;
}
declare const FBBezierCurve: {
  alloc(): FBBezierCurveAllocator;  bezierCurvesFromBezierPath(path: FBBezierPath): NSArray<any>;
  bezierCurveWithLineStartPoint_endPoint(startPoint: FBPoint, endPoint: FBPoint): FBBezierCurve;
  bezierCurveWithEndPoint1_controlPoint1_controlPoint2_endPoint2(endPoint1: FBPoint, controlPoint1: FBPoint, controlPoint2: FBPoint, endPoint2: FBPoint): FBBezierCurve;

}

declare type FBBezierCurveLocation = {
  parameter: FBFloat
  distance: FBFloat
}

interface FBBezierGraphAllocator<InitializedType = FBBezierGraph> extends NSObjectAllocator<FBBezierGraph> {
  initWithBezierPath(path: FBBezierPath): InitializedType;
}
interface FBBezierGraph extends NSObject {
  unionWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  intersectWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  differenceWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  xorWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  noneWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  bezierPath(): FBBezierPath;
  bezierPathWithClass(bezierClass: any): any;
  closestLocationToPoint(point: FBPoint): FBCurveLocation;
  closestCrossingToPoint(point: FBPoint): FBEdgeCrossing;
  convertToNoneZeroWindingRule(): FBBezierGraph;
  convertToEvenOddWindingRule(): FBBezierGraph;
  bezierGraphBySplittingSelfCrossingContours(singleCrossingContoursOut: NSMutableArray<any> | any[]): FBBezierGraph;
  bezierGraphByTrimmingSelfCrossingContours(): FBBezierGraph;
  bezierGraphWithTransform(t: CGAffineTransform): FBBezierGraph;
  bezierGraphByMergingLinearRunsInContours(): FBBezierGraph;
  bezierGraphWithClockwiseFillsAnticlockwiseHoles(): FBBezierGraph;
  containmentResultForContour(testContour: FBBezierContour): FBContainmentResult;
  debuggingInsertCrossingsForUnionWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertCrossingsForIntersectWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertCrossingsForDifferenceWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertIntersectionsWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertCrossingsForFillConversion(): void;
  debugPathForContainmentOfContour(contour: FBBezierContour): FBBezierPath;
  debugPathForContainmentOfContour_transform(testContour: FBBezierContour, transform: CGAffineTransform): FBBezierPath;
  debugPathForJointsOfContour(testContour: FBBezierContour): FBBezierPath;
  debugFindCurvesThatShouldIntersectWith_withBlock(otherGraph: FBBezierGraph, block: Block): void;

  nonEmptyContours(): NSArray<any>;
  contours(): NSArray<any>;
  bounds(): FBRect;
  CGPath(): CGPathRef;
}
declare const FBBezierGraph: {
  alloc(): FBBezierGraphAllocator;  bezierGraph(): FBBezierGraph;
  bezierGraphWithCGPath(path: CGPathRef): FBBezierGraph;
  bezierGraphWithBezierPath(path: FBBezierPath): FBBezierGraph;
  bezierGraphWithContours(contours: NSArray<any> | any[]): FBBezierGraph;

}

interface FBBezierIntersectRangeAllocator<InitializedType = FBBezierIntersectRange> extends NSObjectAllocator<FBBezierIntersectRange> {
  initWithCurve1_parameterRange1_curve2_parameterRange2_reversed(curve1: FBBezierCurve, parameterRange1: FBRange, curve2: FBBezierCurve, parameterRange2: FBRange, reversed: boolean): InitializedType;
}
interface FBBezierIntersectRange extends NSObject {
  merge(other: FBBezierIntersectRange): void;
  flip(): FBBezierIntersectRange;

  curve1(): FBBezierCurve;
  parameterRange1(): FBRange;
  curve1LeftBezier(): FBBezierCurve;
  curve1RightBezier(): FBBezierCurve;
  curve1OverlappingBezier(): FBBezierCurve;
  curve2(): FBBezierCurve;
  parameterRange2(): FBRange;
  reversed(): boolean;
  curve2LeftBezier(): FBBezierCurve;
  curve2RightBezier(): FBBezierCurve;
  curve2OverlappingBezier(): FBBezierCurve;
  startIntersection(): FBBezierIntersection;
  middleIntersection(): FBBezierIntersection;
  stopIntersection(): FBBezierIntersection;
  atStartOfCurve1(): boolean;
  atStopOfCurve1(): boolean;
  atStartOfCurve2(): boolean;
  atStopOfCurve2(): boolean;
}
declare const FBBezierIntersectRange: {
  alloc(): FBBezierIntersectRangeAllocator;  intersectRangeWithCurve1_parameterRange1_curve2_parameterRange2_reversed(curve1: FBBezierCurve, parameterRange1: FBRange, curve2: FBBezierCurve, parameterRange2: FBRange, reversed: boolean): FBBezierIntersectRange;

}

interface FBBezierIntersectionAllocator<InitializedType = FBBezierIntersection> extends NSObjectAllocator<FBBezierIntersection> {
  initWithCurve1_parameter1_curve2_parameter2(curve1: FBBezierCurve, parameter1: FBFloat, curve2: FBBezierCurve, parameter2: FBFloat): InitializedType;
}
interface FBBezierIntersection extends NSObject {
  enumerateAliasesWithBlock(block: Block): void;
  curve1Direction(): FBPoint;
  curve2Direction(): FBPoint;
  curve1WindingCount(): NSInteger;
  curve2WindingCount(): NSInteger;

  location(): FBPoint;
  curve1(): FBBezierCurve;
  parameter1(): FBFloat;
  curve2(): FBBezierCurve;
  parameter2(): FBFloat;
  tangent(): boolean;
  curve1LeftBezier(): FBBezierCurve;
  curve1RightBezier(): FBBezierCurve;
  curve2LeftBezier(): FBBezierCurve;
  curve2RightBezier(): FBBezierCurve;
  atStartOfCurve1(): boolean;
  atStopOfCurve1(): boolean;
  atStartOfCurve2(): boolean;
  atStopOfCurve2(): boolean;
  isAtExactStartOfCurve1(): boolean;
  isAtExactStopOfCurve1(): boolean;
  isAtExactStartOfCurve2(): boolean;
  isAtExactStopOfCurve2(): boolean;
  atEndPointOfCurve1(): boolean;
  atEndPointOfCurve2(): boolean;
  atEndPointOfCurve(): boolean;
}
declare const FBBezierIntersection: {
  alloc(): FBBezierIntersectionAllocator;  intersectionWithCurve1_parameter1_curve2_parameter2(curve1: FBBezierCurve, parameter1: FBFloat, curve2: FBBezierCurve, parameter2: FBFloat): FBBezierIntersection;

}

interface FBBezierOperationChainAllocator<InitializedType = FBBezierOperationChain> extends NSObjectAllocator<FBBezierOperationChain> {
  initWithBezierPath(sourcePath: FBBezierPath): InitializedType;
  initWithData(data: NSData): InitializedType;
}
interface FBBezierOperationChain extends NSObject {
  appendBezierPath_withOperation(path: FBBezierPath, op: FBBezierPathOperation): void;
  archive(): NSData;
  saveWithName(name: NSString | string): void;
  enumerateWithBlock(block: Block): void;
}
declare const FBBezierOperationChain: {
  alloc(): FBBezierOperationChainAllocator;
}

declare type FBBezierPathElement = {
  type: FBPathElementType
  point: FBPoint
  controlPoints: [FBPoint, FBPoint]
}

declare enum FBBezierPathOperation {
  FBBezierPathOperationUnion = 0,
  FBBezierPathOperationDifference = 1,
  FBBezierPathOperationIntersect = 2,
  FBBezierPathOperationXor = 3,
}

interface FBContainmentResultAllocator<InitializedType = FBContainmentResult> extends NSObjectAllocator<FBContainmentResult> {
  initWithTestContour_inGraph_evenOddInside_nonZeroInside_testEdge_intersections(testContour: FBBezierContour, graph: FBBezierGraph, evenOdd: FBContourInside, nonZero: FBContourInside, testEdge: FBBezierCurve | null, intersections: NSArray<any> | any[]): InitializedType;
}
interface FBContainmentResult extends NSObject {

  evenOdd(): FBContourInside;
  nonZero(): FBContourInside;
  testEdge(): FBBezierCurve;
  intersections(): NSArray<any>;
  testContour(): FBBezierContour;
  graph(): FBBezierGraph;
  container(): FBBezierContour;
}
declare const FBContainmentResult: {
  alloc(): FBContainmentResultAllocator;
}

interface FBEdgeOverlapAllocator<InitializedType = FBEdgeOverlap> extends NSObjectAllocator<FBEdgeOverlap> {}
interface FBEdgeOverlap extends NSObject {

  range(): FBBezierIntersectRange;
  edge1(): FBBezierCurve;
  edge2(): FBBezierCurve;
}
declare const FBEdgeOverlap: {
  alloc(): FBEdgeOverlapAllocator;
}

interface FBEdgeOverlapRunAllocator<InitializedType = FBEdgeOverlapRun> extends NSObjectAllocator<FBEdgeOverlapRun> {}
interface FBEdgeOverlapRun extends NSObject {
  isCrossing(): boolean;
  isCrossingUsingNonZeroWindingRule(): boolean;
  removeCrossings(): void;
  addMiddleCrossing(): void;
  addStartCrossing(): void;
  addStopCrossing(): void;
  middleIntersection(): FBBezierIntersection;

  overlaps(): NSArray<any>;
  startIsInsideContour1(): boolean;
  stopIsInsideContour1(): boolean;
  startIsInsideContour2(): boolean;
  stopIsInsideContour2(): boolean;
  crossingType(): FBEdgeOverlapRunCrossingType;
}
declare const FBEdgeOverlapRun: {
  alloc(): FBEdgeOverlapRunAllocator;
}

interface FBContourOverlapAllocator<InitializedType = FBContourOverlap> extends NSObjectAllocator<FBContourOverlap> {}
interface FBContourOverlap extends NSObject {
  addOverlap_forEdge1_edge2(range: FBBezierIntersectRange, edge1: FBBezierCurve, edge2: FBBezierCurve): void;
  runsWithBlock(block: Block): void;
  reset(): void;
  isComplete(): boolean;
  isEmpty(): boolean;
  isBetweenContour_andContour(contour1: FBBezierContour, contour2: FBBezierContour): boolean;
  doesContainCrossing(crossing: FBEdgeCrossing): boolean;
  doesContainParameter_onEdge(parameter: FBFloat, edge: FBBezierCurve): boolean;

  contour1(): FBBezierContour;
  contour2(): FBBezierContour;
  overlapRuns(): NSArray<any>;
}
declare const FBContourOverlap: {
  alloc(): FBContourOverlapAllocator;  contourOverlap(): FBContourOverlap;

}

interface FBCurveLocationAllocator<InitializedType = FBCurveLocation> extends NSObjectAllocator<FBCurveLocation> {
  initWithEdge_parameter_distance(edge: FBBezierCurve, parameter: FBFloat, distance: FBFloat): InitializedType;
}
interface FBCurveLocation extends NSObject {

  graph(): FBBezierGraph;
  setGraph(graph: FBBezierGraph): void;
  contour(): FBBezierContour;
  setContour(contour: FBBezierContour): void;
  edge(): FBBezierCurve;
  parameter(): FBFloat;
  distance(): FBFloat;
}
declare const FBCurveLocation: {
  alloc(): FBCurveLocationAllocator;  curveLocationWithEdge_parameter_distance(edge: FBBezierCurve, parameter: FBFloat, distance: FBFloat): FBCurveLocation;

}

declare enum FBDebugIntersectionType {
  FBDebugIntersectionTypeNone,
  FBDebugIntersectionTypeEntry,
  FBDebugIntersectionTypeExit,
}

declare type FBDoublePoint = {
  x: FBDouble
  y: FBDouble
}

declare type FBDoubleSize = {
  width: FBDouble
  height: FBDouble
}

declare type FBDoubleRect = {
  origin: FBDoublePoint
  size: FBDoubleSize
}

declare type FBDouble = number

interface FBEdgeCrossingAllocator<InitializedType = FBEdgeCrossing> extends NSObjectAllocator<FBEdgeCrossing> {
  initWithIntersection(intersection: FBBezierIntersection): InitializedType;
}
interface FBEdgeCrossing extends NSObject {
  removeFromEdge(): void;
  isCoincidentWith(crossing: FBEdgeCrossing): boolean;
  nextUsingNonself(useNonself: boolean): FBEdgeCrossing;
  previousUsingNonself(useNonself: boolean): FBEdgeCrossing;
  isEqualToEdgeCrossing(crossing: FBEdgeCrossing): boolean;

  edge(): FBBezierCurve;
  setEdge(edge: FBBezierCurve): void;
  counterpart(): FBEdgeCrossing;
  setCounterpart(counterpart: FBEdgeCrossing): void;
  order(): FBFloat;
  entry(): boolean;
  setEntry(entry: boolean): void;
  processed(): boolean;
  setProcessed(processed: boolean): void;
  selfCrossing(): boolean;
  setSelfCrossing(selfCrossing: boolean): void;
  overlapRun(): FBEdgeOverlapRun;
  setOverlapRun(overlapRun: FBEdgeOverlapRun): void;
  fromCrossingOverlap(): boolean;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
  suspicious(): boolean;
  setSuspicious(suspicious: boolean): void;
  next(): FBEdgeCrossing;
  previous(): FBEdgeCrossing;
  parameter(): FBFloat;
  curve(): FBBezierCurve;
  leftCurve(): FBBezierCurve;
  rightCurve(): FBBezierCurve;
  atStart(): boolean;
  atEnd(): boolean;
  location(): FBPoint;
  intersection(): FBBezierIntersection;
}
declare const FBEdgeCrossing: {
  alloc(): FBEdgeCrossingAllocator;  crossingWithIntersection(intersection: FBBezierIntersection): FBEdgeCrossing;

}

declare type FBAngleRange = {
  minimum: FBFloat
  maximum: FBFloat
}

declare type FBRange = {
  minimum: FBFloat
  maximum: FBFloat
}

interface FBTangentIteratorAllocator<InitializedType = FBTangentIterator> extends NSObjectAllocator<FBTangentIterator> {
  initWithIntersection_onCurve(intersection: FBBezierIntersection, curve: FBBezierCurve): InitializedType;
}
interface FBTangentIterator extends NSObject {
  sync(other: FBTangentIterator): void;
  next(tangents: [FBPoint, FBPoint]): boolean;

  leftCurve(): FBBezierCurve;
  setLeftCurve(leftCurve: FBBezierCurve): void;
  rightCurve(): FBBezierCurve;
  setRightCurve(rightCurve: FBBezierCurve): void;
  offset(): FBFloat;
  setOffset(offset: FBFloat): void;
  offsetStep(): FBFloat;
  setOffsetStep(offsetStep: FBFloat): void;
  offsetMaximum(): FBFloat;
  setOffsetMaximum(offsetMaximum: FBFloat): void;
}
declare const FBTangentIterator: {
  alloc(): FBTangentIteratorAllocator;  tangentIteratorWithIntersection_onCurve(intersection: FBBezierIntersection, curve: FBBezierCurve): FBTangentIterator;

}

declare type FBPathElementType = any

declare enum FBContourInside {
  FBContourInsideFilled,
  FBContourInsideHole,
}

declare enum FBEdgeOverlapRunCrossingType {
  FBEdgeOverlapRunCrossingTypeUnknown = 0,
  FBEdgeOverlapRunCrossingTypeCrossing = 1<<1,
  FBEdgeOverlapRunCrossingTypeContainedByContour1 = 1<<2,
  FBEdgeOverlapRunCrossingTypeContainedByContour2 = 1<<3,
  FBEdgeOverlapRunCrossingTypeDisjoint = 1<<4,
  FBEdgeOverlapRunCrossingTypeContainedMask,
}

declare enum FBEdgeOverlapRunCrossingPosition {
  FBEdgeOverlapRunCrossingPositionMiddle,
  FBEdgeOverlapRunCrossingPositionInside,
  FBEdgeOverlapRunCrossingPositionOutside,
}

interface BrushAllocator<InitializedType = Brush> extends NSObjectAllocator<Brush> {}
interface Brush extends NSObject {
  mouseDown_inView_onCanvas(theEvent: NSEvent, view: NSView, canvas: Canvas): void;
  mouseDragged_inView_onCanvas(theEvent: NSEvent, view: NSView, canvas: Canvas): void;
  mouseUp_inView_onCanvas(theEvent: NSEvent, view: NSView, canvas: Canvas): void;
}
declare const Brush: {
  alloc(): BrushAllocator;
}

interface CanvasAllocator<InitializedType = Canvas> extends NSObjectAllocator<Canvas> {}
interface Canvas extends NSObject {
  beginPathAtLocation_withWidth_color(location: NSPoint, width: CGFloat, color: NSColor): void;
  extendPathToLocation(location: NSPoint): void;
  endPath(): void;
  drawRect(dirtyRect: NSRect): void;

  showPoints(): boolean;
  setShowPoints(showPoints: boolean): void;
  simplify(): boolean;
  setSimplify(simplify: boolean): void;
  fitCurve(): boolean;
  setFitCurve(fitCurve: boolean): void;
}
declare const Canvas: {
  alloc(): CanvasAllocator;
}

interface CanvasViewAllocator<InitializedType = CanvasView> extends NSViewAllocator<CanvasView> {}
interface CanvasView extends NSView {

  showPoints(): boolean;
  setShowPoints(showPoints: boolean): void;
  simplify(): boolean;
  setSimplify(simplify: boolean): void;
  fitCurve(): boolean;
  setFitCurve(fitCurve: boolean): void;
}
declare const CanvasView: {
  alloc(): CanvasViewAllocator;
}

interface MyDocumentAllocator<InitializedType = MyDocument> extends NSDocumentAllocator<MyDocument> {}
interface MyDocument extends NSDocument {
  toggleShowPoints(sender: any): IBAction;
  toggleSimplifyPath(sender: any): IBAction;
  toggleFitCurve(sender: any): IBAction;
}
declare const MyDocument: {
  alloc(): MyDocumentAllocator;
}

declare type NSBezierElement = {
  kind: NSBezierPathElement
  point: NSPoint
  controlPoints: [NSPoint, NSPoint]
}

interface AppControllerAllocator<InitializedType = AppController> extends NSObjectAllocator<AppController> {}
interface AppController extends NSObject, INSApplicationDelegate, INSWindowDelegate, INSMenuDelegate, INSUserNotificationCenterDelegate, IMSDataMenuProviderDelegate, IMSDataSupplierManagerDelegate {
  actionClasses(): NSArray<any>;
  runPluginCommandWithIdentifier_fromBundleAtURL_context(identifier: NSString | string, url: NSURL, context: NSDictionary<any, any> | {[key: string]: any}): NSString;
  runPluginCommandWithIdentifier_fromBundleAtURL_context_portToAsnwerTo(identifier: NSString | string, url: NSURL, context: NSDictionary<any, any> | {[key: string]: any}, port: NSString | string): NSString;
  revealPlugin(sender: any): IBAction;
  buildPluginsMenu(menu: NSMenu): void;
  runPluginCommand_fromMenu_context(command: MSPluginCommand, fromMenu: boolean, context: NSDictionary<any, any> | {[key: string]: any}): NSString;
  runPluginScript_name(script: NSString | string, name: NSString | string): NSString;
  runPluginScript_handler_name_withPreprocess(script: NSString | string, handler: NSString | string, name: NSString | string, shoulPreprocess: boolean): NSString;
  validatePluginMenuItem_documentShowing(menuItem: NSMenuItem, documentShowing: boolean): boolean;
  registerURLScheme(): void;
  checkDefaults(): void;
  openPreferencesWindowWithPreferencePaneIdentifier(identifier: NSString | string): void;
  openAboutWindow(sender: any): IBAction;
  revealTemplatesFolderInFinder(sender: any): IBAction;
  buy(sender: any): IBAction;
  refreshCurrentDocument(): void;
  currentDocumentDidChange(): void;
  refreshDocumentWindowBadges(): void;
  openTemplateAtPath(templateURL: NSURL): void;
  templateLibraryPath(): NSURL;
  toggleDarkMode(sender: any): IBAction;

  lastRun(): MSPluginCommand;
  shapesMenu(): any;
  setShapesMenu(shapesMenu: any): void;
  pluginsMenuItem(): NSMenuItem;
  setPluginsMenuItem(pluginsMenuItem: NSMenuItem): void;
  templatesMenu(): NSMenu;
  setTemplatesMenu(templatesMenu: NSMenu): void;
  printMenu(): NSMenu;
  setPrintMenu(printMenu: NSMenu): void;
  prototypingMenuItem(): NSMenuItem;
  setPrototypingMenuItem(prototypingMenuItem: NSMenuItem): void;
  debugMenuItem(): NSMenuItem;
  setDebugMenuItem(debugMenuItem: NSMenuItem): void;
  dataFeedMenuItem(): NSMenuItem;
  setDataFeedMenuItem(dataFeedMenuItem: NSMenuItem): void;
  cloudEnvironmentMenuItem(): NSMenuItem;
  setCloudEnvironmentMenuItem(cloudEnvironmentMenuItem: NSMenuItem): void;
  updateTimer(): NSTimer;
  setUpdateTimer(updateTimer: NSTimer): void;
  pasteboardManager(): MSPasteboardManager;
  setPasteboardManager(pasteboardManager: MSPasteboardManager): void;
  mirrorController(): SMKMirrorController;
  setMirrorController(mirrorController: SMKMirrorController): void;
  mirrorDataProvider(): MSMirrorDataProvider;
  setMirrorDataProvider(mirrorDataProvider: MSMirrorDataProvider): void;
  dataFeedProvider(): MSDataMenuProvider;
  dataSupplierManager(): MSDataSupplierManager;
  crashLogManager(): MSCrashLogManager;
  pluginManager(): MSPluginManagerWithActions;
  licenseManager(): BCLicenseManager;
  updateController(): MSUpdateController;
  actionController(): MSActionController;
  librariesController(): MSAssetLibraryController;
  hud(): MSHUDWindowController;
  creationTime(): NSTimeInterval;
  launchStartTime(): NSTimeInterval;
  launchEndTime(): NSTimeInterval;
  globalAssets(): MSPersistentAssetCollection;
  sketchSafeModeOn(): boolean;
  needToInformUserPluginsAreDisabled(): boolean;
  setNeedToInformUserPluginsAreDisabled(needToInformUserPluginsAreDisabled: boolean): void;
  canShowWelcomeWindowForUserAction(): boolean;
  canCreateDocuments(): boolean;
  setCanCreateDocuments(canCreateDocuments: boolean): void;
}
declare const AppController: {
  alloc(): AppControllerAllocator;  sharedInstance(): AppController;

}

interface BCBaseMagnifierButtonAllocator<InitializedType = BCBaseMagnifierButton> extends NSButtonAllocator<BCBaseMagnifierButton> {}
interface BCBaseMagnifierButton extends NSButton {
  color(): BCFlexibleColor;
  documentColorSpace(): NSColorSpace;
}
declare const BCBaseMagnifierButton: {
  alloc(): BCBaseMagnifierButtonAllocator;
}

interface BCFlexibleColorAllocator<InitializedType = BCFlexibleColor> extends NSObjectAllocator<BCFlexibleColor> {}
interface BCFlexibleColor extends NSObject {
  colorForColorSpace(space: NSColorSpace): NSColor;
}
declare const BCFlexibleColor: {
  alloc(): BCFlexibleColorAllocator;  colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): any;
  colorWithHue_sat_light_alpha(hue: CGFloat, sat: CGFloat, light: CGFloat, alpha: CGFloat): any;

}

interface BCFontSearchFieldAllocator<InitializedType = BCFontSearchField> extends NSSearchFieldAllocator<BCFontSearchField> {}
interface BCFontSearchField extends NSSearchField, INSTextViewDelegate {

  searchResults(): NSTableView;
  setSearchResults(searchResults: NSTableView): void;
}
declare const BCFontSearchField: {
  alloc(): BCFontSearchFieldAllocator;
}

interface BCHexTextFieldAllocator<InitializedType = BCHexTextField> extends NSTextFieldAllocator<BCHexTextField> {}
interface BCHexTextField extends NSTextField {
}
declare const BCHexTextField: {
  alloc(): BCHexTextFieldAllocator;
}

interface BCMagicWandAllocator<InitializedType = BCMagicWand> extends NSOperationAllocator<BCMagicWand> {}
interface BCMagicWand extends NSOperation {

  startPoint(): NSPoint;
  setStartPoint(startPoint: NSPoint): void;
  tolerance(): number;
  setTolerance(tolerance: number): void;
  bitmap(): NSBitmapImageRep;
  setBitmap(bitmap: NSBitmapImageRep): void;
}
declare const BCMagicWand: {
  alloc(): BCMagicWandAllocator;
}

interface BCMagnifierAllocator<InitializedType = BCMagnifier> extends NSObjectAllocator<BCMagnifier> {}
interface BCMagnifier extends NSObject {
}
declare const BCMagnifier: {
  alloc(): BCMagnifierAllocator;  pickColorInColorSpace_completionHandler(colorSpace: NSColorSpace, completionHandler: BCMagnifierCompletionBlock): void;

}

interface BCMagnifierWindowAllocator<InitializedType = BCMagnifierWindow> extends NSWindowAllocator<BCMagnifierWindow> {
  initWithScreenGrab_frameOffset(screenGrab: BCScreenGrab, offset: NSPoint): InitializedType;
}
interface BCMagnifierWindow extends NSWindow {
  updateScreenGrabIfNeeded(screenGrab: BCScreenGrab): void;
  mouseMovedTo(mousePoint: NSPoint): void;
  setCurrentColor(color: BCFlexibleColor): void;
  flagsChanged(): void;

  frameOffset(): NSPoint;
  screenFrame(): CGRect;
  setScreenFrame(screenFrame: CGRect): void;
}
declare const BCMagnifierWindow: {
  alloc(): BCMagnifierWindowAllocator;
}

interface BCMagnifierWindowContentViewAllocator<InitializedType = BCMagnifierWindowContentView> extends NSViewAllocator<BCMagnifierWindowContentView> {}
interface BCMagnifierWindowContentView extends NSView {

  screenGrab(): BCScreenGrab;
  setScreenGrab(screenGrab: BCScreenGrab): void;
  currentColor(): BCFlexibleColor;
  setCurrentColor(currentColor: BCFlexibleColor): void;
}
declare const BCMagnifierWindowContentView: {
  alloc(): BCMagnifierWindowContentViewAllocator;
}

interface BCScreenGrabAllocator<InitializedType = BCScreenGrab> extends NSObjectAllocator<BCScreenGrab> {}
interface BCScreenGrab extends NSObject {
  bitmapImageRepCroppingToRect(r: NSRect): NSBitmapImageRep;

  displayID(): CGDirectDisplayID;
  image(): NSImage;
  bitmapRep(): NSBitmapImageRep;
  imageOrigin(): NSPoint;
  isRetinaScreen(): boolean;
  colorSpace(): NSColorSpace;
  screenFrame(): NSRect;
}
declare const BCScreenGrab: {
  alloc(): BCScreenGrabAllocator;  screenGrabForDisplay_belowWindowWithID(displayID: CGDirectDisplayID, windowID: CGWindowID): BCScreenGrab;
  screenGrabWithBitmapImageRep_originOnScreen_colorSpace_displayID(bitmapRep: NSBitmapImageRep, screenOrigin: NSPoint, colorSpace: NSColorSpace, displayID: CGDirectDisplayID): BCScreenGrab;

}

interface BCSparkleLicensedUpdateCheckerAllocator<InitializedType = BCSparkleLicensedUpdateChecker> extends NSObjectAllocator<BCSparkleLicensedUpdateChecker> {}
interface BCSparkleLicensedUpdateChecker extends NSObject {

  numberOfUnavailableReleases(): NSUInteger;
  hasAvailableUpdates(): boolean;
  numberOfUpdatesRequiringRenewal(): NSUInteger;
  setNumberOfUpdatesRequiringRenewal(numberOfUpdatesRequiringRenewal: NSUInteger): void;
  numberOfUpdatesRequiringHostUpdate(): NSUInteger;
  setNumberOfUpdatesRequiringHostUpdate(numberOfUpdatesRequiringHostUpdate: NSUInteger): void;
  numberOfUpdatesRequiringHostUpdateAndRenewal(): NSUInteger;
  setNumberOfUpdatesRequiringHostUpdateAndRenewal(numberOfUpdatesRequiringHostUpdateAndRenewal: NSUInteger): void;
  latestUnavailableVersion(): NSString;
  latestUnavailableBuildNumber(): NSString;
  latestUnavailableVersionBeforeRenewing(): NSString;
  latestUnavailableBuildNumberBeforeRenewing(): NSString;
  latestUnavailableVersionBeforeUpdatingMac(): NSString;
  latestUnavailableBuildNumberBeforeUpdatingMac(): NSString;
  latestUnavailableVersionBeforeUpdatingMacAndRenewing(): NSString;
  latestUnavailableBuildNumberBeforeUpdatingMacAndRenewing(): NSString;
  indexOfBestUpdate(): NSUInteger;
}
declare const BCSparkleLicensedUpdateChecker: {
  alloc(): BCSparkleLicensedUpdateCheckerAllocator;  sparkleCheckerWithLicenseExpirationDate_buildNumber_appcastResults(date: NSDate, buildNumber: NSString | string, results: NSArray<any> | any[]): BCSparkleLicensedUpdateChecker;

}

interface CHPlainWhiteViewAllocator<InitializedType = CHPlainWhiteView> extends NSViewAllocator<CHPlainWhiteView> {}
interface CHPlainWhiteView extends NSView {

  displayString(): NSString;
  setDisplayString(displayString: NSString | string): void;
}
declare const CHPlainWhiteView: {
  alloc(): CHPlainWhiteViewAllocator;
}

interface CHWhiteViewAllocator<InitializedType = CHWhiteView> extends NSViewAllocator<CHWhiteView> {}
interface CHWhiteView extends NSView {
}
declare const CHWhiteView: {
  alloc(): CHWhiteViewAllocator;
}

interface CHLinedWhiteViewAllocator<InitializedType = CHLinedWhiteView> extends CHPlainWhiteViewAllocator<CHLinedWhiteView> {}
interface CHLinedWhiteView extends CHPlainWhiteView {
}
declare const CHLinedWhiteView: {
  alloc(): CHLinedWhiteViewAllocator;
}

interface BCAlphaColorPickerAllocator<InitializedType = BCAlphaColorPicker> extends BCColorPickerSliderViewAllocator<BCAlphaColorPicker> {}
interface BCAlphaColorPicker extends BCColorPickerSliderView {

  colorAlphaValue(): CGFloat;
  setColorAlphaValue(colorAlphaValue: CGFloat): void;
  color(): BCFlexibleColor;
  setColor(color: BCFlexibleColor): void;
}
declare const BCAlphaColorPicker: {
  alloc(): BCAlphaColorPickerAllocator;
}

interface BCColorPickerBaseViewAllocator<InitializedType = BCColorPickerBaseView> extends NSControlAllocator<BCColorPickerBaseView> {
  initInBounds(colorPickerBounds: NSRect): InitializedType;
}
interface BCColorPickerBaseView extends NSControl {
  drawContentInRect_dirtyRect(contentRect: NSRect, dirtyRect: NSRect): void;
  drawCheckerboardPatternInRect(rect: NSRect): void;
  drawMarkerInRect(rect: NSRect): void;
  contentBounds(): NSRect;
  markerShadow(): NSShadow;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  hideSelection(): boolean;
  setHideSelection(hideSelection: boolean): void;
}
declare const BCColorPickerBaseView: {
  alloc(): BCColorPickerBaseViewAllocator;  darkShadow(): NSShadow;
  drawFrameInRect_block(contentRect: NSRect, block: BCVoidBlock): void;

}

interface BCColorPickerSliderViewAllocator<InitializedType = BCColorPickerSliderView> extends BCColorPickerBaseViewAllocator<BCColorPickerSliderView> {}
interface BCColorPickerSliderView extends BCColorPickerBaseView {
  drawSelectionMarkerAtPosition(xPosition: NSInteger): void;
}
declare const BCColorPickerSliderView: {
  alloc(): BCColorPickerSliderViewAllocator;
}

interface BCColorPreviewAllocator<InitializedType = BCColorPreview> extends NSPopUpButtonAllocator<BCColorPreview> {
  initInBounds(colorPickerBounds: NSRect): InitializedType;
}
interface BCColorPreview extends NSPopUpButton, INSMenuDelegate {

  color(): BCFlexibleColor;
  setColor(color: BCFlexibleColor): void;
  frequentColors(): NSArray<any>;
  setFrequentColors(frequentColors: NSArray<any> | any[]): void;
}
declare const BCColorPreview: {
  alloc(): BCColorPreviewAllocator;  menuItemForColorCounter_target_action_documentColorSpace_useHSB(colorCounter: MSColorCounter, target: any, action: string, colorSpace: NSColorSpace, useHSB: boolean): NSMenuItem;
  shouldUseHSBInColorDescriptions(): boolean;

}

interface IBCColorPreviewDelegate {
  colorPreviewColorSpace(colorPreviewView: BCColorPreview): NSColorSpace;
}

interface BCHSBColorPickerAllocator<InitializedType = BCHSBColorPicker> extends NSControlAllocator<BCHSBColorPicker> {}
interface BCHSBColorPicker extends NSControl, IBCColorPreviewDelegate, IBCMagnifierButtonDelegate {
  setColor_multipleValues(color: MSColor, multiple: boolean): void;
  hueChanged(sender: BCHueColorPicker): IBAction;
  alphaChanged(sender: BCAlphaColorPicker): IBAction;
  saturationBrightnessChanged(sender: BCSaturationBrightnessColorPicker): IBAction;
  rgbComponentFieldsChanged(sender: NSTextField): IBAction;
  hslComponentFieldsChanged(sender: NSTextField): IBAction;
  hexValueFieldChanged(sender: any): IBAction;
  frequentColorPicked(sender: any): IBAction;
  setFrequentColors(frequentColors: NSArray<any> | any[]): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  color(): MSColor;
  setColor(color: MSColor): void;
  hexValueTextField(): NSTextField;
  setHexValueTextField(hexValueTextField: NSTextField): void;
  alphaComponentTextField(): NSTextField;
  setAlphaComponentTextField(alphaComponentTextField: NSTextField): void;
  separatorView(): MSColorInspectorSeparatorView;
  setSeparatorView(separatorView: MSColorInspectorSeparatorView): void;
}
declare const BCHSBColorPicker: {
  alloc(): BCHSBColorPickerAllocator;
}

interface IBCHSBColorPickerDelegate {
  hsbColorPickerDocumentColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
  hsbColorPickerPreviewColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
}

interface BCHueColorPickerAllocator<InitializedType = BCHueColorPicker> extends BCColorPickerSliderViewAllocator<BCHueColorPicker> {}
interface BCHueColorPicker extends BCColorPickerSliderView {

  hueValue(): CGFloat;
  setHueValue(hueValue: CGFloat): void;
}
declare const BCHueColorPicker: {
  alloc(): BCHueColorPickerAllocator;
}

interface BCMagnifierButtonAllocator<InitializedType = BCMagnifierButton> extends BCBaseMagnifierButtonAllocator<BCMagnifierButton> {}
interface BCMagnifierButton extends BCBaseMagnifierButton {

  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const BCMagnifierButton: {
  alloc(): BCMagnifierButtonAllocator;
}

interface BCMagnifierButtonCellAllocator<InitializedType = BCMagnifierButtonCell> extends NSButtonCellAllocator<BCMagnifierButtonCell> {}
interface BCMagnifierButtonCell extends NSButtonCell {
}
declare const BCMagnifierButtonCell: {
  alloc(): BCMagnifierButtonCellAllocator;
}

interface IBCMagnifierButtonDelegate {
  magnifierButtonDocumentColorSpace(button: BCMagnifierButton): NSColorSpace;
}

interface BCSaturationBrightnessColorPickerAllocator<InitializedType = BCSaturationBrightnessColorPicker> extends BCColorPickerBaseViewAllocator<BCSaturationBrightnessColorPicker> {}
interface BCSaturationBrightnessColorPicker extends BCColorPickerBaseView {
}
declare const BCSaturationBrightnessColorPicker: {
  alloc(): BCSaturationBrightnessColorPickerAllocator;
}

interface MSCustomShapeItemAllocator<InitializedType = MSCustomShapeItem> extends MSInspectorItemAllocator<MSCustomShapeItem> {}
interface MSCustomShapeItem extends MSInspectorItem {
  refreshAndResetAction(sender: any): IBAction;
}
declare const MSCustomShapeItem: {
  alloc(): MSCustomShapeItemAllocator;
}

interface MSAboutLinkButtonAllocator<InitializedType = MSAboutLinkButton> extends MSHoverButtonAllocator<MSAboutLinkButton> {}
interface MSAboutLinkButton extends MSHoverButton {
}
declare const MSAboutLinkButton: {
  alloc(): MSAboutLinkButtonAllocator;
}

interface MSAboutLinkButtonCellAllocator<InitializedType = MSAboutLinkButtonCell> extends MSHoverButtonCellAllocator<MSAboutLinkButtonCell> {}
interface MSAboutLinkButtonCell extends MSHoverButtonCell {
}
declare const MSAboutLinkButtonCell: {
  alloc(): MSAboutLinkButtonCellAllocator;
}

interface MSAboutWindowControllerAllocator<InitializedType = MSAboutWindowController> extends NSWindowControllerAllocator<MSAboutWindowController> {}
interface MSAboutWindowController extends NSWindowController {
  showAboutUsPage(sender: any): IBAction;
  showAcknowledgementsPage(sender: any): IBAction;
  showPurchaseLicensePage(sender: any): IBAction;
  showRenewLicensePage(sender: any): IBAction;
  unlinkDevice(sender: any): IBAction;

  backgroundImageView(): NSImageView;
  setBackgroundImageView(backgroundImageView: NSImageView): void;
  buildNumberTextField(): NSTextField;
  setBuildNumberTextField(buildNumberTextField: NSTextField): void;
  copyrightTextField(): NSTextField;
  setCopyrightTextField(copyrightTextField: NSTextField): void;
  expirationTitleTextField(): NSTextField;
  setExpirationTitleTextField(expirationTitleTextField: NSTextField): void;
  expirationDateTextField(): NSTextField;
  setExpirationDateTextField(expirationDateTextField: NSTextField): void;
  purchaseLicenseButton(): NSButton;
  setPurchaseLicenseButton(purchaseLicenseButton: NSButton): void;
  registeredToTextField(): NSTextField;
  setRegisteredToTextField(registeredToTextField: NSTextField): void;
  renewLicenseButton(): NSButton;
  setRenewLicenseButton(renewLicenseButton: NSButton): void;
  trialNoteTextField(): NSTextField;
  setTrialNoteTextField(trialNoteTextField: NSTextField): void;
  unlinkDeviceButton(): NSButton;
  setUnlinkDeviceButton(unlinkDeviceButton: NSButton): void;
  variantNameTextField(): NSTextField;
  setVariantNameTextField(variantNameTextField: NSTextField): void;
  versionTextField(): NSTextField;
  setVersionTextField(versionTextField: NSTextField): void;
}
declare const MSAboutWindowController: {
  alloc(): MSAboutWindowControllerAllocator;  showAboutWindow(): void;

}

interface MSActionGroupAllocator<InitializedType = MSActionGroup> extends MSDocumentActionAllocator<MSActionGroup> {}
interface MSActionGroup extends MSDocumentAction {
  actionNames(): NSArray<any>;
  childActions(): NSArray<any>;
  supportsState(): boolean;
}
declare const MSActionGroup: {
  alloc(): MSActionGroupAllocator;
}

interface MSAddAsLibraryActionAllocator<InitializedType = MSAddAsLibraryAction> extends MSDocumentActionAllocator<MSAddAsLibraryAction> {}
interface MSAddAsLibraryAction extends MSDocumentAction {
  addAsLibraryAction(sender: any): IBAction;
}
declare const MSAddAsLibraryAction: {
  alloc(): MSAddAsLibraryActionAllocator;
}

interface MSAddExportFormatActionAllocator<InitializedType = MSAddExportFormatAction> extends MSDocumentActionAllocator<MSAddExportFormatAction> {}
interface MSAddExportFormatAction extends MSDocumentAction {
  addExportFormat(sender: any): IBAction;
  addExportFormatToLayer(layer: MSLayer): void;
}
declare const MSAddExportFormatAction: {
  alloc(): MSAddExportFormatActionAllocator;
}

interface MSAddFlowActionAllocator<InitializedType = MSAddFlowAction> extends MSFlowBaseActionAllocator<MSAddFlowAction> {}
interface MSAddFlowAction extends MSFlowBaseAction {
  addFlow(sender: any): IBAction;
}
declare const MSAddFlowAction: {
  alloc(): MSAddFlowActionAllocator;
}

interface MSAddFlowBackActionAllocator<InitializedType = MSAddFlowBackAction> extends MSFlowBaseActionAllocator<MSAddFlowBackAction> {}
interface MSAddFlowBackAction extends MSFlowBaseAction {
  addFlowBack(sender: any): IBAction;
}
declare const MSAddFlowBackAction: {
  alloc(): MSAddFlowBackActionAllocator;
}

interface MSAddFlowHomeActionAllocator<InitializedType = MSAddFlowHomeAction> extends MSFlowBaseActionAllocator<MSAddFlowHomeAction> {}
interface MSAddFlowHomeAction extends MSFlowBaseAction {
  addFlowHome(sender: any): IBAction;
}
declare const MSAddFlowHomeAction: {
  alloc(): MSAddFlowHomeActionAllocator;
}

interface MSInsertMenuActionAllocator<InitializedType = MSInsertMenuAction> extends MSDocumentActionAllocator<MSInsertMenuAction> {}
interface MSInsertMenuAction extends MSDocumentAction {
}
declare const MSInsertMenuAction: {
  alloc(): MSInsertMenuActionAllocator;
}

interface MSInsertImageActionAllocator<InitializedType = MSInsertImageAction> extends MSBaseInsertActionAllocator<MSInsertImageAction> {}
interface MSInsertImageAction extends MSBaseInsertAction {
  insertImage(sender: any): IBAction;
}
declare const MSInsertImageAction: {
  alloc(): MSInsertImageActionAllocator;
}

interface MSPencilActionAllocator<InitializedType = MSPencilAction> extends MSDocumentActionAllocator<MSPencilAction> {}
interface MSPencilAction extends MSDocumentAction {
  pencil(sender: any): IBAction;
}
declare const MSPencilAction: {
  alloc(): MSPencilActionAllocator;
}

interface MSAddRemoteLibraryActionAllocator<InitializedType = MSAddRemoteLibraryAction> extends MSActionAllocator<MSAddRemoteLibraryAction> {}
interface MSAddRemoteLibraryAction extends MSAction {
  addAppcastURL(url: NSURL): void;
}
declare const MSAddRemoteLibraryAction: {
  alloc(): MSAddRemoteLibraryActionAllocator;
}

interface MSBaseAlignLayersActionAllocator<InitializedType = MSBaseAlignLayersAction> extends MSDocumentActionAllocator<MSBaseAlignLayersAction> {}
interface MSBaseAlignLayersAction extends MSDocumentAction, IMSAltButtonTarget {
  alignToKey(key: NSString | string): void;
}
declare const MSBaseAlignLayersAction: {
  alloc(): MSBaseAlignLayersActionAllocator;
}

interface MSAlignLayersLeftActionAllocator<InitializedType = MSAlignLayersLeftAction> extends MSBaseAlignLayersActionAllocator<MSAlignLayersLeftAction> {}
interface MSAlignLayersLeftAction extends MSBaseAlignLayersAction {
  alignLayersLeft(sender: any): IBAction;
}
declare const MSAlignLayersLeftAction: {
  alloc(): MSAlignLayersLeftActionAllocator;
}

interface MSAlignLayersCenterActionAllocator<InitializedType = MSAlignLayersCenterAction> extends MSBaseAlignLayersActionAllocator<MSAlignLayersCenterAction> {}
interface MSAlignLayersCenterAction extends MSBaseAlignLayersAction {
  alignLayersCenter(sender: any): IBAction;
}
declare const MSAlignLayersCenterAction: {
  alloc(): MSAlignLayersCenterActionAllocator;
}

interface MSAlignLayersRightActionAllocator<InitializedType = MSAlignLayersRightAction> extends MSBaseAlignLayersActionAllocator<MSAlignLayersRightAction> {}
interface MSAlignLayersRightAction extends MSBaseAlignLayersAction {
  alignLayersRight(sender: any): IBAction;
}
declare const MSAlignLayersRightAction: {
  alloc(): MSAlignLayersRightActionAllocator;
}

interface MSAlignLayersTopActionAllocator<InitializedType = MSAlignLayersTopAction> extends MSBaseAlignLayersActionAllocator<MSAlignLayersTopAction> {}
interface MSAlignLayersTopAction extends MSBaseAlignLayersAction {
  alignLayersTop(sender: any): IBAction;
}
declare const MSAlignLayersTopAction: {
  alloc(): MSAlignLayersTopActionAllocator;
}

interface MSAlignLayersMiddleActionAllocator<InitializedType = MSAlignLayersMiddleAction> extends MSBaseAlignLayersActionAllocator<MSAlignLayersMiddleAction> {}
interface MSAlignLayersMiddleAction extends MSBaseAlignLayersAction {
  alignLayersMiddle(sender: any): IBAction;
}
declare const MSAlignLayersMiddleAction: {
  alloc(): MSAlignLayersMiddleActionAllocator;
}

interface MSAlignLayersBottomActionAllocator<InitializedType = MSAlignLayersBottomAction> extends MSBaseAlignLayersActionAllocator<MSAlignLayersBottomAction> {}
interface MSAlignLayersBottomAction extends MSBaseAlignLayersAction {
  alignLayersBottom(sender: any): IBAction;
}
declare const MSAlignLayersBottomAction: {
  alloc(): MSAlignLayersBottomActionAllocator;
}

interface MSAlignmentActionsAllocator<InitializedType = MSAlignmentActions> extends MSActionGroupAllocator<MSAlignmentActions> {}
interface MSAlignmentActions extends MSActionGroup {
}
declare const MSAlignmentActions: {
  alloc(): MSAlignmentActionsAllocator;
}

interface MSAlignmentBackgroundViewAllocator<InitializedType = MSAlignmentBackgroundView> extends NSStackViewAllocator<MSAlignmentBackgroundView> {}
interface MSAlignmentBackgroundView extends NSStackView {
}
declare const MSAlignmentBackgroundView: {
  alloc(): MSAlignmentBackgroundViewAllocator;
}

interface MSAlternatingViewAllocator<InitializedType = MSAlternatingView> extends NSViewAllocator<MSAlternatingView> {}
interface MSAlternatingView extends NSView {

  otherView(): NSView;
  setOtherView(otherView: NSView): void;
}
declare const MSAlternatingView: {
  alloc(): MSAlternatingViewAllocator;
}

interface MSAnalyticsAllocator<InitializedType = MSAnalytics> extends BCSingletonAllocator<MSAnalytics> {}
interface MSAnalytics extends BCSingleton, IMSActionObserver {
  trackScreenWithName(name: NSString | string): void;
  trackEvent_withValue(event: NSString | string, value: any | null): void;

  isEnabled(): boolean;
  setIsEnabled(isEnabled: boolean): void;
}
declare const MSAnalytics: {
  alloc(): MSAnalyticsAllocator;
}

interface MSAngularGradientEventHandlerAllocator<InitializedType = MSAngularGradientEventHandler> extends MSGradientEventHandlerAllocator<MSAngularGradientEventHandler> {}
interface MSAngularGradientEventHandler extends MSGradientEventHandler {
}
declare const MSAngularGradientEventHandler: {
  alloc(): MSAngularGradientEventHandlerAllocator;
}

interface MSAppearanceInspectorSectionAllocator<InitializedType = MSAppearanceInspectorSection> extends MSBaseInspectorSectionAllocator<MSAppearanceInspectorSection> {}
interface MSAppearanceInspectorSection extends MSBaseInspectorSection {
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
}
declare const MSAppearanceInspectorSection: {
  alloc(): MSAppearanceInspectorSectionAllocator;
}

interface MSApplyOrientationActionAllocator<InitializedType = MSApplyOrientationAction> extends MSDocumentActionAllocator<MSApplyOrientationAction> {}
interface MSApplyOrientationAction extends MSDocumentAction {
}
declare const MSApplyOrientationAction: {
  alloc(): MSApplyOrientationActionAllocator;
}

interface MSApplyLandscapeOrientationActionAllocator<InitializedType = MSApplyLandscapeOrientationAction> extends MSApplyOrientationActionAllocator<MSApplyLandscapeOrientationAction> {}
interface MSApplyLandscapeOrientationAction extends MSApplyOrientationAction {
  applyLandscapeOrientation(sender: any): IBAction;
}
declare const MSApplyLandscapeOrientationAction: {
  alloc(): MSApplyLandscapeOrientationActionAllocator;
}

interface MSApplyPortraitOrientationActionAllocator<InitializedType = MSApplyPortraitOrientationAction> extends MSApplyOrientationActionAllocator<MSApplyPortraitOrientationAction> {}
interface MSApplyPortraitOrientationAction extends MSApplyOrientationAction {
  applyPortraitOrientation(sender: any): IBAction;
}
declare const MSApplyPortraitOrientationAction: {
  alloc(): MSApplyPortraitOrientationActionAllocator;
}

interface MSApplySharedStyleActionAllocator<InitializedType = MSApplySharedStyleAction> extends MSDocumentActionAllocator<MSApplySharedStyleAction> {}
interface MSApplySharedStyleAction extends MSDocumentAction {
}
declare const MSApplySharedStyleAction: {
  alloc(): MSApplySharedStyleActionAllocator;
}

interface MSApplySharedLayerStyleActionAllocator<InitializedType = MSApplySharedLayerStyleAction> extends MSApplySharedStyleActionAllocator<MSApplySharedLayerStyleAction> {}
interface MSApplySharedLayerStyleAction extends MSApplySharedStyleAction {
  applySharedLayerStyle(sender: any): IBAction;
}
declare const MSApplySharedLayerStyleAction: {
  alloc(): MSApplySharedLayerStyleActionAllocator;
}

interface MSApplySharedTextStyleActionAllocator<InitializedType = MSApplySharedTextStyleAction> extends MSApplySharedStyleActionAllocator<MSApplySharedTextStyleAction> {}
interface MSApplySharedTextStyleAction extends MSApplySharedStyleAction {
  applySharedTextStyle(sender: any): IBAction;
}
declare const MSApplySharedTextStyleAction: {
  alloc(): MSApplySharedTextStyleActionAllocator;
}

interface MSBaseMoveActionAllocator<InitializedType = MSBaseMoveAction> extends MSDocumentActionAllocator<MSBaseMoveAction> {}
interface MSBaseMoveAction extends MSDocumentAction {
}
declare const MSBaseMoveAction: {
  alloc(): MSBaseMoveActionAllocator;
}

interface MSBaseMoveForwardActionAllocator<InitializedType = MSBaseMoveForwardAction> extends MSBaseMoveActionAllocator<MSBaseMoveForwardAction> {}
interface MSBaseMoveForwardAction extends MSBaseMoveAction {
}
declare const MSBaseMoveForwardAction: {
  alloc(): MSBaseMoveForwardActionAllocator;
}

interface MSBaseMoveBackwardActionAllocator<InitializedType = MSBaseMoveBackwardAction> extends MSBaseMoveActionAllocator<MSBaseMoveBackwardAction> {}
interface MSBaseMoveBackwardAction extends MSBaseMoveAction {
}
declare const MSBaseMoveBackwardAction: {
  alloc(): MSBaseMoveBackwardActionAllocator;
}

interface MSMoveForwardActionAllocator<InitializedType = MSMoveForwardAction> extends MSBaseMoveForwardActionAllocator<MSMoveForwardAction> {}
interface MSMoveForwardAction extends MSBaseMoveForwardAction {
  moveForward(sender: any): IBAction;
}
declare const MSMoveForwardAction: {
  alloc(): MSMoveForwardActionAllocator;
}

interface MSMoveBackwardActionAllocator<InitializedType = MSMoveBackwardAction> extends MSBaseMoveBackwardActionAllocator<MSMoveBackwardAction> {}
interface MSMoveBackwardAction extends MSBaseMoveBackwardAction {
  moveBackward(sender: any): IBAction;
}
declare const MSMoveBackwardAction: {
  alloc(): MSMoveBackwardActionAllocator;
}

interface MSMoveToFrontActionAllocator<InitializedType = MSMoveToFrontAction> extends MSBaseMoveForwardActionAllocator<MSMoveToFrontAction> {}
interface MSMoveToFrontAction extends MSBaseMoveForwardAction {
  moveToFront(sender: any): IBAction;
}
declare const MSMoveToFrontAction: {
  alloc(): MSMoveToFrontActionAllocator;
}

interface MSMoveToBackActionAllocator<InitializedType = MSMoveToBackAction> extends MSBaseMoveBackwardActionAllocator<MSMoveToBackAction> {}
interface MSMoveToBackAction extends MSBaseMoveBackwardAction {
  moveToBack(sender: any): IBAction;
}
declare const MSMoveToBackAction: {
  alloc(): MSMoveToBackActionAllocator;
}

interface MSMoveActionGroupAllocator<InitializedType = MSMoveActionGroup> extends MSActionGroupAllocator<MSMoveActionGroup> {}
interface MSMoveActionGroup extends MSActionGroup {
}
declare const MSMoveActionGroup: {
  alloc(): MSMoveActionGroupAllocator;
}

interface MSArtboardContentResizeInspectorItemAllocator<InitializedType = MSArtboardContentResizeInspectorItem> extends MSInspectorItemAllocator<MSArtboardContentResizeInspectorItem> {}
interface MSArtboardContentResizeInspectorItem extends MSInspectorItem {
}
declare const MSArtboardContentResizeInspectorItem: {
  alloc(): MSArtboardContentResizeInspectorItemAllocator;
}

interface MSArtboardPositionInspectorItemAllocator<InitializedType = MSArtboardPositionInspectorItem> extends MSPositionInspectorItemAllocator<MSArtboardPositionInspectorItem> {}
interface MSArtboardPositionInspectorItem extends MSPositionInspectorItem {
}
declare const MSArtboardPositionInspectorItem: {
  alloc(): MSArtboardPositionInspectorItemAllocator;
}

declare enum MSArtboardPresetMatch {
  MSArtboardPresetMatchInvalid = 0,
  MSArtboardPresetMatchValid = 1 << 0,
  MSArtboardPresetMatchTall = 1 << 1,
  MSArtboardPresetMatchScaled = 1 << 2,
  MSArtboardPresetMatchRotated = 1 << 3,
}

interface MSArtboardPresetInspectorItemAllocator<InitializedType = MSArtboardPresetInspectorItem> extends MSInspectorItemAllocator<MSArtboardPresetInspectorItem> {}
interface MSArtboardPresetInspectorItem extends MSInspectorItem {
}
declare const MSArtboardPresetInspectorItem: {
  alloc(): MSArtboardPresetInspectorItemAllocator;
}

interface MSArtboardPresetTableCellViewAllocator<InitializedType = MSArtboardPresetTableCellView> extends NSTableCellViewAllocator<MSArtboardPresetTableCellView> {}
interface MSArtboardPresetTableCellView extends NSTableCellView {

  checkmark(): NSImageView;
  setCheckmark(checkmark: NSImageView): void;
  sizeLabel(): NSTextField;
  setSizeLabel(sizeLabel: NSTextField): void;
}
declare const MSArtboardPresetTableCellView: {
  alloc(): MSArtboardPresetTableCellViewAllocator;
}

interface MSArtboardPresetsTableViewAllocator<InitializedType = MSArtboardPresetsTableView> extends NSTableViewAllocator<MSArtboardPresetsTableView> {}
interface MSArtboardPresetsTableView extends NSTableView {
}
declare const MSArtboardPresetsTableView: {
  alloc(): MSArtboardPresetsTableViewAllocator;
}

interface MSArtboardPresetsViewControllerAllocator<InitializedType = MSArtboardPresetsViewController> extends NSViewControllerAllocator<MSArtboardPresetsViewController> {}
interface MSArtboardPresetsViewController extends NSViewController, IBCPopoverDelegate {
  categoryForPreset(preset: MSArtboardPreset): MSArtboardPresetsCategory;
  addUserPreset(newPreset: MSArtboardPreset): void;

  presetStore(): MSArtboardPresetStore;
  setPresetStore(presetStore: MSArtboardPresetStore): void;
  categories(): NSArray<any>;
  selectedCategory(): MSArtboardPresetsCategory;
  setSelectedCategory(selectedCategory: MSArtboardPresetsCategory): void;
  orientation(): NSPaperOrientation;
  setOrientation(orientation: NSPaperOrientation): void;
  extraPresets(): NSArray<any>;
  setExtraPresets(extraPresets: NSArray<any> | any[]): void;
  selectedPresetSize(): NSSize;
  setSelectedPresetSize(selectedPresetSize: NSSize): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSArtboardPresetsViewController: {
  alloc(): MSArtboardPresetsViewControllerAllocator;
}

interface IMSArtboardPresetsViewControllerDelegate {
  artboardPresetsViewController_didSelectPreset(sender: MSArtboardPresetsViewController, preset: MSArtboardPreset): void;
  artboardPresetsViewController_didSelectOrientation(sender: MSArtboardPresetsViewController, orientation: NSPaperOrientation): void;
  showCustomPresetSheet(presetsController: MSArtboardPresetsViewController): void;
}

interface MSArtboardResizeToFitInspectorItemAllocator<InitializedType = MSArtboardResizeToFitInspectorItem> extends MSExportSelectedOrResizeInspectorItemAllocator<MSArtboardResizeToFitInspectorItem> {}
interface MSArtboardResizeToFitInspectorItem extends MSExportSelectedOrResizeInspectorItem {
}
declare const MSArtboardResizeToFitInspectorItem: {
  alloc(): MSArtboardResizeToFitInspectorItemAllocator;
}

interface MSArtboardSizeInspectorItemAllocator<InitializedType = MSArtboardSizeInspectorItem> extends MSBaseSizeInspectorItemAllocator<MSArtboardSizeInspectorItem> {}
interface MSArtboardSizeInspectorItem extends MSBaseSizeInspectorItem {
}
declare const MSArtboardSizeInspectorItem: {
  alloc(): MSArtboardSizeInspectorItemAllocator;
}

interface MSAssetLibrariesPreferencePaneAllocator<InitializedType = MSAssetLibrariesPreferencePane> extends MSPreferencePaneAllocator<MSAssetLibrariesPreferencePane> {}
interface MSAssetLibrariesPreferencePane extends MSPreferencePane, INSTableViewDelegate, INSTableViewDataSource {
  importLibraryAction(sender: any): IBAction;
  removeLibraryAction(sender: any): IBAction;
  locateLibraryAction(sender: any): IBAction;
  addLibrariesFromURLS(urls: NSArray<any> | any[]): void;
  preferenceItemHasUpdated(item: MSAssetPreferenceItem): void;
  startDownloadForRemoteLibrary(remoteLibrary: MSRemoteAssetLibrary): void;
  reloadSelectingLibrary(library: MSAssetLibrary): void;
  updateAvailableForRemoteLibrary(remoteLibrary: MSRemoteAssetLibrary): void;
  displayInstallerAlertSheetForRemoteAssetLibrary(): void;
  displayDuplicateAlertSheetForRemoteAssetLibrary(remoteAssetLibrary: MSRemoteAssetLibrary): void;
  tableCellForLibrary(library: MSAssetLibrary): MSAssetLibraryTableCellView;

  tableView(): MSAssetLibraryTableView;
  setTableView(tableView: MSAssetLibraryTableView): void;
  assetLibraryController(): MSAssetLibraryController;
}
declare const MSAssetLibrariesPreferencePane: {
  alloc(): MSAssetLibrariesPreferencePaneAllocator;
}

interface MSAssetLibraryPreviewAllocator<InitializedType = MSAssetLibraryPreview> extends NSViewAllocator<MSAssetLibraryPreview> {}
interface MSAssetLibraryPreview extends NSView {

  libraryPreview(): NSImage;
  setLibraryPreview(libraryPreview: NSImage): void;
}
declare const MSAssetLibraryPreview: {
  alloc(): MSAssetLibraryPreviewAllocator;
}

interface MSAssetLibraryTableCellViewAllocator<InitializedType = MSAssetLibraryTableCellView> extends NSTableCellViewAllocator<MSAssetLibraryTableCellView> {}
interface MSAssetLibraryTableCellView extends NSTableCellView {
  startDownloading(): void;

  assetPreferenceItem(): MSAssetPreferenceItem;
}
declare const MSAssetLibraryTableCellView: {
  alloc(): MSAssetLibraryTableCellViewAllocator;
}

interface MSAssetLibraryTableViewAllocator<InitializedType = MSAssetLibraryTableView> extends BCKeyEventActionTableViewAllocator<MSAssetLibraryTableView> {}
interface MSAssetLibraryTableView extends BCKeyEventActionTableView {
}
declare const MSAssetLibraryTableView: {
  alloc(): MSAssetLibraryTableViewAllocator;
}

interface MSAssetPickerHeaderViewAllocator<InitializedType = MSAssetPickerHeaderView> extends NSViewAllocator<MSAssetPickerHeaderView> {}
interface MSAssetPickerHeaderView extends NSView {
}
declare const MSAssetPickerHeaderView: {
  alloc(): MSAssetPickerHeaderViewAllocator;  headerPickerWithTitle_isExpandedPreference_delegate(title: NSString | string, preferenceKey: NSString | string, delegate: any): MSAssetPickerHeaderView;

}

interface IMSAssetPickerHeaderViewDelegate {
  assetHeaderViewDidClick(headerView: MSAssetPickerHeaderView): void;
}

interface MSAssetPickerViewAllocator<InitializedType = MSAssetPickerView> extends NSViewAllocator<MSAssetPickerView> {}
interface MSAssetPickerView extends NSView, INSScrubberDataSource, INSScrubberDelegate, INSTouchBarDelegate {
  reloadData(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  tileSize(): NSSize;
  setTileSize(tileSize: NSSize): void;
  tileMargin(): CGFloat;
  setTileMargin(tileMargin: CGFloat): void;
  edgeMargins(): NSEdgeInsets;
  setEdgeMargins(edgeMargins: NSEdgeInsets): void;
  hoveringIndex(): NSUInteger;
  setHoveringIndex(hoveringIndex: NSUInteger): void;
  currentIndexes(): NSIndexSet;
  setCurrentIndexes(currentIndexes: NSIndexSet): void;
  assetCollection(): MSAssetCollection;
  setAssetCollection(assetCollection: MSAssetCollection): void;
  assetType(): MSAsset;
  setAssetType(assetType: MSAsset): void;
}
declare const MSAssetPickerView: {
  alloc(): MSAssetPickerViewAllocator;
}

interface MSAssetPreferenceItemAllocator<InitializedType = MSAssetPreferenceItem> extends NSObjectAllocator<MSAssetPreferenceItem> {}
interface MSAssetPreferenceItem extends NSObject {
  evaluateSecondaryTitle(): void;

  updatingStatus(): MSAssetLibraryUpdatingStatus;
  setUpdatingStatus(updatingStatus: MSAssetLibraryUpdatingStatus): void;
  updateAvailable(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  library(): MSAssetLibrary;
  remoteLibrary(): MSRemoteAssetLibrary;
  name(): NSString;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  validForSecondaryTextField(): boolean;
  preview(): NSImage;
  setPreview(preview: NSImage): void;
  secondaryTitle(): NSString;
  hasAppcastURL(): boolean;
  fileSize(): NSUInteger;
  setFileSize(fileSize: NSUInteger): void;
  downloadedSoFar(): NSUInteger;
  setDownloadedSoFar(downloadedSoFar: NSUInteger): void;
  missingRemoteLibraryWithNoInternet(): boolean;
}
declare const MSAssetPreferenceItem: {
  alloc(): MSAssetPreferenceItemAllocator;  preferenceItemForLibrary(library: MSAssetLibrary): MSAssetPreferenceItem;

}

interface IMSAssetPreferenceItemDelegate {
  preferenceItemHasUpdated(item: MSAssetPreferenceItem): void;
}

declare enum MSAssetLibraryUpdatingStatus {
  MSAssetLibraryUpdatingStatusNoDownloadAvailable = 0,
  MSAssetLibraryUpdatingStatusDownloadAvailable,
  MSAssetLibraryUpdatingStatusUpdateAvailable,
  MSAssetLibraryUpdatingStatusDownloading,
  MSAssetLibraryUpdatingStatusDownloadError,
  MSAssetLibraryUpdatingStatusWaitingForInstall,
}

interface MSAssetScrubberItemViewAllocator<InitializedType = MSAssetScrubberItemView> extends NSScrubberItemViewAllocator<MSAssetScrubberItemView> {}
interface MSAssetScrubberItemView extends NSScrubberItemView {

  color(): MSColor;
  canvasColorSpace(): NSColorSpace;
  gradient(): MSGradient;
  pattern(): MSImageData;
  isFirstInCollection(): boolean;
  isLastInCollection(): boolean;
  tailPadding(): CGFloat;
}
declare const MSAssetScrubberItemView: {
  alloc(): MSAssetScrubberItemViewAllocator;
}

interface MSAssetSyncHeaderCellViewAllocator<InitializedType = MSAssetSyncHeaderCellView> extends NSTableCellViewAllocator<MSAssetSyncHeaderCellView> {}
interface MSAssetSyncHeaderCellView extends NSTableCellView {

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}
declare const MSAssetSyncHeaderCellView: {
  alloc(): MSAssetSyncHeaderCellViewAllocator;
}

interface MSAssetSyncItemTableCellViewAllocator<InitializedType = MSAssetSyncItemTableCellView> extends NSTableCellViewAllocator<MSAssetSyncItemTableCellView> {}
interface MSAssetSyncItemTableCellView extends NSTableCellView {
}
declare const MSAssetSyncItemTableCellView: {
  alloc(): MSAssetSyncItemTableCellViewAllocator;
}

interface MSAssetSyncSheetAllocator<InitializedType = MSAssetSyncSheet> extends CHSheetControllerAllocator<MSAssetSyncSheet> {}
interface MSAssetSyncSheet extends CHSheetController {
}
declare const MSAssetSyncSheet: {
  alloc(): MSAssetSyncSheetAllocator;
}

interface MSAssetSyncSheetHeaderAllocator<InitializedType = MSAssetSyncSheetHeader> extends NSObjectAllocator<MSAssetSyncSheetHeader> {}
interface MSAssetSyncSheetHeader extends NSObject, IMSAssetSyncSheetItem {

  modifiedDateString(): NSString;
}
declare const MSAssetSyncSheetHeader: {
  alloc(): MSAssetSyncSheetHeaderAllocator;
}

interface IMSAssetSyncSheetItem {

  type(): MSAssetSyncSheetItemType;
  library(): MSAssetLibrary;
  setLibrary(library: MSAssetLibrary): void;
  displayName(): NSString;
  shouldSync(): boolean;
}

declare enum MSAssetSyncSheetItemType {
  MSAssetSyncSheetItemTypeHeader,
  MSAssetSyncSheetItemTypeSymbol,
  MSAssetSyncSheetItemTypeLayerStyle,
  MSAssetSyncSheetItemTypeTextStyle,
}

interface MSAssetSyncSheetObjectAllocator<InitializedType = MSAssetSyncSheetObject> extends NSObjectAllocator<MSAssetSyncSheetObject> {}
interface MSAssetSyncSheetObject extends NSObject, IMSAssetSyncSheetItem {

  foreignObject(): MSForeignObject;
  setForeignObject(foreignObject: MSForeignObject): void;
  libraryMaster(): MSShareableObject;
  setLibraryMaster(libraryMaster: MSShareableObject): void;
  shouldSync(): boolean;
  setShouldSync(shouldSync: boolean): void;
  tooltipForLocal(): NSString;
  tooltipForRemote(): NSString;
}
declare const MSAssetSyncSheetObject: {
  alloc(): MSAssetSyncSheetObjectAllocator;
}

interface MSAutoExpandGroupsActionAllocator<InitializedType = MSAutoExpandGroupsAction> extends MSDocumentActionAllocator<MSAutoExpandGroupsAction> {}
interface MSAutoExpandGroupsAction extends MSDocumentAction {
  autoExpandGroups(sender: any): IBAction;
}
declare const MSAutoExpandGroupsAction: {
  alloc(): MSAutoExpandGroupsActionAllocator;
}

interface MSRevealInLayerListActionAllocator<InitializedType = MSRevealInLayerListAction> extends MSDocumentActionAllocator<MSRevealInLayerListAction> {}
interface MSRevealInLayerListAction extends MSDocumentAction {
  revealInLayerList(sender: any): IBAction;
}
declare const MSRevealInLayerListAction: {
  alloc(): MSRevealInLayerListActionAllocator;
}

interface MSBackButtonWindowControllerAllocator<InitializedType = MSBackButtonWindowController> extends NSWindowControllerAllocator<MSBackButtonWindowController> {}
interface MSBackButtonWindowController extends NSWindowController {
  backButtonAction(sender: any): IBAction;
  attachToView_forArtboard(view: NSView, artboard: MSArtboardGroup): void;
  hide(): void;

  doc(): MSDocument;
  setDoc(doc: MSDocument): void;
}
declare const MSBackButtonWindowController: {
  alloc(): MSBackButtonWindowControllerAllocator;
}

interface MSBackButtonContentViewAllocator<InitializedType = MSBackButtonContentView> extends NSViewAllocator<MSBackButtonContentView> {}
interface MSBackButtonContentView extends NSView {
}
declare const MSBackButtonContentView: {
  alloc(): MSBackButtonContentViewAllocator;
}

interface MSBackToInstanceActionAllocator<InitializedType = MSBackToInstanceAction> extends MSDocumentActionAllocator<MSBackToInstanceAction> {}
interface MSBackToInstanceAction extends MSDocumentAction {
  backToInstance(sender: any): IBAction;
}
declare const MSBackToInstanceAction: {
  alloc(): MSBackToInstanceActionAllocator;
}

interface MSBackgroundColorViewAllocator<InitializedType = MSBackgroundColorView> extends NSViewAllocator<MSBackgroundColorView> {}
interface MSBackgroundColorView extends NSView {

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}
declare const MSBackgroundColorView: {
  alloc(): MSBackgroundColorViewAllocator;
}

interface MSBadgeControllerAllocator<InitializedType = MSBadgeController> extends NSObjectAllocator<MSBadgeController> {
  initWithDocument(document: MSDocument): InitializedType;
}
interface MSBadgeController extends NSObject {
  refresh(): void;

  activeWindowBadgingActions(): NSArray<any>;
}
declare const MSBadgeController: {
  alloc(): MSBadgeControllerAllocator;
}

interface MSBadgeMenuActionAllocator<InitializedType = MSBadgeMenuAction> extends MSDocumentActionAllocator<MSBadgeMenuAction> {}
interface MSBadgeMenuAction extends MSDocumentAction, IMSWindowBadgeAction {
}
declare const MSBadgeMenuAction: {
  alloc(): MSBadgeMenuActionAllocator;
}

interface MSBaseBlurInspectorItemAllocator<InitializedType = MSBaseBlurInspectorItem> extends MSStylePartInspectorItemAllocator<MSBaseBlurInspectorItem> {}
interface MSBaseBlurInspectorItem extends MSStylePartInspectorItem, IMSInspectorValueAdaptorDelegate {

  radiusField(): MSUpDownTextField;
  setRadiusField(radiusField: MSUpDownTextField): void;
  radiusSlider(): NSSlider;
  setRadiusSlider(radiusSlider: NSSlider): void;
}
declare const MSBaseBlurInspectorItem: {
  alloc(): MSBaseBlurInspectorItemAllocator;
}

interface MSSimpleBlurInspectorItemAllocator<InitializedType = MSSimpleBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<MSSimpleBlurInspectorItem> {}
interface MSSimpleBlurInspectorItem extends MSBaseBlurInspectorItem {
}
declare const MSSimpleBlurInspectorItem: {
  alloc(): MSSimpleBlurInspectorItemAllocator;
}

interface MSMotionBlurInspectorItemAllocator<InitializedType = MSMotionBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<MSMotionBlurInspectorItem> {}
interface MSMotionBlurInspectorItem extends MSBaseBlurInspectorItem {
}
declare const MSMotionBlurInspectorItem: {
  alloc(): MSMotionBlurInspectorItemAllocator;
}

interface MSZoomBlurInspectorItemAllocator<InitializedType = MSZoomBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<MSZoomBlurInspectorItem> {}
interface MSZoomBlurInspectorItem extends MSBaseBlurInspectorItem {
}
declare const MSZoomBlurInspectorItem: {
  alloc(): MSZoomBlurInspectorItemAllocator;
}

interface MSBackgroundBlurInspectorItemAllocator<InitializedType = MSBackgroundBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<MSBackgroundBlurInspectorItem> {}
interface MSBackgroundBlurInspectorItem extends MSBaseBlurInspectorItem {

  saturationField(): MSUpDownTextField;
  setSaturationField(saturationField: MSUpDownTextField): void;
  saturationSlider(): NSSlider;
  setSaturationSlider(saturationSlider: NSSlider): void;
}
declare const MSBackgroundBlurInspectorItem: {
  alloc(): MSBackgroundBlurInspectorItemAllocator;
}

interface MSBaseInsertActionAllocator<InitializedType = MSBaseInsertAction> extends MSDocumentActionAllocator<MSBaseInsertAction> {}
interface MSBaseInsertAction extends MSDocumentAction {
}
declare const MSBaseInsertAction: {
  alloc(): MSBaseInsertActionAllocator;
}

interface MSInspectorItemAllocator<InitializedType = MSInspectorItem> extends NSViewControllerAllocator<MSInspectorItem> {}
interface MSInspectorItem extends NSViewController {
  manageTextField_adaptor_identifier_toolTip_touchBarItems(textField: MSUpDownTextField, adaptor: MSMathInspectorValueAdaptor, identifier: NSUserInterfaceItemIdentifier, toolTip: NSString | string, touchBarItems: NSArray<any> | any[] | null): void;
  selectionDidChangeTo(layers: MSLayerArray): void;
  updateDisplayedValues(): void;

  layers(): MSLayerArray;
  layersController(): NSArrayController;
  setLayersController(layersController: NSArrayController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  document(): MSDocument;
}
declare const MSInspectorItem: {
  alloc(): MSInspectorItemAllocator;  itemForSection(section: MSBaseInspectorSection): MSInspectorItem;
  filterSelection(layers: MSLayerArray): MSLayerArray;
  canHandleSomeLayersOfSelection(layerArray: MSLayerArray): boolean;
  canHandleLayer(layer: MSLayer): boolean;

}

interface MSBaseInspectorSectionAllocator<InitializedType = MSBaseInspectorSection> extends NSViewControllerAllocator<MSBaseInspectorSection> {}
interface MSBaseInspectorSection extends NSViewController, IMSInspectorSection, IMSInspectorItemDelegate {
  updateItems(): void;
  valuesPossiblyChanged(): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  canHandleColorMagnifierAction(): boolean;
  colorMagnifierAction(sender: any): IBAction;
  changeTextLayerFont(sender: any): IBAction;

  items(): NSArray<any>;
  setItems(items: NSArray<any> | any[]): void;
  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSBaseInspectorSection: {
  alloc(): MSBaseInspectorSectionAllocator;
}

interface MSBaseSharedObjectActionAllocator<InitializedType = MSBaseSharedObjectAction> extends MSDocumentActionAllocator<MSBaseSharedObjectAction> {}
interface MSBaseSharedObjectAction extends MSDocumentAction {
  performSharedObjectAction(): void;

  updater(): MSShareableObjectUpdater;
  needsRenameAfterAction(): boolean;
}
declare const MSBaseSharedObjectAction: {
  alloc(): MSBaseSharedObjectActionAllocator;
}

interface MSBaseSizeInspectorItemAllocator<InitializedType = MSBaseSizeInspectorItem> extends MSInspectorItemAllocator<MSBaseSizeInspectorItem> {}
interface MSBaseSizeInspectorItem extends MSInspectorItem {
  updateUI(): void;

  widthAdapter(): MSSizeInspectorValueAdaptor;
  setWidthAdapter(widthAdapter: MSSizeInspectorValueAdaptor): void;
  heightAdapter(): MSSizeInspectorValueAdaptor;
  setHeightAdapter(heightAdapter: MSSizeInspectorValueAdaptor): void;
}
declare const MSBaseSizeInspectorItem: {
  alloc(): MSBaseSizeInspectorItemAllocator;
}

interface MSBaseTransformInspectorItemAllocator<InitializedType = MSBaseTransformInspectorItem> extends MSInspectorItemAllocator<MSBaseTransformInspectorItem> {
  initWithTitle_textFieldLabel(title: NSString | string, textFieldLabel: NSString | string): InitializedType;
}
interface MSBaseTransformInspectorItem extends MSInspectorItem {

  textField(): MSUpDownTextField;
  setTextField(textField: MSUpDownTextField): void;
  flipSegmentedControl(): NSSegmentedControl;
  setFlipSegmentedControl(flipSegmentedControl: NSSegmentedControl): void;
  textFieldFormatter(): MSMathNumberFormatter;
  setTextFieldFormatter(textFieldFormatter: MSMathNumberFormatter): void;
}
declare const MSBaseTransformInspectorItem: {
  alloc(): MSBaseTransformInspectorItemAllocator;
}

interface MSBitmapEditEventHandlerAllocator<InitializedType = MSBitmapEditEventHandler> extends MSEventHandlerAllocator<MSBitmapEditEventHandler> {}
interface MSBitmapEditEventHandler extends MSEventHandler {
  invertAction(sender: any): IBAction;
  cropAction(sender: any): IBAction;
  selectLayerBelowPoint(mouse: NSPoint): void;
  fillSelectionWithColor(color: NSColor): void;
  bitmapEditableLayer(): MSLayer;
  imageSize(): NSSize;
  imageBounds(): NSRect;

  currentMode(): MSBitmapEditMode;
  setCurrentMode(currentMode: MSBitmapEditMode): void;
  accumulatedSelection(): NSBezierPath;
  setAccumulatedSelection(accumulatedSelection: NSBezierPath): void;
}
declare const MSBitmapEditEventHandler: {
  alloc(): MSBitmapEditEventHandlerAllocator;
}

declare enum MSBitmapEditMode {
  MSBitmapEditModeRect,
  MSBitmapEditModeMagicWand,
}

interface MSBitmapEditInspectorViewControllerAllocator<InitializedType = MSBitmapEditInspectorViewController> extends NSViewControllerAllocator<MSBitmapEditInspectorViewController> {}
interface MSBitmapEditInspectorViewController extends NSViewController, IMSInspectorChildController {
  refresh(): void;

  currentMode(): MSBitmapEditMode;
  setCurrentMode(currentMode: MSBitmapEditMode): void;
  hasSelection(): boolean;
  setHasSelection(hasSelection: boolean): void;
  eventHandler(): MSBitmapEditEventHandler;
  setEventHandler(eventHandler: MSBitmapEditEventHandler): void;
}
declare const MSBitmapEditInspectorViewController: {
  alloc(): MSBitmapEditInspectorViewControllerAllocator;
}

interface IMSBitmapEditable {

  image(): MSImageData;
  setImage(image: MSImageData): void;
  NSImage(): NSImage;
}

interface MSBitmapEditorAllocator<InitializedType = MSBitmapEditor> extends NSObjectAllocator<MSBitmapEditor> {}
interface MSBitmapEditor extends NSObject {
  draw(): void;
  mouseDown_flags(mouse: NSPoint, flags: NSUInteger): void;
  mouseDragged(mouse: NSPoint): void;
  mouseUp_flags(mouse: NSPoint, flags: NSUInteger): void;
  refreshRectInBitmapCoordinates(bitmapRect: NSRect): void;
  drawMarchingAntsForPath(path: NSBezierPath): void;
  pointInBitmapLayer(mouse: NSPoint): NSPoint;
  imageSize(): NSSize;
  imageBounds(): NSRect;

  eventHandler(): MSBitmapEditEventHandler;
  setEventHandler(eventHandler: MSBitmapEditEventHandler): void;
  bitmapEditableLayer(): MSLayer;
  accumulatedSelection(): NSBezierPath;
  setAccumulatedSelection(accumulatedSelection: NSBezierPath): void;
}
declare const MSBitmapEditor: {
  alloc(): MSBitmapEditorAllocator;
}

interface MSBitmapLayerItemAllocator<InitializedType = MSBitmapLayerItem> extends MSInspectorItemAllocator<MSBitmapLayerItem> {}
interface MSBitmapLayerItem extends MSInspectorItem {
}
declare const MSBitmapLayerItem: {
  alloc(): MSBitmapLayerItemAllocator;
}

interface MSBitmapMagicWandEditorAllocator<InitializedType = MSBitmapMagicWandEditor> extends MSBitmapEditorAllocator<MSBitmapMagicWandEditor> {}
interface MSBitmapMagicWandEditor extends MSBitmapEditor {
}
declare const MSBitmapMagicWandEditor: {
  alloc(): MSBitmapMagicWandEditorAllocator;
}

interface MSBitmapOverrideInspectorItemAllocator<InitializedType = MSBitmapOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<MSBitmapOverrideInspectorItem> {}
interface MSBitmapOverrideInspectorItem extends MSOverrideInspectorItem, IMSDataMenuProviderDelegate {
  NSImage(): NSImage;
}
declare const MSBitmapOverrideInspectorItem: {
  alloc(): MSBitmapOverrideInspectorItemAllocator;
}

interface MSBitmapRectangleEditorAllocator<InitializedType = MSBitmapRectangleEditor> extends MSBitmapEditorAllocator<MSBitmapRectangleEditor> {}
interface MSBitmapRectangleEditor extends MSBitmapEditor {
  sizeForLabel(): NSSize;
}
declare const MSBitmapRectangleEditor: {
  alloc(): MSBitmapRectangleEditorAllocator;
}

interface MSBlockAnimationAllocator<InitializedType = MSBlockAnimation> extends CABasicAnimationAllocator<MSBlockAnimation> {
  initWithBlock(aBlock: MSAnimationBlock): InitializedType;
}
interface MSBlockAnimation extends CABasicAnimation {
}
declare const MSBlockAnimation: {
  alloc(): MSBlockAnimationAllocator;
}

interface MSBlurInspectorViewControllerAllocator<InitializedType = MSBlurInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<MSBlurInspectorViewController> {}
interface MSBlurInspectorViewController extends MSStylePartInspectorViewController, INSMenuDelegate {
}
declare const MSBlurInspectorViewController: {
  alloc(): MSBlurInspectorViewControllerAllocator;
}

interface MSBlurNameInspectorItemAllocator<InitializedType = MSBlurNameInspectorItem> extends MSStylePartInspectorItemAllocator<MSBlurNameInspectorItem> {}
interface MSBlurNameInspectorItem extends MSStylePartInspectorItem {
}
declare const MSBlurNameInspectorItem: {
  alloc(): MSBlurNameInspectorItemAllocator;
}

interface MSBlurPopUpButtonCellAllocator<InitializedType = MSBlurPopUpButtonCell> extends NSPopUpButtonCellAllocator<MSBlurPopUpButtonCell> {}
interface MSBlurPopUpButtonCell extends NSPopUpButtonCell {
}
declare const MSBlurPopUpButtonCell: {
  alloc(): MSBlurPopUpButtonCellAllocator;
}

interface MSBooleanMenuActionAllocator<InitializedType = MSBooleanMenuAction> extends MSDocumentActionAllocator<MSBooleanMenuAction> {}
interface MSBooleanMenuAction extends MSDocumentAction {
}
declare const MSBooleanMenuAction: {
  alloc(): MSBooleanMenuActionAllocator;
}

interface MSBaseBooleanActionAllocator<InitializedType = MSBaseBooleanAction> extends MSDocumentActionAllocator<MSBaseBooleanAction> {}
interface MSBaseBooleanAction extends MSDocumentAction {
  booleanOperation(): MSBooleanOperation;
}
declare const MSBaseBooleanAction: {
  alloc(): MSBaseBooleanActionAllocator;
}

interface MSSubtractActionAllocator<InitializedType = MSSubtractAction> extends MSBaseBooleanActionAllocator<MSSubtractAction> {}
interface MSSubtractAction extends MSBaseBooleanAction {
  booleanSubtract(sender: any): IBAction;
}
declare const MSSubtractAction: {
  alloc(): MSSubtractActionAllocator;
}

interface MSUnionActionAllocator<InitializedType = MSUnionAction> extends MSBaseBooleanActionAllocator<MSUnionAction> {}
interface MSUnionAction extends MSBaseBooleanAction {
  booleanUnion(sender: any): IBAction;
}
declare const MSUnionAction: {
  alloc(): MSUnionActionAllocator;
}

interface MSIntersectActionAllocator<InitializedType = MSIntersectAction> extends MSBaseBooleanActionAllocator<MSIntersectAction> {}
interface MSIntersectAction extends MSBaseBooleanAction {
  booleanIntersect(sender: any): IBAction;
}
declare const MSIntersectAction: {
  alloc(): MSIntersectActionAllocator;
}

interface MSDifferenceActionAllocator<InitializedType = MSDifferenceAction> extends MSBaseBooleanActionAllocator<MSDifferenceAction> {}
interface MSDifferenceAction extends MSBaseBooleanAction {
  booleanDifference(sender: any): IBAction;
}
declare const MSDifferenceAction: {
  alloc(): MSDifferenceActionAllocator;
}

interface MSBooleanActionGroupAllocator<InitializedType = MSBooleanActionGroup> extends MSActionGroupAllocator<MSBooleanActionGroup> {}
interface MSBooleanActionGroup extends MSActionGroup {
}
declare const MSBooleanActionGroup: {
  alloc(): MSBooleanActionGroupAllocator;
}

interface MSBorderInspectorViewControllerAllocator<InitializedType = MSBorderInspectorViewController> extends MSColorStylePartInspectorViewControllerAllocator<MSBorderInspectorViewController> {}
interface MSBorderInspectorViewController extends MSColorStylePartInspectorViewController {
  enableAction(sender: any): IBAction;

  positionPopUp(): NSPopUpButton;
  setPositionPopUp(positionPopUp: NSPopUpButton): void;
  thicknessField(): MSUpDownTextField;
  setThicknessField(thicknessField: MSUpDownTextField): void;
}
declare const MSBorderInspectorViewController: {
  alloc(): MSBorderInspectorViewControllerAllocator;
}

interface MSBorderOptionsInspectorViewControllerAllocator<InitializedType = MSBorderOptionsInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<MSBorderOptionsInspectorViewController> {}
interface MSBorderOptionsInspectorViewController extends MSStylePartInspectorViewController {
  startDecorationAction(sender: any): IBAction;
  endDecorationAction(sender: any): IBAction;
  capAction(sender: any): IBAction;
  joinAction(sender: any): IBAction;
  dashPatternAction(sender: any): IBAction;
  reloadData(): void;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}
declare const MSBorderOptionsInspectorViewController: {
  alloc(): MSBorderOptionsInspectorViewControllerAllocator;
}

interface MSBottomGradientViewAllocator<InitializedType = MSBottomGradientView> extends NSViewAllocator<MSBottomGradientView> {}
interface MSBottomGradientView extends NSView {
}
declare const MSBottomGradientView: {
  alloc(): MSBottomGradientViewAllocator;
}

interface MSCallToActionButtonAllocator<InitializedType = MSCallToActionButton> extends MSHoverButtonAllocator<MSCallToActionButton> {}
interface MSCallToActionButton extends MSHoverButton {
}
declare const MSCallToActionButton: {
  alloc(): MSCallToActionButtonAllocator;
}

interface MSCallToActionButtonCellAllocator<InitializedType = MSCallToActionButtonCell> extends MSHoverButtonCellAllocator<MSCallToActionButtonCell> {}
interface MSCallToActionButtonCell extends MSHoverButtonCell {
}
declare const MSCallToActionButtonCell: {
  alloc(): MSCallToActionButtonCellAllocator;
}

interface MSCallToActionButtonDividerViewAllocator<InitializedType = MSCallToActionButtonDividerView> extends NSViewAllocator<MSCallToActionButtonDividerView> {}
interface MSCallToActionButtonDividerView extends NSView {
}
declare const MSCallToActionButtonDividerView: {
  alloc(): MSCallToActionButtonDividerViewAllocator;
}

interface MSZoomToActualSizeActionAllocator<InitializedType = MSZoomToActualSizeAction> extends MSDocumentActionAllocator<MSZoomToActualSizeAction> {}
interface MSZoomToActualSizeAction extends MSDocumentAction {
  actualSize(sender: any): IBAction;
}
declare const MSZoomToActualSizeAction: {
  alloc(): MSZoomToActualSizeActionAllocator;
}

interface MSZoomToSelectionActionAllocator<InitializedType = MSZoomToSelectionAction> extends MSDocumentActionAllocator<MSZoomToSelectionAction> {}
interface MSZoomToSelectionAction extends MSDocumentAction {
}
declare const MSZoomToSelectionAction: {
  alloc(): MSZoomToSelectionActionAllocator;
}

interface MSZoomToArtboardActionAllocator<InitializedType = MSZoomToArtboardAction> extends MSDocumentActionAllocator<MSZoomToArtboardAction> {}
interface MSZoomToArtboardAction extends MSDocumentAction {
}
declare const MSZoomToArtboardAction: {
  alloc(): MSZoomToArtboardActionAllocator;
}

interface MSCenterSelectionInVisibleAreaActionAllocator<InitializedType = MSCenterSelectionInVisibleAreaAction> extends MSDocumentActionAllocator<MSCenterSelectionInVisibleAreaAction> {}
interface MSCenterSelectionInVisibleAreaAction extends MSDocumentAction {
}
declare const MSCenterSelectionInVisibleAreaAction: {
  alloc(): MSCenterSelectionInVisibleAreaActionAllocator;
}

interface MSCenterLayersInCanvasActionAllocator<InitializedType = MSCenterLayersInCanvasAction> extends MSDocumentActionAllocator<MSCenterLayersInCanvasAction> {}
interface MSCenterLayersInCanvasAction extends MSDocumentAction {
}
declare const MSCenterLayersInCanvasAction: {
  alloc(): MSCenterLayersInCanvasActionAllocator;
}

interface MSSelectAllActionAllocator<InitializedType = MSSelectAllAction> extends MSDocumentActionAllocator<MSSelectAllAction> {}
interface MSSelectAllAction extends MSDocumentAction {
}
declare const MSSelectAllAction: {
  alloc(): MSSelectAllActionAllocator;
}

interface MSCutActionAllocator<InitializedType = MSCutAction> extends MSDocumentActionAllocator<MSCutAction> {}
interface MSCutAction extends MSDocumentAction {
}
declare const MSCutAction: {
  alloc(): MSCutActionAllocator;
}

interface MSCopyActionAllocator<InitializedType = MSCopyAction> extends MSDocumentActionAllocator<MSCopyAction> {}
interface MSCopyAction extends MSDocumentAction {
}
declare const MSCopyAction: {
  alloc(): MSCopyActionAllocator;
}

interface MSPasteActionAllocator<InitializedType = MSPasteAction> extends MSDocumentActionAllocator<MSPasteAction> {}
interface MSPasteAction extends MSDocumentAction {
}
declare const MSPasteAction: {
  alloc(): MSPasteActionAllocator;
}

interface MSPasteWithStyleActionAllocator<InitializedType = MSPasteWithStyleAction> extends MSDocumentActionAllocator<MSPasteWithStyleAction> {}
interface MSPasteWithStyleAction extends MSDocumentAction {
}
declare const MSPasteWithStyleAction: {
  alloc(): MSPasteWithStyleActionAllocator;
}

interface MSPasteOverSelectionActionAllocator<InitializedType = MSPasteOverSelectionAction> extends MSDocumentActionAllocator<MSPasteOverSelectionAction> {}
interface MSPasteOverSelectionAction extends MSDocumentAction {
}
declare const MSPasteOverSelectionAction: {
  alloc(): MSPasteOverSelectionActionAllocator;
}

interface MSPasteHereActionAllocator<InitializedType = MSPasteHereAction> extends MSDocumentActionAllocator<MSPasteHereAction> {}
interface MSPasteHereAction extends MSDocumentAction {
}
declare const MSPasteHereAction: {
  alloc(): MSPasteHereActionAllocator;
}

interface MSDuplicateActionAllocator<InitializedType = MSDuplicateAction> extends MSDocumentActionAllocator<MSDuplicateAction> {}
interface MSDuplicateAction extends MSDocumentAction {
}
declare const MSDuplicateAction: {
  alloc(): MSDuplicateActionAllocator;
}

interface MSDeleteActionAllocator<InitializedType = MSDeleteAction> extends MSDocumentActionAllocator<MSDeleteAction> {}
interface MSDeleteAction extends MSDocumentAction {
}
declare const MSDeleteAction: {
  alloc(): MSDeleteActionAllocator;
}

interface MSCanvasPreferencePaneAllocator<InitializedType = MSCanvasPreferencePane> extends MSPreferencePaneAllocator<MSCanvasPreferencePane> {}
interface MSCanvasPreferencePane extends MSPreferencePane {
  adjustSnapColorAction(sender: any): IBAction;
  adjustFlowColorAction(sender: any): IBAction;

  flowColorWell(): NSColorWell;
  setFlowColorWell(flowColorWell: NSColorWell): void;
  flowColorLabel(): NSTextField;
  setFlowColorLabel(flowColorLabel: NSTextField): void;
}
declare const MSCanvasPreferencePane: {
  alloc(): MSCanvasPreferencePaneAllocator;
}

interface MSCanvasUpdatingSheetAllocator<InitializedType = MSCanvasUpdatingSheet> extends CHSheetControllerAllocator<MSCanvasUpdatingSheet> {}
interface MSCanvasUpdatingSheet extends CHSheetController {
  performOperation(): void;
  schedulePerformOperation(): void;
  triggerPerformOperation(): void;
  storeState(): void;
  restoreState(): void;
  historyMomentTitle(): NSString;
  doc(): MSDocument;
}
declare const MSCanvasUpdatingSheet: {
  alloc(): MSCanvasUpdatingSheetAllocator;
}

interface MSCenteredPopUpButtonCellAllocator<InitializedType = MSCenteredPopUpButtonCell> extends NSPopUpButtonCellAllocator<MSCenteredPopUpButtonCell> {}
interface MSCenteredPopUpButtonCell extends NSPopUpButtonCell {
}
declare const MSCenteredPopUpButtonCell: {
  alloc(): MSCenteredPopUpButtonCellAllocator;
}

interface MSChangeFontActionAllocator<InitializedType = MSChangeFontAction> extends MSDocumentActionAllocator<MSChangeFontAction> {}
interface MSChangeFontAction extends MSDocumentAction {
  changeTextLayerFont(sender: any): IBAction;
}
declare const MSChangeFontAction: {
  alloc(): MSChangeFontActionAllocator;
}

interface MSSilentCheckForUpdatesActionAllocator<InitializedType = MSSilentCheckForUpdatesAction> extends MSActionAllocator<MSSilentCheckForUpdatesAction> {}
interface MSSilentCheckForUpdatesAction extends MSAction {
}
declare const MSSilentCheckForUpdatesAction: {
  alloc(): MSSilentCheckForUpdatesActionAllocator;
}

interface MSQuietCheckForUpdatesActionAllocator<InitializedType = MSQuietCheckForUpdatesAction> extends MSSilentCheckForUpdatesActionAllocator<MSQuietCheckForUpdatesAction> {}
interface MSQuietCheckForUpdatesAction extends MSSilentCheckForUpdatesAction {
}
declare const MSQuietCheckForUpdatesAction: {
  alloc(): MSQuietCheckForUpdatesActionAllocator;
}

interface MSCheckForUpdatesActionAllocator<InitializedType = MSCheckForUpdatesAction> extends MSSilentCheckForUpdatesActionAllocator<MSCheckForUpdatesAction> {}
interface MSCheckForUpdatesAction extends MSSilentCheckForUpdatesAction {
  checkForUpdates(sender: any): IBAction;
}
declare const MSCheckForUpdatesAction: {
  alloc(): MSCheckForUpdatesActionAllocator;
}

interface MSClippingMaskActionAllocator<InitializedType = MSClippingMaskAction> extends MSDocumentActionAllocator<MSClippingMaskAction> {}
interface MSClippingMaskAction extends MSDocumentAction {
  clippingMask(sender: any): IBAction;
}
declare const MSClippingMaskAction: {
  alloc(): MSClippingMaskActionAllocator;
}

interface MSClippingMaskModeActionAllocator<InitializedType = MSClippingMaskModeAction> extends MSDocumentActionAllocator<MSClippingMaskModeAction> {}
interface MSClippingMaskModeAction extends MSDocumentAction {
  clippingMaskMode(sender: any): IBAction;
}
declare const MSClippingMaskModeAction: {
  alloc(): MSClippingMaskModeActionAllocator;
}

interface MSClosePathActionAllocator<InitializedType = MSClosePathAction> extends MSDocumentActionAllocator<MSClosePathAction> {}
interface MSClosePathAction extends MSDocumentAction {
  closePath(sender: any): IBAction;
}
declare const MSClosePathAction: {
  alloc(): MSClosePathActionAllocator;
}

interface MSCloudActionAllocator<InitializedType = MSCloudAction> extends MSPopoverActionAllocator<MSCloudAction> {}
interface MSCloudAction extends MSPopoverAction {
  startUploadUpdating(existingShare: SCKShare | null): void;
  refreshShareWithHandler(handler: Block): void;
  updateProgressImage(): void;

  exportedDocument(): any;
  upload(): MSCloudShareUploadController;
  setUpload(upload: MSCloudShareUploadController): void;
  refreshOperation(): SCKAPIOperation;
  setRefreshOperation(refreshOperation: SCKAPIOperation): void;
}
declare const MSCloudAction: {
  alloc(): MSCloudActionAllocator;  isErrorRecoverable(error: NSError): boolean;
  cloudError_addingRecoveryOptionsWithAttempter(error: NSError, attempter: any): NSError;
  attemptRecoveryFromCloudError_optionIndex(error: NSError, recoveryOptionIndex: NSUInteger): void;
  cloudEnabled(): boolean;
  openCloudUploadURL_parameters(url: NSURL, parameters: NSDictionary<any, any> | {[key: string]: any}): void;
  addRemoteLibraryWithURL_parameters(url: NSURL, parameters: NSDictionary<any, any> | {[key: string]: any}): void;

}

interface MSCloudAvatarViewAllocator<InitializedType = MSCloudAvatarView> extends NSViewAllocator<MSCloudAvatarView> {}
interface MSCloudAvatarView extends NSView {

  avatar(): SCKAvatar;
  setAvatar(avatar: SCKAvatar): void;
}
declare const MSCloudAvatarView: {
  alloc(): MSCloudAvatarViewAllocator;
}

interface MSCloudBaseViewControllerAllocator<InitializedType = MSCloudBaseViewController> extends MSToolbarPopoverContentViewControllerAllocator<MSCloudBaseViewController> {}
interface MSCloudBaseViewController extends MSToolbarPopoverContentViewController {
  cloudBaseViewControllerDidAppear(): void;

  cloudAction(): MSCloudAction;
  cloudViewController(): MSCloudViewController;
}
declare const MSCloudBaseViewController: {
  alloc(): MSCloudBaseViewControllerAllocator;
}

interface MSCloudDocumentViewControllerAllocator<InitializedType = MSCloudDocumentViewController> extends MSCloudBaseViewControllerAllocator<MSCloudDocumentViewController> {}
interface MSCloudDocumentViewController extends MSCloudBaseViewController {
}
declare const MSCloudDocumentViewController: {
  alloc(): MSCloudDocumentViewControllerAllocator;
}

interface MSCloudInitialViewControllerAllocator<InitializedType = MSCloudInitialViewController> extends MSCloudBaseViewControllerAllocator<MSCloudInitialViewController> {}
interface MSCloudInitialViewController extends MSCloudBaseViewController {
}
declare const MSCloudInitialViewController: {
  alloc(): MSCloudInitialViewControllerAllocator;
}

interface MSCloudInvalidLicenseViewControllerAllocator<InitializedType = MSCloudInvalidLicenseViewController> extends MSCloudBaseViewControllerAllocator<MSCloudInvalidLicenseViewController> {}
interface MSCloudInvalidLicenseViewController extends MSCloudBaseViewController {
}
declare const MSCloudInvalidLicenseViewController: {
  alloc(): MSCloudInvalidLicenseViewControllerAllocator;
}

interface MSCloudLoginWindowControllerAllocator<InitializedType = MSCloudLoginWindowController> extends NSWindowControllerAllocator<MSCloudLoginWindowController> {}
interface MSCloudLoginWindowController extends NSWindowController {

  delegate(): any;
  setDelegate(delegate: any): void;
  isLoading(): boolean;
  setIsLoading(isLoading: boolean): void;
  email(): NSString;
  setEmail(email: NSString | string): void;
  password(): NSString;
  setPassword(password: NSString | string): void;
}
declare const MSCloudLoginWindowController: {
  alloc(): MSCloudLoginWindowControllerAllocator;
}

interface IMSCloudLoginWindowControllerDelegate {
  cloudLoginControllerDidSignIn(controller: MSCloudLoginWindowController): void;
  cloudLoginControllerDidOpenBrowser(controller: MSCloudLoginWindowController): void;
  cloudLoginControllerDidCancel(controller: MSCloudLoginWindowController): void;
}

interface MSCloudPreferencePaneAllocator<InitializedType = MSCloudPreferencePane> extends MSPreferencePaneAllocator<MSCloudPreferencePane> {}
interface MSCloudPreferencePane extends MSPreferencePane {
  updateWindowFrame(): void;
}
declare const MSCloudPreferencePane: {
  alloc(): MSCloudPreferencePaneAllocator;  loginWithURLParameters(parameters: NSDictionary<any, any> | {[key: string]: any} | null): void;

}

interface MSCloudPreferencesAccountViewControllerAllocator<InitializedType = MSCloudPreferencesAccountViewController> extends MSCloudPreferencesViewControllerAllocator<MSCloudPreferencesAccountViewController> {}
interface MSCloudPreferencesAccountViewController extends MSCloudPreferencesViewController {
}
declare const MSCloudPreferencesAccountViewController: {
  alloc(): MSCloudPreferencesAccountViewControllerAllocator;
}

interface MSCloudPreferencesIntroViewControllerAllocator<InitializedType = MSCloudPreferencesIntroViewController> extends MSCloudPreferencesViewControllerAllocator<MSCloudPreferencesIntroViewController> {}
interface MSCloudPreferencesIntroViewController extends MSCloudPreferencesViewController {
}
declare const MSCloudPreferencesIntroViewController: {
  alloc(): MSCloudPreferencesIntroViewControllerAllocator;
}

interface MSCloudPreferencesViewControllerAllocator<InitializedType = MSCloudPreferencesViewController> extends NSViewControllerAllocator<MSCloudPreferencesViewController> {}
interface MSCloudPreferencesViewController extends NSViewController {
  popToRootViewController(sender: any | null): IBAction;
  showAlert(alert: NSAlert): void;

  preferencePane(): MSCloudPreferencePane;
}
declare const MSCloudPreferencesViewController: {
  alloc(): MSCloudPreferencesViewControllerAllocator;
}

interface MSCloudReuploadViewControllerAllocator<InitializedType = MSCloudReuploadViewController> extends MSCloudBaseViewControllerAllocator<MSCloudReuploadViewController> {}
interface MSCloudReuploadViewController extends MSCloudBaseViewController {
}
declare const MSCloudReuploadViewController: {
  alloc(): MSCloudReuploadViewControllerAllocator;
}

interface MSCloudRoundedViewAllocator<InitializedType = MSCloudRoundedView> extends NSViewAllocator<MSCloudRoundedView> {}
interface MSCloudRoundedView extends NSView {
}
declare const MSCloudRoundedView: {
  alloc(): MSCloudRoundedViewAllocator;
}

interface MSCloudShareCollectionItemAllocator<InitializedType = MSCloudShareCollectionItem> extends MSExistingDocumentCollectionItemAllocator<MSCloudShareCollectionItem> {
  initWithController_cloudShare(controller: MSWelcomeWindowController, share: SCKShare): InitializedType;
}
interface MSCloudShareCollectionItem extends MSExistingDocumentCollectionItem {
  downloadLatestDocument(handler: Block): void;

  cloudShare(): SCKShare;
  latestDocument(): SCKCloudDocument;
  downloadProgress(): NSProgress;
}
declare const MSCloudShareCollectionItem: {
  alloc(): MSCloudShareCollectionItemAllocator;
}

interface MSCloudUploadArrowViewAllocator<InitializedType = MSCloudUploadArrowView> extends NSViewAllocator<MSCloudUploadArrowView> {}
interface MSCloudUploadArrowView extends NSView {
  startAnimation(): void;
}
declare const MSCloudUploadArrowView: {
  alloc(): MSCloudUploadArrowViewAllocator;
}

interface MSCloudUploadFailedViewControllerAllocator<InitializedType = MSCloudUploadFailedViewController> extends MSCloudBaseViewControllerAllocator<MSCloudUploadFailedViewController> {}
interface MSCloudUploadFailedViewController extends MSCloudBaseViewController {

  error(): NSError;
  setError(error: NSError): void;
  existingShare(): SCKShare;
  setExistingShare(existingShare: SCKShare): void;
}
declare const MSCloudUploadFailedViewController: {
  alloc(): MSCloudUploadFailedViewControllerAllocator;
}

interface MSCloudUploadViewControllerAllocator<InitializedType = MSCloudUploadViewController> extends MSCloudBaseViewControllerAllocator<MSCloudUploadViewController> {}
interface MSCloudUploadViewController extends MSCloudBaseViewController {
}
declare const MSCloudUploadViewController: {
  alloc(): MSCloudUploadViewControllerAllocator;
}

interface MSCloudViewControllerAllocator<InitializedType = MSCloudViewController> extends NSViewControllerAllocator<MSCloudViewController> {
  initWithAction(action: MSCloudAction): InitializedType;
}
interface MSCloudViewController extends NSViewController {
  setContentViewController_animated(contentViewController: MSCloudBaseViewController, animated: boolean): void;
  resetContentViewController(sender: any): IBAction;
  updateFrame(): void;
  animateFrameWithCompletionHandler(handler: Block): void;

  action(): MSCloudAction;
  contentViewController(): MSCloudBaseViewController;
  setContentViewController(contentViewController: MSCloudBaseViewController): void;
}
declare const MSCloudViewController: {
  alloc(): MSCloudViewControllerAllocator;
}

interface MSCloudWelcomeViewControllerAllocator<InitializedType = MSCloudWelcomeViewController> extends MSCloudBaseViewControllerAllocator<MSCloudWelcomeViewController> {}
interface MSCloudWelcomeViewController extends MSCloudBaseViewController {
}
declare const MSCloudWelcomeViewController: {
  alloc(): MSCloudWelcomeViewControllerAllocator;
}

interface MSCollapseAllGroupsActionAllocator<InitializedType = MSCollapseAllGroupsAction> extends MSDocumentActionAllocator<MSCollapseAllGroupsAction> {}
interface MSCollapseAllGroupsAction extends MSDocumentAction {
  collapseAllGroups(sender: any): IBAction;
}
declare const MSCollapseAllGroupsAction: {
  alloc(): MSCollapseAllGroupsActionAllocator;
}

interface MSCollapsibleHeaderInspectorItemAllocator<InitializedType = MSCollapsibleHeaderInspectorItem> extends MSHeaderInspectorItemAllocator<MSCollapsibleHeaderInspectorItem> {}
interface MSCollapsibleHeaderInspectorItem extends MSHeaderInspectorItem {
  toggleCollapsed(sender: any): IBAction;

  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
}
declare const MSCollapsibleHeaderInspectorItem: {
  alloc(): MSCollapsibleHeaderInspectorItemAllocator;
}

interface IMSCollapsibleHeaderInspectorItemTarget {
  item_wantsSectionToCollapse(item: NSViewController, collapse: boolean): void;
}

interface MSCollectionViewAllocator<InitializedType = MSCollectionView> extends NSCollectionViewAllocator<MSCollectionView> {}
interface MSCollectionView extends NSCollectionView {
}
declare const MSCollectionView: {
  alloc(): MSCollectionViewAllocator;
}

interface MSColorComponentValueTextFieldAllocator<InitializedType = MSColorComponentValueTextField> extends MSUpDownTextFieldAllocator<MSColorComponentValueTextField> {}
interface MSColorComponentValueTextField extends MSUpDownTextField {

  counterpart(): MSColorComponentValueTextField;
  setCounterpart(counterpart: MSColorComponentValueTextField): void;
}
declare const MSColorComponentValueTextField: {
  alloc(): MSColorComponentValueTextFieldAllocator;
}

interface MSColorControlsInspectorViewControllerAllocator<InitializedType = MSColorControlsInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<MSColorControlsInspectorViewController> {}
interface MSColorControlsInspectorViewController extends MSStylePartInspectorViewController {
  reset(sender: any): IBAction;
}
declare const MSColorControlsInspectorViewController: {
  alloc(): MSColorControlsInspectorViewControllerAllocator;
}

interface MSColorInspectorAllocator<InitializedType = MSColorInspector> extends NSViewControllerAllocator<MSColorInspector> {
  initWithSender_document_handlerManager_globalAssets(delegate: any, document: MSDocument, manager: MSEventHandlerManager, globalAssets: MSPersistentAssetCollection): InitializedType;
}
interface MSColorInspector extends NSViewController, IMSColorInspectorSectionDelegate, IMSModeModePickerDelegate, IBCPopoverDelegate, INSTouchBarDelegate, IBCHSBColorPickerDelegate, IMSStylePartPreviewButtonDelegate {
  validateEnableButtons(): void;
  stack(): void;
  setColor(color: MSColor): void;
  colorPickerAction(sender: any): IBAction;
  refreshAction(sender: any): IBAction;
  colorMagnifierAction(sender: any): IBAction;
  setInitialColor(color: MSColor): void;
  setMaximumAvailableHeight(maxHeight: NSInteger): void;
  switchToColorTabAtIndex(index: NSUInteger): IBAction;
  colorTabIndex(): NSUInteger;

  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  colorPicker(): BCHSBColorPicker;
  setColorPicker(colorPicker: BCHSBColorPicker): void;
  emptyTopView(): NSView;
  setEmptyTopView(emptyTopView: NSView): void;
  colorPickerView(): NSView;
  setColorPickerView(colorPickerView: NSView): void;
}
declare const MSColorInspector: {
  alloc(): MSColorInspectorAllocator;  presentColorInspectorPopoverForViewController_document_globalAssets_relativeToView_colorInspectorSetupHandler(viewController: NSViewController, document: MSDocument, globalAssets: MSPersistentAssetCollection, positioningView: NSView, setupHandler: MSColorInspectorSetupBlock): BCPopover;
  presentColorInspectorPopoverForViewController_inspectorController_relativeToView_colorInspectorSetupHandler(viewController: NSViewController, inspectorController: MSInspectorController, positioningView: NSView, setupHandler: MSColorInspectorSetupBlock): BCPopover;

}

interface IMSColorInspectorDelegate {
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
}

interface MSColorInspectorModePickerActionAllocator<InitializedType = MSColorInspectorModePickerAction> extends MSDocumentActionAllocator<MSColorInspectorModePickerAction> {}
interface MSColorInspectorModePickerAction extends MSDocumentAction {
}
declare const MSColorInspectorModePickerAction: {
  alloc(): MSColorInspectorModePickerActionAllocator;
}

interface MSColorInspectorColorTabActionAllocator<InitializedType = MSColorInspectorColorTabAction> extends MSColorInspectorModePickerActionAllocator<MSColorInspectorColorTabAction> {}
interface MSColorInspectorColorTabAction extends MSColorInspectorModePickerAction {
}
declare const MSColorInspectorColorTabAction: {
  alloc(): MSColorInspectorColorTabActionAllocator;
}

interface MSColorInspectorLinearGradientTabActionAllocator<InitializedType = MSColorInspectorLinearGradientTabAction> extends MSColorInspectorModePickerActionAllocator<MSColorInspectorLinearGradientTabAction> {}
interface MSColorInspectorLinearGradientTabAction extends MSColorInspectorModePickerAction {
}
declare const MSColorInspectorLinearGradientTabAction: {
  alloc(): MSColorInspectorLinearGradientTabActionAllocator;
}

interface MSColorInspectorRadialGradientTabActionAllocator<InitializedType = MSColorInspectorRadialGradientTabAction> extends MSColorInspectorModePickerActionAllocator<MSColorInspectorRadialGradientTabAction> {}
interface MSColorInspectorRadialGradientTabAction extends MSColorInspectorModePickerAction {
}
declare const MSColorInspectorRadialGradientTabAction: {
  alloc(): MSColorInspectorRadialGradientTabActionAllocator;
}

interface MSColorInspectorCircularGradientTabActionAllocator<InitializedType = MSColorInspectorCircularGradientTabAction> extends MSColorInspectorModePickerActionAllocator<MSColorInspectorCircularGradientTabAction> {}
interface MSColorInspectorCircularGradientTabAction extends MSColorInspectorModePickerAction {
}
declare const MSColorInspectorCircularGradientTabAction: {
  alloc(): MSColorInspectorCircularGradientTabActionAllocator;
}

interface MSColorInspectorImageTabActionAllocator<InitializedType = MSColorInspectorImageTabAction> extends MSColorInspectorModePickerActionAllocator<MSColorInspectorImageTabAction> {}
interface MSColorInspectorImageTabAction extends MSColorInspectorModePickerAction {
}
declare const MSColorInspectorImageTabAction: {
  alloc(): MSColorInspectorImageTabActionAllocator;
}

interface MSColorInspectorModeBorderTouchBarGroupActionAllocator<InitializedType = MSColorInspectorModeBorderTouchBarGroupAction> extends MSActionGroupAllocator<MSColorInspectorModeBorderTouchBarGroupAction> {}
interface MSColorInspectorModeBorderTouchBarGroupAction extends MSActionGroup {
}
declare const MSColorInspectorModeBorderTouchBarGroupAction: {
  alloc(): MSColorInspectorModeBorderTouchBarGroupActionAllocator;
}

interface MSColorInspectorModeFillTouchBarGroupActionAllocator<InitializedType = MSColorInspectorModeFillTouchBarGroupAction> extends MSColorInspectorModeBorderTouchBarGroupActionAllocator<MSColorInspectorModeFillTouchBarGroupAction> {}
interface MSColorInspectorModeFillTouchBarGroupAction extends MSColorInspectorModeBorderTouchBarGroupAction {
}
declare const MSColorInspectorModeFillTouchBarGroupAction: {
  alloc(): MSColorInspectorModeFillTouchBarGroupActionAllocator;
}

interface MSColorInspectorSectionAllocator<InitializedType = MSColorInspectorSection> extends NSViewControllerAllocator<MSColorInspectorSection> {
  initWithDelegate(delegate: any): InitializedType;
}
interface MSColorInspectorSection extends NSViewController {
  validate(): void;
  popoverWillClose(): void;
  isEnabled(): boolean;
  hasPresetPickers(): boolean;
  fillType(): NSInteger;
  assetCollectionForPresetPicker(picker: MSAssetPickerView): MSAssetCollection;
  refreshAction(sender: any): IBAction;
  colorPickerChangedTo(color: MSColor): void;
  reloadPresetPicker(): void;
  viewsWithColorPickerView_blendingView_topViewIsEmpty(colorPickerView: NSView, blendingView: NSView, topViewIsEmpty: boolean): NSArray<any>;
  assetPickerViews(): NSArray<any>;
  assetPickerViewKeys(): NSDictionary<any, any>;
  customTouchBarItemIdentifiers(): NSArray<any>;
  makeTouchBarItemForIdentifier(identifier: NSString | string): NSTouchBarItem;
  assetType(): MSAsset;
  numberOfAssetsForPickerView(picker: MSAssetPickerView): NSUInteger;
  addAsset_forPickerView(asset: any, picker: MSAssetPickerView): void;
  insertAsset_atIndex_forPickerView(asset: any, index: NSUInteger, picker: MSAssetPickerView): void;
  assetAtIndex_forPickerView(index: NSUInteger, picker: MSAssetPickerView): any;
  removeAssetAtIndex_forPickerView(index: NSUInteger, picker: MSAssetPickerView): void;
  indexesOfAsset_forPickerView(asset: any, picker: MSAssetPickerView): NSIndexSet;
  moveAssetAtIndex_beforeObjectAtIndex_ForPickerView(fromIndex: NSUInteger, toIndex: NSUInteger, picker: MSAssetPickerView): boolean;
  scrollViewWithStackedViews(scrollableViews: NSArray<any> | any[]): NSScrollView;
  minimumHeight(): CGFloat;
  colorAssetCollectionLabelWithTitle(title: NSString | string): NSTextField;
  fittingAssetScrubberLabelItemSizeForTitle(title: NSString | string): NSSize;

  delegate(): any;
  setDelegate(delegate: any): void;
  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
}
declare const MSColorInspectorSection: {
  alloc(): MSColorInspectorSectionAllocator;  refreshColorPickerViewHeight(colorPickerView: NSView): void;

}

interface MSColorInspectorSectionColorAllocator<InitializedType = MSColorInspectorSectionColor> extends MSColorInspectorSectionAllocator<MSColorInspectorSectionColor> {}
interface MSColorInspectorSectionColor extends MSColorInspectorSection {

  pickedColor(): MSColor;
  setPickedColor(pickedColor: MSColor): void;
}
declare const MSColorInspectorSectionColor: {
  alloc(): MSColorInspectorSectionColorAllocator;
}

interface IMSColorInspectorSectionDelegate {
  colorDidChangeTo(color: MSColor): void;
  inspectorSectionDidUpdate(pattern: MSColorInspectorSectionPattern): void;
  documentAssets(): MSAssetCollection;
  globalAssets(): MSPersistentAssetCollection;
  eventHandlerManager(): MSEventHandlerManager;
  stack(): void;
  didAddAsset(asset: any): void;
  didRemoveAssetOfType(assetType: MSAsset): void;
  touchBar(): NSTouchBar;

  document(): MSDocument;
}

interface MSColorInspectorSectionGradientAllocator<InitializedType = MSColorInspectorSectionGradient> extends MSColorInspectorSectionAllocator<MSColorInspectorSectionGradient> {}
interface MSColorInspectorSectionGradient extends MSColorInspectorSection, IMSGradientEventHandlerDelegate, IMSGradientBarViewDelegate {
  switchToGradientHandler(): void;
  gradientBarAction(sender: any): IBAction;
  rotateGradientAction(sender: any): IBAction;
  closeGradientHandler(): void;
  switchToGradientHandlerIfNecessary(): void;

  gradientBarParentView(): NSView;
  setGradientBarParentView(gradientBarParentView: NSView): void;
  gradientBarView(): MSGradientBarView;
  setGradientBarView(gradientBarView: MSGradientBarView): void;
}
declare const MSColorInspectorSectionGradient: {
  alloc(): MSColorInspectorSectionGradientAllocator;
}

interface MSColorInspectorSectionNoiseAllocator<InitializedType = MSColorInspectorSectionNoise> extends MSColorInspectorSectionAllocator<MSColorInspectorSectionNoise> {}
interface MSColorInspectorSectionNoise extends MSColorInspectorSection {
}
declare const MSColorInspectorSectionNoise: {
  alloc(): MSColorInspectorSectionNoiseAllocator;
}

interface MSColorInspectorSectionPatternAllocator<InitializedType = MSColorInspectorSectionPattern> extends MSColorInspectorSectionAllocator<MSColorInspectorSectionPattern> {}
interface MSColorInspectorSectionPattern extends MSColorInspectorSection {
  choosePatternImage(sender: any): IBAction;
  patternWellAction(sender: any): IBAction;
  updatePatternWellImage(): void;

  patternWell(): NSImageView;
  setPatternWell(patternWell: NSImageView): void;
  choosePatternButton(): NSButton;
  setChoosePatternButton(choosePatternButton: NSButton): void;
  patternTilButton(): NSPopUpButton;
  setPatternTilButton(patternTilButton: NSPopUpButton): void;
}
declare const MSColorInspectorSectionPattern: {
  alloc(): MSColorInspectorSectionPatternAllocator;
}

interface MSColorPickerBackgroundViewAllocator<InitializedType = MSColorPickerBackgroundView> extends NSViewAllocator<MSColorPickerBackgroundView> {}
interface MSColorPickerBackgroundView extends NSView {
}
declare const MSColorPickerBackgroundView: {
  alloc(): MSColorPickerBackgroundViewAllocator;
}

interface MSColorStylePartInspectorViewControllerAllocator<InitializedType = MSColorStylePartInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<MSColorStylePartInspectorViewController> {}
interface MSColorStylePartInspectorViewController extends MSStylePartInspectorViewController {
  updateColorInActiveInspector(): void;
  previewCellAction(sender: any): IBAction;
  checkBoxAction(sender: any): IBAction;

  colorButton(): MSStylePartPreviewButton;
  setColorButton(colorButton: MSStylePartPreviewButton): void;
}
declare const MSColorStylePartInspectorViewController: {
  alloc(): MSColorStylePartInspectorViewControllerAllocator;
}

interface MSCommandAllocator<InitializedType = MSCommand> extends NSObjectAllocator<MSCommand> {}
interface MSCommand extends NSObject {
  run(): any;
}
declare const MSCommand: {
  alloc(): MSCommandAllocator;  runWithArguments(block: MSCommandPreparation): any;

}

interface MSConstraintActionAllocator<InitializedType = MSConstraintAction> extends MSDocumentActionAllocator<MSConstraintAction> {}
interface MSConstraintAction extends MSDocumentAction {

  actionKeyPath(): NSString;
  validationKeyPath(): NSString;
}
declare const MSConstraintAction: {
  alloc(): MSConstraintActionAllocator;
}

interface MSConstraintPinLeftActionAllocator<InitializedType = MSConstraintPinLeftAction> extends MSConstraintActionAllocator<MSConstraintPinLeftAction> {}
interface MSConstraintPinLeftAction extends MSConstraintAction {
  pinLeftAction(sender: any): IBAction;
}
declare const MSConstraintPinLeftAction: {
  alloc(): MSConstraintPinLeftActionAllocator;
}

interface MSConstraintPinRightActionAllocator<InitializedType = MSConstraintPinRightAction> extends MSConstraintActionAllocator<MSConstraintPinRightAction> {}
interface MSConstraintPinRightAction extends MSConstraintAction {
  pinRightAction(sender: any): IBAction;
}
declare const MSConstraintPinRightAction: {
  alloc(): MSConstraintPinRightActionAllocator;
}

interface MSConstraintPinTopActionAllocator<InitializedType = MSConstraintPinTopAction> extends MSConstraintActionAllocator<MSConstraintPinTopAction> {}
interface MSConstraintPinTopAction extends MSConstraintAction {
  pinTopAction(sender: any): IBAction;
}
declare const MSConstraintPinTopAction: {
  alloc(): MSConstraintPinTopActionAllocator;
}

interface MSConstraintPinBottomActionAllocator<InitializedType = MSConstraintPinBottomAction> extends MSConstraintActionAllocator<MSConstraintPinBottomAction> {}
interface MSConstraintPinBottomAction extends MSConstraintAction {
  pinBottomAction(sender: any): IBAction;
}
declare const MSConstraintPinBottomAction: {
  alloc(): MSConstraintPinBottomActionAllocator;
}

interface MSConstraintFixWidthActionAllocator<InitializedType = MSConstraintFixWidthAction> extends MSConstraintActionAllocator<MSConstraintFixWidthAction> {}
interface MSConstraintFixWidthAction extends MSConstraintAction {
  fixWidthAction(sender: any): IBAction;
}
declare const MSConstraintFixWidthAction: {
  alloc(): MSConstraintFixWidthActionAllocator;
}

interface MSConstraintFixHeightActionAllocator<InitializedType = MSConstraintFixHeightAction> extends MSConstraintActionAllocator<MSConstraintFixHeightAction> {}
interface MSConstraintFixHeightAction extends MSConstraintAction {
  fixHeightAction(sender: any): IBAction;
}
declare const MSConstraintFixHeightAction: {
  alloc(): MSConstraintFixHeightActionAllocator;
}

interface MSConstraintResetActionAllocator<InitializedType = MSConstraintResetAction> extends MSDocumentActionAllocator<MSConstraintResetAction> {}
interface MSConstraintResetAction extends MSDocumentAction {
  resetConstraintAction(sender: any): IBAction;
}
declare const MSConstraintResetAction: {
  alloc(): MSConstraintResetActionAllocator;
}

interface MSContentDrawViewAllocator<InitializedType = MSContentDrawView> extends NSViewAllocator<MSContentDrawView> {}
interface MSContentDrawView extends NSView, IMSEventHandlerManagerDelegate, IMSTiledRendererHostView {
  setNeedsUpdateCursor(): void;
  scheduleRedraw(): void;
  redrawContentImmediately(): void;
  centerDocumentAndPlaceScrollOriginInTopLeft(): void;
  placeOriginInTopLeft(): void;
  currentPage(): MSPage;
  animateToZoom_scalingCenteredOnAbsoluteCoordinates(zoom: CGFloat, midPoint: NSPoint): void;
  animateToViewPort(viewPort: MSViewPort): void;
  zoomIn(): void;
  zoomOut(): void;
  zoomToActualSizeAnimated(animated: boolean): void;
  animateToZoom(zoom: CGFloat): void;
  endZoomToolMode(): void;
  prepare(): void;
  refreshAfterSettingsChange(): void;
  renderOverlayInRect_context_pageOverlayRenderOptions(rect: NSRect, context: CGContextRef, pageOverlayRenderOptions: MSPageOverlayRenderOptions): void;
  centerLayersInCanvas(): void;
  centerSelectionInVisibleArea(): void;
  centerRect(rect: NSRect): void;
  centerRect_animated(rect: NSRect, animated: boolean): void;
  zoomToFitRect(rect: NSRect): void;
  viewPortForZoomToFitRect(rect: NSRect): MSViewPort;
  viewPortWithCenter_zoomValue(center: NSPoint, zoom: CGFloat): MSViewPort;
  selectToolbarItemWithIdentifier(identifier: NSString | string): void;
  visibleContentRect(): NSRect;
  scrollToScrollOrigin(scrollOrigin: NSPoint): void;
  displayPropertiesDidChange(): void;
  pageDidChange(page: MSPage): void;
  windowDidResize(note: NSNotification): void;
  pixelGridDidChange(): void;
  ignoreNextKeyDownEventUntilModifiersChange(): void;
  layerPositionPossiblyChanged(): void;
  convertPoint_toLayer(point: NSPoint, layer: MSLayer): NSPoint;
  convertPointFromPage(aPoint: NSPoint): NSPoint;
  convertSizeToPage(aSize: NSSize): NSSize;

  tiledRenderer(): MSTiledRenderer;
  contentDrawViewParent(): MSContentDrawViewParent;
  setContentDrawViewParent(contentDrawViewParent: MSContentDrawViewParent): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  eventHandlerManager(): MSEventHandlerManager;
  setEventHandlerManager(eventHandlerManager: MSEventHandlerManager): void;
  viewPort(): MSViewPort;
  setViewPort(viewPort: MSViewPort): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  shouldHideOverlayControls(): boolean;
  setShouldHideOverlayControls(shouldHideOverlayControls: boolean): void;
  measurementLabelNumberFormatter(): NSNumberFormatter;
  pendingMonitor(): MSRenderMonitor;
  setPendingMonitor(pendingMonitor: MSRenderMonitor): void;
  driver(): MSRenderingDriver;
  cacheManager(): MSCacheManager;
  setCacheManager(cacheManager: MSCacheManager): void;
  mouseTracker(): MSMouseTracker;
  didMouseDown(): boolean;
  handToolState(): MSHandToolState;
  setHandToolState(handToolState: MSHandToolState): void;
  needsUpdateCursor(): boolean;
  zoomTool(): MSZoomTool;
}
declare const MSContentDrawView: {
  alloc(): MSContentDrawViewAllocator;
}

interface IMSContentDrawViewDelegate {

  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}

declare enum MSHandToolState {
  MSHandToolStateInactive,
  MSHandToolStateActive,
  MSHandToolStateDragging,
}

interface MSContentDrawViewControllerAllocator<InitializedType = MSContentDrawViewController> extends NSViewControllerAllocator<MSContentDrawViewController> {}
interface MSContentDrawViewController extends NSViewController, IMSContentDrawViewDelegate {
  currentArtboardDidChange(): void;
  changeToPage(page: MSPage): void;
  prepareForDealloc(): void;

  contentDrawView(): MSContentDrawView;
  setContentDrawView(contentDrawView: MSContentDrawView): void;
  contentDrawViewParent(): MSContentDrawViewParent;
  setContentDrawViewParent(contentDrawViewParent: MSContentDrawViewParent): void;
  horizontalRuler(): MSRulerView;
  setHorizontalRuler(horizontalRuler: MSRulerView): void;
  verticalRuler(): MSRulerView;
  setVerticalRuler(verticalRuler: MSRulerView): void;
  rulerCornerView(): NSView;
  setRulerCornerView(rulerCornerView: NSView): void;
  rulerWidthConstraint(): NSLayoutConstraint;
  setRulerWidthConstraint(rulerWidthConstraint: NSLayoutConstraint): void;
  rulerHeightConstraint(): NSLayoutConstraint;
  setRulerHeightConstraint(rulerHeightConstraint: NSLayoutConstraint): void;
  flashController(): MSFlashController;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
}
declare const MSContentDrawViewController: {
  alloc(): MSContentDrawViewControllerAllocator;
}

interface MSContentDrawViewParentAllocator<InitializedType = MSContentDrawViewParent> extends NSViewAllocator<MSContentDrawViewParent> {}
interface MSContentDrawViewParent extends NSView {

  contentDrawView(): MSContentDrawView;
  setContentDrawView(contentDrawView: MSContentDrawView): void;
}
declare const MSContentDrawViewParent: {
  alloc(): MSContentDrawViewParentAllocator;
}

interface MSConvertFlowToHotspotActionAllocator<InitializedType = MSConvertFlowToHotspotAction> extends MSFlowBaseActionAllocator<MSConvertFlowToHotspotAction> {}
interface MSConvertFlowToHotspotAction extends MSFlowBaseAction {
  convertFlowToHotspot(sender: any): IBAction;
}
declare const MSConvertFlowToHotspotAction: {
  alloc(): MSConvertFlowToHotspotActionAllocator;
}

interface MSConvertSymbolOrDetachInstancesActionAllocator<InitializedType = MSConvertSymbolOrDetachInstancesAction> extends MSDocumentActionAllocator<MSConvertSymbolOrDetachInstancesAction> {}
interface MSConvertSymbolOrDetachInstancesAction extends MSDocumentAction {
  detachSymbolInstances(sender: any): IBAction;
}
declare const MSConvertSymbolOrDetachInstancesAction: {
  alloc(): MSConvertSymbolOrDetachInstancesActionAllocator;
}

interface MSConvertToOutlinesActionAllocator<InitializedType = MSConvertToOutlinesAction> extends MSDocumentActionAllocator<MSConvertToOutlinesAction> {}
interface MSConvertToOutlinesAction extends MSDocumentAction {
  convertToOutlines(sender: any): IBAction;
}
declare const MSConvertToOutlinesAction: {
  alloc(): MSConvertToOutlinesActionAllocator;
}

interface MSCopySVGCodeActionAllocator<InitializedType = MSCopySVGCodeAction> extends MSDocumentActionAllocator<MSCopySVGCodeAction> {}
interface MSCopySVGCodeAction extends MSDocumentAction {
  copySVG(sender: any): IBAction;
}
declare const MSCopySVGCodeAction: {
  alloc(): MSCopySVGCodeActionAllocator;
}

interface MSCopyStyleActionAllocator<InitializedType = MSCopyStyleAction> extends MSDocumentActionAllocator<MSCopyStyleAction> {}
interface MSCopyStyleAction extends MSDocumentAction {
  copyStyle(sender: any): IBAction;
}
declare const MSCopyStyleAction: {
  alloc(): MSCopyStyleActionAllocator;
}

interface MSPasteStyleActionAllocator<InitializedType = MSPasteStyleAction> extends MSDocumentActionAllocator<MSPasteStyleAction> {}
interface MSPasteStyleAction extends MSDocumentAction {
  pasteStyle(sender: any): IBAction;
}
declare const MSPasteStyleAction: {
  alloc(): MSPasteStyleActionAllocator;
}

interface MSCopyCSSAttributesActionAllocator<InitializedType = MSCopyCSSAttributesAction> extends MSDocumentActionAllocator<MSCopyCSSAttributesAction> {}
interface MSCopyCSSAttributesAction extends MSDocumentAction {
  copyCSSAttributes(sender: any): IBAction;
}
declare const MSCopyCSSAttributesAction: {
  alloc(): MSCopyCSSAttributesActionAllocator;
}

interface MSCrashLogManagerAllocator<InitializedType = MSCrashLogManager> extends NSObjectAllocator<MSCrashLogManager> {}
interface MSCrashLogManager extends NSObject, IMSActionObserver, IBITHockeyManagerDelegate, IBITCrashManagerDelegate {
  setEnvironmentValue_forKey(value: NSString | string, key: NSString | string): void;
  log(text: NSString | string): void;
  setup(): boolean;

  text(): NSString;
}
declare const MSCrashLogManager: {
  alloc(): MSCrashLogManagerAllocator;
}

interface MSCreateDetachSymbolButtonCellAllocator<InitializedType = MSCreateDetachSymbolButtonCell> extends MSHoverButtonCellAllocator<MSCreateDetachSymbolButtonCell> {}
interface MSCreateDetachSymbolButtonCell extends MSHoverButtonCell {

  artboardPreviewImage(): NSImage;
  setArtboardPreviewImage(artboardPreviewImage: NSImage): void;
}
declare const MSCreateDetachSymbolButtonCell: {
  alloc(): MSCreateDetachSymbolButtonCellAllocator;
}

interface MSCreateSharedStyleActionAllocator<InitializedType = MSCreateSharedStyleAction> extends MSBaseSharedObjectActionAllocator<MSCreateSharedStyleAction> {}
interface MSCreateSharedStyleAction extends MSBaseSharedObjectAction {
  createSharedStyle(sender: any): IBAction;
}
declare const MSCreateSharedStyleAction: {
  alloc(): MSCreateSharedStyleActionAllocator;
}

interface MSCreateSymbolActionAllocator<InitializedType = MSCreateSymbolAction> extends MSDocumentActionAllocator<MSCreateSymbolAction> {}
interface MSCreateSymbolAction extends MSDocumentAction {
  createSymbolAction(sender: any): IBAction;
}
declare const MSCreateSymbolAction: {
  alloc(): MSCreateSymbolActionAllocator;
}

interface MSCreateSymbolNamingSheetAllocator<InitializedType = MSCreateSymbolNamingSheet> extends CHSheetControllerAllocator<MSCreateSymbolNamingSheet> {}
interface MSCreateSymbolNamingSheet extends CHSheetController {
  setSymbolPageName(symbolPageName: NSString | string): void;
  setSuggestedName(suggestedName: NSString | string): void;
  setShouldShowMoveCheckbox(showCheckbox: boolean): void;

  symbolNameField(): NSTextField;
  setSymbolNameField(symbolNameField: NSTextField): void;
  symbolPageField(): NSTextField;
  setSymbolPageField(symbolPageField: NSTextField): void;
  completionBlock(): MSCreateSymbolCompletionBlock;
  setCompletionBlock(completionBlock: MSCreateSymbolCompletionBlock): void;
}
declare const MSCreateSymbolNamingSheet: {
  alloc(): MSCreateSymbolNamingSheetAllocator;
}

interface MSCursorButtonAllocator<InitializedType = MSCursorButton> extends NSButtonAllocator<MSCursorButton> {}
interface MSCursorButton extends NSButton {

  cursor(): NSCursor;
  setCursor(cursor: NSCursor): void;
}
declare const MSCursorButton: {
  alloc(): MSCursorButtonAllocator;
}

interface MSCurveModeAdjustActionAllocator<InitializedType = MSCurveModeAdjustAction> extends MSDocumentActionAllocator<MSCurveModeAdjustAction> {}
interface MSCurveModeAdjustAction extends MSDocumentAction {
}
declare const MSCurveModeAdjustAction: {
  alloc(): MSCurveModeAdjustActionAllocator;
}

interface MSCurveModeStraightActionAllocator<InitializedType = MSCurveModeStraightAction> extends MSCurveModeAdjustActionAllocator<MSCurveModeStraightAction> {}
interface MSCurveModeStraightAction extends MSCurveModeAdjustAction {
}
declare const MSCurveModeStraightAction: {
  alloc(): MSCurveModeStraightActionAllocator;
}

interface MSCurveModeMirroredActionAllocator<InitializedType = MSCurveModeMirroredAction> extends MSCurveModeAdjustActionAllocator<MSCurveModeMirroredAction> {}
interface MSCurveModeMirroredAction extends MSCurveModeAdjustAction {
}
declare const MSCurveModeMirroredAction: {
  alloc(): MSCurveModeMirroredActionAllocator;
}

interface MSCurveModeDisconnectedActionAllocator<InitializedType = MSCurveModeDisconnectedAction> extends MSCurveModeAdjustActionAllocator<MSCurveModeDisconnectedAction> {}
interface MSCurveModeDisconnectedAction extends MSCurveModeAdjustAction {
}
declare const MSCurveModeDisconnectedAction: {
  alloc(): MSCurveModeDisconnectedActionAllocator;
}

interface MSCurveModeAsymmetricActionAllocator<InitializedType = MSCurveModeAsymmetricAction> extends MSCurveModeAdjustActionAllocator<MSCurveModeAsymmetricAction> {}
interface MSCurveModeAsymmetricAction extends MSCurveModeAdjustAction {
}
declare const MSCurveModeAsymmetricAction: {
  alloc(): MSCurveModeAsymmetricActionAllocator;
}

interface MSCurveModeTouchGroupActionAllocator<InitializedType = MSCurveModeTouchGroupAction> extends MSActionGroupAllocator<MSCurveModeTouchGroupAction> {}
interface MSCurveModeTouchGroupAction extends MSActionGroup {
}
declare const MSCurveModeTouchGroupAction: {
  alloc(): MSCurveModeTouchGroupActionAllocator;
}

interface MSDataActionAllocator<InitializedType = MSDataAction> extends MSDocumentActionAllocator<MSDataAction> {}
interface MSDataAction extends MSDocumentAction, IMSDataMenuProviderDelegate, INSMenuDelegate {
}
declare const MSDataAction: {
  alloc(): MSDataActionAllocator;
}

interface MSDataMenuActionAllocator<InitializedType = MSDataMenuAction> extends MSDocumentActionAllocator<MSDataMenuAction> {}
interface MSDataMenuAction extends MSDocumentAction {
}
declare const MSDataMenuAction: {
  alloc(): MSDataMenuActionAllocator;
}

interface MSDataPreferenceItemAllocator<InitializedType = MSDataPreferenceItem> extends NSObjectAllocator<MSDataPreferenceItem> {}
interface MSDataPreferenceItem extends NSObject {

  data(): MSDataSupplier;
  name(): NSString;
  preview(): NSImage;
  setPreview(preview: NSImage): void;
  secondaryTitle(): NSString;
  valid(): boolean;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  canRevealInFinder(): boolean;
  localData(): MSLocalDataSupplier;
  pluginData(): MSPluginDataSupplier;
  pluginBundleIcon(): NSImage;
  primaryTextFieldColor(): NSColor;
  secondaryTextFieldColor(): NSColor;
  cellView(): MSDataTableCellView;
  setCellView(cellView: MSDataTableCellView): void;
}
declare const MSDataPreferenceItem: {
  alloc(): MSDataPreferenceItemAllocator;  preferenceItemForLocalData(localData: MSDataSupplier): MSDataPreferenceItem;

}

interface MSDataPreferencePaneAllocator<InitializedType = MSDataPreferencePane> extends MSPreferencePaneAllocator<MSDataPreferencePane> {}
interface MSDataPreferencePane extends MSPreferencePane, INSTableViewDelegate, INSTableViewDataSource {

  tableView(): MSDataTableView;
  setTableView(tableView: MSDataTableView): void;
  dataArrayController(): NSArrayController;
  setDataArrayController(dataArrayController: NSArrayController): void;
  data(): NSArray<any>;
  dataSupplierManager(): MSDataSupplierManager;
}
declare const MSDataPreferencePane: {
  alloc(): MSDataPreferencePaneAllocator;
}

interface MSDataPreviewAllocator<InitializedType = MSDataPreview> extends NSViewAllocator<MSDataPreview> {}
interface MSDataPreview extends NSView {

  dataItem(): MSDataPreferenceItem;
  setDataItem(dataItem: MSDataPreferenceItem): void;
}
declare const MSDataPreview: {
  alloc(): MSDataPreviewAllocator;
}

interface MSDataTableCellViewAllocator<InitializedType = MSDataTableCellView> extends NSTableCellViewAllocator<MSDataTableCellView> {}
interface MSDataTableCellView extends NSTableCellView {

  dataPreferenceItem(): MSDataPreferenceItem;
}
declare const MSDataTableCellView: {
  alloc(): MSDataTableCellViewAllocator;
}

interface MSDataTableViewAllocator<InitializedType = MSDataTableView> extends BCKeyEventActionTableViewAllocator<MSDataTableView> {}
interface MSDataTableView extends BCKeyEventActionTableView {
}
declare const MSDataTableView: {
  alloc(): MSDataTableViewAllocator;
}

interface MSDefaultStyleActionAllocator<InitializedType = MSDefaultStyleAction> extends MSDocumentActionAllocator<MSDefaultStyleAction> {}
interface MSDefaultStyleAction extends MSDocumentAction {
  setStyleAsDefault(sender: any): IBAction;
}
declare const MSDefaultStyleAction: {
  alloc(): MSDefaultStyleActionAllocator;
}

interface MSDetachSharedStyleActionAllocator<InitializedType = MSDetachSharedStyleAction> extends MSBaseSharedObjectActionAllocator<MSDetachSharedStyleAction> {}
interface MSDetachSharedStyleAction extends MSBaseSharedObjectAction {
  detachSharedStyle(sender: any): IBAction;
}
declare const MSDetachSharedStyleAction: {
  alloc(): MSDetachSharedStyleActionAllocator;
}

interface MSDisabledButtonCellAllocator<InitializedType = MSDisabledButtonCell> extends NSButtonCellAllocator<MSDisabledButtonCell> {}
interface MSDisabledButtonCell extends NSButtonCell {
}
declare const MSDisabledButtonCell: {
  alloc(): MSDisabledButtonCellAllocator;
}

interface MSDistributeActionAllocator<InitializedType = MSDistributeAction> extends MSDocumentActionAllocator<MSDistributeAction> {}
interface MSDistributeAction extends MSDocumentAction {
  distributeAlongAxis(axis: BCAxis): void;
}
declare const MSDistributeAction: {
  alloc(): MSDistributeActionAllocator;
}

interface MSDistributeHorizontallyActionAllocator<InitializedType = MSDistributeHorizontallyAction> extends MSDistributeActionAllocator<MSDistributeHorizontallyAction> {}
interface MSDistributeHorizontallyAction extends MSDistributeAction {
  distributeHorizontally(sender: any): IBAction;
}
declare const MSDistributeHorizontallyAction: {
  alloc(): MSDistributeHorizontallyActionAllocator;
}

interface MSDistributeVerticallyActionAllocator<InitializedType = MSDistributeVerticallyAction> extends MSDistributeActionAllocator<MSDistributeVerticallyAction> {}
interface MSDistributeVerticallyAction extends MSDistributeAction {
  distributeVertically(sender: any): IBAction;
}
declare const MSDistributeVerticallyAction: {
  alloc(): MSDistributeVerticallyActionAllocator;
}

interface MSDistributeActionsAllocator<InitializedType = MSDistributeActions> extends MSActionGroupAllocator<MSDistributeActions> {}
interface MSDistributeActions extends MSActionGroup {
}
declare const MSDistributeActions: {
  alloc(): MSDistributeActionsAllocator;
}

interface MSDocumentAllocator<InitializedType = MSDocument> extends NSDocumentAllocator<MSDocument> {}
interface MSDocument extends NSDocument, INSMenuDelegate, INSToolbarDelegate, INSWindowDelegate, IMSEventHandlerManagerDelegate, IMSDocumentDataDelegate, IMSMenuBuilderDelegate {
  actionClasses(): NSArray<any>;
  addLayerFromImageAtURL_toGroup_fitPixels_error(fileURL: NSURL, group: MSLayerGroup, fitPixels: boolean, outError: NSError): MSLayer;
  askForUserInput_initialValue(label: NSString | string, defaultString: NSString | string): NSString;
  askForUserInput_ofType_initialValue(label: NSString | string, type: MSModalInputTypes, defaultString: NSString | string): NSString;
  saveArtboardOrSlice_toFile(artboardOrSlice: any, filename: NSString | string): void;
  dataForRequest_ofType(request: MSExportRequest, extension: NSString | string): NSData;
  showMessage(message: NSString | string): void;
  pluginContext(): NSDictionary<any, any>;
  saveDocumentToURL_saveMode_context_callback(url: NSURL, saveMode: NSSaveOperationType, coscript: COScript, callback: MOJavaScriptObject | Function): void;
  contentDrawView(): MSContentDrawView;
  window(): NSWindow;
  setCurrentArtboard(newArtboard: MSArtboardGroup): void;
  selectedLayers(): MSLayerArray;
  changeToImmutableDocumentData_selecting_onPage(documentData: MSImmutableDocumentData, selection: NSSet<any>, pageID: NSString | string): void;
  commitHistoryIfNecessary(sender: any): void;
  addLayer(layer: MSLayer): void;
  addLayer_changeName(layer: MSLayer, changeName: boolean): void;
  currentPage(): MSPage;
  validateMenuItem(item: NSMenuItem): boolean;
  toolbar(): NSToolbar;
  selectToolbarItemWithIdentifier(anIdentifier: NSString | string): void;
  createActions(): void;
  shouldCreateToolbar(): boolean;
  resetDocumentData(newData: MSDocumentData): void;
  deleteSymbolMasters(array: NSArray<any> | any[]): void;
  setCurrentPage(page: any): void;
  refreshSidebarWithMask(mask: BCSideBarRefreshType): void;
  updateFilterSettings(): void;
  reloadInspector(): void;
  reloadView(): void;
  refreshWindowBadge(): void;
  layerStyles(): MSSharedStyleContainer;
  pages(): NSArray<any>;
  isLayerListVisible(): boolean;
  isInspectorVisible(): boolean;
  toggleClickThrough(sender: any): IBAction;
  exportSliceLayers(sliceLayers: NSArray<any> | any[]): void;
  allExportableLayers(): NSArray<any>;
  currentArtboardDidChange(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  addBlankPage(): MSPage;
  removePage(page: MSPage): void;
  hasArtboards(): boolean;
  currentHorizontalRulerData(): MSRulerData;
  currentVerticalRulerData(): MSRulerData;
  isRulersVisible(): boolean;
  layerPositionPossiblyChanged(): void;
  zoomValueDidChange(): void;
  debugCountObjects(sender: any): IBAction;
  shouldDrawSelectionForLayer(layer: MSLayer): boolean;
  temporarilyDisableSelectionHidingDuringBlock(block: BCVoidBlock): void;
  isShowingMeasurements(): boolean;
  visitArtboardForInstance(instance: MSSymbolInstance): void;
  openLibrariesForForeignObjects(objects: NSArray<any> | any[]): void;
  restoreViewportAfterArtboardEdit(artboard: MSArtboardGroup): void;
  removeViewportForArtboard(artboard: MSArtboardGroup): void;
  canRestoreViewportAfterArtboardEdit(artboard: MSArtboardGroup): boolean;
  visitSymbolMasterWithID(symbolID: NSString | string): void;
  reloadTouchBars(): void;
  localObjectForObjectReference(ref: MSShareableObjectReference): MSShareableObject;
  symbolReferenceForRecipe(recipe: MSSymbolMasterReferenceDescriptor): MSSymbolMasterReference;
  showNonDefaultColorSpaceWarningIfApplicable(): void;
  returnToDefaultFirstResponder(): void;
  installedFontsDidChange(): void;
  historyMaker_didApplyHistoryUpdate(maker: MSHistoryMaker, update: MSHistoryUpdate): void;
  historyMakerDidRevertHistory(maker: MSHistoryMaker): void;
  historyMakerDidProgressHistory(maker: MSHistoryMaker): void;

  cloudShare(): SCKShare;
  setCloudShare(cloudShare: SCKShare): void;
  cloudName(): NSString;
  documentWindow(): NSWindow;
  setDocumentWindow(documentWindow: NSWindow): void;
  messageView(): NSView;
  setMessageView(messageView: NSView): void;
  splitViewController(): MSMainSplitViewController;
  setSplitViewController(splitViewController: MSMainSplitViewController): void;
  toolbarConstructor(): MSToolbarConstructor;
  setToolbarConstructor(toolbarConstructor: MSToolbarConstructor): void;
  actionsController(): MSActionController;
  setActionsController(actionsController: MSActionController): void;
  badgeController(): MSBadgeController;
  documentData(): MSDocumentData;
  immutableDocumentData(): MSImmutableDocumentData;
  colorSpace(): NSColorSpace;
  canvasColorSpace(): NSColorSpace;
  eventHandlerManager(): MSEventHandlerManager;
  setEventHandlerManager(eventHandlerManager: MSEventHandlerManager): void;
  cacheManager(): MSCacheManager;
  historyMaker(): MSHistoryMaker;
  inspectorController(): MSInspectorController;
  setInspectorController(inspectorController: MSInspectorController): void;
  exportableLayerSelection(): NSArray<any>;
  setExportableLayerSelection(exportableLayerSelection: NSArray<any> | any[]): void;
  sidebarController(): BCSideBarViewController;
  setSidebarController(sidebarController: BCSideBarViewController): void;
  currentContentViewController(): MSContentDrawViewController;
  nextReadFromURLIsReload(): boolean;
  setNextReadFromURLIsReload(nextReadFromURLIsReload: boolean): void;
  hasOpenedImageFile(): boolean;
  setHasOpenedImageFile(hasOpenedImageFile: boolean): void;
  UIMetadata(): NSDictionary<any, any>;
  setUIMetadata(UIMetadata: NSDictionary<any, any> | {[key: string]: any}): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  colorSpaceMismatchWarning(): any;
  setColorSpaceMismatchWarning(colorSpaceMismatchWarning: any): void;
  editingLibraryWarning(): any;
  setEditingLibraryWarning(editingLibraryWarning: any): void;
  isCurrent(): boolean;
}
declare const MSDocument: {
  alloc(): MSDocumentAllocator;  currentDocument(): MSDocument;
  windowForSheet(): NSWindow;

}

interface MSDocumentActionAllocator<InitializedType = MSDocumentAction> extends MSActionAllocator<MSDocumentAction> {
  initWithDocument(doc: MSDocument): InitializedType;
}
interface MSDocumentAction extends MSAction {
  touchBarItem(): NSTouchBarItem;
  makeTouchBarItem(): NSTouchBarItem;
  makeTouchBarItemButton(): NSButton;
  touchBarItemButtonShouldShowState(): boolean;
  refreshTouchBarItem(): void;
  showTouchBarPopover(sender: any): void;
  isTouchBarItemSelected(): boolean;
  shouldUseImageForTouchBarItem(): boolean;
  touchBarImage(): NSImage;
  touchBarItemSizing(): MSTouchBarItemSizing;
  selectedLayers(): MSLayerArray;
  isInNormalHandler(): boolean;
  currentHandler(): MSEventHandler;
  toggleHandlerClass(handlerClass: any): MSEventHandler;
  setCurrentHandlerClass(handlerClass: any): MSEventHandler;
  switchToNormalHandler(): void;
  currentPage(): MSPage;
  contentDrawView(): MSContentDrawView;
  refreshOverlay(): void;
  repopulateMenu(menu: NSMenu): void;

  document(): MSDocument;
  setDocument(document: MSDocument): void;
  historyMomentTitle(): NSString;
  cachedTouchedBarItem(): NSTouchBarItem;
  setCachedTouchedBarItem(cachedTouchedBarItem: NSTouchBarItem): void;
}
declare const MSDocumentAction: {
  alloc(): MSDocumentActionAllocator;
}

declare enum MSTouchBarItemSizing {
  MSTouchBarItemSizingDefault = 0,
  MSTouchBarItemSizingNarrow = 1,
  MSTouchBarItemSizingSquare = 2,
}

interface MSDocumentControllerAllocator<InitializedType = MSDocumentController> extends NSDocumentControllerAllocator<MSDocumentController> {}
interface MSDocumentController extends NSDocumentController {
  openDocumentWithContentsOfURL_display_context_callback(url: NSURL, displayDocument: boolean, coscript: COScript, callback: MOJavaScriptObject | Function): void;
}
declare const MSDocumentController: {
  alloc(): MSDocumentControllerAllocator;
}

interface MSDocumentImporterAllocator<InitializedType = MSDocumentImporter> extends NSObjectAllocator<MSDocumentImporter> {}
interface MSDocumentImporter extends NSObject {

  group(): MSLayerGroup;
  view(): MSContentDrawView;
}
declare const MSDocumentImporter: {
  alloc(): MSDocumentImporterAllocator;  importFromURL_inPage_importer(url: NSURL, page: MSPage, importer: any): void;

}

interface MSDocumentWindowAllocator<InitializedType = MSDocumentWindow> extends NSWindowAllocator<MSDocumentWindow> {}
interface MSDocumentWindow extends NSWindow {

  titleBarBadge(): BCWindowBadge;
  setTitleBarBadge(titleBarBadge: BCWindowBadge): void;
}
declare const MSDocumentWindow: {
  alloc(): MSDocumentWindowAllocator;
}

interface MSDocumentWindowContentViewAllocator<InitializedType = MSDocumentWindowContentView> extends NSViewAllocator<MSDocumentWindowContentView> {}
interface MSDocumentWindowContentView extends NSView {
}
declare const MSDocumentWindowContentView: {
  alloc(): MSDocumentWindowContentViewAllocator;
}

interface MSDragHandleGestureRecognizerAllocator<InitializedType = MSDragHandleGestureRecognizer> extends MSDragToMoveOrCopyGestureRecognizerAllocator<MSDragHandleGestureRecognizer> {}
interface MSDragHandleGestureRecognizer extends MSDragToMoveOrCopyGestureRecognizer {

  originalHandleLocation(): NSPoint;
  setOriginalHandleLocation(originalHandleLocation: NSPoint): void;
  lockingConstraint(): MSAlignmentEngineConstraint;
  setLockingConstraint(lockingConstraint: MSAlignmentEngineConstraint): void;
  effectiveLockingConstraint(): MSAlignmentEngineConstraint;
}
declare const MSDragHandleGestureRecognizer: {
  alloc(): MSDragHandleGestureRecognizerAllocator;
}

interface MSDragRectEventHandlerAllocator<InitializedType = MSDragRectEventHandler> extends MSEventHandlerAllocator<MSDragRectEventHandler> {}
interface MSDragRectEventHandler extends MSEventHandler {
  performActionWithRect_fromLayer_constrainProportions(rect: NSRect, layer: MSLayer | null, constrainProportions: boolean): MSLayer;
  drawingRectForInsertionRect(insertionRect: NSRect): NSRect;
  drawRectPreview(): void;

  insertionRect(): NSRect;
  setInsertionRect(insertionRect: NSRect): void;
  allowsInsertLayerFromExistingLayer(): boolean;
  cursorForInsertingFromExisting(): NSCursor;
  layerSelectionOptionsForInsertingFromExistingLayer(): MSLayerSelectionOptions;
  dragGestureRecognizer(): MSDragGestureRecognizer;
  snapper(): MSAlignmentEngine;
  snappingResult(): MSAlignmentEngineResult;
  setSnappingResult(snappingResult: MSAlignmentEngineResult): void;
  insertionCursor(): NSCursor;
  setInsertionCursor(insertionCursor: NSCursor): void;
}
declare const MSDragRectEventHandler: {
  alloc(): MSDragRectEventHandlerAllocator;
}

interface MSDragRectGestureRecognizerAllocator<InitializedType = MSDragRectGestureRecognizer> extends MSDragGestureRecognizerAllocator<MSDragRectGestureRecognizer> {}
interface MSDragRectGestureRecognizer extends MSDragGestureRecognizer {

  constrainProportions(): boolean;
}
declare const MSDragRectGestureRecognizer: {
  alloc(): MSDragRectGestureRecognizerAllocator;
}

interface MSDragSegmentGestureRecognizerAllocator<InitializedType = MSDragSegmentGestureRecognizer> extends MSDragGestureRecognizerAllocator<MSDragSegmentGestureRecognizer> {}
interface MSDragSegmentGestureRecognizer extends MSDragGestureRecognizer {

  offset(): CGFloat;
  setOffset(offset: CGFloat): void;
}
declare const MSDragSegmentGestureRecognizer: {
  alloc(): MSDragSegmentGestureRecognizerAllocator;
}

interface MSDragToMoveOrCopyGestureRecognizerAllocator<InitializedType = MSDragToMoveOrCopyGestureRecognizer> extends MSDragGestureRecognizerAllocator<MSDragToMoveOrCopyGestureRecognizer> {}
interface MSDragToMoveOrCopyGestureRecognizer extends MSDragGestureRecognizer {
  translationInLayer(layer: MSLayer | null): CGVector;
  locationInLayer(layer: MSLayer | null): NSPoint;

  shouldCopyDraggedItems(): boolean;
  shouldSnap(): boolean;
  alignModifierMask(): NSEventModifierFlags;
  setAlignModifierMask(alignModifierMask: NSEventModifierFlags): void;
  shouldInterpretAlignment(): boolean;
  setShouldInterpretAlignment(shouldInterpretAlignment: boolean): void;
  align(): boolean;
  alignmentAxis(): BCAxis;
  draggedItem(): any;
  setDraggedItem(draggedItem: any): void;
  originalDraggedItems(): NSArray<any>;
  setOriginalDraggedItems(originalDraggedItems: NSArray<any> | any[]): void;
  originalDragPositions(): NSArray<any>;
  setOriginalDragPositions(originalDragPositions: NSArray<any> | any[]): void;
  copiedItems(): NSArray<any>;
  setCopiedItems(copiedItems: NSArray<any> | any[]): void;
}
declare const MSDragToMoveOrCopyGestureRecognizer: {
  alloc(): MSDragToMoveOrCopyGestureRecognizerAllocator;
}

interface MSDragLayerGestureRecognizerAllocator<InitializedType = MSDragLayerGestureRecognizer> extends MSDragToMoveOrCopyGestureRecognizerAllocator<MSDragLayerGestureRecognizer> {}
interface MSDragLayerGestureRecognizer extends MSDragToMoveOrCopyGestureRecognizer {
}
declare const MSDragLayerGestureRecognizer: {
  alloc(): MSDragLayerGestureRecognizerAllocator;
}

interface MSDragToSelectGestureRecognizerAllocator<InitializedType = MSDragToSelectGestureRecognizer> extends MSDragGestureRecognizerAllocator<MSDragToSelectGestureRecognizer> {}
interface MSDragToSelectGestureRecognizer extends MSDragGestureRecognizer {
  selectionRect(): NSRect;

  extendSelection(): boolean;
  selectionExtensionMask(): NSEventModifierFlags;
  setSelectionExtensionMask(selectionExtensionMask: NSEventModifierFlags): void;
  initialSelection(): NSArray<any>;
  setInitialSelection(initialSelection: NSArray<any> | any[]): void;
}
declare const MSDragToSelectGestureRecognizer: {
  alloc(): MSDragToSelectGestureRecognizerAllocator;
}

interface MSDrawingInfoAllocator<InitializedType = MSDrawingInfo> extends NSObjectAllocator<MSDrawingInfo> {}
interface MSDrawingInfo extends NSObject {

  isDragging(): boolean;
  setIsDragging(isDragging: boolean): void;
}
declare const MSDrawingInfo: {
  alloc(): MSDrawingInfoAllocator;  sharedController(): MSDrawingInfo;

}

interface MSDropdownButtonCellAllocator<InitializedType = MSDropdownButtonCell> extends MSSmallButtonCellAllocator<MSDropdownButtonCell> {}
interface MSDropdownButtonCell extends MSSmallButtonCell {

  imageRightEdgeInset(): CGFloat;
  setImageRightEdgeInset(imageRightEdgeInset: CGFloat): void;
}
declare const MSDropdownButtonCell: {
  alloc(): MSDropdownButtonCellAllocator;
}

interface MSDuplicateOffsetTrackerAllocator<InitializedType = MSDuplicateOffsetTracker> extends NSObjectAllocator<MSDuplicateOffsetTracker> {}
interface MSDuplicateOffsetTracker extends NSObject {
  reset(): void;
  resetToInitialOffset(): void;
  increment(): void;
  offset(): CGFloat;
}
declare const MSDuplicateOffsetTracker: {
  alloc(): MSDuplicateOffsetTrackerAllocator;
}

interface MSEditActionAllocator<InitializedType = MSEditAction> extends MSDocumentActionAllocator<MSEditAction> {}
interface MSEditAction extends MSDocumentAction {
  edit(sender: any): IBAction;
}
declare const MSEditAction: {
  alloc(): MSEditActionAllocator;  editableLayerTraits(): MSTraits;

}

interface MSEditArtboardPresetViewControllerAllocator<InitializedType = MSEditArtboardPresetViewController> extends NSViewControllerAllocator<MSEditArtboardPresetViewController> {}
interface MSEditArtboardPresetViewController extends NSViewController {

  preset(): MSArtboardPreset;
  setPreset(preset: MSArtboardPreset): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSEditArtboardPresetViewController: {
  alloc(): MSEditArtboardPresetViewControllerAllocator;
}

interface IMSEditArtboardPresetViewControllerDelegate {
  editArtboardPresetViewController_savePreset(sender: MSEditArtboardPresetViewController, preset: MSArtboardPreset): void;
}

interface MSEditColorSpaceActionAllocator<InitializedType = MSEditColorSpaceAction> extends MSDocumentActionAllocator<MSEditColorSpaceAction> {}
interface MSEditColorSpaceAction extends MSDocumentAction {
  editDocumentColorSpace(sender: any): IBAction;
}
declare const MSEditColorSpaceAction: {
  alloc(): MSEditColorSpaceActionAllocator;
}

interface MSChangeColorSpaceActionAllocator<InitializedType = MSChangeColorSpaceAction> extends MSDocumentActionAllocator<MSChangeColorSpaceAction> {}
interface MSChangeColorSpaceAction extends MSDocumentAction {
}
declare const MSChangeColorSpaceAction: {
  alloc(): MSChangeColorSpaceActionAllocator;
}

interface MSAssignColorSpaceActionAllocator<InitializedType = MSAssignColorSpaceAction> extends MSChangeColorSpaceActionAllocator<MSAssignColorSpaceAction> {}
interface MSAssignColorSpaceAction extends MSChangeColorSpaceAction {
  assignDocumentColorSpace(sender: any): IBAction;
}
declare const MSAssignColorSpaceAction: {
  alloc(): MSAssignColorSpaceActionAllocator;
}

interface MSConvertColorSpaceActionAllocator<InitializedType = MSConvertColorSpaceAction> extends MSChangeColorSpaceActionAllocator<MSConvertColorSpaceAction> {}
interface MSConvertColorSpaceAction extends MSChangeColorSpaceAction {
  convertDocumentColorSpace(sender: any): IBAction;
}
declare const MSConvertColorSpaceAction: {
  alloc(): MSConvertColorSpaceActionAllocator;
}

interface MSEditColorSpaceSheetControllerAllocator<InitializedType = MSEditColorSpaceSheetController> extends CHSheetControllerAllocator<MSEditColorSpaceSheetController> {}
interface MSEditColorSpaceSheetController extends CHSheetController {
  pickColorSpace(sender: any): IBAction;
  pickChangeLogic(sender: any): IBAction;
  viewDocumentation(sender: any): IBAction;

  assignButton(): NSButton;
  setAssignButton(assignButton: NSButton): void;
  assignDescriptionTextField(): NSTextField;
  setAssignDescriptionTextField(assignDescriptionTextField: NSTextField): void;
  colorSpacePopUpButton(): NSPopUpButton;
  setColorSpacePopUpButton(colorSpacePopUpButton: NSPopUpButton): void;
  descriptionTextField(): NSTextField;
  setDescriptionTextField(descriptionTextField: NSTextField): void;
  confirmButton(): NSButton;
  setConfirmButton(confirmButton: NSButton): void;
  convertButton(): NSButton;
  setConvertButton(convertButton: NSButton): void;
  convertDescriptionTextField(): NSTextField;
  setConvertDescriptionTextField(convertDescriptionTextField: NSTextField): void;
}
declare const MSEditColorSpaceSheetController: {
  alloc(): MSEditColorSpaceSheetControllerAllocator;
}

interface MSEditShapeInspectorViewControllerAllocator<InitializedType = MSEditShapeInspectorViewController> extends NSViewControllerAllocator<MSEditShapeInspectorViewController> {}
interface MSEditShapeInspectorViewController extends NSViewController, IMSInspectorChildController {
  refresh(): void;
  refreshClosePathButton(): void;

  pathController(): MSPathController;
  setPathController(pathController: MSPathController): void;
  shapeEventHandler(): MSShapeEventHandler;
  setShapeEventHandler(shapeEventHandler: MSShapeEventHandler): void;
  isMakingRectSelection(): boolean;
  setIsMakingRectSelection(isMakingRectSelection: boolean): void;
}
declare const MSEditShapeInspectorViewController: {
  alloc(): MSEditShapeInspectorViewControllerAllocator;
}

interface MSEventHandlerAllocator<InitializedType = MSEventHandler> extends NSResponderAllocator<MSEventHandler> {
  initWithManager(aManager: MSEventHandlerManager): InitializedType;
}
interface MSEventHandler extends NSResponder, INSDraggingDestination, INSTouchBarDelegate {
  currentGroup(): MSLayerGroup;
  layersToCopy(): MSLayerArray;
  parentForInsertingLayer(layer: MSLayer): MSLayerGroup;
  alignPointToGrid(point: NSPoint): NSPoint;
  mouseDownEvent(event: NSEvent): boolean;
  mouseDraggedEvent(event: NSEvent): boolean;
  mouseUpEvent(event: NSEvent): boolean;
  mouseMovedEvent(event: NSEvent): boolean;
  rightMouseDown(event: NSEvent): void;
  absoluteMouseDown_clickCount_flags(mouse: NSPoint, c: NSUInteger, flags: NSUInteger): boolean;
  absoluteMouseDragged_flags(mouse: NSPoint, flags: NSUInteger): boolean;
  absoluteMouseUp_flags(mouse: NSPoint, flags: NSUInteger): boolean;
  absoluteMouseMoved_flags(mouse: NSPoint, flags: NSEventModifierFlags): boolean;
  mouseDraggedOutsideViewShouldMoveScrollOrigin(): boolean;
  zoomValue(): CGFloat;
  viewDidScroll(sender: any): void;
  trackMouse(tracker: MSMouseTracker): void;
  addGestureRecognizer(recognizer: MSGestureRecognizer): void;
  updateCursor(): boolean;
  setNeedsUpdateCursor(): void;
  cancelOperation(sender: any): void;
  setMeasurementTextWithSize(size: NSSize): void;
  setMeasurementTextWithDegrees(degrees: NSInteger): void;
  addOverlayRenderer(renderer: MSOverlayRenderer): void;
  prepareGraphicsStateForGroup_drawingBlock(group: MSLayerGroup, block: BCVoidBlock): void;
  drawMeasurementLabel(): void;
  drawDragSelection(): void;
  handlerWillLoseFocus(): void;
  handlerDidLoseFocus(): void;
  selectAll(sender: any): IBAction;
  returnToDefaultHandler(): void;
  returnToDefaultHandlerByClickingOutside(): void;
  selectToolbarItemWithIdentifier(identifier: NSString | string): void;
  menuForEvent(theEvent: NSEvent): NSMenu;
  writeLayers_toPasteboard(layers: MSLayerArray, pb: NSPasteboard): void;
  duplicateSelectedLayersWithOffset(offset: CGVector): NSArray<any>;
  contentDrawView(): MSContentDrawView;
  currentPage(): MSPage;
  document(): MSDocument;
  refreshOverlay(): void;
  cut(sender: any): IBAction;
  copy(sender: any): IBAction;
  paste(sender: any): IBAction;
  pasteWithStyle(sender: any): IBAction;
  pasteOverSelection(sender: any): IBAction;
  pasteHere(sender: any): IBAction;
  duplicate(sender: any): IBAction;
  delete(sender: any): IBAction;
  itemAtPoint_modifierFlags(mouse: NSPoint, flags: NSEventModifierFlags): MSHitTestResult;
  hitTestingOptions(): MSLayerSelectionOptions;
  deleteKeyIsPressed(c: unichar): boolean;
  enterKeyIsPressed(c: unichar): boolean;
  escapeKeyIsPressed(c: unichar): boolean;
  arrowKeyIsPressed(c: unichar): boolean;
  drawHandles(): void;
  toolbarIdentifier(): NSString;
  changeColor(sender: any): void;
  selectedLayers(): MSLayerArray;
  selectLayer_extendSelection(layer: MSLayer, extend: boolean): void;
  selectHitTestResult_extendSelection(hitTestResult: MSHitTestResult, extend: boolean): void;
  imageName(): NSString;
  willMoveThroughHistory(note: NSNotification): void;
  didMoveThroughHistory(note: NSNotification): void;
  commitPendingEdits(): void;
  reloadFollowingBackgroundChangesToDocument(): void;
  zoomToSelection(): void;
  zoomToArtboard(): void;
  selectedRect(): NSRect;
  centerPointForZooming(): NSPoint;
  draggingEntered(sender: any): NSDragOperation;
  draggingExited(sender: any): void;
  prepareForDragOperation(sender: any): boolean;
  draggingUpdated(sender: any): NSDragOperation;
  performDragOperation(sender: any): boolean;
  zoomValueWillChangeTo(zoomValue: CGFloat): void;
  zoomValueDidChange(): void;
  layerListSelectionDidChange(selection: NSArray<any> | any[]): void;
  layerRulerOriginChanged(): void;
  currentPageDidChange(): void;
  allowsSwitchToInsertAction(): boolean;
  handlesHandToolItself(): boolean;
  insertTab(sender: any): void;
  insertBacktab(sender: any): void;
  mouseExited(): void;
  mayShowResizingInspectorView(): boolean;
  editLayer(layer: MSLayer): void;
  willResignFirstResponder(): void;
  layerPositionPossiblyChanged(): void;
  configureInspector(inspector: MSInspectorController): void;
  inspectorViewControllersForLayers_standardControllers(layers: NSArray<any> | any[], standardInspectors: MSStandardInspectorViewControllers): NSArray<any>;
  inspectorLocation(): MSInpectorLocation;
  inspectorShouldShowPositions(): boolean;
  focusOnMainWindow(): void;
  canDuplicate(): boolean;
  shouldFitToPixelBounds(): boolean;
  nudgeDistanceForFlags(flags: NSEventModifierFlags): CGFloat;
  touchBarWithIdentifiers(identifiers: NSArray<any> | any[]): NSTouchBar;
  refreshTouchBarItemWithIdentifier(identifier: NSString | string): void;
  documentWindow(): MSDocumentWindow;

  manager(): MSEventHandlerManager;
  setManager(manager: MSEventHandlerManager): void;
  offsetTracker(): MSDuplicateOffsetTracker;
  setOffsetTracker(offsetTracker: MSDuplicateOffsetTracker): void;
  pressedKeys(): NSString;
  setPressedKeys(pressedKeys: NSString | string): void;
  handlesHistoryCoalescing(): boolean;
  shouldExitOnContentViewResize(): boolean;
  undoManager(): NSUndoManager;
  applicableActionItemIdentifier(): NSString;
  gestureRecognizers(): NSArray<any>;
  cursor(): NSCursor;
  setCursor(cursor: NSCursor): void;
  measurementText(): NSString;
  setMeasurementText(measurementText: NSString | string): void;
  overlayRenderers(): NSArray<any>;
  selectionRect(): NSRect;
  setSelectionRect(selectionRect: NSRect): void;
  wantsStandardSelectionControls(): boolean;
  wantsLayerHighlight(): boolean;
}
declare const MSEventHandler: {
  alloc(): MSEventHandlerAllocator;  eventHandlerWithManager(aManager: MSEventHandlerManager): any;

}

declare enum MSUnicodeAdditions {
  MSUnicodeEscapeKey = 27,
  MSUnicodeFNLeftKey = 63273,
  MSUnicodeFNRightKey = 63275,
}

declare enum MSInpectorLocation {
  MSInspectorLocationNone,
  MSInspectorLocationTakeOverEntireInspector,
  MSInspectorLocationAboveNormalInspector,
}

interface MSEventHandlerActionAllocator<InitializedType = MSEventHandlerAction> extends MSDocumentActionAllocator<MSEventHandlerAction> {}
interface MSEventHandlerAction extends MSDocumentAction {
  eventHandlerClass(): any;
}
declare const MSEventHandlerAction: {
  alloc(): MSEventHandlerActionAllocator;
}

interface MSEventHandlerManagerAllocator<InitializedType = MSEventHandlerManager> extends NSObjectAllocator<MSEventHandlerManager> {
  initWithDelegate(delegate: any): InitializedType;
}
interface MSEventHandlerManager extends NSObject {
  setCurrentHandler_force(handler: MSEventHandler | null, force: boolean): void;
  handlerForClass(aClass: any): MSEventHandler;
  switchToEventHandlerClass(handlerClass: any): MSEventHandler;
  toggleHandlerClass(handlerClass: any): MSEventHandler;
  drawInRect_context(dirtyRect: NSRect, context: MSRenderingContext): void;
  sendMouseDownEvent(event: NSEvent): void;
  sendMouseDraggedEvent(event: NSEvent): void;
  sendMouseUpEvent(event: NSEvent): void;
  sendMouseMovedEvent(event: NSEvent): void;
  recordEvent(event: NSEvent): void;

  document(): MSDocument;
  setDocument(document: MSDocument): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  currentHandler(): MSEventHandler;
  setCurrentHandler(currentHandler: MSEventHandler): void;
  normalHandler(): MSNormalEventHandler;
  lastMouseDownClickCount(): NSInteger;
  lastEventType(): MSEventType;
}
declare const MSEventHandlerManager: {
  alloc(): MSEventHandlerManagerAllocator;
}

interface IMSEventHandlerManagerDelegate {
  eventHandlerManager_didChangeCurrentHandler(manager: MSEventHandlerManager, newHandler: MSEventHandler): void;
}

declare enum MSEventType {
  MSEventTypeUndefined = 0,
  MSEventTypeMouse = 1,
}

interface MSExpandedStateSavingOutlineViewAllocator<InitializedType = MSExpandedStateSavingOutlineView> extends NSOutlineViewAllocator<MSExpandedStateSavingOutlineView> {}
interface MSExpandedStateSavingOutlineView extends NSOutlineView {

  expandedStateAutosaveName(): NSString;
  setExpandedStateAutosaveName(expandedStateAutosaveName: NSString | string): void;
}
declare const MSExpandedStateSavingOutlineView: {
  alloc(): MSExpandedStateSavingOutlineViewAllocator;
}

interface MSExportActionAllocator<InitializedType = MSExportAction> extends MSDocumentActionAllocator<MSExportAction> {}
interface MSExportAction extends MSDocumentAction {
  export(sender: any): IBAction;
}
declare const MSExportAction: {
  alloc(): MSExportActionAllocator;
}

interface MSExportSelectionWithExportFormatsActionAllocator<InitializedType = MSExportSelectionWithExportFormatsAction> extends MSDocumentActionAllocator<MSExportSelectionWithExportFormatsAction> {}
interface MSExportSelectionWithExportFormatsAction extends MSDocumentAction {
  exportSelection(sender: any): IBAction;
}
declare const MSExportSelectionWithExportFormatsAction: {
  alloc(): MSExportSelectionWithExportFormatsActionAllocator;
}

interface MSExportFormatNamingTextFieldAllocator<InitializedType = MSExportFormatNamingTextField> extends NSTextFieldAllocator<MSExportFormatNamingTextField> {}
interface MSExportFormatNamingTextField extends NSTextField {

  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
}
declare const MSExportFormatNamingTextField: {
  alloc(): MSExportFormatNamingTextFieldAllocator;  sharedFieldEditor(): NSTextView;

}

interface MSExportFormatNamingTextFieldCellAllocator<InitializedType = MSExportFormatNamingTextFieldCell> extends NSTextFieldCellAllocator<MSExportFormatNamingTextFieldCell> {}
interface MSExportFormatNamingTextFieldCell extends NSTextFieldCell {
}
declare const MSExportFormatNamingTextFieldCell: {
  alloc(): MSExportFormatNamingTextFieldCellAllocator;
}

interface MSExportFormatPopUpButtonCellAllocator<InitializedType = MSExportFormatPopUpButtonCell> extends NSPopUpButtonCellAllocator<MSExportFormatPopUpButtonCell> {}
interface MSExportFormatPopUpButtonCell extends NSPopUpButtonCell {
}
declare const MSExportFormatPopUpButtonCell: {
  alloc(): MSExportFormatPopUpButtonCellAllocator;
}

interface MSExportFormatViewControllerAllocator<InitializedType = MSExportFormatViewController> extends NSViewControllerAllocator<MSExportFormatViewController> {}
interface MSExportFormatViewController extends NSViewController {
  prepare(): void;
  commitScaleFieldEditsWithCompletionBlock(block: dispatch_block_t): void;
  removeExportFormat(sender: any): IBAction;
  formatPopupAction(sender: any): IBAction;
  scaleFieldAction(sender: any): IBAction;

  formatPopup(): NSPopUpButton;
  setFormatPopup(formatPopup: NSPopUpButton): void;
  removeSizeButton(): NSButton;
  setRemoveSizeButton(removeSizeButton: NSButton): void;
  sizeView(): NSView;
  setSizeView(sizeView: NSView): void;
  suffixTextField(): MSExportFormatNamingTextField;
  setSuffixTextField(suffixTextField: MSExportFormatNamingTextField): void;
  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
  scaleField(): NSTextField;
  setScaleField(scaleField: NSTextField): void;
  removeButtonHidden(): boolean;
  setRemoveButtonHidden(removeButtonHidden: boolean): void;
}
declare const MSExportFormatViewController: {
  alloc(): MSExportFormatViewControllerAllocator;
}

interface MSExportInspectorViewControllerAllocator<InitializedType = MSExportInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<MSExportInspectorViewController> {}
interface MSExportInspectorViewController extends MSStylePartInspectorViewController {
  addExportFormat(sender: any): IBAction;
  createSliceAction(sender: any): IBAction;
  showExportPresetMenu(sender: any): IBAction;
  addExportPreset(sender: any): IBAction;
  applyExportPreset(sender: any): IBAction;
  editExportPresets(sender: any): IBAction;

  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  bottomLabelView(): NSView;
  setBottomLabelView(bottomLabelView: NSView): void;
  exportFormatLabelTextField(): NSTextField;
  setExportFormatLabelTextField(exportFormatLabelTextField: NSTextField): void;
  headerLabel(): NSTextField;
  setHeaderLabel(headerLabel: NSTextField): void;
}
declare const MSExportInspectorViewController: {
  alloc(): MSExportInspectorViewControllerAllocator;
}

interface MSExportManagerAllocator<InitializedType = MSExportManager> extends NSObjectAllocator<MSExportManager> {}
interface MSExportManager extends NSObject {
  exportedDataForRequest(exportRequest: MSExportRequest): NSData;
  exportFileForRequest_toFileURL(exportRequest: MSExportRequest, fileURL: NSURL): void;
  exportFilesForRequests(exportRequests: NSArray<any> | any[]): void;

  colorSpace(): NSColorSpace;
  sliceCompletionBlock(): MSExportManagerSliceCompletionBlock;
  setSliceCompletionBlock(sliceCompletionBlock: MSExportManagerSliceCompletionBlock): void;
}
declare const MSExportManager: {
  alloc(): MSExportManagerAllocator;
}

interface MSExportPDFBookActionAllocator<InitializedType = MSExportPDFBookAction> extends MSDocumentActionAllocator<MSExportPDFBookAction> {}
interface MSExportPDFBookAction extends MSDocumentAction {
  exportPDFBook(sender: any): IBAction;
}
declare const MSExportPDFBookAction: {
  alloc(): MSExportPDFBookActionAllocator;
}

interface MSExportPresetFormatViewControllerAllocator<InitializedType = MSExportPresetFormatViewController> extends MSExportFormatViewControllerAllocator<MSExportPresetFormatViewController> {}
interface MSExportPresetFormatViewController extends MSExportFormatViewController {
}
declare const MSExportPresetFormatViewController: {
  alloc(): MSExportPresetFormatViewControllerAllocator;
}

interface MSExportPresetsPreferencePaneAllocator<InitializedType = MSExportPresetsPreferencePane> extends MSPreferencePaneAllocator<MSExportPresetsPreferencePane> {}
interface MSExportPresetsPreferencePane extends MSPreferencePane, INSTableViewDataSource, INSTableViewDelegate {
  editExportPreset(preset: MSExportPreset): void;
  addExportPreset(sender: any): IBAction;
  removeExportPreset(sender: any): IBAction;
  pickDefaultExportPreset(sender: any): IBAction;
  restoreDefaultExportPresets(sender: any): IBAction;
  addExportFormat(sender: any): IBAction;
  removeExportFormatFromPreset(sender: any): IBAction;
  commitExportPresetName(sender: any): IBAction;

  addButton(): NSButton;
  setAddButton(addButton: NSButton): void;
  addFormatButton(): NSButton;
  setAddFormatButton(addFormatButton: NSButton): void;
  exportFormatEditorView(): NSView;
  setExportFormatEditorView(exportFormatEditorView: NSView): void;
  exportFormatFooterView(): NSView;
  setExportFormatFooterView(exportFormatFooterView: NSView): void;
  exportFormatFooterBottomConstraint(): NSLayoutConstraint;
  setExportFormatFooterBottomConstraint(exportFormatFooterBottomConstraint: NSLayoutConstraint): void;
  exportFormatsView(): NSStackView;
  setExportFormatsView(exportFormatsView: NSStackView): void;
  exportFormatsViewController(): MSExportFormatViewController;
  setExportFormatsViewController(exportFormatsViewController: MSExportFormatViewController): void;
  noPresetsPlaceholderView(): NSView;
  setNoPresetsPlaceholderView(noPresetsPlaceholderView: NSView): void;
  presetNameTextField(): NSTextField;
  setPresetNameTextField(presetNameTextField: NSTextField): void;
  removeButton(): NSButton;
  setRemoveButton(removeButton: NSButton): void;
  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  presets(): NSArray<any>;
}
declare const MSExportPresetsPreferencePane: {
  alloc(): MSExportPresetsPreferencePaneAllocator;  localizedNewExportPresetName(): NSString;

}

interface MSExportPresetTableCellViewAllocator<InitializedType = MSExportPresetTableCellView> extends NSTableCellViewAllocator<MSExportPresetTableCellView> {}
interface MSExportPresetTableCellView extends NSTableCellView {

  defaultPresetButton(): NSButton;
  setDefaultPresetButton(defaultPresetButton: NSButton): void;
}
declare const MSExportPresetTableCellView: {
  alloc(): MSExportPresetTableCellViewAllocator;
}

interface MSExportPreviewHeaderInspectorItemAllocator<InitializedType = MSExportPreviewHeaderInspectorItem> extends MSInspectorItemAllocator<MSExportPreviewHeaderInspectorItem> {}
interface MSExportPreviewHeaderInspectorItem extends MSInspectorItem {

  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
  hideSeparator(): boolean;
  setHideSeparator(hideSeparator: boolean): void;
}
declare const MSExportPreviewHeaderInspectorItem: {
  alloc(): MSExportPreviewHeaderInspectorItemAllocator;
}

interface MSExportPreviewImagesInspectorItemAllocator<InitializedType = MSExportPreviewImagesInspectorItem> extends MSInspectorItemAllocator<MSExportPreviewImagesInspectorItem> {}
interface MSExportPreviewImagesInspectorItem extends MSInspectorItem {
}
declare const MSExportPreviewImagesInspectorItem: {
  alloc(): MSExportPreviewImagesInspectorItemAllocator;
}

interface MSExportPreviewInspectorSectionAllocator<InitializedType = MSExportPreviewInspectorSection> extends MSBaseInspectorSectionAllocator<MSExportPreviewInspectorSection> {}
interface MSExportPreviewInspectorSection extends MSBaseInspectorSection {
}
declare const MSExportPreviewInspectorSection: {
  alloc(): MSExportPreviewInspectorSectionAllocator;
}

interface MSExportPreviewOperationAllocator<InitializedType = MSExportPreviewOperation> extends NSOperationAllocator<MSExportPreviewOperation> {
  initWithAncestry(ancestry: MSImmutableLayerAncestry): InitializedType;
}
interface MSExportPreviewOperation extends NSOperation {

  previewViewModel(): MSExportPreviewViewModel;
}
declare const MSExportPreviewOperation: {
  alloc(): MSExportPreviewOperationAllocator;  sharedPreviewRenderQueue(): NSOperationQueue;

}

interface MSExportPreviewViewAllocator<InitializedType = MSExportPreviewView> extends NSViewAllocator<MSExportPreviewView> {
  initWithViewModel(viewModel: MSExportPreviewViewModel): InitializedType;
}
interface MSExportPreviewView extends NSView, INSDraggingSource, INSPasteboardWriting {

  viewModel(): MSExportPreviewViewModel;
  setViewModel(viewModel: MSExportPreviewViewModel): void;
}
declare const MSExportPreviewView: {
  alloc(): MSExportPreviewViewAllocator;
}

interface MSExportPreviewViewModelAllocator<InitializedType = MSExportPreviewViewModel> extends NSObjectAllocator<MSExportPreviewViewModel> {
  initWithPreviewImage_cachedExportRequest_ancestry(previewImage: NSImage, cachedExportRequest: MSExportRequest, ancestry: MSImmutableLayerAncestry): InitializedType;
}
interface MSExportPreviewViewModel extends NSObject {
  imageDataInFormat(fileFormat: NSString | string): NSData;

  previewImage(): NSImage;
  cachedExportRequest(): MSExportRequest;
  layerName(): NSString;
  defaultExportFormat(): NSString;
  isVectorFormat(): boolean;
  previewFrame(): NSRect;
  setPreviewFrame(previewFrame: NSRect): void;
}
declare const MSExportPreviewViewModel: {
  alloc(): MSExportPreviewViewModelAllocator;
}

interface MSExportSelectedInspectorItemAllocator<InitializedType = MSExportSelectedInspectorItem> extends MSExportSelectedOrResizeInspectorItemAllocator<MSExportSelectedInspectorItem> {}
interface MSExportSelectedInspectorItem extends MSExportSelectedOrResizeInspectorItem {
}
declare const MSExportSelectedInspectorItem: {
  alloc(): MSExportSelectedInspectorItemAllocator;
}

interface MSExportSelectedOrResizeInspectorItemAllocator<InitializedType = MSExportSelectedOrResizeInspectorItem> extends MSInspectorItemAllocator<MSExportSelectedOrResizeInspectorItem> {}
interface MSExportSelectedOrResizeInspectorItem extends MSInspectorItem {

  sizeToFitButton(): NSButton;
  setSizeToFitButton(sizeToFitButton: NSButton): void;
  exportButton(): NSButton;
  setExportButton(exportButton: NSButton): void;
}
declare const MSExportSelectedOrResizeInspectorItem: {
  alloc(): MSExportSelectedOrResizeInspectorItemAllocator;
}

interface MSExportSheetAllocator<InitializedType = MSExportSheet> extends CHSheetControllerAllocator<MSExportSheet> {}
interface MSExportSheet extends CHSheetController {
  includeAllCheckboxAction(sender: any): IBAction;
  collectionView_newItemForRepresentedObject(collectionView: NSCollectionView, object: any): NSCollectionViewItem;
  validateIncludeAllSlicesCheckBox(): void;
  isItemSelectedForExport(item: any): boolean;
  toggleItemSelectedForExportState(item: any): void;

  collectionView(): NSCollectionView;
  setCollectionView(collectionView: NSCollectionView): void;
  selectedSlices(): NSMutableArray<any>;
  setSelectedSlices(selectedSlices: NSMutableArray<any> | any[]): void;
}
declare const MSExportSheet: {
  alloc(): MSExportSheetAllocator;
}

interface MSExportSheetItemAllocator<InitializedType = MSExportSheetItem> extends NSCollectionViewItemAllocator<MSExportSheetItem> {}
interface MSExportSheetItem extends NSCollectionViewItem {

  previewContainer(): NSView;
  setPreviewContainer(previewContainer: NSView): void;
  checkBox(): NSButton;
  setCheckBox(checkBox: NSButton): void;
  warningView(): NSImageView;
  setWarningView(warningView: NSImageView): void;
  exportSheet(): MSExportSheet;
  setExportSheet(exportSheet: MSExportSheet): void;
  showWarningLabel(): boolean;
  setShowWarningLabel(showWarningLabel: boolean): void;
  isExportable(): boolean;
  setIsExportable(isExportable: boolean): void;
}
declare const MSExportSheetItem: {
  alloc(): MSExportSheetItemAllocator;
}

interface MSExportStackViewAllocator<InitializedType = MSExportStackView> extends MSStackViewAllocator<MSExportStackView> {}
interface MSExportStackView extends MSStackView {
}
declare const MSExportStackView: {
  alloc(): MSExportStackViewAllocator;
}

interface MSExportableLayerInspectorViewControllerAllocator<InitializedType = MSExportableLayerInspectorViewController> extends CHViewControllerAllocator<MSExportableLayerInspectorViewController> {}
interface MSExportableLayerInspectorViewController extends CHViewController, IMSInspectorChildController, IMSSliceLayerWatcher, IMSColorInspectorDelegate, IBCPopoverDelegate {
  selectionDidChangeTo(newLayers: NSArray<any> | any[]): void;
  oldStyleIncludedRadioAction(sender: any): IBAction;
  exportableSizeDidChange(sender: any): IBAction;
  groupContentsOnlyAction(sender: any): IBAction;
  layerPositionPossiblyChanged(): IBAction;
  artboardBackgroundCheckAction(sender: any): IBAction;
  backgroundColorAction(sender: any): IBAction;
  refreshAction(sender: any): IBAction;

  stackView(): MSInspectorStackView;
  setStackView(stackView: MSInspectorStackView): void;
  oldSliceIncludedTable(): NSTableView;
  setOldSliceIncludedTable(oldSliceIncludedTable: NSTableView): void;
  oldStyleIncludeMatrix(): NSMatrix;
  setOldStyleIncludeMatrix(oldStyleIncludeMatrix: NSMatrix): void;
  groupContentsOnlyButton(): NSButton;
  setGroupContentsOnlyButton(groupContentsOnlyButton: NSButton): void;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}
declare const MSExportableLayerInspectorViewController: {
  alloc(): MSExportableLayerInspectorViewControllerAllocator;
}

interface MSFastPathBuilderAllocator<InitializedType = MSFastPathBuilder> extends NSObjectAllocator<MSFastPathBuilder> {}
interface MSFastPathBuilder extends NSObject {
}
declare const MSFastPathBuilder: {
  alloc(): MSFastPathBuilderAllocator;  pathForMaskImage(maskImage: NSBitmapImageRep): NSBezierPath;

}

interface MSFeedbackActionAllocator<InitializedType = MSFeedbackAction> extends MSActionAllocator<MSFeedbackAction> {}
interface MSFeedbackAction extends MSAction {
  feedback(sender: any): IBAction;
}
declare const MSFeedbackAction: {
  alloc(): MSFeedbackActionAllocator;
}

interface MSFillAndBorderColorScreenPickerAllocator<InitializedType = MSFillAndBorderColorScreenPicker> extends NSObjectAllocator<MSFillAndBorderColorScreenPicker> {}
interface MSFillAndBorderColorScreenPicker extends NSObject {
}
declare const MSFillAndBorderColorScreenPicker: {
  alloc(): MSFillAndBorderColorScreenPickerAllocator;  pickColorForLayers_colorSpace_completionBlock(layers: NSArray<any> | any[], colorspace: NSColorSpace, completionBlock: BCVoidBlock): void;
  applyColor_toLayers(chosenColor: MSColor, layers: NSArray<any> | any[]): void;
  setPreferredStylePartName(name: NSString | string): void;

}

interface MSFillInspectorViewControllerAllocator<InitializedType = MSFillInspectorViewController> extends MSColorStylePartInspectorViewControllerAllocator<MSFillInspectorViewController> {}
interface MSFillInspectorViewController extends MSColorStylePartInspectorViewController {
  opacityFieldAction(sender: any): IBAction;

  blendingPopUpButton(): NSPopUpButton;
  setBlendingPopUpButton(blendingPopUpButton: NSPopUpButton): void;
  opacityField(): MSUpDownTextField;
  setOpacityField(opacityField: MSUpDownTextField): void;
}
declare const MSFillInspectorViewController: {
  alloc(): MSFillInspectorViewControllerAllocator;
}

interface MSFillOptionsInspectorViewControllerAllocator<InitializedType = MSFillOptionsInspectorViewController> extends NSViewControllerAllocator<MSFillOptionsInspectorViewController> {}
interface MSFillOptionsInspectorViewController extends NSViewController {

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}
declare const MSFillOptionsInspectorViewController: {
  alloc(): MSFillOptionsInspectorViewControllerAllocator;
}

interface MSBarViewAllocator<InitializedType = MSBarView> extends MSGradientViewAllocator<MSBarView> {}
interface MSBarView extends MSGradientView {
}
declare const MSBarView: {
  alloc(): MSBarViewAllocator;
}

interface MSFilterBarViewAllocator<InitializedType = MSFilterBarView> extends MSBarViewAllocator<MSFilterBarView> {}
interface MSFilterBarView extends MSBarView {
}
declare const MSFilterBarView: {
  alloc(): MSFilterBarViewAllocator;
}

interface MSFindLayerActionAllocator<InitializedType = MSFindLayerAction> extends MSDocumentActionAllocator<MSFindLayerAction> {}
interface MSFindLayerAction extends MSDocumentAction {
  findLayer(sender: any): IBAction;
}
declare const MSFindLayerAction: {
  alloc(): MSFindLayerActionAllocator;
}

interface MSFinishEditingButtonAllocator<InitializedType = MSFinishEditingButton> extends NSButtonAllocator<MSFinishEditingButton> {}
interface MSFinishEditingButton extends NSButton {
}
declare const MSFinishEditingButton: {
  alloc(): MSFinishEditingButtonAllocator;
}

interface MSFixedPopoverTouchBarItemAllocator<InitializedType = MSFixedPopoverTouchBarItem> extends NSPopoverTouchBarItemAllocator<MSFixedPopoverTouchBarItem> {}
interface MSFixedPopoverTouchBarItem extends NSPopoverTouchBarItem {

  ms_parentTouchBar(): NSTouchBar;
  setMs_parentTouchBar(ms_parentTouchBar: NSTouchBar): void;
}
declare const MSFixedPopoverTouchBarItem: {
  alloc(): MSFixedPopoverTouchBarItemAllocator;
}

interface MSFlattenActionAllocator<InitializedType = MSFlattenAction> extends MSDocumentActionAllocator<MSFlattenAction> {}
interface MSFlattenAction extends MSDocumentAction {
  flatten(sender: any): IBAction;
}
declare const MSFlattenAction: {
  alloc(): MSFlattenActionAllocator;
}

interface MSFlattenSelectionActionAllocator<InitializedType = MSFlattenSelectionAction> extends MSDocumentActionAllocator<MSFlattenSelectionAction> {}
interface MSFlattenSelectionAction extends MSDocumentAction {
  flattenSelection(sender: any): IBAction;
}
declare const MSFlattenSelectionAction: {
  alloc(): MSFlattenSelectionActionAllocator;
}

interface MSBaseFlipActionAllocator<InitializedType = MSBaseFlipAction> extends MSDocumentActionAllocator<MSBaseFlipAction> {}
interface MSBaseFlipAction extends MSDocumentAction {
}
declare const MSBaseFlipAction: {
  alloc(): MSBaseFlipActionAllocator;
}

interface MSFlipHorizontalActionAllocator<InitializedType = MSFlipHorizontalAction> extends MSBaseFlipActionAllocator<MSFlipHorizontalAction> {}
interface MSFlipHorizontalAction extends MSBaseFlipAction {
  flipHorizontal(sender: any): IBAction;
}
declare const MSFlipHorizontalAction: {
  alloc(): MSFlipHorizontalActionAllocator;
}

interface MSFlipVerticalActionAllocator<InitializedType = MSFlipVerticalAction> extends MSBaseFlipActionAllocator<MSFlipVerticalAction> {}
interface MSFlipVerticalAction extends MSBaseFlipAction {
  flipVertical(sender: any): IBAction;
}
declare const MSFlipVerticalAction: {
  alloc(): MSFlipVerticalActionAllocator;
}

interface MSApplyHorizontalFlipActionAllocator<InitializedType = MSApplyHorizontalFlipAction> extends MSBaseFlipActionAllocator<MSApplyHorizontalFlipAction> {}
interface MSApplyHorizontalFlipAction extends MSBaseFlipAction {
}
declare const MSApplyHorizontalFlipAction: {
  alloc(): MSApplyHorizontalFlipActionAllocator;
}

interface MSApplyVerticalFlipActionAllocator<InitializedType = MSApplyVerticalFlipAction> extends MSBaseFlipActionAllocator<MSApplyVerticalFlipAction> {}
interface MSApplyVerticalFlipAction extends MSBaseFlipAction {
}
declare const MSApplyVerticalFlipAction: {
  alloc(): MSApplyVerticalFlipActionAllocator;
}

interface MSFlippedViewAllocator<InitializedType = MSFlippedView> extends NSViewAllocator<MSFlippedView> {}
interface MSFlippedView extends NSView {
}
declare const MSFlippedView: {
  alloc(): MSFlippedViewAllocator;
}

interface MSFlowBaseActionAllocator<InitializedType = MSFlowBaseAction> extends MSDocumentActionAllocator<MSFlowBaseAction> {}
interface MSFlowBaseAction extends MSDocumentAction {
  refreshLayerListInspectorAndOverlay(): void;
}
declare const MSFlowBaseAction: {
  alloc(): MSFlowBaseActionAllocator;
}

interface MSChangeFlowAnimationActionAllocator<InitializedType = MSChangeFlowAnimationAction> extends MSDocumentActionAllocator<MSChangeFlowAnimationAction> {}
interface MSChangeFlowAnimationAction extends MSDocumentAction {
}
declare const MSChangeFlowAnimationAction: {
  alloc(): MSChangeFlowAnimationActionAllocator;
}

interface MSChangeFlowAnimationNoAnimationActionAllocator<InitializedType = MSChangeFlowAnimationNoAnimationAction> extends MSChangeFlowAnimationActionAllocator<MSChangeFlowAnimationNoAnimationAction> {}
interface MSChangeFlowAnimationNoAnimationAction extends MSChangeFlowAnimationAction {
  changeFlowAnimationToNoAnimation(sender: any): IBAction;
}
declare const MSChangeFlowAnimationNoAnimationAction: {
  alloc(): MSChangeFlowAnimationNoAnimationActionAllocator;
}

interface MSChangeFlowAnimationFromLeftAnimationActionAllocator<InitializedType = MSChangeFlowAnimationFromLeftAnimationAction> extends MSChangeFlowAnimationActionAllocator<MSChangeFlowAnimationFromLeftAnimationAction> {}
interface MSChangeFlowAnimationFromLeftAnimationAction extends MSChangeFlowAnimationAction {
  changeFlowAnimationToFromLeftAnimation(sender: any): IBAction;
}
declare const MSChangeFlowAnimationFromLeftAnimationAction: {
  alloc(): MSChangeFlowAnimationFromLeftAnimationActionAllocator;
}

interface MSChangeFlowAnimationFromRightAnimationActionAllocator<InitializedType = MSChangeFlowAnimationFromRightAnimationAction> extends MSChangeFlowAnimationActionAllocator<MSChangeFlowAnimationFromRightAnimationAction> {}
interface MSChangeFlowAnimationFromRightAnimationAction extends MSChangeFlowAnimationAction {
  changeFlowAnimationToFromRightAnimation(sender: any): IBAction;
}
declare const MSChangeFlowAnimationFromRightAnimationAction: {
  alloc(): MSChangeFlowAnimationFromRightAnimationActionAllocator;
}

interface MSChangeFlowAnimationFromTopAnimationActionAllocator<InitializedType = MSChangeFlowAnimationFromTopAnimationAction> extends MSChangeFlowAnimationActionAllocator<MSChangeFlowAnimationFromTopAnimationAction> {}
interface MSChangeFlowAnimationFromTopAnimationAction extends MSChangeFlowAnimationAction {
  changeFlowAnimationToFromTopAnimation(sender: any): IBAction;
}
declare const MSChangeFlowAnimationFromTopAnimationAction: {
  alloc(): MSChangeFlowAnimationFromTopAnimationActionAllocator;
}

interface MSChangeFlowAnimationFromBottomAnimationActionAllocator<InitializedType = MSChangeFlowAnimationFromBottomAnimationAction> extends MSChangeFlowAnimationActionAllocator<MSChangeFlowAnimationFromBottomAnimationAction> {}
interface MSChangeFlowAnimationFromBottomAnimationAction extends MSChangeFlowAnimationAction {
  changeFlowAnimationToFromBottomAnimation(sender: any): IBAction;
}
declare const MSChangeFlowAnimationFromBottomAnimationAction: {
  alloc(): MSChangeFlowAnimationFromBottomAnimationActionAllocator;
}

interface MSFlowEventHandlerAllocator<InitializedType = MSFlowEventHandler> extends MSEventHandlerAllocator<MSFlowEventHandler> {}
interface MSFlowEventHandler extends MSEventHandler, IMSFlowMenuBuilderTarget {
  findMouseAndDisconnectFromTarget(): void;

  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
}
declare const MSFlowEventHandler: {
  alloc(): MSFlowEventHandlerAllocator;
}

interface MSFlowFixLayerInspectorItemAllocator<InitializedType = MSFlowFixLayerInspectorItem> extends MSInspectorItemAllocator<MSFlowFixLayerInspectorItem> {}
interface MSFlowFixLayerInspectorItem extends MSInspectorItem {
}
declare const MSFlowFixLayerInspectorItem: {
  alloc(): MSFlowFixLayerInspectorItemAllocator;
}

interface MSFlowHeaderInspectorItemAllocator<InitializedType = MSFlowHeaderInspectorItem> extends MSCollapsibleHeaderInspectorItemAllocator<MSFlowHeaderInspectorItem> {}
interface MSFlowHeaderInspectorItem extends MSCollapsibleHeaderInspectorItem {
}
declare const MSFlowHeaderInspectorItem: {
  alloc(): MSFlowHeaderInspectorItemAllocator;
}

interface MSFlowInspectorItemAllocator<InitializedType = MSFlowInspectorItem> extends MSInspectorItemAllocator<MSFlowInspectorItem> {}
interface MSFlowInspectorItem extends MSInspectorItem {
}
declare const MSFlowInspectorItem: {
  alloc(): MSFlowInspectorItemAllocator;
}

interface MSFlowInspectorSectionAllocator<InitializedType = MSFlowInspectorSection> extends MSBaseInspectorSectionAllocator<MSFlowInspectorSection> {}
interface MSFlowInspectorSection extends MSBaseInspectorSection {
}
declare const MSFlowInspectorSection: {
  alloc(): MSFlowInspectorSectionAllocator;
}

interface MSFlowMenuBuilderAllocator<InitializedType = MSFlowMenuBuilder> extends NSObjectAllocator<MSFlowMenuBuilder> {}
interface MSFlowMenuBuilder extends NSObject {
}
declare const MSFlowMenuBuilder: {
  alloc(): MSFlowMenuBuilderAllocator;  createFlowDestinationMenuButton_document_destination_target(button: NSPopUpButton, doc: MSDocumentData, destinationID: NSString | string, target: any): void;
  menuForPages_target(pages: NSArray<any> | any[], target: any): NSMenu;

}

interface IMSFlowMenuBuilderTarget {
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
}

interface MSFollowFlowActionAllocator<InitializedType = MSFollowFlowAction> extends MSFlowBaseActionAllocator<MSFollowFlowAction> {}
interface MSFollowFlowAction extends MSFlowBaseAction {
  followFlow(sender: any): IBAction;
}
declare const MSFollowFlowAction: {
  alloc(): MSFollowFlowActionAllocator;
}

interface MSFontFamilyPickerViewControllerAllocator<InitializedType = MSFontFamilyPickerViewController> extends NSViewControllerAllocator<MSFontFamilyPickerViewController> {}
interface MSFontFamilyPickerViewController extends NSViewController, INSTableViewDelegate, INSTableViewDataSource {

  completionBlock(): MSFontFamilyPickerCompletionBlock;
  setCompletionBlock(completionBlock: MSFontFamilyPickerCompletionBlock): void;
  fontList(): MSFontList;
  setFontList(fontList: MSFontList): void;
  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
}
declare const MSFontFamilyPickerViewController: {
  alloc(): MSFontFamilyPickerViewControllerAllocator;
}

interface MSFontFamilyTextFieldCellAllocator<InitializedType = MSFontFamilyTextFieldCell> extends NSTextFieldCellAllocator<MSFontFamilyTextFieldCell> {}
interface MSFontFamilyTextFieldCell extends NSTextFieldCell {
}
declare const MSFontFamilyTextFieldCell: {
  alloc(): MSFontFamilyTextFieldCellAllocator;
}

interface MSFontNamesTableViewAllocator<InitializedType = MSFontNamesTableView> extends NSTableViewAllocator<MSFontNamesTableView> {}
interface MSFontNamesTableView extends NSTableView {

  searchField(): NSSearchField;
  setSearchField(searchField: NSSearchField): void;
}
declare const MSFontNamesTableView: {
  alloc(): MSFontNamesTableViewAllocator;
}

interface MSUpDownComboBoxAllocator<InitializedType = MSUpDownComboBox> extends NSComboBoxAllocator<MSUpDownComboBox> {}
interface MSUpDownComboBox extends NSComboBox {

  refreshDelegate(): any;
  setRefreshDelegate(refreshDelegate: any): void;
  upDownController(): MSUpDownController;
  setUpDownController(upDownController: MSUpDownController): void;
}
declare const MSUpDownComboBox: {
  alloc(): MSUpDownComboBoxAllocator;
}

interface MSFontSizeUpDownComboBoxAllocator<InitializedType = MSFontSizeUpDownComboBox> extends MSUpDownComboBoxAllocator<MSFontSizeUpDownComboBox> {}
interface MSFontSizeUpDownComboBox extends MSUpDownComboBox {
}
declare const MSFontSizeUpDownComboBox: {
  alloc(): MSFontSizeUpDownComboBoxAllocator;
}

interface MSFontWatcherAllocator<InitializedType = MSFontWatcher> extends NSObjectAllocator<MSFontWatcher> {
  initWithDocumentController(documentController: NSDocumentController): InitializedType;
}
interface MSFontWatcher extends NSObject {
}
declare const MSFontWatcher: {
  alloc(): MSFontWatcherAllocator;
}

interface MSFooterInspectorSectionAllocator<InitializedType = MSFooterInspectorSection> extends MSBaseInspectorSectionAllocator<MSFooterInspectorSection> {}
interface MSFooterInspectorSection extends MSBaseInspectorSection {
}
declare const MSFooterInspectorSection: {
  alloc(): MSFooterInspectorSectionAllocator;
}

interface MSForeignObjectProviderAllocator<InitializedType = MSForeignObjectProvider> extends NSObjectAllocator<MSForeignObjectProvider> {
  initWithDocument(document: MSDocument): InitializedType;
}
interface MSForeignObjectProvider extends NSObject, IMSForeignObjectProvider {
}
declare const MSForeignObjectProvider: {
  alloc(): MSForeignObjectProviderAllocator;  providerForLayers_inDocument(layers: MSLayerArray, document: MSDocument): MSForeignObjectProvider;

}

interface MSForeignSymbolProviderAllocator<InitializedType = MSForeignSymbolProvider> extends MSForeignObjectProviderAllocator<MSForeignSymbolProvider> {}
interface MSForeignSymbolProvider extends MSForeignObjectProvider {
}
declare const MSForeignSymbolProvider: {
  alloc(): MSForeignSymbolProviderAllocator;
}

interface MSSharedLayerStyleProviderAllocator<InitializedType = MSSharedLayerStyleProvider> extends MSForeignObjectProviderAllocator<MSSharedLayerStyleProvider> {}
interface MSSharedLayerStyleProvider extends MSForeignObjectProvider {
}
declare const MSSharedLayerStyleProvider: {
  alloc(): MSSharedLayerStyleProviderAllocator;
}

interface MSSharedTextStyleProviderAllocator<InitializedType = MSSharedTextStyleProvider> extends MSForeignObjectProviderAllocator<MSSharedTextStyleProvider> {}
interface MSSharedTextStyleProvider extends MSForeignObjectProvider {
}
declare const MSSharedTextStyleProvider: {
  alloc(): MSSharedTextStyleProviderAllocator;
}

interface MSGeneralPreferencePaneAllocator<InitializedType = MSGeneralPreferencePane> extends MSPreferencePaneAllocator<MSGeneralPreferencePane> {}
interface MSGeneralPreferencePane extends MSPreferencePane {
  analyticsAction(sender: any): IBAction;
  pickDefaultColorSpace(sender: any): IBAction;

  defaultColorSpaceDescriptionLabel(): NSTextField;
  setDefaultColorSpaceDescriptionLabel(defaultColorSpaceDescriptionLabel: NSTextField): void;
  defaultColorSpacePopUpButton(): NSPopUpButton;
  setDefaultColorSpacePopUpButton(defaultColorSpacePopUpButton: NSPopUpButton): void;
}
declare const MSGeneralPreferencePane: {
  alloc(): MSGeneralPreferencePaneAllocator;
}

interface MSGeometryInspectorSectionAllocator<InitializedType = MSGeometryInspectorSection> extends MSBaseInspectorSectionAllocator<MSGeometryInspectorSection> {}
interface MSGeometryInspectorSection extends MSBaseInspectorSection {

  shouldShowPositions(): boolean;
  setShouldShowPositions(shouldShowPositions: boolean): void;
}
declare const MSGeometryInspectorSection: {
  alloc(): MSGeometryInspectorSectionAllocator;
}

interface MSGoogleAnalyticsWrapperAllocator<InitializedType = MSGoogleAnalyticsWrapper> extends NSObjectAllocator<MSGoogleAnalyticsWrapper> {}
interface MSGoogleAnalyticsWrapper extends NSObject, IWebFrameLoadDelegate, IWebResourceLoadDelegate, IWebUIDelegate {
  start(): void;
  stop(): void;
  sendAction_arguments(action: NSString | string, arguments: NSArray<any> | any[]): void;
}
declare const MSGoogleAnalyticsWrapper: {
  alloc(): MSGoogleAnalyticsWrapperAllocator;
}

interface MSGradientBarViewAllocator<InitializedType = MSGradientBarView> extends BCColorPickerBaseViewAllocator<MSGradientBarView> {}
interface MSGradientBarView extends BCColorPickerBaseView {

  delegate(): any;
  setDelegate(delegate: any): void;
  gradient(): MSGradient;
  setGradient(gradient: MSGradient): void;
  selectedStopIndex(): NSUInteger;
  setSelectedStopIndex(selectedStopIndex: NSUInteger): void;
}
declare const MSGradientBarView: {
  alloc(): MSGradientBarViewAllocator;
}

interface IMSGradientBarViewDelegate {
  gradientBarViewPreviewColorSpace(gradientBarView: MSGradientBarView): NSColorSpace;
  gradientBarChanged(gradientView: MSGradientBarView): void;
}

interface MSGradientEventHandlerAllocator<InitializedType = MSGradientEventHandler> extends MSPointsEventHandlerAllocator<MSGradientEventHandler> {}
interface MSGradientEventHandler extends MSPointsEventHandler, IMSGradientPointArrayDelegate {
  gradient(): MSGradient;
  selectPointCursor(): NSCursor;
  insertPointCursor(): NSCursor;
  canInsertPointAtMouse(mouse: NSPoint): boolean;
  addStopAtPosition(mouse: NSPoint): NSInteger;
  repairGradientIfNecessary(): void;

  stylePart(): MSStyleBasicFill;
  setStylePart(stylePart: MSStyleBasicFill): void;
  gradientDelegate(): any;
  setGradientDelegate(gradientDelegate: any): void;
}
declare const MSGradientEventHandler: {
  alloc(): MSGradientEventHandlerAllocator;  gradientHandlerForStylePart_manager(part: MSStyleBasicFill, manager: MSEventHandlerManager): MSGradientEventHandler;

}

interface IMSGradientEventHandlerDelegate {
  gradientHandlerDidChangeCurrentPoint(handler: MSGradientEventHandler): void;
  gradientHandlerDidChangeGradient(handler: MSGradientEventHandler): void;
  gradientHandlerWillLoseFocus(handler: MSGradientEventHandler): void;
}

interface MSGradientViewAllocator<InitializedType = MSGradientView> extends NSViewAllocator<MSGradientView> {}
interface MSGradientView extends NSView {

  topColour(): NSColor;
  setTopColour(topColour: NSColor): void;
  bottomColour(): NSColor;
  setBottomColour(bottomColour: NSColor): void;
  borderColour(): NSColor;
  setBorderColour(borderColour: NSColor): void;
  gradientAngle(): number;
  setGradientAngle(gradientAngle: number): void;
  borderSize(): number;
  setBorderSize(borderSize: number): void;
  topBorder(): boolean;
  setTopBorder(topBorder: boolean): void;
  leftBorder(): boolean;
  setLeftBorder(leftBorder: boolean): void;
  rightBorder(): boolean;
  setRightBorder(rightBorder: boolean): void;
  bottomBorder(): boolean;
  setBottomBorder(bottomBorder: boolean): void;
}
declare const MSGradientView: {
  alloc(): MSGradientViewAllocator;
}

interface MSGridSettingsActionAllocator<InitializedType = MSGridSettingsAction> extends MSDocumentActionAllocator<MSGridSettingsAction> {}
interface MSGridSettingsAction extends MSDocumentAction {
  gridSettings(sender: any): IBAction;
}
declare const MSGridSettingsAction: {
  alloc(): MSGridSettingsActionAllocator;
}

interface MSGridSheetAllocator<InitializedType = MSGridSheet> extends MSGridSheetBaseAllocator<MSGridSheet> {}
interface MSGridSheet extends MSGridSheetBase {
  setAsDefault(sender: any): IBAction;
}
declare const MSGridSheet: {
  alloc(): MSGridSheetAllocator;
}

interface MSGridSheetBaseAllocator<InitializedType = MSGridSheetBase> extends CHSheetControllerAllocator<MSGridSheetBase> {}
interface MSGridSheetBase extends CHSheetController, INSWindowDelegate {
  baseObjectForRootLayer(root: any): MSBaseGrid;
  defaultObject(): MSBaseGrid;
  applyObject_toLayer(obj: MSBaseGrid, root: any): void;
  refreshView(): void;
  refreshCanvas(sender: any): IBAction;
  gridChanged(grid: any): IBAction;
  cancelAction(sender: any): IBAction;

  originalSettings(): NSMapTable<any, any>;
  templateObject(): MSBaseGrid;
}
declare const MSGridSheetBase: {
  alloc(): MSGridSheetBaseAllocator;
}

interface MSGroupActionAllocator<InitializedType = MSGroupAction> extends MSDocumentActionAllocator<MSGroupAction> {}
interface MSGroupAction extends MSDocumentAction {
  group(sender: any): IBAction;
}
declare const MSGroupAction: {
  alloc(): MSGroupActionAllocator;
}

interface MSUngroupActionAllocator<InitializedType = MSUngroupAction> extends MSDocumentActionAllocator<MSUngroupAction> {}
interface MSUngroupAction extends MSDocumentAction {
  ungroup(sender: any): IBAction;
}
declare const MSUngroupAction: {
  alloc(): MSUngroupActionAllocator;
}

interface MSGroupActionGroupAllocator<InitializedType = MSGroupActionGroup> extends MSActionGroupAllocator<MSGroupActionGroup> {}
interface MSGroupActionGroup extends MSActionGroup {
}
declare const MSGroupActionGroup: {
  alloc(): MSGroupActionGroupAllocator;
}

interface MSHangingGlyphViewAllocator<InitializedType = MSHangingGlyphView> extends NSViewAllocator<MSHangingGlyphView> {}
interface MSHangingGlyphView extends NSView {

  textView(): NSTextView;
  setTextView(textView: NSTextView): void;
}
declare const MSHangingGlyphView: {
  alloc(): MSHangingGlyphViewAllocator;
}

interface MSHeader2InspectorItemAllocator<InitializedType = MSHeader2InspectorItem> extends MSInspectorItemAllocator<MSHeader2InspectorItem> {}
interface MSHeader2InspectorItem extends MSInspectorItem {

  labelText(): NSString;
  setLabelText(labelText: NSString | string): void;
}
declare const MSHeader2InspectorItem: {
  alloc(): MSHeader2InspectorItemAllocator;
}

interface MSHeaderInspectorItemAllocator<InitializedType = MSHeaderInspectorItem> extends MSInspectorItemAllocator<MSHeaderInspectorItem> {}
interface MSHeaderInspectorItem extends MSInspectorItem {
  setButtonTarget_action_image_alternate(target: any, action: string, image: NSImage, alternateImage: NSImage): void;

  labelText(): NSString;
  setLabelText(labelText: NSString | string): void;
  buttonState(): NSControlStateValue;
  setButtonState(buttonState: NSControlStateValue): void;
}
declare const MSHeaderInspectorItem: {
  alloc(): MSHeaderInspectorItemAllocator;
}

interface MSHideLayerActionAllocator<InitializedType = MSHideLayerAction> extends MSDocumentActionAllocator<MSHideLayerAction> {}
interface MSHideLayerAction extends MSDocumentAction {
  hideLayer(sender: any): IBAction;
}
declare const MSHideLayerAction: {
  alloc(): MSHideLayerActionAllocator;
}

interface MSHistoryMakerAllocator<InitializedType = MSHistoryMaker> extends NSObjectAllocator<MSHistoryMaker> {
  initWithDocument(document: MSDocument): InitializedType;
}
interface MSHistoryMaker extends NSObject {
  registerHistoryMomentTitle(title: NSString | string): void;
  canMoveThroughHistoryBackInTime(backInTime: boolean): boolean;
  moveThroughHistoryBackInTime(backwards: boolean): void;
  startCoalescingHistory(): void;
  finishCoalescingHistory(): void;
  coalesceHistoryInBlock(block: BCVoidBlock): void;
  deferMakingHistoryInBlock(block: BCVoidBlock): void;
  ignoreDocumentChangesInBlock(block: BCVoidBlock): boolean;
  makeHistoryIfNecessary(): void;
  makeTransientMomentInHistoryIfNecessary(): void;
  commitTransientMomentIfNecessary(): void;
  updateCurrentMomentWithSelection(selectedLayerIDs: NSSet<any>): void;

  document(): MSDocument;
  history(): MSHistory;
  historyMomentTitle(): NSString;
  historyIsCoalescing(): boolean;
}
declare const MSHistoryMaker: {
  alloc(): MSHistoryMakerAllocator;
}

interface MSHotspotOverrideInspectorItemAllocator<InitializedType = MSHotspotOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<MSHotspotOverrideInspectorItem> {}
interface MSHotspotOverrideInspectorItem extends MSOverrideInspectorItem, IMSFlowMenuBuilderTarget {
}
declare const MSHotspotOverrideInspectorItem: {
  alloc(): MSHotspotOverrideInspectorItemAllocator;
}

interface MSIgnoreClippingMaskActionAllocator<InitializedType = MSIgnoreClippingMaskAction> extends MSDocumentActionAllocator<MSIgnoreClippingMaskAction> {}
interface MSIgnoreClippingMaskAction extends MSDocumentAction {
  ignoreClippingMask(sender: any): IBAction;
}
declare const MSIgnoreClippingMaskAction: {
  alloc(): MSIgnoreClippingMaskActionAllocator;
}

interface MSImageOriginalSizeActionAllocator<InitializedType = MSImageOriginalSizeAction> extends MSDocumentActionAllocator<MSImageOriginalSizeAction> {}
interface MSImageOriginalSizeAction extends MSDocumentAction {
  imageOriginalSize(sender: any): IBAction;
}
declare const MSImageOriginalSizeAction: {
  alloc(): MSImageOriginalSizeActionAllocator;
}

interface MSImageOverrideViewAllocator<InitializedType = MSImageOverrideView> extends NSImageViewAllocator<MSImageOverrideView> {}
interface MSImageOverrideView extends NSImageView {

  normalImage(): NSImage;
  setNormalImage(normalImage: NSImage): void;
  placeholderImage(): NSImage;
  setPlaceholderImage(placeholderImage: NSImage): void;
}
declare const MSImageOverrideView: {
  alloc(): MSImageOverrideViewAllocator;
}

interface MSImageTransformEventHandlerAllocator<InitializedType = MSImageTransformEventHandler> extends MSTransformEventHandlerAllocator<MSImageTransformEventHandler> {}
interface MSImageTransformEventHandler extends MSTransformEventHandler {
}
declare const MSImageTransformEventHandler: {
  alloc(): MSImageTransformEventHandlerAllocator;
}

interface MSImageViewAllocator<InitializedType = MSImageView> extends NSImageViewAllocator<MSImageView> {}
interface MSImageView extends NSImageView {
}
declare const MSImageView: {
  alloc(): MSImageViewAllocator;
}

interface MSIncludeBackgroundColorInExportInspectorItemAllocator<InitializedType = MSIncludeBackgroundColorInExportInspectorItem> extends MSInspectorItemAllocator<MSIncludeBackgroundColorInExportInspectorItem> {}
interface MSIncludeBackgroundColorInExportInspectorItem extends MSInspectorItem {
}
declare const MSIncludeBackgroundColorInExportInspectorItem: {
  alloc(): MSIncludeBackgroundColorInExportInspectorItemAllocator;
}

interface MSIncludeBackgroundColorInInstancesInspectorItemAllocator<InitializedType = MSIncludeBackgroundColorInInstancesInspectorItem> extends MSInspectorItemAllocator<MSIncludeBackgroundColorInInstancesInspectorItem> {}
interface MSIncludeBackgroundColorInInstancesInspectorItem extends MSInspectorItem {
}
declare const MSIncludeBackgroundColorInInstancesInspectorItem: {
  alloc(): MSIncludeBackgroundColorInInstancesInspectorItemAllocator;
}

interface MSIncompatiblePluginsDisabledActionAllocator<InitializedType = MSIncompatiblePluginsDisabledAction> extends MSDocumentActionAllocator<MSIncompatiblePluginsDisabledAction> {}
interface MSIncompatiblePluginsDisabledAction extends MSDocumentAction, IMSWindowBadgeAction {
}
declare const MSIncompatiblePluginsDisabledAction: {
  alloc(): MSIncompatiblePluginsDisabledActionAllocator;
}

interface MSInlineIntegratedStepperAllocator<InitializedType = MSInlineIntegratedStepper> extends MSIntegratedStepperAllocator<MSInlineIntegratedStepper> {}
interface MSInlineIntegratedStepper extends MSIntegratedStepper {
}
declare const MSInlineIntegratedStepper: {
  alloc(): MSInlineIntegratedStepperAllocator;
}

interface MSInlineTextLabelForUpDownFieldAllocator<InitializedType = MSInlineTextLabelForUpDownField> extends MSTextLabelForUpDownFieldAllocator<MSInlineTextLabelForUpDownField> {}
interface MSInlineTextLabelForUpDownField extends MSTextLabelForUpDownField {
}
declare const MSInlineTextLabelForUpDownField: {
  alloc(): MSInlineTextLabelForUpDownFieldAllocator;  labelWithImage(image: NSImage): MSInlineTextLabelForUpDownField;

}

interface MSInlineTextLabelImageCellAllocator<InitializedType = MSInlineTextLabelImageCell> extends NSTextFieldCellAllocator<MSInlineTextLabelImageCell> {}
interface MSInlineTextLabelImageCell extends NSTextFieldCell {
}
declare const MSInlineTextLabelImageCell: {
  alloc(): MSInlineTextLabelImageCellAllocator;  inlineTextLabelFont(): NSFont;

}

interface MSInlineUpDownControllerAllocator<InitializedType = MSInlineUpDownController> extends MSUpDownControllerAllocator<MSInlineUpDownController> {}
interface MSInlineUpDownController extends MSUpDownController {
}
declare const MSInlineUpDownController: {
  alloc(): MSInlineUpDownControllerAllocator;
}

interface MSInlineUpDownTextFieldAllocator<InitializedType = MSInlineUpDownTextField> extends MSUpDownTextFieldAllocator<MSInlineUpDownTextField> {}
interface MSInlineUpDownTextField extends MSUpDownTextField {

  inlineLabel(): NSString;
  setInlineLabel(inlineLabel: NSString | string): void;
  inlineImage(): NSImage;
  setInlineImage(inlineImage: NSImage): void;
  inlineFieldWidth(): CGFloat;
  inlineLabelField(): NSTextField;
}
declare const MSInlineUpDownTextField: {
  alloc(): MSInlineUpDownTextFieldAllocator;
}

interface MSInlineUpDownMiniTextFieldAllocator<InitializedType = MSInlineUpDownMiniTextField> extends MSInlineUpDownTextFieldAllocator<MSInlineUpDownMiniTextField> {}
interface MSInlineUpDownMiniTextField extends MSInlineUpDownTextField {
}
declare const MSInlineUpDownMiniTextField: {
  alloc(): MSInlineUpDownMiniTextFieldAllocator;
}

interface MSInlineUpDownNanoTextFieldAllocator<InitializedType = MSInlineUpDownNanoTextField> extends MSInlineUpDownTextFieldAllocator<MSInlineUpDownNanoTextField> {}
interface MSInlineUpDownNanoTextField extends MSInlineUpDownTextField {
}
declare const MSInlineUpDownNanoTextField: {
  alloc(): MSInlineUpDownNanoTextFieldAllocator;
}

interface MSInlineUpDownTextFieldCellAllocator<InitializedType = MSInlineUpDownTextFieldCell> extends NSTextFieldCellAllocator<MSInlineUpDownTextFieldCell> {}
interface MSInlineUpDownTextFieldCell extends NSTextFieldCell {
}
declare const MSInlineUpDownTextFieldCell: {
  alloc(): MSInlineUpDownTextFieldCellAllocator;
}

interface MSInsertArrowActionAllocator<InitializedType = MSInsertArrowAction> extends MSInsertLineActionAllocator<MSInsertArrowAction> {}
interface MSInsertArrowAction extends MSInsertLineAction {
}
declare const MSInsertArrowAction: {
  alloc(): MSInsertArrowActionAllocator;
}

interface MSInsertArtboardActionAllocator<InitializedType = MSInsertArtboardAction> extends MSBaseInsertActionAllocator<MSInsertArtboardAction> {}
interface MSInsertArtboardAction extends MSBaseInsertAction {
  insertArtboard(sender: any): IBAction;
}
declare const MSInsertArtboardAction: {
  alloc(): MSInsertArtboardActionAllocator;
}

interface MSInsertArtboardEventHandlerAllocator<InitializedType = MSInsertArtboardEventHandler> extends MSInsertLayerEventHandlerAllocator<MSInsertArtboardEventHandler> {}
interface MSInsertArtboardEventHandler extends MSInsertLayerEventHandler {
  insertArtboardFromPreset(preset: MSArtboardPreset): void;
}
declare const MSInsertArtboardEventHandler: {
  alloc(): MSInsertArtboardEventHandlerAllocator;
}

interface MSInsertArtboardInspectorViewControllerAllocator<InitializedType = MSInsertArtboardInspectorViewController> extends NSViewControllerAllocator<MSInsertArtboardInspectorViewController> {}
interface MSInsertArtboardInspectorViewController extends NSViewController, IMSInspectorChildController {

  shouldAddInsertFromSelectionItem(): boolean;
  setShouldAddInsertFromSelectionItem(shouldAddInsertFromSelectionItem: boolean): void;
  proposedArtboardSize(): NSSize;
  setProposedArtboardSize(proposedArtboardSize: NSSize): void;
  eventHandler(): MSInsertArtboardEventHandler;
  setEventHandler(eventHandler: MSInsertArtboardEventHandler): void;
}
declare const MSInsertArtboardInspectorViewController: {
  alloc(): MSInsertArtboardInspectorViewControllerAllocator;
}

interface MSInsertHotspotActionAllocator<InitializedType = MSInsertHotspotAction> extends MSDocumentActionAllocator<MSInsertHotspotAction> {}
interface MSInsertHotspotAction extends MSDocumentAction {
  insertHotspot(sender: any): IBAction;
}
declare const MSInsertHotspotAction: {
  alloc(): MSInsertHotspotActionAllocator;
}

interface MSInsertHotspotEventHandlerAllocator<InitializedType = MSInsertHotspotEventHandler> extends MSInsertLayerEventHandlerAllocator<MSInsertHotspotEventHandler> {}
interface MSInsertHotspotEventHandler extends MSInsertLayerEventHandler {
}
declare const MSInsertHotspotEventHandler: {
  alloc(): MSInsertHotspotEventHandlerAllocator;
}

interface MSInsertLayerEventHandlerAllocator<InitializedType = MSInsertLayerEventHandler> extends MSDragRectEventHandlerAllocator<MSInsertLayerEventHandler> {}
interface MSInsertLayerEventHandler extends MSDragRectEventHandler {

  prototypeLayer(): MSLayer;
  setPrototypeLayer(prototypeLayer: MSLayer): void;
  insertedLayer(): MSLayer;
  setInsertedLayer(insertedLayer: MSLayer): void;
}
declare const MSInsertLayerEventHandler: {
  alloc(): MSInsertLayerEventHandlerAllocator;
}

interface MSInsertLineActionAllocator<InitializedType = MSInsertLineAction> extends MSBaseInsertActionAllocator<MSInsertLineAction> {}
interface MSInsertLineAction extends MSBaseInsertAction {
  lineShapeFrom_to(from: NSPoint, to: NSPoint): MSShapePathLayer;
  eventHandlerClass(): any;
}
declare const MSInsertLineAction: {
  alloc(): MSInsertLineActionAllocator;
}

interface MSInsertLineEventHandlerAllocator<InitializedType = MSInsertLineEventHandler> extends MSEventHandlerAllocator<MSInsertLineEventHandler> {}
interface MSInsertLineEventHandler extends MSEventHandler {

  lineShapeCreator(): MSLineShapeCreatorBlock;
  setLineShapeCreator(lineShapeCreator: MSLineShapeCreatorBlock): void;
}
declare const MSInsertLineEventHandler: {
  alloc(): MSInsertLineEventHandlerAllocator;
}

interface MSInsertArrowEventHandlerAllocator<InitializedType = MSInsertArrowEventHandler> extends MSInsertLineEventHandlerAllocator<MSInsertArrowEventHandler> {}
interface MSInsertArrowEventHandler extends MSInsertLineEventHandler {
}
declare const MSInsertArrowEventHandler: {
  alloc(): MSInsertArrowEventHandlerAllocator;
}

interface MSInsertSharedTextActionAllocator<InitializedType = MSInsertSharedTextAction> extends MSSharedObjectActionAllocator<MSInsertSharedTextAction> {}
interface MSInsertSharedTextAction extends MSSharedObjectAction, INSMenuDelegate {
}
declare const MSInsertSharedTextAction: {
  alloc(): MSInsertSharedTextActionAllocator;
}

interface MSInsertSliceActionAllocator<InitializedType = MSInsertSliceAction> extends MSDocumentActionAllocator<MSInsertSliceAction> {}
interface MSInsertSliceAction extends MSDocumentAction {
  insertSlice(sender: any): IBAction;
}
declare const MSInsertSliceAction: {
  alloc(): MSInsertSliceActionAllocator;
}

interface MSInsertSliceEventHandlerAllocator<InitializedType = MSInsertSliceEventHandler> extends MSInsertLayerEventHandlerAllocator<MSInsertSliceEventHandler> {}
interface MSInsertSliceEventHandler extends MSInsertLayerEventHandler {

  allSlices(): NSArray<any>;
  setAllSlices(allSlices: NSArray<any> | any[]): void;
}
declare const MSInsertSliceEventHandler: {
  alloc(): MSInsertSliceEventHandlerAllocator;
}

interface MSInsertSymbolActionAllocator<InitializedType = MSInsertSymbolAction> extends MSSharedSymbolActionAllocator<MSInsertSymbolAction> {}
interface MSInsertSymbolAction extends MSSharedSymbolAction {
}
declare const MSInsertSymbolAction: {
  alloc(): MSInsertSymbolActionAllocator;
}

interface MSInsertSymbolEventHandlerAllocator<InitializedType = MSInsertSymbolEventHandler> extends MSEventHandlerAllocator<MSInsertSymbolEventHandler> {}
interface MSInsertSymbolEventHandler extends MSEventHandler {

  symbolReference(): MSSymbolMasterReference;
  setSymbolReference(symbolReference: MSSymbolMasterReference): void;
}
declare const MSInsertSymbolEventHandler: {
  alloc(): MSInsertSymbolEventHandlerAllocator;
}

interface MSInsertTextEventHandlerAllocator<InitializedType = MSInsertTextEventHandler> extends MSEventHandlerAllocator<MSInsertTextEventHandler> {}
interface MSInsertTextEventHandler extends MSEventHandler {

  textLayer(): MSTextLayer;
  setTextLayer(textLayer: MSTextLayer): void;
  completionBlock(): MSInsertTextEventHandlerCompletionBlock;
  setCompletionBlock(completionBlock: MSInsertTextEventHandlerCompletionBlock): void;
}
declare const MSInsertTextEventHandler: {
  alloc(): MSInsertTextEventHandlerAllocator;
}

interface MSInsertTextLayerActionAllocator<InitializedType = MSInsertTextLayerAction> extends MSBaseInsertActionAllocator<MSInsertTextLayerAction> {}
interface MSInsertTextLayerAction extends MSBaseInsertAction {
  insertTextLayer(sender: any): IBAction;
}
declare const MSInsertTextLayerAction: {
  alloc(): MSInsertTextLayerActionAllocator;
}

interface MSInsertVectorActionAllocator<InitializedType = MSInsertVectorAction> extends MSDocumentActionAllocator<MSInsertVectorAction> {}
interface MSInsertVectorAction extends MSDocumentAction {
  insertVector(sender: any): IBAction;
}
declare const MSInsertVectorAction: {
  alloc(): MSInsertVectorActionAllocator;
}

interface MSInspectorAltButtonCellAllocator<InitializedType = MSInspectorAltButtonCell> extends MSAltButtonCellAllocator<MSInspectorAltButtonCell> {}
interface MSInspectorAltButtonCell extends MSAltButtonCell {
}
declare const MSInspectorAltButtonCell: {
  alloc(): MSInspectorAltButtonCellAllocator;
}

interface MSInspectorBackgroundViewAllocator<InitializedType = MSInspectorBackgroundView> extends MSBackgroundColorViewAllocator<MSInspectorBackgroundView> {}
interface MSInspectorBackgroundView extends MSBackgroundColorView {
}
declare const MSInspectorBackgroundView: {
  alloc(): MSInspectorBackgroundViewAllocator;
}

interface MSInspectorButtonCellAllocator<InitializedType = MSInspectorButtonCell> extends NSButtonCellAllocator<MSInspectorButtonCell> {}
interface MSInspectorButtonCell extends NSButtonCell {
}
declare const MSInspectorButtonCell: {
  alloc(): MSInspectorButtonCellAllocator;
}

interface MSInspectorPushButtonCellAllocator<InitializedType = MSInspectorPushButtonCell> extends NSButtonCellAllocator<MSInspectorPushButtonCell> {}
interface MSInspectorPushButtonCell extends NSButtonCell {
}
declare const MSInspectorPushButtonCell: {
  alloc(): MSInspectorPushButtonCellAllocator;
}

interface MSInspectorCheckmarkCellAllocator<InitializedType = MSInspectorCheckmarkCell> extends MSInspectorButtonCellAllocator<MSInspectorCheckmarkCell> {}
interface MSInspectorCheckmarkCell extends MSInspectorButtonCell {
}
declare const MSInspectorCheckmarkCell: {
  alloc(): MSInspectorCheckmarkCellAllocator;
}

interface MSInspectorToggleButtonCellAllocator<InitializedType = MSInspectorToggleButtonCell> extends MSInspectorButtonCellAllocator<MSInspectorToggleButtonCell> {}
interface MSInspectorToggleButtonCell extends MSInspectorButtonCell {
}
declare const MSInspectorToggleButtonCell: {
  alloc(): MSInspectorToggleButtonCellAllocator;
}

interface MSInspectorSectionHeaderButtonCellAllocator<InitializedType = MSInspectorSectionHeaderButtonCell> extends MSInspectorToggleButtonCellAllocator<MSInspectorSectionHeaderButtonCell> {}
interface MSInspectorSectionHeaderButtonCell extends MSInspectorToggleButtonCell {
}
declare const MSInspectorSectionHeaderButtonCell: {
  alloc(): MSInspectorSectionHeaderButtonCellAllocator;
}

interface MSInspectorToggleImageButtonCellAllocator<InitializedType = MSInspectorToggleImageButtonCell> extends MSInspectorButtonCellAllocator<MSInspectorToggleImageButtonCell> {}
interface MSInspectorToggleImageButtonCell extends MSInspectorButtonCell {
}
declare const MSInspectorToggleImageButtonCell: {
  alloc(): MSInspectorToggleImageButtonCellAllocator;
}

interface MSInspectorSectionHeaderToggleImageButtonCellAllocator<InitializedType = MSInspectorSectionHeaderToggleImageButtonCell> extends MSInspectorToggleImageButtonCellAllocator<MSInspectorSectionHeaderToggleImageButtonCell> {}
interface MSInspectorSectionHeaderToggleImageButtonCell extends MSInspectorToggleImageButtonCell {
}
declare const MSInspectorSectionHeaderToggleImageButtonCell: {
  alloc(): MSInspectorSectionHeaderToggleImageButtonCellAllocator;
}

interface MSInspectorButtonAllocator<InitializedType = MSInspectorButton> extends NSButtonAllocator<MSInspectorButton> {}
interface MSInspectorButton extends NSButton {
}
declare const MSInspectorButton: {
  alloc(): MSInspectorButtonAllocator;
}

interface IMSInspectorChildController {
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
}

interface MSInspectorControlViewAllocator<InitializedType = MSInspectorControlView> extends NSViewAllocator<MSInspectorControlView> {}
interface MSInspectorControlView extends NSView {
}
declare const MSInspectorControlView: {
  alloc(): MSInspectorControlViewAllocator;
}

interface MSInspectorControllerAllocator<InitializedType = MSInspectorController> extends NSViewControllerAllocator<MSInspectorController> {}
interface MSInspectorController extends NSViewController, INSTouchBarDelegate {
  selectionDidChangeTo(layers: MSLayerArray): void;
  changeColor(sender: any): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  currentHandlerChanged(): void;
  handlerManager(): MSEventHandlerManager;
  changeTextLayerFont(sender: any): IBAction;
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
  reloadSharedObjectsSection(): void;
  validateAlignmentButtons(): void;
  reload(): void;
  focusOnFirstTextField(): void;
  focusOnTextFieldWithIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  showFillOptionsAction(sender: any): IBAction;
  showBorderOptionsAction(sender: any): IBAction;
  openPopoverForStylePart_atIndex(stylePart: MSStylePartType, index: NSUInteger): void;
  adjustInspectorToColorPopover_sender(popover: BCPopover, sender: any): void;
  closeAnyColorPopover(): void;
  reloadTouchBars(): void;

  currentController(): NSViewController;
  setCurrentController(currentController: NSViewController): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  globalAssets(): MSPersistentAssetCollection;
  setGlobalAssets(globalAssets: MSPersistentAssetCollection): void;
  alignmentBarHidden(): boolean;
  setAlignmentBarHidden(alignmentBarHidden: boolean): void;
  sharedStyleInspectorVisible(): boolean;
}
declare const MSInspectorController: {
  alloc(): MSInspectorControllerAllocator;
}

interface MSInspectorFlowHandlerAllocator<InitializedType = MSInspectorFlowHandler> extends NSObjectAllocator<MSInspectorFlowHandler> {}
interface MSInspectorFlowHandler extends NSObject, IMSFlowMenuBuilderTarget {
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
  flowConnection(): MSFlowConnection;
  enumerateLayersAndReload(block: Block): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSInspectorFlowHandler: {
  alloc(): MSInspectorFlowHandlerAllocator;  flowConnectionForLayers(layers: MSLayerArray): MSFlowConnection;
  shouldShowFullInspectorForFlow(flow: MSFlowConnection): boolean;
  shouldShowFullInspectorForLayers(layers: MSLayerArray): boolean;

}

interface IMSInspectorFlowHandlerDelegate {
  documentForFlowHandler(flowHandler: MSInspectorFlowHandler): MSDocument;
  layersForFlowHandler(flowHandler: MSInspectorFlowHandler): MSLayerArray;
}

interface IMSInspectorItemDelegate {
  valuesPossiblyChanged(item: NSViewController): void;
  itemDidResize(item: NSViewController): void;
  documentForInspectorItem(section: NSViewController): MSDocument;
  item_wantsSectionToCollapse(item: NSViewController, collapse: boolean): void;
}

interface MSInspectorLeftAlignedPopUpAllocator<InitializedType = MSInspectorLeftAlignedPopUp> extends NSPopUpButtonAllocator<MSInspectorLeftAlignedPopUp> {}
interface MSInspectorLeftAlignedPopUp extends NSPopUpButton {
}
declare const MSInspectorLeftAlignedPopUp: {
  alloc(): MSInspectorLeftAlignedPopUpAllocator;
}

interface MSInspectorNextResponderFixerAllocator<InitializedType = MSInspectorNextResponderFixer> extends NSObjectAllocator<MSInspectorNextResponderFixer> {}
interface MSInspectorNextResponderFixer extends NSObject {
}
declare const MSInspectorNextResponderFixer: {
  alloc(): MSInspectorNextResponderFixerAllocator;  findNextKeyViewFor_inView(keyView: NSView, view: NSView): NSView;
  firstKeyViewForInView(view: NSView): NSView;

}

interface MSInspectorPopUpButtonCellAllocator<InitializedType = MSInspectorPopUpButtonCell> extends NSPopUpButtonCellAllocator<MSInspectorPopUpButtonCell> {}
interface MSInspectorPopUpButtonCell extends NSPopUpButtonCell {
}
declare const MSInspectorPopUpButtonCell: {
  alloc(): MSInspectorPopUpButtonCellAllocator;
}

interface MSInspectorPopUpButtonAllocator<InitializedType = MSInspectorPopUpButton> extends NSPopUpButtonAllocator<MSInspectorPopUpButton> {}
interface MSInspectorPopUpButton extends NSPopUpButton {
}
declare const MSInspectorPopUpButton: {
  alloc(): MSInspectorPopUpButtonAllocator;
}

interface IMSInspectorSectionDelegate {
  sectionDidResize(section: NSViewController): void;
  documentForInspectorSection(section: NSViewController): MSDocument;
  isSectionCollapsed(section: NSViewController): boolean;
  setSection_collapsed(section: NSViewController, collapsed: boolean): void;
}

interface MSInspectorSectionHeaderLabelAllocator<InitializedType = MSInspectorSectionHeaderLabel> extends NSTextFieldAllocator<MSInspectorSectionHeaderLabel> {}
interface MSInspectorSectionHeaderLabel extends NSTextField {
}
declare const MSInspectorSectionHeaderLabel: {
  alloc(): MSInspectorSectionHeaderLabelAllocator;
}

interface MSInspectorSectionHeaderLabelCellAllocator<InitializedType = MSInspectorSectionHeaderLabelCell> extends NSTextFieldCellAllocator<MSInspectorSectionHeaderLabelCell> {}
interface MSInspectorSectionHeaderLabelCell extends NSTextFieldCell {
}
declare const MSInspectorSectionHeaderLabelCell: {
  alloc(): MSInspectorSectionHeaderLabelCellAllocator;
}

interface MSInspectorSegmentedCellAllocator<InitializedType = MSInspectorSegmentedCell> extends NSSegmentedCellAllocator<MSInspectorSegmentedCell> {}
interface MSInspectorSegmentedCell extends NSSegmentedCell {
  setAlternateImage_forSegment(image: NSImage, segment: NSUInteger): void;
}
declare const MSInspectorSegmentedCell: {
  alloc(): MSInspectorSegmentedCellAllocator;
}

interface MSInspectorSliderCellAllocator<InitializedType = MSInspectorSliderCell> extends NSSliderCellAllocator<MSInspectorSliderCell> {}
interface MSInspectorSliderCell extends NSSliderCell {
}
declare const MSInspectorSliderCell: {
  alloc(): MSInspectorSliderCellAllocator;
}

interface MSInspectorStackViewAllocator<InitializedType = MSInspectorStackView> extends NSViewAllocator<MSInspectorStackView> {}
interface MSInspectorStackView extends NSView {
  reloadWithViewControllers(controllers: NSArray<any> | any[]): void;
  reloadSubviews(): void;
  recalculateHeight(): void;
  stack(): void;
  subViewFrameDidChange(subview: NSView): void;

  sectionViewControllers(): NSArray<any>;
}
declare const MSInspectorStackView: {
  alloc(): MSInspectorStackViewAllocator;
}

interface MSInspectorTextfieldManagerAllocator<InitializedType = MSInspectorTextfieldManager> extends NSObjectAllocator<MSInspectorTextfieldManager> {}
interface MSInspectorTextfieldManager extends NSObject {
}
declare const MSInspectorTextfieldManager: {
  alloc(): MSInspectorTextfieldManagerAllocator;  managerWithItem_textField_adaptor_identifier_toolTip_touchBarItems(item: MSInspectorItem, textField: MSUpDownTextField, adaptor: MSMathInspectorValueAdaptor, identifier: NSUserInterfaceItemIdentifier, toolTip: NSString | string, touchBarItems: NSArray<any> | any[] | null): MSInspectorTextfieldManager;

}

interface MSInstanceOverridesHeaderItemAllocator<InitializedType = MSInstanceOverridesHeaderItem> extends MSInspectorItemAllocator<MSInstanceOverridesHeaderItem> {}
interface MSInstanceOverridesHeaderItem extends MSInspectorItem {
}
declare const MSInstanceOverridesHeaderItem: {
  alloc(): MSInstanceOverridesHeaderItemAllocator;
}

interface MSInstanceStylesHeaderItemAllocator<InitializedType = MSInstanceStylesHeaderItem> extends MSInspectorItemAllocator<MSInstanceStylesHeaderItem> {}
interface MSInstanceStylesHeaderItem extends MSInspectorItem {
}
declare const MSInstanceStylesHeaderItem: {
  alloc(): MSInstanceStylesHeaderItemAllocator;
}

interface MSIntegerSliderAllocator<InitializedType = MSIntegerSlider> extends NSSliderAllocator<MSIntegerSlider> {}
interface MSIntegerSlider extends NSSlider {
}
declare const MSIntegerSlider: {
  alloc(): MSIntegerSliderAllocator;
}

interface MSIntegratedStepperAllocator<InitializedType = MSIntegratedStepper> extends NSViewAllocator<MSIntegratedStepper> {}
interface MSIntegratedStepper extends NSView {

  target(): MSUpDownController;
  setTarget(target: MSUpDownController): void;
  highlightMode(): MSIntegratedStepperHighlight;
}
declare const MSIntegratedStepper: {
  alloc(): MSIntegratedStepperAllocator;
}

declare enum MSIntegratedStepperHighlight {
  MSIntegratedStepperHighlightNone,
  MSIntegratedStepperHighlightUp,
  MSIntegratedStepperHighlightDown,
}

interface MSInterceptingViewAllocator<InitializedType = MSInterceptingView> extends NSViewAllocator<MSInterceptingView> {}
interface MSInterceptingView extends NSView {
}
declare const MSInterceptingView: {
  alloc(): MSInterceptingViewAllocator;
}

interface MSJoinActionAllocator<InitializedType = MSJoinAction> extends MSDocumentActionAllocator<MSJoinAction> {}
interface MSJoinAction extends MSDocumentAction {
}
declare const MSJoinAction: {
  alloc(): MSJoinActionAllocator;
}

interface MSKeyBindingsAllocator<InitializedType = MSKeyBindings> extends BCSingletonAllocator<MSKeyBindings> {}
interface MSKeyBindings extends BCSingleton {

  shortcutMap(): NSDictionary<any, any>;
}
declare const MSKeyBindings: {
  alloc(): MSKeyBindingsAllocator;
}

interface MSLayerAdjustedPopupButtonCellAllocator<InitializedType = MSLayerAdjustedPopupButtonCell> extends NSPopUpButtonCellAllocator<MSLayerAdjustedPopupButtonCell> {}
interface MSLayerAdjustedPopupButtonCell extends NSPopUpButtonCell {
}
declare const MSLayerAdjustedPopupButtonCell: {
  alloc(): MSLayerAdjustedPopupButtonCellAllocator;
}

interface MSLayerFontManagerAllocator<InitializedType = MSLayerFontManager> extends NSObjectAllocator<MSLayerFontManager> {
  initWithCoder(aDecoder: NSCoder): InitializedType;
}
interface MSLayerFontManager extends NSObject, INSCoding {
  availableFonts(): NSArray<any>;
  currentFontVariations(): NSArray<any>;
  currentFont(): NSString;
  setCurrentFont(aValue: NSString | string): void;
  setLayer(aValue: any): void;
  currentFontFaceIndex(): number;
  setCurrentFontFaceIndex(aValue: number): void;
  bold(): boolean;
  setBold(aValue: boolean): void;
  italic(): boolean;
  setItalic(aValue: boolean): void;
  underline(): boolean;
  setUnderline(aValue: boolean): void;
  fontSize(): number;
  setFontSize(aValue: number): void;
  textColor(): NSColor;
  setTextColor(aValue: NSColor): void;
}
declare const MSLayerFontManager: {
  alloc(): MSLayerFontManagerAllocator;  loadFonts(): void;

}

interface MSLayerGroupItemAllocator<InitializedType = MSLayerGroupItem> extends MSInspectorItemAllocator<MSLayerGroupItem> {}
interface MSLayerGroupItem extends MSInspectorItem {
}
declare const MSLayerGroupItem: {
  alloc(): MSLayerGroupItemAllocator;
}

interface MSLayerInsertingAllocator<InitializedType = MSLayerInserting> extends NSObjectAllocator<MSLayerInserting> {}
interface MSLayerInserting extends NSObject {
}
declare const MSLayerInserting: {
  alloc(): MSLayerInsertingAllocator;  rectForCenteringLayerWithSize_inView_selection(layerSize: NSSize, contentDrawView: MSContentDrawView, layers: MSLayerArray): NSRect;

}

interface MSLayerMeasurementRendererAllocator<InitializedType = MSLayerMeasurementRenderer> extends MSOverlayRendererAllocator<MSLayerMeasurementRenderer> {}
interface MSLayerMeasurementRenderer extends MSOverlayRenderer {
  clear(): void;
  prepareForGeometryChange(): void;
  drawRect_context(dirtyRect: NSRect, context: MSRenderingContext): void;
  isMeasuringDistance(): boolean;

  selectedLayers(): MSLayerArray;
  setSelectedLayers(selectedLayers: MSLayerArray): void;
  measurementTarget(): MSLayerMeasurementTarget;
  setMeasurementTarget(measurementTarget: MSLayerMeasurementTarget): void;
  measurementOptions(): MSAlignmentRectOptions;
  setMeasurementOptions(measurementOptions: MSAlignmentRectOptions): void;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
}
declare const MSLayerMeasurementRenderer: {
  alloc(): MSLayerMeasurementRendererAllocator;
}

interface MSLayerMeasurementTargetAllocator<InitializedType = MSLayerMeasurementTarget> extends NSObjectAllocator<MSLayerMeasurementTarget> {
  initWithLayer_guides(targetLayer: MSLayer | null, targetGuides: NSArray<any> | any[] | null): InitializedType;
}
interface MSLayerMeasurementTarget extends NSObject {

  layer(): MSLayer;
  guideLines(): NSArray<any>;
}
declare const MSLayerMeasurementTarget: {
  alloc(): MSLayerMeasurementTargetAllocator;
}

interface MSLayerPickerMenuBuilderAllocator<InitializedType = MSLayerPickerMenuBuilder> extends MSMenuBuilderAllocator<MSLayerPickerMenuBuilder> {}
interface MSLayerPickerMenuBuilder extends MSMenuBuilder {
  updatePickerMenuItem_forPage_atPoint(item: NSMenuItem, page: MSPage, mouse: NSPoint): void;
}
declare const MSLayerPickerMenuBuilder: {
  alloc(): MSLayerPickerMenuBuilderAllocator;
}

interface MSLayerFocusActionsAllocator<InitializedType = MSLayerFocusActions> extends MSActionGroupAllocator<MSLayerFocusActions> {}
interface MSLayerFocusActions extends MSActionGroup {
}
declare const MSLayerFocusActions: {
  alloc(): MSLayerFocusActionsAllocator;
}

interface MSLayerXFocusActionAllocator<InitializedType = MSLayerXFocusAction> extends MSDocumentActionAllocator<MSLayerXFocusAction> {}
interface MSLayerXFocusAction extends MSDocumentAction {
}
declare const MSLayerXFocusAction: {
  alloc(): MSLayerXFocusActionAllocator;
}

interface MSLayerYFocusActionAllocator<InitializedType = MSLayerYFocusAction> extends MSDocumentActionAllocator<MSLayerYFocusAction> {}
interface MSLayerYFocusAction extends MSDocumentAction {
}
declare const MSLayerYFocusAction: {
  alloc(): MSLayerYFocusActionAllocator;
}

interface MSLayerWidthFocusActionAllocator<InitializedType = MSLayerWidthFocusAction> extends MSDocumentActionAllocator<MSLayerWidthFocusAction> {}
interface MSLayerWidthFocusAction extends MSDocumentAction {
}
declare const MSLayerWidthFocusAction: {
  alloc(): MSLayerWidthFocusActionAllocator;
}

interface MSLayerHeightFocusActionAllocator<InitializedType = MSLayerHeightFocusAction> extends MSDocumentActionAllocator<MSLayerHeightFocusAction> {}
interface MSLayerHeightFocusAction extends MSDocumentAction {
}
declare const MSLayerHeightFocusAction: {
  alloc(): MSLayerHeightFocusActionAllocator;
}

interface MSLayerSelectionDrawingAllocator<InitializedType = MSLayerSelectionDrawing> extends NSObjectAllocator<MSLayerSelectionDrawing> {}
interface MSLayerSelectionDrawing extends NSObject {
}
declare const MSLayerSelectionDrawing: {
  alloc(): MSLayerSelectionDrawingAllocator;  drawSelectionForLayer_zoomValue(aLayer: MSLayer, zoom: CGFloat): void;
  strokeWidthForZoomValue(zoom: CGFloat): CGFloat;

}

interface MSLayersPreferencePaneAllocator<InitializedType = MSLayersPreferencePane> extends MSPreferencePaneAllocator<MSLayersPreferencePane> {}
interface MSLayersPreferencePane extends MSPreferencePane {
}
declare const MSLayersPreferencePane: {
  alloc(): MSLayersPreferencePaneAllocator;
}

interface MSLayoutSettingsActionAllocator<InitializedType = MSLayoutSettingsAction> extends MSDocumentActionAllocator<MSLayoutSettingsAction> {}
interface MSLayoutSettingsAction extends MSDocumentAction {
  layoutSettings(sender: any): IBAction;
}
declare const MSLayoutSettingsAction: {
  alloc(): MSLayoutSettingsActionAllocator;
}

interface MSLayoutSheetAllocator<InitializedType = MSLayoutSheet> extends MSGridSheetBaseAllocator<MSLayoutSheet> {}
interface MSLayoutSheet extends MSGridSheetBase {
  setAsDefault(sender: any): IBAction;
  centerGrid(sender: any): IBAction;
  offsetChanged(sender: any): IBAction;

  centerGridButton(): NSButton;
  setCenterGridButton(centerGridButton: NSButton): void;
}
declare const MSLayoutSheet: {
  alloc(): MSLayoutSheetAllocator;
}

interface MSLicenseRegistrationWindowControllerAllocator<InitializedType = MSLicenseRegistrationWindowController> extends NSWindowControllerAllocator<MSLicenseRegistrationWindowController> {}
interface MSLicenseRegistrationWindowController extends NSWindowController, INSWindowDelegate {
}
declare const MSLicenseRegistrationWindowController: {
  alloc(): MSLicenseRegistrationWindowControllerAllocator;  showTrialExpiredModal(): void;
  showRegistrationWindow(): void;
  registerWithKey(key: NSString | string): void;

}

interface MSLicenseRenewalWindowControllerAllocator<InitializedType = MSLicenseRenewalWindowController> extends NSWindowControllerAllocator<MSLicenseRenewalWindowController> {}
interface MSLicenseRenewalWindowController extends NSWindowController, INSWindowDelegate {
}
declare const MSLicenseRenewalWindowController: {
  alloc(): MSLicenseRenewalWindowControllerAllocator;  showLicenseUpdateWindow(): void;

}

interface MSLineEndpointInspectorItemAllocator<InitializedType = MSLineEndpointInspectorItem> extends MSTwoTextFieldInspectorItemAllocator<MSLineEndpointInspectorItem> {}
interface MSLineEndpointInspectorItem extends MSTwoTextFieldInspectorItem {
}
declare const MSLineEndpointInspectorItem: {
  alloc(): MSLineEndpointInspectorItemAllocator;
}

interface MSLineEndpointInspectorItem1Allocator<InitializedType = MSLineEndpointInspectorItem1> extends MSLineEndpointInspectorItemAllocator<MSLineEndpointInspectorItem1> {}
interface MSLineEndpointInspectorItem1 extends MSLineEndpointInspectorItem {
}
declare const MSLineEndpointInspectorItem1: {
  alloc(): MSLineEndpointInspectorItem1Allocator;
}

interface MSLineEndpointInspectorItem2Allocator<InitializedType = MSLineEndpointInspectorItem2> extends MSLineEndpointInspectorItemAllocator<MSLineEndpointInspectorItem2> {}
interface MSLineEndpointInspectorItem2 extends MSLineEndpointInspectorItem {
}
declare const MSLineEndpointInspectorItem2: {
  alloc(): MSLineEndpointInspectorItem2Allocator;
}

interface MSLineTransformInspectorItemAllocator<InitializedType = MSLineTransformInspectorItem> extends MSInspectorItemAllocator<MSLineTransformInspectorItem> {}
interface MSLineTransformInspectorItem extends MSInspectorItem {
}
declare const MSLineTransformInspectorItem: {
  alloc(): MSLineTransformInspectorItemAllocator;
}

interface MSListTypeActionAllocator<InitializedType = MSListTypeAction> extends MSDocumentActionAllocator<MSListTypeAction> {}
interface MSListTypeAction extends MSDocumentAction {
}
declare const MSListTypeAction: {
  alloc(): MSListTypeActionAllocator;
}

interface MSListTypeActionNoneAllocator<InitializedType = MSListTypeActionNone> extends MSListTypeActionAllocator<MSListTypeActionNone> {}
interface MSListTypeActionNone extends MSListTypeAction {
  setListTypeNone(sender: any): IBAction;
}
declare const MSListTypeActionNone: {
  alloc(): MSListTypeActionNoneAllocator;
}

interface MSListTypeActionNumberedAllocator<InitializedType = MSListTypeActionNumbered> extends MSListTypeActionAllocator<MSListTypeActionNumbered> {}
interface MSListTypeActionNumbered extends MSListTypeAction {
  setListTypeNumbered(sender: any): IBAction;
}
declare const MSListTypeActionNumbered: {
  alloc(): MSListTypeActionNumberedAllocator;
}

interface MSListTypeActionBulletAllocator<InitializedType = MSListTypeActionBullet> extends MSListTypeActionAllocator<MSListTypeActionBullet> {}
interface MSListTypeActionBullet extends MSListTypeAction {
  setListTypeBullet(sender: any): IBAction;
}
declare const MSListTypeActionBullet: {
  alloc(): MSListTypeActionBulletAllocator;
}

interface MSLockLayerActionAllocator<InitializedType = MSLockLayerAction> extends MSDocumentActionAllocator<MSLockLayerAction> {}
interface MSLockLayerAction extends MSDocumentAction {
  lockLayer(sender: any): IBAction;
}
declare const MSLockLayerAction: {
  alloc(): MSLockLayerActionAllocator;
}

interface MSLogActionAllocator<InitializedType = MSLogAction> extends MSActionAllocator<MSLogAction> {}
interface MSLogAction extends MSAction, IMSPluginLogAction {
}
declare const MSLogAction: {
  alloc(): MSLogActionAllocator;
}

interface MSMagnifierActionAllocator<InitializedType = MSMagnifierAction> extends MSDocumentActionAllocator<MSMagnifierAction> {}
interface MSMagnifierAction extends MSDocumentAction {
}
declare const MSMagnifierAction: {
  alloc(): MSMagnifierActionAllocator;
}

interface MSMainSplitViewControllerAllocator<InitializedType = MSMainSplitViewController> extends NSObjectAllocator<MSMainSplitViewController> {}
interface MSMainSplitViewController extends NSObject, INSSplitViewDelegate {
  didEnterVersionBrowser(): void;
  didExitVersionBrowser(): void;

  splitView(): NSSplitView;
  setSplitView(splitView: NSSplitView): void;
  window(): NSWindow;
  setWindow(window: NSWindow): void;
}
declare const MSMainSplitViewController: {
  alloc(): MSMainSplitViewControllerAllocator;
}

interface MSMakeGridActionAllocator<InitializedType = MSMakeGridAction> extends MSDocumentActionAllocator<MSMakeGridAction> {}
interface MSMakeGridAction extends MSDocumentAction {
}
declare const MSMakeGridAction: {
  alloc(): MSMakeGridActionAllocator;
}

interface MSMakeGridSheetAllocator<InitializedType = MSMakeGridSheet> extends CHSheetControllerAllocator<MSMakeGridSheet> {}
interface MSMakeGridSheet extends CHSheetController {

  doc(): MSDocument;
  setDoc(doc: MSDocument): void;
  subtextField(): NSTextField;
  setSubtextField(subtextField: NSTextField): void;
}
declare const MSMakeGridSheet: {
  alloc(): MSMakeGridSheetAllocator;
}

interface MSTextTransformActionAllocator<InitializedType = MSTextTransformAction> extends MSDocumentActionAllocator<MSTextTransformAction> {}
interface MSTextTransformAction extends MSDocumentAction {
}
declare const MSTextTransformAction: {
  alloc(): MSTextTransformActionAllocator;
}

interface MSMakeUppercaseActionAllocator<InitializedType = MSMakeUppercaseAction> extends MSTextTransformActionAllocator<MSMakeUppercaseAction> {}
interface MSMakeUppercaseAction extends MSTextTransformAction {
}
declare const MSMakeUppercaseAction: {
  alloc(): MSMakeUppercaseActionAllocator;
}

interface MSMakeLowercaseActionAllocator<InitializedType = MSMakeLowercaseAction> extends MSTextTransformActionAllocator<MSMakeLowercaseAction> {}
interface MSMakeLowercaseAction extends MSTextTransformAction {
}
declare const MSMakeLowercaseAction: {
  alloc(): MSMakeLowercaseActionAllocator;
}

interface MSRemoveTextTransformActionAllocator<InitializedType = MSRemoveTextTransformAction> extends MSTextTransformActionAllocator<MSRemoveTextTransformAction> {}
interface MSRemoveTextTransformAction extends MSTextTransformAction {
}
declare const MSRemoveTextTransformAction: {
  alloc(): MSRemoveTextTransformActionAllocator;
}

interface MSManageForeignSymbolItemAllocator<InitializedType = MSManageForeignSymbolItem> extends NSObjectAllocator<MSManageForeignSymbolItem> {
  initWithForeignSymbol(foreignSymbol: MSForeignSymbol): InitializedType;
}
interface MSManageForeignSymbolItem extends NSObject {

  libraryName(): NSString;
  foreignSymbol(): MSForeignSymbol;
  library(): MSAssetLibrary;
  symbolName(): NSString;
}
declare const MSManageForeignSymbolItem: {
  alloc(): MSManageForeignSymbolItemAllocator;
}

interface MSManageForeignSymbolTableCellViewAllocator<InitializedType = MSManageForeignSymbolTableCellView> extends NSTableCellViewAllocator<MSManageForeignSymbolTableCellView> {}
interface MSManageForeignSymbolTableCellView extends NSTableCellView {
}
declare const MSManageForeignSymbolTableCellView: {
  alloc(): MSManageForeignSymbolTableCellViewAllocator;
}

interface MSManageForeignSymbolsViewAllocator<InitializedType = MSManageForeignSymbolsView> extends NSViewControllerAllocator<MSManageForeignSymbolsView> {}
interface MSManageForeignSymbolsView extends NSViewController {

  document(): MSDocument;
  setDocument(document: MSDocument): void;
}
declare const MSManageForeignSymbolsView: {
  alloc(): MSManageForeignSymbolsViewAllocator;
}

interface MSManageLayerStyleViewAllocator<InitializedType = MSManageLayerStyleView> extends MSManageSharedObjectBaseViewControllerAllocator<MSManageLayerStyleView> {}
interface MSManageLayerStyleView extends MSManageSharedObjectBaseViewController {
}
declare const MSManageLayerStyleView: {
  alloc(): MSManageLayerStyleViewAllocator;
}

interface MSManageShareableObjectsActionAllocator<InitializedType = MSManageShareableObjectsAction> extends MSBaseSharedObjectActionAllocator<MSManageShareableObjectsAction> {}
interface MSManageShareableObjectsAction extends MSBaseSharedObjectAction {
  showOrganiserSheet(sender: any): IBAction;
}
declare const MSManageShareableObjectsAction: {
  alloc(): MSManageShareableObjectsActionAllocator;
}

interface MSManageSharedObjectBaseViewControllerAllocator<InitializedType = MSManageSharedObjectBaseViewController> extends NSViewControllerAllocator<MSManageSharedObjectBaseViewController> {}
interface MSManageSharedObjectBaseViewController extends NSViewController, INSTableViewDataSource, INSTableViewDelegate {
  deleteSelectedObjects(sender: any): IBAction;

  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  sharedObjectsSortedByName(): NSArray<any>;
}
declare const MSManageSharedObjectBaseViewController: {
  alloc(): MSManageSharedObjectBaseViewControllerAllocator;
}

interface MSManageSharedObjectSheetAllocator<InitializedType = MSManageSharedObjectSheet> extends CHSheetControllerAllocator<MSManageSharedObjectSheet> {}
interface MSManageSharedObjectSheet extends CHSheetController {
}
declare const MSManageSharedObjectSheet: {
  alloc(): MSManageSharedObjectSheetAllocator;
  tabIndex(): MSManageSharedObjectSheetTabIndex;
  setTabIndex(tabIndex: MSManageSharedObjectSheetTabIndex): void;

}

declare enum MSManageSharedObjectSheetTabIndex {
  MSManageSharedObjectSheetTabIndexLayerStyles = 1,
  MSManageSharedObjectSheetTabIndexTextStyles = 2,
  MSManageSharedObjectSheetTabIndexImportedSymbols = 3,
}

interface MSManageTextStyleViewAllocator<InitializedType = MSManageTextStyleView> extends MSManageSharedObjectBaseViewControllerAllocator<MSManageTextStyleView> {}
interface MSManageTextStyleView extends MSManageSharedObjectBaseViewController {
}
declare const MSManageTextStyleView: {
  alloc(): MSManageTextStyleViewAllocator;
}

interface MSMaskWithShapeActionAllocator<InitializedType = MSMaskWithShapeAction> extends MSDocumentActionAllocator<MSMaskWithShapeAction> {}
interface MSMaskWithShapeAction extends MSDocumentAction {
  maskWithShape(sender: any): IBAction;
}
declare const MSMaskWithShapeAction: {
  alloc(): MSMaskWithShapeActionAllocator;
}

interface MSMeasurementDataAllocator<InitializedType = MSMeasurementData> extends NSObjectAllocator<MSMeasurementData> {}
interface MSMeasurementData extends NSObject {

  sourceRect(): NSRect;
  setSourceRect(sourceRect: NSRect): void;
  targetRect(): NSRect;
  setTargetRect(targetRect: NSRect): void;
  targetLines(): NSArray<any>;
  setTargetLines(targetLines: NSArray<any> | any[]): void;
}
declare const MSMeasurementData: {
  alloc(): MSMeasurementDataAllocator;
}

interface MSMenuBuilderAllocator<InitializedType = MSMenuBuilder> extends NSObjectAllocator<MSMenuBuilder> {}
interface MSMenuBuilder extends NSObject {

  target(): any;
  action(): string;
}
declare const MSMenuBuilder: {
  alloc(): MSMenuBuilderAllocator;  menuBuilderWithTarget(target: any): any;
  menuBuilderWithTarget_action(target: any, action: string): any;

}

interface MSMiniToolbarTextFieldCellAllocator<InitializedType = MSMiniToolbarTextFieldCell> extends NSTextFieldCellAllocator<MSMiniToolbarTextFieldCell> {}
interface MSMiniToolbarTextFieldCell extends NSTextFieldCell {
}
declare const MSMiniToolbarTextFieldCell: {
  alloc(): MSMiniToolbarTextFieldCellAllocator;
}

interface MSMirrorActionAllocator<InitializedType = MSMirrorAction> extends MSDocumentActionAllocator<MSMirrorAction> {}
interface MSMirrorAction extends MSDocumentAction, IMSWindowBadgeAction {
}
declare const MSMirrorAction: {
  alloc(): MSMirrorActionAllocator;
}

interface MSMirrorDataProviderAllocator<InitializedType = MSMirrorDataProvider> extends NSObjectAllocator<MSMirrorDataProvider> {}
interface MSMirrorDataProvider extends NSObject, ISMKMirrorDataSource {
  currentArtboardDidChange(): void;
  setNeedsUpdate(): void;
  setNeedsUpdateMetadata(): void;

  connectionController(): SMKMirrorController;
  setConnectionController(connectionController: SMKMirrorController): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  documentData(): MSImmutableDocumentData;
  requiresImmediateUpdate(): boolean;
  setRequiresImmediateUpdate(requiresImmediateUpdate: boolean): void;
}
declare const MSMirrorDataProvider: {
  alloc(): MSMirrorDataProviderAllocator;
}

interface MSMirrorPopUpButtonCellAllocator<InitializedType = MSMirrorPopUpButtonCell> extends NSPopUpButtonCellAllocator<MSMirrorPopUpButtonCell> {}
interface MSMirrorPopUpButtonCell extends NSPopUpButtonCell {
}
declare const MSMirrorPopUpButtonCell: {
  alloc(): MSMirrorPopUpButtonCellAllocator;
}

interface MSMirrorToolbarItemViewAllocator<InitializedType = MSMirrorToolbarItemView> extends NSViewAllocator<MSMirrorToolbarItemView> {}
interface MSMirrorToolbarItemView extends NSView {

  controls(): NSArray<any>;
}
declare const MSMirrorToolbarItemView: {
  alloc(): MSMirrorToolbarItemViewAllocator;
}

interface MSMirrorWebViewAllocator<InitializedType = MSMirrorWebView> extends WKWebViewAllocator<MSMirrorWebView> {}
interface MSMirrorWebView extends WKWebView {
}
declare const MSMirrorWebView: {
  alloc(): MSMirrorWebViewAllocator;  developerToolsEnabled(): boolean;

}

interface MSMirrorWindowControllerAllocator<InitializedType = MSMirrorWindowController> extends NSWindowControllerAllocator<MSMirrorWindowController> {}
interface MSMirrorWindowController extends NSWindowController {
  sortedArtboards(artboards: NSArray<any> | any[] | null): NSArray<any>;
  changeVisibleArtboardID(artboardID: NSString | string | null): void;
  transitionToArtboardID_animatedBy(artboardID: NSString | string, animationType: MSFlowAnimationType): void;

  viewPort(): NSRect;
  dataProvider(): MSMirrorDataProvider;
  currentDocument(): MSImmutableDocumentData;
  currentMutableDocument(): MSDocumentData;
  currentArtboardID(): NSString;
  firstArtboardID(): NSString;
  visibleArtboardID(): NSString;
  defaultArtboardID(): NSString;
  currentStartpoint(): MSImmutableArtboardGroup;
  startpoints(): NSArray<any>;
}
declare const MSMirrorWindowController: {
  alloc(): MSMirrorWindowControllerAllocator;  sharedController(): MSMirrorWindowController;
  show(): void;
  close(): void;

}

interface IMSMirrorWindowControllerContent {

  webView(): WKWebView;
  setWebView(webView: WKWebView): void;
}

interface MSShowColorsActionAllocator<InitializedType = MSShowColorsAction> extends MSDocumentActionAllocator<MSShowColorsAction> {}
interface MSShowColorsAction extends MSDocumentAction {
  showColorsAction(sender: any): IBAction;
}
declare const MSShowColorsAction: {
  alloc(): MSShowColorsActionAllocator;
}

interface MSShowFontsActionAllocator<InitializedType = MSShowFontsAction> extends MSDocumentActionAllocator<MSShowFontsAction> {}
interface MSShowFontsAction extends MSDocumentAction {
}
declare const MSShowFontsAction: {
  alloc(): MSShowFontsActionAllocator;
}

interface MSMissingFontsDialogAllocator<InitializedType = MSMissingFontsDialog> extends NSWindowControllerAllocator<MSMissingFontsDialog> {}
interface MSMissingFontsDialog extends NSWindowController, INSTableViewDataSource {
  runPanelWithMissingFonts_savingWillChangeFonts(missingFonts: NSArray<any> | any[], savingWillChangeFonts: boolean): boolean;
  //   close(sender: any): IBAction;
  openAnyway(sender: any): IBAction;
}
declare const MSMissingFontsDialog: {
  alloc(): MSMissingFontsDialogAllocator;
}

interface MSModalInputSheetAllocator<InitializedType = MSModalInputSheet> extends NSObjectAllocator<MSModalInputSheet> {}
interface MSModalInputSheet extends NSObject, INSWindowDelegate {
  runPanelWithNibName_ofType_initialString_label(nibName: NSString | string, inputType: MSModalInputTypes, initialString: NSString | string, label: NSString | string): NSString;
  ok(sender: any): IBAction;
  cancel(sender: any): IBAction;

  type(): MSModalInputTypes;
  setType(type: MSModalInputTypes): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  numberFieldBinding(): CGFloat;
  setNumberFieldBinding(numberFieldBinding: CGFloat): void;
}
declare const MSModalInputSheet: {
  alloc(): MSModalInputSheetAllocator;
}

declare enum MSModalInputTypes {
  MSModalInputTypeString,
  MSModalInputTypeNumber,
  MSModalInputTypePath,
}

interface MSModePickerViewAllocator<InitializedType = MSModePickerView> extends NSViewAllocator<MSModePickerView> {}
interface MSModePickerView extends NSView {

  pickerMode(): NSInteger;
  setPickerMode(pickerMode: NSInteger): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  labelField(): NSTextField;
  setLabelField(labelField: NSTextField): void;
}
declare const MSModePickerView: {
  alloc(): MSModePickerViewAllocator;
}

interface MSColorModePickerCellAllocator<InitializedType = MSColorModePickerCell> extends NSButtonCellAllocator<MSColorModePickerCell> {}
interface MSColorModePickerCell extends NSButtonCell {
}
declare const MSColorModePickerCell: {
  alloc(): MSColorModePickerCellAllocator;
}

interface IMSModeModePickerDelegate {
  pickerViewWillChange(picker: MSModePickerView): void;
  pickerViewChanged(picker: MSModePickerView): void;
  pickerView_labelForMode(view: MSModePickerView, mode: NSInteger): NSString;
}

interface MSMouseTrackerAllocator<InitializedType = MSMouseTracker> extends NSObjectAllocator<MSMouseTracker> {
  initWithTarget_action(target: any | null, action: string | null): InitializedType;
}
interface MSMouseTracker extends NSObject {
  sendAction(): void;
  locationInView(view: NSView | null): NSPoint;
  mouseEntered(event: NSEvent): void;
  mouseMoved(event: NSEvent): void;
  mouseExited(event: NSEvent | null): void;
  flagsChanged(event: NSEvent): void;
  mouseDown(event: NSEvent): void;
  mouseDragged(event: NSEvent): void;
  mouseUp(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  trackingState(): MSMouseTrackingState;
  view(): NSView;
  setView(view: NSView): void;
  modifierFlags(): NSEventModifierFlags;
  canUpdateCursor(): boolean;
}
declare const MSMouseTracker: {
  alloc(): MSMouseTrackerAllocator;
}

declare enum MSMouseTrackingState {
  MSMouseTrackingStateNone,
  MSMouseTrackingStateInside = 1 << 0,
  MSMouseTrackingStateMouseDown = 1 << 1,
}

interface MSMoveToTopActionAllocator<InitializedType = MSMoveToTopAction> extends MSDocumentActionAllocator<MSMoveToTopAction> {}
interface MSMoveToTopAction extends MSDocumentAction {
  moveToTop(sender: any): IBAction;
}
declare const MSMoveToTopAction: {
  alloc(): MSMoveToTopActionAllocator;
}

interface MSMoveUpHierarchyActionAllocator<InitializedType = MSMoveUpHierarchyAction> extends MSDocumentActionAllocator<MSMoveUpHierarchyAction> {}
interface MSMoveUpHierarchyAction extends MSDocumentAction {
  moveUpHierarchy(sender: any): IBAction;
}
declare const MSMoveUpHierarchyAction: {
  alloc(): MSMoveUpHierarchyActionAllocator;
}

interface MSMultipleBorderInspectorViewControllerAllocator<InitializedType = MSMultipleBorderInspectorViewController> extends MSMultipleColorStylePartInspectorViewControllerAllocator<MSMultipleBorderInspectorViewController> {}
interface MSMultipleBorderInspectorViewController extends MSMultipleColorStylePartInspectorViewController, IBCPopoverDelegate {
  showAdvancedOptionsAction(sender: any): IBAction;
  styleDidEnableOrDisable(): void;

  borderOptionsController(): MSBorderOptionsInspectorViewController;
  thicknessLabel(): MSTextLabelForUpDownField;
  setThicknessLabel(thicknessLabel: MSTextLabelForUpDownField): void;
}
declare const MSMultipleBorderInspectorViewController: {
  alloc(): MSMultipleBorderInspectorViewControllerAllocator;
}

interface MSMultipleColorStylePartInspectorViewControllerAllocator<InitializedType = MSMultipleColorStylePartInspectorViewController> extends MSMultipleStylePartInspectorViewControllerAllocator<MSMultipleColorStylePartInspectorViewController> {}
interface MSMultipleColorStylePartInspectorViewController extends MSMultipleStylePartInspectorViewController {
  openPopoverAtIndex(index: NSUInteger): void;
  closeAnyColorPopover(): void;
}
declare const MSMultipleColorStylePartInspectorViewController: {
  alloc(): MSMultipleColorStylePartInspectorViewControllerAllocator;
}

interface MSMultipleFillInspectorViewControllerAllocator<InitializedType = MSMultipleFillInspectorViewController> extends MSMultipleColorStylePartInspectorViewControllerAllocator<MSMultipleFillInspectorViewController> {}
interface MSMultipleFillInspectorViewController extends MSMultipleColorStylePartInspectorViewController, IBCPopoverDelegate {
  showAdvancedOptionsAction(sender: any): IBAction;

  opacityLabel(): MSTextLabelForUpDownField;
  setOpacityLabel(opacityLabel: MSTextLabelForUpDownField): void;
}
declare const MSMultipleFillInspectorViewController: {
  alloc(): MSMultipleFillInspectorViewControllerAllocator;
}

interface MSMultipleInnerShadowInspectorViewControllerAllocator<InitializedType = MSMultipleInnerShadowInspectorViewController> extends MSMultipleShadowInspectorViewControllerAllocator<MSMultipleInnerShadowInspectorViewController> {}
interface MSMultipleInnerShadowInspectorViewController extends MSMultipleShadowInspectorViewController {
}
declare const MSMultipleInnerShadowInspectorViewController: {
  alloc(): MSMultipleInnerShadowInspectorViewControllerAllocator;
}

interface MSMultipleShadowInspectorViewControllerAllocator<InitializedType = MSMultipleShadowInspectorViewController> extends MSMultipleColorStylePartInspectorViewControllerAllocator<MSMultipleShadowInspectorViewController> {}
interface MSMultipleShadowInspectorViewController extends MSMultipleColorStylePartInspectorViewController {
  shouldHideAddStylePartButton(): boolean;

  addStylePartButton(): NSButton;
  setAddStylePartButton(addStylePartButton: NSButton): void;
}
declare const MSMultipleShadowInspectorViewController: {
  alloc(): MSMultipleShadowInspectorViewControllerAllocator;
}

interface MSMultipleStylePartInspectorViewControllerAllocator<InitializedType = MSMultipleStylePartInspectorViewController> extends NSViewControllerAllocator<MSMultipleStylePartInspectorViewController> {}
interface MSMultipleStylePartInspectorViewController extends NSViewController, IMSReorderingContainerDelegate {
  prepare(): void;
  stylePartType(): MSStylePartType;
  rotatedStyleParts(): NSArray<any>;
  addStylePartAction(sender: any): IBAction;
  deleteStylePartAction(sender: any): IBAction;
  deleteUnusedStylePartsAction(sender: any): IBAction;
  addStylePartsForSelection(): NSArray<any>;
  hasEnabledStyle(): boolean;
  prepareInspector_parts_index(inspector: MSStylePartInspectorViewController, styleParts: NSArray<any> | any[], index: NSUInteger): void;
  loadViewControllers(): void;
  validateSpecialButtons(): void;
  validateRemoveDisabledStylesButton(): void;
  resizeViewToFit(): void;
  styleDidEnableOrDisable(): void;
  inspectorForStyleParts_atIndex(styleParts: NSArray<any> | any[], index: NSUInteger): any;
  shouldShowAdvancedOptionsButton(): boolean;
  lastEnabledStylePartController(): MSStylePartInspectorViewController;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  stylePartViewControllers(): NSArray<any>;
  setStylePartViewControllers(stylePartViewControllers: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  reorderingContainer(): MSReorderingContainerView;
  setReorderingContainer(reorderingContainer: MSReorderingContainerView): void;
  nameView(): NSView;
  setNameView(nameView: NSView): void;
  removeDisabledStylesButton(): NSButton;
  setRemoveDisabledStylesButton(removeDisabledStylesButton: NSButton): void;
  showAdvancedOptionsButton(): NSButton;
  setShowAdvancedOptionsButton(showAdvancedOptionsButton: NSButton): void;
}
declare const MSMultipleStylePartInspectorViewController: {
  alloc(): MSMultipleStylePartInspectorViewControllerAllocator;
}

interface MSNewsTriggerAllocator<InitializedType = MSNewsTrigger> extends BCSingletonAllocator<MSNewsTrigger> {}
interface MSNewsTrigger extends BCSingleton {
}
declare const MSNewsTrigger: {
  alloc(): MSNewsTriggerAllocator;
}

interface MSNewsTriggerWindowControllerAllocator<InitializedType = MSNewsTriggerWindowController> extends CHWindowControllerAllocator<MSNewsTriggerWindowController> {}
interface MSNewsTriggerWindowController extends CHWindowController {
}
declare const MSNewsTriggerWindowController: {
  alloc(): MSNewsTriggerWindowControllerAllocator;
}

interface MSNewsletterSignupAllocator<InitializedType = MSNewsletterSignup> extends NSObjectAllocator<MSNewsletterSignup> {}
interface MSNewsletterSignup extends NSObject {
}
declare const MSNewsletterSignup: {
  alloc(): MSNewsletterSignupAllocator;
}

interface MSNiceSliceActionAllocator<InitializedType = MSNiceSliceAction> extends MSEventHandlerActionAllocator<MSNiceSliceAction> {}
interface MSNiceSliceAction extends MSEventHandlerAction {
}
declare const MSNiceSliceAction: {
  alloc(): MSNiceSliceActionAllocator;
}

interface MSNonAutosavingDocumentAllocator<InitializedType = MSNonAutosavingDocument> extends MSDocumentAllocator<MSNonAutosavingDocument> {}
interface MSNonAutosavingDocument extends MSDocument {
}
declare const MSNonAutosavingDocument: {
  alloc(): MSNonAutosavingDocumentAllocator;
}

interface MSNormalBaseEventHandlerAllocator<InitializedType = MSNormalBaseEventHandler> extends MSEventHandlerAllocator<MSNormalBaseEventHandler> {}
interface MSNormalBaseEventHandler extends MSEventHandler {
  cursorForCorner_ofLayer(corner: BCCorner, layer: MSLayer | null): NSCursor;
  resizeParentsOfSelectedLayersToFit(): void;
  configureInspector(inspector: MSInspectorController): void;
}
declare const MSNormalBaseEventHandler: {
  alloc(): MSNormalBaseEventHandlerAllocator;
}

interface MSNormalEventContextualMenuBuilderAllocator<InitializedType = MSNormalEventContextualMenuBuilder> extends NSObjectAllocator<MSNormalEventContextualMenuBuilder> {}
interface MSNormalEventContextualMenuBuilder extends NSObject {
  constructMenus(): void;
  menuForLayers(layers: NSArray<any> | any[]): NSMenu;
}
declare const MSNormalEventContextualMenuBuilder: {
  alloc(): MSNormalEventContextualMenuBuilderAllocator;
}

interface MSNormalEventDataAllocator<InitializedType = MSNormalEventData> extends NSObjectAllocator<MSNormalEventData> {}
interface MSNormalEventData extends NSObject {

  hasMultipleTouches(): boolean;
  setHasMultipleTouches(hasMultipleTouches: boolean): void;
  didMouseDown(): boolean;
  setDidMouseDown(didMouseDown: boolean): void;
  mouseDown(): NSPoint;
  setMouseDown(mouseDown: NSPoint): void;
  midPoint(): NSPoint;
  setMidPoint(midPoint: NSPoint): void;
  originalScrollOrigin(): NSPoint;
  setOriginalScrollOrigin(originalScrollOrigin: NSPoint): void;
  resizingLayer(): MSLayer;
  setResizingLayer(resizingLayer: MSLayer): void;
  resizingHandle(): BCCorner;
  setResizingHandle(resizingHandle: BCCorner): void;
  dragMode(): MSEventHandlerDragMode;
  setDragMode(dragMode: MSEventHandlerDragMode): void;
  snapperData(): MSSnapperData;
  setSnapperData(snapperData: MSSnapperData): void;
}
declare const MSNormalEventData: {
  alloc(): MSNormalEventDataAllocator;
}

declare enum MSEventHandlerDragMode {
  MSEventHandlerDragNone = -1,
  MSEventHandlerDragMove = 0,
  MSEventHandlerDragSelect = 2,
}

interface MSNormalEventHandlerAllocator<InitializedType = MSNormalEventHandler> extends MSNormalBaseEventHandlerAllocator<MSNormalEventHandler> {}
interface MSNormalEventHandler extends MSNormalBaseEventHandler {
  selectLayer(sender: any): IBAction;
  ignoreNextKeyDownEventUntilModifiersChange(): void;
  cancelOperation(sender: any): void;
  drawSelectedShapePathLayers(): void;

  measurementRenderer(): MSLayerMeasurementRenderer;
  highlightedItem(): NSObject;
  setHighlightedItem(highlightedItem: NSObject): void;
}
declare const MSNormalEventHandler: {
  alloc(): MSNormalEventHandlerAllocator;
}

interface MSNormalInspectorAllocator<InitializedType = MSNormalInspector> extends NSViewControllerAllocator<MSNormalInspector> {}
interface MSNormalInspector extends NSViewController, IMSStylePartInspectorDelegate, IMSInspectorChildController {
  selectionDidChangeTo(newLayers: NSArray<any> | any[]): void;
  adjustInspectorToColorPopover_sender(popover: BCPopover, sender: any): void;
  closeAnyColorPopover(): void;
  colorMagnifierAction(sender: any): IBAction;
  changeTextLayerFont(sender: any): IBAction;
  layerPositionPossiblyChanged(): void;
  showFillOptionsAction(sender: any): IBAction;
  showBorderOptionsAction(sender: any): IBAction;
  openPopoverForStylePart_atIndex(stylePart: MSStylePartType, index: NSUInteger): void;
  reloadSharedObjectsSection(): void;
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;

  stackView(): MSInspectorStackView;
  setStackView(stackView: MSInspectorStackView): void;
  //   layers(): MSLayerArray;
  //   setLayers(layers: MSLayerArray): void;
  eventHandler(): MSEventHandler;
  setEventHandler(eventHandler: MSEventHandler): void;
  sharedStyleInspectorVisible(): boolean;
}
declare const MSNormalInspector: {
  alloc(): MSNormalInspectorAllocator;
}

interface MSNormalMultipleResizeEventHandlerAllocator<InitializedType = MSNormalMultipleResizeEventHandler> extends MSNormalBaseEventHandlerAllocator<MSNormalMultipleResizeEventHandler> {}
interface MSNormalMultipleResizeEventHandler extends MSNormalBaseEventHandler {
  calculateOppositePoint(): void;
  calculateMidPoint(): void;
  displayResizeCursor(): void;
  storeCurrentLayerFrame(): void;
  makeRectConform_toProportions(newFrame: NSRect, constrainProportions: boolean): NSRect;
  placeRectInOppositeCorner(newFrame: NSRect): NSRect;
  oppositeCorner(): BCCorner;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  resizingCorner(): BCCorner;
  setResizingCorner(resizingCorner: BCCorner): void;
  layerSnapper(): MSSnapper;
  setLayerSnapper(layerSnapper: MSSnapper): void;
  eventData(): MSNormalEventData;
  setEventData(eventData: MSNormalEventData): void;
}
declare const MSNormalMultipleResizeEventHandler: {
  alloc(): MSNormalMultipleResizeEventHandlerAllocator;
}

interface MSNormalResizeEventHandlerAllocator<InitializedType = MSNormalResizeEventHandler> extends MSNormalBaseEventHandlerAllocator<MSNormalResizeEventHandler> {}
interface MSNormalResizeEventHandler extends MSNormalBaseEventHandler {

  snappingSession(): MSSnappingSession;
  setSnappingSession(snappingSession: MSSnappingSession): void;
  eventData(): MSNormalEventData;
  setEventData(eventData: MSNormalEventData): void;
}
declare const MSNormalResizeEventHandler: {
  alloc(): MSNormalResizeEventHandlerAllocator;
}

interface MSNormalResizeLineEventHandlerAllocator<InitializedType = MSNormalResizeLineEventHandler> extends MSNormalBaseEventHandlerAllocator<MSNormalResizeLineEventHandler> {}
interface MSNormalResizeLineEventHandler extends MSNormalBaseEventHandler {

  layer(): MSShapePathLayer;
  setLayer(layer: MSShapePathLayer): void;
  pointIndex(): NSInteger;
  setPointIndex(pointIndex: NSInteger): void;
  layerSnapper(): MSSnapper;
  setLayerSnapper(layerSnapper: MSSnapper): void;
  eventData(): MSNormalEventData;
  setEventData(eventData: MSNormalEventData): void;
}
declare const MSNormalResizeLineEventHandler: {
  alloc(): MSNormalResizeLineEventHandlerAllocator;
}

interface MSOffsetPathActionAllocator<InitializedType = MSOffsetPathAction> extends MSDocumentActionAllocator<MSOffsetPathAction> {}
interface MSOffsetPathAction extends MSDocumentAction {
  offsetPath(sender: any): IBAction;
}
declare const MSOffsetPathAction: {
  alloc(): MSOffsetPathActionAllocator;
}

interface MSOffsetPathSheetAllocator<InitializedType = MSOffsetPathSheet> extends MSCanvasUpdatingSheetAllocator<MSOffsetPathSheet> {}
interface MSOffsetPathSheet extends MSCanvasUpdatingSheet {

  offset(): CGFloat;
  setOffset(offset: CGFloat): void;
  duplicateLayers(): boolean;
  setDuplicateLayers(duplicateLayers: boolean): void;
}
declare const MSOffsetPathSheet: {
  alloc(): MSOffsetPathSheetAllocator;
}

interface MSOpacityBlendingInspectorItemAllocator<InitializedType = MSOpacityBlendingInspectorItem> extends MSInspectorItemAllocator<MSOpacityBlendingInspectorItem> {}
interface MSOpacityBlendingInspectorItem extends MSInspectorItem, INSMenuDelegate {
}
declare const MSOpacityBlendingInspectorItem: {
  alloc(): MSOpacityBlendingInspectorItemAllocator;
}

interface MSOpenCloudPreferencesActionAllocator<InitializedType = MSOpenCloudPreferencesAction> extends MSActionAllocator<MSOpenCloudPreferencesAction> {}
interface MSOpenCloudPreferencesAction extends MSAction {
  openCloudPreferences(sender: any): IBAction;
}
declare const MSOpenCloudPreferencesAction: {
  alloc(): MSOpenCloudPreferencesActionAllocator;
}

interface MSOpenInLibraryActionAllocator<InitializedType = MSOpenInLibraryAction> extends MSDocumentActionAllocator<MSOpenInLibraryAction> {}
interface MSOpenInLibraryAction extends MSDocumentAction {
}
declare const MSOpenInLibraryAction: {
  alloc(): MSOpenInLibraryActionAllocator;
}

interface MSOpenSymbolInLibraryActionAllocator<InitializedType = MSOpenSymbolInLibraryAction> extends MSOpenInLibraryActionAllocator<MSOpenSymbolInLibraryAction> {}
interface MSOpenSymbolInLibraryAction extends MSOpenInLibraryAction {
  openLibraryForForeignSymbols(sender: any): void;
}
declare const MSOpenSymbolInLibraryAction: {
  alloc(): MSOpenSymbolInLibraryActionAllocator;
}

interface MSOpenStyleInLibraryActionAllocator<InitializedType = MSOpenStyleInLibraryAction> extends MSOpenInLibraryActionAllocator<MSOpenStyleInLibraryAction> {}
interface MSOpenStyleInLibraryAction extends MSOpenInLibraryAction {
  openLibraryForStyles(sender: any): void;
}
declare const MSOpenStyleInLibraryAction: {
  alloc(): MSOpenStyleInLibraryActionAllocator;
}

interface MSOpenPluginPreferencesActionAllocator<InitializedType = MSOpenPluginPreferencesAction> extends MSActionAllocator<MSOpenPluginPreferencesAction> {}
interface MSOpenPluginPreferencesAction extends MSAction {
  openPluginPreferences(sender: any): IBAction;
}
declare const MSOpenPluginPreferencesAction: {
  alloc(): MSOpenPluginPreferencesActionAllocator;
}

interface MSOpenPreferencesActionAllocator<InitializedType = MSOpenPreferencesAction> extends MSActionAllocator<MSOpenPreferencesAction> {}
interface MSOpenPreferencesAction extends MSAction {
  openPreferences(sender: any): IBAction;
  openPreferencesWindowWithPreferencePaneIdentifier(identifier: NSString | string): void;
}
declare const MSOpenPreferencesAction: {
  alloc(): MSOpenPreferencesActionAllocator;
}

interface MSOpenPreviewActionAllocator<InitializedType = MSOpenPreviewAction> extends MSDocumentActionAllocator<MSOpenPreviewAction> {}
interface MSOpenPreviewAction extends MSDocumentAction {
  openMirrorPreview(sender: any): IBAction;
}
declare const MSOpenPreviewAction: {
  alloc(): MSOpenPreviewActionAllocator;
}

interface MSOperatingSystemAllocator<InitializedType = MSOperatingSystem> extends NSObjectAllocator<MSOperatingSystem> {}
interface MSOperatingSystem extends NSObject {
}
declare const MSOperatingSystem: {
  alloc(): MSOperatingSystemAllocator;  operatingSystemVersion(): NSOperatingSystemVersion;
  isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
  systemVersionString(): NSString;

}

interface MSOverrideInspectorItemAllocator<InitializedType = MSOverrideInspectorItem> extends MSInspectorItemAllocator<MSOverrideInspectorItem> {
  initWithPrimaryOverrideRepresentation(overrideRepresentation: MSOverrideRepresentation): InitializedType;
}
interface MSOverrideInspectorItem extends MSInspectorItem, IMSDataMenuProviderDelegate {
  labelView(): NSTextField;
  build(): void;
  supportedDataProviders(): MSDataType;
  controlViewForEditingOverride(): NSControl;
  valueFromControlView(controlView: any): any;
  overrideValueAction(sender: any): IBAction;
  applyOverrideToSelectedLayers(value: any): void;
  setIndentationLevel(level: NSUInteger): void;

  primaryOverride(): MSAvailableOverride;
  overrideRepresentation(): MSOverrideRepresentation;
  hasSingleOverride(): boolean;
  contentView(): NSView;
  documentData(): MSDocumentData;
  document(): MSDocument;
  displaysLabel(): boolean;
  setDisplaysLabel(displaysLabel: boolean): void;
}
declare const MSOverrideInspectorItem: {
  alloc(): MSOverrideInspectorItemAllocator;
}

interface MSOverrideTextFieldAllocator<InitializedType = MSOverrideTextField> extends NSTextFieldAllocator<MSOverrideTextField> {}
interface MSOverrideTextField extends NSTextField {
}
declare const MSOverrideTextField: {
  alloc(): MSOverrideTextFieldAllocator;
}

interface MSPDFBookExporterAllocator<InitializedType = MSPDFBookExporter> extends NSObjectAllocator<MSPDFBookExporter> {}
interface MSPDFBookExporter extends NSObject {
}
declare const MSPDFBookExporter: {
  alloc(): MSPDFBookExporterAllocator;  exportPages_defaultFilename(pages: NSArray<any> | any[], defaultFilename: NSString | string): void;

}

interface MSPaddingInspectorItemAllocator<InitializedType = MSPaddingInspectorItem> extends MSInspectorItemAllocator<MSPaddingInspectorItem> {}
interface MSPaddingInspectorItem extends MSInspectorItem {

  wantsSeparator(): boolean;
  setWantsSeparator(wantsSeparator: boolean): void;
}
declare const MSPaddingInspectorItem: {
  alloc(): MSPaddingInspectorItemAllocator;  paddingWithHeight(height: CGFloat): MSPaddingInspectorItem;

}

interface MSPaddingInspectorItemViewAllocator<InitializedType = MSPaddingInspectorItemView> extends NSViewAllocator<MSPaddingInspectorItemView> {}
interface MSPaddingInspectorItemView extends NSView {

  wantsSeparator(): boolean;
  setWantsSeparator(wantsSeparator: boolean): void;
}
declare const MSPaddingInspectorItemView: {
  alloc(): MSPaddingInspectorItemViewAllocator;
}

interface MSNewPageActionAllocator<InitializedType = MSNewPageAction> extends MSDocumentActionAllocator<MSNewPageAction> {}
interface MSNewPageAction extends MSDocumentAction {
  addNewPage(sender: any): IBAction;
}
declare const MSNewPageAction: {
  alloc(): MSNewPageActionAllocator;
}

interface MSChangePageActionAllocator<InitializedType = MSChangePageAction> extends MSDocumentActionAllocator<MSChangePageAction> {}
interface MSChangePageAction extends MSDocumentAction {
}
declare const MSChangePageAction: {
  alloc(): MSChangePageActionAllocator;
}

interface MSPreviousPageActionAllocator<InitializedType = MSPreviousPageAction> extends MSChangePageActionAllocator<MSPreviousPageAction> {}
interface MSPreviousPageAction extends MSChangePageAction {
  previousPage(sender: any): IBAction;
}
declare const MSPreviousPageAction: {
  alloc(): MSPreviousPageActionAllocator;
}

interface MSNextPageActionAllocator<InitializedType = MSNextPageAction> extends MSChangePageActionAllocator<MSNextPageAction> {}
interface MSNextPageAction extends MSChangePageAction {
  nextPage(sender: any): IBAction;
}
declare const MSNextPageAction: {
  alloc(): MSNextPageActionAllocator;
}

interface MSPagesTableViewAllocator<InitializedType = MSPagesTableView> extends NSTableViewAllocator<MSPagesTableView> {}
interface MSPagesTableView extends NSTableView {
}
declare const MSPagesTableView: {
  alloc(): MSPagesTableViewAllocator;
}

interface MSParagraphStyleViewControllerAllocator<InitializedType = MSParagraphStyleViewController> extends NSViewControllerAllocator<MSParagraphStyleViewController> {}
interface MSParagraphStyleViewController extends NSViewController {
  decorationButtonAction(sender: any): IBAction;
  listPopUpAction(sender: any): IBAction;
  transformPopUpAction(sender: any): IBAction;

  textSection(): MSTextLayerItem;
  setTextSection(textSection: MSTextLayerItem): void;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  decorationButton(): NSSegmentedControl;
  setDecorationButton(decorationButton: NSSegmentedControl): void;
  listPopUpButton(): NSPopUpButton;
  setListPopUpButton(listPopUpButton: NSPopUpButton): void;
  transformPopUpButton(): NSPopUpButton;
  setTransformPopUpButton(transformPopUpButton: NSPopUpButton): void;
}
declare const MSParagraphStyleViewController: {
  alloc(): MSParagraphStyleViewControllerAllocator;
}

interface MSPathControllerAllocator<InitializedType = MSPathController> extends NSObjectAllocator<MSPathController> {}
interface MSPathController extends NSObject {
  setSelectionIndexPath(indexPath: NSIndexPath | null): void;
  runChange(change: MSShapeChange): void;
  runChange_context(change: MSShapeChange, context: MSShapeChangeContext): void;
  selectNext(sender: any): void;
  selectPrevious(sender: any): void;
  currentCurveMode(): NSNumber;
  changeCurveMode(mode: MSCurveMode): void;
  remove(sender: any): IBAction;

  content(): NSArray<any>;
  setContent(content: NSArray<any> | any[]): void;
  selectionIndexPaths(): NSArray<any>;
  setSelectionIndexPaths(selectionIndexPaths: NSArray<any> | any[]): void;
  selectedObjects(): NSArray<any>;
  changeContext(): MSShapeChangeContext;
}
declare const MSPathController: {
  alloc(): MSPathControllerAllocator;
}

interface MSPencilEventHandlerAllocator<InitializedType = MSPencilEventHandler> extends MSEventHandlerAllocator<MSPencilEventHandler> {}
interface MSPencilEventHandler extends MSEventHandler {
}
declare const MSPencilEventHandler: {
  alloc(): MSPencilEventHandlerAllocator;
}

interface MSPluginManagerWithActionsAllocator<InitializedType = MSPluginManagerWithActions> extends MSPluginManagerAllocator<MSPluginManagerWithActions> {}
interface MSPluginManagerWithActions extends MSPluginManager, IMSActionObserver {

  dataManager(): MSDataSupplierManager;
  setDataManager(dataManager: MSDataSupplierManager): void;
}
declare const MSPluginManagerWithActions: {
  alloc(): MSPluginManagerWithActionsAllocator;
}

interface MSPluginStandaloneScriptAllocator<InitializedType = MSPluginStandaloneScript> extends MSPluginScriptAllocator<MSPluginStandaloneScript> {}
interface MSPluginStandaloneScript extends MSPluginScript {

  rawScript(): NSString;
  handler(): NSString;
}
declare const MSPluginStandaloneScript: {
  alloc(): MSPluginStandaloneScriptAllocator;  wrappedScript_handler(script: NSString | string, handler: NSString | string): NSString;

}

interface MSPluginsPreferenceIconViewAllocator<InitializedType = MSPluginsPreferenceIconView> extends NSViewAllocator<MSPluginsPreferenceIconView> {}
interface MSPluginsPreferenceIconView extends NSView {

  icon(): NSImage;
  setIcon(icon: NSImage): void;
}
declare const MSPluginsPreferenceIconView: {
  alloc(): MSPluginsPreferenceIconViewAllocator;
}

interface MSPluginsPreferencePaneAllocator<InitializedType = MSPluginsPreferencePane> extends MSPreferencePaneAllocator<MSPluginsPreferencePane> {}
interface MSPluginsPreferencePane extends MSPreferencePane, INSTextFieldDelegate {
  getPlugins(sender: any): IBAction;
  togglePluginEnabled(sender: any): IBAction;
  tableContextMenu(sender: any): IBAction;
  openPluginsFolder(sender: any): IBAction;
  installPluginUpdates(sender: any): IBAction;
  installPluginUpdate(sender: any): IBAction;
  openPluginURL(sender: any): IBAction;
  activateSearchField(sender: any): IBAction;

  pluginsArrayController(): NSArrayController;
  setPluginsArrayController(pluginsArrayController: NSArrayController): void;
  pluginSortDescriptors(): NSArray<any>;
  filteredPlugins(): NSArray<any>;
  pluginFilterPredicate(): NSPredicate;
  zeroPluginsImage(): NSImage;
  zeroPluginsTitle(): NSString;
  zeroPluginsTitleFont(): NSFont;
  zeroPluginsText(): NSString;
  filterTextField(): NSSearchField;
  setFilterTextField(filterTextField: NSSearchField): void;
  tableView(): BCKeyEventActionTableView;
  setTableView(tableView: BCKeyEventActionTableView): void;
  getPluginsButton(): NSButton;
  setGetPluginsButton(getPluginsButton: NSButton): void;
  contextMenuControl(): NSControl;
  setContextMenuControl(contextMenuControl: NSControl): void;
  contextMenu(): NSMenu;
  setContextMenu(contextMenu: NSMenu): void;
  spyglassFilterButton(): NSButton;
  setSpyglassFilterButton(spyglassFilterButton: NSButton): void;
  enableUpdateAllButton(): boolean;
  setEnableUpdateAllButton(enableUpdateAllButton: boolean): void;
}
declare const MSPluginsPreferencePane: {
  alloc(): MSPluginsPreferencePaneAllocator;  openWithPluginToHighlight(pluginIdentifier: NSString | string): void;

}

interface MSPluginsPreferenceTableCellViewAllocator<InitializedType = MSPluginsPreferenceTableCellView> extends NSTableCellViewAllocator<MSPluginsPreferenceTableCellView> {}
interface MSPluginsPreferenceTableCellView extends NSTableCellView {

  updateAvailableContainer(): NSView;
  setUpdateAvailableContainer(updateAvailableContainer: NSView): void;
  pluginIncompatibleContainer(): NSView;
  setPluginIncompatibleContainer(pluginIncompatibleContainer: NSView): void;
  updateAvailableInfo(): MSPluginsPreferencesUpdateButton;
  setUpdateAvailableInfo(updateAvailableInfo: MSPluginsPreferencesUpdateButton): void;
  updatePlugin(): NSButton;
  setUpdatePlugin(updatePlugin: NSButton): void;
  pluginUpdating(): NSProgressIndicator;
  setPluginUpdating(pluginUpdating: NSProgressIndicator): void;
  updateAvailableHeightConstraint(): NSLayoutConstraint;
  setUpdateAvailableHeightConstraint(updateAvailableHeightConstraint: NSLayoutConstraint): void;
  incompatiblePluginHeightConstraint(): NSLayoutConstraint;
  setIncompatiblePluginHeightConstraint(incompatiblePluginHeightConstraint: NSLayoutConstraint): void;
  descriptionField(): NSTextField;
  setDescriptionField(descriptionField: NSTextField): void;
  iconView(): MSPluginsPreferenceIconView;
  setIconView(iconView: MSPluginsPreferenceIconView): void;
  tableCellWidthConstraint(): NSLayoutConstraint;
  setTableCellWidthConstraint(tableCellWidthConstraint: NSLayoutConstraint): void;
}
declare const MSPluginsPreferenceTableCellView: {
  alloc(): MSPluginsPreferenceTableCellViewAllocator;
}

interface MSPluginsPreferencesUpdateButtonAllocator<InitializedType = MSPluginsPreferencesUpdateButton> extends NSButtonAllocator<MSPluginsPreferencesUpdateButton> {}
interface MSPluginsPreferencesUpdateButton extends NSButton {

  tableCellView(): MSPluginsPreferenceTableCellView;
  setTableCellView(tableCellView: MSPluginsPreferenceTableCellView): void;
}
declare const MSPluginsPreferencesUpdateButton: {
  alloc(): MSPluginsPreferencesUpdateButtonAllocator;
}

interface MSPointsEventHandlerAllocator<InitializedType = MSPointsEventHandler> extends MSEventHandlerAllocator<MSPointsEventHandler> {}
interface MSPointsEventHandler extends MSEventHandler {
  findSelectedLayer(): MSStyledLayer;
  points(): MSPointArray;
  convertPointToUnitCoordinateSpace(mouse: NSPoint): NSPoint;
  point_isNearPoint(p1: NSPoint, p2: NSPoint): boolean;
  pointAtIndex(index: NSUInteger): NSPoint;
  replacePointAtIndex_withPoint(index: NSInteger, newObj: NSPoint): void;
  movePointAtIndex_toLocation_modifierFlags(index: NSInteger, newLocation: NSPoint, flags: NSEventModifierFlags): void;
  indexOfPointAtLocation(location: NSPoint): NSInteger;
  useSnaps(): boolean;
  pointsToSnap(): MSPointArray;
  bounds(): NSRect;
  convertPointToAbsoluteCoordinates(point: NSPoint): NSPoint;
  handleLinesColor(): NSColor;
  handleLinesPath(): NSBezierPath;
  drawHandleAtPoint_index_selected(p: NSPoint, index: NSInteger, selected: boolean): void;
  drawHandleLines(): void;

  layer(): MSStyledLayer;
  setLayer(layer: MSStyledLayer): void;
  indexForSelectedPoint(): NSInteger;
  setIndexForSelectedPoint(indexForSelectedPoint: NSInteger): void;
  coordinateSpace(): MSLayer;
}
declare const MSPointsEventHandler: {
  alloc(): MSPointsEventHandlerAllocator;
}

interface MSPolygonShapeItemAllocator<InitializedType = MSPolygonShapeItem> extends MSCustomShapeItemAllocator<MSPolygonShapeItem> {}
interface MSPolygonShapeItem extends MSCustomShapeItem {
}
declare const MSPolygonShapeItem: {
  alloc(): MSPolygonShapeItemAllocator;
}

interface MSPopoverActionAllocator<InitializedType = MSPopoverAction> extends MSDocumentActionAllocator<MSPopoverAction> {}
interface MSPopoverAction extends MSDocumentAction {
  showPopover(sender: any): void;
  closePopover(): void;
  popoverWillClose(popover: BCPopover): void;

  popoverViewController(): NSViewController;
  popoverVisible(): boolean;
}
declare const MSPopoverAction: {
  alloc(): MSPopoverActionAllocator;  popoverClass(): any;

}

interface MSPositionInspectorItemAllocator<InitializedType = MSPositionInspectorItem> extends MSInspectorItemAllocator<MSPositionInspectorItem> {}
interface MSPositionInspectorItem extends MSInspectorItem {
}
declare const MSPositionInspectorItem: {
  alloc(): MSPositionInspectorItemAllocator;
}

interface MSPreferencePaneAllocator<InitializedType = MSPreferencePane> extends NSViewControllerAllocator<MSPreferencePane> {
  initWithPreferencesController(preferencesController: MSPreferencesController): InitializedType;
}
interface MSPreferencePane extends NSViewController {
  dismissAlertWindow(alertWindow: NSWindow): void;
  dismissAlertSheet(): void;
  didSwitchToPane(): void;

  preferencesController(): MSPreferencesController;
}
declare const MSPreferencePane: {
  alloc(): MSPreferencePaneAllocator;  identifier(): NSString;
  title(): NSString;
  toolbarIcon(): NSImage;
  nibName(): NSString;

}

interface IMSPreferencePaneSizing {
  preferredSize(): NSSize;
}

interface MSPreferencesControllerAllocator<InitializedType = MSPreferencesController> extends NSWindowControllerAllocator<MSPreferencesController> {}
interface MSPreferencesController extends NSWindowController, INSWindowDelegate {
  switchToPaneWithIdentifier(identifier: NSString | string): MSPreferencePane;
  updateWindowFrame(): void;
  dismissAnyAlertSheet(): void;
  existingPaneWithIdentifier(identifier: NSString | string): MSPreferencePane;

  currentPreferencePane(): MSPreferencePane;
}
declare const MSPreferencesController: {
  alloc(): MSPreferencesControllerAllocator;  sharedController(): MSPreferencesController;

}

interface MSPreferencesPluginInfoAllocator<InitializedType = MSPreferencesPluginInfo> extends NSObjectAllocator<MSPreferencesPluginInfo> {}
interface MSPreferencesPluginInfo extends NSObject {

  name(): NSString;
  pluginDescription(): NSString;
  attributedTitle(): NSAttributedString;
  icon(): NSImage;
  enableCheckboxTitle(): NSString;
  version(): NSString;
  updateVersionString(): NSString;
  updateAvailable(): boolean;
  isCompatible(): boolean;
  warningString(): NSString;
  namePlusAuthor(): NSString;
  homepage(): NSURL;
  isUpdating(): boolean;
  setIsUpdating(isUpdating: boolean): void;
  suppliesData(): boolean;
  pluginBundle(): MSPluginBundle;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}
declare const MSPreferencesPluginInfo: {
  alloc(): MSPreferencesPluginInfoAllocator;  pluginInfoWithPluginBundle(pluginBundle: MSPluginBundle): MSPreferencesPluginInfo;
  pluginInfoWithName(name: NSString | string): MSPreferencesPluginInfo;

}

interface MSPresetPickerButtonAllocator<InitializedType = MSPresetPickerButton> extends NSButtonAllocator<MSPresetPickerButton> {}
interface MSPresetPickerButton extends NSButton {
  animateToOrigin(origin: NSPoint): void;
}
declare const MSPresetPickerButton: {
  alloc(): MSPresetPickerButtonAllocator;
}

interface MSPresetPickerPresetButtonAllocator<InitializedType = MSPresetPickerPresetButton> extends MSPresetPickerButtonAllocator<MSPresetPickerPresetButton> {}
interface MSPresetPickerPresetButton extends MSPresetPickerButton, INSDraggingSource {
  frameConsideringAnimation(): NSRect;
}
declare const MSPresetPickerPresetButton: {
  alloc(): MSPresetPickerPresetButtonAllocator;
}

interface IMSPresetPickerViewDelegate {
  numberOfPresetsInPickerView(pickerView: MSAssetPickerView): NSUInteger;
  addPresetForPickerView(pickerView: MSAssetPickerView): void;
  pickerView_removePresetAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): void;
  pickerView_didPickPresetAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): void;
  drawContentForCellInPickerView_withFrame_atIndex_inRect(pickerView: MSAssetPickerView, drawFrame: boolean, index: NSUInteger, rect: NSRect): void;
  shouldShowAddPresetButton(pickerView: MSAssetPickerView): boolean;
  pickerViewSupportsDrag_fromIndex(pickerView: MSAssetPickerView, index: NSUInteger): boolean;
  pickerViewSupportsDrop(pickerView: MSAssetPickerView): boolean;
  pickerView_shouldShowMenuForItemAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): boolean;
  pickerView_didDragPresetAtIndex_toIndex(pickerView: MSAssetPickerView, sourceIndex: NSUInteger, destinationIndex: NSUInteger): boolean;
  pickerView_insertPresetFromDragRepresentation_atIndex(view: MSAssetPickerView, representation: any, index: NSUInteger): boolean;
  pickerView_dragRepresentationForItemAtIndex(pickerView: any, index: NSUInteger): any;
  presetPickerFinishedDragging(presetView: MSAssetPickerView): void;
  pickerView_didHoverPresetAtIndex(pickerView: MSAssetPickerView, index: NSInteger): void;
  pickerView_didStopHoverPresetAtIndex(pickerView: MSAssetPickerView, index: NSInteger): void;
  pickerView_tooltipForPresetButtonAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): NSString;
}

interface MSPreviewImageCacheAllocator<InitializedType = MSPreviewImageCache> extends NSObjectAllocator<MSPreviewImageCache> {
  initWithSubdirectoryName(subdirectory: NSString | string): InitializedType;
}
interface MSPreviewImageCache extends NSObject {
  fetchPreviewImageForDocumentAtURL_maximumPixelSize_handler(documentURL: NSURL, maxPixelSize: CGFloat, handler: MSPreviewImageHandler): void;

  directoryURL(): NSURL;
}
declare const MSPreviewImageCache: {
  alloc(): MSPreviewImageCacheAllocator;
}

interface MSPrintActionAllocator<InitializedType = MSPrintAction> extends MSDocumentActionAllocator<MSPrintAction> {}
interface MSPrintAction extends MSDocumentAction {
}
declare const MSPrintAction: {
  alloc(): MSPrintActionAllocator;
}

interface MSRadialGradientEventHandlerAllocator<InitializedType = MSRadialGradientEventHandler> extends MSGradientEventHandlerAllocator<MSRadialGradientEventHandler> {}
interface MSRadialGradientEventHandler extends MSGradientEventHandler {
  ellipsePoint(): NSPoint;
  setEllipsePoint(point: NSPoint): void;
  ovalPath(): NSBezierPath;
}
declare const MSRadialGradientEventHandler: {
  alloc(): MSRadialGradientEventHandlerAllocator;
}

interface MSRectangleShapeItemAllocator<InitializedType = MSRectangleShapeItem> extends MSCustomShapeItemAllocator<MSRectangleShapeItem> {}
interface MSRectangleShapeItem extends MSCustomShapeItem {
}
declare const MSRectangleShapeItem: {
  alloc(): MSRectangleShapeItemAllocator;
}

interface MSReduceFileSizeActionAllocator<InitializedType = MSReduceFileSizeAction> extends MSDocumentActionAllocator<MSReduceFileSizeAction> {}
interface MSReduceFileSizeAction extends MSDocumentAction {
}
declare const MSReduceFileSizeAction: {
  alloc(): MSReduceFileSizeActionAllocator;
}

interface MSReduceImageSizeActionAllocator<InitializedType = MSReduceImageSizeAction> extends MSDocumentActionAllocator<MSReduceImageSizeAction> {}
interface MSReduceImageSizeAction extends MSDocumentAction {
  reduceImageSize(sender: any): IBAction;
}
declare const MSReduceImageSizeAction: {
  alloc(): MSReduceImageSizeActionAllocator;
}

interface MSRemoveAllOverridesActionAllocator<InitializedType = MSRemoveAllOverridesAction> extends MSDocumentActionAllocator<MSRemoveAllOverridesAction> {}
interface MSRemoveAllOverridesAction extends MSDocumentAction {
  removeAllOverridesFromSelection(sender: any): IBAction;
}
declare const MSRemoveAllOverridesAction: {
  alloc(): MSRemoveAllOverridesActionAllocator;
}

interface MSRemoveFlowActionAllocator<InitializedType = MSRemoveFlowAction> extends MSFlowBaseActionAllocator<MSRemoveFlowAction> {}
interface MSRemoveFlowAction extends MSFlowBaseAction {
  removeFlow(sender: any): IBAction;
}
declare const MSRemoveFlowAction: {
  alloc(): MSRemoveFlowActionAllocator;
}

interface MSRenameLayerActionAllocator<InitializedType = MSRenameLayerAction> extends MSDocumentActionAllocator<MSRenameLayerAction> {}
interface MSRenameLayerAction extends MSDocumentAction {
  renameLayer(sender: any): IBAction;
}
declare const MSRenameLayerAction: {
  alloc(): MSRenameLayerActionAllocator;
}

interface IMSReorderingContainerDelegate {
  containerBackground_dragDidReorderChildAtIndex_toIndex(backgroundView: MSReorderingContainerView, fromIndex: NSUInteger, toIndex: NSUInteger): void;
  startingOffsetForStackingContainerBackground(backgroundView: MSReorderingContainerView): CGFloat;
  numberOfReorderableSubviewsForContainerBackground(backgroundView: MSReorderingContainerView): NSUInteger;
}

interface MSReorderingContainerViewAllocator<InitializedType = MSReorderingContainerView> extends NSViewAllocator<MSReorderingContainerView> {}
interface MSReorderingContainerView extends NSView {
  reorderSubviewsAnimated(flag: boolean): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSReorderingContainerView: {
  alloc(): MSReorderingContainerViewAllocator;
}

interface MSReorderingViewAllocator<InitializedType = MSReorderingView> extends NSViewAllocator<MSReorderingView> {}
interface MSReorderingView extends NSView, INSDraggingSource {

  deleteAction(): string;
  setDeleteAction(deleteAction: string): void;
  duplicateAction(): string;
  setDuplicateAction(duplicateAction: string): void;
  target(): any;
  setTarget(target: any): void;
  reorderingTag(): NSInteger;
  setReorderingTag(reorderingTag: NSInteger): void;
}
declare const MSReorderingView: {
  alloc(): MSReorderingViewAllocator;
}

interface MSShowReplaceColorSheetActionAllocator<InitializedType = MSShowReplaceColorSheetAction> extends MSDocumentActionAllocator<MSShowReplaceColorSheetAction> {}
interface MSShowReplaceColorSheetAction extends MSDocumentAction {
  showReplaceColorSheet(sender: any | null): IBAction;
}
declare const MSShowReplaceColorSheetAction: {
  alloc(): MSShowReplaceColorSheetActionAllocator;
}

interface MSReplaceColorActionAllocator<InitializedType = MSReplaceColorAction> extends MSDocumentActionAllocator<MSReplaceColorAction> {}
interface MSReplaceColorAction extends MSDocumentAction {
  replaceColor(sender: any): IBAction;
}
declare const MSReplaceColorAction: {
  alloc(): MSReplaceColorActionAllocator;
}

interface IMSReplaceColorActionDetails {

  ignoreAlphaWhenMatchingOriginalColor(): boolean;
  originalColor(): MSColor;
  replaceAlphaOfOriginalColor(): boolean;
  replacementColor(): MSColor;
}

interface MSReplaceColorSheetControllerAllocator<InitializedType = MSReplaceColorSheetController> extends CHSheetControllerAllocator<MSReplaceColorSheetController> {}
interface MSReplaceColorSheetController extends CHSheetController, INSWindowDelegate, INSMenuDelegate, IMSColorInspectorDelegate {
  pickOriginalColor(sender: any): IBAction;
  pickReplacementColor(sender: any): IBAction;
  toggleIgnoreAlpha(sender: any): IBAction;

  cancelButton(): NSButton;
  setCancelButton(cancelButton: NSButton): void;
  ignoreAlphaWhenMatchingOriginalColorButton(): NSButton;
  setIgnoreAlphaWhenMatchingOriginalColorButton(ignoreAlphaWhenMatchingOriginalColorButton: NSButton): void;
  originalColorButton(): MSStylePartPreviewButton;
  setOriginalColorButton(originalColorButton: MSStylePartPreviewButton): void;
  replacementColorButton(): MSStylePartPreviewButton;
  setReplacementColorButton(replacementColorButton: MSStylePartPreviewButton): void;
  keepAlphaOfOriginalColorButton(): NSButton;
  setKeepAlphaOfOriginalColorButton(keepAlphaOfOriginalColorButton: NSButton): void;
  replacementColorPopoverDismissingView(): MSPopoverDismisserView;
  setReplacementColorPopoverDismissingView(replacementColorPopoverDismissingView: MSPopoverDismisserView): void;
  replaceButton(): NSButton;
  setReplaceButton(replaceButton: NSButton): void;
}
declare const MSReplaceColorSheetController: {
  alloc(): MSReplaceColorSheetControllerAllocator;
}

interface MSReplaceFontCellViewAllocator<InitializedType = MSReplaceFontCellView> extends NSTableCellViewAllocator<MSReplaceFontCellView> {}
interface MSReplaceFontCellView extends NSTableCellView {

  fontFamilyButton(): NSButton;
  setFontFamilyButton(fontFamilyButton: NSButton): void;
  fontWeightPopUpButton(): NSPopUpButton;
  setFontWeightPopUpButton(fontWeightPopUpButton: NSPopUpButton): void;
}
declare const MSReplaceFontCellView: {
  alloc(): MSReplaceFontCellViewAllocator;
}

interface MSReplaceFontsActionAllocator<InitializedType = MSReplaceFontsAction> extends MSDocumentActionAllocator<MSReplaceFontsAction> {}
interface MSReplaceFontsAction extends MSDocumentAction, IMSWindowBadgeAction {
  replaceMissingFonts(sender: any): IBAction;
}
declare const MSReplaceFontsAction: {
  alloc(): MSReplaceFontsActionAllocator;
}

interface MSReplaceFontsSheetAllocator<InitializedType = MSReplaceFontsSheet> extends CHSheetControllerAllocator<MSReplaceFontsSheet> {}
interface MSReplaceFontsSheet extends CHSheetController {
}
declare const MSReplaceFontsSheet: {
  alloc(): MSReplaceFontsSheetAllocator;
}

interface MSReplaceImageActionAllocator<InitializedType = MSReplaceImageAction> extends MSDocumentActionAllocator<MSReplaceImageAction> {}
interface MSReplaceImageAction extends MSDocumentAction {
  replaceImage(sender: any): IBAction;
}
declare const MSReplaceImageAction: {
  alloc(): MSReplaceImageActionAllocator;
}

interface MSReplaceWithSymbolActionAllocator<InitializedType = MSReplaceWithSymbolAction> extends MSSharedSymbolActionAllocator<MSReplaceWithSymbolAction> {}
interface MSReplaceWithSymbolAction extends MSSharedSymbolAction {
}
declare const MSReplaceWithSymbolAction: {
  alloc(): MSReplaceWithSymbolActionAllocator;
}

interface MSReplaceWithSymbolMenuBuilderAllocator<InitializedType = MSReplaceWithSymbolMenuBuilder> extends MSMenuBuilderAllocator<MSReplaceWithSymbolMenuBuilder> {}
interface MSReplaceWithSymbolMenuBuilder extends MSMenuBuilder {
  updateMenuItem_forDocument(item: NSMenuItem, document: MSDocument): void;
}
declare const MSReplaceWithSymbolMenuBuilder: {
  alloc(): MSReplaceWithSymbolMenuBuilderAllocator;
}

interface MSReplacementFontPickerViewControllerAllocator<InitializedType = MSReplacementFontPickerViewController> extends MSFontFamilyPickerViewControllerAllocator<MSReplacementFontPickerViewController> {}
interface MSReplacementFontPickerViewController extends MSFontFamilyPickerViewController {
}
declare const MSReplacementFontPickerViewController: {
  alloc(): MSReplacementFontPickerViewControllerAllocator;
}

interface MSResetSharedStyleActionAllocator<InitializedType = MSResetSharedStyleAction> extends MSBaseSharedObjectActionAllocator<MSResetSharedStyleAction> {}
interface MSResetSharedStyleAction extends MSBaseSharedObjectAction {
  resetSharedStyle(sender: any): IBAction;
}
declare const MSResetSharedStyleAction: {
  alloc(): MSResetSharedStyleActionAllocator;
}

interface MSResetSymbolSizeActionAllocator<InitializedType = MSResetSymbolSizeAction> extends MSDocumentActionAllocator<MSResetSymbolSizeAction> {}
interface MSResetSymbolSizeAction extends MSDocumentAction {
  resetSymbolSize(sender: any): IBAction;
}
declare const MSResetSymbolSizeAction: {
  alloc(): MSResetSymbolSizeActionAllocator;
}

interface MSResizeArtboardToFitActionAllocator<InitializedType = MSResizeArtboardToFitAction> extends MSDocumentActionAllocator<MSResizeArtboardToFitAction> {}
interface MSResizeArtboardToFitAction extends MSDocumentAction {
  resizeArtboardToFit(sender: any): IBAction;
}
declare const MSResizeArtboardToFitAction: {
  alloc(): MSResizeArtboardToFitActionAllocator;
}

interface MSResizeGestureRecognizerAllocator<InitializedType = MSResizeGestureRecognizer> extends MSDragGestureRecognizerAllocator<MSResizeGestureRecognizer> {}
interface MSResizeGestureRecognizer extends MSDragGestureRecognizer {

  maySnap(): boolean;
  shouldResizeFromCenter(): boolean;
  constrainProportions(): boolean;
}
declare const MSResizeGestureRecognizer: {
  alloc(): MSResizeGestureRecognizerAllocator;
}

interface MSResizeInspectorItemAllocator<InitializedType = MSResizeInspectorItem> extends MSInspectorItemAllocator<MSResizeInspectorItem> {}
interface MSResizeInspectorItem extends MSInspectorItem {
}
declare const MSResizeInspectorItem: {
  alloc(): MSResizeInspectorItemAllocator;
}

interface MSResizeInspectorSectionAllocator<InitializedType = MSResizeInspectorSection> extends MSBaseInspectorSectionAllocator<MSResizeInspectorSection> {}
interface MSResizeInspectorSection extends MSBaseInspectorSection {
}
declare const MSResizeInspectorSection: {
  alloc(): MSResizeInspectorSectionAllocator;
}

interface MSResizingPreviewAllocator<InitializedType = MSResizingPreview> extends NSViewAllocator<MSResizingPreview> {}
interface MSResizingPreview extends NSView {

  previewResizingOptions(): NSAutoresizingMaskOptions;
  setPreviewResizingOptions(previewResizingOptions: NSAutoresizingMaskOptions): void;
}
declare const MSResizingPreview: {
  alloc(): MSResizingPreviewAllocator;
}

interface MSResizingPreviewContainerAllocator<InitializedType = MSResizingPreviewContainer> extends NSViewAllocator<MSResizingPreviewContainer> {}
interface MSResizingPreviewContainer extends NSView {

  fixTop(): boolean;
  setFixTop(fixTop: boolean): void;
  fixBottom(): boolean;
  setFixBottom(fixBottom: boolean): void;
  fixLeft(): boolean;
  setFixLeft(fixLeft: boolean): void;
  fixRight(): boolean;
  setFixRight(fixRight: boolean): void;
  fixWidth(): boolean;
  setFixWidth(fixWidth: boolean): void;
  fixHeight(): boolean;
  setFixHeight(fixHeight: boolean): void;
  animate(): boolean;
  setAnimate(animate: boolean): void;
}
declare const MSResizingPreviewContainer: {
  alloc(): MSResizingPreviewContainerAllocator;
}

interface MSRevealPluginsActionAllocator<InitializedType = MSRevealPluginsAction> extends MSActionAllocator<MSRevealPluginsAction> {}
interface MSRevealPluginsAction extends MSAction {
  revealPlugins(sender: any): IBAction;
}
declare const MSRevealPluginsAction: {
  alloc(): MSRevealPluginsActionAllocator;
}

interface MSReversePathActionAllocator<InitializedType = MSReversePathAction> extends MSDocumentActionAllocator<MSReversePathAction> {}
interface MSReversePathAction extends MSDocumentAction {
  reversePath(sender: any): IBAction;
}
declare const MSReversePathAction: {
  alloc(): MSReversePathActionAllocator;
}

interface MSRightOffsetHoverButtonCellAllocator<InitializedType = MSRightOffsetHoverButtonCell> extends MSHoverButtonCellAllocator<MSRightOffsetHoverButtonCell> {}
interface MSRightOffsetHoverButtonCell extends MSHoverButtonCell {
}
declare const MSRightOffsetHoverButtonCell: {
  alloc(): MSRightOffsetHoverButtonCellAllocator;
}

interface MSRotateActionAllocator<InitializedType = MSRotateAction> extends MSEventHandlerActionAllocator<MSRotateAction> {}
interface MSRotateAction extends MSEventHandlerAction {
  rotate(sender: any): IBAction;
}
declare const MSRotateAction: {
  alloc(): MSRotateActionAllocator;
}

interface MSRotateClockwiseActionAllocator<InitializedType = MSRotateClockwiseAction> extends MSEventHandlerActionAllocator<MSRotateClockwiseAction> {}
interface MSRotateClockwiseAction extends MSEventHandlerAction {
  rotate90C(sender: any): IBAction;
}
declare const MSRotateClockwiseAction: {
  alloc(): MSRotateClockwiseActionAllocator;
}

interface MSRotateCounterclockwiseActionAllocator<InitializedType = MSRotateCounterclockwiseAction> extends MSEventHandlerActionAllocator<MSRotateCounterclockwiseAction> {}
interface MSRotateCounterclockwiseAction extends MSEventHandlerAction {
  rotate90CC(sender: any): IBAction;
}
declare const MSRotateCounterclockwiseAction: {
  alloc(): MSRotateCounterclockwiseActionAllocator;
}

interface MSRotateEventHandlerAllocator<InitializedType = MSRotateEventHandler> extends MSNormalBaseEventHandlerAllocator<MSRotateEventHandler> {}
interface MSRotateEventHandler extends MSNormalBaseEventHandler, INSTouchBarDelegate {

  exitOnMouseUp(): boolean;
  setExitOnMouseUp(exitOnMouseUp: boolean): void;
  disableMoving(): boolean;
  setDisableMoving(disableMoving: boolean): void;
  rotationCenterPoint(): NSPoint;
  setRotationCenterPoint(rotationCenterPoint: NSPoint): void;
  rotationItems(): NSArray<any>;
}
declare const MSRotateEventHandler: {
  alloc(): MSRotateEventHandlerAllocator;  cursorForDegrees(degrees: NSInteger): NSCursor;

}

interface MSRotationBarAllocator<InitializedType = MSRotationBar> extends NSControlAllocator<MSRotationBar> {}
interface MSRotationBar extends NSControl {

  rotation(): CGFloat;
  setRotation(rotation: CGFloat): void;
}
declare const MSRotationBar: {
  alloc(): MSRotationBarAllocator;
}

interface MSRotationGestureInterpreterAllocator<InitializedType = MSRotationGestureInterpreter> extends NSObjectAllocator<MSRotationGestureInterpreter> {}
interface MSRotationGestureInterpreter extends NSObject {
  updateWithDragRecognizer(recognizer: MSDragGestureRecognizer): IBAction;
  updateWithLocation(location: NSPoint): void;
  rotationInLayer(layer: MSLayer | null): CGFloat;
  rotationInDegreesInLayer(layer: MSLayer | null): CGFloat;

  centerPoint(): NSPoint;
  setCenterPoint(centerPoint: NSPoint): void;
}
declare const MSRotationGestureInterpreter: {
  alloc(): MSRotationGestureInterpreterAllocator;
}

interface MSRoundToPixelActionAllocator<InitializedType = MSRoundToPixelAction> extends MSDocumentActionAllocator<MSRoundToPixelAction> {}
interface MSRoundToPixelAction extends MSDocumentAction {
  roundToPixel(sender: any): IBAction;
}
declare const MSRoundToPixelAction: {
  alloc(): MSRoundToPixelActionAllocator;
}

interface MSResetOriginActionAllocator<InitializedType = MSResetOriginAction> extends MSDocumentActionAllocator<MSResetOriginAction> {}
interface MSResetOriginAction extends MSDocumentAction {
  resetRulerOrigin(sender: any): IBAction;
}
declare const MSResetOriginAction: {
  alloc(): MSResetOriginActionAllocator;
}

interface MSToggleRulerDragLockingActionAllocator<InitializedType = MSToggleRulerDragLockingAction> extends MSDocumentActionAllocator<MSToggleRulerDragLockingAction> {}
interface MSToggleRulerDragLockingAction extends MSDocumentAction {
  toggleRulerDragLocking(sender: any): IBAction;
}
declare const MSToggleRulerDragLockingAction: {
  alloc(): MSToggleRulerDragLockingActionAllocator;
}

interface MSRulerBlockCellAllocator<InitializedType = MSRulerBlockCell> extends MSTintedHoverButtonCellAllocator<MSRulerBlockCell> {}
interface MSRulerBlockCell extends MSTintedHoverButtonCell {
}
declare const MSRulerBlockCell: {
  alloc(): MSRulerBlockCellAllocator;
}

interface MSRulerViewAllocator<InitializedType = MSRulerView> extends NSViewAllocator<MSRulerView> {}
interface MSRulerView extends NSView {
  refreshGuideInDrawViewAtIndex(anIndex: NSUInteger): void;
  refreshGuideInDrawViewAtPosition(line: CGFloat): void;
  mouseEventToPoint(anEvent: NSEvent): NSPoint;
  document(): MSDocument;
  baseLine(): CGFloat;
  baseLineIncludingScrollOrigin(includeOrigin: boolean): CGFloat;
  drawGuidesOnCanvasInRect(aRect: NSRect): void;
  bezierPathForLineAtPosition_inRect(line: CGFloat, aRect: NSRect): NSBezierPath;
  occupiedRegionForRect_withOffset_zoom(rect: NSRect, left: NSInteger, zoom: CGFloat): NSBezierPath;
  scrollOrigin(): NSPoint;
  zoomValue(): CGFloat;
  rulerLength(): NSInteger;
  refreshTemporaryRulerGuide(): void;
  relevantAxisForPoint(aPoint: NSPoint): CGFloat;
  otherAxisForPoint(aPoint: NSPoint): CGFloat;
  setResizeCursor(): void;
  prepareRulerViewLayer(dirtyRect: NSRect): void;

  rulerData(): MSRulerData;
  setRulerData(rulerData: MSRulerData): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  contentView(): MSContentDrawView;
  setContentView(contentView: MSContentDrawView): void;
  mouseDidDrag(): boolean;
  setMouseDidDrag(mouseDidDrag: boolean): void;
  mouseDownPoint(): NSPoint;
  setMouseDownPoint(mouseDownPoint: NSPoint): void;
  axis(): BCAxis;
  setAxis(axis: BCAxis): void;
  temporaryRulerGuide(): CGFloat;
  setTemporaryRulerGuide(temporaryRulerGuide: CGFloat): void;
}
declare const MSRulerView: {
  alloc(): MSRulerViewAllocator;
  rulerDraggingLocked(): boolean;
  setRulerDraggingLocked(rulerDraggingLocked: boolean): void;

}

declare enum MSLineDrawingOptions {
  MSShortLine = 0x01,
  MSDarkLine = 0x02,
}

declare enum MSMetricsDrawingOptions {
  MSMetricsDrawingLeft = 1,
  MSMetricsDrawingRight = 2,
}

interface MSRulerViewLayerAllocator<InitializedType = MSRulerViewLayer> extends CALayerAllocator<MSRulerViewLayer> {}
interface MSRulerViewLayer extends CALayer {
  drawBackground(): void;
  drawBackgroundForLabel_atPoint(string: NSString | string, p: NSPoint): void;

  axis(): BCAxis;
  setAxis(axis: BCAxis): void;
  formatter(): NSNumberFormatter;
  setFormatter(formatter: NSNumberFormatter): void;
  snapColor(): NSColor;
  setSnapColor(snapColor: NSColor): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  baseLine(): CGFloat;
  setBaseLine(baseLine: CGFloat): void;
  occupiedRegion(): NSRect;
  setOccupiedRegion(occupiedRegion: NSRect): void;
  guides(): NSArray<any>;
  setGuides(guides: NSArray<any> | any[]): void;
  shouldDrawGuides(): boolean;
  setShouldDrawGuides(shouldDrawGuides: boolean): void;
  parentView(): NSView;
  setParentView(parentView: NSView): void;
}
declare const MSRulerViewLayer: {
  alloc(): MSRulerViewLayerAllocator;
}

interface MSRunCustomScriptActionAllocator<InitializedType = MSRunCustomScriptAction> extends MSActionAllocator<MSRunCustomScriptAction> {}
interface MSRunCustomScriptAction extends MSAction {
  runCustomScript(sender: any): IBAction;
}
declare const MSRunCustomScriptAction: {
  alloc(): MSRunCustomScriptActionAllocator;
}

interface MSRunCustomScriptSheetAllocator<InitializedType = MSRunCustomScriptSheet> extends CHSheetControllerAllocator<MSRunCustomScriptSheet> {}
interface MSRunCustomScriptSheet extends CHSheetController, INSTextViewDelegate {
  saveAction(sender: any): IBAction;
  scriptingMenuAction(sender: any): IBAction;

  logField(): NSTextView;
  setLogField(logField: NSTextView): void;
}
declare const MSRunCustomScriptSheet: {
  alloc(): MSRunCustomScriptSheetAllocator;
}

interface MSRunLastScriptActionAllocator<InitializedType = MSRunLastScriptAction> extends MSActionAllocator<MSRunLastScriptAction> {}
interface MSRunLastScriptAction extends MSAction {
  runLastScript(sender: any): IBAction;
}
declare const MSRunLastScriptAction: {
  alloc(): MSRunLastScriptActionAllocator;
}

interface MSRunPluginActionAllocator<InitializedType = MSRunPluginAction> extends MSActionAllocator<MSRunPluginAction> {}
interface MSRunPluginAction extends MSAction {
  runPlugin(sender: any): IBAction;
}
declare const MSRunPluginAction: {
  alloc(): MSRunPluginActionAllocator;
}

interface MSSaveAsTemplateActionAllocator<InitializedType = MSSaveAsTemplateAction> extends MSDocumentActionAllocator<MSSaveAsTemplateAction> {}
interface MSSaveAsTemplateAction extends MSDocumentAction {
  saveAsTemplate(sender: any): IBAction;
}
declare const MSSaveAsTemplateAction: {
  alloc(): MSSaveAsTemplateActionAllocator;
}

interface MSSaveAsTemplateSheetAllocator<InitializedType = MSSaveAsTemplateSheet> extends CHSheetControllerAllocator<MSSaveAsTemplateSheet> {}
interface MSSaveAsTemplateSheet extends CHSheetController {

  inputCompletionBlock(): MSSaveAsTemplateSheetCompletionBlock;
  setInputCompletionBlock(inputCompletionBlock: MSSaveAsTemplateSheetCompletionBlock): void;
  inputField(): NSTextField;
  setInputField(inputField: NSTextField): void;
}
declare const MSSaveAsTemplateSheet: {
  alloc(): MSSaveAsTemplateSheetAllocator;  runForDocument_completionBlock(document: MSDocument, block: MSSaveAsTemplateSheetCompletionBlock): any;

}

interface MSScaleActionAllocator<InitializedType = MSScaleAction> extends MSDocumentActionAllocator<MSScaleAction> {}
interface MSScaleAction extends MSDocumentAction {
  scale(sender: any): IBAction;
}
declare const MSScaleAction: {
  alloc(): MSScaleActionAllocator;
}

interface MSScaleSheetAllocator<InitializedType = MSScaleSheet> extends MSCanvasUpdatingSheetAllocator<MSScaleSheet> {}
interface MSScaleSheet extends MSCanvasUpdatingSheet {
}
declare const MSScaleSheet: {
  alloc(): MSScaleSheetAllocator;
}

interface MSScissorsEventHandlerAllocator<InitializedType = MSScissorsEventHandler> extends MSEventHandlerAllocator<MSScissorsEventHandler> {}
interface MSScissorsEventHandler extends MSEventHandler {
}
declare const MSScissorsEventHandler: {
  alloc(): MSScissorsEventHandlerAllocator;
}

interface MSScriptDocumentAllocator<InitializedType = MSScriptDocument> extends NSDocumentAllocator<MSScriptDocument> {}
interface MSScriptDocument extends NSDocument {
}
declare const MSScriptDocument: {
  alloc(): MSScriptDocumentAllocator;
}

interface MSScrollViewAllocator<InitializedType = MSScrollView> extends NSScrollViewAllocator<MSScrollView> {}
interface MSScrollView extends NSScrollView {

  allowsScrolling(): boolean;
  setAllowsScrolling(allowsScrolling: boolean): void;
}
declare const MSScrollView: {
  alloc(): MSScrollViewAllocator;
}

interface MSSectionBackgroundSeparatorViewAllocator<InitializedType = MSSectionBackgroundSeparatorView> extends NSViewAllocator<MSSectionBackgroundSeparatorView> {}
interface MSSectionBackgroundSeparatorView extends NSView {
}
declare const MSSectionBackgroundSeparatorView: {
  alloc(): MSSectionBackgroundSeparatorViewAllocator;  separator(): MSSectionBackgroundSeparatorView;
  separatorWithInsets(insets: NSEdgeInsets): MSSectionBackgroundSeparatorView;

}

interface MSColorInspectorSeparatorViewAllocator<InitializedType = MSColorInspectorSeparatorView> extends MSSectionBackgroundSeparatorViewAllocator<MSColorInspectorSeparatorView> {}
interface MSColorInspectorSeparatorView extends MSSectionBackgroundSeparatorView {
}
declare const MSColorInspectorSeparatorView: {
  alloc(): MSColorInspectorSeparatorViewAllocator;
}

interface MSFlatSectionBackgroundSeparatorViewAllocator<InitializedType = MSFlatSectionBackgroundSeparatorView> extends MSSectionBackgroundSeparatorViewAllocator<MSFlatSectionBackgroundSeparatorView> {}
interface MSFlatSectionBackgroundSeparatorView extends MSSectionBackgroundSeparatorView {
}
declare const MSFlatSectionBackgroundSeparatorView: {
  alloc(): MSFlatSectionBackgroundSeparatorViewAllocator;
}

interface MSSubtleSectionSeparatorViewAllocator<InitializedType = MSSubtleSectionSeparatorView> extends MSSectionBackgroundSeparatorViewAllocator<MSSubtleSectionSeparatorView> {}
interface MSSubtleSectionSeparatorView extends MSSectionBackgroundSeparatorView {
}
declare const MSSubtleSectionSeparatorView: {
  alloc(): MSSubtleSectionSeparatorViewAllocator;
}

interface MSSectionBackgroundViewAllocator<InitializedType = MSSectionBackgroundView> extends NSViewAllocator<MSSectionBackgroundView> {}
interface MSSectionBackgroundView extends NSView {
  recalculateHeight(): void;
  stackSubviews(): void;
}
declare const MSSectionBackgroundView: {
  alloc(): MSSectionBackgroundViewAllocator;  sectionBackgroundWithController(controller: NSViewController): MSSectionBackgroundView;

}

interface MSWhiteHeaderViewAllocator<InitializedType = MSWhiteHeaderView> extends NSViewAllocator<MSWhiteHeaderView> {}
interface MSWhiteHeaderView extends NSView {
}
declare const MSWhiteHeaderView: {
  alloc(): MSWhiteHeaderViewAllocator;
}

interface MSSegmentedToolbarItemAllocator<InitializedType = MSSegmentedToolbarItem> extends NSToolbarItemGroupAllocator<MSSegmentedToolbarItem> {
  initWithAction_forToolbar(action: MSActionGroup, forToolbar: boolean): InitializedType;
}
interface MSSegmentedToolbarItem extends NSToolbarItemGroup {
  validateWithAction(action: MSActionGroup): void;
}
declare const MSSegmentedToolbarItem: {
  alloc(): MSSegmentedToolbarItemAllocator;
}

interface MSSelectAllArtboardsActionAllocator<InitializedType = MSSelectAllArtboardsAction> extends MSDocumentActionAllocator<MSSelectAllArtboardsAction> {}
interface MSSelectAllArtboardsAction extends MSDocumentAction {
  selectAllArtboards(sender: any): IBAction;
}
declare const MSSelectAllArtboardsAction: {
  alloc(): MSSelectAllArtboardsActionAllocator;
}

interface MSSelectVectorHandleGestureRecognizerAllocator<InitializedType = MSSelectVectorHandleGestureRecognizer> extends MSGestureRecognizerAllocator<MSSelectVectorHandleGestureRecognizer> {}
interface MSSelectVectorHandleGestureRecognizer extends MSGestureRecognizer {

  toggleSelection(): boolean;
  modifierFlags(): NSEventModifierFlags;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSSelectVectorHandleGestureRecognizer: {
  alloc(): MSSelectVectorHandleGestureRecognizerAllocator;
}

interface IMSSelectVectorHandleGestureRecognizerDelegate {
  gestureRecognizerShouldDelaySelectionUntilMouseUp(sender: MSSelectVectorHandleGestureRecognizer): boolean;
}

interface MSSendToSymbolsPageActionAllocator<InitializedType = MSSendToSymbolsPageAction> extends MSDocumentActionAllocator<MSSendToSymbolsPageAction> {}
interface MSSendToSymbolsPageAction extends MSDocumentAction {
  sendSymbolToSymbolsPage(sender: any): IBAction;
}
declare const MSSendToSymbolsPageAction: {
  alloc(): MSSendToSymbolsPageActionAllocator;
}

interface MSSeparatorInspectorItemAllocator<InitializedType = MSSeparatorInspectorItem> extends MSInspectorItemAllocator<MSSeparatorInspectorItem> {}
interface MSSeparatorInspectorItem extends MSInspectorItem {
}
declare const MSSeparatorInspectorItem: {
  alloc(): MSSeparatorInspectorItemAllocator;
}

interface MSSubtleSeparatorInspectorItemAllocator<InitializedType = MSSubtleSeparatorInspectorItem> extends MSInspectorItemAllocator<MSSubtleSeparatorInspectorItem> {}
interface MSSubtleSeparatorInspectorItem extends MSInspectorItem {
}
declare const MSSubtleSeparatorInspectorItem: {
  alloc(): MSSubtleSeparatorInspectorItemAllocator;
}

interface MSShadowInspectorViewControllerAllocator<InitializedType = MSShadowInspectorViewController> extends MSColorStylePartInspectorViewControllerAllocator<MSShadowInspectorViewController> {}
interface MSShadowInspectorViewController extends MSColorStylePartInspectorViewController {

  type(): NSString;
  setType(type: NSString | string): void;
}
declare const MSShadowInspectorViewController: {
  alloc(): MSShadowInspectorViewControllerAllocator;
}

interface MSShapeActionAllocator<InitializedType = MSShapeAction> extends MSDocumentActionAllocator<MSShapeAction> {}
interface MSShapeAction extends MSDocumentAction {
}
declare const MSShapeAction: {
  alloc(): MSShapeActionAllocator;
}

interface MSBaseShapeActionAllocator<InitializedType = MSBaseShapeAction> extends MSBaseInsertActionAllocator<MSBaseShapeAction> {}
interface MSBaseShapeAction extends MSBaseInsertAction {
  prototypeLayer(): MSShapePathLayer;
}
declare const MSBaseShapeAction: {
  alloc(): MSBaseShapeActionAllocator;  insertShapeLayer_identifier_document(shapeOrPath: any, identifier: NSString | string, doc: MSDocument): any;

}

interface MSRectangleShapeActionAllocator<InitializedType = MSRectangleShapeAction> extends MSBaseShapeActionAllocator<MSRectangleShapeAction> {}
interface MSRectangleShapeAction extends MSBaseShapeAction {
}
declare const MSRectangleShapeAction: {
  alloc(): MSRectangleShapeActionAllocator;
}

interface MSOvalShapeActionAllocator<InitializedType = MSOvalShapeAction> extends MSBaseShapeActionAllocator<MSOvalShapeAction> {}
interface MSOvalShapeAction extends MSBaseShapeAction {
}
declare const MSOvalShapeAction: {
  alloc(): MSOvalShapeActionAllocator;
}

interface MSRoundedRectangleShapeActionAllocator<InitializedType = MSRoundedRectangleShapeAction> extends MSBaseShapeActionAllocator<MSRoundedRectangleShapeAction> {}
interface MSRoundedRectangleShapeAction extends MSBaseShapeAction {
}
declare const MSRoundedRectangleShapeAction: {
  alloc(): MSRoundedRectangleShapeActionAllocator;
}

interface MSStarShapeActionAllocator<InitializedType = MSStarShapeAction> extends MSBaseShapeActionAllocator<MSStarShapeAction> {}
interface MSStarShapeAction extends MSBaseShapeAction {
}
declare const MSStarShapeAction: {
  alloc(): MSStarShapeActionAllocator;
}

interface MSPolygonShapeActionAllocator<InitializedType = MSPolygonShapeAction> extends MSBaseShapeActionAllocator<MSPolygonShapeAction> {}
interface MSPolygonShapeAction extends MSBaseShapeAction {
}
declare const MSPolygonShapeAction: {
  alloc(): MSPolygonShapeActionAllocator;
}

interface MSTriangleShapeActionAllocator<InitializedType = MSTriangleShapeAction> extends MSBaseShapeActionAllocator<MSTriangleShapeAction> {}
interface MSTriangleShapeAction extends MSBaseShapeAction {
}
declare const MSTriangleShapeAction: {
  alloc(): MSTriangleShapeActionAllocator;
}

interface MSShapeEventHandlerAllocator<InitializedType = MSShapeEventHandler> extends MSEventHandlerAllocator<MSShapeEventHandler> {}
interface MSShapeEventHandler extends MSEventHandler, INSTextDelegate, INSMenuDelegate, IMSGestureRecognizerDelegate {
  forceSelection(sender: NSButton): IBAction;
  pathDidOpenOrClose(): void;
  refreshCloseOrOpenPathUI(): void;

  layers(): NSArray<any>;
  canvasHandler(): MSVectorCanvas;
  inspectorViewController(): MSEditShapeInspectorViewController;
  pathController(): MSPathController;
  editingBehavior(): MSShapeEditingBehavior;
  setEditingBehavior(editingBehavior: MSShapeEditingBehavior): void;
}
declare const MSShapeEventHandler: {
  alloc(): MSShapeEventHandlerAllocator;
}

interface MSSharedObjectActionAllocator<InitializedType = MSSharedObjectAction> extends MSDocumentActionAllocator<MSSharedObjectAction> {}
interface MSSharedObjectAction extends MSDocumentAction, INSMenuDelegate {
  sortedObjectMenuItemsForMenu(menu: NSMenu): NSArray<any>;

  sharedObjectName(): NSString;
}
declare const MSSharedObjectAction: {
  alloc(): MSSharedObjectActionAllocator;
}

interface MSSharedObjectViewAllocator<InitializedType = MSSharedObjectView> extends NSViewAllocator<MSSharedObjectView> {}
interface MSSharedObjectView extends NSView {

  sharedObject(): MSShareableObject;
  setSharedObject(sharedObject: MSShareableObject): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  labelColor(): NSColor;
  setLabelColor(labelColor: NSColor): void;
  labelBackgroundColor(): NSColor;
  setLabelBackgroundColor(labelBackgroundColor: NSColor): void;
  borders(): NSUInteger;
  setBorders(borders: NSUInteger): void;
  hasShadow(): boolean;
  setHasShadow(hasShadow: boolean): void;
}
declare const MSSharedObjectView: {
  alloc(): MSSharedObjectViewAllocator;
}

interface MSSharedStylesInspectorItemAllocator<InitializedType = MSSharedStylesInspectorItem> extends MSInspectorItemAllocator<MSSharedStylesInspectorItem> {}
interface MSSharedStylesInspectorItem extends MSInspectorItem, INSMenuDelegate {
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
}
declare const MSSharedStylesInspectorItem: {
  alloc(): MSSharedStylesInspectorItemAllocator;
}

interface MSSharedSymbolActionAllocator<InitializedType = MSSharedSymbolAction> extends MSSharedObjectActionAllocator<MSSharedSymbolAction> {}
interface MSSharedSymbolAction extends MSSharedObjectAction {

  menuBuilder(): MSForeignObjectMenuBuilder;
}
declare const MSSharedSymbolAction: {
  alloc(): MSSharedSymbolActionAllocator;
}

interface MSShowOnlineHelpActionAllocator<InitializedType = MSShowOnlineHelpAction> extends MSActionAllocator<MSShowOnlineHelpAction> {}
interface MSShowOnlineHelpAction extends MSAction {
  showOnlineHelp(sender: any): IBAction;
}
declare const MSShowOnlineHelpAction: {
  alloc(): MSShowOnlineHelpActionAllocator;
}

interface MSShowReleaseNotesWindowActionAllocator<InitializedType = MSShowReleaseNotesWindowAction> extends MSActionAllocator<MSShowReleaseNotesWindowAction> {}
interface MSShowReleaseNotesWindowAction extends MSAction {
  showReleaseNotesWindow(sender: any): IBAction;
}
declare const MSShowReleaseNotesWindowAction: {
  alloc(): MSShowReleaseNotesWindowActionAllocator;
}

interface MSShowSupportPageActionAllocator<InitializedType = MSShowSupportPageAction> extends MSActionAllocator<MSShowSupportPageAction> {}
interface MSShowSupportPageAction extends MSAction {
  showSupportPage(sender: any): IBAction;
}
declare const MSShowSupportPageAction: {
  alloc(): MSShowSupportPageActionAllocator;
}

interface MSSizeInspectorItemAllocator<InitializedType = MSSizeInspectorItem> extends MSBaseSizeInspectorItemAllocator<MSSizeInspectorItem> {}
interface MSSizeInspectorItem extends MSBaseSizeInspectorItem {
}
declare const MSSizeInspectorItem: {
  alloc(): MSSizeInspectorItemAllocator;
}

interface MSSliceDragViewAllocator<InitializedType = MSSliceDragView> extends NSViewAllocator<MSSliceDragView> {}
interface MSSliceDragView extends NSView, INSDraggingSource, INSPasteboardWriting {
  setExportableLayer_previewCompletionBlock(layer: MSLayer, completionBlock: dispatch_block_t): void;
  sizeToFit(): void;
}
declare const MSSliceDragView: {
  alloc(): MSSliceDragViewAllocator;
}

interface MSSliceExportOptionsAllocator<InitializedType = MSSliceExportOptions> extends NSViewControllerAllocator<MSSliceExportOptions> {}
interface MSSliceExportOptions extends NSViewController {
}
declare const MSSliceExportOptions: {
  alloc(): MSSliceExportOptionsAllocator;  exportOptionsForRequests(requests: NSArray<any> | any[]): MSSliceExportOptions;

}

interface MSSliceExportPropertiesInspectorItemAllocator<InitializedType = MSSliceExportPropertiesInspectorItem> extends MSInspectorItemAllocator<MSSliceExportPropertiesInspectorItem> {}
interface MSSliceExportPropertiesInspectorItem extends MSInspectorItem, IMSLayerChangeObserver {
}
declare const MSSliceExportPropertiesInspectorItem: {
  alloc(): MSSliceExportPropertiesInspectorItemAllocator;
}

interface MSSmallButtonCellAllocator<InitializedType = MSSmallButtonCell> extends NSButtonCellAllocator<MSSmallButtonCell> {}
interface MSSmallButtonCell extends NSButtonCell {
}
declare const MSSmallButtonCell: {
  alloc(): MSSmallButtonCellAllocator;
}

interface MSSmartRotateActionAllocator<InitializedType = MSSmartRotateAction> extends MSDocumentActionAllocator<MSSmartRotateAction> {}
interface MSSmartRotateAction extends MSDocumentAction {
  smartRotate(sender: any): IBAction;
}
declare const MSSmartRotateAction: {
  alloc(): MSSmartRotateActionAllocator;
}

interface MSSmartRotateEventHandlerAllocator<InitializedType = MSSmartRotateEventHandler> extends MSEventHandlerAllocator<MSSmartRotateEventHandler> {}
interface MSSmartRotateEventHandler extends MSEventHandler {

  numberOfRepetitions(): NSUInteger;
  setNumberOfRepetitions(numberOfRepetitions: NSUInteger): void;
}
declare const MSSmartRotateEventHandler: {
  alloc(): MSSmartRotateEventHandlerAllocator;
}

interface MSSmartRotateSheetAllocator<InitializedType = MSSmartRotateSheet> extends CHSheetControllerAllocator<MSSmartRotateSheet> {}
interface MSSmartRotateSheet extends CHSheetController {

  explanationLabel(): NSTextField;
  setExplanationLabel(explanationLabel: NSTextField): void;
  numberOfCopies(): NSInteger;
  setNumberOfCopies(numberOfCopies: NSInteger): void;
}
declare const MSSmartRotateSheet: {
  alloc(): MSSmartRotateSheetAllocator;
}

interface MSSpecialLayerViewControllerAllocator<InitializedType = MSSpecialLayerViewController> extends NSViewControllerAllocator<MSSpecialLayerViewController> {}
interface MSSpecialLayerViewController extends NSViewController, IMSInspectorSection, INSMenuDelegate {
  changeTextLayerFont(sender: any): IBAction;
  valuesPossiblyChanged(): void;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSSpecialLayerViewController: {
  alloc(): MSSpecialLayerViewControllerAllocator;
}

interface MSSplitViewAllocator<InitializedType = MSSplitView> extends NSSplitViewAllocator<MSSplitView> {}
interface MSSplitView extends NSSplitView {
}
declare const MSSplitView: {
  alloc(): MSSplitViewAllocator;
}

interface MSSidebarSplitViewAllocator<InitializedType = MSSidebarSplitView> extends NSSplitViewAllocator<MSSidebarSplitView> {}
interface MSSidebarSplitView extends NSSplitView {
}
declare const MSSidebarSplitView: {
  alloc(): MSSidebarSplitViewAllocator;
}

interface MSSquareButtonCellAllocator<InitializedType = MSSquareButtonCell> extends NSButtonCellAllocator<MSSquareButtonCell> {}
interface MSSquareButtonCell extends NSButtonCell {
}
declare const MSSquareButtonCell: {
  alloc(): MSSquareButtonCellAllocator;
}

interface MSStackViewAllocator<InitializedType = MSStackView> extends NSViewAllocator<MSStackView> {}
interface MSStackView extends NSView {
  stack(sender: any): IBAction;

  autoupdatesMaximumHeight(): boolean;
  setAutoupdatesMaximumHeight(autoupdatesMaximumHeight: boolean): void;
  maximumHeight(): NSInteger;
  setMaximumHeight(maximumHeight: NSInteger): void;
  minimumHeight(): CGFloat;
  setMinimumHeight(minimumHeight: CGFloat): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  keyResponder(): any;
  setKeyResponder(keyResponder: any): void;
}
declare const MSStackView: {
  alloc(): MSStackViewAllocator;
}

interface MSStackViewScrollViewAllocator<InitializedType = MSStackViewScrollView> extends NSScrollViewAllocator<MSStackViewScrollView> {}
interface MSStackViewScrollView extends NSScrollView {
}
declare const MSStackViewScrollView: {
  alloc(): MSStackViewScrollViewAllocator;
}

interface MSStandardInspectorViewControllersAllocator<InitializedType = MSStandardInspectorViewControllers> extends NSObjectAllocator<MSStandardInspectorViewControllers> {}
interface MSStandardInspectorViewControllers extends NSObject {

  geometryViewController(): MSGeometryInspectorSection;
  resizeSection(): MSResizeInspectorSection;
  fillViewController(): MSMultipleFillInspectorViewController;
  borderViewController(): MSMultipleBorderInspectorViewController;
  blurViewController(): MSBlurInspectorViewController;
  colorControlsViewController(): MSColorControlsInspectorViewController;
  flowInspectorViewController(): MSFlowInspectorSection;
  appearanceInspectorSection(): MSAppearanceInspectorSection;
  specialLayerViewController(): MSSpecialLayerViewController;
  exportPreviewViewController(): MSExportPreviewInspectorSection;
  exportViewController(): MSExportInspectorViewController;
  footerViewController(): MSFooterInspectorSection;
}
declare const MSStandardInspectorViewControllers: {
  alloc(): MSStandardInspectorViewControllersAllocator;
}

interface MSStarShapeItemAllocator<InitializedType = MSStarShapeItem> extends MSCustomShapeItemAllocator<MSStarShapeItem> {}
interface MSStarShapeItem extends MSCustomShapeItem {
}
declare const MSStarShapeItem: {
  alloc(): MSStarShapeItemAllocator;
}

interface MSBaseStyleActionAllocator<InitializedType = MSBaseStyleAction> extends MSDocumentActionAllocator<MSBaseStyleAction> {}
interface MSBaseStyleAction extends MSDocumentAction {
}
declare const MSBaseStyleAction: {
  alloc(): MSBaseStyleActionAllocator;
}

interface MSAddFillActionAllocator<InitializedType = MSAddFillAction> extends MSBaseStyleActionAllocator<MSAddFillAction> {}
interface MSAddFillAction extends MSBaseStyleAction {
  addFill(sender: any): IBAction;
}
declare const MSAddFillAction: {
  alloc(): MSAddFillActionAllocator;
}

interface MSAddBorderActionAllocator<InitializedType = MSAddBorderAction> extends MSBaseStyleActionAllocator<MSAddBorderAction> {}
interface MSAddBorderAction extends MSBaseStyleAction {
  addBorder(sender: any): IBAction;
}
declare const MSAddBorderAction: {
  alloc(): MSAddBorderActionAllocator;
}

interface MSAddShadowActionAllocator<InitializedType = MSAddShadowAction> extends MSBaseStyleActionAllocator<MSAddShadowAction> {}
interface MSAddShadowAction extends MSBaseStyleAction {
  addShadow(sender: any): IBAction;
}
declare const MSAddShadowAction: {
  alloc(): MSAddShadowActionAllocator;
}

interface MSAddInnerShadowActionAllocator<InitializedType = MSAddInnerShadowAction> extends MSBaseStyleActionAllocator<MSAddInnerShadowAction> {}
interface MSAddInnerShadowAction extends MSBaseStyleAction {
  addInnerShadow(sender: any): IBAction;
}
declare const MSAddInnerShadowAction: {
  alloc(): MSAddInnerShadowActionAllocator;
}

interface MSShowFillOptionsActionAllocator<InitializedType = MSShowFillOptionsAction> extends MSBaseStyleActionAllocator<MSShowFillOptionsAction> {}
interface MSShowFillOptionsAction extends MSBaseStyleAction {
  showFillOptions(sender: any): IBAction;
}
declare const MSShowFillOptionsAction: {
  alloc(): MSShowFillOptionsActionAllocator;
}

interface MSShowBorderOptionsActionAllocator<InitializedType = MSShowBorderOptionsAction> extends MSBaseStyleActionAllocator<MSShowBorderOptionsAction> {}
interface MSShowBorderOptionsAction extends MSBaseStyleAction {
  showBorderOptions(sender: any): IBAction;
}
declare const MSShowBorderOptionsAction: {
  alloc(): MSShowBorderOptionsActionAllocator;
}

interface MSRemoveUnusedStylesActionAllocator<InitializedType = MSRemoveUnusedStylesAction> extends MSBaseStyleActionAllocator<MSRemoveUnusedStylesAction> {}
interface MSRemoveUnusedStylesAction extends MSBaseStyleAction {
  removeUnusedStyles(sender: any): IBAction;
}
declare const MSRemoveUnusedStylesAction: {
  alloc(): MSRemoveUnusedStylesActionAllocator;
}

interface MSStyleOverrideInspectorItemAllocator<InitializedType = MSStyleOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<MSStyleOverrideInspectorItem> {}
interface MSStyleOverrideInspectorItem extends MSOverrideInspectorItem {
}
declare const MSStyleOverrideInspectorItem: {
  alloc(): MSStyleOverrideInspectorItemAllocator;
}

interface MSLayerStyleOverrideInspectorItemAllocator<InitializedType = MSLayerStyleOverrideInspectorItem> extends MSStyleOverrideInspectorItemAllocator<MSLayerStyleOverrideInspectorItem> {}
interface MSLayerStyleOverrideInspectorItem extends MSStyleOverrideInspectorItem {
}
declare const MSLayerStyleOverrideInspectorItem: {
  alloc(): MSLayerStyleOverrideInspectorItemAllocator;
}

interface MSTextStyleOverrideInspectorItemAllocator<InitializedType = MSTextStyleOverrideInspectorItem> extends MSStyleOverrideInspectorItemAllocator<MSTextStyleOverrideInspectorItem> {}
interface MSTextStyleOverrideInspectorItem extends MSStyleOverrideInspectorItem {
}
declare const MSTextStyleOverrideInspectorItem: {
  alloc(): MSTextStyleOverrideInspectorItemAllocator;
}

interface IMSStylePartInspectorDelegate {
  switchToEventHandlerWithName(handlerName: NSString | string): any;
  layers(): NSArray<any>;
  reload(): void;
}

interface MSStylePartInspectorItemAllocator<InitializedType = MSStylePartInspectorItem> extends NSViewControllerAllocator<MSStylePartInspectorItem> {}
interface MSStylePartInspectorItem extends NSViewController {
  updateDisplayedValues(): void;

  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
  layers(): NSArray<any>;
  stylesController(): NSArrayController;
  setStylesController(stylesController: NSArrayController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSStylePartInspectorItem: {
  alloc(): MSStylePartInspectorItemAllocator;
}

interface IMSStylePartInspectorItemDelegate {
  stylePartInspectorItemDocument(inspectorItem: NSViewController): MSDocument;
  valuesPossiblyChanged(item: NSViewController): void;
}

interface MSStylePartInspectorViewControllerAllocator<InitializedType = MSStylePartInspectorViewController> extends NSViewControllerAllocator<MSStylePartInspectorViewController> {}
interface MSStylePartInspectorViewController extends NSViewController, IMSInspectorSection, INSWindowDelegate {
  prepareForReuse(): void;
  hasEnabledStyle(): boolean;
  didGetAddedToInspector(): void;
  prepare(): void;
  supportedActionsForLayers(layers: NSArray<any> | any[]): MSMultipleStylePartInspectorAction;
  closePopover(): void;

  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
  arrayController(): NSArrayController;
  setArrayController(arrayController: NSArrayController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
}
declare const MSStylePartInspectorViewController: {
  alloc(): MSStylePartInspectorViewControllerAllocator;  stylePartViewController(): any;

}

declare enum MSMultipleStylePartInspectorAction {
  MSMultipleStylePartInspectorActionNone = 0,
  MSMultipleStylePartInspectorActionDuplicate = 1 << 0,
  MSMultipleStylePartInspectorActionRemove = 1 << 1,
}

interface MSStylePartPreviewButtonAllocator<InitializedType = MSStylePartPreviewButton> extends MSInspectorButtonAllocator<MSStylePartPreviewButton> {}
interface MSStylePartPreviewButton extends MSInspectorButton {

  stylePart(): MSStylePart;
  setStylePart(stylePart: MSStylePart): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  dragOwner(): any;
  setDragOwner(dragOwner: any): void;
}
declare const MSStylePartPreviewButton: {
  alloc(): MSStylePartPreviewButtonAllocator;
}

interface MSMultipleStylePartsPlaceholderAllocator<InitializedType = MSMultipleStylePartsPlaceholder> extends MSStylePartAllocator<MSMultipleStylePartsPlaceholder> {}
interface MSMultipleStylePartsPlaceholder extends MSStylePart {
}
declare const MSMultipleStylePartsPlaceholder: {
  alloc(): MSMultipleStylePartsPlaceholderAllocator;
}

interface MSMultipleColorsPlaceholderAllocator<InitializedType = MSMultipleColorsPlaceholder> extends NSObjectAllocator<MSMultipleColorsPlaceholder> {}
interface MSMultipleColorsPlaceholder extends NSObject {
}
declare const MSMultipleColorsPlaceholder: {
  alloc(): MSMultipleColorsPlaceholderAllocator;  placeholderColor(): MSMultipleColorsPlaceholder;

}

interface IMSStylePartPreviewButtonDisabledTarget {
  stylePartPreviewButtonDisabledAction(button: MSStylePartPreviewButton): IBAction;
}

interface IMSStylePartPreviewButtonDelegate {
  stylePartPreviewButtonPreviewColorSpace(button: MSStylePartPreviewButton): NSColorSpace;
}

interface MSSwitchModeButtonCellAllocator<InitializedType = MSSwitchModeButtonCell> extends NSButtonCellAllocator<MSSwitchModeButtonCell> {}
interface MSSwitchModeButtonCell extends NSButtonCell {
}
declare const MSSwitchModeButtonCell: {
  alloc(): MSSwitchModeButtonCellAllocator;
}

interface MSSymbolInstanceOverrideInspectorItemAllocator<InitializedType = MSSymbolInstanceOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<MSSymbolInstanceOverrideInspectorItem> {}
interface MSSymbolInstanceOverrideInspectorItem extends MSOverrideInspectorItem {

  labelField(): NSTextField;
  setLabelField(labelField: NSTextField): void;
  popupButton(): NSPopUpButton;
  setPopupButton(popupButton: NSPopUpButton): void;
}
declare const MSSymbolInstanceOverrideInspectorItem: {
  alloc(): MSSymbolInstanceOverrideInspectorItemAllocator;
}

interface MSSymbolInstanceSectionAllocator<InitializedType = MSSymbolInstanceSection> extends MSBaseInspectorSectionAllocator<MSSymbolInstanceSection> {}
interface MSSymbolInstanceSection extends MSBaseInspectorSection {
}
declare const MSSymbolInstanceSection: {
  alloc(): MSSymbolInstanceSectionAllocator;
}

interface MSSyncLibraryActionAllocator<InitializedType = MSSyncLibraryAction> extends MSDocumentActionAllocator<MSSyncLibraryAction> {}
interface MSSyncLibraryAction extends MSDocumentAction, IMSWindowBadgeAction {
}
declare const MSSyncLibraryAction: {
  alloc(): MSSyncLibraryActionAllocator;
}

interface MSBaseAlignActionAllocator<InitializedType = MSBaseAlignAction> extends MSDocumentActionAllocator<MSBaseAlignAction> {}
interface MSBaseAlignAction extends MSDocumentAction {
  textAlignment(): NSTextAlignment;
}
declare const MSBaseAlignAction: {
  alloc(): MSBaseAlignActionAllocator;
}

interface MSAlignLeftActionAllocator<InitializedType = MSAlignLeftAction> extends MSBaseAlignActionAllocator<MSAlignLeftAction> {}
interface MSAlignLeftAction extends MSBaseAlignAction {
}
declare const MSAlignLeftAction: {
  alloc(): MSAlignLeftActionAllocator;
}

interface MSAlignCenterActionAllocator<InitializedType = MSAlignCenterAction> extends MSBaseAlignActionAllocator<MSAlignCenterAction> {}
interface MSAlignCenterAction extends MSBaseAlignAction {
}
declare const MSAlignCenterAction: {
  alloc(): MSAlignCenterActionAllocator;
}

interface MSAlignRightActionAllocator<InitializedType = MSAlignRightAction> extends MSBaseAlignActionAllocator<MSAlignRightAction> {}
interface MSAlignRightAction extends MSBaseAlignAction {
}
declare const MSAlignRightAction: {
  alloc(): MSAlignRightActionAllocator;
}

interface MSAlignJustifiedActionAllocator<InitializedType = MSAlignJustifiedAction> extends MSBaseAlignActionAllocator<MSAlignJustifiedAction> {}
interface MSAlignJustifiedAction extends MSBaseAlignAction {
}
declare const MSAlignJustifiedAction: {
  alloc(): MSAlignJustifiedActionAllocator;
}

interface MSTextAlignTouchBarGroupActionAllocator<InitializedType = MSTextAlignTouchBarGroupAction> extends MSActionGroupAllocator<MSTextAlignTouchBarGroupAction> {}
interface MSTextAlignTouchBarGroupAction extends MSActionGroup {
}
declare const MSTextAlignTouchBarGroupAction: {
  alloc(): MSTextAlignTouchBarGroupActionAllocator;
}

interface MSTextLabelForUpDownFieldAllocator<InitializedType = MSTextLabelForUpDownField> extends NSTextFieldAllocator<MSTextLabelForUpDownField> {}
interface MSTextLabelForUpDownField extends NSTextField {

  upDownTextField(): NSTextField;
  setUpDownTextField(upDownTextField: NSTextField): void;
  textFields(): NSArray<any>;
  setTextFields(textFields: NSArray<any> | any[]): void;
}
declare const MSTextLabelForUpDownField: {
  alloc(): MSTextLabelForUpDownFieldAllocator;
}

interface MSTextLayerEventHandlerAllocator<InitializedType = MSTextLayerEventHandler> extends MSEventHandlerAllocator<MSTextLayerEventHandler> {}
interface MSTextLayerEventHandler extends MSEventHandler, INSTextViewDelegate, INSTextStorageDelegate, INSWindowDelegate, IMSTextLayerEditingDelegate, IMSTextLayerTextViewDelegate, IMSFirstLineTypesetterDelegate {
  applyTextTransform(textTransformValue: NSNumber | number | null): void;
  applyTextColor(color: MSColor): NSColor;
  updateTextViewStyling(): void;
  setListType(list: NSTextList): void;

  textView(): MSTextLayerTextView;
}
declare const MSTextLayerEventHandler: {
  alloc(): MSTextLayerEventHandlerAllocator;
}

interface MSTextLayerItemAllocator<InitializedType = MSTextLayerItem> extends MSInspectorItemAllocator<MSTextLayerItem> {}
interface MSTextLayerItem extends MSInspectorItem, INSMenuDelegate, IMSColorInspectorDelegate, INSComboBoxDataSource, IMSStylePartPreviewButtonDelegate {
  fontFamilyAction(sender: any): IBAction;
  fontWeightAction(sender: any): IBAction;
  fontSizeAction(sender: any): IBAction;
  showColorPickerAction(sender: any): IBAction;
  kerningAction(sender: any): IBAction;
  lineHeightAction(sender: any): IBAction;
  paragraphHeightAction(sender: any): IBAction;
  alignmentButtonAction(sender: any): IBAction;
  verticalAlignmentAction(sender: any): IBAction;
  showParagraphStylingAction(sender: any): IBAction;
  changeTextLayerFont(sender: any): IBAction;
  changeParagraphStyleInBlock(block: MSTextSectionParagraphEnumerator): void;
  changeFontPropertiesOfTextObjectsInBlock(block: MSTextSectionStringEnumerator): void;
  firstOccurrenceOfAttributeWithName(attributeName: NSString | string): any;
  textView(): MSTextLayerTextView;
  putFocusOnTextView(): void;

  missingFontsLabel(): NSTextField;
  setMissingFontsLabel(missingFontsLabel: NSTextField): void;
  fontWeightPopUpButton(): NSPopUpButton;
  setFontWeightPopUpButton(fontWeightPopUpButton: NSPopUpButton): void;
  fontSizeField(): NSComboBox;
  setFontSizeField(fontSizeField: NSComboBox): void;
  colorPickerButton(): MSStylePartPreviewButton;
  setColorPickerButton(colorPickerButton: MSStylePartPreviewButton): void;
  kerningField(): NSTextField;
  setKerningField(kerningField: NSTextField): void;
  lineHeightField(): MSUpDownTextField;
  setLineHeightField(lineHeightField: MSUpDownTextField): void;
  paragraphHeightField(): NSTextField;
  setParagraphHeightField(paragraphHeightField: NSTextField): void;
  alignmentButton(): NSSegmentedControl;
  setAlignmentButton(alignmentButton: NSSegmentedControl): void;
  verticalAlignmentButton(): NSSegmentedControl;
  setVerticalAlignmentButton(verticalAlignmentButton: NSSegmentedControl): void;
}
declare const MSTextLayerItem: {
  alloc(): MSTextLayerItemAllocator;
}

interface MSTextLayerTextViewAllocator<InitializedType = MSTextLayerTextView> extends NSTextViewAllocator<MSTextLayerTextView> {}
interface MSTextLayerTextView extends NSTextView {
  hideSelectionTemporarily(): void;
  selectSimilar(sender: any): IBAction;
  rectForSelectedRange(): NSRect;
  changeColorWithColor(color: NSColor): void;

  hangingGlyphView(): MSHangingGlyphView;
  setHangingGlyphView(hangingGlyphView: MSHangingGlyphView): void;
  textLayerTextViewDelegate(): any;
  setTextLayerTextViewDelegate(textLayerTextViewDelegate: any): void;
}
declare const MSTextLayerTextView: {
  alloc(): MSTextLayerTextViewAllocator;
}

interface IMSTextLayerTextViewDelegate {
  canvasColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
  documentColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
}

interface MSTextOnPathActionAllocator<InitializedType = MSTextOnPathAction> extends MSDocumentActionAllocator<MSTextOnPathAction> {}
interface MSTextOnPathAction extends MSDocumentAction {
  textOnPath(sender: any): IBAction;
}
declare const MSTextOnPathAction: {
  alloc(): MSTextOnPathActionAllocator;
}

interface MSTextOverrideInspectorItemAllocator<InitializedType = MSTextOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<MSTextOverrideInspectorItem> {}
interface MSTextOverrideInspectorItem extends MSOverrideInspectorItem {
}
declare const MSTextOverrideInspectorItem: {
  alloc(): MSTextOverrideInspectorItemAllocator;
}

interface MSTextStyleTouchBarActionAllocator<InitializedType = MSTextStyleTouchBarAction> extends MSDocumentActionAllocator<MSTextStyleTouchBarAction> {}
interface MSTextStyleTouchBarAction extends MSDocumentAction, INSTouchBarDelegate {
}
declare const MSTextStyleTouchBarAction: {
  alloc(): MSTextStyleTouchBarActionAllocator;
}

interface MSTextVerticalAlignmentActionAllocator<InitializedType = MSTextVerticalAlignmentAction> extends MSDocumentActionAllocator<MSTextVerticalAlignmentAction> {}
interface MSTextVerticalAlignmentAction extends MSDocumentAction {
  verticalAlignment(): MSTextStyleVerticalAlignment;
}
declare const MSTextVerticalAlignmentAction: {
  alloc(): MSTextVerticalAlignmentActionAllocator;
}

interface MSAlignTopActionAllocator<InitializedType = MSAlignTopAction> extends MSTextVerticalAlignmentActionAllocator<MSAlignTopAction> {}
interface MSAlignTopAction extends MSTextVerticalAlignmentAction {
  alignTop(sender: any): IBAction;
}
declare const MSAlignTopAction: {
  alloc(): MSAlignTopActionAllocator;
}

interface MSAlignBottomActionAllocator<InitializedType = MSAlignBottomAction> extends MSTextVerticalAlignmentActionAllocator<MSAlignBottomAction> {}
interface MSAlignBottomAction extends MSTextVerticalAlignmentAction {
  alignBottom(sender: any): IBAction;
}
declare const MSAlignBottomAction: {
  alloc(): MSAlignBottomActionAllocator;
}

interface MSAlignMiddleActionAllocator<InitializedType = MSAlignMiddleAction> extends MSTextVerticalAlignmentActionAllocator<MSAlignMiddleAction> {}
interface MSAlignMiddleAction extends MSTextVerticalAlignmentAction {
  alignMiddle(sender: any): IBAction;
}
declare const MSAlignMiddleAction: {
  alloc(): MSAlignMiddleActionAllocator;
}

interface MSTextWindowAllocator<InitializedType = MSTextWindow> extends NSWindowAllocator<MSTextWindow> {
  initWithRect(rect: NSRect): InitializedType;
}
interface MSTextWindow extends NSWindow {
  moveToRect_contentDrawViewRect_behaviour(textViewRect: NSRect, contentDrawViewRect: NSRect, behaviour: BCTextBehaviourType): void;
  addTextView_toView(textView: NSTextView, childView: NSView): void;

  contentDrawView(): MSContentDrawView;
  setContentDrawView(contentDrawView: MSContentDrawView): void;
  textView(): NSTextView;
}
declare const MSTextWindow: {
  alloc(): MSTextWindowAllocator;
}

interface MSTiledImageViewAllocator<InitializedType = MSTiledImageView> extends NSViewAllocator<MSTiledImageView> {}
interface MSTiledImageView extends NSView {

  image(): NSImage;
  setImage(image: NSImage): void;
}
declare const MSTiledImageView: {
  alloc(): MSTiledImageViewAllocator;
}

interface MSToggleBaseActionAllocator<InitializedType = MSToggleBaseAction> extends MSDocumentActionAllocator<MSToggleBaseAction> {}
interface MSToggleBaseAction extends MSDocumentAction {
}
declare const MSToggleBaseAction: {
  alloc(): MSToggleBaseActionAllocator;
}

interface MSToggleGridActionAllocator<InitializedType = MSToggleGridAction> extends MSToggleBaseActionAllocator<MSToggleGridAction> {}
interface MSToggleGridAction extends MSToggleBaseAction {
  toggleGrid(sender: any): IBAction;
}
declare const MSToggleGridAction: {
  alloc(): MSToggleGridActionAllocator;
}

interface MSToggleLayoutActionAllocator<InitializedType = MSToggleLayoutAction> extends MSToggleBaseActionAllocator<MSToggleLayoutAction> {}
interface MSToggleLayoutAction extends MSToggleBaseAction {
  toggleLayout(sender: any): IBAction;
}
declare const MSToggleLayoutAction: {
  alloc(): MSToggleLayoutActionAllocator;
}

interface MSHideAllGridsAndLayoutsActionAllocator<InitializedType = MSHideAllGridsAndLayoutsAction> extends MSDocumentActionAllocator<MSHideAllGridsAndLayoutsAction> {}
interface MSHideAllGridsAndLayoutsAction extends MSDocumentAction {
  hideAllGridsAndLayouts(sender: any): IBAction;
}
declare const MSHideAllGridsAndLayoutsAction: {
  alloc(): MSHideAllGridsAndLayoutsActionAllocator;
}

interface MSToggleStylePartActionAllocator<InitializedType = MSToggleStylePartAction> extends MSDocumentActionAllocator<MSToggleStylePartAction> {}
interface MSToggleStylePartAction extends MSDocumentAction {
}
declare const MSToggleStylePartAction: {
  alloc(): MSToggleStylePartActionAllocator;
}

interface MSToggleFillActionAllocator<InitializedType = MSToggleFillAction> extends MSToggleStylePartActionAllocator<MSToggleFillAction> {}
interface MSToggleFillAction extends MSToggleStylePartAction {
}
declare const MSToggleFillAction: {
  alloc(): MSToggleFillActionAllocator;
}

interface MSToggleBorderActionAllocator<InitializedType = MSToggleBorderAction> extends MSToggleStylePartActionAllocator<MSToggleBorderAction> {}
interface MSToggleBorderAction extends MSToggleStylePartAction {
}
declare const MSToggleBorderAction: {
  alloc(): MSToggleBorderActionAllocator;
}

interface MSToggleFixToViewportActionAllocator<InitializedType = MSToggleFixToViewportAction> extends MSDocumentActionAllocator<MSToggleFixToViewportAction> {}
interface MSToggleFixToViewportAction extends MSDocumentAction {
  toggleFixToViewport(sender: any): IBAction;

  state(): NSCellStateValue;
}
declare const MSToggleFixToViewportAction: {
  alloc(): MSToggleFixToViewportActionAllocator;
}

interface MSToggleInspectorVisibilityActionAllocator<InitializedType = MSToggleInspectorVisibilityAction> extends MSToggleVisibilityActionAllocator<MSToggleInspectorVisibilityAction> {}
interface MSToggleInspectorVisibilityAction extends MSToggleVisibilityAction {
  toggleInspectorVisibility(sender: any): IBAction;
}
declare const MSToggleInspectorVisibilityAction: {
  alloc(): MSToggleInspectorVisibilityActionAllocator;
}

interface MSToggleInterfaceActionAllocator<InitializedType = MSToggleInterfaceAction> extends MSDocumentActionAllocator<MSToggleInterfaceAction> {}
interface MSToggleInterfaceAction extends MSDocumentAction {
  toggleHideInterface(sender: any): IBAction;
  documentWillClose(): void;
}
declare const MSToggleInterfaceAction: {
  alloc(): MSToggleInterfaceActionAllocator;
}

interface MSToggleLayerListVisibilityActionAllocator<InitializedType = MSToggleLayerListVisibilityAction> extends MSToggleVisibilityActionAllocator<MSToggleLayerListVisibilityAction> {}
interface MSToggleLayerListVisibilityAction extends MSToggleVisibilityAction {
  toggleLayerListVisibility(sender: any): IBAction;
}
declare const MSToggleLayerListVisibilityAction: {
  alloc(): MSToggleLayerListVisibilityActionAllocator;
}

interface MSToggleResizeButtonCellAllocator<InitializedType = MSToggleResizeButtonCell> extends NSButtonCellAllocator<MSToggleResizeButtonCell> {}
interface MSToggleResizeButtonCell extends NSButtonCell {
}
declare const MSToggleResizeButtonCell: {
  alloc(): MSToggleResizeButtonCellAllocator;
}

interface MSToggleRulersActionAllocator<InitializedType = MSToggleRulersAction> extends MSToggleVisibilityActionAllocator<MSToggleRulersAction> {}
interface MSToggleRulersAction extends MSToggleVisibilityAction {
  toggleRulers(sender: any): IBAction;
}
declare const MSToggleRulersAction: {
  alloc(): MSToggleRulersActionAllocator;
}

interface MSToggleToolbarVisibilityActionAllocator<InitializedType = MSToggleToolbarVisibilityAction> extends MSToggleVisibilityActionAllocator<MSToggleToolbarVisibilityAction> {}
interface MSToggleToolbarVisibilityAction extends MSToggleVisibilityAction {
  toggleToolbarVisibility(sender: any): IBAction;
}
declare const MSToggleToolbarVisibilityAction: {
  alloc(): MSToggleToolbarVisibilityActionAllocator;
}

interface MSToggleViewPreferenceActionAllocator<InitializedType = MSToggleViewPreferenceAction> extends MSDocumentActionAllocator<MSToggleViewPreferenceAction> {}
interface MSToggleViewPreferenceAction extends MSDocumentAction {
  preferenceKey(): NSString;
}
declare const MSToggleViewPreferenceAction: {
  alloc(): MSToggleViewPreferenceActionAllocator;
}

interface MSToggleArtboardShadowActionAllocator<InitializedType = MSToggleArtboardShadowAction> extends MSToggleViewPreferenceActionAllocator<MSToggleArtboardShadowAction> {}
interface MSToggleArtboardShadowAction extends MSToggleViewPreferenceAction {
  toggleArtboardShadow(sender: any): IBAction;
}
declare const MSToggleArtboardShadowAction: {
  alloc(): MSToggleArtboardShadowActionAllocator;
}

interface MSToggleAlignmentGuidesActionAllocator<InitializedType = MSToggleAlignmentGuidesAction> extends MSToggleViewPreferenceActionAllocator<MSToggleAlignmentGuidesAction> {}
interface MSToggleAlignmentGuidesAction extends MSToggleViewPreferenceAction {
  toggleAlignmentGuides(sender: any): IBAction;
}
declare const MSToggleAlignmentGuidesAction: {
  alloc(): MSToggleAlignmentGuidesActionAllocator;
}

interface MSTogglePixelLinesActionAllocator<InitializedType = MSTogglePixelLinesAction> extends MSToggleViewPreferenceActionAllocator<MSTogglePixelLinesAction> {}
interface MSTogglePixelLinesAction extends MSToggleViewPreferenceAction {
  togglePixelLines(sender: any): IBAction;
}
declare const MSTogglePixelLinesAction: {
  alloc(): MSTogglePixelLinesActionAllocator;
}

interface MSToggleSelectionActionAllocator<InitializedType = MSToggleSelectionAction> extends MSToggleViewPreferenceActionAllocator<MSToggleSelectionAction> {}
interface MSToggleSelectionAction extends MSToggleViewPreferenceAction {
  toggleSelection(sender: any): IBAction;
}
declare const MSToggleSelectionAction: {
  alloc(): MSToggleSelectionActionAllocator;
}

interface MSToggleLayerHighlightActionAllocator<InitializedType = MSToggleLayerHighlightAction> extends MSToggleViewPreferenceActionAllocator<MSToggleLayerHighlightAction> {}
interface MSToggleLayerHighlightAction extends MSToggleViewPreferenceAction {
  toggleLayerHighlight(sender: any): IBAction;
}
declare const MSToggleLayerHighlightAction: {
  alloc(): MSToggleLayerHighlightActionAllocator;
}

interface MSToggleSliceInteractionActionAllocator<InitializedType = MSToggleSliceInteractionAction> extends MSToggleViewPreferenceActionAllocator<MSToggleSliceInteractionAction> {}
interface MSToggleSliceInteractionAction extends MSToggleViewPreferenceAction {
  toggleSliceInteraction(sender: any): IBAction;
}
declare const MSToggleSliceInteractionAction: {
  alloc(): MSToggleSliceInteractionActionAllocator;
}

interface MSToggleFlowInteractionActionAllocator<InitializedType = MSToggleFlowInteractionAction> extends MSToggleViewPreferenceActionAllocator<MSToggleFlowInteractionAction> {}
interface MSToggleFlowInteractionAction extends MSToggleViewPreferenceAction {
  toggleFlowInteraction(sender: any): IBAction;
}
declare const MSToggleFlowInteractionAction: {
  alloc(): MSToggleFlowInteractionActionAllocator;
}

interface MSToggleVisibilityActionAllocator<InitializedType = MSToggleVisibilityAction> extends MSDocumentActionAllocator<MSToggleVisibilityAction> {}
interface MSToggleVisibilityAction extends MSDocumentAction {
  show(): void;
  hide(): void;
  defaultsKey(): NSString;
  prepareForNewWindow(): void;

  isActive(): boolean;
}
declare const MSToggleVisibilityAction: {
  alloc(): MSToggleVisibilityActionAllocator;
}

interface MSToolbarConstructorAllocator<InitializedType = MSToolbarConstructor> extends NSObjectAllocator<MSToolbarConstructor> {
  initWithDocument(document: MSDocument): InitializedType;
}
interface MSToolbarConstructor extends NSObject, INSToolbarDelegate {
  constructToolbarForWindow(window: NSWindow): void;
  validateToolbarItems(): void;

  doc(): MSDocument;
  setDoc(doc: MSDocument): void;
}
declare const MSToolbarConstructor: {
  alloc(): MSToolbarConstructorAllocator;  toolbarAllowedItemIdentifiers(): NSArray<any>;
  toolbarForDocument(document: MSDocument): any;

}

interface MSToolbarAllocator<InitializedType = MSToolbar> extends NSToolbarAllocator<MSToolbar> {}
interface MSToolbar extends NSToolbar {
}
declare const MSToolbar: {
  alloc(): MSToolbarAllocator;
}

interface MSToolbarPopoverContentViewControllerAllocator<InitializedType = MSToolbarPopoverContentViewController> extends NSViewControllerAllocator<MSToolbarPopoverContentViewController> {
  initWithAction(action: MSPopoverAction): InitializedType;
}
interface MSToolbarPopoverContentViewController extends NSViewController {
  newActionButtonWithTitle_action(title: NSString | string, selector: string): NSButton;
  newLabel(): NSTextField;
  animateFrameWithCompletionHandler(handler: Block): void;

  action(): MSPopoverAction;
  edgeInsets(): NSEdgeInsets;
  stackView(): NSStackView;
  imageView(): NSImageView;
  titleLabel(): NSTextField;
  descriptionLabel(): NSTextField;
  actionView(): NSView;
  footerLabel(): NSTextField;
}
declare const MSToolbarPopoverContentViewController: {
  alloc(): MSToolbarPopoverContentViewControllerAllocator;
}

interface MSTransformEventHandlerAllocator<InitializedType = MSTransformEventHandler> extends MSPointsEventHandlerAllocator<MSTransformEventHandler> {}
interface MSTransformEventHandler extends MSPointsEventHandler {
  transformLayers(): void;

  originalRect(): NSRect;
  setOriginalRect(originalRect: NSRect): void;
}
declare const MSTransformEventHandler: {
  alloc(): MSTransformEventHandlerAllocator;
}

declare enum MSTransformDirectionLock {
  MSTransformDirectionLockNone = 0,
  MSTransformDirectionLockX = 1,
  MSTransformDirectionLockY = 2,
}

interface MSTwoTextFieldInspectorItemAllocator<InitializedType = MSTwoTextFieldInspectorItem> extends MSInspectorItemAllocator<MSTwoTextFieldInspectorItem> {
  initWithTitle_field1Label_field2Label(title: NSString | string, field1: NSString | string, field2: NSString | string): InitializedType;
  initWithTitle_field1Label_field2Label_nibName(title: NSString | string, field1: NSString | string, field2: NSString | string, nibName: NSString | string): InitializedType;
}
interface MSTwoTextFieldInspectorItem extends MSInspectorItem {

  itemLabel(): NSTextField;
  setItemLabel(itemLabel: NSTextField): void;
  textField1(): MSInlineUpDownTextField;
  setTextField1(textField1: MSInlineUpDownTextField): void;
  textField2(): MSInlineUpDownTextField;
  setTextField2(textField2: MSInlineUpDownTextField): void;
  interTextFieldButton(): NSButton;
  setInterTextFieldButton(interTextFieldButton: NSButton): void;
}
declare const MSTwoTextFieldInspectorItem: {
  alloc(): MSTwoTextFieldInspectorItemAllocator;
}

interface MSUnavailableUpdatesWindowControllerAllocator<InitializedType = MSUnavailableUpdatesWindowController> extends NSWindowControllerAllocator<MSUnavailableUpdatesWindowController> {}
interface MSUnavailableUpdatesWindowController extends NSWindowController, INSWindowDelegate {
}
declare const MSUnavailableUpdatesWindowController: {
  alloc(): MSUnavailableUpdatesWindowControllerAllocator;  showModalWithVersion_buildNumber_reason(version: NSString | string, buildNumber: NSString | string, reason: MSUnavailableUpdatesReason): void;

}

declare enum MSUnavailableUpdatesReason {
  MSUnavailableUpdatesRenewalRequired,
  MSUnavailableUpdatesMacOSUpdateRequired,
  MSUnavailableUpdatesRenewalAndMacOSUpdateRequired,
}

interface MSUnderlineActionAllocator<InitializedType = MSUnderlineAction> extends MSDocumentActionAllocator<MSUnderlineAction> {}
interface MSUnderlineAction extends MSDocumentAction {
}
declare const MSUnderlineAction: {
  alloc(): MSUnderlineActionAllocator;
}

interface MSUndoBaseActionAllocator<InitializedType = MSUndoBaseAction> extends MSDocumentActionAllocator<MSUndoBaseAction> {}
interface MSUndoBaseAction extends MSDocumentAction {
}
declare const MSUndoBaseAction: {
  alloc(): MSUndoBaseActionAllocator;
}

interface MSUndoActionAllocator<InitializedType = MSUndoAction> extends MSUndoBaseActionAllocator<MSUndoAction> {}
interface MSUndoAction extends MSUndoBaseAction {
  undo(sender: any): IBAction;
}
declare const MSUndoAction: {
  alloc(): MSUndoActionAllocator;
}

interface MSRedoActionAllocator<InitializedType = MSRedoAction> extends MSUndoBaseActionAllocator<MSRedoAction> {}
interface MSRedoAction extends MSUndoBaseAction {
  redo(sender: any): IBAction;
}
declare const MSRedoAction: {
  alloc(): MSRedoActionAllocator;
}

interface MSUnlinkAndOrSyncActionAllocator<InitializedType = MSUnlinkAndOrSyncAction> extends MSBaseSharedObjectActionAllocator<MSUnlinkAndOrSyncAction> {}
interface MSUnlinkAndOrSyncAction extends MSBaseSharedObjectAction {
}
declare const MSUnlinkAndOrSyncAction: {
  alloc(): MSUnlinkAndOrSyncActionAllocator;
}

interface MSSyncLocalStyleActionAllocator<InitializedType = MSSyncLocalStyleAction> extends MSUnlinkAndOrSyncActionAllocator<MSSyncLocalStyleAction> {}
interface MSSyncLocalStyleAction extends MSUnlinkAndOrSyncAction {
  syncLocalSharedStyle(sender: any): IBAction;
}
declare const MSSyncLocalStyleAction: {
  alloc(): MSSyncLocalStyleActionAllocator;
}

interface MSUnlinkFromLibraryActionAllocator<InitializedType = MSUnlinkFromLibraryAction> extends MSUnlinkAndOrSyncActionAllocator<MSUnlinkFromLibraryAction> {}
interface MSUnlinkFromLibraryAction extends MSUnlinkAndOrSyncAction {
  unlinkFromLibrary(sender: any): IBAction;
}
declare const MSUnlinkFromLibraryAction: {
  alloc(): MSUnlinkFromLibraryActionAllocator;
}

interface MSUnlinkAndSyncFromLibraryActionAllocator<InitializedType = MSUnlinkAndSyncFromLibraryAction> extends MSUnlinkAndOrSyncActionAllocator<MSUnlinkAndSyncFromLibraryAction> {}
interface MSUnlinkAndSyncFromLibraryAction extends MSUnlinkAndOrSyncAction {
  unlinkAndSyncFromLibrary(sender: any): IBAction;
}
declare const MSUnlinkAndSyncFromLibraryAction: {
  alloc(): MSUnlinkAndSyncFromLibraryActionAllocator;
}

interface MSUpDownControllerAllocator<InitializedType = MSUpDownController> extends NSResponderAllocator<MSUpDownController> {
  initWithTextField_createStepper(field: NSTextField, makeStepper: boolean): InitializedType;
}
interface MSUpDownController extends NSResponder {
  becomeFirstResponder(): boolean;
  textDidEndEditing(): void;
  textDidChange(note: NSNotification): void;
  doCommandBySelector(selector: string): boolean;
  cancelTextEditingForInvalidReplacementString(replacementStrings: NSArray<any> | any[]): boolean;
  keyUp(): void;
  increment(): void;
  decrement(): void;
  floatValue(): number;
  incrementBy(amount: CGFloat): void;
  incrementValueAccountingForModifierFlags(): CGFloat;
  hideStepper(hide: boolean): void;

  incrementDecrementDelegate(): any;
  setIncrementDecrementDelegate(incrementDecrementDelegate: any): void;
  textField(): NSTextField;
}
declare const MSUpDownController: {
  alloc(): MSUpDownControllerAllocator;
}

interface IMSUpDownTextFieldDelegate {
  refreshAction(sender: any): void;
  valueForUpDownTextField(upDownTextField: NSTextField): CGFloat;
}

interface IMSUpDownProtocol {
  incrementValue(): CGFloat;
  minimum(): NSNumber;
  maximum(): NSNumber;

  upDownController(): MSUpDownController;
}

interface MSUpDownTextFieldAllocator<InitializedType = MSUpDownTextField> extends NSTextFieldAllocator<MSUpDownTextField> {}
interface MSUpDownTextField extends NSTextField, INSTextViewDelegate, IMSUpDownProtocol, INSTouchBarDelegate {
  connectToValueAdapter(valueAdaptor: MSMathInspectorValueAdaptor): void;
  connectToValueAdapter_bindingOptions(valueAdaptor: MSMathInspectorValueAdaptor, bindingOptions: NSDictionary<any, any> | {[key: string]: any}): void;
  incrementValue(): CGFloat;

  refreshDelegate(): any;
  setRefreshDelegate(refreshDelegate: any): void;
  upDownController(): MSUpDownController;
}
declare const MSUpDownTextField: {
  alloc(): MSUpDownTextFieldAllocator;
}

interface MSUpDownMiniTextFieldAllocator<InitializedType = MSUpDownMiniTextField> extends MSUpDownTextFieldAllocator<MSUpDownMiniTextField> {}
interface MSUpDownMiniTextField extends MSUpDownTextField {
}
declare const MSUpDownMiniTextField: {
  alloc(): MSUpDownMiniTextFieldAllocator;
}

interface MSUpDownNanoTextFieldAllocator<InitializedType = MSUpDownNanoTextField> extends MSUpDownTextFieldAllocator<MSUpDownNanoTextField> {}
interface MSUpDownNanoTextField extends MSUpDownTextField {
}
declare const MSUpDownNanoTextField: {
  alloc(): MSUpDownNanoTextFieldAllocator;
}

interface MSUpdateControllerAllocator<InitializedType = MSUpdateController> extends NSObjectAllocator<MSUpdateController> {}
interface MSUpdateController extends NSObject {
  checkNormally(): void;
  checkSilently(): void;
  checkQuietly(): void;
  commandEnabled(): boolean;
  commandLabel(): NSString;

  unavailableUpdateCount(): NSUInteger;
  setUnavailableUpdateCount(unavailableUpdateCount: NSUInteger): void;
  hasAvailableUpdates(): boolean;
  setHasAvailableUpdates(hasAvailableUpdates: boolean): void;
}
declare const MSUpdateController: {
  alloc(): MSUpdateControllerAllocator;
}

interface MSUpdatePluginsActionAllocator<InitializedType = MSUpdatePluginsAction> extends MSDocumentActionAllocator<MSUpdatePluginsAction> {}
interface MSUpdatePluginsAction extends MSDocumentAction, IMSWindowBadgeAction {
}
declare const MSUpdatePluginsAction: {
  alloc(): MSUpdatePluginsActionAllocator;
}

interface MSToolsMenuActionAllocator<InitializedType = MSToolsMenuAction> extends MSDocumentActionAllocator<MSToolsMenuAction> {}
interface MSToolsMenuAction extends MSDocumentAction {
}
declare const MSToolsMenuAction: {
  alloc(): MSToolsMenuActionAllocator;
}

interface MSTransformActionAllocator<InitializedType = MSTransformAction> extends MSEventHandlerActionAllocator<MSTransformAction> {}
interface MSTransformAction extends MSEventHandlerAction {
  transform(sender: any): IBAction;
}
declare const MSTransformAction: {
  alloc(): MSTransformActionAllocator;
}

interface MSScissorsActionAllocator<InitializedType = MSScissorsAction> extends MSEventHandlerActionAllocator<MSScissorsAction> {}
interface MSScissorsAction extends MSEventHandlerAction {
  scissors(sender: any): IBAction;
}
declare const MSScissorsAction: {
  alloc(): MSScissorsActionAllocator;
}

interface MSVectorCanvasAllocator<InitializedType = MSVectorCanvas> extends NSObjectAllocator<MSVectorCanvas> {}
interface MSVectorCanvas extends NSObject {
  registerWithEventHandler(handler: MSShapeEventHandler): void;
  didChangeAllowSelectionOnly(): void;
  selectHandleAtIndexPath_extendSelection(handle: NSIndexPath, extendSelection: boolean): void;
  selectHandlesAtIndexPaths(indexPaths: NSArray<any> | any[]): void;
  deselectHandleAtIndexPath(handle: NSIndexPath): void;
  drawHairline(): void;
  drawWire(): void;
  drawSnaps(): void;
  drawHighlightedSegment(): void;
  drawInsertionPoint(): void;
  drawHandles(): void;
  changeToCurveMode(curveMode: MSCurveMode): void;
  delete(sender: any): IBAction;
  alignVectorPointsToKey(key: NSString | string): void;
  distributeVectorPointsToAxis(axis: BCAxis): void;
  adjustHandlesToValue_onAxis(value: CGFloat, axis: BCAxis): void;
  adjustHandle_toValue_onAxis(handle: NSIndexPath, value: CGFloat, axis: BCAxis): void;
  singleMouseDownAtPoint_modifierFlags(location: NSPoint, flags: NSEventModifierFlags): void;
  doubleMouseDownAtPoint_modifierFlags(location: NSPoint, flags: NSEventModifierFlags): void;
  mouseUpAtPoint(location: NSPoint): void;
  trackMouse(sender: MSMouseTracker): void;
  flagsChanged(event: NSEvent): void;
  updateCursor(): void;
  setNeedsUpdateCursor(): void;

  eventHandler(): MSShapeEventHandler;
  view(): MSContentDrawView;
  setView(view: MSContentDrawView): void;
  pathController(): MSPathController;
  setPathController(pathController: MSPathController): void;
  selectedLayers(): NSArray<any>;
  setSelectedLayers(selectedLayers: NSArray<any> | any[]): void;
  visibleLayers(): NSArray<any>;
  editingBehavior(): MSShapeEditingBehavior;
  setEditingBehavior(editingBehavior: MSShapeEditingBehavior): void;
  indexPathsForSelectedHandles(): NSArray<any>;
  indexPathForHighlightedComponent(): NSIndexPath;
  interactivelySelecting(): boolean;
  snaps(): MSAlignmentEngineResult;
  setSnaps(snaps: MSAlignmentEngineResult): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}
declare const MSVectorCanvas: {
  alloc(): MSVectorCanvasAllocator;
}

interface IMSVectorCanvasDelegate {
  vectorCanvas_didHighlightHandleAtIndexPath(canvas: MSVectorCanvas, indexPath: NSIndexPath): void;
  vectorCanvas_didUnhighlightHandleAtIndexPath(canvas: MSVectorCanvas, indexPath: NSIndexPath): void;
  vectorCanvas_didSelectHandlesAtIndexPaths(canvas: MSVectorCanvas, indexPaths: NSArray<any> | any[]): void;
  vectorCanvas_didDeselectHandlesAtIndexPaths(canvas: MSVectorCanvas, indexPaths: NSArray<any> | any[]): void;
  vectorCanvasDidFinishInteractiveSelection(canvas: MSVectorCanvas): void;
  vectorCanvas_didSelectLayers(canvas: MSVectorCanvas, layers: NSArray<any> | any[]): void;
  vectorCanvasDidEditPoints(canvas: MSVectorCanvas): void;
}

interface MSVectorHandleAllocator<InitializedType = MSVectorHandle> extends NSObjectAllocator<MSVectorHandle> {}
interface MSVectorHandle extends NSObject {
  drawAtProposedPoint_inView(proposedPoint: NSPoint, canvasView: NSView): void;
  drawingSize(): NSSize;

  state(): MSHandleState;
  setState(state: MSHandleState): void;
}
declare const MSVectorHandle: {
  alloc(): MSVectorHandleAllocator;
}

interface MSVectorAdjustmentHandleAllocator<InitializedType = MSVectorAdjustmentHandle> extends MSVectorHandleAllocator<MSVectorAdjustmentHandle> {}
interface MSVectorAdjustmentHandle extends MSVectorHandle {

  locationOfMainPoint(): NSPoint;
  setLocationOfMainPoint(locationOfMainPoint: NSPoint): void;
}
declare const MSVectorAdjustmentHandle: {
  alloc(): MSVectorAdjustmentHandleAllocator;
}

interface MSVerticalRulerViewAllocator<InitializedType = MSVerticalRulerView> extends MSRulerViewAllocator<MSVerticalRulerView> {}
interface MSVerticalRulerView extends MSRulerView {
}
declare const MSVerticalRulerView: {
  alloc(): MSVerticalRulerViewAllocator;
}

interface MSVerticalRulerViewLayerAllocator<InitializedType = MSVerticalRulerViewLayer> extends MSRulerViewLayerAllocator<MSVerticalRulerViewLayer> {}
interface MSVerticalRulerViewLayer extends MSRulerViewLayer {
}
declare const MSVerticalRulerViewLayer: {
  alloc(): MSVerticalRulerViewLayerAllocator;
}

interface MSVerticallyCenteredTextFieldCellAllocator<InitializedType = MSVerticallyCenteredTextFieldCell> extends NSTextFieldCellAllocator<MSVerticallyCenteredTextFieldCell> {}
interface MSVerticallyCenteredTextFieldCell extends NSTextFieldCell {
}
declare const MSVerticallyCenteredTextFieldCell: {
  alloc(): MSVerticallyCenteredTextFieldCellAllocator;
}

interface MSViewMenuActionAllocator<InitializedType = MSViewMenuAction> extends MSDocumentActionAllocator<MSViewMenuAction> {}
interface MSViewMenuAction extends MSDocumentAction {
}
declare const MSViewMenuAction: {
  alloc(): MSViewMenuActionAllocator;
}

interface MSTogglePixelGridActionAllocator<InitializedType = MSTogglePixelGridAction> extends MSDocumentActionAllocator<MSTogglePixelGridAction> {}
interface MSTogglePixelGridAction extends MSDocumentAction {
  togglePixelGrid(sender: any): IBAction;
}
declare const MSTogglePixelGridAction: {
  alloc(): MSTogglePixelGridActionAllocator;
}

interface MSVisitDocumentationActionAllocator<InitializedType = MSVisitDocumentationAction> extends MSActionAllocator<MSVisitDocumentationAction> {}
interface MSVisitDocumentationAction extends MSAction {
  visitDocumentation(sender: any): IBAction;
}
declare const MSVisitDocumentationAction: {
  alloc(): MSVisitDocumentationActionAllocator;
}

interface MSWelcomeCollectionImageViewAllocator<InitializedType = MSWelcomeCollectionImageView> extends NSImageViewAllocator<MSWelcomeCollectionImageView> {}
interface MSWelcomeCollectionImageView extends NSImageView {

  doubleClickAction(): string;
  setDoubleClickAction(doubleClickAction: string): void;
  imageInterpolation(): NSImageInterpolation;
  setImageInterpolation(imageInterpolation: NSImageInterpolation): void;
  selected(): boolean;
  setSelected(selected: boolean): void;
}
declare const MSWelcomeCollectionImageView: {
  alloc(): MSWelcomeCollectionImageViewAllocator;
}

interface MSWelcomeCollectionImageCellAllocator<InitializedType = MSWelcomeCollectionImageCell> extends NSImageCellAllocator<MSWelcomeCollectionImageCell> {}
interface MSWelcomeCollectionImageCell extends NSImageCell {
}
declare const MSWelcomeCollectionImageCell: {
  alloc(): MSWelcomeCollectionImageCellAllocator;
}

interface MSWelcomeCollectionItemAllocator<InitializedType = MSWelcomeCollectionItem> extends NSObjectAllocator<MSWelcomeCollectionItem> {
  initWithController(controller: MSWelcomeWindowController): InitializedType;
}
interface MSWelcomeCollectionItem extends NSObject, IMSWelcomeCollectionItemPreviewImageLoading {

  placeholderImage(): NSImage;
  title(): NSString;
  welcomeWindowController(): MSWelcomeWindowController;
  setWelcomeWindowController(welcomeWindowController: MSWelcomeWindowController): void;
}
declare const MSWelcomeCollectionItem: {
  alloc(): MSWelcomeCollectionItemAllocator;  bundledTemplatesDirectoryURL(): NSURL;
  userTemplatesDirectoryURL(): NSURL;

}

interface MSExistingDocumentCollectionItemAllocator<InitializedType = MSExistingDocumentCollectionItem> extends MSWelcomeCollectionItemAllocator<MSExistingDocumentCollectionItem> {
  initWithController_URL(controller: MSWelcomeWindowController, URL: NSURL): InitializedType;
}
interface MSExistingDocumentCollectionItem extends MSWelcomeCollectionItem {

  URL(): NSURL;
}
declare const MSExistingDocumentCollectionItem: {
  alloc(): MSExistingDocumentCollectionItemAllocator;
}

interface MSNewDocumentCollectionItemAllocator<InitializedType = MSNewDocumentCollectionItem> extends MSWelcomeCollectionItemAllocator<MSNewDocumentCollectionItem> {}
interface MSNewDocumentCollectionItem extends MSWelcomeCollectionItem {
}
declare const MSNewDocumentCollectionItem: {
  alloc(): MSNewDocumentCollectionItemAllocator;
}

interface IMSWelcomeCollectionItemPreviewImageLoading {
  fetchPreviewImageWithMaximumPixelSize_completionHandler(maxPixelSize: CGFloat, handler: MSPreviewImageHandler): void;

  providesPreviewImage(): boolean;
  URL(): NSURL;
}

interface MSWelcomeCollectionTextFieldAllocator<InitializedType = MSWelcomeCollectionTextField> extends NSTextFieldAllocator<MSWelcomeCollectionTextField> {}
interface MSWelcomeCollectionTextField extends NSTextField {

  selected(): boolean;
  setSelected(selected: boolean): void;
}
declare const MSWelcomeCollectionTextField: {
  alloc(): MSWelcomeCollectionTextFieldAllocator;
}

interface MSWelcomeCollectionTextFieldCellAllocator<InitializedType = MSWelcomeCollectionTextFieldCell> extends NSTextFieldCellAllocator<MSWelcomeCollectionTextFieldCell> {}
interface MSWelcomeCollectionTextFieldCell extends NSTextFieldCell {
}
declare const MSWelcomeCollectionTextFieldCell: {
  alloc(): MSWelcomeCollectionTextFieldCellAllocator;
}

interface MSWelcomeCollectionViewAllocator<InitializedType = MSWelcomeCollectionView> extends NSCollectionViewAllocator<MSWelcomeCollectionView> {}
interface MSWelcomeCollectionView extends NSCollectionView {
}
declare const MSWelcomeCollectionView: {
  alloc(): MSWelcomeCollectionViewAllocator;
}

interface IMSWelcomeCollectionViewDelegate {
  collectionView_newItemForRepresentedObject(collectionView: NSCollectionView, object: any): NSCollectionViewItem;
}

interface MSWelcomeCollectionViewItemAllocator<InitializedType = MSWelcomeCollectionViewItem> extends NSCollectionViewItemAllocator<MSWelcomeCollectionViewItem> {}
interface MSWelcomeCollectionViewItem extends NSCollectionViewItem, INSMenuDelegate {

  collectionItem(): MSWelcomeCollectionItem;
}
declare const MSWelcomeCollectionViewItem: {
  alloc(): MSWelcomeCollectionViewItemAllocator;
}

interface MSWelcomeColorStripViewAllocator<InitializedType = MSWelcomeColorStripView> extends NSViewAllocator<MSWelcomeColorStripView> {}
interface MSWelcomeColorStripView extends NSView {
}
declare const MSWelcomeColorStripView: {
  alloc(): MSWelcomeColorStripViewAllocator;
}

interface MSWelcomeProgressViewAllocator<InitializedType = MSWelcomeProgressView> extends NSViewAllocator<MSWelcomeProgressView> {}
interface MSWelcomeProgressView extends NSView {

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  collectionItem(): MSCloudShareCollectionItem;
  setCollectionItem(collectionItem: MSCloudShareCollectionItem): void;
}
declare const MSWelcomeProgressView: {
  alloc(): MSWelcomeProgressViewAllocator;
}

interface MSWelcomeToSketchActionAllocator<InitializedType = MSWelcomeToSketchAction> extends MSActionAllocator<MSWelcomeToSketchAction> {}
interface MSWelcomeToSketchAction extends MSAction {
  welcomeToSketch(sender: any): IBAction;
}
declare const MSWelcomeToSketchAction: {
  alloc(): MSWelcomeToSketchActionAllocator;
}

interface MSWelcomeBackgroundViewAllocator<InitializedType = MSWelcomeBackgroundView> extends NSViewAllocator<MSWelcomeBackgroundView> {}
interface MSWelcomeBackgroundView extends NSView {
}
declare const MSWelcomeBackgroundView: {
  alloc(): MSWelcomeBackgroundViewAllocator;
}

interface MSWelcomeTopFadeViewAllocator<InitializedType = MSWelcomeTopFadeView> extends NSViewAllocator<MSWelcomeTopFadeView> {}
interface MSWelcomeTopFadeView extends NSView {
}
declare const MSWelcomeTopFadeView: {
  alloc(): MSWelcomeTopFadeViewAllocator;
}

interface MSWelcomeControlContainerViewAllocator<InitializedType = MSWelcomeControlContainerView> extends NSViewAllocator<MSWelcomeControlContainerView> {}
interface MSWelcomeControlContainerView extends NSView {
}
declare const MSWelcomeControlContainerView: {
  alloc(): MSWelcomeControlContainerViewAllocator;
}

interface MSWelcomeBottomFadeViewAllocator<InitializedType = MSWelcomeBottomFadeView> extends MSWelcomeTopFadeViewAllocator<MSWelcomeBottomFadeView> {}
interface MSWelcomeBottomFadeView extends MSWelcomeTopFadeView {
}
declare const MSWelcomeBottomFadeView: {
  alloc(): MSWelcomeBottomFadeViewAllocator;
}

interface MSWelcomeDebugViewAllocator<InitializedType = MSWelcomeDebugView> extends NSViewAllocator<MSWelcomeDebugView> {}
interface MSWelcomeDebugView extends NSView {
}
declare const MSWelcomeDebugView: {
  alloc(): MSWelcomeDebugViewAllocator;
}

interface MSWelcomeWindowAllocator<InitializedType = MSWelcomeWindow> extends NSWindowAllocator<MSWelcomeWindow> {}
interface MSWelcomeWindow extends NSWindow {
}
declare const MSWelcomeWindow: {
  alloc(): MSWelcomeWindowAllocator;
}

interface MSWelcomeWindowButtonCellAllocator<InitializedType = MSWelcomeWindowButtonCell> extends MSHoverButtonCellAllocator<MSWelcomeWindowButtonCell> {}
interface MSWelcomeWindowButtonCell extends MSHoverButtonCell {
}
declare const MSWelcomeWindowButtonCell: {
  alloc(): MSWelcomeWindowButtonCellAllocator;
}

interface MSWelcomeWindowBigButtonAllocator<InitializedType = MSWelcomeWindowBigButton> extends MSHoverButtonAllocator<MSWelcomeWindowBigButton> {}
interface MSWelcomeWindowBigButton extends MSHoverButton {
}
declare const MSWelcomeWindowBigButton: {
  alloc(): MSWelcomeWindowBigButtonAllocator;
}

interface MSWelcomeWindowBigButtonCellAllocator<InitializedType = MSWelcomeWindowBigButtonCell> extends MSHoverButtonCellAllocator<MSWelcomeWindowBigButtonCell> {}
interface MSWelcomeWindowBigButtonCell extends MSHoverButtonCell {
}
declare const MSWelcomeWindowBigButtonCell: {
  alloc(): MSWelcomeWindowBigButtonCellAllocator;
}

interface MSWelcomeWindowPlayButtonCellAllocator<InitializedType = MSWelcomeWindowPlayButtonCell> extends MSHoverButtonCellAllocator<MSWelcomeWindowPlayButtonCell> {}
interface MSWelcomeWindowPlayButtonCell extends MSHoverButtonCell {
}
declare const MSWelcomeWindowPlayButtonCell: {
  alloc(): MSWelcomeWindowPlayButtonCellAllocator;
}

interface MSWelcomeWindowControllerAllocator<InitializedType = MSWelcomeWindowController> extends CHWindowControllerAllocator<MSWelcomeWindowController> {}
interface MSWelcomeWindowController extends CHWindowController, INSMenuDelegate, INSWindowDelegate, IMSWelcomeCollectionViewDelegate {
  pickCollection(sender: any): IBAction;
  openDocument(sender: any): IBAction;
  confirm(sender: any): IBAction;
  //   close(sender: any): IBAction;
  visitLearnPage(sender: any): IBAction;
  subscribeToNewsletter(sender: any): IBAction;
  visitPluginsPage(sender: any): IBAction;
  revealDocumentInFinder(sender: any): IBAction;
  revealDocumentInCloud(sender: any): IBAction;
  clearRecentDocuments(sender: any): IBAction;
  showCollection(collection: MSWelcomeCollection): void;

  closeButton(): NSButton;
  setCloseButton(closeButton: NSButton): void;
  collectionView(): NSCollectionView;
  setCollectionView(collectionView: NSCollectionView): void;
  collectionScrollView(): NSScrollView;
  setCollectionScrollView(collectionScrollView: NSScrollView): void;
  collectionStaticContainerView(): NSView;
  setCollectionStaticContainerView(collectionStaticContainerView: NSView): void;
  collectionsSegmentedControl(): NSSegmentedControl;
  setCollectionsSegmentedControl(collectionsSegmentedControl: NSSegmentedControl): void;
  collectionsWidthConstraint(): NSLayoutConstraint;
  setCollectionsWidthConstraint(collectionsWidthConstraint: NSLayoutConstraint): void;
  confirmButton(): NSButton;
  setConfirmButton(confirmButton: NSButton): void;
  doNotShowAgainButton(): NSButton;
  setDoNotShowAgainButton(doNotShowAgainButton: NSButton): void;
  newsletterButton(): MSCallToActionButton;
  setNewsletterButton(newsletterButton: MSCallToActionButton): void;
  pluginsButton(): MSCallToActionButton;
  setPluginsButton(pluginsButton: MSCallToActionButton): void;
  recentDocumentsContextMenu(): NSMenu;
  setRecentDocumentsContextMenu(recentDocumentsContextMenu: NSMenu): void;
  templatesContextMenu(): NSMenu;
  setTemplatesContextMenu(templatesContextMenu: NSMenu): void;
  versionTextField(): NSTextField;
  setVersionTextField(versionTextField: NSTextField): void;
  collectionToShow(): MSWelcomeCollection;
  numberOfDocuments(): NSInteger;
  previewImageCache(): MSPreviewImageCache;
}
declare const MSWelcomeWindowController: {
  alloc(): MSWelcomeWindowControllerAllocator;  showWelcomeWindowIfAppropriate(): boolean;
  showWelcomeWindowCollection_isLaunching(collection: MSWelcomeCollection, launching: boolean): void;
  hideWelcomeWindowIfNeeded(): boolean;

}

declare enum MSWelcomeCollection {
  MSWelcomeCollectionRecents = 0,
  MSWelcomeCollectionTemplates = 1,
  MSWelcomeCollectionCloud = 2,
}

interface MSZoomActionAllocator<InitializedType = MSZoomAction> extends MSDocumentActionAllocator<MSZoomAction> {}
interface MSZoomAction extends MSDocumentAction {
}
declare const MSZoomAction: {
  alloc(): MSZoomActionAllocator;
}

interface MSZoomInActionAllocator<InitializedType = MSZoomInAction> extends MSDocumentActionAllocator<MSZoomInAction> {}
interface MSZoomInAction extends MSDocumentAction {
}
declare const MSZoomInAction: {
  alloc(): MSZoomInActionAllocator;
}

interface MSZoomOutActionAllocator<InitializedType = MSZoomOutAction> extends MSDocumentActionAllocator<MSZoomOutAction> {}
interface MSZoomOutAction extends MSDocumentAction {
}
declare const MSZoomOutAction: {
  alloc(): MSZoomOutActionAllocator;
}

interface MSZoomActionsAllocator<InitializedType = MSZoomActions> extends MSActionGroupAllocator<MSZoomActions> {}
interface MSZoomActions extends MSActionGroup {
}
declare const MSZoomActions: {
  alloc(): MSZoomActionsAllocator;
}

interface MSPreviewAtActualSizeActionAllocator<InitializedType = MSPreviewAtActualSizeAction> extends MSDocumentActionAllocator<MSPreviewAtActualSizeAction> {}
interface MSPreviewAtActualSizeAction extends MSDocumentAction {
}
declare const MSPreviewAtActualSizeAction: {
  alloc(): MSPreviewAtActualSizeActionAllocator;
}

interface MSZoomBlurEventHandlerAllocator<InitializedType = MSZoomBlurEventHandler> extends MSPointsEventHandlerAllocator<MSZoomBlurEventHandler> {}
interface MSZoomBlurEventHandler extends MSPointsEventHandler {

  blurStyle(): MSStyleBlur;
  setBlurStyle(blurStyle: MSStyleBlur): void;
}
declare const MSZoomBlurEventHandler: {
  alloc(): MSZoomBlurEventHandlerAllocator;
}

interface MSZoomToolAllocator<InitializedType = MSZoomTool> extends NSObjectAllocator<MSZoomTool> {}
interface MSZoomTool extends NSObject {
  beginZoomToolModeActivatedByKey(activatedByKey: boolean): void;
  endZoomToolModeInView(view: MSContentDrawView): void;
  flagsChanged(): void;
  mouseDown_inView(event: NSEvent, view: MSContentDrawView): void;
  mouseDragged_inView(event: NSEvent, view: MSContentDrawView): void;
  mouseUp_inView(event: NSEvent, view: MSContentDrawView): void;
  mouseMoved(): void;
  drawWithScrollOrigin(origin: NSPoint): void;
  zoomValueAfterZoomIn(): CGFloat;
  zoomValueAfterZoomOut(): CGFloat;

  active(): boolean;
  activatedByKey(): boolean;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}
declare const MSZoomTool: {
  alloc(): MSZoomToolAllocator;
}

declare enum BCMainMenuItemTag {
  BCMainMenuPrintItem = 201,
  BCMainMenuInsertItem = 400,
  BCMainMenuShapeItem = 401,
  BCMainMenuReplaceWithItem = 501,
}

interface NSAlternatingViewBackgroundViewAllocator<InitializedType = NSAlternatingViewBackgroundView> extends NSViewAllocator<NSAlternatingViewBackgroundView> {}
interface NSAlternatingViewBackgroundView extends NSView {
}
declare const NSAlternatingViewBackgroundView: {
  alloc(): NSAlternatingViewBackgroundViewAllocator;
}

interface MSSeparatorlessViewAllocator<InitializedType = MSSeparatorlessView> extends NSViewAllocator<MSSeparatorlessView> {}
interface MSSeparatorlessView extends NSView {
}
declare const MSSeparatorlessView: {
  alloc(): MSSeparatorlessViewAllocator;
}

interface MSSeparatorlessFlippedViewAllocator<InitializedType = MSSeparatorlessFlippedView> extends MSSeparatorlessViewAllocator<MSSeparatorlessFlippedView> {}
interface MSSeparatorlessFlippedView extends MSSeparatorlessView {
}
declare const MSSeparatorlessFlippedView: {
  alloc(): MSSeparatorlessFlippedViewAllocator;
}

interface MSInsetSeparatorViewAllocator<InitializedType = MSInsetSeparatorView> extends NSViewAllocator<MSInsetSeparatorView> {}
interface MSInsetSeparatorView extends NSView {
}
declare const MSInsetSeparatorView: {
  alloc(): MSInsetSeparatorViewAllocator;
}

interface MSSeparatorConfigurableViewAllocator<InitializedType = MSSeparatorConfigurableView> extends NSViewAllocator<MSSeparatorConfigurableView> {}
interface MSSeparatorConfigurableView extends NSView {

  wantsSeparator(): boolean;
  setWantsSeparator(wantsSeparator: boolean): void;
  inset(): boolean;
  setInset(inset: boolean): void;
}
declare const MSSeparatorConfigurableView: {
  alloc(): MSSeparatorConfigurableViewAllocator;
}

interface SketchQuicklookGeneratorAllocator<InitializedType = SketchQuicklookGenerator> extends NSObjectAllocator<SketchQuicklookGenerator> {}
interface SketchQuicklookGenerator extends NSObject {
  generatePreview(): NSImage;
  generateThumbnailWithMaxSize(maxSize: NSSize): NSData;
}
declare const SketchQuicklookGenerator: {
  alloc(): SketchQuicklookGeneratorAllocator;  generatorForURL_options(url: NSURL, options: NSDictionary<any, any> | {[key: string]: any}): SketchQuicklookGenerator;

}

interface MSUITestAutomatorAllocator<InitializedType = MSUITestAutomator> extends NSObjectAllocator<MSUITestAutomator> {}
interface MSUITestAutomator extends NSObject {
  queuePlaybackEvent(event: dispatch_block_t): void;
  playback(): void;
  pausePlaybackFor(pause: NSTimeInterval): void;
  singleClickAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  doubleClickAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  startDragAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  dragToPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  endDragAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  sendKeyPressEvent_modifiers(characters: NSString | string, flags: NSEventModifierFlags): void;
  sendDeleteKeyPressed(flags: NSEventModifierFlags): void;
  sendRightArrowKeyModifiers(flags: NSEventModifierFlags): void;
  sendLeftArrowKeyModifiers(flags: NSEventModifierFlags): void;
  sendUpArrowKeyModifiers(flags: NSEventModifierFlags): void;
  sendDownArrowKeyModifiers(flags: NSEventModifierFlags): void;
}
declare const MSUITestAutomator: {
  alloc(): MSUITestAutomatorAllocator;
}

interface ReachabilityAllocator<InitializedType = Reachability> extends NSObjectAllocator<Reachability> {}
interface Reachability extends NSObject {
  startNotifier(): boolean;
  stopNotifier(): void;
  currentReachabilityStatus(): NetworkStatus;
  connectionRequired(): boolean;
}
declare const Reachability: {
  alloc(): ReachabilityAllocator;  reachabilityWithHostName(hostName: NSString | string): Reachability;
  reachabilityWithAddress(hostAddress: sockaddr_): Reachability;
  reachabilityForInternetConnection(): Reachability;
  reachabilityForLocalWiFi(): Reachability;

}

declare enum NetworkStatus {
  NotReachable = 0,
  ReachableViaWiFi,
  ReachableViaWWAN,
}

interface UIDeviceAllocator<InitializedType = UIDevice> {}
interface UIDevice {
  awk_totalMemory(): NSNumber;
}
declare const UIDevice: {
  alloc(): UIDeviceAllocator;
}

interface BCJSONUnarchiverAllocator<InitializedType = BCJSONUnarchiver> extends NSObjectAllocator<BCJSONUnarchiver> {}
interface BCJSONUnarchiver extends NSObject {
}
declare const BCJSONUnarchiver: {
  alloc(): BCJSONUnarchiverAllocator;
}

interface CHViewControllerAllocator<InitializedType = CHViewController> extends NSViewControllerAllocator<CHViewController> {}
interface CHViewController extends NSViewController {
}
declare const CHViewController: {
  alloc(): CHViewControllerAllocator;
}

interface WKWebViewAllocator<InitializedType = WKWebView> extends NSViewAllocator<WKWebView> {}
interface WKWebView extends NSView {
}
declare const WKWebView: {
  alloc(): WKWebViewAllocator;
}

interface MSPopoverDismisserViewAllocator<InitializedType = MSPopoverDismisserView> extends NSViewAllocator<MSPopoverDismisserView> {}
interface MSPopoverDismisserView extends NSView {
}
declare const MSPopoverDismisserView: {
  alloc(): MSPopoverDismisserViewAllocator;
}

interface MSAlignmentEngineCycleAllocator<InitializedType = MSAlignmentEngineCycle> {}
interface MSAlignmentEngineCycle {
}
declare const MSAlignmentEngineCycle: {
  alloc(): MSAlignmentEngineCycleAllocator;
}


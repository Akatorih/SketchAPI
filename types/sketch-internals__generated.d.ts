/****** OVERRIDES ********/

// block alias
declare type Block = any
declare type BCVoidBlock = Block
declare type CHStringAttributesCompareBlock = Block
declare type CHStringWordEnumeratorBlock = Block
declare type BCDictionaryFilterBlock = Block
declare type CGContextDrawBlock = Block
declare type BCTimerBlock = Block
declare type BCConcurrentMapCompletionBlock = Block
declare type BCSumBlock = Block
declare type BCMapTableFilterBlock = Block
declare type MSDocumentIteratorBlock = Block
declare type ECTestComparisonBlock = Block
declare type MSPreviewGeneratorBlock = Block
declare type MSLayerFilterBlock = Block
declare type MSSelectionModifierBlock = Block
declare type MSLayerIteratorBlock = Block
declare type MSLayerIteratorTestBlock = Block
declare type MSRenameSharedObjectBlock = Block
declare type BCMagnifierCompletionBlock = Block
declare type FBCurveIntersectionBlock = Block
declare type BCCacheCreateObjectBlock = Block
declare type ProgressBlock = Block
declare type MSLayerEnumeratorBlock = Block
declare type MSLayerSimpleEnumeratorBlock = Block
declare type MSUndoActionBlock = Block
declare type imageGenerationBlock = Block
declare type MSColorFinderCompletionBlock = Block
declare type MSWebExporterCompletionBlock = Block
declare type MSFlashViewControllerBlock = Block
declare type MSFlashControllerHelpBlock = Block
declare type MSColorConvertibleHandler = Block
declare type MSDataApplierBlock = Block
declare type MSManifestImageProviderBlock = Block
declare type MSAveragingRenderMonitorUpdateBlock = Block
declare type MSAttributeConverterBlock = Block
declare type MSActionFakeActionBlock = Block
declare type NSComparator = Block
declare type MSDocumentPreviewImageHandler = Block
declare type MSAnimationBlock = Block
declare type MSColorInspectorSetupBlock = Block
declare type MSCreateSymbolCompletionBlock = Block
declare type MSExportManagerSliceCompletionBlock = Block
declare type MSFontFamilyPickerCompletionBlock = Block
declare type MSInsertTextEventHandlerCompletionBlock = Block
declare type NSItemProviderLoadHandler = Block
declare type NSItemProviderCompletionHandler = Block
declare type MSBezierPathModifierBlock = Block
declare type MSPasteboardItemWritingBlock = Block
declare type MSPreviewImageHandler = Block
declare type dispatch_block_t = Block
declare type MSSaveAsTemplateSheetCompletionBlock = Block
declare type NSProgressPublishingHandler = Block
declare type NSUserScriptTaskCompletionHandler = Block
declare type NSUserUnixTaskCompletionHandler = Block
declare type NSUserAppleScriptTaskCompletionHandler = Block
declare type NSUserAutomatorTaskCompletionHandler = Block
declare type GradientInterpolationFunction = Block
declare type BCOutlineViewControllerPostRefreshBlock = Block
declare type FMDBExecuteStatementsCallbackBlock = Block
declare type CGPDFOperatorCallback = Block
declare type ArgumentBlock = Block
declare type BITCustomCrashReportUIHandler = Block
declare type BITCrashManagerPostCrashSignalCallback = Block
declare type BITLogHandler = Block
declare type MSNetworkTimeCompletionBlock = Block
declare type SCKDownloadOperationHandler = Block
declare type MSTextSectionParagraphEnumerator = Block
declare type MSTextSectionStringEnumerator = Block
declare type MSForeignObjectCollectionFilter = Block
declare type MSRenderMonitorHook = Block
declare type MSLineShapeCreatorBlock = Block
declare type MSCommandPreparation = Block
declare type MSDataPropertyEnumerator = Block
declare type MSDescendantEnumerator = Block
declare type MSToolCompletionHandler = Block

// C types
declare type CGPath = any
declare type NSFetchRequest = any
declare type NSManagedObjectModel = any
declare type NSAttributeType = number
declare type NSEntityDescription = any

// CORE SERVICES TYPES
declare type DescType = any
declare type OSType = any
declare type SInt32 = number
declare type AEEventClass = any
declare type AEEventID = any
declare type AEReturnID = any
declare type AETransactionID = any
declare type pid_t = any
declare type AEDesc = any
declare type AEKeyword = any
declare type AppleEvent = any
declare type SRefCon = any
declare type OSErr = any
declare type OSStatus = any

// JAVASCRIPT CORE TYPES
declare type JSValueRef = any
declare type JSContextRef = any
declare type JSObjectRef = JSValueRef
declare type JSGlobalContextRef = JSContextRef
declare type JSPropertyAttributes = any
declare type JSClassRef = any
declare type MOObjCOwnershipRule = any
declare type ffi_type = any

// CORE DATA TYPES
declare type NSManagedObjectContext = any

// Webkit
declare interface IWebUIDelegate {}
declare interface IWebResourceLoadDelegate {}
declare interface IWebFrameLoadDelegate {}
declare interface IWKExtensionDelegate {}

declare type IBAction = any
declare type Protocol = any

declare type FBFloat = CGFloat
declare type FBPoint = NSPoint
declare type FBSize = NSSize
declare type FBRect = NSRect
declare type FBBezierPath = NSBezierPath

declare type CFTimeInterval = number
declare type CVTimeStamp = number
declare type CFTypeRef = any

declare type dispatch_group_t = any
declare type dispatch_queue_t = any
declare type uuid_t = any
declare type au_asid_t = any
declare type uid_t = any
declare type gid_t = any
declare type int16_t = any
declare type size_t = any

// METAL TYPES
declare type MTLPixelFormat = number
declare type MTLClearColor = {
  red: number
  green: number
  blue: number
  alpha: number
}

declare type mach_port_t = number
declare type sockaddr_ = number

declare type compression_algorithm = any
declare type dispatch_data_t = any

declare type CKShare = any
declare type CKContainer = any
declare type CKShareMetadata = any

declare type SecIdentityRef = any
declare type SecTrustRef = any
declare type SSLProtocol = any

declare type CIFilter = any
declare type CIContext = any

declare type IconRef = any
declare type QTMovie = any

declare type _CGLPixelFormatObject = any
declare type GLint = any
declare type GLuint = any
declare type GLenum = any
declare type GLsizei = any
declare type _CGLPBufferObject = any
declare type _CGLContextObject = any
declare type GLbitfield = any

declare type SCNetworkReachabilityRef = any

// TODO: find why this is not auto generated
declare type NSTypesetterGlyphInfo = any
declare interface IMSSliceLayerWatcher {}
declare interface IMSAllRenderers extends IMSLayerRenderer, IMSPathRenderer, IMSFillRenderer, IMSBackgroundBlurRenderer, IMSShadowRenderer, IMSGridRenderer {}
declare interface INSCollectionViewElement {}
declare interface INSAccessibilityTable {}
declare interface INSTextAttachmentContainer {}
declare interface INSTextLayoutOrientationProvider {}
declare interface IECIODelegate {}
declare interface ISCKDiff {}
declare interface IMSLayer {}

/****** AUTO GENERATED ********/

class CAAnimationAllocator<T extends CAAnimation> extends NSObjectAllocator<T> {}
declare class CAAnimation extends NSObject {
  alloc<T extends CAAnimation>(): CAAnimationAllocator<T>;
  static animation(): CAAnimation;
  static defaultValueForKey(key: NSString | string): any;
  shouldArchiveValueForKey(key: NSString | string): boolean;

  timingFunction(): CAMediaTimingFunction;
  setTimingFunction(timingFunction: CAMediaTimingFunction): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  removedOnCompletion(): boolean;
  setRemovedOnCompletion(removedOnCompletion: boolean): void;
}

class CAPropertyAnimationAllocator<T extends CAPropertyAnimation> extends CAAnimationAllocator<T> {}
declare class CAPropertyAnimation extends CAAnimation {
  alloc<T extends CAPropertyAnimation>(): CAPropertyAnimationAllocator<T>;
  static animationWithKeyPath(path: NSString | string | null): CAPropertyAnimation;

  keyPath(): NSString;
  setKeyPath(keyPath: NSString | string): void;
  additive(): boolean;
  setAdditive(additive: boolean): void;
  cumulative(): boolean;
  setCumulative(cumulative: boolean): void;
  valueFunction(): CAValueFunction;
  setValueFunction(valueFunction: CAValueFunction): void;
}

class CABasicAnimationAllocator<T extends CABasicAnimation> extends CAPropertyAnimationAllocator<T> {}
declare class CABasicAnimation extends CAPropertyAnimation {
  alloc<T extends CABasicAnimation>(): CABasicAnimationAllocator<T>;

  fromValue(): any;
  setFromValue(fromValue: any): void;
  toValue(): any;
  setToValue(toValue: any): void;
  byValue(): any;
  setByValue(byValue: any): void;
}

class CAKeyframeAnimationAllocator<T extends CAKeyframeAnimation> extends CAPropertyAnimationAllocator<T> {}
declare class CAKeyframeAnimation extends CAPropertyAnimation {
  alloc<T extends CAKeyframeAnimation>(): CAKeyframeAnimationAllocator<T>;

  values(): NSArray<any>;
  setValues(values: NSArray<any> | any[]): void;
  path(): CGPathRef;
  setPath(path: CGPathRef): void;
  keyTimes(): NSArray<any>;
  setKeyTimes(keyTimes: NSArray<any> | any[]): void;
  timingFunctions(): NSArray<any>;
  setTimingFunctions(timingFunctions: NSArray<any> | any[]): void;
  calculationMode(): NSString;
  setCalculationMode(calculationMode: NSString | string): void;
  tensionValues(): NSArray<any>;
  setTensionValues(tensionValues: NSArray<any> | any[]): void;
  continuityValues(): NSArray<any>;
  setContinuityValues(continuityValues: NSArray<any> | any[]): void;
  biasValues(): NSArray<any>;
  setBiasValues(biasValues: NSArray<any> | any[]): void;
  rotationMode(): NSString;
  setRotationMode(rotationMode: NSString | string): void;
}

class CASpringAnimationAllocator<T extends CASpringAnimation> extends CABasicAnimationAllocator<T> {}
declare class CASpringAnimation extends CABasicAnimation {
  alloc<T extends CASpringAnimation>(): CASpringAnimationAllocator<T>;

  mass(): CGFloat;
  setMass(mass: CGFloat): void;
  stiffness(): CGFloat;
  setStiffness(stiffness: CGFloat): void;
  damping(): CGFloat;
  setDamping(damping: CGFloat): void;
  initialVelocity(): CGFloat;
  setInitialVelocity(initialVelocity: CGFloat): void;
  settlingDuration(): CFTimeInterval;
}

class CATransitionAllocator<T extends CATransition> extends CAAnimationAllocator<T> {}
declare class CATransition extends CAAnimation {
  alloc<T extends CATransition>(): CATransitionAllocator<T>;

  type(): NSString;
  setType(type: NSString | string): void;
  subtype(): NSString;
  setSubtype(subtype: NSString | string): void;
  startProgress(): number;
  setStartProgress(startProgress: number): void;
  endProgress(): number;
  setEndProgress(endProgress: number): void;
  filter(): any;
  setFilter(filter: any): void;
}

class CAAnimationGroupAllocator<T extends CAAnimationGroup> extends CAAnimationAllocator<T> {}
declare class CAAnimationGroup extends CAAnimation {
  alloc<T extends CAAnimationGroup>(): CAAnimationGroupAllocator<T>;

  animations(): NSArray<any>;
  setAnimations(animations: NSArray<any> | any[]): void;
}

declare interface ICAAnimationDelegate {
  animationDidStart(anim: CAAnimation): void;
  animationDidStop_finished(anim: CAAnimation, flag: boolean): void;
}

class CALayerAllocator<T extends CALayer> extends NSObjectAllocator<T> {
  init(): T;
  initWithLayer(layer: any): T;
}
declare class CALayer extends NSObject implements INSSecureCoding, ICAMediaTiming {
  alloc<T extends CALayer>(): CALayerAllocator<T>;
  addConstraint(c: CAConstraint): void;
  static layer(): CALayer;
  presentationLayer(): CALayer;
  modelLayer(): CALayer;
  static defaultValueForKey(key: NSString | string): any;
  static needsDisplayForKey(key: NSString | string): boolean;
  shouldArchiveValueForKey(key: NSString | string): boolean;
  affineTransform(): CGAffineTransform;
  setAffineTransform(m: CGAffineTransform): void;
  contentsAreFlipped(): boolean;
  removeFromSuperlayer(): void;
  addSublayer(layer: CALayer): void;
  insertSublayer_atIndex(layer: CALayer, idx: number): void;
  insertSublayer_below(layer: CALayer, sibling: CALayer | null): void;
  insertSublayer_above(layer: CALayer, sibling: CALayer | null): void;
  replaceSublayer_with(layer: CALayer, layer2: CALayer): void;
  convertPoint_fromLayer(p: CGPoint, l: CALayer | null): CGPoint;
  convertPoint_toLayer(p: CGPoint, l: CALayer | null): CGPoint;
  convertRect_fromLayer(r: CGRect, l: CALayer | null): CGRect;
  convertRect_toLayer(r: CGRect, l: CALayer | null): CGRect;
  convertTime_fromLayer(t: CFTimeInterval, l: CALayer | null): CFTimeInterval;
  convertTime_toLayer(t: CFTimeInterval, l: CALayer | null): CFTimeInterval;
  hitTest(p: CGPoint): CALayer;
  containsPoint(p: CGPoint): boolean;
  display(): void;
  setNeedsDisplay(): void;
  setNeedsDisplayInRect(r: CGRect): void;
  needsDisplay(): boolean;
  displayIfNeeded(): void;
  drawInContext(ctx: CGContextRef): void;
  renderInContext(ctx: CGContextRef): void;
  preferredFrameSize(): CGSize;
  setNeedsLayout(): void;
  needsLayout(): boolean;
  layoutIfNeeded(): void;
  layoutSublayers(): void;
  resizeSublayersWithOldSize(size: CGSize): void;
  resizeWithOldSuperlayerSize(size: CGSize): void;
  static defaultActionForKey(event: NSString | string): any;
  actionForKey(event: NSString | string): any;
  addAnimation_forKey(anim: CAAnimation, key: NSString | string | null): void;
  removeAllAnimations(): void;
  removeAnimationForKey(key: NSString | string): void;
  animationKeys(): NSArray<any>;
  animationForKey(key: NSString | string): CAAnimation;
  static layerWithRemoteClientId(client_id: number): CALayer;
  scrollPoint(p: CGPoint): void;
  scrollRectToVisible(r: CGRect): void;

  constraints(): NSArray<any>;
  setConstraints(constraints: NSArray<any> | any[]): void;
  bounds(): CGRect;
  setBounds(bounds: CGRect): void;
  position(): CGPoint;
  setPosition(position: CGPoint): void;
  zPosition(): CGFloat;
  setZPosition(zPosition: CGFloat): void;
  anchorPoint(): CGPoint;
  setAnchorPoint(anchorPoint: CGPoint): void;
  anchorPointZ(): CGFloat;
  setAnchorPointZ(anchorPointZ: CGFloat): void;
  transform(): CATransform3D;
  setTransform(transform: CATransform3D): void;
  frame(): CGRect;
  setFrame(frame: CGRect): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  doubleSided(): boolean;
  setDoubleSided(doubleSided: boolean): void;
  geometryFlipped(): boolean;
  setGeometryFlipped(geometryFlipped: boolean): void;
  superlayer(): CALayer;
  sublayers(): NSArray<any>;
  setSublayers(sublayers: NSArray<any> | any[]): void;
  sublayerTransform(): CATransform3D;
  setSublayerTransform(sublayerTransform: CATransform3D): void;
  mask(): CALayer;
  setMask(mask: CALayer): void;
  masksToBounds(): boolean;
  setMasksToBounds(masksToBounds: boolean): void;
  contents(): any;
  setContents(contents: any): void;
  contentsRect(): CGRect;
  setContentsRect(contentsRect: CGRect): void;
  contentsGravity(): NSString;
  setContentsGravity(contentsGravity: NSString | string): void;
  contentsCenter(): CGRect;
  setContentsCenter(contentsCenter: CGRect): void;
  minificationFilter(): NSString;
  setMinificationFilter(minificationFilter: NSString | string): void;
  magnificationFilter(): NSString;
  setMagnificationFilter(magnificationFilter: NSString | string): void;
  minificationFilterBias(): number;
  setMinificationFilterBias(minificationFilterBias: number): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
  needsDisplayOnBoundsChange(): boolean;
  setNeedsDisplayOnBoundsChange(needsDisplayOnBoundsChange: boolean): void;
  edgeAntialiasingMask(): CAEdgeAntialiasingMask;
  setEdgeAntialiasingMask(edgeAntialiasingMask: CAEdgeAntialiasingMask): void;
  backgroundColor(): CGColorRef;
  setBackgroundColor(backgroundColor: CGColorRef): void;
  cornerRadius(): CGFloat;
  setCornerRadius(cornerRadius: CGFloat): void;
  borderWidth(): CGFloat;
  setBorderWidth(borderWidth: CGFloat): void;
  borderColor(): CGColorRef;
  setBorderColor(borderColor: CGColorRef): void;
  opacity(): number;
  setOpacity(opacity: number): void;
  compositingFilter(): any;
  setCompositingFilter(compositingFilter: any): void;
  filters(): NSArray<any>;
  setFilters(filters: NSArray<any> | any[]): void;
  backgroundFilters(): NSArray<any>;
  setBackgroundFilters(backgroundFilters: NSArray<any> | any[]): void;
  shouldRasterize(): boolean;
  setShouldRasterize(shouldRasterize: boolean): void;
  rasterizationScale(): CGFloat;
  setRasterizationScale(rasterizationScale: CGFloat): void;
  shadowColor(): CGColorRef;
  setShadowColor(shadowColor: CGColorRef): void;
  shadowOpacity(): number;
  setShadowOpacity(shadowOpacity: number): void;
  shadowOffset(): CGSize;
  setShadowOffset(shadowOffset: CGSize): void;
  shadowRadius(): CGFloat;
  setShadowRadius(shadowRadius: CGFloat): void;
  shadowPath(): CGPathRef;
  setShadowPath(shadowPath: CGPathRef): void;
  autoresizingMask(): CAAutoresizingMask;
  setAutoresizingMask(autoresizingMask: CAAutoresizingMask): void;
  layoutManager(): any;
  setLayoutManager(layoutManager: any): void;
  actions(): NSDictionary<any, any>;
  setActions(actions: NSDictionary<any, any> | {[key: string]: any}): void;
  name(): NSString;
  setName(name: NSString | string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  style(): NSDictionary<any, any>;
  setStyle(style: NSDictionary<any, any> | {[key: string]: any}): void;
  visibleRect(): CGRect;
  static supportsSecureCoding(): boolean;
  beginTime(): CFTimeInterval;
  setBeginTime(beginTime: CFTimeInterval): void;
  duration(): CFTimeInterval;
  setDuration(duration: CFTimeInterval): void;
  speed(): number;
  setSpeed(speed: number): void;
  timeOffset(): CFTimeInterval;
  setTimeOffset(timeOffset: CFTimeInterval): void;
  repeatCount(): number;
  setRepeatCount(repeatCount: number): void;
  repeatDuration(): CFTimeInterval;
  setRepeatDuration(repeatDuration: CFTimeInterval): void;
  autoreverses(): boolean;
  setAutoreverses(autoreverses: boolean): void;
  fillMode(): NSString;
  setFillMode(fillMode: NSString | string): void;
}

class CAConstraintLayoutManagerAllocator<T extends CAConstraintLayoutManager> extends NSObjectAllocator<T> {}
declare class CAConstraintLayoutManager extends NSObject implements ICALayoutManager {
  alloc<T extends CAConstraintLayoutManager>(): CAConstraintLayoutManagerAllocator<T>;
  static layoutManager(): CAConstraintLayoutManager;
  preferredSizeOfLayer(layer: CALayer): CGSize;
  invalidateLayoutOfLayer(layer: CALayer): void;
  layoutSublayersOfLayer(layer: CALayer): void;
  preferredSizeOfLayer(layer: CALayer): CGSize;
  invalidateLayoutOfLayer(layer: CALayer): void;
  layoutSublayersOfLayer(layer: CALayer): void;
}

class CAConstraintAllocator<T extends CAConstraint> extends NSObjectAllocator<T> {
  initWithAttribute_relativeTo_attribute_scale_offset(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute, m: CGFloat, c: CGFloat): T;
}
declare class CAConstraint extends NSObject implements INSSecureCoding {
  alloc<T extends CAConstraint>(): CAConstraintAllocator<T>;
  static constraintWithAttribute_relativeTo_attribute_scale_offset(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute, m: CGFloat, c: CGFloat): CAConstraint;
  static constraintWithAttribute_relativeTo_attribute_offset(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute, c: CGFloat): CAConstraint;
  static constraintWithAttribute_relativeTo_attribute(attr: CAConstraintAttribute, srcId: NSString | string, srcAttr: CAConstraintAttribute): CAConstraint;

  attribute(): CAConstraintAttribute;
  sourceName(): NSString;
  sourceAttribute(): CAConstraintAttribute;
  scale(): CGFloat;
  offset(): CGFloat;
  static supportsSecureCoding(): boolean;
}

declare enum CAConstraintAttribute {
  kCAConstraintMinX,
  kCAConstraintMidX,
  kCAConstraintMaxX,
  kCAConstraintWidth,
  kCAConstraintMinY,
  kCAConstraintMidY,
  kCAConstraintMaxY,
  kCAConstraintHeight,
}

class CAEmitterCellAllocator<T extends CAEmitterCell> extends NSObjectAllocator<T> {}
declare class CAEmitterCell extends NSObject implements INSSecureCoding, ICAMediaTiming {
  alloc<T extends CAEmitterCell>(): CAEmitterCellAllocator<T>;
  static emitterCell(): CAEmitterCell;
  static defaultValueForKey(key: NSString | string): any;
  shouldArchiveValueForKey(key: NSString | string): boolean;

  name(): NSString;
  setName(name: NSString | string): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  birthRate(): number;
  setBirthRate(birthRate: number): void;
  lifetime(): number;
  setLifetime(lifetime: number): void;
  lifetimeRange(): number;
  setLifetimeRange(lifetimeRange: number): void;
  emissionLatitude(): CGFloat;
  setEmissionLatitude(emissionLatitude: CGFloat): void;
  emissionLongitude(): CGFloat;
  setEmissionLongitude(emissionLongitude: CGFloat): void;
  emissionRange(): CGFloat;
  setEmissionRange(emissionRange: CGFloat): void;
  velocity(): CGFloat;
  setVelocity(velocity: CGFloat): void;
  velocityRange(): CGFloat;
  setVelocityRange(velocityRange: CGFloat): void;
  xAcceleration(): CGFloat;
  setXAcceleration(xAcceleration: CGFloat): void;
  yAcceleration(): CGFloat;
  setYAcceleration(yAcceleration: CGFloat): void;
  zAcceleration(): CGFloat;
  setZAcceleration(zAcceleration: CGFloat): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  scaleRange(): CGFloat;
  setScaleRange(scaleRange: CGFloat): void;
  scaleSpeed(): CGFloat;
  setScaleSpeed(scaleSpeed: CGFloat): void;
  spin(): CGFloat;
  setSpin(spin: CGFloat): void;
  spinRange(): CGFloat;
  setSpinRange(spinRange: CGFloat): void;
  color(): CGColorRef;
  setColor(color: CGColorRef): void;
  redRange(): number;
  setRedRange(redRange: number): void;
  greenRange(): number;
  setGreenRange(greenRange: number): void;
  blueRange(): number;
  setBlueRange(blueRange: number): void;
  alphaRange(): number;
  setAlphaRange(alphaRange: number): void;
  redSpeed(): number;
  setRedSpeed(redSpeed: number): void;
  greenSpeed(): number;
  setGreenSpeed(greenSpeed: number): void;
  blueSpeed(): number;
  setBlueSpeed(blueSpeed: number): void;
  alphaSpeed(): number;
  setAlphaSpeed(alphaSpeed: number): void;
  contents(): any;
  setContents(contents: any): void;
  contentsRect(): CGRect;
  setContentsRect(contentsRect: CGRect): void;
  contentsScale(): CGFloat;
  setContentsScale(contentsScale: CGFloat): void;
  minificationFilter(): NSString;
  setMinificationFilter(minificationFilter: NSString | string): void;
  magnificationFilter(): NSString;
  setMagnificationFilter(magnificationFilter: NSString | string): void;
  minificationFilterBias(): number;
  setMinificationFilterBias(minificationFilterBias: number): void;
  emitterCells(): NSArray<any>;
  setEmitterCells(emitterCells: NSArray<any> | any[]): void;
  style(): NSDictionary<any, any>;
  setStyle(style: NSDictionary<any, any> | {[key: string]: any}): void;
  static supportsSecureCoding(): boolean;
  beginTime(): CFTimeInterval;
  setBeginTime(beginTime: CFTimeInterval): void;
  duration(): CFTimeInterval;
  setDuration(duration: CFTimeInterval): void;
  speed(): number;
  setSpeed(speed: number): void;
  timeOffset(): CFTimeInterval;
  setTimeOffset(timeOffset: CFTimeInterval): void;
  repeatCount(): number;
  setRepeatCount(repeatCount: number): void;
  repeatDuration(): CFTimeInterval;
  setRepeatDuration(repeatDuration: CFTimeInterval): void;
  autoreverses(): boolean;
  setAutoreverses(autoreverses: boolean): void;
  fillMode(): NSString;
  setFillMode(fillMode: NSString | string): void;
}

class CAEmitterLayerAllocator<T extends CAEmitterLayer> extends CALayerAllocator<T> {}
declare class CAEmitterLayer extends CALayer {
  alloc<T extends CAEmitterLayer>(): CAEmitterLayerAllocator<T>;

  emitterCells(): NSArray<any>;
  setEmitterCells(emitterCells: NSArray<any> | any[]): void;
  birthRate(): number;
  setBirthRate(birthRate: number): void;
  lifetime(): number;
  setLifetime(lifetime: number): void;
  emitterPosition(): CGPoint;
  setEmitterPosition(emitterPosition: CGPoint): void;
  emitterZPosition(): CGFloat;
  setEmitterZPosition(emitterZPosition: CGFloat): void;
  emitterSize(): CGSize;
  setEmitterSize(emitterSize: CGSize): void;
  emitterDepth(): CGFloat;
  setEmitterDepth(emitterDepth: CGFloat): void;
  emitterShape(): NSString;
  setEmitterShape(emitterShape: NSString | string): void;
  emitterMode(): NSString;
  setEmitterMode(emitterMode: NSString | string): void;
  renderMode(): NSString;
  setRenderMode(renderMode: NSString | string): void;
  preservesDepth(): boolean;
  setPreservesDepth(preservesDepth: boolean): void;
  velocity(): number;
  setVelocity(velocity: number): void;
  scale(): number;
  setScale(scale: number): void;
  spin(): number;
  setSpin(spin: number): void;
  seed(): number;
  setSeed(seed: number): void;
}

class CAGradientLayerAllocator<T extends CAGradientLayer> extends CALayerAllocator<T> {}
declare class CAGradientLayer extends CALayer {
  alloc<T extends CAGradientLayer>(): CAGradientLayerAllocator<T>;

  colors(): NSArray<any>;
  setColors(colors: NSArray<any> | any[]): void;
  locations(): NSArray<any>;
  setLocations(locations: NSArray<any> | any[]): void;
  startPoint(): CGPoint;
  setStartPoint(startPoint: CGPoint): void;
  endPoint(): CGPoint;
  setEndPoint(endPoint: CGPoint): void;
  type(): NSString;
  setType(type: NSString | string): void;
}

class NSNullAllocator<T extends NSNull> extends NSObjectAllocator<T> {}
declare class NSNull extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSNull>(): NSNullAllocator<T>;
  static null(): NSNull;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  static supportsSecureCoding(): boolean;
}

declare interface ICALayoutManager {
  preferredSizeOfLayer(layer: CALayer): CGSize;
  invalidateLayoutOfLayer(layer: CALayer): void;
  layoutSublayersOfLayer(layer: CALayer): void;
}

declare interface ICAAction {
  runActionForKey_object_arguments(event: NSString | string, anObject: any, dict: NSDictionary<any, any> | {[key: string]: any} | null): void;
}

declare interface ICALayerDelegate {
  displayLayer(layer: CALayer): void;
  drawLayer_inContext(layer: CALayer, ctx: CGContextRef): void;
  layoutSublayersOfLayer(layer: CALayer): void;
  actionForLayer_forKey(layer: CALayer, event: NSString | string): any;
}

declare enum CAAutoresizingMask {
  kCALayerNotSizable = 0,
  kCALayerMinXMargin = 1 << 0,
  kCALayerWidthSizable = 1 << 1,
  kCALayerMaxXMargin = 1 << 2,
  kCALayerMinYMargin = 1 << 3,
  kCALayerHeightSizable = 1 << 4,
  kCALayerMaxYMargin = 1 << 5,
}

declare enum CAEdgeAntialiasingMask {
  kCALayerLeftEdge = 1 << 0,
  kCALayerRightEdge = 1 << 1,
  kCALayerBottomEdge = 1 << 2,
  kCALayerTopEdge = 1 << 3,
}

declare enum CACornerMask {
  kCALayerMinXMinYCorner = 1 << 0,
  kCALayerMaxXMinYCorner = 1 << 1,
  kCALayerMinXMaxYCorner = 1 << 2,
  kCALayerMaxXMaxYCorner = 1 << 3,
}

declare interface ICAMediaTiming {

  beginTime(): CFTimeInterval;
  setBeginTime(beginTime: CFTimeInterval): void;
  duration(): CFTimeInterval;
  setDuration(duration: CFTimeInterval): void;
  speed(): number;
  setSpeed(speed: number): void;
  timeOffset(): CFTimeInterval;
  setTimeOffset(timeOffset: CFTimeInterval): void;
  repeatCount(): number;
  setRepeatCount(repeatCount: number): void;
  repeatDuration(): CFTimeInterval;
  setRepeatDuration(repeatDuration: CFTimeInterval): void;
  autoreverses(): boolean;
  setAutoreverses(autoreverses: boolean): void;
  fillMode(): NSString;
  setFillMode(fillMode: NSString | string): void;
}

class CAMediaTimingFunctionAllocator<T extends CAMediaTimingFunction> extends NSObjectAllocator<T> {
  initWithControlPoints___(c1x: number, c1y: number, c2x: number, c2y: number): T;
}
declare class CAMediaTimingFunction extends NSObject implements INSSecureCoding {
  alloc<T extends CAMediaTimingFunction>(): CAMediaTimingFunctionAllocator<T>;
  static functionWithName(name: NSString | string): CAMediaTimingFunction;
  static functionWithControlPoints___(c1x: number, c1y: number, c2x: number, c2y: number): CAMediaTimingFunction;
  getControlPointAtIndex_values(idx: size_t, ptr: [number, number]): void;

  static supportsSecureCoding(): boolean;
}

class CAMetalLayerAllocator<T extends CAMetalLayer> extends CALayerAllocator<T> {}
declare class CAMetalLayer extends CALayer {
  alloc<T extends CAMetalLayer>(): CAMetalLayerAllocator<T>;
  nextDrawable(): any;

  device(): any;
  setDevice(device: any): void;
  pixelFormat(): MTLPixelFormat;
  setPixelFormat(pixelFormat: MTLPixelFormat): void;
  framebufferOnly(): boolean;
  setFramebufferOnly(framebufferOnly: boolean): void;
  drawableSize(): CGSize;
  setDrawableSize(drawableSize: CGSize): void;
  presentsWithTransaction(): boolean;
  setPresentsWithTransaction(presentsWithTransaction: boolean): void;
  colorspace(): CGColorSpaceRef;
  setColorspace(colorspace: CGColorSpaceRef): void;
  wantsExtendedDynamicRangeContent(): boolean;
  setWantsExtendedDynamicRangeContent(wantsExtendedDynamicRangeContent: boolean): void;
}

class CARemoteLayerClientAllocator<T extends CARemoteLayerClient> extends NSObjectAllocator<T> {
  initWithServerPort(port: mach_port_t): T;
}
declare class CARemoteLayerClient extends NSObject {
  alloc<T extends CARemoteLayerClient>(): CARemoteLayerClientAllocator<T>;
  invalidate(): void;

  clientId(): number;
  layer(): CALayer;
  setLayer(layer: CALayer): void;
}

class CARemoteLayerServerAllocator<T extends CARemoteLayerServer> extends NSObjectAllocator<T> {}
declare class CARemoteLayerServer extends NSObject {
  alloc<T extends CARemoteLayerServer>(): CARemoteLayerServerAllocator<T>;
  static sharedServer(): CARemoteLayerServer;

  serverPort(): mach_port_t;
}

class CARendererAllocator<T extends CARenderer> extends NSObjectAllocator<T> {}
declare class CARenderer extends NSObject {
  alloc<T extends CARenderer>(): CARendererAllocator<T>;
  static rendererWithCGLContext_options(ctx: void, dict: NSDictionary<any, any> | {[key: string]: any} | null): CARenderer;
  beginFrameAtTime_timeStamp(t: CFTimeInterval, ts: CVTimeStamp | null): void;
  updateBounds(): CGRect;
  addUpdateRect(r: CGRect): void;
  render(): void;
  nextFrameTime(): CFTimeInterval;
  endFrame(): void;

  layer(): CALayer;
  setLayer(layer: CALayer): void;
  bounds(): CGRect;
  setBounds(bounds: CGRect): void;
}

class CAReplicatorLayerAllocator<T extends CAReplicatorLayer> extends CALayerAllocator<T> {}
declare class CAReplicatorLayer extends CALayer {
  alloc<T extends CAReplicatorLayer>(): CAReplicatorLayerAllocator<T>;

  instanceCount(): NSInteger;
  setInstanceCount(instanceCount: NSInteger): void;
  preservesDepth(): boolean;
  setPreservesDepth(preservesDepth: boolean): void;
  instanceDelay(): CFTimeInterval;
  setInstanceDelay(instanceDelay: CFTimeInterval): void;
  instanceTransform(): CATransform3D;
  setInstanceTransform(instanceTransform: CATransform3D): void;
  instanceColor(): CGColorRef;
  setInstanceColor(instanceColor: CGColorRef): void;
  instanceRedOffset(): number;
  setInstanceRedOffset(instanceRedOffset: number): void;
  instanceGreenOffset(): number;
  setInstanceGreenOffset(instanceGreenOffset: number): void;
  instanceBlueOffset(): number;
  setInstanceBlueOffset(instanceBlueOffset: number): void;
  instanceAlphaOffset(): number;
  setInstanceAlphaOffset(instanceAlphaOffset: number): void;
}

class CAScrollLayerAllocator<T extends CAScrollLayer> extends CALayerAllocator<T> {}
declare class CAScrollLayer extends CALayer {
  alloc<T extends CAScrollLayer>(): CAScrollLayerAllocator<T>;
  scrollToPoint(p: CGPoint): void;
  scrollToRect(r: CGRect): void;

  scrollMode(): NSString;
  setScrollMode(scrollMode: NSString | string): void;
}

class CAShapeLayerAllocator<T extends CAShapeLayer> extends CALayerAllocator<T> {}
declare class CAShapeLayer extends CALayer {
  alloc<T extends CAShapeLayer>(): CAShapeLayerAllocator<T>;

  path(): CGPathRef;
  setPath(path: CGPathRef): void;
  fillColor(): CGColorRef;
  setFillColor(fillColor: CGColorRef): void;
  fillRule(): NSString;
  setFillRule(fillRule: NSString | string): void;
  strokeColor(): CGColorRef;
  setStrokeColor(strokeColor: CGColorRef): void;
  strokeStart(): CGFloat;
  setStrokeStart(strokeStart: CGFloat): void;
  strokeEnd(): CGFloat;
  setStrokeEnd(strokeEnd: CGFloat): void;
  lineWidth(): CGFloat;
  setLineWidth(lineWidth: CGFloat): void;
  miterLimit(): CGFloat;
  setMiterLimit(miterLimit: CGFloat): void;
  lineCap(): NSString;
  setLineCap(lineCap: NSString | string): void;
  lineJoin(): NSString;
  setLineJoin(lineJoin: NSString | string): void;
  lineDashPhase(): CGFloat;
  setLineDashPhase(lineDashPhase: CGFloat): void;
  lineDashPattern(): NSArray<any>;
  setLineDashPattern(lineDashPattern: NSArray<any> | any[]): void;
}

class CATextLayerAllocator<T extends CATextLayer> extends CALayerAllocator<T> {}
declare class CATextLayer extends CALayer {
  alloc<T extends CATextLayer>(): CATextLayerAllocator<T>;

  string(): any;
  setString(string: any): void;
  font(): CFTypeRef;
  setFont(font: CFTypeRef): void;
  fontSize(): CGFloat;
  setFontSize(fontSize: CGFloat): void;
  foregroundColor(): CGColorRef;
  setForegroundColor(foregroundColor: CGColorRef): void;
  wrapped(): boolean;
  setWrapped(wrapped: boolean): void;
  truncationMode(): NSString;
  setTruncationMode(truncationMode: NSString | string): void;
  alignmentMode(): NSString;
  setAlignmentMode(alignmentMode: NSString | string): void;
  allowsFontSubpixelQuantization(): boolean;
  setAllowsFontSubpixelQuantization(allowsFontSubpixelQuantization: boolean): void;
}

class CATiledLayerAllocator<T extends CATiledLayer> extends CALayerAllocator<T> {}
declare class CATiledLayer extends CALayer {
  alloc<T extends CATiledLayer>(): CATiledLayerAllocator<T>;
  static fadeDuration(): CFTimeInterval;

  levelsOfDetail(): size_t;
  setLevelsOfDetail(levelsOfDetail: size_t): void;
  levelsOfDetailBias(): size_t;
  setLevelsOfDetailBias(levelsOfDetailBias: size_t): void;
  tileSize(): CGSize;
  setTileSize(tileSize: CGSize): void;
}

class CATransactionAllocator<T extends CATransaction> extends NSObjectAllocator<T> {}
declare class CATransaction extends NSObject {
  alloc<T extends CATransaction>(): CATransactionAllocator<T>;
  static begin(): void;
  static commit(): void;
  static flush(): void;
  static lock(): void;
  static unlock(): void;
  static animationDuration(): CFTimeInterval;
  static setAnimationDuration(dur: CFTimeInterval): void;
  static animationTimingFunction(): CAMediaTimingFunction;
  static setAnimationTimingFunction(functionName: CAMediaTimingFunction | null): void;
  static disableActions(): boolean;
  static setDisableActions(flag: boolean): void;
  static setCompletionBlock(block: Block | null): void;
  static valueForKey(key: NSString | string): any;
  static setValue_forKey(anObject: any | null, key: NSString | string): void;
  static disableAnimationsInBlock(block: BCVoidBlock): void;
}

class NSValueAllocator<T extends NSValue> extends NSObjectAllocator<T> {
  initWithBytes_objCType(value: void, type: string): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSValue extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSValue>(): NSValueAllocator<T>;
  static valueWithCATransform3D(t: CATransform3D): NSValue;
  static valueWithPoint(point: NSPoint): NSValue;
  static valueWithSize(size: NSSize): NSValue;
  static valueWithRect(rect: NSRect): NSValue;
  static valueWithEdgeInsets(insets: NSEdgeInsets): NSValue;
  static valueWithRange(range: NSRange): NSValue;
  getValue_size(value: void, size: NSUInteger): void;
  static valueWithBytes_objCType(value: void, type: string): NSValue;
  static value_withObjCType(value: void, type: string): NSValue;
  static valueWithNonretainedObject(anObject: any | null): NSValue;
  static valueWithPointer(pointer: void | null): NSValue;
  isEqualToValue(value: NSValue): boolean;
  getValue(value: void): void;
  static valueWithCGVector(vector: CGVector): NSValue;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  CATransform3DValue(): CATransform3D;
  pointValue(): NSPoint;
  sizeValue(): NSSize;
  rectValue(): NSRect;
  edgeInsetsValue(): NSEdgeInsets;
  rangeValue(): NSRange;
  objCType(): string;
  nonretainedObjectValue(): any;
  pointerValue(): void;
  CGVectorValue(): CGVector;
  static supportsSecureCoding(): boolean;
}

declare type CATransform3D = {
  m11: CGFloat
  m12: CGFloat
  m13: CGFloat
  m14: CGFloat
  m21: CGFloat
  m22: CGFloat
  m23: CGFloat
  m24: CGFloat
  m31: CGFloat
  m32: CGFloat
  m33: CGFloat
  m34: CGFloat
  m41: CGFloat
  m42: CGFloat
  m43: CGFloat
  m44: CGFloat
}

class CATransformLayerAllocator<T extends CATransformLayer> extends CALayerAllocator<T> {}
declare class CATransformLayer extends CALayer {
  alloc<T extends CATransformLayer>(): CATransformLayerAllocator<T>;
}

class CAValueFunctionAllocator<T extends CAValueFunction> extends NSObjectAllocator<T> {}
declare class CAValueFunction extends NSObject implements INSSecureCoding {
  alloc<T extends CAValueFunction>(): CAValueFunctionAllocator<T>;
  static functionWithName(name: NSString | string): CAValueFunction;

  name(): NSString;
  static supportsSecureCoding(): boolean;
}

declare type CGAffineTransform = {
  a: CGFloat
  b: CGFloat
  c: CGFloat
  d: CGFloat
  tx: CGFloat
  ty: CGFloat
}

declare type CGFloat = number

declare type CGColorRef = any

declare enum CGColorConversionInfoTransformType {
  kCGColorConversionTransformFromSpace = 0,
  kCGColorConversionTransformToSpace,
  kCGColorConversionTransformApplySpace,
}

declare type CGColorSpaceRef = any

declare enum CGColorRenderingIntent {
  kCGRenderingIntentDefault,
  kCGRenderingIntentAbsoluteColorimetric,
  kCGRenderingIntentRelativeColorimetric,
  kCGRenderingIntentPerceptual,
  kCGRenderingIntentSaturation,
}

declare enum CGColorSpaceModel {
  kCGColorSpaceModelUnknown = -1,
  kCGColorSpaceModelMonochrome,
  kCGColorSpaceModelRGB,
  kCGColorSpaceModelCMYK,
  kCGColorSpaceModelLab,
  kCGColorSpaceModelDeviceN,
  kCGColorSpaceModelIndexed,
  kCGColorSpaceModelPattern,
}

declare type CGContextRef = any

declare enum CGPathDrawingMode {
  kCGPathFill,
  kCGPathEOFill,
  kCGPathStroke,
  kCGPathFillStroke,
  kCGPathEOFillStroke,
}

declare enum CGTextDrawingMode {
  kCGTextFill,
  kCGTextStroke,
  kCGTextFillStroke,
  kCGTextInvisible,
  kCGTextFillClip,
  kCGTextStrokeClip,
  kCGTextFillStrokeClip,
  kCGTextClip,
}

declare enum CGTextEncoding {
  kCGEncodingFontSpecific,
  kCGEncodingMacRoman,
}

declare enum CGInterpolationQuality {
  kCGInterpolationDefault = 0,
  kCGInterpolationNone = 1,
  kCGInterpolationLow = 2,
  kCGInterpolationMedium = 4,
  kCGInterpolationHigh = 3,
}

declare enum CGBlendMode {
  kCGBlendModeNormal,
  kCGBlendModeMultiply,
  kCGBlendModeScreen,
  kCGBlendModeOverlay,
  kCGBlendModeDarken,
  kCGBlendModeLighten,
  kCGBlendModeColorDodge,
  kCGBlendModeColorBurn,
  kCGBlendModeSoftLight,
  kCGBlendModeHardLight,
  kCGBlendModeDifference,
  kCGBlendModeExclusion,
  kCGBlendModeHue,
  kCGBlendModeSaturation,
  kCGBlendModeColor,
  kCGBlendModeLuminosity,
  kCGBlendModeClear,
  kCGBlendModeCopy,
  kCGBlendModeSourceIn,
  kCGBlendModeSourceOut,
  kCGBlendModeSourceAtop,
  kCGBlendModeDestinationOver,
  kCGBlendModeDestinationIn,
  kCGBlendModeDestinationOut,
  kCGBlendModeDestinationAtop,
  kCGBlendModeXOR,
  kCGBlendModePlusDarker,
  kCGBlendModePlusLighter,
}

declare type CGDirectDisplayID = number

declare type CGOpenGLDisplayMask = number

declare type CGRefreshRate = number

declare type CGGammaValue = number

declare type CGDisplayCount = number

declare type CGDisplayFadeReservationToken = number

declare type CGDisplayBlendFraction = number

declare type CGDisplayFadeInterval = number

declare type CGDisplayReservationInterval = number

declare enum CGDisplayStreamUpdateRectType {
  kCGDisplayStreamUpdateRefreshedRects,
  kCGDisplayStreamUpdateMovedRects,
  kCGDisplayStreamUpdateDirtyRects,
  kCGDisplayStreamUpdateReducedDirtyRects,
}

declare enum CGDisplayStreamFrameStatus {
  kCGDisplayStreamFrameStatusFrameComplete,
  kCGDisplayStreamFrameStatusFrameIdle,
  kCGDisplayStreamFrameStatusFrameBlank,
  kCGDisplayStreamFrameStatusStopped,
}

declare enum CGError {
  kCGErrorSuccess = 0,
  kCGErrorFailure = 1000,
  kCGErrorIllegalArgument = 1001,
  kCGErrorInvalidConnection = 1002,
  kCGErrorInvalidContext = 1003,
  kCGErrorCannotComplete = 1004,
  kCGErrorNotImplemented = 1006,
  kCGErrorRangeCheck = 1007,
  kCGErrorTypeCheck = 1008,
  kCGErrorInvalidOperation = 1010,
  kCGErrorNoneAvailable = 1011,
}

declare type CGEventRef = any

declare type CGEventTimestamp = number

declare type CGEventMask = number

declare type CGEventSourceKeyboardType = number

declare enum CGMouseButton {
  kCGMouseButtonLeft = 0,
  kCGMouseButtonRight = 1,
  kCGMouseButtonCenter = 2,
}

declare enum CGScrollEventUnit {
  kCGScrollEventUnitPixel = 0,
  kCGScrollEventUnitLine = 1,
}

declare enum CGMomentumScrollPhase {
  kCGMomentumScrollPhaseNone = 0,
  kCGMomentumScrollPhaseBegin = 1,
  kCGMomentumScrollPhaseContinue = 2,
  kCGMomentumScrollPhaseEnd = 3,
}

declare enum CGScrollPhase {
  kCGScrollPhaseBegan = 1,
  kCGScrollPhaseChanged = 2,
  kCGScrollPhaseEnded = 4,
  kCGScrollPhaseCancelled = 8,
  kCGScrollPhaseMayBegin = 128,
}

declare enum CGGesturePhase {
  kCGGesturePhaseNone = 0,
  kCGGesturePhaseBegan = 1,
  kCGGesturePhaseChanged = 2,
  kCGGesturePhaseEnded = 4,
  kCGGesturePhaseCancelled = 8,
  kCGGesturePhaseMayBegin = 128,
}

declare enum CGEventType {
  kCGEventNull,
  kCGEventLeftMouseDown,
  kCGEventLeftMouseUp,
  kCGEventRightMouseDown,
  kCGEventRightMouseUp,
  kCGEventMouseMoved,
  kCGEventLeftMouseDragged,
  kCGEventRightMouseDragged,
  kCGEventKeyDown,
  kCGEventKeyUp,
  kCGEventFlagsChanged,
  kCGEventScrollWheel,
  kCGEventTabletPointer,
  kCGEventTabletProximity,
  kCGEventOtherMouseDown,
  kCGEventOtherMouseUp,
  kCGEventOtherMouseDragged,
  kCGEventTapDisabledByTimeout = 0xFFFFFFFE,
  kCGEventTapDisabledByUserInput = 0xFFFFFFFF,
}

declare enum CGEventField {
  kCGMouseEventNumber = 0,
  kCGMouseEventClickState = 1,
  kCGMouseEventPressure = 2,
  kCGMouseEventButtonNumber = 3,
  kCGMouseEventDeltaX = 4,
  kCGMouseEventDeltaY = 5,
  kCGMouseEventInstantMouser = 6,
  kCGMouseEventSubtype = 7,
  kCGKeyboardEventAutorepeat = 8,
  kCGKeyboardEventKeycode = 9,
  kCGKeyboardEventKeyboardType = 10,
  kCGScrollWheelEventDeltaAxis1 = 11,
  kCGScrollWheelEventDeltaAxis2 = 12,
  kCGScrollWheelEventDeltaAxis3 = 13,
  kCGScrollWheelEventFixedPtDeltaAxis1 = 93,
  kCGScrollWheelEventFixedPtDeltaAxis2 = 94,
  kCGScrollWheelEventFixedPtDeltaAxis3 = 95,
  kCGScrollWheelEventPointDeltaAxis1 = 96,
  kCGScrollWheelEventPointDeltaAxis2 = 97,
  kCGScrollWheelEventPointDeltaAxis3 = 98,
  kCGScrollWheelEventScrollPhase = 99,
  kCGScrollWheelEventScrollCount = 100,
  kCGScrollWheelEventMomentumPhase = 123,
  kCGScrollWheelEventInstantMouser = 14,
  kCGTabletEventPointX = 15,
  kCGTabletEventPointY = 16,
  kCGTabletEventPointZ = 17,
  kCGTabletEventPointButtons = 18,
  kCGTabletEventPointPressure = 19,
  kCGTabletEventTiltX = 20,
  kCGTabletEventTiltY = 21,
  kCGTabletEventRotation = 22,
  kCGTabletEventTangentialPressure = 23,
  kCGTabletEventDeviceID = 24,
  kCGTabletEventVendor1 = 25,
  kCGTabletEventVendor2 = 26,
  kCGTabletEventVendor3 = 27,
  kCGTabletProximityEventVendorID = 28,
  kCGTabletProximityEventTabletID = 29,
  kCGTabletProximityEventPointerID = 30,
  kCGTabletProximityEventDeviceID = 31,
  kCGTabletProximityEventSystemTabletID = 32,
  kCGTabletProximityEventVendorPointerType = 33,
  kCGTabletProximityEventVendorPointerSerialNumber = 34,
  kCGTabletProximityEventVendorUniqueID = 35,
  kCGTabletProximityEventCapabilityMask = 36,
  kCGTabletProximityEventPointerType = 37,
  kCGTabletProximityEventEnterProximity = 38,
  kCGEventTargetProcessSerialNumber = 39,
  kCGEventTargetUnixProcessID = 40,
  kCGEventSourceUnixProcessID = 41,
  kCGEventSourceUserData = 42,
  kCGEventSourceUserID = 43,
  kCGEventSourceGroupID = 44,
  kCGEventSourceStateID = 45,
  kCGScrollWheelEventIsContinuous = 88,
  kCGMouseEventWindowUnderMousePointer = 91,
  kCGMouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
}

declare enum CGEventMouseSubtype {
  kCGEventMouseSubtypeDefault = 0,
  kCGEventMouseSubtypeTabletPoint = 1,
  kCGEventMouseSubtypeTabletProximity = 2,
}

declare enum CGEventTapLocation {
  kCGHIDEventTap = 0,
  kCGSessionEventTap,
  kCGAnnotatedSessionEventTap,
}

declare enum CGEventTapPlacement {
  kCGHeadInsertEventTap = 0,
  kCGTailAppendEventTap,
}

declare enum CGEventTapOptions {
  kCGEventTapOptionDefault = 0x00000000,
  kCGEventTapOptionListenOnly = 0x00000001,
}

declare enum CGEventSourceStateID {
  kCGEventSourceStatePrivate = -1,
  kCGEventSourceStateCombinedSessionState = 0,
  kCGEventSourceStateHIDSystemState = 1,
}

declare type CGFontIndex = number

declare type CGGlyph = CGFontIndex

declare enum CGFontPostScriptFormat {
  kCGFontPostScriptFormatType1 = 1,
  kCGFontPostScriptFormatType3 = 3,
  kCGFontPostScriptFormatType42 = 42,
}

declare type CGPoint = {
  x: CGFloat
  y: CGFloat
}

declare type CGSize = {
  width: CGFloat
  height: CGFloat
}

declare type CGVector = {
  dx: CGFloat
  dy: CGFloat
}

declare type CGRect = {
  origin: CGPoint
  size: CGSize
}

declare enum CGRectEdge {
  CGRectMinXEdge,
  CGRectMinYEdge,
  CGRectMaxXEdge,
  CGRectMaxYEdge,
}

declare type CGGradientRef = any

declare type CGImageRef = any

declare enum CGImageAlphaInfo {
  kCGImageAlphaNone,
  kCGImageAlphaPremultipliedLast,
  kCGImageAlphaPremultipliedFirst,
  kCGImageAlphaLast,
  kCGImageAlphaFirst,
  kCGImageAlphaNoneSkipLast,
  kCGImageAlphaNoneSkipFirst,
  kCGImageAlphaOnly,
}

declare enum CGImageByteOrderInfo {
  kCGImageByteOrderMask = 0x7000,
  kCGImageByteOrderDefault,
  kCGImageByteOrder16Little,
  kCGImageByteOrder32Little,
  kCGImageByteOrder16Big,
  kCGImageByteOrder32Big,
}

declare type CGPDFArrayRef = any

declare type CGPDFContentStreamRef = any

declare type CGPDFDictionaryRef = any

declare type CGPDFBoolean = string

declare type CGPDFInteger = number

declare type CGPDFReal = CGFloat

declare type CGPDFObjectRef = any

declare enum CGPDFObjectType {
  kCGPDFObjectTypeNull = 1,
  kCGPDFObjectTypeBoolean,
  kCGPDFObjectTypeInteger,
  kCGPDFObjectTypeReal,
  kCGPDFObjectTypeName,
  kCGPDFObjectTypeString,
  kCGPDFObjectTypeArray,
  kCGPDFObjectTypeDictionary,
  kCGPDFObjectTypeStream,
}

declare type CGPDFPageRef = any

declare enum CGPDFBox {
  kCGPDFMediaBox = 0,
  kCGPDFCropBox = 1,
  kCGPDFBleedBox = 2,
  kCGPDFTrimBox = 3,
  kCGPDFArtBox = 4,
}

declare type CGPDFStreamRef = any

declare enum CGPDFDataFormat {
  CGPDFDataFormatRaw,
  CGPDFDataFormatJPEGEncoded,
  CGPDFDataFormatJPEG2000,
}

declare type CGPDFStringRef = any

declare type CGMutablePathRef = CGPath

declare type CGPathRef = CGPath

declare enum CGLineJoin {
  kCGLineJoinMiter,
  kCGLineJoinRound,
  kCGLineJoinBevel,
}

declare enum CGLineCap {
  kCGLineCapButt,
  kCGLineCapRound,
  kCGLineCapSquare,
}

declare enum CGPathElementType {
  kCGPathElementMoveToPoint,
  kCGPathElementAddLineToPoint,
  kCGPathElementAddQuadCurveToPoint,
  kCGPathElementAddCurveToPoint,
  kCGPathElementCloseSubpath,
}

declare enum CGPatternTiling {
  kCGPatternTilingNoDistortion,
  kCGPatternTilingConstantSpacingMinimalDistortion,
  kCGPatternTilingConstantSpacing,
}

declare type CGButtonCount = number

declare type CGWheelCount = number

declare type CGCharCode = number

declare type CGKeyCode = number

declare type CGRectCount = number

declare enum CGEventSuppressionState {
  kCGEventSuppressionStateSuppressionInterval = 0,
  kCGEventSuppressionStateRemoteMouseDrag,
  kCGNumberOfEventSuppressionStates,
}

declare type CGWindowID = number

declare enum CGWindowSharingType {
  kCGWindowSharingNone = 0,
  kCGWindowSharingReadOnly = 1,
  kCGWindowSharingReadWrite = 2,
}

declare enum CGWindowBackingType {
  kCGBackingStoreRetained = 0,
  kCGBackingStoreNonretained = 1,
  kCGBackingStoreBuffered = 2,
}

declare type CGWindowLevel = number

declare enum CGWindowLevelKey {
  kCGBaseWindowLevelKey = 0,
  kCGMinimumWindowLevelKey,
  kCGDesktopWindowLevelKey,
  kCGBackstopMenuLevelKey,
  kCGNormalWindowLevelKey,
  kCGFloatingWindowLevelKey,
  kCGTornOffMenuWindowLevelKey,
  kCGDockWindowLevelKey,
  kCGMainMenuWindowLevelKey,
  kCGStatusWindowLevelKey,
  kCGModalPanelWindowLevelKey,
  kCGPopUpMenuWindowLevelKey,
  kCGDraggingWindowLevelKey,
  kCGScreenSaverWindowLevelKey,
  kCGMaximumWindowLevelKey,
  kCGOverlayWindowLevelKey,
  kCGHelpWindowLevelKey,
  kCGUtilityWindowLevelKey,
  kCGDesktopIconWindowLevelKey,
  kCGCursorWindowLevelKey,
  kCGAssistiveTechHighWindowLevelKey,
  kCGNumberOfWindowLevelKeys,
}

class NSAffineTransformAllocator<T extends NSAffineTransform> extends NSObjectAllocator<T> {
  initWithTransform(transform: NSAffineTransform): T;
  init(): T;
}
declare class NSAffineTransform extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSAffineTransform>(): NSAffineTransformAllocator<T>;
  static transform(): NSAffineTransform;
  translateXBy_yBy(deltaX: CGFloat, deltaY: CGFloat): void;
  rotateByDegrees(angle: CGFloat): void;
  rotateByRadians(angle: CGFloat): void;
  scaleBy(scale: CGFloat): void;
  scaleXBy_yBy(scaleX: CGFloat, scaleY: CGFloat): void;
  invert(): void;
  appendTransform(transform: NSAffineTransform): void;
  prependTransform(transform: NSAffineTransform): void;
  transformPoint(aPoint: NSPoint): NSPoint;
  transformSize(aSize: NSSize): NSSize;
  transformBezierPath(path: NSBezierPath): NSBezierPath;
  set(): void;
  concat(): void;
  static transformByTranslatingXBy_yBy(x: CGFloat, y: CGFloat): NSAffineTransform;
  static transformByScaling(scale: CGFloat): NSAffineTransform;
  static transformWithOffset(offset: NSPoint): NSAffineTransform;
  static rotationTransformWithDegrees_aroundPoint(degrees: CGFloat, point: NSPoint): NSAffineTransform;
  static transformFromStruct_aroundPoint(transformStruct: CHTransformStruct, p: NSPoint): NSAffineTransform;
  static transformFromStruct_aroundPoint_inPlace(transformStruct: CHTransformStruct, p: NSPoint, transformInPlace: boolean): NSAffineTransform;
  translateByOffset(offset: NSPoint): void;
  transactionWithBlock(block: BCVoidBlock): void;
  rotateWithDegrees_aroundPoint(degrees: CGFloat, point: NSPoint): void;
  invertedTransform(): NSAffineTransform;
  CGAffineTransform(): CGAffineTransform;
  static transformWithCGAffineTransform_ms(t: CGAffineTransform): NSAffineTransform;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  transformStruct(): NSAffineTransformStruct;
  setTransformStruct(transformStruct: NSAffineTransformStruct): void;
  determinant(): CGFloat;
  includesFlip(): boolean;
  static supportsSecureCoding(): boolean;
}

declare type NSAffineTransformStruct = {
  m11: CGFloat
  m12: CGFloat
  m21: CGFloat
  m22: CGFloat
  tX: CGFloat
  tY: CGFloat
}

class NSAppleEventDescriptorAllocator<T extends NSAppleEventDescriptor> extends NSObjectAllocator<T> {
  initWithAEDescNoCopy(aeDesc: AEDesc): T;
  initWithDescriptorType_bytes_length(descriptorType: DescType, bytes: void | null, byteCount: NSUInteger): T;
  initWithDescriptorType_data(descriptorType: DescType, data: NSData | null): T;
  initWithEventClass_eventID_targetDescriptor_returnID_transactionID(eventClass: AEEventClass, eventID: AEEventID, targetDescriptor: NSAppleEventDescriptor | null, returnID: AEReturnID, transactionID: AETransactionID): T;
  initListDescriptor(): T;
  initRecordDescriptor(): T;
}
declare class NSAppleEventDescriptor extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSAppleEventDescriptor>(): NSAppleEventDescriptorAllocator<T>;
  static nullDescriptor(): NSAppleEventDescriptor;
  static descriptorWithDescriptorType_bytes_length(descriptorType: DescType, bytes: void | null, byteCount: NSUInteger): NSAppleEventDescriptor;
  static descriptorWithDescriptorType_data(descriptorType: DescType, data: NSData | null): NSAppleEventDescriptor;
  static descriptorWithBoolean(boolean: Boolean): NSAppleEventDescriptor;
  static descriptorWithEnumCode(enumerator: OSType): NSAppleEventDescriptor;
  static descriptorWithInt32(signedInt: SInt32): NSAppleEventDescriptor;
  static descriptorWithDouble(doubleValue: number): NSAppleEventDescriptor;
  static descriptorWithTypeCode(typeCode: OSType): NSAppleEventDescriptor;
  static descriptorWithString(string: NSString | string): NSAppleEventDescriptor;
  static descriptorWithDate(date: NSDate): NSAppleEventDescriptor;
  static descriptorWithFileURL(fileURL: NSURL): NSAppleEventDescriptor;
  static appleEventWithEventClass_eventID_targetDescriptor_returnID_transactionID(eventClass: AEEventClass, eventID: AEEventID, targetDescriptor: NSAppleEventDescriptor | null, returnID: AEReturnID, transactionID: AETransactionID): NSAppleEventDescriptor;
  static listDescriptor(): NSAppleEventDescriptor;
  static recordDescriptor(): NSAppleEventDescriptor;
  static currentProcessDescriptor(): NSAppleEventDescriptor;
  static descriptorWithProcessIdentifier(processIdentifier: pid_t): NSAppleEventDescriptor;
  static descriptorWithBundleIdentifier(bundleIdentifier: NSString | string): NSAppleEventDescriptor;
  static descriptorWithApplicationURL(applicationURL: NSURL): NSAppleEventDescriptor;
  setParamDescriptor_forKeyword(descriptor: NSAppleEventDescriptor, keyword: AEKeyword): void;
  paramDescriptorForKeyword(keyword: AEKeyword): NSAppleEventDescriptor;
  removeParamDescriptorWithKeyword(keyword: AEKeyword): void;
  setAttributeDescriptor_forKeyword(descriptor: NSAppleEventDescriptor, keyword: AEKeyword): void;
  attributeDescriptorForKeyword(keyword: AEKeyword): NSAppleEventDescriptor;
  sendEventWithOptions_timeout_error(sendOptions: NSAppleEventSendOptions, timeoutInSeconds: NSTimeInterval, error: NSError): NSAppleEventDescriptor;
  insertDescriptor_atIndex(descriptor: NSAppleEventDescriptor, index: NSInteger): void;
  descriptorAtIndex(index: NSInteger): NSAppleEventDescriptor;
  removeDescriptorAtIndex(index: NSInteger): void;
  setDescriptor_forKeyword(descriptor: NSAppleEventDescriptor, keyword: AEKeyword): void;
  descriptorForKeyword(keyword: AEKeyword): NSAppleEventDescriptor;
  removeDescriptorWithKeyword(keyword: AEKeyword): void;
  keywordForDescriptorAtIndex(index: NSInteger): AEKeyword;
  coerceToDescriptorType(descriptorType: DescType): NSAppleEventDescriptor;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  aeDesc(): AEDesc;
  descriptorType(): DescType;
  data(): NSData;
  booleanValue(): Boolean;
  enumCodeValue(): OSType;
  int32Value(): SInt32;
  doubleValue(): number;
  typeCodeValue(): OSType;
  stringValue(): NSString;
  dateValue(): NSDate;
  fileURLValue(): NSURL;
  eventClass(): AEEventClass;
  eventID(): AEEventID;
  returnID(): AEReturnID;
  transactionID(): AETransactionID;
  isRecordDescriptor(): boolean;
  numberOfItems(): NSInteger;
  static supportsSecureCoding(): boolean;
}

declare enum NSAppleEventSendOptions {
  NSAppleEventSendNoReply = 0x00000001,
  NSAppleEventSendQueueReply = 0x00000002,
  NSAppleEventSendWaitForReply = 0x00000003,
  NSAppleEventSendNeverInteract = 0x00000010,
  NSAppleEventSendCanInteract = 0x00000020,
  NSAppleEventSendAlwaysInteract = 0x00000030,
  NSAppleEventSendCanSwitchLayer = 0x00000040,
  NSAppleEventSendDontRecord = 0x00001000,
  NSAppleEventSendDontExecute = 0x00002000,
  NSAppleEventSendDontAnnotate = 0x00010000,
  NSAppleEventSendDefaultOptions,
}

class NSAppleEventManagerAllocator<T extends NSAppleEventManager> extends NSObjectAllocator<T> {}
declare class NSAppleEventManager extends NSObject {
  alloc<T extends NSAppleEventManager>(): NSAppleEventManagerAllocator<T>;
  static sharedAppleEventManager(): NSAppleEventManager;
  setEventHandler_andSelector_forEventClass_andEventID(handler: any, handleEventSelector: string, eventClass: AEEventClass, eventID: AEEventID): void;
  removeEventHandlerForEventClass_andEventID(eventClass: AEEventClass, eventID: AEEventID): void;
  dispatchRawAppleEvent_withRawReply_handlerRefCon(theAppleEvent: AppleEvent, theReply: AppleEvent, handlerRefCon: SRefCon): OSErr;
  suspendCurrentAppleEvent(): NSAppleEventManagerSuspensionID;
  appleEventForSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): NSAppleEventDescriptor;
  replyAppleEventForSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): NSAppleEventDescriptor;
  setCurrentAppleEventAndReplyEventWithSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): void;
  resumeWithSuspensionID(suspensionID: NSAppleEventManagerSuspensionID): void;

  currentAppleEvent(): NSAppleEventDescriptor;
  currentReplyAppleEvent(): NSAppleEventDescriptor;
}

declare type NSAppleEventManagerSuspensionID = any

class NSAppleScriptAllocator<T extends NSAppleScript> extends NSObjectAllocator<T> {
  initWithContentsOfURL_error(url: NSURL, errorInfo: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithSource(source: NSString | string): T;
}
declare class NSAppleScript extends NSObject implements INSCopying {
  alloc<T extends NSAppleScript>(): NSAppleScriptAllocator<T>;
  compileAndReturnError(errorInfo: NSDictionary<any, any> | {[key: string]: any}): boolean;
  executeAndReturnError(errorInfo: NSDictionary<any, any> | {[key: string]: any}): NSAppleEventDescriptor;
  executeAppleEvent_error(event: NSAppleEventDescriptor, errorInfo: NSDictionary<any, any> | {[key: string]: any}): NSAppleEventDescriptor;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  source(): NSString;
  compiled(): boolean;
  richTextSource(): NSAttributedString;
}

class NSArchiverAllocator<T extends NSArchiver> extends NSCoderAllocator<T> {
  initForWritingWithMutableData(mdata: NSMutableData): T;
}
declare class NSArchiver extends NSCoder {
  alloc<T extends NSArchiver>(): NSArchiverAllocator<T>;
  encodeRootObject(rootObject: any): void;
  encodeConditionalObject(object: any | null): void;
  static archivedDataWithRootObject(rootObject: any): NSData;
  static archiveRootObject_toFile(rootObject: any, path: NSString | string): boolean;
  encodeClassName_intoClassName(trueName: NSString | string, inArchiveName: NSString | string): void;
  classNameEncodedForTrueClassName(trueName: NSString | string): NSString;
  replaceObject_withObject(object: any, newObject: any): void;

  archiverData(): NSMutableData;
}

class NSUnarchiverAllocator<T extends NSUnarchiver> extends NSCoderAllocator<T> {
  initForReadingWithData(data: NSData): T;
}
declare class NSUnarchiver extends NSCoder {
  alloc<T extends NSUnarchiver>(): NSUnarchiverAllocator<T>;
  static unarchiveObjectWithData(data: NSData): any;
  static unarchiveObjectWithFile(path: NSString | string): any;
  decodeClassName_asClassName(inArchiveName: NSString | string, trueName: NSString | string): void;
  classNameDecodedForArchiveClassName(inArchiveName: NSString | string): NSString;
  replaceObject_withObject(object: any, newObject: any): void;

  atEnd(): boolean;
  systemVersion(): number;
}

class NSObjectAllocator<T extends NSObject> {
  initWithUnarchiver_migratingFrom_toVersion(unarchiver: MSBaseUnarchiver, fromVersion: NSInteger, toVersion: NSInteger): T;
}
declare class NSObject {
  alloc<T extends NSObject>(): NSObjectAllocator<T>;

  description(): NSString;
  inverseForRelationshipKey(relationshipKey: NSString | string): NSString;
  attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo(error: NSError, recoveryOptionIndex: NSUInteger, delegate: any | null, didRecoverSelector: string | null, contextInfo: void | null): void;
  attemptRecoveryFromError_optionIndex(error: NSError, recoveryOptionIndex: NSUInteger): boolean;
  fileManager_shouldProceedAfterError(fm: NSFileManager, errorInfo: NSDictionary<any, any> | {[key: string]: any}): boolean;
  fileManager_willProcessPath(fm: NSFileManager, path: NSString | string): void;
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  validateValue_forKey_error(ioValue: any, inKey: NSString | string, outError: NSError): boolean;
  mutableArrayValueForKey(key: NSString | string): NSMutableArray<any>;
  mutableOrderedSetValueForKey(key: NSString | string): NSMutableOrderedSet<any>;
  mutableSetValueForKey(key: NSString | string): NSMutableSet<any>;
  valueForKeyPath(keyPath: NSString | string): any;
  setValue_forKeyPath(value: any | null, keyPath: NSString | string): void;
  validateValue_forKeyPath_error(ioValue: any, inKeyPath: NSString | string, outError: NSError): boolean;
  mutableArrayValueForKeyPath(keyPath: NSString | string): NSMutableArray<any>;
  mutableOrderedSetValueForKeyPath(keyPath: NSString | string): NSMutableOrderedSet<any>;
  mutableSetValueForKeyPath(keyPath: NSString | string): NSMutableSet<any>;
  valueForUndefinedKey(key: NSString | string): any;
  setValue_forUndefinedKey(value: any | null, key: NSString | string): void;
  setNilValueForKey(key: NSString | string): void;
  dictionaryWithValuesForKeys(keys: NSArray<any> | any[]): NSDictionary<any, any>;
  setValuesForKeysWithDictionary(keyedValues: NSDictionary<any, any> | {[key: string]: any}): void;
  static useStoredAccessor(): boolean;
  storedValueForKey(key: NSString | string): any;
  takeStoredValue_forKey(value: any | null, key: NSString | string): void;
  takeValue_forKey(value: any | null, key: NSString | string): void;
  takeValue_forKeyPath(value: any | null, keyPath: NSString | string): void;
  handleQueryWithUnboundKey(key: NSString | string): any;
  handleTakeValue_forUnboundKey(value: any | null, key: NSString | string): void;
  unableToSetNilForKey(key: NSString | string): void;
  valuesForKeys(keys: NSArray<any> | any[]): NSDictionary<any, any>;
  takeValuesFromDictionary(properties: NSDictionary<any, any> | {[key: string]: any}): void;
  observeValueForKeyPath_ofObject_change_context(keyPath: NSString | string | null, object: any | null, change: NSDictionary<any, any> | {[key: string]: any} | null, context: void | null): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  willChangeValueForKey(key: NSString | string): void;
  didChangeValueForKey(key: NSString | string): void;
  willChange_valuesAtIndexes_forKey(changeKind: NSKeyValueChange, indexes: NSIndexSet, key: NSString | string): void;
  didChange_valuesAtIndexes_forKey(changeKind: NSKeyValueChange, indexes: NSIndexSet, key: NSString | string): void;
  willChangeValueForKey_withSetMutation_usingObjects(key: NSString | string, mutationKind: NSKeyValueSetMutationKind, objects: NSSet<any>): void;
  didChangeValueForKey_withSetMutation_usingObjects(key: NSString | string, mutationKind: NSKeyValueSetMutationKind, objects: NSSet<any>): void;
  static keyPathsForValuesAffectingValueForKey(key: NSString | string): NSSet<any>;
  static automaticallyNotifiesObserversForKey(key: NSString | string): boolean;
  static setKeys_triggerChangeNotificationsForDependentKey(keys: NSArray<any> | any[], dependentKey: NSString | string): void;
  replacementObjectForKeyedArchiver(archiver: NSKeyedArchiver): any;
  static classFallbacksForKeyedArchiver(): NSArray<any>;
  static classForKeyedUnarchiver(): any;
  static version(): NSInteger;
  static setVersion(aVersion: NSInteger): void;
  replacementObjectForCoder(aCoder: NSCoder): any;
  awakeAfterUsingCoder_NS_REPLACES_RECEIVER(aDecoder: NSCoder): any;
  scriptingValueForSpecifier(objectSpecifier: NSScriptObjectSpecifier): any;
  copyScriptingValue_forKey_withProperties(value: any, key: NSString | string, properties: NSDictionary<any, any> | {[key: string]: any}): any;
  newScriptingObjectOfClass_forValueForKey_withContentsValue_properties(objectClass: any, key: NSString | string, contentsValue: any | null, properties: NSDictionary<any, any> | {[key: string]: any}): any;
  replacementObjectForPortCoder(coder: NSPortCoder): any;
  performSelector_withObject_afterDelay_inModes(aSelector: string, anArgument: any | null, delay: NSTimeInterval, modes: NSArray<any> | any[]): void;
  performSelector_withObject_afterDelay(aSelector: string, anArgument: any | null, delay: NSTimeInterval): void;
  static cancelPreviousPerformRequestsWithTarget_selector_object(aTarget: any, aSelector: string, anArgument: any | null): void;
  static cancelPreviousPerformRequestsWithTarget(aTarget: any): void;
  valueAtIndex_inPropertyWithKey(index: NSUInteger, key: NSString | string): any;
  valueWithName_inPropertyWithKey(name: NSString | string, key: NSString | string): any;
  valueWithUniqueID_inPropertyWithKey(uniqueID: any, key: NSString | string): any;
  insertValue_atIndex_inPropertyWithKey(value: any, index: NSUInteger, key: NSString | string): void;
  removeValueAtIndex_fromPropertyWithKey(index: NSUInteger, key: NSString | string): void;
  replaceValueAtIndex_inPropertyWithKey_withValue(index: NSUInteger, key: NSString | string, value: any): void;
  insertValue_inPropertyWithKey(value: any, key: NSString | string): void;
  coerceValue_forKey(value: any | null, key: NSString | string): any;
  indicesOfObjectsByEvaluatingObjectSpecifier(specifier: NSScriptObjectSpecifier): NSArray<any>;
  isEqualTo(object: any | null): boolean;
  isLessThanOrEqualTo(object: any | null): boolean;
  isLessThan(object: any | null): boolean;
  isGreaterThanOrEqualTo(object: any | null): boolean;
  isGreaterThan(object: any | null): boolean;
  isNotEqualTo(object: any | null): boolean;
  doesContain(object: any): boolean;
  isLike(object: NSString | string): boolean;
  isCaseInsensitiveLike(object: NSString | string): boolean;
  scriptingIsEqualTo(object: any): boolean;
  scriptingIsLessThanOrEqualTo(object: any): boolean;
  scriptingIsLessThan(object: any): boolean;
  scriptingIsGreaterThanOrEqualTo(object: any): boolean;
  scriptingIsGreaterThan(object: any): boolean;
  scriptingBeginsWith(object: any): boolean;
  scriptingEndsWith(object: any): boolean;
  scriptingContains(object: any): boolean;
  performSelectorOnMainThread_withObject_waitUntilDone_modes(aSelector: string, arg: any | null, wait: boolean, array: NSArray<any> | any[] | null): void;
  performSelectorOnMainThread_withObject_waitUntilDone(aSelector: string, arg: any | null, wait: boolean): void;
  performSelector_onThread_withObject_waitUntilDone_modes(aSelector: string, thr: NSThread, arg: any | null, wait: boolean, array: NSArray<any> | any[] | null): void;
  performSelector_onThread_withObject_waitUntilDone(aSelector: string, thr: NSThread, arg: any | null, wait: boolean): void;
  performSelectorInBackground_withObject(aSelector: string, arg: any | null): void;
  URL_resourceDataDidBecomeAvailable(sender: NSURL, newBytes: NSData): void;
  URLResourceDidFinishLoading(sender: NSURL): void;
  URLResourceDidCancelLoading(sender: NSURL): void;
  URL_resourceDidFailLoadingWithReason(sender: NSURL, reason: NSString | string): void;
  accessibilityIsIgnored(): boolean;
  accessibilityHitTest(point: NSPoint): any;
  accessibilityIndexOfChild(child: any): NSUInteger;
  accessibilityArrayAttributeCount(attribute: NSAccessibilityAttributeName): NSUInteger;
  accessibilityArrayAttributeValues_index_maxCount(attribute: NSAccessibilityAttributeName, index: NSUInteger, maxCount: NSUInteger): NSArray<any>;
  application_delegateHandlesKey(sender: NSApplication, key: NSString | string): boolean;
  changeColor(sender: any | null): void;
  controlTextDidBeginEditing(obj: NSNotification): void;
  controlTextDidEndEditing(obj: NSNotification): void;
  controlTextDidChange(obj: NSNotification): void;
  namesOfPromisedFilesDroppedAtDestination(dropDestination: NSURL): NSArray<any>;
  draggingSourceOperationMaskForLocal(flag: boolean): NSDragOperation;
  draggedImage_beganAt(image: NSImage, screenPoint: NSPoint): void;
  draggedImage_endedAt_operation(image: NSImage, screenPoint: NSPoint, operation: NSDragOperation): void;
  draggedImage_movedTo(image: NSImage, screenPoint: NSPoint): void;
  ignoreModifierKeysWhileDragging(): boolean;
  draggedImage_endedAt_deposited_DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER(image: NSImage, screenPoint: NSPoint, flag: boolean): void;
  fontManager_willIncludeFont(sender: any, fontName: NSString | string): boolean;
  changeFont(sender: any | null): void;
  validModesForFontPanel(fontPanel: NSFontPanel): NSFontPanelModeMask;
  static exposeBinding(binding: NSBindingName): void;
  valueClassForBinding(binding: NSBindingName): any;
  bind_toObject_withKeyPath_options(binding: NSBindingName, observable: any, keyPath: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null): void;
  unbind(binding: NSBindingName): void;
  infoForBinding(binding: NSBindingName): NSDictionary<any, any>;
  optionDescriptionsForBinding(binding: NSBindingName): NSArray<any>;
  static setDefaultPlaceholder_forMarker_withBinding(placeholder: any | null, marker: any | null, binding: NSBindingName): void;
  static defaultPlaceholderForMarker_withBinding(marker: any | null, binding: NSBindingName): any;
  objectDidBeginEditing(editor: any): void;
  objectDidEndEditing(editor: any): void;
  discardEditing(): void;
  commitEditing(): boolean;
  commitEditingWithDelegate_didCommitSelector_contextInfo(delegate: any | null, didCommitSelector: string | null, contextInfo: void | null): void;
  commitEditingAndReturnError(error: NSError): boolean;
  validateMenuItem(menuItem: NSMenuItem): boolean;
  awakeFromNib(): void;
  prepareForInterfaceBuilder(): void;
  pasteboard_provideDataForType(sender: NSPasteboard, type: NSPasteboardType): void;
  pasteboardChangedOwner(sender: NSPasteboard): void;
  panel_isValidFilename(sender: any, filename: NSString | string): boolean;
  panel_directoryDidChange(sender: any, path: NSString | string): void;
  panel_compareFilename_with_caseSensitive(sender: any, name1: NSString | string, name2: NSString | string, caseSensitive: boolean): NSComparisonResult;
  panel_shouldShowFilename(sender: any, filename: NSString | string): boolean;
  tableView_writeRows_toPasteboard(tableView: NSTableView, rows: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  textStorageWillProcessEditing(notification: NSNotification): void;
  textStorageDidProcessEditing(notification: NSNotification): void;
  validateToolbarItem(item: NSToolbarItem): boolean;
  layer_shouldInheritContentsScale_fromWindow(layer: CALayer, newScale: CGFloat, window: NSWindow): boolean;
  view_stringForToolTip_point_userData(view: NSView, tag: NSToolTipTag, point: NSPoint, data: void | null): NSString;
  changeKey_inBlock(aKey: NSString | string, block: BCVoidBlock): void;
  executeAsBlock(): void;
  runningOSVersion_bc_minorVersion(majorVersion: NSInteger, minorVersion: NSInteger): boolean;
  runningSierra_bc(): boolean;
  mutableCopyDeep(): any;
  outlineView_shouldShowDisclosureTriangleForItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_handleKeyEvent(outlineView: NSOutlineView, anEvent: NSEvent): boolean;
  outlineView_deleteItem(outlineView: NSOutlineView, anItem: any): void;
  tableView_handleKeyEvent(tableView: NSTableView, anEvent: NSEvent): boolean;
  tableViewPoofEffect(tv: NSTableView): boolean;
  coderSafeVersion_bc(): NSObject;
  addObserver_forKeyPaths_options_context(anObserver: NSObject, keyPaths: NSArray<any> | any[], options: NSKeyValueObservingOptions, context: void): void;
  removeObserver_forKeyPaths(anObserver: NSObject, keyPaths: NSArray<any> | any[]): void;
  setCOSJSTargetFunction(jsFunction: MOJavaScriptObject | Function): void;
  coscript_hadError_onLineNumber_atSourceURL(coscript: any, error: NSString | string, lineNumber: NSInteger, url: any): void;
  static mo_swizzleAdditions(): void;
  static mo_mocha(): MOClassDescription;
  static isSelectorExcludedFromMochaScript(selector: string): boolean;
  static selectorForMochaPropertyName(propertyName: NSString | string): string;
  finalizeForMochaScript(): void;
  objectForIndexedSubscript(idx: NSUInteger): any;
  setObject_forIndexedSubscript(obj: any, idx: NSUInteger): void;
  // @ts-ignore
  objectForKeyedSubscript(key: NSString | string): any;
  // @ts-ignore
  setObject_forKeyedSubscript(obj: any, key: NSString | string): void;
  shutdown(): void;
  JSValueForObject(object: any): JSValueRef;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  immutableModelObject(): any;
  copyWithOptions(options: MSModelCopyOptions): any;
  hasDefaultValues(): boolean;
  propertiesAreEqual(object: any): boolean;
  parentObject(): any;
  setParentObject(parentObject: MSModelObjectCommon): void;
  breakConnectionWith(parent: MSModelObjectCommon): void;
  mapTreeWithLeafTransformBlock(block: Block): any;
  safeCastToClass(classToCastTo: any): any;
  drawContentForButton_inRect(button: MSPresetPickerPresetButton, rect: NSRect): void;
  removePresetForButton(menuItem: NSMenuItem): void;
  shouldShowMenuForButton(button: MSPresetPickerPresetButton): boolean;
  removePresetWithTag(tag: NSInteger): void;

  classForArchiver(): any;
  classDescription(): NSClassDescription;
  attributeKeys(): NSArray<any>;
  toOneRelationshipKeys(): NSArray<any>;
  toManyRelationshipKeys(): NSArray<any>;
  static accessInstanceVariablesDirectly(): boolean;
  observationInfo(): void;
  setObservationInfo(observationInfo: void): void;
  classForKeyedArchiver(): any;
  classForCoder(): any;
  autoContentAccessingProxy(): any;
  scriptingProperties(): NSDictionary<any, any>;
  setScriptingProperties(scriptingProperties: NSDictionary<any, any> | {[key: string]: any}): void;
  classForPortCoder(): any;
  classCode(): number;
  className(): NSString;
  objectSpecifier(): NSScriptObjectSpecifier;
  accessibilityFocusedUIElement(): any;
  accessibilityNotifiesWhenDestroyed(): boolean;
  exposedBindings(): NSArray<any>;
}

class NSArrayAllocator<ObjectType, T extends NSArray<ObjectType>> extends NSObjectAllocator<T> {
  init(): T;
  initWithObjects_count(objects: ObjectType[], cnt: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithObjects(firstObj: ObjectType, ...args: any[]): T;
  initWithArray(array: NSArray<any> | any[]): T;
  initWithArray_copyItems(array: NSArray<any> | any[], flag: boolean): T;
  initWithContentsOfURL_error(url: NSURL, error: NSError): T;
  initWithContentsOfFile(path: NSString | string): T;
  initWithContentsOfURL(url: NSURL): T;
}
declare class NSArray<ObjectType> extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {
  alloc<T extends NSArray<ObjectType>>(): NSArrayAllocator<ObjectType, T>;

  [key: number]: ObjectType | Function;
  [key: string]: ObjectType | Function;
  objectAtIndex(index: NSUInteger): ObjectType;
  arrayByAddingObject(anObject: ObjectType): NSArray<any>;
  arrayByAddingObjectsFromArray(otherArray: NSArray<any> | any[]): NSArray<any>;
  componentsJoinedByString(separator: NSString | string): NSString;
  containsObject(anObject: ObjectType): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  descriptionWithLocale_indent(locale: any | null, level: NSUInteger): NSString;
  firstObjectCommonWithArray(otherArray: NSArray<any> | any[]): ObjectType;
  indexOfObject(anObject: ObjectType): NSUInteger;
  indexOfObject_inRange(anObject: ObjectType, range: NSRange): NSUInteger;
  indexOfObjectIdenticalTo(anObject: ObjectType): NSUInteger;
  indexOfObjectIdenticalTo_inRange(anObject: ObjectType, range: NSRange): NSUInteger;
  isEqualToArray(otherArray: NSArray<any> | any[]): boolean;
  objectEnumerator(): NSEnumerator<any>;
  reverseObjectEnumerator(): NSEnumerator<any>;
  sortedArrayUsingSelector(comparator: string): NSArray<any>;
  subarrayWithRange(range: NSRange): NSArray<any>;
  writeToURL_error(url: NSURL, error: NSError): boolean;
  makeObjectsPerformSelector(aSelector: string): void;
  makeObjectsPerformSelector_withObject(aSelector: string, argument: any | null): void;
  objectsAtIndexes(indexes: NSIndexSet): NSArray<any>;
  objectAtIndexedSubscript(idx: NSUInteger): ObjectType;
  enumerateObjectsUsingBlock(block: Block): void;
  enumerateObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateObjectsAtIndexes_options_usingBlock(s: NSIndexSet, opts: NSEnumerationOptions, block: Block): void;
  indexOfObjectPassingTest(predicate: Block): NSUInteger;
  indexOfObjectWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexOfObjectAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexesOfObjectsPassingTest(predicate: Block): NSIndexSet;
  indexesOfObjectsWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexesOfObjectsAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  sortedArrayUsingComparator(cmptr: NSComparator): NSArray<any>;
  sortedArrayWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): NSArray<any>;
  indexOfObject_inSortedRange_options_usingComparator(obj: ObjectType, r: NSRange, opts: NSBinarySearchingOptions, cmp: NSComparator): NSUInteger;
  static array<ObjectType>(): NSArray<ObjectType>;
  static arrayWithObject<ObjectType>(anObject: ObjectType): NSArray<ObjectType>;
  static arrayWithObjects_count<ObjectType>(objects: ObjectType[], cnt: NSUInteger): NSArray<ObjectType>;
  static arrayWithObjects<ObjectType>(firstObj: ObjectType, ...args: any[]): NSArray<ObjectType>;
  static arrayWithArray<ObjectType>(array: NSArray<any> | any[]): NSArray<ObjectType>;
  static arrayWithContentsOfURL_error(url: NSURL, error: NSError): NSArray<any>;
  getObjects(objects: ObjectType[]): void;
  static arrayWithContentsOfFile(path: NSString | string): NSArray<any>;
  static arrayWithContentsOfURL(url: NSURL): NSArray<any>;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  addObserver_toObjectsAtIndexes_forKeyPath_options_context(observer: NSObject, indexes: NSIndexSet, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_fromObjectsAtIndexes_forKeyPath_context(observer: NSObject, indexes: NSIndexSet, keyPath: NSString | string, context: void | null): void;
  removeObserver_fromObjectsAtIndexes_forKeyPath(observer: NSObject, indexes: NSIndexSet, keyPath: NSString | string): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  pathsMatchingExtensions(filterTypes: NSArray<any> | any[]): NSArray<any>;
  filteredArrayUsingPredicate(predicate: NSPredicate): NSArray<any>;
  sortedArrayUsingDescriptors(sortDescriptors: NSArray<any> | any[]): NSArray<any>;
  front(): NSArray<any>;
  tail(): NSArray<any>;
  arrayByRemovingLastObject(): NSArray<any>;
  enumerateTailUsingBlock(block: Block): void;
  reversedArray(): NSArray<any>;
  map(block: Block): NSArray<any>;
  flatMap(block: Block): NSArray<any>;
  mapWithIndex(block: Block): NSArray<any>;
  enumerate(block: Block): void;
  enumerateWithIndex(block: Block): void;
  filter(block: Block): NSArray<any>;
  containsObjectPassingTest(predicate: Block): boolean;
  firstObjectPassingTest(predicate: Block): ObjectType;
  indexOfFirstObjectPassingTest(predicate: Block): NSUInteger;
  filterWithIndex(block: Block): NSArray<any>;
  filteredByObjectsOfClass(aClass: any): NSArray<any>;
  containsObjectOfClass(aClass: any): boolean;
  containsOnlyObjectsOfClass(aClass: any): boolean;
  firstObjectOfClass(aClass: any): any;
  sum(block: BCSumBlock): CGFloat;
  static arrayWithCapacity_fill(count: NSUInteger, block: Block): any;
  arrayByRemovingNull(): NSArray<any>;
  copyDeep(): any;
  sortedArray(): NSArray<any>;
  sortedArrayUsingKey(key: NSString | string): NSArray<any>;
  sortedArrayUsingKey_selector(key: NSString | string, action: string): NSArray<any>;
  shuffledArray(): NSArray<any>;
  arrayByRemovingObject(anObject: any): NSArray<any>;
  arrayByRemovingObjects(objects: NSArray<any> | any[]): NSArray<any>;
  arrayByAddingObjects(firstObj: any, ...args: any[]): NSArray<any>;
  dictionaryByIndexingObjectForKey(aKey: NSString | string): NSDictionary<any, any>;
  static arrayByMergingArrays(array: NSArray<any> | any[]): NSArray<any>;
  isValidIndex(anIndex: NSUInteger): boolean;
  objectAtIndexOrNil(index: NSUInteger): ObjectType;
  subArrayToIndex(anIndex: NSUInteger): NSArray<any>;
  uniqueObjects(): NSArray<any>;
  rotateTwoDimensionalArray(): NSArray<any>;
  indexOfSubArray(array: NSArray<any> | any[]): NSUInteger;
  mapWithMaxConcurrencyCount_usingBlock_completionBlock(maxConcurrentCount: NSInteger, block: Block, completionBlock: BCConcurrentMapCompletionBlock): void;
  mo_objectForIndexedSubscript(idx: NSUInteger): any;
  cloudObjectsOfType_parentObject(type: any, parent: SCKObject | null): NSArray<any>;
  sck_flatMap(transform: Block): NSArray<any>;
  smk_map(mappingBlock: Block): NSArray<any>;
  length(): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  count(): NSUInteger;
  description(): NSString;
  firstObject(): ObjectType;
  lastObject(): ObjectType;
  sortedArrayHint(): NSData;
  static supportsSecureCoding(): boolean;
}

class NSMutableArrayAllocator<ObjectType, T extends NSMutableArray<ObjectType>> extends NSArrayAllocator<ObjectType, T> {
  initWithCapacity(numItems: NSUInteger): T;
}
declare class NSMutableArray<ObjectType> extends NSArray<ObjectType> {
  alloc<T extends NSMutableArray<ObjectType>>(): NSMutableArrayAllocator<ObjectType, T>;
  addObject(anObject: ObjectType): void;
  insertObject_atIndex(anObject: ObjectType, index: NSUInteger): void;
  removeLastObject(): void;
  removeObjectAtIndex(index: NSUInteger): void;
  replaceObjectAtIndex_withObject(index: NSUInteger, anObject: ObjectType): void;
  addObjectsFromArray(otherArray: NSArray<any> | any[]): void;
  exchangeObjectAtIndex_withObjectAtIndex(idx1: NSUInteger, idx2: NSUInteger): void;
  removeAllObjects(): void;
  removeObject_inRange(anObject: ObjectType, range: NSRange): void;
  removeObject(anObject: ObjectType): void;
  removeObjectIdenticalTo_inRange(anObject: ObjectType, range: NSRange): void;
  removeObjectIdenticalTo(anObject: ObjectType): void;
  removeObjectsFromIndices_numIndices(indices: NSUInteger, cnt: NSUInteger): void;
  removeObjectsInArray(otherArray: NSArray<any> | any[]): void;
  removeObjectsInRange(range: NSRange): void;
  replaceObjectsInRange_withObjectsFromArray_range(range: NSRange, otherArray: NSArray<any> | any[], otherRange: NSRange): void;
  replaceObjectsInRange_withObjectsFromArray(range: NSRange, otherArray: NSArray<any> | any[]): void;
  setArray(otherArray: NSArray<any> | any[]): void;
  sortUsingSelector(comparator: string): void;
  insertObjects_atIndexes(objects: NSArray<any> | any[], indexes: NSIndexSet): void;
  removeObjectsAtIndexes(indexes: NSIndexSet): void;
  replaceObjectsAtIndexes_withObjects(indexes: NSIndexSet, objects: NSArray<any> | any[]): void;
  setObject_atIndexedSubscript(obj: ObjectType, idx: NSUInteger): void;
  sortUsingComparator(cmptr: NSComparator): void;
  sortWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): void;
  static arrayWithCapacity<ObjectType>(numItems: NSUInteger): NSMutableArray<ObjectType>;
  static arrayWithContentsOfFile(path: NSString | string): NSMutableArray<any>;
  static arrayWithContentsOfURL(url: NSURL): NSMutableArray<any>;
  filterUsingPredicate(predicate: NSPredicate): void;
  sortUsingDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  removeObjectsPassingTest(predicate: Block): void;
  static arrayWithCapacity_fill(count: NSUInteger, block: Block): any;
  addObjectIfNotNil(obj: any): void;
  removeFirstObject(): void;
  replaceObject_withObject(obj1: any, obj2: any): void;
  mo_setObject_forIndexedSubscript(obj: any, idx: NSUInteger): void;
  indexOfAttributeWithName(name: NSString | string): NSUInteger;
  addAttributeForID(identifier: NSString | string): void;
  addAttributeWithName_stringValue(name: NSString | string, value: NSString | string): void;
  addAttributeWithName_pixelValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_numberValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageFractionalValue(name: NSString | string, value: CGFloat): void;
  removeAttributeWithName(name: NSString | string): void;
}

declare enum NSBinarySearchingOptions {
  NSBinarySearchingFirstEqual,
  NSBinarySearchingLastEqual,
  NSBinarySearchingInsertionIndex,
}

class NSAttributedStringAllocator<T extends NSAttributedString> extends NSObjectAllocator<T> {
  initWithString(str: NSString | string): T;
  initWithString_attributes(str: NSString | string, attrs: NSDictionary<any, any> | {[key: string]: any} | null): T;
  initWithAttributedString(attrStr: NSAttributedString): T;
  initWithURL_options_documentAttributes_error(url: NSURL, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): T;
  initWithData_options_documentAttributes_error(data: NSData, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): T;
  initWithRTF_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithRTFD_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithHTML_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithHTML_baseURL_documentAttributes(data: NSData, base: NSURL, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithDocFormat_documentAttributes(data: NSData, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithHTML_options_documentAttributes(data: NSData, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithRTFDFileWrapper_documentAttributes(wrapper: NSFileWrapper, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithURL_documentAttributes(url: NSURL, dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithPath_documentAttributes(path: NSString | string, dict: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class NSAttributedString extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSAttributedString>(): NSAttributedStringAllocator<T>;
  attributesAtIndex_effectiveRange(location: NSUInteger, range: NSRangePointer | null): NSDictionary<any, any>;
  attribute_atIndex_effectiveRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null): any;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  attributesAtIndex_longestEffectiveRange_inRange(location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): NSDictionary<any, any>;
  attribute_atIndex_longestEffectiveRange_inRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): any;
  isEqualToAttributedString(other: NSAttributedString): boolean;
  enumerateAttributesInRange_options_usingBlock(enumerationRange: NSRange, opts: NSAttributedStringEnumerationOptions, block: Block): void;
  enumerateAttribute_inRange_options_usingBlock(attrName: NSAttributedStringKey, enumerationRange: NSRange, opts: NSAttributedStringEnumerationOptions, block: Block): void;
  dataFromRange_documentAttributes_error(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSData;
  fileWrapperFromRange_documentAttributes_error(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSFileWrapper;
  RTFFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  RTFDFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  RTFDFileWrapperFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSFileWrapper;
  docFormatFromRange_documentAttributes(range: NSRange, dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  fontAttributesInRange(range: NSRange): NSDictionary<any, any>;
  rulerAttributesInRange(range: NSRange): NSDictionary<any, any>;
  containsAttachmentsInRange(range: NSRange): boolean;
  lineBreakBeforeIndex_withinRange(location: NSUInteger, aRange: NSRange): NSUInteger;
  lineBreakByHyphenatingBeforeIndex_withinRange(location: NSUInteger, aRange: NSRange): NSUInteger;
  doubleClickAtIndex(location: NSUInteger): NSRange;
  nextWordFromIndex_forward(location: NSUInteger, isForward: boolean): NSUInteger;
  rangeOfTextBlock_atIndex(block: NSTextBlock, location: NSUInteger): NSRange;
  rangeOfTextTable_atIndex(table: NSTextTable, location: NSUInteger): NSRange;
  rangeOfTextList_atIndex(list: NSTextList, location: NSUInteger): NSRange;
  itemNumberInTextList_atIndex(list: NSTextList, location: NSUInteger): NSInteger;
  static textFileTypes(): NSArray<any>;
  static textPasteboardTypes(): NSArray<any>;
  static textUnfilteredFileTypes(): NSArray<any>;
  static textUnfilteredPasteboardTypes(): NSArray<any>;
  URLAtIndex_effectiveRange(location: NSUInteger, effectiveRange: NSRangePointer): NSURL;
  size(): NSSize;
  drawAtPoint(point: NSPoint): void;
  drawInRect(rect: NSRect): void;
  drawWithRect_options_context(rect: NSRect, options: NSStringDrawingOptions, context: NSStringDrawingContext | null): void;
  boundingRectWithSize_options_context(size: NSSize, options: NSStringDrawingOptions, context: NSStringDrawingContext | null): NSRect;
  drawWithRect_options(rect: NSRect, options: NSStringDrawingOptions): void;
  boundingRectWithSize_options(size: NSSize, options: NSStringDrawingOptions): NSRect;
  static attributedStringWithAttachment(attachment: NSTextAttachment): NSAttributedString;
  static attributedStringWithString_attributes(aString: NSString | string, attributes: NSDictionary<any, any> | {[key: string]: any}): NSAttributedString;
  static attributedStringWithString_font(aString: NSString | string, font: NSFont): NSAttributedString;
  heightWithFont_maxWidth(myFont: NSFont, myWidth: CGFloat): CGFloat;
  attributedStringWithHighlightColor(highlightColor: NSColor): NSAttributedString;
  attributeOrNil_atIndex(attrName: NSString | string, location: NSUInteger): any;
  attributesMatch(other: NSAttributedString): boolean;
  attributesMatch_comparison(other: NSAttributedString, compareBlock: CHStringAttributesCompareBlock): boolean;
  standardAttributedStringWithDocumentColorSpace(colorSpace: NSColorSpace): NSAttributedString;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  string(): NSString;
  length(): NSUInteger;
  static textTypes(): NSArray<any>;
  static textUnfilteredTypes(): NSArray<any>;
  containsAttachments(): boolean;
  static supportsSecureCoding(): boolean;
}

class NSMutableAttributedStringAllocator<T extends NSMutableAttributedString> extends NSAttributedStringAllocator<T> {}
declare class NSMutableAttributedString extends NSAttributedString {
  alloc<T extends NSMutableAttributedString>(): NSMutableAttributedStringAllocator<T>;
  replaceCharactersInRange_withString(range: NSRange, str: NSString | string): void;
  setAttributes_range(attrs: NSDictionary<any, any> | {[key: string]: any} | null, range: NSRange): void;
  addAttribute_value_range(name: NSAttributedStringKey, value: any, range: NSRange): void;
  addAttributes_range(attrs: NSDictionary<any, any> | {[key: string]: any}, range: NSRange): void;
  removeAttribute_range(name: NSAttributedStringKey, range: NSRange): void;
  replaceCharactersInRange_withAttributedString(range: NSRange, attrString: NSAttributedString): void;
  insertAttributedString_atIndex(attrString: NSAttributedString, loc: NSUInteger): void;
  appendAttributedString(attrString: NSAttributedString): void;
  deleteCharactersInRange(range: NSRange): void;
  setAttributedString(attrString: NSAttributedString): void;
  beginEditing(): void;
  endEditing(): void;
  fixAttributesInRange(range: NSRange): void;
  fixFontAttributeInRange(range: NSRange): void;
  fixParagraphStyleAttributeInRange(range: NSRange): void;
  fixAttachmentAttributeInRange(range: NSRange): void;
  readFromURL_options_documentAttributes_error(url: NSURL, opts: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  readFromData_options_documentAttributes_error(data: NSData, opts: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  superscriptRange(range: NSRange): void;
  subscriptRange(range: NSRange): void;
  unscriptRange(range: NSRange): void;
  applyFontTraits_range(traitMask: NSFontTraitMask, range: NSRange): void;
  setAlignment_range(alignment: NSTextAlignment, range: NSRange): void;
  setBaseWritingDirection_range(writingDirection: NSWritingDirection, range: NSRange): void;
  readFromURL_options_documentAttributes(url: NSURL, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}): boolean;
  readFromData_options_documentAttributes(data: NSData, options: NSDictionary<any, any> | {[key: string]: any}, dict: NSDictionary<any, any> | {[key: string]: any}): boolean;
  updateAttachmentsFromPath(path: NSString | string): void;
  appendString_attributes(string: NSString | string, attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  currentListStyle(): NSTextList;
  updateListStyle(newList: NSTextList): void;
  updateListFrom_toList(oldList: NSTextList, newList: NSTextList): void;
  removeUnsupportedAttributes(): void;

  mutableString(): NSMutableString;
}

declare type NSAttributedStringKey = NSString

declare enum NSAttributedStringEnumerationOptions {
  NSAttributedStringEnumerationReverse,
  NSAttributedStringEnumerationLongestEffectiveRangeNotRequired,
}

class NSAutoreleasePoolAllocator<T extends NSAutoreleasePool> extends NSObjectAllocator<T> {}
declare class NSAutoreleasePool extends NSObject {
  alloc<T extends NSAutoreleasePool>(): NSAutoreleasePoolAllocator<T>;
  addObject(anObject: any): void;
  drain(): void;
  static showPools(): void;
}

class NSBackgroundActivitySchedulerAllocator<T extends NSBackgroundActivityScheduler> extends NSObjectAllocator<T> {
  initWithIdentifier(identifier: NSString | string): T;
}
declare class NSBackgroundActivityScheduler extends NSObject {
  alloc<T extends NSBackgroundActivityScheduler>(): NSBackgroundActivitySchedulerAllocator<T>;
  scheduleWithBlock(block: Block): void;
  invalidate(): void;

  identifier(): NSString;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  repeats(): boolean;
  setRepeats(repeats: boolean): void;
  interval(): NSTimeInterval;
  setInterval(interval: NSTimeInterval): void;
  tolerance(): NSTimeInterval;
  setTolerance(tolerance: NSTimeInterval): void;
  shouldDefer(): boolean;
}

declare enum NSBackgroundActivityResult {
  NSBackgroundActivityResultFinished = 1,
  NSBackgroundActivityResultDeferred = 2,
}

class NSBundleAllocator<T extends NSBundle> extends NSObjectAllocator<T> {
  initWithPath(path: NSString | string): T;
  initWithURL(url: NSURL): T;
}
declare class NSBundle extends NSObject {
  alloc<T extends NSBundle>(): NSBundleAllocator<T>;
  static bundleWithPath(path: NSString | string): NSBundle;
  static bundleWithURL(url: NSURL): NSBundle;
  static bundleForClass(aClass: any): NSBundle;
  static bundleWithIdentifier(identifier: NSString | string): NSBundle;
  load(): boolean;
  unload(): boolean;
  preflightAndReturnError(error: NSError): boolean;
  loadAndReturnError(error: NSError): boolean;
  URLForAuxiliaryExecutable(executableName: NSString | string): NSURL;
  pathForAuxiliaryExecutable(executableName: NSString | string): NSString;
  static URLForResource_withExtension_subdirectory_inBundleWithURL(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null, bundleURL: NSURL): NSURL;
  static URLsForResourcesWithExtension_subdirectory_inBundleWithURL(ext: NSString | string | null, subpath: NSString | string | null, bundleURL: NSURL): NSArray<any>;
  URLForResource_withExtension(name: NSString | string | null, ext: NSString | string | null): NSURL;
  URLForResource_withExtension_subdirectory(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null): NSURL;
  URLForResource_withExtension_subdirectory_localization(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSURL;
  URLsForResourcesWithExtension_subdirectory(ext: NSString | string | null, subpath: NSString | string | null): NSArray<any>;
  URLsForResourcesWithExtension_subdirectory_localization(ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSArray<any>;
  pathForResource_ofType_inDirectory(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null): NSString;
  pathsForResourcesOfType_inDirectory(ext: NSString | string | null, subpath: NSString | string | null): NSArray<any>;
  pathForResource_ofType(name: NSString | string | null, ext: NSString | string | null): NSString;
  pathForResource_ofType_inDirectory_forLocalization(name: NSString | string | null, ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSString;
  pathsForResourcesOfType_inDirectory_forLocalization(ext: NSString | string | null, subpath: NSString | string | null, localizationName: NSString | string | null): NSArray<any>;
  objectForInfoDictionaryKey(key: NSString | string): any;
  classNamed(className: NSString | string): any;
  static preferredLocalizationsFromArray(localizationsArray: NSArray<any> | any[]): NSArray<any>;
  static preferredLocalizationsFromArray_forPreferences(localizationsArray: NSArray<any> | any[], preferencesArray: NSArray<any> | any[] | null): NSArray<any>;
  setPreservationPriority_forTags(priority: number, tags: NSSet<any>): void;
  preservationPriorityForTag(tag: NSString | string): number;
  contextHelpForKey(key: NSHelpManagerContextHelpKey): NSAttributedString;
  imageForResource(name: NSImageName): NSImage;
  pathForImageResource(name: NSImageName): NSString;
  URLForImageResource(name: NSImageName): NSURL;
  loadNibNamed_owner_topLevelObjects(nibName: NSNibName, owner: any | null, topLevelObjects: NSArray<any> | any[]): boolean;
  loadNibFile_externalNameTable_withZone(fileName: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, zone: NSZone): boolean;
  static loadNibNamed_owner(nibName: NSString | string, owner: any): boolean;
  pathForSoundResource(name: NSSoundName): NSString;
  bundleName(): NSString;
  bundleVersion(): NSString;
  bundleBuild(): NSString;
  bundleFullVersion(): NSString;
  bundleCopyright(): NSString;

  static mainBundle(): NSBundle;
  static allBundles(): NSArray<any>;
  static allFrameworks(): NSArray<any>;
  loaded(): boolean;
  bundleURL(): NSURL;
  resourceURL(): NSURL;
  executableURL(): NSURL;
  privateFrameworksURL(): NSURL;
  sharedFrameworksURL(): NSURL;
  sharedSupportURL(): NSURL;
  builtInPlugInsURL(): NSURL;
  appStoreReceiptURL(): NSURL;
  bundlePath(): NSString;
  resourcePath(): NSString;
  executablePath(): NSString;
  privateFrameworksPath(): NSString;
  sharedFrameworksPath(): NSString;
  sharedSupportPath(): NSString;
  builtInPlugInsPath(): NSString;
  bundleIdentifier(): NSString;
  infoDictionary(): NSDictionary<any, any>;
  localizedInfoDictionary(): NSDictionary<any, any>;
  principalClass(): any;
  preferredLocalizations(): NSArray<any>;
  localizations(): NSArray<any>;
  developmentLocalization(): NSString;
  executableArchitectures(): NSArray<any>;
}

class NSStringAllocator<T extends NSString> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCharactersNoCopy_length_freeWhenDone(characters: unichar, length: NSUInteger, freeBuffer: boolean): T;
  initWithCharacters_length(characters: unichar, length: NSUInteger): T;
  initWithUTF8String(nullTerminatedCString: string): T;
  initWithString(aString: NSString | string): T;
  initWithFormat(format: NSString | string, ...args: any[]): T;
  initWithFormat_arguments(format: NSString | string, ...argList: any[]): T;
  initWithFormat_locale(format: NSString | string, locale: any | null, ...args: any[]): T;
  initWithFormat_locale_arguments(format: NSString | string, locale: any | null, ...argList: any[]): T;
  initWithData_encoding(data: NSData, encoding: NSStringEncoding): T;
  initWithBytes_length_encoding(bytes: void, len: NSUInteger, encoding: NSStringEncoding): T;
  initWithBytesNoCopy_length_encoding_freeWhenDone(bytes: void, len: NSUInteger, encoding: NSStringEncoding, freeBuffer: boolean): T;
  initWithCString_encoding(nullTerminatedCString: string, encoding: NSStringEncoding): T;
  initWithContentsOfURL_encoding_error(url: NSURL, enc: NSStringEncoding, error: NSError): T;
  initWithContentsOfFile_encoding_error(path: NSString | string, enc: NSStringEncoding, error: NSError): T;
  initWithContentsOfURL_usedEncoding_error(url: NSURL, enc: NSStringEncoding | null, error: NSError): T;
  initWithContentsOfFile_usedEncoding_error(path: NSString | string, enc: NSStringEncoding | null, error: NSError): T;
  initWithContentsOfFile(path: NSString | string): T;
  initWithContentsOfURL(url: NSURL): T;
  initWithCStringNoCopy_length_freeWhenDone(bytes: string, length: NSUInteger, freeBuffer: boolean): T;
  initWithCString_length(bytes: string, length: NSUInteger): T;
  initWithCString(bytes: string): T;
}
declare class NSString extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSString>(): NSStringAllocator<T>;
  variantFittingPresentationWidth(width: NSInteger): NSString;
  linguisticTagsInRange_scheme_options_orthography_tokenRanges(range: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  enumerateLinguisticTagsInRange_scheme_options_orthography_usingBlock(range: NSRange, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, block: Block): void;
  static pathWithComponents(components: NSArray<any> | any[]): NSString;
  stringByAppendingPathComponent(str: NSString | string): NSString;
  stringByAppendingPathExtension(str: NSString | string): NSString;
  stringsByAppendingPaths(paths: NSArray<any> | any[]): NSArray<any>;
  completePathIntoString_caseSensitive_matchesIntoArray_filterTypes(outputName: NSString | string, flag: boolean, outputArray: NSArray<any> | any[], filterTypes: NSArray<any> | any[] | null): NSUInteger;
  getFileSystemRepresentation_maxLength(cname: string, max: NSUInteger): boolean;
  characterAtIndex(index: NSUInteger): unichar;
  substringFromIndex(from: NSUInteger): NSString;
  substringToIndex(to: NSUInteger): NSString;
  substringWithRange(range: NSRange): NSString;
  getCharacters_range(buffer: unichar, range: NSRange): void;
  compare(string: NSString | string): NSComparisonResult;
  compare_options(string: NSString | string, mask: NSStringCompareOptions): NSComparisonResult;
  compare_options_range(string: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToCompare: NSRange): NSComparisonResult;
  compare_options_range_locale(string: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToCompare: NSRange, locale: any | null): NSComparisonResult;
  caseInsensitiveCompare(string: NSString | string): NSComparisonResult;
  localizedCompare(string: NSString | string): NSComparisonResult;
  localizedCaseInsensitiveCompare(string: NSString | string): NSComparisonResult;
  localizedStandardCompare(string: NSString | string): NSComparisonResult;
  isEqualToString(aString: NSString | string): boolean;
  hasPrefix(str: NSString | string): boolean;
  hasSuffix(str: NSString | string): boolean;
  commonPrefixWithString_options(str: NSString | string, mask: NSStringCompareOptions): NSString;
  containsString(str: NSString | string): boolean;
  localizedCaseInsensitiveContainsString(str: NSString | string): boolean;
  localizedStandardContainsString(str: NSString | string): boolean;
  localizedStandardRangeOfString(str: NSString | string): NSRange;
  rangeOfString(searchString: NSString | string): NSRange;
  rangeOfString_options(searchString: NSString | string, mask: NSStringCompareOptions): NSRange;
  rangeOfString_options_range(searchString: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToSearch: NSRange): NSRange;
  rangeOfString_options_range_locale(searchString: NSString | string, mask: NSStringCompareOptions, rangeOfReceiverToSearch: NSRange, locale: NSLocale | null): NSRange;
  rangeOfCharacterFromSet(searchSet: NSCharacterSet): NSRange;
  rangeOfCharacterFromSet_options(searchSet: NSCharacterSet, mask: NSStringCompareOptions): NSRange;
  rangeOfCharacterFromSet_options_range(searchSet: NSCharacterSet, mask: NSStringCompareOptions, rangeOfReceiverToSearch: NSRange): NSRange;
  rangeOfComposedCharacterSequenceAtIndex(index: NSUInteger): NSRange;
  rangeOfComposedCharacterSequencesForRange(range: NSRange): NSRange;
  stringByAppendingString(aString: NSString | string): NSString;
  stringByAppendingFormat(format: NSString | string, ...args: any[]): NSString;
  uppercaseStringWithLocale(locale: NSLocale | null): NSString;
  lowercaseStringWithLocale(locale: NSLocale | null): NSString;
  capitalizedStringWithLocale(locale: NSLocale | null): NSString;
  getLineStart_end_contentsEnd_forRange(startPtr: NSUInteger | null, lineEndPtr: NSUInteger | null, contentsEndPtr: NSUInteger | null, range: NSRange): void;
  lineRangeForRange(range: NSRange): NSRange;
  getParagraphStart_end_contentsEnd_forRange(startPtr: NSUInteger | null, parEndPtr: NSUInteger | null, contentsEndPtr: NSUInteger | null, range: NSRange): void;
  paragraphRangeForRange(range: NSRange): NSRange;
  enumerateSubstringsInRange_options_usingBlock(range: NSRange, opts: NSStringEnumerationOptions, block: Block): void;
  enumerateLinesUsingBlock(block: Block): void;
  dataUsingEncoding_allowLossyConversion(encoding: NSStringEncoding, lossy: boolean): NSData;
  dataUsingEncoding(encoding: NSStringEncoding): NSData;
  canBeConvertedToEncoding(encoding: NSStringEncoding): boolean;
  cStringUsingEncoding(encoding: NSStringEncoding): string;
  getCString_maxLength_encoding(buffer: string, maxBufferCount: NSUInteger, encoding: NSStringEncoding): boolean;
  getBytes_maxLength_usedLength_encoding_options_range_remainingRange(buffer: void | null, maxBufferCount: NSUInteger, usedBufferCount: NSUInteger | null, encoding: NSStringEncoding, options: NSStringEncodingConversionOptions, range: NSRange, leftover: NSRangePointer | null): boolean;
  maximumLengthOfBytesUsingEncoding(enc: NSStringEncoding): NSUInteger;
  lengthOfBytesUsingEncoding(enc: NSStringEncoding): NSUInteger;
  static localizedNameOfStringEncoding(encoding: NSStringEncoding): NSString;
  componentsSeparatedByString(separator: NSString | string): NSArray<any>;
  componentsSeparatedByCharactersInSet(separator: NSCharacterSet): NSArray<any>;
  stringByTrimmingCharactersInSet(set: NSCharacterSet): NSString;
  stringByPaddingToLength_withString_startingAtIndex(newLength: NSUInteger, padString: NSString | string, padIndex: NSUInteger): NSString;
  stringByFoldingWithOptions_locale(options: NSStringCompareOptions, locale: NSLocale | null): NSString;
  stringByReplacingOccurrencesOfString_withString_options_range(target: NSString | string, replacement: NSString | string, options: NSStringCompareOptions, searchRange: NSRange): NSString;
  stringByReplacingOccurrencesOfString_withString(target: NSString | string, replacement: NSString | string): NSString;
  stringByReplacingCharactersInRange_withString(range: NSRange, replacement: NSString | string): NSString;
  stringByApplyingTransform_reverse(transform: NSStringTransform, reverse: boolean): NSString;
  writeToURL_atomically_encoding_error(url: NSURL, useAuxiliaryFile: boolean, enc: NSStringEncoding, error: NSError): boolean;
  writeToFile_atomically_encoding_error(path: NSString | string, useAuxiliaryFile: boolean, enc: NSStringEncoding, error: NSError): boolean;
  static string(): NSString;
  static stringWithString(string: NSString | string): NSString;
  static stringWithCharacters_length(characters: unichar, length: NSUInteger): NSString;
  static stringWithUTF8String(nullTerminatedCString: string): NSString;
  static stringWithFormat(format: NSString | string, ...args: any[]): NSString;
  static localizedStringWithFormat(format: NSString | string, ...args: any[]): NSString;
  static stringWithCString_encoding(cString: string, enc: NSStringEncoding): NSString;
  static stringWithContentsOfURL_encoding_error(url: NSURL, enc: NSStringEncoding, error: NSError): NSString;
  static stringWithContentsOfFile_encoding_error(path: NSString | string, enc: NSStringEncoding, error: NSError): NSString;
  static stringWithContentsOfURL_usedEncoding_error(url: NSURL, enc: NSStringEncoding | null, error: NSError): NSString;
  static stringWithContentsOfFile_usedEncoding_error(path: NSString | string, enc: NSStringEncoding | null, error: NSError): NSString;
  static stringEncodingForData_encodingOptions_convertedString_usedLossyConversion(data: NSData, opts: NSDictionary<any, any> | {[key: string]: any} | null, string: NSString | string, usedLossyConversion: boolean | null): NSStringEncoding;
  propertyList(): any;
  propertyListFromStringsFileFormat(): NSDictionary<any, any>;
  cString(): string;
  lossyCString(): string;
  cStringLength(): NSUInteger;
  getCString(bytes: string): void;
  getCString_maxLength(bytes: string, maxLength: NSUInteger): void;
  getCString_maxLength_range_remainingRange(bytes: string, maxLength: NSUInteger, aRange: NSRange, leftoverRange: NSRangePointer | null): void;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  static stringWithContentsOfFile(path: NSString | string): any;
  static stringWithContentsOfURL(url: NSURL): any;
  static stringWithCString_length(bytes: string, length: NSUInteger): any;
  static stringWithCString(bytes: string): any;
  getCharacters(buffer: unichar): void;
  stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet): NSString;
  stringByAddingPercentEscapesUsingEncoding(enc: NSStringEncoding): NSString;
  stringByReplacingPercentEscapesUsingEncoding(enc: NSStringEncoding): NSString;
  sizeWithAttributes(attrs: NSDictionary<any, any> | {[key: string]: any} | null): NSSize;
  drawAtPoint_withAttributes(point: NSPoint, attrs: NSDictionary<any, any> | {[key: string]: any} | null): void;
  drawInRect_withAttributes(rect: NSRect, attrs: NSDictionary<any, any> | {[key: string]: any} | null): void;
  drawWithRect_options_attributes_context(rect: NSRect, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null, context: NSStringDrawingContext | null): void;
  boundingRectWithSize_options_attributes_context(size: NSSize, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null, context: NSStringDrawingContext | null): NSRect;
  drawWithRect_options_attributes(rect: NSRect, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null): void;
  boundingRectWithSize_options_attributes(size: NSSize, options: NSStringDrawingOptions, attributes: NSDictionary<any, any> | {[key: string]: any} | null): NSRect;
  static stringRepresentationForSeconds(numberOfSeconds: NSUInteger): NSString;
  stringByDeletingPrefix(prefix: NSString | string): NSString;
  stringByDeletingSuffix(suffix: NSString | string): NSString;
  stringByStrippingStrings(strings: NSArray<any> | any[]): NSString;
  stringByAppendingPathComponents(components: NSArray<any> | any[]): NSString;
  startsWith(str: NSString | string): boolean;
  endsWith(str: NSString | string): boolean;
  endsWith_options(str: NSString | string, options: NSStringCompareOptions): boolean;
  containsSubstring(sub: NSString | string): boolean;
  containsCharacter(c: unichar): boolean;
  stringWithFirstCharacterLowercase(): NSString;
  trimmedString(): NSString;
  splitByBaseAndNumber(): NSDictionary<any, any>;
  uniqueStringComparedToStrings_includeCopySuffix(strings: NSSet<any>, shouldAppendCopySuffix: boolean): NSString;
  static stringWithPrefix_number(front: NSString | string, number: NSInteger): NSString;
  words(): NSArray<any>;
  safeSubstringToIndex_ms(index: NSUInteger): NSString;
  safeSubstringFromIndex_ms(index: NSUInteger): NSString;
  safeSubstringWithRange_ms(range: NSRange): NSString;
  parent(): NSString;
  child(childName: NSString | string): NSString;
  extension(): NSString;
  withoutExtension(): NSString;
  withExtension(extension: NSString | string): NSString;
  expandTilde(): NSString;
  hasExtension(extension: NSString | string): boolean;
  isValidEmailAddress(): boolean;
  stringBySplittingMixedCaps(): NSString;
  componentsSeparatedByMixedCaps(): NSArray<any>;
  lastLines(count: NSUInteger): NSString;
  firstLines(count: NSUInteger): NSString;
  matchesString_divergingAfter_atIndex_divergentChar_expectedChar(string: NSString | string | null, prefix: NSString | string, index: NSUInteger, divergentChar: string, expectedChar: string): boolean;
  matchesString_divergingAtLine_after_diverged_expected(string: NSString | string | null, divergingLine: NSUInteger, after: NSString | string, diverged: NSString | string, expected: NSString | string): boolean;
  matchesString_divergingAtLine1_andLine2_diverged_expected(string: NSString | string | null, line1: NSUInteger, line2: NSUInteger, diverged: NSString | string, expected: NSString | string): boolean;
  matchesString_divergingAtLine1_andLine2_diverged_expected_window(string: NSString | string | null, line1: NSUInteger, line2: NSUInteger, diverged: NSString | string, expected: NSString | string, window: NSInteger): boolean;
  drawAtPoint_withFont(aPoint: NSPoint, font: NSFont): void;
  drawCenteredAtPoint_withFont_color(aPoint: NSPoint, font: NSFont, color: NSColor): void;
  sizeWithFont(aFont: NSFont): NSSize;
  heightWithFont_maxWidth(myFont: NSFont, myWidth: CGFloat): CGFloat;
  fontSizeToFitStringWithAttributes_inSize_maximumFontSize(attributes: CHStringAttributes, aSize: NSSize, maxSize: NSInteger): NSInteger;
  fontSizeToFitStringWithAttributes_inSize(attributes: CHStringAttributes, aSize: NSSize): NSInteger;
  fontSizeToFitStringWithAttributes_inWidth(attributes: CHStringAttributes, width: NSInteger): NSInteger;
  fontSizeToFitStringWithAttributes_inHeight(attributes: CHStringAttributes, height: NSInteger): NSInteger;
  fitStringAttributes_inSize(attributes: CHStringAttributes, aSize: NSSize): void;
  fitStringAttributes_inWidth(attributes: CHStringAttributes, width: NSInteger): void;
  fitStringAttributes_inHeight(attributes: CHStringAttributes, height: NSInteger): void;
  colorValue(): NSColor;
  sRGBColorFromHexColor(): NSColor;
  enumerateWordRanges(block: CHStringWordEnumeratorBlock): void;
  wordRanges(): NSArray<any>;
  static stringWithUUID(): any;
  numberValueInContextOfSize_onAxis(size: NSRect, axis: BCAxis): NSNumber;
  stringBySanitizingForNumberFormatter(formatter: NSNumberFormatter | null): NSString;
  stringByCalculatingMath(): NSString;
  numberValueUsingMath(): NSNumber;
  containsMathSymbols(): boolean;
  mathPrefix(): NSString;
  numberValueByUsingNumberFormatter(): NSNumber;
  static nativeDecimalSeparator(): NSString;
  static mathStringWithOperand1_operator_operand2(operand1: CGFloat, operator: NSString | string, operand2: CGFloat): NSString;
  uniqueSlugUsingEarlierSlugs(earlierSlugs: NSMutableDictionary<any, any> | {[key: string]: any} | null): NSString;
  svgURL(): NSString;
  static svgStringWithPixelValue(value: CGFloat): NSString;
  static svgStringWithNumberValue(value: CGFloat): NSString;
  static svgStringWithPercentageValue(value: CGFloat): NSString;
  static svgStringWithPercentageFractionalValue(value: CGFloat): NSString;
  static stringWithInt_suffix(anInt: NSInteger, suffix: NSString | string): NSString;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  pathComponents(): NSArray<any>;
  absolutePath(): boolean;
  lastPathComponent(): NSString;
  stringByDeletingLastPathComponent(): NSString;
  pathExtension(): NSString;
  stringByDeletingPathExtension(): NSString;
  stringByAbbreviatingWithTildeInPath(): NSString;
  stringByExpandingTildeInPath(): NSString;
  stringByStandardizingPath(): NSString;
  stringByResolvingSymlinksInPath(): NSString;
  fileSystemRepresentation(): string;
  length(): NSUInteger;
  doubleValue(): number;
  floatValue(): number;
  intValue(): number;
  integerValue(): NSInteger;
  longLongValue(): number;
  boolValue(): boolean;
  uppercaseString(): NSString;
  lowercaseString(): NSString;
  capitalizedString(): NSString;
  localizedUppercaseString(): NSString;
  localizedLowercaseString(): NSString;
  localizedCapitalizedString(): NSString;
  UTF8String(): string;
  fastestEncoding(): NSStringEncoding;
  smallestEncoding(): NSStringEncoding;
  static availableStringEncodings(): NSStringEncoding;
  static defaultCStringEncoding(): NSStringEncoding;
  decomposedStringWithCanonicalMapping(): NSString;
  precomposedStringWithCanonicalMapping(): NSString;
  decomposedStringWithCompatibilityMapping(): NSString;
  precomposedStringWithCompatibilityMapping(): NSString;
  description(): NSString;
  hash(): NSUInteger;
  stringByRemovingPercentEncoding(): NSString;
  slug(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSBundleResourceRequestAllocator<T extends NSBundleResourceRequest> extends NSObjectAllocator<T> {
  initWithTags(tags: NSSet<any>): T;
  initWithTags_bundle(tags: NSSet<any>, bundle: NSBundle): T;
}
declare class NSBundleResourceRequest extends NSObject implements INSProgressReporting {
  alloc<T extends NSBundleResourceRequest>(): NSBundleResourceRequestAllocator<T>;
  beginAccessingResourcesWithCompletionHandler(completionHandler: Block): void;
  conditionallyBeginAccessingResourcesWithCompletionHandler(completionHandler: Block): void;
  endAccessingResources(): void;

  loadingPriority(): number;
  setLoadingPriority(loadingPriority: number): void;
  tags(): NSSet<any>;
  bundle(): NSBundle;
  progress(): NSProgress;
}

class NSByteCountFormatterAllocator<T extends NSByteCountFormatter> extends NSFormatterAllocator<T> {}
declare class NSByteCountFormatter extends NSFormatter {
  alloc<T extends NSByteCountFormatter>(): NSByteCountFormatterAllocator<T>;
  static stringFromByteCount_countStyle(byteCount: number, countStyle: NSByteCountFormatterCountStyle): NSString;
  stringFromByteCount(byteCount: number): NSString;

  allowedUnits(): NSByteCountFormatterUnits;
  setAllowedUnits(allowedUnits: NSByteCountFormatterUnits): void;
  countStyle(): NSByteCountFormatterCountStyle;
  setCountStyle(countStyle: NSByteCountFormatterCountStyle): void;
  allowsNonnumericFormatting(): boolean;
  setAllowsNonnumericFormatting(allowsNonnumericFormatting: boolean): void;
  includesUnit(): boolean;
  setIncludesUnit(includesUnit: boolean): void;
  includesCount(): boolean;
  setIncludesCount(includesCount: boolean): void;
  includesActualByteCount(): boolean;
  setIncludesActualByteCount(includesActualByteCount: boolean): void;
  adaptive(): boolean;
  setAdaptive(adaptive: boolean): void;
  zeroPadsFractionDigits(): boolean;
  setZeroPadsFractionDigits(zeroPadsFractionDigits: boolean): void;
  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
}

declare enum NSByteCountFormatterUnits {
  NSByteCountFormatterUseDefault = 0,
  NSByteCountFormatterUseBytes = 1 << 0,
  NSByteCountFormatterUseKB = 1 << 1,
  NSByteCountFormatterUseMB = 1 << 2,
  NSByteCountFormatterUseGB = 1 << 3,
  NSByteCountFormatterUseTB = 1 << 4,
  NSByteCountFormatterUsePB = 1 << 5,
  NSByteCountFormatterUseEB = 1 << 6,
  NSByteCountFormatterUseZB = 1 << 7,
  NSByteCountFormatterUseYBOrHigher = 0x0FF << 8,
  NSByteCountFormatterUseAll = 0x0FFFF,
}

declare enum NSByteCountFormatterCountStyle {
  NSByteCountFormatterCountStyleFile = 0,
  NSByteCountFormatterCountStyleMemory = 1,
  NSByteCountFormatterCountStyleDecimal = 2,
  NSByteCountFormatterCountStyleBinary = 3,
}

declare type NSSwappedFloat = {
  v: number
}

declare type NSSwappedDouble = {
  v: number
}

declare type NSCache = any

declare interface INSCacheDelegate {
  cache_willEvictObject(cache: NSCache, obj: any): void;
}

class NSCalendarAllocator<T extends NSCalendar> extends NSObjectAllocator<T> {
  initWithCalendarIdentifier(ident: NSCalendarIdentifier): T;
}
declare class NSCalendar extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSCalendar>(): NSCalendarAllocator<T>;
  static calendarWithIdentifier(calendarIdentifierConstant: NSCalendarIdentifier): NSCalendar;
  minimumRangeOfUnit(unit: NSCalendarUnit): NSRange;
  maximumRangeOfUnit(unit: NSCalendarUnit): NSRange;
  rangeOfUnit_inUnit_forDate(smaller: NSCalendarUnit, larger: NSCalendarUnit, date: NSDate): NSRange;
  ordinalityOfUnit_inUnit_forDate(smaller: NSCalendarUnit, larger: NSCalendarUnit, date: NSDate): NSUInteger;
  rangeOfUnit_startDate_interval_forDate(unit: NSCalendarUnit, datep: NSDate, tip: NSTimeInterval | null, date: NSDate): boolean;
  dateFromComponents(comps: NSDateComponents): NSDate;
  components_fromDate(unitFlags: NSCalendarUnit, date: NSDate): NSDateComponents;
  dateByAddingComponents_toDate_options(comps: NSDateComponents, date: NSDate, opts: NSCalendarOptions): NSDate;
  components_fromDate_toDate_options(unitFlags: NSCalendarUnit, startingDate: NSDate, resultDate: NSDate, opts: NSCalendarOptions): NSDateComponents;
  getEra_year_month_day_fromDate(eraValuePointer: NSInteger, yearValuePointer: NSInteger, monthValuePointer: NSInteger, dayValuePointer: NSInteger, date: NSDate): void;
  getEra_yearForWeekOfYear_weekOfYear_weekday_fromDate(eraValuePointer: NSInteger, yearValuePointer: NSInteger, weekValuePointer: NSInteger, weekdayValuePointer: NSInteger, date: NSDate): void;
  getHour_minute_second_nanosecond_fromDate(hourValuePointer: NSInteger, minuteValuePointer: NSInteger, secondValuePointer: NSInteger, nanosecondValuePointer: NSInteger, date: NSDate): void;
  component_fromDate(unit: NSCalendarUnit, date: NSDate): NSInteger;
  dateWithEra_year_month_day_hour_minute_second_nanosecond(eraValue: NSInteger, yearValue: NSInteger, monthValue: NSInteger, dayValue: NSInteger, hourValue: NSInteger, minuteValue: NSInteger, secondValue: NSInteger, nanosecondValue: NSInteger): NSDate;
  dateWithEra_yearForWeekOfYear_weekOfYear_weekday_hour_minute_second_nanosecond(eraValue: NSInteger, yearValue: NSInteger, weekValue: NSInteger, weekdayValue: NSInteger, hourValue: NSInteger, minuteValue: NSInteger, secondValue: NSInteger, nanosecondValue: NSInteger): NSDate;
  startOfDayForDate(date: NSDate): NSDate;
  componentsInTimeZone_fromDate(timezone: NSTimeZone, date: NSDate): NSDateComponents;
  compareDate_toDate_toUnitGranularity(date1: NSDate, date2: NSDate, unit: NSCalendarUnit): NSComparisonResult;
  isDate_equalToDate_toUnitGranularity(date1: NSDate, date2: NSDate, unit: NSCalendarUnit): boolean;
  isDate_inSameDayAsDate(date1: NSDate, date2: NSDate): boolean;
  isDateInToday(date: NSDate): boolean;
  isDateInYesterday(date: NSDate): boolean;
  isDateInTomorrow(date: NSDate): boolean;
  isDateInWeekend(date: NSDate): boolean;
  rangeOfWeekendStartDate_interval_containingDate(datep: NSDate, tip: NSTimeInterval, date: NSDate): boolean;
  nextWeekendStartDate_interval_options_afterDate(datep: NSDate, tip: NSTimeInterval, options: NSCalendarOptions, date: NSDate): boolean;
  components_fromDateComponents_toDateComponents_options(unitFlags: NSCalendarUnit, startingDateComp: NSDateComponents, resultDateComp: NSDateComponents, options: NSCalendarOptions): NSDateComponents;
  dateByAddingUnit_value_toDate_options(unit: NSCalendarUnit, value: NSInteger, date: NSDate, options: NSCalendarOptions): NSDate;
  enumerateDatesStartingAfterDate_matchingComponents_options_usingBlock(start: NSDate, comps: NSDateComponents, opts: NSCalendarOptions, block: Block): void;
  nextDateAfterDate_matchingComponents_options(date: NSDate, comps: NSDateComponents, options: NSCalendarOptions): NSDate;
  nextDateAfterDate_matchingUnit_value_options(date: NSDate, unit: NSCalendarUnit, value: NSInteger, options: NSCalendarOptions): NSDate;
  nextDateAfterDate_matchingHour_minute_second_options(date: NSDate, hourValue: NSInteger, minuteValue: NSInteger, secondValue: NSInteger, options: NSCalendarOptions): NSDate;
  dateBySettingUnit_value_ofDate_options(unit: NSCalendarUnit, v: NSInteger, date: NSDate, opts: NSCalendarOptions): NSDate;
  dateBySettingHour_minute_second_ofDate_options(h: NSInteger, m: NSInteger, s: NSInteger, date: NSDate, opts: NSCalendarOptions): NSDate;
  date_matchesComponents(date: NSDate, components: NSDateComponents): boolean;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  static currentCalendar(): NSCalendar;
  static autoupdatingCurrentCalendar(): NSCalendar;
  calendarIdentifier(): NSCalendarIdentifier;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  firstWeekday(): NSUInteger;
  setFirstWeekday(firstWeekday: NSUInteger): void;
  minimumDaysInFirstWeek(): NSUInteger;
  setMinimumDaysInFirstWeek(minimumDaysInFirstWeek: NSUInteger): void;
  eraSymbols(): NSArray<any>;
  longEraSymbols(): NSArray<any>;
  monthSymbols(): NSArray<any>;
  shortMonthSymbols(): NSArray<any>;
  veryShortMonthSymbols(): NSArray<any>;
  standaloneMonthSymbols(): NSArray<any>;
  shortStandaloneMonthSymbols(): NSArray<any>;
  veryShortStandaloneMonthSymbols(): NSArray<any>;
  weekdaySymbols(): NSArray<any>;
  shortWeekdaySymbols(): NSArray<any>;
  veryShortWeekdaySymbols(): NSArray<any>;
  standaloneWeekdaySymbols(): NSArray<any>;
  shortStandaloneWeekdaySymbols(): NSArray<any>;
  veryShortStandaloneWeekdaySymbols(): NSArray<any>;
  quarterSymbols(): NSArray<any>;
  shortQuarterSymbols(): NSArray<any>;
  standaloneQuarterSymbols(): NSArray<any>;
  shortStandaloneQuarterSymbols(): NSArray<any>;
  AMSymbol(): NSString;
  PMSymbol(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSDateComponentsAllocator<T extends NSDateComponents> extends NSObjectAllocator<T> {}
declare class NSDateComponents extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSDateComponents>(): NSDateComponentsAllocator<T>;
  setValue_forComponent(value: NSInteger, unit: NSCalendarUnit): void;
  valueForComponent(unit: NSCalendarUnit): NSInteger;
  isValidDateInCalendar(calendar: NSCalendar): boolean;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  era(): NSInteger;
  setEra(era: NSInteger): void;
  year(): NSInteger;
  setYear(year: NSInteger): void;
  month(): NSInteger;
  setMonth(month: NSInteger): void;
  day(): NSInteger;
  setDay(day: NSInteger): void;
  hour(): NSInteger;
  setHour(hour: NSInteger): void;
  minute(): NSInteger;
  setMinute(minute: NSInteger): void;
  second(): NSInteger;
  setSecond(second: NSInteger): void;
  nanosecond(): NSInteger;
  setNanosecond(nanosecond: NSInteger): void;
  weekday(): NSInteger;
  setWeekday(weekday: NSInteger): void;
  weekdayOrdinal(): NSInteger;
  setWeekdayOrdinal(weekdayOrdinal: NSInteger): void;
  quarter(): NSInteger;
  setQuarter(quarter: NSInteger): void;
  weekOfMonth(): NSInteger;
  setWeekOfMonth(weekOfMonth: NSInteger): void;
  weekOfYear(): NSInteger;
  setWeekOfYear(weekOfYear: NSInteger): void;
  yearForWeekOfYear(): NSInteger;
  setYearForWeekOfYear(yearForWeekOfYear: NSInteger): void;
  leapMonth(): boolean;
  setLeapMonth(leapMonth: boolean): void;
  date(): NSDate;
  validDate(): boolean;
  static supportsSecureCoding(): boolean;
}

declare type NSCalendarIdentifier = NSString

declare enum NSCalendarUnit {
  NSCalendarUnitEra,
  NSCalendarUnitYear,
  NSCalendarUnitMonth,
  NSCalendarUnitDay,
  NSCalendarUnitHour,
  NSCalendarUnitMinute,
  NSCalendarUnitSecond,
  NSCalendarUnitWeekday,
  NSCalendarUnitWeekdayOrdinal,
  NSCalendarUnitQuarter,
  NSCalendarUnitWeekOfMonth,
  NSCalendarUnitWeekOfYear,
  NSCalendarUnitYearForWeekOfYear,
  NSCalendarUnitNanosecond,
  NSCalendarUnitCalendar,
  NSCalendarUnitTimeZone,
  NSEraCalendarUnit,
  NSYearCalendarUnit,
  NSMonthCalendarUnit,
  NSDayCalendarUnit,
  NSHourCalendarUnit,
  NSMinuteCalendarUnit,
  NSSecondCalendarUnit,
  NSWeekCalendarUnit,
  NSWeekdayCalendarUnit,
  NSWeekdayOrdinalCalendarUnit,
  NSQuarterCalendarUnit,
  NSWeekOfMonthCalendarUnit,
  NSWeekOfYearCalendarUnit,
  NSYearForWeekOfYearCalendarUnit,
  NSCalendarCalendarUnit,
  NSTimeZoneCalendarUnit,
}

declare enum NSCalendarOptions {
  NSCalendarWrapComponents,
  NSCalendarMatchStrictly,
  NSCalendarSearchBackwards,
  NSCalendarMatchPreviousTimePreservingSmallerUnits,
  NSCalendarMatchNextTimePreservingSmallerUnits,
  NSCalendarMatchNextTime,
  NSCalendarMatchFirst,
  NSCalendarMatchLast,
}

class NSCalendarDateAllocator<T extends NSCalendarDate> extends NSDateAllocator<T> {}
declare class NSCalendarDate extends NSDate {
  alloc<T extends NSCalendarDate>(): NSCalendarDateAllocator<T>;
}

class NSDateAllocator<T extends NSDate> extends NSObjectAllocator<T> {
  init(): T;
  initWithTimeIntervalSinceReferenceDate(ti: NSTimeInterval): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithTimeIntervalSinceNow(secs: NSTimeInterval): T;
  initWithTimeIntervalSince1970(secs: NSTimeInterval): T;
  initWithTimeInterval_sinceDate(secsToBeAdded: NSTimeInterval, date: NSDate): T;
}
declare class NSDate extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSDate>(): NSDateAllocator<T>;
  timeIntervalSinceDate(anotherDate: NSDate): NSTimeInterval;
  addTimeInterval(seconds: NSTimeInterval): any;
  dateByAddingTimeInterval(ti: NSTimeInterval): NSDate;
  earlierDate(anotherDate: NSDate): NSDate;
  laterDate(anotherDate: NSDate): NSDate;
  compare(other: NSDate): NSComparisonResult;
  isEqualToDate(otherDate: NSDate): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  static date(): NSDate;
  static dateWithTimeIntervalSinceNow(secs: NSTimeInterval): NSDate;
  static dateWithTimeIntervalSinceReferenceDate(ti: NSTimeInterval): NSDate;
  static dateWithTimeIntervalSince1970(secs: NSTimeInterval): NSDate;
  static dateWithTimeInterval_sinceDate(secsToBeAdded: NSTimeInterval, date: NSDate): NSDate;
  static iso8601DateFormatter(): NSDateFormatter;
  iso8601(): NSString;
  static dateWithNTPRepresentation_bc(ntp: number): NSDate;
  NTPRepresentation_bc(): number;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  static timeIntervalSinceReferenceDate(): NSTimeInterval;
  timeIntervalSinceNow(): NSTimeInterval;
  timeIntervalSince1970(): NSTimeInterval;
  description(): NSString;
  static distantFuture(): NSDate;
  static distantPast(): NSDate;
  static supportsSecureCoding(): boolean;
}

class NSCharacterSetAllocator<T extends NSCharacterSet> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSCharacterSet extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSCharacterSet>(): NSCharacterSetAllocator<T>;
  static characterSetWithRange(aRange: NSRange): NSCharacterSet;
  static characterSetWithCharactersInString(aString: NSString | string): NSCharacterSet;
  static characterSetWithBitmapRepresentation(data: NSData): NSCharacterSet;
  static characterSetWithContentsOfFile(fName: NSString | string): NSCharacterSet;
  characterIsMember(aCharacter: unichar): boolean;
  longCharacterIsMember(theLongChar: string): boolean;
  isSupersetOfSet(theOtherSet: NSCharacterSet): boolean;
  hasMemberInPlane(thePlane: number): boolean;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  static controlCharacterSet(): NSCharacterSet;
  static whitespaceCharacterSet(): NSCharacterSet;
  static whitespaceAndNewlineCharacterSet(): NSCharacterSet;
  static decimalDigitCharacterSet(): NSCharacterSet;
  static letterCharacterSet(): NSCharacterSet;
  static lowercaseLetterCharacterSet(): NSCharacterSet;
  static uppercaseLetterCharacterSet(): NSCharacterSet;
  static nonBaseCharacterSet(): NSCharacterSet;
  static alphanumericCharacterSet(): NSCharacterSet;
  static decomposableCharacterSet(): NSCharacterSet;
  static illegalCharacterSet(): NSCharacterSet;
  static punctuationCharacterSet(): NSCharacterSet;
  static capitalizedLetterCharacterSet(): NSCharacterSet;
  static symbolCharacterSet(): NSCharacterSet;
  static newlineCharacterSet(): NSCharacterSet;
  bitmapRepresentation(): NSData;
  invertedSet(): NSCharacterSet;
  static URLUserAllowedCharacterSet(): NSCharacterSet;
  static URLPasswordAllowedCharacterSet(): NSCharacterSet;
  static URLHostAllowedCharacterSet(): NSCharacterSet;
  static URLPathAllowedCharacterSet(): NSCharacterSet;
  static URLQueryAllowedCharacterSet(): NSCharacterSet;
  static URLFragmentAllowedCharacterSet(): NSCharacterSet;
  static supportsSecureCoding(): boolean;
}

class NSMutableCharacterSetAllocator<T extends NSMutableCharacterSet> extends NSCharacterSetAllocator<T> {}
declare class NSMutableCharacterSet extends NSCharacterSet implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSMutableCharacterSet>(): NSMutableCharacterSetAllocator<T>;
  addCharactersInRange(aRange: NSRange): void;
  removeCharactersInRange(aRange: NSRange): void;
  addCharactersInString(aString: NSString | string): void;
  removeCharactersInString(aString: NSString | string): void;
  formUnionWithCharacterSet(otherSet: NSCharacterSet): void;
  formIntersectionWithCharacterSet(otherSet: NSCharacterSet): void;
  invert(): void;
  static controlCharacterSet(): NSMutableCharacterSet;
  static whitespaceCharacterSet(): NSMutableCharacterSet;
  static whitespaceAndNewlineCharacterSet(): NSMutableCharacterSet;
  static decimalDigitCharacterSet(): NSMutableCharacterSet;
  static letterCharacterSet(): NSMutableCharacterSet;
  static lowercaseLetterCharacterSet(): NSMutableCharacterSet;
  static uppercaseLetterCharacterSet(): NSMutableCharacterSet;
  static nonBaseCharacterSet(): NSMutableCharacterSet;
  static alphanumericCharacterSet(): NSMutableCharacterSet;
  static decomposableCharacterSet(): NSMutableCharacterSet;
  static illegalCharacterSet(): NSMutableCharacterSet;
  static punctuationCharacterSet(): NSMutableCharacterSet;
  static capitalizedLetterCharacterSet(): NSMutableCharacterSet;
  static symbolCharacterSet(): NSMutableCharacterSet;
  static newlineCharacterSet(): NSMutableCharacterSet;
  static characterSetWithRange(aRange: NSRange): NSMutableCharacterSet;
  static characterSetWithCharactersInString(aString: NSString | string): NSMutableCharacterSet;
  static characterSetWithBitmapRepresentation(data: NSData): NSMutableCharacterSet;
  static characterSetWithContentsOfFile(fName: NSString | string): NSMutableCharacterSet;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  static supportsSecureCoding(): boolean;
}

class NSClassDescriptionAllocator<T extends NSClassDescription> extends NSObjectAllocator<T> {}
declare class NSClassDescription extends NSObject {
  alloc<T extends NSClassDescription>(): NSClassDescriptionAllocator<T>;
  static registerClassDescription_forClass(description: NSClassDescription, aClass: any): void;
  static invalidateClassDescriptionCache(): void;
  static classDescriptionForClass(aClass: any): NSClassDescription;
  inverseForRelationshipKey(relationshipKey: NSString | string): NSString;

  attributeKeys(): NSArray<any>;
  toOneRelationshipKeys(): NSArray<any>;
  toManyRelationshipKeys(): NSArray<any>;
}

class NSCoderAllocator<T extends NSCoder> extends NSObjectAllocator<T> {}
declare class NSCoder extends NSObject {
  alloc<T extends NSCoder>(): NSCoderAllocator<T>;
  encodeValueOfObjCType_at(type: string, addr: void): void;
  encodeDataObject(data: NSData): void;
  decodeDataObject(): NSData;
  decodeValueOfObjCType_at_size(type: string, data: void, size: NSUInteger): void;
  versionForClassName(className: NSString | string): NSInteger;
  encodeObject(object: any | null): void;
  encodeRootObject(rootObject: any): void;
  encodeBycopyObject(anObject: any | null): void;
  encodeByrefObject(anObject: any | null): void;
  encodeConditionalObject(object: any | null): void;
  encodeValuesOfObjCTypes(types: string, ...args: any[]): void;
  encodeArrayOfObjCType_count_at(type: string, count: NSUInteger, array: void): void;
  encodeBytes_length(byteaddr: void | null, length: NSUInteger): void;
  decodeObject(): any;
  decodeValuesOfObjCTypes(types: string, ...args: any[]): void;
  decodeArrayOfObjCType_count_at(itemType: string, count: NSUInteger, array: void): void;
  decodeBytesWithReturnedLength(lengthp: NSUInteger): void;
  encodePropertyList(aPropertyList: any): void;
  decodePropertyList(): any;
  encodeObject_forKey(object: any | null, key: NSString | string): void;
  encodeConditionalObject_forKey(object: any | null, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeInt_forKey(value: number, key: NSString | string): void;
  encodeInt32_forKey(value: number, key: NSString | string): void;
  encodeInt64_forKey(value: number, key: NSString | string): void;
  encodeFloat_forKey(value: number, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBytes_length_forKey(bytes: number | null, length: NSUInteger, key: NSString | string): void;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeBoolForKey(key: NSString | string): boolean;
  decodeIntForKey(key: NSString | string): number;
  decodeInt32ForKey(key: NSString | string): number;
  decodeInt64ForKey(key: NSString | string): number;
  decodeFloatForKey(key: NSString | string): number;
  decodeDoubleForKey(key: NSString | string): number;
  decodeBytesForKey_returnedLength(key: NSString | string, lengthp: NSUInteger | null): number;
  encodeInteger_forKey(value: NSInteger, key: NSString | string): void;
  decodeIntegerForKey(key: NSString | string): NSInteger;
  decodeObjectOfClass_forKey(aClass: any, key: NSString | string): any;
  decodeObjectOfClasses_forKey(classes: NSSet<any> | null, key: NSString | string): any;
  decodePropertyListForKey(key: NSString | string): any;
  failWithError(error: NSError): void;
  encodeNXObject(object: any): void;
  decodeNXObject(): any;
  decodeValueOfObjCType_at(type: string, data: void): void;
  encodePoint(point: NSPoint): void;
  decodePoint(): NSPoint;
  encodeSize(size: NSSize): void;
  decodeSize(): NSSize;
  encodeRect(rect: NSRect): void;
  decodeRect(): NSRect;
  encodePoint_forKey(point: NSPoint, key: NSString | string): void;
  encodeSize_forKey(size: NSSize, key: NSString | string): void;
  encodeRect_forKey(rect: NSRect, key: NSString | string): void;
  decodePointForKey(key: NSString | string): NSPoint;
  decodeSizeForKey(key: NSString | string): NSSize;
  decodeRectForKey(key: NSString | string): NSRect;
  decodeNXColor(): NSColor;

  systemVersion(): number;
  allowsKeyedCoding(): boolean;
  requiresSecureCoding(): boolean;
  allowedClasses(): NSSet<any>;
  decodingFailurePolicy(): NSDecodingFailurePolicy;
  error(): NSError;
}

declare enum NSDecodingFailurePolicy {
  NSDecodingFailurePolicyRaiseException,
  NSDecodingFailurePolicySetErrorAndReturn,
}

class NSComparisonPredicateAllocator<T extends NSComparisonPredicate> extends NSPredicateAllocator<T> {
  initWithLeftExpression_rightExpression_modifier_type_options(lhs: NSExpression, rhs: NSExpression, modifier: NSComparisonPredicateModifier, type: NSPredicateOperatorType, options: NSComparisonPredicateOptions): T;
  initWithLeftExpression_rightExpression_customSelector(lhs: NSExpression, rhs: NSExpression, selector: string): T;
  initWithCoder(coder: NSCoder): T;
}
declare class NSComparisonPredicate extends NSPredicate {
  alloc<T extends NSComparisonPredicate>(): NSComparisonPredicateAllocator<T>;
  static predicateWithLeftExpression_rightExpression_modifier_type_options(lhs: NSExpression, rhs: NSExpression, modifier: NSComparisonPredicateModifier, type: NSPredicateOperatorType, options: NSComparisonPredicateOptions): NSComparisonPredicate;
  static predicateWithLeftExpression_rightExpression_customSelector(lhs: NSExpression, rhs: NSExpression, selector: string): NSComparisonPredicate;

  predicateOperatorType(): NSPredicateOperatorType;
  comparisonPredicateModifier(): NSComparisonPredicateModifier;
  leftExpression(): NSExpression;
  rightExpression(): NSExpression;
  customSelector(): string;
  options(): NSComparisonPredicateOptions;
}

declare enum NSComparisonPredicateOptions {
  NSCaseInsensitivePredicateOption = 0x01,
  NSDiacriticInsensitivePredicateOption = 0x02,
  NSNormalizedPredicateOption = 0x04,
}

declare enum NSComparisonPredicateModifier {
  NSDirectPredicateModifier = 0,
  NSAllPredicateModifier,
  NSAnyPredicateModifier,
}

declare enum NSPredicateOperatorType {
  NSLessThanPredicateOperatorType = 0,
  NSLessThanOrEqualToPredicateOperatorType,
  NSGreaterThanPredicateOperatorType,
  NSGreaterThanOrEqualToPredicateOperatorType,
  NSEqualToPredicateOperatorType,
  NSNotEqualToPredicateOperatorType,
  NSMatchesPredicateOperatorType,
  NSLikePredicateOperatorType,
  NSBeginsWithPredicateOperatorType,
  NSEndsWithPredicateOperatorType,
  NSInPredicateOperatorType,
  NSCustomSelectorPredicateOperatorType,
  NSContainsPredicateOperatorType = 99,
  NSBetweenPredicateOperatorType,
}

class NSCompoundPredicateAllocator<T extends NSCompoundPredicate> extends NSPredicateAllocator<T> {
  initWithType_subpredicates(type: NSCompoundPredicateType, subpredicates: NSArray<any> | any[]): T;
  initWithCoder(coder: NSCoder): T;
}
declare class NSCompoundPredicate extends NSPredicate {
  alloc<T extends NSCompoundPredicate>(): NSCompoundPredicateAllocator<T>;

  compoundPredicateType(): NSCompoundPredicateType;
  subpredicates(): NSArray<any>;
}

declare enum NSCompoundPredicateType {
  NSNotPredicateType = 0,
  NSAndPredicateType,
  NSOrPredicateType,
}

class NSConnectionAllocator<T extends NSConnection> extends NSObjectAllocator<T> {
  initWithReceivePort_sendPort(receivePort: NSPort | null, sendPort: NSPort | null): T;
}
declare class NSConnection extends NSObject {
  alloc<T extends NSConnection>(): NSConnectionAllocator<T>;
  static allConnections(): NSArray<any>;
  static defaultConnection(): NSConnection;
  static connectionWithRegisteredName_host(name: NSString | string, hostName: NSString | string | null): NSConnection;
  static connectionWithRegisteredName_host_usingNameServer(name: NSString | string, hostName: NSString | string | null, server: NSPortNameServer): NSConnection;
  static rootProxyForConnectionWithRegisteredName_host(name: NSString | string, hostName: NSString | string | null): NSDistantObject;
  static rootProxyForConnectionWithRegisteredName_host_usingNameServer(name: NSString | string, hostName: NSString | string | null, server: NSPortNameServer): NSDistantObject;
  static serviceConnectionWithName_rootObject_usingNameServer(name: NSString | string, root: any, server: NSPortNameServer): NSConnection;
  static serviceConnectionWithName_rootObject(name: NSString | string, root: any): NSConnection;
  invalidate(): void;
  addRequestMode(rmode: NSString | string): void;
  removeRequestMode(rmode: NSString | string): void;
  registerName(name: NSString | string | null): boolean;
  registerName_withNameServer(name: NSString | string | null, server: NSPortNameServer): boolean;
  static connectionWithReceivePort_sendPort(receivePort: NSPort | null, sendPort: NSPort | null): NSConnection;
  static currentConversation(): any;
  enableMultipleThreads(): void;
  addRunLoop(runloop: NSRunLoop): void;
  removeRunLoop(runloop: NSRunLoop): void;
  runInNewThread(): void;
  dispatchWithComponents(components: NSArray<any> | any[]): void;

  statistics(): NSDictionary<any, any>;
  requestTimeout(): NSTimeInterval;
  setRequestTimeout(requestTimeout: NSTimeInterval): void;
  replyTimeout(): NSTimeInterval;
  setReplyTimeout(replyTimeout: NSTimeInterval): void;
  rootObject(): any;
  setRootObject(rootObject: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  independentConversationQueueing(): boolean;
  setIndependentConversationQueueing(independentConversationQueueing: boolean): void;
  valid(): boolean;
  rootProxy(): NSDistantObject;
  requestModes(): NSArray<any>;
  sendPort(): NSPort;
  receivePort(): NSPort;
  multipleThreadsEnabled(): boolean;
  remoteObjects(): NSArray<any>;
  localObjects(): NSArray<any>;
}

class NSDistantObjectRequestAllocator<T extends NSDistantObjectRequest> extends NSObjectAllocator<T> {}
declare class NSDistantObjectRequest extends NSObject {
  alloc<T extends NSDistantObjectRequest>(): NSDistantObjectRequestAllocator<T>;
  replyWithException(exception: NSException | Error | null): void;

  invocation(): NSInvocation;
  connection(): NSConnection;
  conversation(): any;
}

declare interface INSConnectionDelegate {
  makeNewConnection_sender(conn: NSConnection, ancestor: NSConnection): boolean;
  connection_shouldMakeNewConnection(ancestor: NSConnection, conn: NSConnection): boolean;
  authenticationDataForComponents(components: NSArray<any> | any[]): NSData;
  authenticateComponents_withData(components: NSArray<any> | any[], signature: NSData): boolean;
  createConversationForConnection(conn: NSConnection): any;
  connection_handleRequest(connection: NSConnection, doreq: NSDistantObjectRequest): boolean;
}

class NSDataAllocator<T extends NSData> extends NSObjectAllocator<T> {
  initWithBytes_length(bytes: void | null, length: NSUInteger): T;
  initWithBytesNoCopy_length(bytes: void, length: NSUInteger): T;
  initWithBytesNoCopy_length_freeWhenDone(bytes: void, length: NSUInteger, b: boolean): T;
  initWithBytesNoCopy_length_deallocator(bytes: void, length: NSUInteger, deallocator: Block | null): T;
  initWithContentsOfFile_options_error(path: NSString | string, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): T;
  initWithContentsOfURL_options_error(url: NSURL, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): T;
  initWithContentsOfFile(path: NSString | string): T;
  initWithContentsOfURL(url: NSURL): T;
  initWithData(data: NSData): T;
  initWithBase64EncodedString_options(base64String: NSString | string, options: NSDataBase64DecodingOptions): T;
  initWithBase64EncodedData_options(base64Data: NSData, options: NSDataBase64DecodingOptions): T;
  initWithContentsOfMappedFile(path: NSString | string): T;
  initWithBase64Encoding(base64String: NSString | string): T;
}
declare class NSData extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSData>(): NSDataAllocator<T>;
  getBytes_length(buffer: void, length: NSUInteger): void;
  getBytes_range(buffer: void, range: NSRange): void;
  isEqualToData(other: NSData): boolean;
  subdataWithRange(range: NSRange): NSData;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  writeToFile_options_error(path: NSString | string, writeOptionsMask: NSDataWritingOptions, errorPtr: NSError): boolean;
  writeToURL_options_error(url: NSURL, writeOptionsMask: NSDataWritingOptions, errorPtr: NSError): boolean;
  rangeOfData_options_range(dataToFind: NSData, mask: NSDataSearchOptions, searchRange: NSRange): NSRange;
  enumerateByteRangesUsingBlock(block: Block): void;
  static data(): NSData;
  static dataWithBytes_length(bytes: void | null, length: NSUInteger): NSData;
  static dataWithBytesNoCopy_length(bytes: void, length: NSUInteger): NSData;
  static dataWithBytesNoCopy_length_freeWhenDone(bytes: void, length: NSUInteger, b: boolean): NSData;
  static dataWithContentsOfFile_options_error(path: NSString | string, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): NSData;
  static dataWithContentsOfURL_options_error(url: NSURL, readOptionsMask: NSDataReadingOptions, errorPtr: NSError): NSData;
  static dataWithContentsOfFile(path: NSString | string): NSData;
  static dataWithContentsOfURL(url: NSURL): NSData;
  static dataWithData(data: NSData): NSData;
  base64EncodedStringWithOptions(options: NSDataBase64EncodingOptions): NSString;
  base64EncodedDataWithOptions(options: NSDataBase64EncodingOptions): NSData;
  getBytes(buffer: void): void;
  static dataWithContentsOfMappedFile(path: NSString | string): any;
  base64Encoding(): NSString;
  sha1(): NSData;
  sha1AsString(): NSString;
  dataByCompressingWithAlgorithm_bc(algorithm: compression_algorithm): NSData;
  dataByDecompressing_bc(): NSData;
  hexString(): NSString;
  static dataWithBase64Encoding_xcd(base64String: NSString | string): any;
  base64Encoding_xcd(): NSString;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  length(): NSUInteger;
  bytes(): void;
  description(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSMutableDataAllocator<T extends NSMutableData> extends NSDataAllocator<T> {
  initWithCapacity(capacity: NSUInteger): T;
  initWithLength(length: NSUInteger): T;
}
declare class NSMutableData extends NSData {
  alloc<T extends NSMutableData>(): NSMutableDataAllocator<T>;
  appendBytes_length(bytes: void, length: NSUInteger): void;
  appendData(other: NSData): void;
  increaseLengthBy(extraLength: NSUInteger): void;
  replaceBytesInRange_withBytes(range: NSRange, bytes: void): void;
  resetBytesInRange(range: NSRange): void;
  setData(data: NSData): void;
  replaceBytesInRange_withBytes_length(range: NSRange, replacementBytes: void | null, replacementLength: NSUInteger): void;
  static dataWithCapacity(aNumItems: NSUInteger): NSMutableData;
  static dataWithLength(length: NSUInteger): NSMutableData;

  mutableBytes(): void;
  length(): NSUInteger;
  setLength(length: NSUInteger): void;
}

class NSPurgeableDataAllocator<T extends NSPurgeableData> extends NSMutableDataAllocator<T> {}
declare class NSPurgeableData extends NSMutableData implements INSDiscardableContent {
  alloc<T extends NSPurgeableData>(): NSPurgeableDataAllocator<T>;
  beginContentAccess(): boolean;
  endContentAccess(): void;
  discardContentIfPossible(): void;
  isContentDiscarded(): boolean;
  beginContentAccess(): boolean;
  endContentAccess(): void;
  discardContentIfPossible(): void;
  isContentDiscarded(): boolean;
}

declare enum NSDataReadingOptions {
  NSDataReadingMappedIfSafe = 1 << 0,
  NSDataReadingUncached = 1 << 1,
  NSDataReadingMappedAlways = 1 << 3,
  NSDataReadingMapped,
  NSMappedRead,
  NSUncachedRead,
}

declare enum NSDataWritingOptions {
  NSDataWritingAtomic = 1 << 0,
  NSDataWritingWithoutOverwriting = 1 << 1,
  NSDataWritingFileProtectionNone = 0x10000000,
  NSDataWritingFileProtectionComplete = 0x20000000,
  NSDataWritingFileProtectionCompleteUnlessOpen = 0x30000000,
  NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication = 0x40000000,
  NSDataWritingFileProtectionMask = 0xf0000000,
  NSAtomicWrite,
}

declare enum NSDataSearchOptions {
  NSDataSearchBackwards = 1 << 0,
  NSDataSearchAnchored = 1 << 1,
}

declare enum NSDataBase64EncodingOptions {
  NSDataBase64Encoding64CharacterLineLength = 1 << 0,
  NSDataBase64Encoding76CharacterLineLength = 1 << 1,
  NSDataBase64EncodingEndLineWithCarriageReturn = 1 << 4,
  NSDataBase64EncodingEndLineWithLineFeed = 1 << 5,
}

declare enum NSDataBase64DecodingOptions {
  NSDataBase64DecodingIgnoreUnknownCharacters = 1 << 0,
}

declare type NSTimeInterval = number

class NSDateComponentsFormatterAllocator<T extends NSDateComponentsFormatter> extends NSFormatterAllocator<T> {}
declare class NSDateComponentsFormatter extends NSFormatter {
  alloc<T extends NSDateComponentsFormatter>(): NSDateComponentsFormatterAllocator<T>;
  stringForObjectValue(obj: any | null): NSString;
  stringFromDateComponents(components: NSDateComponents): NSString;
  stringFromDate_toDate(startDate: NSDate, endDate: NSDate): NSString;
  stringFromTimeInterval(ti: NSTimeInterval): NSString;
  static localizedStringFromDateComponents_unitsStyle(components: NSDateComponents, unitsStyle: NSDateComponentsFormatterUnitsStyle): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  unitsStyle(): NSDateComponentsFormatterUnitsStyle;
  setUnitsStyle(unitsStyle: NSDateComponentsFormatterUnitsStyle): void;
  allowedUnits(): NSCalendarUnit;
  setAllowedUnits(allowedUnits: NSCalendarUnit): void;
  zeroFormattingBehavior(): NSDateComponentsFormatterZeroFormattingBehavior;
  setZeroFormattingBehavior(zeroFormattingBehavior: NSDateComponentsFormatterZeroFormattingBehavior): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  referenceDate(): NSDate;
  setReferenceDate(referenceDate: NSDate): void;
  allowsFractionalUnits(): boolean;
  setAllowsFractionalUnits(allowsFractionalUnits: boolean): void;
  maximumUnitCount(): NSInteger;
  setMaximumUnitCount(maximumUnitCount: NSInteger): void;
  collapsesLargestUnit(): boolean;
  setCollapsesLargestUnit(collapsesLargestUnit: boolean): void;
  includesApproximationPhrase(): boolean;
  setIncludesApproximationPhrase(includesApproximationPhrase: boolean): void;
  includesTimeRemainingPhrase(): boolean;
  setIncludesTimeRemainingPhrase(includesTimeRemainingPhrase: boolean): void;
  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
}

declare enum NSDateComponentsFormatterUnitsStyle {
  NSDateComponentsFormatterUnitsStylePositional = 0,
  NSDateComponentsFormatterUnitsStyleAbbreviated,
  NSDateComponentsFormatterUnitsStyleShort,
  NSDateComponentsFormatterUnitsStyleFull,
  NSDateComponentsFormatterUnitsStyleSpellOut,
  NSDateComponentsFormatterUnitsStyleBrief,
}

declare enum NSDateComponentsFormatterZeroFormattingBehavior {
  NSDateComponentsFormatterZeroFormattingBehaviorNone,
  NSDateComponentsFormatterZeroFormattingBehaviorDefault,
  NSDateComponentsFormatterZeroFormattingBehaviorDropLeading,
  NSDateComponentsFormatterZeroFormattingBehaviorDropMiddle,
  NSDateComponentsFormatterZeroFormattingBehaviorDropTrailing,
  NSDateComponentsFormatterZeroFormattingBehaviorDropAll,
  NSDateComponentsFormatterZeroFormattingBehaviorPad,
}

class NSDateFormatterAllocator<T extends NSDateFormatter> extends NSFormatterAllocator<T> {}
declare class NSDateFormatter extends NSFormatter {
  alloc<T extends NSDateFormatter>(): NSDateFormatterAllocator<T>;
  getObjectValue_forString_range_error(obj: any, string: NSString | string, rangep: NSRange, error: NSError): boolean;
  stringFromDate(date: NSDate): NSString;
  dateFromString(string: NSString | string): NSDate;
  static localizedStringFromDate_dateStyle_timeStyle(date: NSDate, dstyle: NSDateFormatterStyle, tstyle: NSDateFormatterStyle): NSString;
  static dateFormatFromTemplate_options_locale(tmplate: NSString | string, opts: NSUInteger, locale: NSLocale | null): NSString;
  setLocalizedDateFormatFromTemplate(dateFormatTemplate: NSString | string): void;

  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
  static defaultFormatterBehavior(): NSDateFormatterBehavior;
  static setDefaultFormatterBehavior(defaultFormatterBehavior: NSDateFormatterBehavior): void;
  dateFormat(): NSString;
  setDateFormat(dateFormat: NSString | string): void;
  dateStyle(): NSDateFormatterStyle;
  setDateStyle(dateStyle: NSDateFormatterStyle): void;
  timeStyle(): NSDateFormatterStyle;
  setTimeStyle(timeStyle: NSDateFormatterStyle): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  generatesCalendarDates(): boolean;
  setGeneratesCalendarDates(generatesCalendarDates: boolean): void;
  formatterBehavior(): NSDateFormatterBehavior;
  setFormatterBehavior(formatterBehavior: NSDateFormatterBehavior): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  lenient(): boolean;
  setLenient(lenient: boolean): void;
  twoDigitStartDate(): NSDate;
  setTwoDigitStartDate(twoDigitStartDate: NSDate): void;
  defaultDate(): NSDate;
  setDefaultDate(defaultDate: NSDate): void;
  eraSymbols(): NSArray<any>;
  setEraSymbols(eraSymbols: NSArray<any> | any[]): void;
  monthSymbols(): NSArray<any>;
  setMonthSymbols(monthSymbols: NSArray<any> | any[]): void;
  shortMonthSymbols(): NSArray<any>;
  setShortMonthSymbols(shortMonthSymbols: NSArray<any> | any[]): void;
  weekdaySymbols(): NSArray<any>;
  setWeekdaySymbols(weekdaySymbols: NSArray<any> | any[]): void;
  shortWeekdaySymbols(): NSArray<any>;
  setShortWeekdaySymbols(shortWeekdaySymbols: NSArray<any> | any[]): void;
  AMSymbol(): NSString;
  setAMSymbol(AMSymbol: NSString | string): void;
  PMSymbol(): NSString;
  setPMSymbol(PMSymbol: NSString | string): void;
  longEraSymbols(): NSArray<any>;
  setLongEraSymbols(longEraSymbols: NSArray<any> | any[]): void;
  veryShortMonthSymbols(): NSArray<any>;
  setVeryShortMonthSymbols(veryShortMonthSymbols: NSArray<any> | any[]): void;
  standaloneMonthSymbols(): NSArray<any>;
  setStandaloneMonthSymbols(standaloneMonthSymbols: NSArray<any> | any[]): void;
  shortStandaloneMonthSymbols(): NSArray<any>;
  setShortStandaloneMonthSymbols(shortStandaloneMonthSymbols: NSArray<any> | any[]): void;
  veryShortStandaloneMonthSymbols(): NSArray<any>;
  setVeryShortStandaloneMonthSymbols(veryShortStandaloneMonthSymbols: NSArray<any> | any[]): void;
  veryShortWeekdaySymbols(): NSArray<any>;
  setVeryShortWeekdaySymbols(veryShortWeekdaySymbols: NSArray<any> | any[]): void;
  standaloneWeekdaySymbols(): NSArray<any>;
  setStandaloneWeekdaySymbols(standaloneWeekdaySymbols: NSArray<any> | any[]): void;
  shortStandaloneWeekdaySymbols(): NSArray<any>;
  setShortStandaloneWeekdaySymbols(shortStandaloneWeekdaySymbols: NSArray<any> | any[]): void;
  veryShortStandaloneWeekdaySymbols(): NSArray<any>;
  setVeryShortStandaloneWeekdaySymbols(veryShortStandaloneWeekdaySymbols: NSArray<any> | any[]): void;
  quarterSymbols(): NSArray<any>;
  setQuarterSymbols(quarterSymbols: NSArray<any> | any[]): void;
  shortQuarterSymbols(): NSArray<any>;
  setShortQuarterSymbols(shortQuarterSymbols: NSArray<any> | any[]): void;
  standaloneQuarterSymbols(): NSArray<any>;
  setStandaloneQuarterSymbols(standaloneQuarterSymbols: NSArray<any> | any[]): void;
  shortStandaloneQuarterSymbols(): NSArray<any>;
  setShortStandaloneQuarterSymbols(shortStandaloneQuarterSymbols: NSArray<any> | any[]): void;
  gregorianStartDate(): NSDate;
  setGregorianStartDate(gregorianStartDate: NSDate): void;
  doesRelativeDateFormatting(): boolean;
  setDoesRelativeDateFormatting(doesRelativeDateFormatting: boolean): void;
}

declare enum NSDateFormatterStyle {
  NSDateFormatterNoStyle = 0,
  NSDateFormatterShortStyle = 1,
  NSDateFormatterMediumStyle = 2,
  NSDateFormatterLongStyle = 3,
  NSDateFormatterFullStyle = 4,
}

declare enum NSDateFormatterBehavior {
  NSDateFormatterBehaviorDefault = 0,
  NSDateFormatterBehavior10_0 = 1000,
}

class NSDateIntervalAllocator<T extends NSDateInterval> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithStartDate_duration(startDate: NSDate, duration: NSTimeInterval): T;
  initWithStartDate_endDate(startDate: NSDate, endDate: NSDate): T;
}
declare class NSDateInterval extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSDateInterval>(): NSDateIntervalAllocator<T>;
  compare(dateInterval: NSDateInterval): NSComparisonResult;
  isEqualToDateInterval(dateInterval: NSDateInterval): boolean;
  intersectsDateInterval(dateInterval: NSDateInterval): boolean;
  intersectionWithDateInterval(dateInterval: NSDateInterval): NSDateInterval;
  containsDate(date: NSDate): boolean;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  startDate(): NSDate;
  endDate(): NSDate;
  duration(): NSTimeInterval;
  static supportsSecureCoding(): boolean;
}

class NSDateIntervalFormatterAllocator<T extends NSDateIntervalFormatter> extends NSFormatterAllocator<T> {}
declare class NSDateIntervalFormatter extends NSFormatter {
  alloc<T extends NSDateIntervalFormatter>(): NSDateIntervalFormatterAllocator<T>;
  stringFromDate_toDate(fromDate: NSDate, toDate: NSDate): NSString;
  stringFromDateInterval(dateInterval: NSDateInterval): NSString;

  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  dateTemplate(): NSString;
  setDateTemplate(dateTemplate: NSString | string): void;
  dateStyle(): NSDateIntervalFormatterStyle;
  setDateStyle(dateStyle: NSDateIntervalFormatterStyle): void;
  timeStyle(): NSDateIntervalFormatterStyle;
  setTimeStyle(timeStyle: NSDateIntervalFormatterStyle): void;
}

declare enum NSDateIntervalFormatterStyle {
  NSDateIntervalFormatterNoStyle = 0,
  NSDateIntervalFormatterShortStyle = 1,
  NSDateIntervalFormatterMediumStyle = 2,
  NSDateIntervalFormatterLongStyle = 3,
  NSDateIntervalFormatterFullStyle = 4,
}

declare type NSDecimal = any

declare enum NSRoundingMode {
  NSRoundPlain,
  NSRoundDown,
  NSRoundUp,
  NSRoundBankers,
}

declare enum NSCalculationError {
  NSCalculationNoError = 0,
  NSCalculationLossOfPrecision,
  NSCalculationUnderflow,
  NSCalculationOverflow,
  NSCalculationDivideByZero,
}

class NSDecimalNumberAllocator<T extends NSDecimalNumber> extends NSNumberAllocator<T> {
  initWithMantissa_exponent_isNegative(mantissa: number, exponent: number, flag: boolean): T;
  initWithDecimal(dcm: NSDecimal): T;
  initWithString(numberValue: NSString | string | null): T;
  initWithString_locale(numberValue: NSString | string | null, locale: any | null): T;
}
declare class NSDecimalNumber extends NSNumber {
  alloc<T extends NSDecimalNumber>(): NSDecimalNumberAllocator<T>;
  descriptionWithLocale(locale: any | null): NSString;
  static decimalNumberWithMantissa_exponent_isNegative(mantissa: number, exponent: number, flag: boolean): NSDecimalNumber;
  static decimalNumberWithDecimal(dcm: NSDecimal): NSDecimalNumber;
  static decimalNumberWithString(numberValue: NSString | string | null): NSDecimalNumber;
  static decimalNumberWithString_locale(numberValue: NSString | string | null, locale: any | null): NSDecimalNumber;
  decimalNumberByAdding(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberByAdding_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberBySubtracting(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberBySubtracting_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberByMultiplyingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberByMultiplyingBy_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberByDividingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;
  decimalNumberByDividingBy_withBehavior(decimalNumber: NSDecimalNumber, behavior: any | null): NSDecimalNumber;
  decimalNumberByRaisingToPower(power: NSUInteger): NSDecimalNumber;
  decimalNumberByRaisingToPower_withBehavior(power: NSUInteger, behavior: any | null): NSDecimalNumber;
  decimalNumberByMultiplyingByPowerOf10(power: number): NSDecimalNumber;
  decimalNumberByMultiplyingByPowerOf10_withBehavior(power: number, behavior: any | null): NSDecimalNumber;
  decimalNumberByRoundingAccordingToBehavior(behavior: any | null): NSDecimalNumber;
  compare(decimalNumber: NSNumber | number): NSComparisonResult;

  decimalValue(): NSDecimal;
  static zero(): NSDecimalNumber;
  static one(): NSDecimalNumber;
  static minimumDecimalNumber(): NSDecimalNumber;
  static maximumDecimalNumber(): NSDecimalNumber;
  static notANumber(): NSDecimalNumber;
  static defaultBehavior(): any;
  static setDefaultBehavior(defaultBehavior: any): void;
  objCType(): string;
  doubleValue(): number;
}

class NSDecimalNumberHandlerAllocator<T extends NSDecimalNumberHandler> extends NSObjectAllocator<T> {
  initWithRoundingMode_scale_raiseOnExactness_raiseOnOverflow_raiseOnUnderflow_raiseOnDivideByZero(roundingMode: NSRoundingMode, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSDecimalNumberHandler extends NSObject implements INSDecimalNumberBehaviors, INSCoding {
  alloc<T extends NSDecimalNumberHandler>(): NSDecimalNumberHandlerAllocator<T>;
  static decimalNumberHandlerWithRoundingMode_scale_raiseOnExactness_raiseOnOverflow_raiseOnUnderflow_raiseOnDivideByZero(roundingMode: NSRoundingMode, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): NSDecimalNumberHandler;
  roundingMode(): NSRoundingMode;
  scale(): number;
  exceptionDuringOperation_error_leftOperand_rightOperand(operation: string, error: NSCalculationError, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;
  encodeWithCoder(aCoder: NSCoder): void;
  roundingMode(): NSRoundingMode;
  scale(): number;
  exceptionDuringOperation_error_leftOperand_rightOperand(operation: string, error: NSCalculationError, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;
  encodeWithCoder(aCoder: NSCoder): void;

  static defaultDecimalNumberHandler(): NSDecimalNumberHandler;
}

class NSNumberAllocator<T extends NSNumber> extends NSValueAllocator<T> {
  initWithChar(value: string): T;
  initWithUnsignedChar(value: string): T;
  initWithShort(value: number): T;
  initWithUnsignedShort(value: number): T;
  initWithInt(value: number): T;
  initWithUnsignedInt(value: number): T;
  initWithLong(value: number): T;
  initWithUnsignedLong(value: number): T;
  initWithLongLong(value: number): T;
  initWithUnsignedLongLong(value: number): T;
  initWithFloat(value: number): T;
  initWithDouble(value: number): T;
  initWithBool(value: boolean): T;
  initWithInteger(value: NSInteger): T;
  initWithUnsignedInteger(value: NSUInteger): T;
}
declare class NSNumber extends NSValue {
  alloc<T extends NSNumber>(): NSNumberAllocator<T>;
  compare(otherNumber: NSNumber | number): NSComparisonResult;
  isEqualToNumber(number: NSNumber | number): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  static numberWithChar(value: string): NSNumber;
  static numberWithUnsignedChar(value: string): NSNumber;
  static numberWithShort(value: number): NSNumber;
  static numberWithUnsignedShort(value: number): NSNumber;
  static numberWithInt(value: number): NSNumber;
  static numberWithUnsignedInt(value: number): NSNumber;
  static numberWithLong(value: number): NSNumber;
  static numberWithUnsignedLong(value: number): NSNumber;
  static numberWithLongLong(value: number): NSNumber;
  static numberWithUnsignedLongLong(value: number): NSNumber;
  static numberWithFloat(value: number): NSNumber;
  static numberWithDouble(value: number): NSNumber;
  static numberWithBool(value: boolean): NSNumber;
  static numberWithInteger(value: NSInteger): NSNumber;
  static numberWithUnsignedInteger(value: NSUInteger): NSNumber;

  decimalValue(): NSDecimal;
  charValue(): string;
  unsignedCharValue(): string;
  shortValue(): number;
  unsignedShortValue(): number;
  intValue(): number;
  unsignedIntValue(): number;
  longValue(): number;
  unsignedLongValue(): number;
  longLongValue(): number;
  unsignedLongLongValue(): number;
  floatValue(): number;
  doubleValue(): number;
  boolValue(): boolean;
  integerValue(): NSInteger;
  unsignedIntegerValue(): NSUInteger;
  stringValue(): NSString;
}

class NSScannerAllocator<T extends NSScanner> extends NSObjectAllocator<T> {
  initWithString(string: NSString | string): T;
}
declare class NSScanner extends NSObject implements INSCopying {
  alloc<T extends NSScanner>(): NSScannerAllocator<T>;
  scanDecimal(dcm: NSDecimal | null): boolean;
  scanInt(result: number | null): boolean;
  scanInteger(result: NSInteger | null): boolean;
  scanLongLong(result: number | null): boolean;
  scanUnsignedLongLong(result: number | null): boolean;
  scanFloat(result: number | null): boolean;
  scanDouble(result: number | null): boolean;
  scanHexInt(result: number | null): boolean;
  scanHexLongLong(result: number | null): boolean;
  scanHexFloat(result: number | null): boolean;
  scanHexDouble(result: number | null): boolean;
  scanString_intoString(string: NSString | string, result: NSString | string): boolean;
  scanCharactersFromSet_intoString(set: NSCharacterSet, result: NSString | string): boolean;
  scanUpToString_intoString(string: NSString | string, result: NSString | string): boolean;
  scanUpToCharactersFromSet_intoString(set: NSCharacterSet, result: NSString | string): boolean;
  static scannerWithString(string: NSString | string): NSScanner;
  static localizedScannerWithString(string: NSString | string): any;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  string(): NSString;
  scanLocation(): NSUInteger;
  setScanLocation(scanLocation: NSUInteger): void;
  charactersToBeSkipped(): NSCharacterSet;
  setCharactersToBeSkipped(charactersToBeSkipped: NSCharacterSet): void;
  caseSensitive(): boolean;
  setCaseSensitive(caseSensitive: boolean): void;
  locale(): any;
  setLocale(locale: any): void;
  atEnd(): boolean;
}

declare interface INSDecimalNumberBehaviors {
  roundingMode(): NSRoundingMode;
  scale(): number;
  exceptionDuringOperation_error_leftOperand_rightOperand(operation: string, error: NSCalculationError, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;
}

class NSDictionaryAllocator<KeyType, ObjectType, T extends NSDictionary<KeyType, ObjectType>> extends NSObjectAllocator<T> {
  init(): T;
  initWithObjects_forKeys_count(objects: ObjectType[], keys: KeyType[], cnt: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithContentsOfFile(path: NSString | string): T;
  initWithContentsOfURL(url: NSURL): T;
  initWithObjectsAndKeys(firstObject: any, ...args: any[]): T;
  initWithDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithDictionary_copyItems(otherDictionary: NSDictionary<any, any> | {[key: string]: any}, flag: boolean): T;
  initWithObjects_forKeys(objects: NSArray<any> | any[], keys: NSArray<any> | any[]): T;
  initWithContentsOfURL_error(url: NSURL, error: NSError): T;
}
declare class NSDictionary<KeyType, ObjectType> extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {
  alloc<T extends NSDictionary<KeyType, ObjectType>>(): NSDictionaryAllocator<KeyType, ObjectType, T>;

  [key: string]: ObjectType | Function;
  objectForKey(aKey: KeyType): ObjectType;
  keyEnumerator(): NSEnumerator<any>;
  allKeysForObject(anObject: ObjectType): NSArray<any>;
  descriptionWithLocale(locale: any | null): NSString;
  descriptionWithLocale_indent(locale: any | null, level: NSUInteger): NSString;
  isEqualToDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): boolean;
  objectEnumerator(): NSEnumerator<any>;
  objectsForKeys_notFoundMarker(keys: NSArray<any> | any[], marker: ObjectType): NSArray<any>;
  writeToURL_error(url: NSURL, error: NSError): boolean;
  keysSortedByValueUsingSelector(comparator: string): NSArray<any>;
  getObjects_andKeys_count(objects: ObjectType[], keys: KeyType[], count: NSUInteger): void;
  // @ts-ignore
  objectForKeyedSubscript(key: KeyType): ObjectType;
  enumerateKeysAndObjectsUsingBlock(block: Block): void;
  enumerateKeysAndObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  keysSortedByValueUsingComparator(cmptr: NSComparator): NSArray<any>;
  keysSortedByValueWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): NSArray<any>;
  keysOfEntriesPassingTest(predicate: Block): NSSet<any>;
  keysOfEntriesWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSSet<any>;
  getObjects_andKeys(objects: ObjectType[], keys: KeyType[]): void;
  static dictionaryWithContentsOfFile(path: NSString | string): NSDictionary<any, any>;
  static dictionaryWithContentsOfURL(url: NSURL): NSDictionary<any, any>;
  writeToFile_atomically(path: NSString | string, useAuxiliaryFile: boolean): boolean;
  writeToURL_atomically(url: NSURL, atomically: boolean): boolean;
  static dictionary<KeyType, ObjectType>(): NSDictionary<KeyType, ObjectType>;
  static dictionaryWithObject_forKey<KeyType, ObjectType>(object: ObjectType, key: KeyType): NSDictionary<KeyType, ObjectType>;
  static dictionaryWithObjects_forKeys_count<KeyType, ObjectType>(objects: ObjectType[], keys: KeyType[], cnt: NSUInteger): NSDictionary<KeyType, ObjectType>;
  static dictionaryWithObjectsAndKeys<KeyType, ObjectType>(firstObject: any, ...args: any[]): NSDictionary<KeyType, ObjectType>;
  static dictionaryWithDictionary<KeyType, ObjectType>(dict: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<KeyType, ObjectType>;
  static dictionaryWithObjects_forKeys<KeyType, ObjectType>(objects: NSArray<any> | any[], keys: NSArray<any> | any[]): NSDictionary<KeyType, ObjectType>;
  static dictionaryWithContentsOfURL_error(url: NSURL, error: NSError): NSDictionary<any, any>;
  static sharedKeySetForKeys(keys: NSArray<any> | any[]): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  fileSize(): number;
  fileModificationDate(): NSDate;
  fileType(): NSString;
  filePosixPermissions(): NSUInteger;
  fileOwnerAccountName(): NSString;
  fileGroupOwnerAccountName(): NSString;
  fileSystemNumber(): NSInteger;
  fileSystemFileNumber(): NSUInteger;
  fileExtensionHidden(): boolean;
  fileHFSCreatorCode(): OSType;
  fileHFSTypeCode(): OSType;
  fileIsImmutable(): boolean;
  fileIsAppendOnly(): boolean;
  fileCreationDate(): NSDate;
  fileOwnerAccountID(): NSNumber;
  fileGroupOwnerAccountID(): NSNumber;
  valueForKey(key: NSString | string): ObjectType;
  stringForKey_bc(aKey: any): NSString;
  arrayForKey_bc(aKey: any): NSArray<any>;
  dictionaryForKey_bc(aKey: any): NSDictionary<any, any>;
  numberForKey_bc(aKey: any): NSNumber;
  boolForKey_bc(aKey: any): boolean;
  urlForKey_bc(key: any): NSURL;
  dictionaryByAddingOrRemovingObject_forKey(object: any, key: any): NSDictionary<KeyType, ObjectType>;
  mutableCopyDeep(): any;
  dictionaryByAddingDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  filter(block: BCDictionaryFilterBlock): NSDictionary<any, any>;
  dictionaryByReplacing_usingBlock(key: any, block: Block): NSDictionary<any, any>;
  dictionaryByMappingKeys_bc(map: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  dictionaryByReverseMappingKeys_bc(map: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  mo_objectForKeyedSubscript(key: any): any;
  valueForKey_intoBool(key: NSString | string, valueOut: boolean): any;
  valueForKey_intoDouble(key: NSString | string, valueOut: number): any;
  pointForKey(key: NSString | string): CGPoint;
  sizeForKey(key: NSString | string): CGSize;
  rectForKey(key: NSString | string): CGRect;
  dictionaryWithoutKey(key: NSString | string): NSDictionary<any, any>;
  objectForKey_ofType(aKey: any, type: any): any;
  dateForKey(key: NSString | string): NSDate;
  urlForKey(key: NSString | string): NSURL;
  uuidForKey(key: NSString | string): NSUUID;
  boolForKey(key: NSString | string): boolean;
  cloudObjectForKey_ofType_parentObject(key: NSString | string, type: any, parent: SCKObject | null): SCKObject;
  cloudObjectArrayForKey_ofType_parentObject(key: NSString | string, type: any, parent: SCKObject | null): NSArray<any>;
  sizeForWidthKey_heightKey(widthKey: any, heightKey: any): CGSize;
  pointForXKey_yKey(xKey: any, yKey: any): CGPoint;
  rectForXKey_yKey_widthKey_heightKey(xKey: any, yKey: any, widthKey: any, heightKey: any): CGRect;
  prepareStringAttributesForEncoding(): NSDictionary<any, any>;
  prepareStringAttributesAfterDecoding(): NSDictionary<any, any>;
  dictionaryByMappingFontToFontDescriptors(): NSDictionary<any, any>;
  dictionaryByMappingFontDescriptorsToFont(): NSDictionary<any, any>;
  dictionaryByRefreshingFontDescriptors(): NSDictionary<any, any>;
  dictionaryByMappingComponentsDictionaryToMSImmutableColor(): NSDictionary<any, any>;
  dictionaryByConvertingNSColorsToMSImmutableColorsInColorSpace(colorSpace: NSColorSpace): NSDictionary<any, any>;
  dictionaryByConvertingMSImmutableColorsToNSColorsInColorSpace(colorSpace: NSColorSpace): NSDictionary<any, any>;
  dictionaryByTranslatingNSColorsToMSImmutableColorsInColorSpace(colorSpace: NSColorSpace): NSDictionary<any, any>;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  count(): NSUInteger;
  allKeys(): NSArray<any>;
  allValues(): NSArray<any>;
  description(): NSString;
  descriptionInStringsFileFormat(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSMutableDictionaryAllocator<KeyType, ObjectType, T extends NSMutableDictionary<KeyType, ObjectType>> extends NSDictionaryAllocator<KeyType, ObjectType, T> {
  initWithCapacity(numItems: NSUInteger): T;
}
declare class NSMutableDictionary<KeyType, ObjectType> extends NSDictionary<KeyType, ObjectType> {
  alloc<T extends NSMutableDictionary<KeyType, ObjectType>>(): NSMutableDictionaryAllocator<KeyType, ObjectType, T>;
  removeObjectForKey(aKey: KeyType): void;
  setObject_forKey(anObject: ObjectType, aKey: KeyType): void;
  addEntriesFromDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  removeAllObjects(): void;
  removeObjectsForKeys(keyArray: NSArray<any> | any[]): void;
  setDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  // @ts-ignore
  setObject_forKeyedSubscript(obj: ObjectType | null, key: KeyType): void;
  static dictionaryWithCapacity<KeyType, ObjectType>(numItems: NSUInteger): NSMutableDictionary<KeyType, ObjectType>;
  static dictionaryWithContentsOfFile(path: NSString | string): NSMutableDictionary<any, any>;
  static dictionaryWithContentsOfURL(url: NSURL): NSMutableDictionary<any, any>;
  static dictionaryWithSharedKeySet(keyset: any): NSMutableDictionary<any, any>;
  setValue_forKey(value: ObjectType | null, key: NSString | string): void;
  objectForKey_orBySettingMissingObject(aKey: NSString | string, anObject: any): any;
  addObject_forKey(anObject: any, aKey: any): void;
  mo_setObject_forKeyedSubscript(obj: any, key: any): void;
  setPoint_forKey(point: CGPoint, key: NSString | string): void;
  setSize_forKey(size: CGSize, key: NSString | string): void;
  setRect_forKey(rect: CGRect, key: NSString | string): void;
  mergeEntriesFromDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  setDate_forKey(date: NSDate | null, key: NSString | string): void;

  visible(): boolean;
  setVisible(visible: boolean): void;
  locked(): boolean;
  setLocked(locked: boolean): void;
  selected(): boolean;
  setSelected(selected: boolean): void;
  hovered(): boolean;
  setHovered(hovered: boolean): void;
  isFlow(): boolean;
  setIsFlow(isFlow: boolean): void;
  isSlice(): boolean;
  setIsSlice(isSlice: boolean): void;
  exportFileName(): NSString;
}

class NSDistantObjectAllocator<T extends NSDistantObject> extends NSProxyAllocator<T> {
  initWithTarget_connection(target: any, connection: NSConnection): T;
  initWithLocal_connection(target: any, connection: NSConnection): T;
  initWithCoder(inCoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSDistantObject extends NSProxy implements INSCoding {
  alloc<T extends NSDistantObject>(): NSDistantObjectAllocator<T>;
  static proxyWithTarget_connection(target: any, connection: NSConnection): any;
  static proxyWithLocal_connection(target: any, connection: NSConnection): any;
  setProtocolForProxy(proto: Protocol | null): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  connectionForProxy(): NSConnection;
}

class NSDistributedLockAllocator<T extends NSDistributedLock> extends NSObjectAllocator<T> {
  initWithPath(path: NSString | string): T;
}
declare class NSDistributedLock extends NSObject {
  alloc<T extends NSDistributedLock>(): NSDistributedLockAllocator<T>;
  static lockWithPath(path: NSString | string): NSDistributedLock;
  tryLock(): boolean;
  unlock(): void;
  breakLock(): void;

  lockDate(): NSDate;
}

class NSDistributedNotificationCenterAllocator<T extends NSDistributedNotificationCenter> extends NSNotificationCenterAllocator<T> {}
declare class NSDistributedNotificationCenter extends NSNotificationCenter {
  alloc<T extends NSDistributedNotificationCenter>(): NSDistributedNotificationCenterAllocator<T>;
  static notificationCenterForType(notificationCenterType: NSDistributedNotificationCenterType): NSDistributedNotificationCenter;
  static defaultCenter(): NSDistributedNotificationCenter;
  addObserver_selector_name_object_suspensionBehavior(observer: any, selector: string, name: NSNotificationName | null, object: NSString | string | null, suspensionBehavior: NSNotificationSuspensionBehavior): void;
  postNotificationName_object_userInfo_deliverImmediately(name: NSNotificationName, object: NSString | string | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null, deliverImmediately: boolean): void;
  postNotificationName_object_userInfo_options(name: NSNotificationName, object: NSString | string | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null, options: NSDistributedNotificationOptions): void;
  addObserver_selector_name_object(observer: any, aSelector: string, aName: NSNotificationName | null, anObject: NSString | string | null): void;
  postNotificationName_object(aName: NSNotificationName, anObject: NSString | string | null): void;
  postNotificationName_object_userInfo(aName: NSNotificationName, anObject: NSString | string | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): void;
  removeObserver_name_object(observer: any, aName: NSNotificationName | null, anObject: NSString | string | null): void;

  suspended(): boolean;
  setSuspended(suspended: boolean): void;
}

declare type NSDistributedNotificationCenterType = NSString

declare enum NSNotificationSuspensionBehavior {
  NSNotificationSuspensionBehaviorDrop = 1,
  NSNotificationSuspensionBehaviorCoalesce = 2,
  NSNotificationSuspensionBehaviorHold = 3,
  NSNotificationSuspensionBehaviorDeliverImmediately = 4,
}

declare enum NSDistributedNotificationOptions {
  NSDistributedNotificationDeliverImmediately,
  NSDistributedNotificationPostToAllSessions,
}

class NSEnergyFormatterAllocator<T extends NSEnergyFormatter> extends NSFormatterAllocator<T> {}
declare class NSEnergyFormatter extends NSFormatter {
  alloc<T extends NSEnergyFormatter>(): NSEnergyFormatterAllocator<T>;
  stringFromValue_unit(value: number, unit: NSEnergyFormatterUnit): NSString;
  stringFromJoules(numberInJoules: number): NSString;
  unitStringFromValue_unit(value: number, unit: NSEnergyFormatterUnit): NSString;
  unitStringFromJoules_usedUnit(numberInJoules: number, unitp: NSEnergyFormatterUnit | null): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  forFoodEnergyUse(): boolean;
  setForFoodEnergyUse(forFoodEnergyUse: boolean): void;
}

declare enum NSEnergyFormatterUnit {
  NSEnergyFormatterUnitJoule = 11,
  NSEnergyFormatterUnitKilojoule = 14,
  NSEnergyFormatterUnitCalorie,
  NSEnergyFormatterUnitKilocalorie,
}

class NSEnumeratorAllocator<ObjectType, T extends NSEnumerator<ObjectType>> extends NSObjectAllocator<T> {}
declare class NSEnumerator<ObjectType> extends NSObject implements INSFastEnumeration {
  alloc<T extends NSEnumerator<ObjectType>>(): NSEnumeratorAllocator<ObjectType, T>;
  nextObject(): ObjectType;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  allObjects(): NSArray<any>;
}

declare interface INSFastEnumeration {
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
}

declare type NSFastEnumerationState = {
  state: number
  itemsPtr: any
  mutationsPtr: number
  extra: [number, number, number, number, number]
}

class NSErrorAllocator<T extends NSError> extends NSObjectAllocator<T> {
  initWithDomain_code_userInfo(domain: NSErrorDomain, code: NSInteger, dict: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class NSError extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSError>(): NSErrorAllocator<T>;
  static errorWithDomain_code_userInfo(domain: NSErrorDomain, code: NSInteger, dict: NSDictionary<any, any> | {[key: string]: any} | null): NSError;
  static setUserInfoValueProviderForDomain_provider(errorDomain: NSErrorDomain, provider: Block): void;
  static errorFromAPIResponse_data(response: NSURLResponse | null, data: NSData | null): NSError;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  domain(): NSErrorDomain;
  code(): NSInteger;
  userInfo(): NSDictionary<any, any>;
  localizedDescription(): NSString;
  localizedFailureReason(): NSString;
  localizedRecoverySuggestion(): NSString;
  localizedRecoveryOptions(): NSArray<any>;
  recoveryAttempter(): any;
  helpAnchor(): NSString;
  isCloudError(): boolean;
  isCloudUnauthorized(): boolean;
  isCloudForbidden(): boolean;
  isUrlCancelled(): boolean;
  static supportsSecureCoding(): boolean;
}

declare type NSErrorDomain = NSString

declare type NSErrorUserInfoKey = NSString

class NSExceptionAllocator<T extends NSException> extends NSObjectAllocator<T> {
  initWithName_reason_userInfo(aName: NSExceptionName, aReason: NSString | string | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSException extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSException>(): NSExceptionAllocator<T>;
  static exceptionWithName_reason_userInfo(name: NSExceptionName, reason: NSString | string | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null): NSException;
  raise(): void;
  static raise_format(name: NSExceptionName, format: NSString | string, ...args: any[]): void;
  static raise_format_arguments(name: NSExceptionName, format: NSString | string, ...argList: any[]): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  name(): NSExceptionName;
  reason(): NSString;
  userInfo(): NSDictionary<any, any>;
  callStackReturnAddresses(): NSArray<any>;
  callStackSymbols(): NSArray<any>;
}

class NSAssertionHandlerAllocator<T extends NSAssertionHandler> extends NSObjectAllocator<T> {}
declare class NSAssertionHandler extends NSObject {
  alloc<T extends NSAssertionHandler>(): NSAssertionHandlerAllocator<T>;
  handleFailureInMethod_object_file_lineNumber_description(selector: string, object: any, fileName: NSString | string, line: NSInteger, format: NSString | string | null, ...args: any[]): void;
  handleFailureInFunction_file_lineNumber_description(functionName: NSString | string, fileName: NSString | string, line: NSInteger, format: NSString | string | null, ...args: any[]): void;

  static currentHandler(): NSAssertionHandler;
}

class NSExpressionAllocator<T extends NSExpression> extends NSObjectAllocator<T> {
  initWithExpressionType(type: NSExpressionType): T;
  initWithCoder(coder: NSCoder): T;
}
declare class NSExpression extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSExpression>(): NSExpressionAllocator<T>;
  static expressionWithFormat_argumentArray(expressionFormat: NSString | string, arguments: NSArray<any> | any[]): NSExpression;
  static expressionWithFormat(expressionFormat: NSString | string, ...args: any[]): NSExpression;
  static expressionWithFormat_arguments(expressionFormat: NSString | string, ...argList: any[]): NSExpression;
  static expressionForConstantValue(obj: any | null): NSExpression;
  static expressionForEvaluatedObject(): NSExpression;
  static expressionForVariable(string: NSString | string): NSExpression;
  static expressionForKeyPath(keyPath: NSString | string): NSExpression;
  static expressionForFunction_arguments(name: NSString | string, parameters: NSArray<any> | any[]): NSExpression;
  static expressionForAggregate(subexpressions: NSArray<any> | any[]): NSExpression;
  static expressionForUnionSet_with(left: NSExpression, right: NSExpression): NSExpression;
  static expressionForIntersectSet_with(left: NSExpression, right: NSExpression): NSExpression;
  static expressionForMinusSet_with(left: NSExpression, right: NSExpression): NSExpression;
  static expressionForSubquery_usingIteratorVariable_predicate(expression: NSExpression, variable: NSString | string, predicate: NSPredicate): NSExpression;
  static expressionForFunction_selectorName_arguments(target: NSExpression, name: NSString | string, parameters: NSArray<any> | any[] | null): NSExpression;
  static expressionForAnyKey(): NSExpression;
  static expressionForBlock_arguments(block: Block, arguments: NSArray<any> | any[] | null): NSExpression;
  static expressionForConditional_trueExpression_falseExpression(predicate: NSPredicate, trueExpression: NSExpression, falseExpression: NSExpression): NSExpression;
  expressionValueWithObject_context(object: any | null, context: NSMutableDictionary<any, any> | {[key: string]: any} | null): any;
  allowEvaluation(): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  expressionType(): NSExpressionType;
  constantValue(): any;
  keyPath(): NSString;
  function(): NSString;
  variable(): NSString;
  operand(): NSExpression;
  arguments(): NSArray<any>;
  collection(): any;
  predicate(): NSPredicate;
  leftExpression(): NSExpression;
  rightExpression(): NSExpression;
  trueExpression(): NSExpression;
  falseExpression(): NSExpression;
  static supportsSecureCoding(): boolean;
}

declare enum NSExpressionType {
  NSConstantValueExpressionType = 0,
  NSEvaluatedObjectExpressionType,
  NSVariableExpressionType,
  NSKeyPathExpressionType,
  NSFunctionExpressionType,
  NSUnionSetExpressionType,
  NSIntersectSetExpressionType,
  NSMinusSetExpressionType,
  NSSubqueryExpressionType = 13,
  NSAggregateExpressionType = 14,
  NSAnyKeyExpressionType = 15,
  NSBlockExpressionType = 19,
  NSConditionalExpressionType = 20,
}

class NSExtensionContextAllocator<T extends NSExtensionContext> extends NSObjectAllocator<T> {}
declare class NSExtensionContext extends NSObject {
  alloc<T extends NSExtensionContext>(): NSExtensionContextAllocator<T>;
  completeRequestReturningItems_completionHandler(items: NSArray<any> | any[] | null, completionHandler: Block): void;
  cancelRequestWithError(error: NSError): void;
  openURL_completionHandler(URL: NSURL, completionHandler: Block): void;

  inputItems(): NSArray<any>;
}

class NSExtensionItemAllocator<T extends NSExtensionItem> extends NSObjectAllocator<T> {}
declare class NSExtensionItem extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSExtensionItem>(): NSExtensionItemAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  attributedContentText(): NSAttributedString;
  setAttributedContentText(attributedContentText: NSAttributedString): void;
  attachments(): NSArray<any>;
  setAttachments(attachments: NSArray<any> | any[]): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  static supportsSecureCoding(): boolean;
}

declare interface INSExtensionRequestHandling {
  beginRequestWithExtensionContext(context: NSExtensionContext): void;
}

class NSFileAccessIntentAllocator<T extends NSFileAccessIntent> extends NSObjectAllocator<T> {}
declare class NSFileAccessIntent extends NSObject {
  alloc<T extends NSFileAccessIntent>(): NSFileAccessIntentAllocator<T>;
  static readingIntentWithURL_options(url: NSURL, options: NSFileCoordinatorReadingOptions): NSFileAccessIntent;
  static writingIntentWithURL_options(url: NSURL, options: NSFileCoordinatorWritingOptions): NSFileAccessIntent;

  URL(): NSURL;
}

class NSFileCoordinatorAllocator<T extends NSFileCoordinator> extends NSObjectAllocator<T> {
  initWithFilePresenter(filePresenterOrNil: any | null): T;
}
declare class NSFileCoordinator extends NSObject {
  alloc<T extends NSFileCoordinator>(): NSFileCoordinatorAllocator<T>;
  static addFilePresenter(filePresenter: any): void;
  static removeFilePresenter(filePresenter: any): void;
  coordinateAccessWithIntents_queue_byAccessor(intents: NSArray<any> | any[], queue: NSOperationQueue, accessor: Block): void;
  coordinateReadingItemAtURL_options_error_byAccessor(url: NSURL, options: NSFileCoordinatorReadingOptions, outError: NSError, reader: Block): void;
  coordinateWritingItemAtURL_options_error_byAccessor(url: NSURL, options: NSFileCoordinatorWritingOptions, outError: NSError, writer: Block): void;
  coordinateReadingItemAtURL_options_writingItemAtURL_options_error_byAccessor(readingURL: NSURL, readingOptions: NSFileCoordinatorReadingOptions, writingURL: NSURL, writingOptions: NSFileCoordinatorWritingOptions, outError: NSError, readerWriter: Block): void;
  coordinateWritingItemAtURL_options_writingItemAtURL_options_error_byAccessor(url1: NSURL, options1: NSFileCoordinatorWritingOptions, url2: NSURL, options2: NSFileCoordinatorWritingOptions, outError: NSError, writer: Block): void;
  prepareForReadingItemsAtURLs_options_writingItemsAtURLs_options_error_byAccessor(readingURLs: NSArray<any> | any[], readingOptions: NSFileCoordinatorReadingOptions, writingURLs: NSArray<any> | any[], writingOptions: NSFileCoordinatorWritingOptions, outError: NSError, batchAccessor: Block): void;
  itemAtURL_willMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  itemAtURL_didMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  itemAtURL_didChangeUbiquityAttributes(url: NSURL, attributes: NSSet<any>): void;
  cancel(): void;

  static filePresenters(): NSArray<any>;
  purposeIdentifier(): NSString;
  setPurposeIdentifier(purposeIdentifier: NSString | string): void;
}

declare enum NSFileCoordinatorReadingOptions {
  NSFileCoordinatorReadingWithoutChanges = 1 << 0,
  NSFileCoordinatorReadingResolvesSymbolicLink = 1 << 1,
  NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly = 1 << 2,
  NSFileCoordinatorReadingForUploading = 1 << 3,
}

declare enum NSFileCoordinatorWritingOptions {
  NSFileCoordinatorWritingForDeleting = 1 << 0,
  NSFileCoordinatorWritingForMoving = 1 << 1,
  NSFileCoordinatorWritingForMerging = 1 << 2,
  NSFileCoordinatorWritingForReplacing = 1 << 3,
  NSFileCoordinatorWritingContentIndependentMetadataOnly = 1 << 4,
}

class NSFileHandleAllocator<T extends NSFileHandle> extends NSObjectAllocator<T> {
  initWithFileDescriptor_closeOnDealloc(fd: number, closeopt: boolean): T;
  initWithCoder(coder: NSCoder): T;
  initWithFileDescriptor(fd: number): T;
}
declare class NSFileHandle extends NSObject implements INSSecureCoding {
  alloc<T extends NSFileHandle>(): NSFileHandleAllocator<T>;
  readDataToEndOfFile(): NSData;
  readDataOfLength(length: NSUInteger): NSData;
  writeData(data: NSData): void;
  seekToEndOfFile(): number;
  seekToFileOffset(offset: number): void;
  truncateFileAtOffset(offset: number): void;
  synchronizeFile(): void;
  closeFile(): void;
  static fileHandleForReadingAtPath(path: NSString | string): NSFileHandle;
  static fileHandleForWritingAtPath(path: NSString | string): NSFileHandle;
  static fileHandleForUpdatingAtPath(path: NSString | string): NSFileHandle;
  static fileHandleForReadingFromURL_error(url: NSURL, error: NSError): NSFileHandle;
  static fileHandleForWritingToURL_error(url: NSURL, error: NSError): NSFileHandle;
  static fileHandleForUpdatingURL_error(url: NSURL, error: NSError): NSFileHandle;
  readInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  readInBackgroundAndNotify(): void;
  readToEndOfFileInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  readToEndOfFileInBackgroundAndNotify(): void;
  acceptConnectionInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  acceptConnectionInBackgroundAndNotify(): void;
  waitForDataInBackgroundAndNotifyForModes(modes: NSArray<any> | any[] | null): void;
  waitForDataInBackgroundAndNotify(): void;

  availableData(): NSData;
  offsetInFile(): number;
  static fileHandleWithStandardInput(): NSFileHandle;
  static fileHandleWithStandardOutput(): NSFileHandle;
  static fileHandleWithStandardError(): NSFileHandle;
  static fileHandleWithNullDevice(): NSFileHandle;
  fileDescriptor(): number;
  static supportsSecureCoding(): boolean;
}

class NSPipeAllocator<T extends NSPipe> extends NSObjectAllocator<T> {}
declare class NSPipe extends NSObject {
  alloc<T extends NSPipe>(): NSPipeAllocator<T>;
  static pipe(): NSPipe;

  fileHandleForReading(): NSFileHandle;
  fileHandleForWriting(): NSFileHandle;
}

class NSFileManagerAllocator<T extends NSFileManager> extends NSObjectAllocator<T> {}
declare class NSFileManager extends NSObject {
  alloc<T extends NSFileManager>(): NSFileManagerAllocator<T>;
  mountedVolumeURLsIncludingResourceValuesForKeys_options(propertyKeys: NSArray<any> | any[] | null, options: NSVolumeEnumerationOptions): NSArray<any>;
  unmountVolumeAtURL_options_completionHandler(url: NSURL, mask: NSFileManagerUnmountOptions, completionHandler: Block): void;
  contentsOfDirectoryAtURL_includingPropertiesForKeys_options_error(url: NSURL, keys: NSArray<any> | any[] | null, mask: NSDirectoryEnumerationOptions, error: NSError): NSArray<any>;
  URLsForDirectory_inDomains(directory: NSSearchPathDirectory, domainMask: NSSearchPathDomainMask): NSArray<any>;
  URLForDirectory_inDomain_appropriateForURL_create_error(directory: NSSearchPathDirectory, domain: NSSearchPathDomainMask, url: NSURL | null, shouldCreate: boolean, error: NSError): NSURL;
  getRelationship_ofDirectoryAtURL_toItemAtURL_error(outRelationship: NSURLRelationship, directoryURL: NSURL, otherURL: NSURL, error: NSError): boolean;
  getRelationship_ofDirectory_inDomain_toItemAtURL_error(outRelationship: NSURLRelationship, directory: NSSearchPathDirectory, domainMask: NSSearchPathDomainMask, url: NSURL, error: NSError): boolean;
  createDirectoryAtURL_withIntermediateDirectories_attributes_error(url: NSURL, createIntermediates: boolean, attributes: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): boolean;
  createSymbolicLinkAtURL_withDestinationURL_error(url: NSURL, destURL: NSURL, error: NSError): boolean;
  setAttributes_ofItemAtPath_error(attributes: NSDictionary<any, any> | {[key: string]: any}, path: NSString | string, error: NSError): boolean;
  createDirectoryAtPath_withIntermediateDirectories_attributes_error(path: NSString | string, createIntermediates: boolean, attributes: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): boolean;
  contentsOfDirectoryAtPath_error(path: NSString | string, error: NSError): NSArray<any>;
  subpathsOfDirectoryAtPath_error(path: NSString | string, error: NSError): NSArray<any>;
  attributesOfItemAtPath_error(path: NSString | string, error: NSError): NSDictionary<any, any>;
  attributesOfFileSystemForPath_error(path: NSString | string, error: NSError): NSDictionary<any, any>;
  createSymbolicLinkAtPath_withDestinationPath_error(path: NSString | string, destPath: NSString | string, error: NSError): boolean;
  destinationOfSymbolicLinkAtPath_error(path: NSString | string, error: NSError): NSString;
  copyItemAtPath_toPath_error(srcPath: NSString | string, dstPath: NSString | string, error: NSError): boolean;
  moveItemAtPath_toPath_error(srcPath: NSString | string, dstPath: NSString | string, error: NSError): boolean;
  linkItemAtPath_toPath_error(srcPath: NSString | string, dstPath: NSString | string, error: NSError): boolean;
  removeItemAtPath_error(path: NSString | string, error: NSError): boolean;
  copyItemAtURL_toURL_error(srcURL: NSURL, dstURL: NSURL, error: NSError): boolean;
  moveItemAtURL_toURL_error(srcURL: NSURL, dstURL: NSURL, error: NSError): boolean;
  linkItemAtURL_toURL_error(srcURL: NSURL, dstURL: NSURL, error: NSError): boolean;
  removeItemAtURL_error(URL: NSURL, error: NSError): boolean;
  trashItemAtURL_resultingItemURL_error(url: NSURL, outResultingURL: NSURL, error: NSError): boolean;
  fileAttributesAtPath_traverseLink(path: NSString | string, yorn: boolean): NSDictionary<any, any>;
  changeFileAttributes_atPath(attributes: NSDictionary<any, any> | {[key: string]: any}, path: NSString | string): boolean;
  directoryContentsAtPath(path: NSString | string): NSArray<any>;
  fileSystemAttributesAtPath(path: NSString | string): NSDictionary<any, any>;
  pathContentOfSymbolicLinkAtPath(path: NSString | string): NSString;
  createSymbolicLinkAtPath_pathContent(path: NSString | string, otherpath: NSString | string): boolean;
  createDirectoryAtPath_attributes(path: NSString | string, attributes: NSDictionary<any, any> | {[key: string]: any}): boolean;
  linkPath_toPath_handler(src: NSString | string, dest: NSString | string, handler: any | null): boolean;
  copyPath_toPath_handler(src: NSString | string, dest: NSString | string, handler: any | null): boolean;
  movePath_toPath_handler(src: NSString | string, dest: NSString | string, handler: any | null): boolean;
  removeFileAtPath_handler(path: NSString | string, handler: any | null): boolean;
  changeCurrentDirectoryPath(path: NSString | string): boolean;
  fileExistsAtPath(path: NSString | string): boolean;
  fileExistsAtPath_isDirectory(path: NSString | string, isDirectory: boolean | null): boolean;
  isReadableFileAtPath(path: NSString | string): boolean;
  isWritableFileAtPath(path: NSString | string): boolean;
  isExecutableFileAtPath(path: NSString | string): boolean;
  isDeletableFileAtPath(path: NSString | string): boolean;
  contentsEqualAtPath_andPath(path1: NSString | string, path2: NSString | string): boolean;
  displayNameAtPath(path: NSString | string): NSString;
  componentsToDisplayForPath(path: NSString | string): NSArray<any>;
  enumeratorAtPath(path: NSString | string): NSDirectoryEnumerator<any>;
  enumeratorAtURL_includingPropertiesForKeys_options_errorHandler(url: NSURL, keys: NSArray<any> | any[] | null, mask: NSDirectoryEnumerationOptions, handler: Block | null): NSDirectoryEnumerator<any>;
  subpathsAtPath(path: NSString | string): NSArray<any>;
  contentsAtPath(path: NSString | string): NSData;
  createFileAtPath_contents_attributes(path: NSString | string, data: NSData | null, attr: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  fileSystemRepresentationWithPath(path: NSString | string): string;
  stringWithFileSystemRepresentation_length(str: string, len: NSUInteger): NSString;
  replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(originalItemURL: NSURL, newItemURL: NSURL, backupItemName: NSString | string | null, options: NSFileManagerItemReplacementOptions, resultingURL: NSURL, error: NSError): boolean;
  setUbiquitous_itemAtURL_destinationURL_error(flag: boolean, url: NSURL, destinationURL: NSURL, error: NSError): boolean;
  isUbiquitousItemAtURL(url: NSURL): boolean;
  startDownloadingUbiquitousItemAtURL_error(url: NSURL, error: NSError): boolean;
  evictUbiquitousItemAtURL_error(url: NSURL, error: NSError): boolean;
  URLForUbiquityContainerIdentifier(containerIdentifier: NSString | string | null): NSURL;
  URLForPublishingUbiquitousItemAtURL_expirationDate_error(url: NSURL, outDate: NSDate, error: NSError): NSURL;
  getFileProviderServicesForItemAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  containerURLForSecurityApplicationGroupIdentifier(groupIdentifier: NSString | string): NSURL;
  homeDirectoryForUser(userName: NSString | string): NSURL;
  visibleSubpathsOfDirectory(path: NSString | string): NSArray<any>;
  createDirectoryIfNecessary(directory: NSString | string): boolean;
  fileExistsAtURL(url: NSURL): boolean;
  shallowSubpathsOfDirectoryAtURL(url: NSURL): NSArray<any>;
  shallowSubpathURLsOfDirectoryAtURL(url: NSURL): NSArray<any>;
  shallowFilenamesOfDirectoryAtURL_withURLResourceValues_forURLResourceKey(url: NSURL, urlResourceValues: NSSet<any>, resourceKey: NSURLResourceKey): NSArray<any>;
  isFolderAtPath(path: NSString | string): boolean;
  isFolderAtURL(url: NSURL): boolean;
  uniqueURL(url: NSURL): NSURL;
  temporaryFolderURL(): NSURL;
  temporaryFolderURLWithName(name: NSString | string): NSURL;
  temporaryFileURLWithName_extension(name: NSString | string, extension: NSString | string): NSURL;
  temporaryFileURLToReplaceURL(url: NSURL): NSURL;
  temporaryFileURLWithExtension(extension: NSString | string): NSURL;
  _temporaryFilesRootForURL(url: NSURL): NSURL;
  static _setTemporaryFilesRootToURL(rootURL: NSURL): void;
  visibleSubpathsOfDirectoryWithoutGoingIntoPackages(path: NSString | string): NSArray<any>;
  visibleSubpathsOfDirectoryAtURLWithoutGoingIntoPackages(url: NSURL): NSArray<any>;

  static defaultManager(): NSFileManager;
  delegate(): any;
  setDelegate(delegate: any): void;
  currentDirectoryPath(): NSString;
  ubiquityIdentityToken(): any;
  homeDirectoryForCurrentUser(): NSURL;
  temporaryDirectory(): NSURL;
}

class NSDirectoryEnumeratorAllocator<ObjectType, T extends NSDirectoryEnumerator<ObjectType>> extends NSEnumeratorAllocator<ObjectType, T> {}
declare class NSDirectoryEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
  alloc<T extends NSDirectoryEnumerator<ObjectType>>(): NSDirectoryEnumeratorAllocator<ObjectType, T>;
  skipDescendents(): void;
  skipDescendants(): void;

  fileAttributes(): NSDictionary<any, any>;
  directoryAttributes(): NSDictionary<any, any>;
  level(): NSUInteger;
}

class NSFileProviderServiceAllocator<T extends NSFileProviderService> extends NSObjectAllocator<T> {}
declare class NSFileProviderService extends NSObject {
  alloc<T extends NSFileProviderService>(): NSFileProviderServiceAllocator<T>;
  getFileProviderConnectionWithCompletionHandler(completionHandler: Block): void;

  name(): NSFileProviderServiceName;
}

declare interface INSFileManagerDelegate {
  fileManager_shouldCopyItemAtPath_toPath(fileManager: NSFileManager, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldCopyItemAtURL_toURL(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldProceedAfterError_copyingItemAtPath_toPath(fileManager: NSFileManager, error: NSError, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldProceedAfterError_copyingItemAtURL_toURL(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldMoveItemAtPath_toPath(fileManager: NSFileManager, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldMoveItemAtURL_toURL(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldProceedAfterError_movingItemAtPath_toPath(fileManager: NSFileManager, error: NSError, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldProceedAfterError_movingItemAtURL_toURL(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldLinkItemAtPath_toPath(fileManager: NSFileManager, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldLinkItemAtURL_toURL(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldProceedAfterError_linkingItemAtPath_toPath(fileManager: NSFileManager, error: NSError, srcPath: NSString | string, dstPath: NSString | string): boolean;
  fileManager_shouldProceedAfterError_linkingItemAtURL_toURL(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
  fileManager_shouldRemoveItemAtPath(fileManager: NSFileManager, path: NSString | string): boolean;
  fileManager_shouldRemoveItemAtURL(fileManager: NSFileManager, URL: NSURL): boolean;
  fileManager_shouldProceedAfterError_removingItemAtPath(fileManager: NSFileManager, error: NSError, path: NSString | string): boolean;
  fileManager_shouldProceedAfterError_removingItemAtURL(fileManager: NSFileManager, error: NSError, URL: NSURL): boolean;
}

declare type NSFileAttributeKey = NSString

declare type NSFileAttributeType = NSString

declare type NSFileProtectionType = NSString

declare type NSFileProviderServiceName = NSString

declare enum NSVolumeEnumerationOptions {
  NSVolumeEnumerationSkipHiddenVolumes = 1 << 1,
  NSVolumeEnumerationProduceFileReferenceURLs = 1 << 2,
}

declare enum NSDirectoryEnumerationOptions {
  NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1 << 0,
  NSDirectoryEnumerationSkipsPackageDescendants = 1 << 1,
  NSDirectoryEnumerationSkipsHiddenFiles = 1 << 2,
}

declare enum NSFileManagerItemReplacementOptions {
  NSFileManagerItemReplacementUsingNewMetadataOnly = 1 << 0,
  NSFileManagerItemReplacementWithoutDeletingBackupItem = 1 << 1,
}

declare enum NSURLRelationship {
  NSURLRelationshipContains,
  NSURLRelationshipSame,
  NSURLRelationshipOther,
}

declare enum NSFileManagerUnmountOptions {
  NSFileManagerUnmountAllPartitionsAndEjectDisk = 1 << 0,
  NSFileManagerUnmountWithoutUI = 1 << 1,
}

declare interface INSFilePresenter extends NSObject {
  relinquishPresentedItemToReader(reader: Block): void;
  relinquishPresentedItemToWriter(writer: Block): void;
  savePresentedItemChangesWithCompletionHandler(completionHandler: Block): void;
  accommodatePresentedItemDeletionWithCompletionHandler(completionHandler: Block): void;
  presentedItemDidMoveToURL(newURL: NSURL): void;
  presentedItemDidChange(): void;
  presentedItemDidChangeUbiquityAttributes(attributes: NSSet<any>): void;
  presentedItemDidGainVersion(version: NSFileVersion): void;
  presentedItemDidLoseVersion(version: NSFileVersion): void;
  presentedItemDidResolveConflictVersion(version: NSFileVersion): void;
  accommodatePresentedSubitemDeletionAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  presentedSubitemDidAppearAtURL(url: NSURL): void;
  presentedSubitemAtURL_didMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  presentedSubitemDidChangeAtURL(url: NSURL): void;
  presentedSubitemAtURL_didGainVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didLoseVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didResolveConflictVersion(url: NSURL, version: NSFileVersion): void;

  presentedItemURL(): NSURL;
  presentedItemOperationQueue(): NSOperationQueue;
  primaryPresentedItemURL(): NSURL;
  observedPresentedItemUbiquityAttributes(): NSSet<any>;
}

class NSFileVersionAllocator<T extends NSFileVersion> extends NSObjectAllocator<T> {}
declare class NSFileVersion extends NSObject {
  alloc<T extends NSFileVersion>(): NSFileVersionAllocator<T>;
  static currentVersionOfItemAtURL(url: NSURL): NSFileVersion;
  static otherVersionsOfItemAtURL(url: NSURL): NSArray<any>;
  static unresolvedConflictVersionsOfItemAtURL(url: NSURL): NSArray<any>;
  static getNonlocalVersionsOfItemAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  static versionOfItemAtURL_forPersistentIdentifier(url: NSURL, persistentIdentifier: any): NSFileVersion;
  static addVersionOfItemAtURL_withContentsOfURL_options_error(url: NSURL, contentsURL: NSURL, options: NSFileVersionAddingOptions, outError: NSError): NSFileVersion;
  static temporaryDirectoryURLForNewVersionOfItemAtURL(url: NSURL): NSURL;
  replaceItemAtURL_options_error(url: NSURL, options: NSFileVersionReplacingOptions, error: NSError): NSURL;
  removeAndReturnError(outError: NSError): boolean;
  static removeOtherVersionsOfItemAtURL_error(url: NSURL, outError: NSError): boolean;

  URL(): NSURL;
  localizedName(): NSString;
  localizedNameOfSavingComputer(): NSString;
  originatorNameComponents(): NSPersonNameComponents;
  modificationDate(): NSDate;
  persistentIdentifier(): any;
  conflict(): boolean;
  resolved(): boolean;
  setResolved(resolved: boolean): void;
  discardable(): boolean;
  setDiscardable(discardable: boolean): void;
  hasLocalContents(): boolean;
  hasThumbnail(): boolean;
}

declare enum NSFileVersionAddingOptions {
  NSFileVersionAddingByMoving = 1 << 0,
}

declare enum NSFileVersionReplacingOptions {
  NSFileVersionReplacingByMoving = 1 << 0,
}

class NSFileWrapperAllocator<T extends NSFileWrapper> extends NSObjectAllocator<T> {
  initWithURL_options_error(url: NSURL, options: NSFileWrapperReadingOptions, outError: NSError): T;
  initDirectoryWithFileWrappers(childrenByPreferredName: NSDictionary<any, any> | {[key: string]: any}): T;
  initRegularFileWithContents(contents: NSData): T;
  initSymbolicLinkWithDestinationURL(url: NSURL): T;
  initWithSerializedRepresentation(serializeRepresentation: NSData): T;
  initWithCoder(inCoder: NSCoder): T;
  initWithPath(path: NSString | string): T;
  initSymbolicLinkWithDestination(path: NSString | string): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSFileWrapper extends NSObject implements INSCoding {
  alloc<T extends NSFileWrapper>(): NSFileWrapperAllocator<T>;
  matchesContentsOfURL(url: NSURL): boolean;
  readFromURL_options_error(url: NSURL, options: NSFileWrapperReadingOptions, outError: NSError): boolean;
  writeToURL_options_originalContentsURL_error(url: NSURL, options: NSFileWrapperWritingOptions, originalContentsURL: NSURL | null, outError: NSError): boolean;
  addFileWrapper(child: NSFileWrapper): NSString;
  addRegularFileWithContents_preferredFilename(data: NSData, fileName: NSString | string): NSString;
  removeFileWrapper(child: NSFileWrapper): void;
  keyForFileWrapper(child: NSFileWrapper): NSString;
  needsToBeUpdatedFromPath(path: NSString | string): boolean;
  updateFromPath(path: NSString | string): boolean;
  writeToFile_atomically_updateFilenames(path: NSString | string, atomicFlag: boolean, updateFilenamesFlag: boolean): boolean;
  addFileWithPath(path: NSString | string): NSString;
  addSymbolicLinkWithDestination_preferredFilename(path: NSString | string, filename: NSString | string): NSString;
  symbolicLinkDestination(): NSString;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  directory(): boolean;
  regularFile(): boolean;
  symbolicLink(): boolean;
  preferredFilename(): NSString;
  setPreferredFilename(preferredFilename: NSString | string): void;
  filename(): NSString;
  setFilename(filename: NSString | string): void;
  fileAttributes(): NSDictionary<any, any>;
  setFileAttributes(fileAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  serializedRepresentation(): NSData;
  fileWrappers(): NSDictionary<any, any>;
  regularFileContents(): NSData;
  symbolicLinkDestinationURL(): NSURL;
  icon(): NSImage;
  setIcon(icon: NSImage): void;
}

declare enum NSFileWrapperReadingOptions {
  NSFileWrapperReadingImmediate = 1 << 0,
  NSFileWrapperReadingWithoutMapping = 1 << 1,
}

declare enum NSFileWrapperWritingOptions {
  NSFileWrapperWritingAtomic = 1 << 0,
  NSFileWrapperWritingWithNameUpdating = 1 << 1,
}

class NSFormatterAllocator<T extends NSFormatter> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSFormatter extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSFormatter>(): NSFormatterAllocator<T>;
  stringForObjectValue(obj: any | null): NSString;
  attributedStringForObjectValue_withDefaultAttributes(obj: any, attrs: NSDictionary<any, any> | {[key: string]: any} | null): NSAttributedString;
  editingStringForObjectValue(obj: any): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;
  isPartialStringValid_newEditingString_errorDescription(partialString: NSString | string, newString: NSString | string, error: NSString | string): boolean;
  isPartialStringValid_proposedSelectedRange_originalString_originalSelectedRange_errorDescription(partialStringPtr: NSString | string, proposedSelRangePtr: NSRangePointer | null, origString: NSString | string, origSelRange: NSRange, error: NSString | string): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
}

declare enum NSFormattingContext {
  NSFormattingContextUnknown = 0,
  NSFormattingContextDynamic = 1,
  NSFormattingContextStandalone = 2,
  NSFormattingContextListItem = 3,
  NSFormattingContextBeginningOfSentence = 4,
  NSFormattingContextMiddleOfSentence = 5,
}

declare enum NSFormattingUnitStyle {
  NSFormattingUnitStyleShort = 1,
  NSFormattingUnitStyleMedium,
  NSFormattingUnitStyleLong,
}

class NSGarbageCollectorAllocator<T extends NSGarbageCollector> extends NSObjectAllocator<T> {}
declare class NSGarbageCollector extends NSObject {
  alloc<T extends NSGarbageCollector>(): NSGarbageCollectorAllocator<T>;
  static defaultCollector(): any;
  isCollecting(): boolean;
  disable(): void;
  enable(): void;
  isEnabled(): boolean;
  collectIfNeeded(): void;
  collectExhaustively(): void;
  disableCollectorForPointer(ptr: void): void;
  enableCollectorForPointer(ptr: void): void;
  zone(): NSZone;
}

declare type NSPoint = CGPoint

declare type NSSize = CGSize

declare type NSRect = CGRect

declare type NSEdgeInsets = {
  top: CGFloat
  left: CGFloat
  bottom: CGFloat
  right: CGFloat
}

declare type NSPointPointer = NSPoint

declare type NSPointArray = NSPoint

declare type NSSizePointer = NSSize

declare type NSSizeArray = NSSize

declare type NSRectPointer = NSRect

declare type NSRectArray = NSRect

declare enum NSRectEdge {
  NSRectEdgeMinX = 0,
  NSRectEdgeMinY = 1,
  NSRectEdgeMaxX = 2,
  NSRectEdgeMaxY = 3,
  NSMinXEdge,
  NSMinYEdge,
  NSMaxXEdge,
  NSMaxYEdge,
}

declare enum NSAlignmentOptions {
  NSAlignMinXInward = 1 << 0,
  NSAlignMinYInward = 1 << 1,
  NSAlignMaxXInward = 1 << 2,
  NSAlignMaxYInward = 1 << 3,
  NSAlignWidthInward = 1 << 4,
  NSAlignHeightInward = 1 << 5,
  NSAlignMinXOutward = 1 << 8,
  NSAlignMinYOutward = 1 << 9,
  NSAlignMaxXOutward = 1 << 10,
  NSAlignMaxYOutward = 1 << 11,
  NSAlignWidthOutward = 1 << 12,
  NSAlignHeightOutward = 1 << 13,
  NSAlignMinXNearest = 1 << 16,
  NSAlignMinYNearest = 1 << 17,
  NSAlignMaxXNearest = 1 << 18,
  NSAlignMaxYNearest = 1 << 19,
  NSAlignWidthNearest = 1 << 20,
  NSAlignHeightNearest = 1 << 21,
  NSAlignRectFlipped = 1 << 63,
  NSAlignAllEdgesInward,
  NSAlignAllEdgesOutward,
  NSAlignAllEdgesNearest,
}

class NSHTTPCookieAllocator<T extends NSHTTPCookie> extends NSObjectAllocator<T> {
  initWithProperties(properties: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class NSHTTPCookie extends NSObject {
  alloc<T extends NSHTTPCookie>(): NSHTTPCookieAllocator<T>;
  static cookieWithProperties(properties: NSDictionary<any, any> | {[key: string]: any}): NSHTTPCookie;
  static requestHeaderFieldsWithCookies(cookies: NSArray<any> | any[]): NSDictionary<any, any>;
  static cookiesWithResponseHeaderFields_forURL(headerFields: NSDictionary<any, any> | {[key: string]: any}, URL: NSURL): NSArray<any>;

  properties(): NSDictionary<any, any>;
  version(): NSUInteger;
  name(): NSString;
  value(): NSString;
  expiresDate(): NSDate;
  sessionOnly(): boolean;
  domain(): NSString;
  path(): NSString;
  secure(): boolean;
  HTTPOnly(): boolean;
  comment(): NSString;
  commentURL(): NSURL;
  portList(): NSArray<any>;
}

declare type NSHTTPCookiePropertyKey = NSString

class NSHTTPCookieStorageAllocator<T extends NSHTTPCookieStorage> extends NSObjectAllocator<T> {}
declare class NSHTTPCookieStorage extends NSObject {
  alloc<T extends NSHTTPCookieStorage>(): NSHTTPCookieStorageAllocator<T>;
  static sharedCookieStorageForGroupContainerIdentifier(identifier: NSString | string): NSHTTPCookieStorage;
  setCookie(cookie: NSHTTPCookie): void;
  deleteCookie(cookie: NSHTTPCookie): void;
  removeCookiesSinceDate(date: NSDate): void;
  cookiesForURL(URL: NSURL): NSArray<any>;
  setCookies_forURL_mainDocumentURL(cookies: NSArray<any> | any[], URL: NSURL | null, mainDocumentURL: NSURL | null): void;
  sortedCookiesUsingDescriptors(sortOrder: NSArray<any> | any[]): NSArray<any>;
  storeCookies_forTask(cookies: NSArray<any> | any[], task: NSURLSessionTask): void;
  getCookiesForTask_completionHandler(task: NSURLSessionTask, completionHandler: Block): void;

  static sharedHTTPCookieStorage(): NSHTTPCookieStorage;
  cookies(): NSArray<any>;
  cookieAcceptPolicy(): NSHTTPCookieAcceptPolicy;
  setCookieAcceptPolicy(cookieAcceptPolicy: NSHTTPCookieAcceptPolicy): void;
}

declare enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways,
  NSHTTPCookieAcceptPolicyNever,
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
}

class NSHashTableAllocator<ObjectType, T extends NSHashTable<ObjectType>> extends NSObjectAllocator<T> {
  initWithOptions_capacity(options: NSPointerFunctionsOptions, initialCapacity: NSUInteger): T;
  initWithPointerFunctions_capacity(functions: NSPointerFunctions, initialCapacity: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSHashTable<ObjectType> extends NSObject implements INSCopying, INSCoding, INSFastEnumeration {
  alloc<T extends NSHashTable<ObjectType>>(): NSHashTableAllocator<ObjectType, T>;
  static hashTableWithOptions(options: NSPointerFunctionsOptions): NSHashTable<any>;
  static hashTableWithWeakObjects(): any;
  static weakObjectsHashTable(): NSHashTable<any>;
  member(object: ObjectType | null): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  addObject(object: ObjectType | null): void;
  removeObject(object: ObjectType | null): void;
  removeAllObjects(): void;
  containsObject(anObject: ObjectType | null): boolean;
  intersectsHashTable(other: NSHashTable<any>): boolean;
  isEqualToHashTable(other: NSHashTable<any>): boolean;
  isSubsetOfHashTable(other: NSHashTable<any>): boolean;
  intersectHashTable(other: NSHashTable<any>): void;
  unionHashTable(other: NSHashTable<any>): void;
  minusHashTable(other: NSHashTable<any>): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  pointerFunctions(): NSPointerFunctions;
  count(): NSUInteger;
  allObjects(): NSArray<any>;
  anyObject(): ObjectType;
  setRepresentation(): NSSet<any>;
}

declare type NSHashEnumerator = {
  _pi: NSUInteger
  _si: NSUInteger
  _bs: void
}

declare type NSHashTableCallBacks = any

declare type NSHashTableOptions = NSUInteger

class NSHostAllocator<T extends NSHost> extends NSObjectAllocator<T> {}
declare class NSHost extends NSObject {
  alloc<T extends NSHost>(): NSHostAllocator<T>;
  static currentHost(): NSHost;
  static hostWithName(name: NSString | string | null): NSHost;
  static hostWithAddress(address: NSString | string): NSHost;
  isEqualToHost(aHost: NSHost): boolean;
  static setHostCacheEnabled(flag: boolean): void;
  static isHostCacheEnabled(): boolean;
  static flushHostCache(): void;

  name(): NSString;
  names(): NSArray<any>;
  address(): NSString;
  addresses(): NSArray<any>;
  localizedName(): NSString;
}

class NSISO8601DateFormatterAllocator<T extends NSISO8601DateFormatter> extends NSFormatterAllocator<T> {
  init(): T;
}
declare class NSISO8601DateFormatter extends NSFormatter implements INSSecureCoding {
  alloc<T extends NSISO8601DateFormatter>(): NSISO8601DateFormatterAllocator<T>;
  stringFromDate(date: NSDate): NSString;
  dateFromString(string: NSString | string): NSDate;
  static stringFromDate_timeZone_formatOptions(date: NSDate, timeZone: NSTimeZone, formatOptions: NSISO8601DateFormatOptions): NSString;

  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  formatOptions(): NSISO8601DateFormatOptions;
  setFormatOptions(formatOptions: NSISO8601DateFormatOptions): void;
  static supportsSecureCoding(): boolean;
}

declare enum NSISO8601DateFormatOptions {
  NSISO8601DateFormatWithYear,
  NSISO8601DateFormatWithMonth,
  NSISO8601DateFormatWithWeekOfYear,
  NSISO8601DateFormatWithDay,
  NSISO8601DateFormatWithTime,
  NSISO8601DateFormatWithTimeZone,
  NSISO8601DateFormatWithSpaceBetweenDateAndTime,
  NSISO8601DateFormatWithDashSeparatorInDate,
  NSISO8601DateFormatWithColonSeparatorInTime,
  NSISO8601DateFormatWithColonSeparatorInTimeZone,
  NSISO8601DateFormatWithFractionalSeconds,
  NSISO8601DateFormatWithFullDate,
  NSISO8601DateFormatWithFullTime,
  NSISO8601DateFormatWithInternetDateTime,
}

class NSIndexPathAllocator<T extends NSIndexPath> extends NSObjectAllocator<T> {
  initWithIndexes_length(indexes: NSUInteger[], length: NSUInteger): T;
  initWithIndex(index: NSUInteger): T;
}
declare class NSIndexPath extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSIndexPath>(): NSIndexPathAllocator<T>;
  static indexPathWithIndex(index: NSUInteger): NSIndexPath;
  static indexPathWithIndexes_length(indexes: NSUInteger[], length: NSUInteger): NSIndexPath;
  indexPathByAddingIndex(index: NSUInteger): NSIndexPath;
  indexPathByRemovingLastIndex(): NSIndexPath;
  indexAtPosition(position: NSUInteger): NSUInteger;
  getIndexes_range(indexes: NSUInteger, positionRange: NSRange): void;
  compare(otherObject: NSIndexPath): NSComparisonResult;
  getIndexes(indexes: NSUInteger): void;
  static indexPathForItem_inSection(item: NSInteger, section: NSInteger): NSIndexPath;
  static indexPathForComponent_point_ofShape(component: MSVectorComponent, point: NSUInteger, shape: NSUInteger): NSIndexPath;
  static indexPathForPoint_ofShape(point: NSUInteger, shape: NSUInteger): NSIndexPath;
  indexPathWithComponent(component: MSVectorComponent): NSIndexPath;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  length(): NSUInteger;
  item(): NSInteger;
  section(): NSInteger;
  component(): MSVectorComponent;
  point(): NSUInteger;
  shape(): NSUInteger;
  handle(): MSPointType;
  static supportsSecureCoding(): boolean;
}

class NSIndexSetAllocator<T extends NSIndexSet> extends NSObjectAllocator<T> {
  initWithIndexesInRange(range: NSRange): T;
  initWithIndexSet(indexSet: NSIndexSet): T;
  initWithIndex(value: NSUInteger): T;
}
declare class NSIndexSet extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSIndexSet>(): NSIndexSetAllocator<T>;
  static indexSet(): NSIndexSet;
  static indexSetWithIndex(value: NSUInteger): NSIndexSet;
  static indexSetWithIndexesInRange(range: NSRange): NSIndexSet;
  isEqualToIndexSet(indexSet: NSIndexSet): boolean;
  indexGreaterThanIndex(value: NSUInteger): NSUInteger;
  indexLessThanIndex(value: NSUInteger): NSUInteger;
  indexGreaterThanOrEqualToIndex(value: NSUInteger): NSUInteger;
  indexLessThanOrEqualToIndex(value: NSUInteger): NSUInteger;
  getIndexes_maxCount_inIndexRange(indexBuffer: NSUInteger, bufferSize: NSUInteger, range: NSRangePointer | null): NSUInteger;
  countOfIndexesInRange(range: NSRange): NSUInteger;
  containsIndex(value: NSUInteger): boolean;
  containsIndexesInRange(range: NSRange): boolean;
  containsIndexes(indexSet: NSIndexSet): boolean;
  intersectsIndexesInRange(range: NSRange): boolean;
  enumerateIndexesUsingBlock(block: Block): void;
  enumerateIndexesWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateIndexesInRange_options_usingBlock(range: NSRange, opts: NSEnumerationOptions, block: Block): void;
  indexPassingTest(predicate: Block): NSUInteger;
  indexWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexInRange_options_passingTest(range: NSRange, opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexesPassingTest(predicate: Block): NSIndexSet;
  indexesWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexesInRange_options_passingTest(range: NSRange, opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  enumerateRangesUsingBlock(block: Block): void;
  enumerateRangesWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateRangesInRange_options_usingBlock(range: NSRange, opts: NSEnumerationOptions, block: Block): void;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  count(): NSUInteger;
  firstIndex(): NSUInteger;
  lastIndex(): NSUInteger;
  static supportsSecureCoding(): boolean;
}

class NSMutableIndexSetAllocator<T extends NSMutableIndexSet> extends NSIndexSetAllocator<T> {}
declare class NSMutableIndexSet extends NSIndexSet {
  alloc<T extends NSMutableIndexSet>(): NSMutableIndexSetAllocator<T>;
  addIndexes(indexSet: NSIndexSet): void;
  removeIndexes(indexSet: NSIndexSet): void;
  removeAllIndexes(): void;
  addIndex(value: NSUInteger): void;
  removeIndex(value: NSUInteger): void;
  addIndexesInRange(range: NSRange): void;
  removeIndexesInRange(range: NSRange): void;
  shiftIndexesStartingAtIndex_by(index: NSUInteger, delta: NSInteger): void;
}

class NSInvocationAllocator<T extends NSInvocation> extends NSObjectAllocator<T> {}
declare class NSInvocation extends NSObject {
  alloc<T extends NSInvocation>(): NSInvocationAllocator<T>;
  static invocationWithMethodSignature(sig: NSMethodSignature): NSInvocation;
  retainArguments(): void;
  getReturnValue(retLoc: void): void;
  setReturnValue(retLoc: void): void;
  getArgument_atIndex(argumentLocation: void, idx: NSInteger): void;
  setArgument_atIndex(argumentLocation: void, idx: NSInteger): void;
  invoke(): void;
  invokeWithTarget(target: any): void;

  methodSignature(): NSMethodSignature;
  argumentsRetained(): boolean;
  target(): any;
  setTarget(target: any): void;
  selector(): string;
  setSelector(selector: string): void;
}

class NSItemProviderAllocator<T extends NSItemProvider> extends NSObjectAllocator<T> {
  init(): T;
  initWithObject(object: any): T;
  initWithItem_typeIdentifier(item: any | null, typeIdentifier: NSString | string | null): T;
  initWithContentsOfURL(fileURL: NSURL): T;
}
declare class NSItemProvider extends NSObject implements INSCopying {
  alloc<T extends NSItemProvider>(): NSItemProviderAllocator<T>;
  registerDataRepresentationForTypeIdentifier_visibility_loadHandler(typeIdentifier: NSString | string, visibility: NSItemProviderRepresentationVisibility, loadHandler: Block): void;
  registerFileRepresentationForTypeIdentifier_fileOptions_visibility_loadHandler(typeIdentifier: NSString | string, fileOptions: NSItemProviderFileOptions, visibility: NSItemProviderRepresentationVisibility, loadHandler: Block): void;
  registeredTypeIdentifiersWithFileOptions(fileOptions: NSItemProviderFileOptions): NSArray<any>;
  hasItemConformingToTypeIdentifier(typeIdentifier: NSString | string): boolean;
  hasRepresentationConformingToTypeIdentifier_fileOptions(typeIdentifier: NSString | string, fileOptions: NSItemProviderFileOptions): boolean;
  loadDataRepresentationForTypeIdentifier_completionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;
  loadFileRepresentationForTypeIdentifier_completionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;
  loadInPlaceFileRepresentationForTypeIdentifier_completionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;
  registerObject_visibility(object: any, visibility: NSItemProviderRepresentationVisibility): void;
  registerObjectOfClass_visibility_loadHandler(aClass: any, visibility: NSItemProviderRepresentationVisibility, loadHandler: Block): void;
  canLoadObjectOfClass(aClass: any): boolean;
  loadObjectOfClass_completionHandler(aClass: any, completionHandler: Block): NSProgress;
  registerItemForTypeIdentifier_loadHandler(typeIdentifier: NSString | string, loadHandler: NSItemProviderLoadHandler): void;
  loadItemForTypeIdentifier_options_completionHandler(typeIdentifier: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null, completionHandler: NSItemProviderCompletionHandler | null): void;
  loadPreviewImageWithOptions_completionHandler(options: NSDictionary<any, any> | {[key: string]: any}, completionHandler: NSItemProviderCompletionHandler): void;
  registerCloudKitShareWithPreparationHandler(preparationHandler: Block): void;
  registerCloudKitShare_container(share: CKShare, container: CKContainer): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  registeredTypeIdentifiers(): NSArray<any>;
  suggestedName(): NSString;
  setSuggestedName(suggestedName: NSString | string): void;
  previewImageHandler(): NSItemProviderLoadHandler;
  setPreviewImageHandler(previewImageHandler: NSItemProviderLoadHandler): void;
  sourceFrame(): NSRect;
  containerFrame(): NSRect;
  preferredPresentationSize(): NSSize;
}

declare interface INSItemProviderWriting {
  itemProviderVisibilityForRepresentationWithTypeIdentifier(typeIdentifier: NSString | string): NSItemProviderRepresentationVisibility;
  loadDataWithTypeIdentifier_forItemProviderCompletionHandler(typeIdentifier: NSString | string, completionHandler: Block): NSProgress;

  writableTypeIdentifiersForItemProvider(): NSArray<any>;
}

declare interface INSItemProviderReading {

  // static readableTypeIdentifiersForItemProvider(): NSArray<any>;
}

declare enum NSItemProviderRepresentationVisibility {
  NSItemProviderRepresentationVisibilityAll = 0,
  NSItemProviderRepresentationVisibilityTeam = 1,
  NSItemProviderRepresentationVisibilityGroup = 2,
  NSItemProviderRepresentationVisibilityOwnProcess = 3,
}

declare enum NSItemProviderFileOptions {
  NSItemProviderFileOptionOpenInPlace = 1,
}

declare enum NSItemProviderErrorCode {
  NSItemProviderUnknownError = -1,
  NSItemProviderItemUnavailableError = -1000,
  NSItemProviderUnexpectedValueClassError = -1100,
  NSItemProviderUnavailableCoercionError = -1200,
}

class NSJSONSerializationAllocator<T extends NSJSONSerialization> extends NSObjectAllocator<T> {}
declare class NSJSONSerialization extends NSObject {
  alloc<T extends NSJSONSerialization>(): NSJSONSerializationAllocator<T>;
  static isValidJSONObject(obj: any): boolean;
  static dataWithJSONObject_options_error(obj: any, opt: NSJSONWritingOptions, error: NSError): NSData;
  static JSONObjectWithData_options_error(data: NSData, opt: NSJSONReadingOptions, error: NSError): any;
  static writeJSONObject_toStream_options_error(obj: any, stream: NSOutputStream, opt: NSJSONWritingOptions, error: NSError): NSInteger;
  static JSONObjectWithStream_options_error(stream: NSInputStream, opt: NSJSONReadingOptions, error: NSError): any;
}

declare enum NSJSONReadingOptions {
  NSJSONReadingMutableContainers,
  NSJSONReadingMutableLeaves,
  NSJSONReadingAllowFragments,
}

declare enum NSJSONWritingOptions {
  NSJSONWritingPrettyPrinted,
  NSJSONWritingSortedKeys,
}

class NSOrderedSetAllocator<ObjectType, T extends NSOrderedSet<ObjectType>> extends NSObjectAllocator<T> {
  init(): T;
  initWithObjects_count(objects: ObjectType[], cnt: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithObject(object: ObjectType): T;
  initWithObjects(firstObj: ObjectType, ...args: any[]): T;
  initWithOrderedSet(set: NSOrderedSet<any>): T;
  initWithOrderedSet_copyItems(set: NSOrderedSet<any>, flag: boolean): T;
  initWithOrderedSet_range_copyItems(set: NSOrderedSet<any>, range: NSRange, flag: boolean): T;
  initWithArray(array: NSArray<any> | any[]): T;
  initWithArray_copyItems(set: NSArray<any> | any[], flag: boolean): T;
  initWithArray_range_copyItems(set: NSArray<any> | any[], range: NSRange, flag: boolean): T;
  initWithSet(set: NSSet<any>): T;
  initWithSet_copyItems(set: NSSet<any>, flag: boolean): T;
}
declare class NSOrderedSet<ObjectType> extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {
  alloc<T extends NSOrderedSet<ObjectType>>(): NSOrderedSetAllocator<ObjectType, T>;
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  objectAtIndex(idx: NSUInteger): ObjectType;
  indexOfObject(object: ObjectType): NSUInteger;
  getObjects_range(objects: ObjectType[], range: NSRange): void;
  objectsAtIndexes(indexes: NSIndexSet): NSArray<any>;
  isEqualToOrderedSet(other: NSOrderedSet<any>): boolean;
  containsObject(object: ObjectType): boolean;
  intersectsOrderedSet(other: NSOrderedSet<any>): boolean;
  intersectsSet(set: NSSet<any>): boolean;
  isSubsetOfOrderedSet(other: NSOrderedSet<any>): boolean;
  isSubsetOfSet(set: NSSet<any>): boolean;
  objectAtIndexedSubscript(idx: NSUInteger): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  reverseObjectEnumerator(): NSEnumerator<any>;
  enumerateObjectsUsingBlock(block: Block): void;
  enumerateObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  enumerateObjectsAtIndexes_options_usingBlock(s: NSIndexSet, opts: NSEnumerationOptions, block: Block): void;
  indexOfObjectPassingTest(predicate: Block): NSUInteger;
  indexOfObjectWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexOfObjectAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSUInteger;
  indexesOfObjectsPassingTest(predicate: Block): NSIndexSet;
  indexesOfObjectsWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexesOfObjectsAtIndexes_options_passingTest(s: NSIndexSet, opts: NSEnumerationOptions, predicate: Block): NSIndexSet;
  indexOfObject_inSortedRange_options_usingComparator(object: ObjectType, range: NSRange, opts: NSBinarySearchingOptions, cmp: NSComparator): NSUInteger;
  sortedArrayUsingComparator(cmptr: NSComparator): NSArray<any>;
  sortedArrayWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): NSArray<any>;
  descriptionWithLocale(locale: any | null): NSString;
  descriptionWithLocale_indent(locale: any | null, level: NSUInteger): NSString;
  static orderedSet<ObjectType>(): NSOrderedSet<ObjectType>;
  static orderedSetWithObject<ObjectType>(object: ObjectType): NSOrderedSet<ObjectType>;
  static orderedSetWithObjects_count<ObjectType>(objects: ObjectType[], cnt: NSUInteger): NSOrderedSet<ObjectType>;
  static orderedSetWithObjects<ObjectType>(firstObj: ObjectType, ...args: any[]): NSOrderedSet<ObjectType>;
  static orderedSetWithOrderedSet<ObjectType>(set: NSOrderedSet<any>): NSOrderedSet<ObjectType>;
  static orderedSetWithOrderedSet_range_copyItems<ObjectType>(set: NSOrderedSet<any>, range: NSRange, flag: boolean): NSOrderedSet<ObjectType>;
  static orderedSetWithArray<ObjectType>(array: NSArray<any> | any[]): NSOrderedSet<ObjectType>;
  static orderedSetWithArray_range_copyItems<ObjectType>(array: NSArray<any> | any[], range: NSRange, flag: boolean): NSOrderedSet<ObjectType>;
  static orderedSetWithSet<ObjectType>(set: NSSet<any>): NSOrderedSet<ObjectType>;
  static orderedSetWithSet_copyItems<ObjectType>(set: NSSet<any>, flag: boolean): NSOrderedSet<ObjectType>;
  filteredOrderedSetUsingPredicate(p: NSPredicate): NSOrderedSet<any>;
  sortedArrayUsingDescriptors(sortDescriptors: NSArray<any> | any[]): NSArray<any>;
  mo_objectForIndexedSubscript(idx: NSUInteger): any;
  smk_map(mappingBlock: Block): NSOrderedSet<any>;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  count(): NSUInteger;
  firstObject(): ObjectType;
  lastObject(): ObjectType;
  reversedOrderedSet(): NSOrderedSet<any>;
  array(): NSArray<any>;
  set(): NSSet<any>;
  description(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSSetAllocator<ObjectType, T extends NSSet<ObjectType>> extends NSObjectAllocator<T> {
  init(): T;
  initWithObjects_count(objects: ObjectType[], cnt: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithObjects(firstObj: ObjectType, ...args: any[]): T;
  initWithSet(set: NSSet<any>): T;
  initWithSet_copyItems(set: NSSet<any>, flag: boolean): T;
  initWithArray(array: NSArray<any> | any[]): T;
}
declare class NSSet<ObjectType> extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding, INSFastEnumeration {
  alloc<T extends NSSet<ObjectType>>(): NSSetAllocator<ObjectType, T>;
  valueForKey(key: NSString | string): any;
  setValue_forKey(value: any | null, key: NSString | string): void;
  addObserver_forKeyPath_options_context(observer: NSObject, keyPath: NSString | string, options: NSKeyValueObservingOptions, context: void | null): void;
  removeObserver_forKeyPath_context(observer: NSObject, keyPath: NSString | string, context: void | null): void;
  removeObserver_forKeyPath(observer: NSObject, keyPath: NSString | string): void;
  filteredSetUsingPredicate(predicate: NSPredicate): NSSet<any>;
  member(object: ObjectType): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  anyObject(): ObjectType;
  containsObject(anObject: ObjectType): boolean;
  descriptionWithLocale(locale: any | null): NSString;
  intersectsSet(otherSet: NSSet<any>): boolean;
  isEqualToSet(otherSet: NSSet<any>): boolean;
  isSubsetOfSet(otherSet: NSSet<any>): boolean;
  makeObjectsPerformSelector(aSelector: string): void;
  makeObjectsPerformSelector_withObject(aSelector: string, argument: any | null): void;
  setByAddingObject(anObject: ObjectType): NSSet<any>;
  setByAddingObjectsFromSet(other: NSSet<any>): NSSet<any>;
  setByAddingObjectsFromArray(other: NSArray<any> | any[]): NSSet<any>;
  enumerateObjectsUsingBlock(block: Block): void;
  enumerateObjectsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  objectsPassingTest(predicate: Block): NSSet<any>;
  objectsWithOptions_passingTest(opts: NSEnumerationOptions, predicate: Block): NSSet<any>;
  static set<ObjectType>(): NSSet<ObjectType>;
  static setWithObject<ObjectType>(object: ObjectType): NSSet<ObjectType>;
  static setWithObjects_count<ObjectType>(objects: ObjectType[], cnt: NSUInteger): NSSet<ObjectType>;
  static setWithObjects<ObjectType>(firstObj: ObjectType, ...args: any[]): NSSet<ObjectType>;
  static setWithSet<ObjectType>(set: NSSet<any>): NSSet<ObjectType>;
  static setWithArray<ObjectType>(array: NSArray<any> | any[]): NSSet<ObjectType>;
  sortedArrayUsingDescriptors(sortDescriptors: NSArray<any> | any[]): NSArray<any>;
  static setWithCollectionViewIndexPath<ObjectType>(indexPath: NSIndexPath): NSSet<ObjectType>;
  static setWithCollectionViewIndexPaths<ObjectType>(indexPaths: NSArray<any> | any[]): NSSet<ObjectType>;
  enumerateIndexPathsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  each(block: Block): void;
  map(block: Block): NSSet<ObjectType>;
  containsObjectPassingTest(predicate: Block): boolean;
  isEquivalentToArray_bc(array: NSArray<any> | any[]): boolean;
  sortedArrayUsingKey(key: NSString | string): NSArray<any>;
  setMinusSet(otherSet: NSSet<any>): NSSet<any>;
  sck_flatMap(transform: Block): NSSet<any>;
  sortedOffsets_ms(): NSArray<any>;
  offsetsInBezierInterval_ms(): NSSet<any>;
  sortedOffsetsInBezierInterval_ms(): NSArray<any>;
  firstOffsetInBezierInterval_ms(): NSNumber;
  lastOffsetInBezierInterval_ms(): NSNumber;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  count(): NSUInteger;
  allObjects(): NSArray<any>;
  description(): NSString;
  static supportsSecureCoding(): boolean;
}

declare type NSKeyValueOperator = NSString

declare type NSKeyValueChangeKey = NSString

declare enum NSKeyValueObservingOptions {
  NSKeyValueObservingOptionNew = 0x01,
  NSKeyValueObservingOptionOld = 0x02,
  NSKeyValueObservingOptionInitial = 0x04,
  NSKeyValueObservingOptionPrior = 0x08,
}

declare enum NSKeyValueChange {
  NSKeyValueChangeSetting = 1,
  NSKeyValueChangeInsertion = 2,
  NSKeyValueChangeRemoval = 3,
  NSKeyValueChangeReplacement = 4,
}

declare enum NSKeyValueSetMutationKind {
  NSKeyValueUnionSetMutation = 1,
  NSKeyValueMinusSetMutation = 2,
  NSKeyValueIntersectSetMutation = 3,
  NSKeyValueSetSetMutation = 4,
}

class NSKeyedArchiverAllocator<T extends NSKeyedArchiver> extends NSCoderAllocator<T> {
  init(): T;
  initForWritingWithMutableData(data: NSMutableData): T;
}
declare class NSKeyedArchiver extends NSCoder {
  alloc<T extends NSKeyedArchiver>(): NSKeyedArchiverAllocator<T>;
  static archivedDataWithRootObject(rootObject: any): NSData;
  static archiveRootObject_toFile(rootObject: any, path: NSString | string): boolean;
  finishEncoding(): void;
  setClassName_forClass(codedName: NSString | string | null, cls: any): void;
  classNameForClass(cls: any): NSString;
  encodeObject_forKey(object: any | null, key: NSString | string): void;
  encodeConditionalObject_forKey(object: any | null, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeInt_forKey(value: number, key: NSString | string): void;
  encodeInt32_forKey(value: number, key: NSString | string): void;
  encodeInt64_forKey(value: number, key: NSString | string): void;
  encodeFloat_forKey(value: number, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBytes_length_forKey(bytes: number | null, length: NSUInteger, key: NSString | string): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  outputFormat(): NSPropertyListFormat;
  setOutputFormat(outputFormat: NSPropertyListFormat): void;
  encodedData(): NSData;
  requiresSecureCoding(): boolean;
  setRequiresSecureCoding(requiresSecureCoding: boolean): void;
}

class NSKeyedUnarchiverAllocator<T extends NSKeyedUnarchiver> extends NSCoderAllocator<T> {
  initForReadingWithData(data: NSData): T;
}
declare class NSKeyedUnarchiver extends NSCoder {
  alloc<T extends NSKeyedUnarchiver>(): NSKeyedUnarchiverAllocator<T>;
  static unarchiveObjectWithData(data: NSData): any;
  static unarchiveObjectWithFile(path: NSString | string): any;
  finishDecoding(): void;
  setClass_forClassName(cls: any | null, codedName: NSString | string): void;
  classForClassName(codedName: NSString | string): any;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeBoolForKey(key: NSString | string): boolean;
  decodeIntForKey(key: NSString | string): number;
  decodeInt32ForKey(key: NSString | string): number;
  decodeInt64ForKey(key: NSString | string): number;
  decodeFloatForKey(key: NSString | string): number;
  decodeDoubleForKey(key: NSString | string): number;
  decodeBytesForKey_returnedLength(key: NSString | string, lengthp: NSUInteger | null): number;

  delegate(): any;
  setDelegate(delegate: any): void;
  requiresSecureCoding(): boolean;
  setRequiresSecureCoding(requiresSecureCoding: boolean): void;
  decodingFailurePolicy(): NSDecodingFailurePolicy;
  setDecodingFailurePolicy(decodingFailurePolicy: NSDecodingFailurePolicy): void;
}

declare interface INSKeyedArchiverDelegate {
  archiver_willEncodeObject(archiver: NSKeyedArchiver, object: any): any;
  archiver_didEncodeObject(archiver: NSKeyedArchiver, object: any | null): void;
  archiver_willReplaceObject_withObject(archiver: NSKeyedArchiver, object: any | null, newObject: any | null): void;
  archiverWillFinish(archiver: NSKeyedArchiver): void;
  archiverDidFinish(archiver: NSKeyedArchiver): void;
}

declare interface INSKeyedUnarchiverDelegate {
  unarchiver_cannotDecodeObjectOfClassName_originalClasses(unarchiver: NSKeyedUnarchiver, name: NSString | string, classNames: NSArray<any> | any[]): any;
  unarchiver_willReplaceObject_withObject(unarchiver: NSKeyedUnarchiver, object: any, newObject: any): void;
  unarchiverWillFinish(unarchiver: NSKeyedUnarchiver): void;
  unarchiverDidFinish(unarchiver: NSKeyedUnarchiver): void;
}

class NSLengthFormatterAllocator<T extends NSLengthFormatter> extends NSFormatterAllocator<T> {}
declare class NSLengthFormatter extends NSFormatter {
  alloc<T extends NSLengthFormatter>(): NSLengthFormatterAllocator<T>;
  stringFromValue_unit(value: number, unit: NSLengthFormatterUnit): NSString;
  stringFromMeters(numberInMeters: number): NSString;
  unitStringFromValue_unit(value: number, unit: NSLengthFormatterUnit): NSString;
  unitStringFromMeters_usedUnit(numberInMeters: number, unitp: NSLengthFormatterUnit | null): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  forPersonHeightUse(): boolean;
  setForPersonHeightUse(forPersonHeightUse: boolean): void;
}

declare enum NSLengthFormatterUnit {
  NSLengthFormatterUnitMillimeter = 8,
  NSLengthFormatterUnitCentimeter = 9,
  NSLengthFormatterUnitMeter = 11,
  NSLengthFormatterUnitKilometer = 14,
  NSLengthFormatterUnitInch,
  NSLengthFormatterUnitFoot,
  NSLengthFormatterUnitYard,
  NSLengthFormatterUnitMile,
}

class NSLinguisticTaggerAllocator<T extends NSLinguisticTagger> extends NSObjectAllocator<T> {
  initWithTagSchemes_options(tagSchemes: NSArray<any> | any[], opts: NSUInteger): T;
}
declare class NSLinguisticTagger extends NSObject {
  alloc<T extends NSLinguisticTagger>(): NSLinguisticTaggerAllocator<T>;
  static availableTagSchemesForUnit_language(unit: NSLinguisticTaggerUnit, language: NSString | string): NSArray<any>;
  static availableTagSchemesForLanguage(language: NSString | string): NSArray<any>;
  setOrthography_range(orthography: NSOrthography | null, range: NSRange): void;
  orthographyAtIndex_effectiveRange(charIndex: NSUInteger, effectiveRange: NSRangePointer | null): NSOrthography;
  stringEditedInRange_changeInLength(newRange: NSRange, delta: NSInteger): void;
  tokenRangeAtIndex_unit(charIndex: NSUInteger, unit: NSLinguisticTaggerUnit): NSRange;
  sentenceRangeForRange(range: NSRange): NSRange;
  enumerateTagsInRange_unit_scheme_options_usingBlock(range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, block: Block): void;
  tagAtIndex_unit_scheme_tokenRange(charIndex: NSUInteger, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, tokenRange: NSRangePointer | null): NSLinguisticTag;
  tagsInRange_unit_scheme_options_tokenRanges(range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  enumerateTagsInRange_scheme_options_usingBlock(range: NSRange, tagScheme: NSLinguisticTagScheme, opts: NSLinguisticTaggerOptions, block: Block): void;
  tagAtIndex_scheme_tokenRange_sentenceRange(charIndex: NSUInteger, scheme: NSLinguisticTagScheme, tokenRange: NSRangePointer | null, sentenceRange: NSRangePointer | null): NSLinguisticTag;
  tagsInRange_scheme_options_tokenRanges(range: NSRange, tagScheme: NSString | string, opts: NSLinguisticTaggerOptions, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  static dominantLanguageForString(string: NSString | string): NSString;
  static tagForString_atIndex_unit_scheme_orthography_tokenRange(string: NSString | string, charIndex: NSUInteger, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, orthography: NSOrthography | null, tokenRange: NSRangePointer | null): NSLinguisticTag;
  static tagsForString_range_unit_scheme_options_orthography_tokenRanges(string: NSString | string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, tokenRanges: NSArray<any> | any[]): NSArray<any>;
  static enumerateTagsForString_range_unit_scheme_options_orthography_usingBlock(string: NSString | string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: NSLinguisticTagScheme, options: NSLinguisticTaggerOptions, orthography: NSOrthography | null, block: Block): void;
  possibleTagsAtIndex_scheme_tokenRange_sentenceRange_scores(charIndex: NSUInteger, tagScheme: NSString | string, tokenRange: NSRangePointer | null, sentenceRange: NSRangePointer | null, scores: NSArray<any> | any[]): NSArray<any>;

  tagSchemes(): NSArray<any>;
  string(): NSString;
  setString(string: NSString | string): void;
  dominantLanguage(): NSString;
}

declare type NSLinguisticTagScheme = NSString

declare type NSLinguisticTag = NSString

declare enum NSLinguisticTaggerUnit {
  NSLinguisticTaggerUnitWord,
  NSLinguisticTaggerUnitSentence,
  NSLinguisticTaggerUnitParagraph,
  NSLinguisticTaggerUnitDocument,
}

declare enum NSLinguisticTaggerOptions {
  NSLinguisticTaggerOmitWords = 1 << 0,
  NSLinguisticTaggerOmitPunctuation = 1 << 1,
  NSLinguisticTaggerOmitWhitespace = 1 << 2,
  NSLinguisticTaggerOmitOther = 1 << 3,
  NSLinguisticTaggerJoinNames = 1 << 4,
}

class NSLocaleAllocator<T extends NSLocale> extends NSObjectAllocator<T> {
  initWithLocaleIdentifier(string: NSString | string): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSLocale extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSLocale>(): NSLocaleAllocator<T>;
  objectForKey(key: NSLocaleKey): any;
  displayNameForKey_value(key: NSLocaleKey, value: any): NSString;
  localizedStringForLocaleIdentifier(localeIdentifier: NSString | string): NSString;
  localizedStringForLanguageCode(languageCode: NSString | string): NSString;
  localizedStringForCountryCode(countryCode: NSString | string): NSString;
  localizedStringForScriptCode(scriptCode: NSString | string): NSString;
  localizedStringForVariantCode(variantCode: NSString | string): NSString;
  localizedStringForCalendarIdentifier(calendarIdentifier: NSString | string): NSString;
  localizedStringForCollationIdentifier(collationIdentifier: NSString | string): NSString;
  localizedStringForCurrencyCode(currencyCode: NSString | string): NSString;
  localizedStringForCollatorIdentifier(collatorIdentifier: NSString | string): NSString;
  static localeWithLocaleIdentifier(ident: NSString | string): NSLocale;
  static componentsFromLocaleIdentifier(string: NSString | string): NSDictionary<any, any>;
  static localeIdentifierFromComponents(dict: NSDictionary<any, any> | {[key: string]: any}): NSString;
  static canonicalLocaleIdentifierFromString(string: NSString | string): NSString;
  static canonicalLanguageIdentifierFromString(string: NSString | string): NSString;
  static localeIdentifierFromWindowsLocaleCode(lcid: number): NSString;
  static windowsLocaleCodeFromLocaleIdentifier(localeIdentifier: NSString | string): number;
  static characterDirectionForLanguage(isoLangCode: NSString | string): NSLocaleLanguageDirection;
  static lineDirectionForLanguage(isoLangCode: NSString | string): NSLocaleLanguageDirection;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  localeIdentifier(): NSString;
  languageCode(): NSString;
  countryCode(): NSString;
  scriptCode(): NSString;
  variantCode(): NSString;
  exemplarCharacterSet(): NSCharacterSet;
  calendarIdentifier(): NSString;
  collationIdentifier(): NSString;
  usesMetricSystem(): boolean;
  decimalSeparator(): NSString;
  groupingSeparator(): NSString;
  currencySymbol(): NSString;
  currencyCode(): NSString;
  collatorIdentifier(): NSString;
  quotationBeginDelimiter(): NSString;
  quotationEndDelimiter(): NSString;
  alternateQuotationBeginDelimiter(): NSString;
  alternateQuotationEndDelimiter(): NSString;
  static autoupdatingCurrentLocale(): NSLocale;
  static currentLocale(): NSLocale;
  static systemLocale(): NSLocale;
  static availableLocaleIdentifiers(): NSArray<any>;
  static ISOLanguageCodes(): NSArray<any>;
  static ISOCountryCodes(): NSArray<any>;
  static ISOCurrencyCodes(): NSArray<any>;
  static commonISOCurrencyCodes(): NSArray<any>;
  static preferredLanguages(): NSArray<any>;
  static supportsSecureCoding(): boolean;
}

declare type NSLocaleKey = NSString

declare enum NSLocaleLanguageDirection {
  NSLocaleLanguageDirectionUnknown,
  NSLocaleLanguageDirectionLeftToRight,
  NSLocaleLanguageDirectionRightToLeft,
  NSLocaleLanguageDirectionTopToBottom,
  NSLocaleLanguageDirectionBottomToTop,
}

class NSLockAllocator<T extends NSLock> extends NSObjectAllocator<T> {}
declare class NSLock extends NSObject implements INSLocking {
  alloc<T extends NSLock>(): NSLockAllocator<T>;
  tryLock(): boolean;
  lockBeforeDate(limit: NSDate): boolean;
  lock(): void;
  unlock(): void;
  lock(): void;
  unlock(): void;

  name(): NSString;
  setName(name: NSString | string): void;
}

class NSConditionLockAllocator<T extends NSConditionLock> extends NSObjectAllocator<T> {
  initWithCondition(condition: NSInteger): T;
}
declare class NSConditionLock extends NSObject implements INSLocking {
  alloc<T extends NSConditionLock>(): NSConditionLockAllocator<T>;
  lockWhenCondition(condition: NSInteger): void;
  tryLock(): boolean;
  tryLockWhenCondition(condition: NSInteger): boolean;
  unlockWithCondition(condition: NSInteger): void;
  lockBeforeDate(limit: NSDate): boolean;
  lockWhenCondition_beforeDate(condition: NSInteger, limit: NSDate): boolean;
  lock(): void;
  unlock(): void;
  lock(): void;
  unlock(): void;

  condition(): NSInteger;
  name(): NSString;
  setName(name: NSString | string): void;
}

class NSRecursiveLockAllocator<T extends NSRecursiveLock> extends NSObjectAllocator<T> {}
declare class NSRecursiveLock extends NSObject implements INSLocking {
  alloc<T extends NSRecursiveLock>(): NSRecursiveLockAllocator<T>;
  tryLock(): boolean;
  lockBeforeDate(limit: NSDate): boolean;
  lock(): void;
  unlock(): void;
  lock(): void;
  unlock(): void;

  name(): NSString;
  setName(name: NSString | string): void;
}

class NSConditionAllocator<T extends NSCondition> extends NSObjectAllocator<T> {}
declare class NSCondition extends NSObject implements INSLocking {
  alloc<T extends NSCondition>(): NSConditionAllocator<T>;
  wait(): void;
  waitUntilDate(limit: NSDate): boolean;
  signal(): void;
  broadcast(): void;
  lock(): void;
  unlock(): void;
  lock(): void;
  unlock(): void;

  name(): NSString;
  setName(name: NSString | string): void;
}

declare interface INSLocking {
  lock(): void;
  unlock(): void;
}

class NSMapTableAllocator<KeyType, ObjectType, T extends NSMapTable<KeyType, ObjectType>> extends NSObjectAllocator<T> {
  initWithKeyOptions_valueOptions_capacity(keyOptions: NSPointerFunctionsOptions, valueOptions: NSPointerFunctionsOptions, initialCapacity: NSUInteger): T;
  initWithKeyPointerFunctions_valuePointerFunctions_capacity(keyFunctions: NSPointerFunctions, valueFunctions: NSPointerFunctions, initialCapacity: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSMapTable<KeyType, ObjectType> extends NSObject implements INSCopying, INSCoding, INSFastEnumeration {
  alloc<T extends NSMapTable<KeyType, ObjectType>>(): NSMapTableAllocator<KeyType, ObjectType, T>;
  static mapTableWithKeyOptions_valueOptions(keyOptions: NSPointerFunctionsOptions, valueOptions: NSPointerFunctionsOptions): NSMapTable<any, any>;
  static mapTableWithStrongToStrongObjects(): any;
  static mapTableWithWeakToStrongObjects(): any;
  static mapTableWithStrongToWeakObjects(): any;
  static mapTableWithWeakToWeakObjects(): any;
  static strongToStrongObjectsMapTable(): NSMapTable<any, any>;
  static weakToStrongObjectsMapTable(): NSMapTable<any, any>;
  static strongToWeakObjectsMapTable(): NSMapTable<any, any>;
  static weakToWeakObjectsMapTable(): NSMapTable<any, any>;
  objectForKey(aKey: KeyType | null): ObjectType;
  removeObjectForKey(aKey: KeyType | null): void;
  setObject_forKey(anObject: ObjectType | null, aKey: KeyType | null): void;
  keyEnumerator(): NSEnumerator<any>;
  objectEnumerator(): NSEnumerator<any>;
  removeAllObjects(): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
  enumerateKeysAndObjectsUsingBlock(block: Block): void;
  enumerateKeysUsingBlock(block: Block): void;
  enumerateObjectsUsingBlock(block: Block): void;
  objectForKeyedSubscript(key: any): any;
  setObject_forKeyedSubscript(obj: any, key: any): void;
  filter(block: BCMapTableFilterBlock): NSMapTable<any, any>;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  keyPointerFunctions(): NSPointerFunctions;
  valuePointerFunctions(): NSPointerFunctions;
  count(): NSUInteger;
}

declare type NSMapEnumerator = {
  _pi: NSUInteger
  _si: NSUInteger
  _bs: void
}

declare type NSMapTableKeyCallBacks = any

declare type NSMapTableValueCallBacks = any

declare type NSMapTableOptions = NSUInteger

class NSMassFormatterAllocator<T extends NSMassFormatter> extends NSFormatterAllocator<T> {}
declare class NSMassFormatter extends NSFormatter {
  alloc<T extends NSMassFormatter>(): NSMassFormatterAllocator<T>;
  stringFromValue_unit(value: number, unit: NSMassFormatterUnit): NSString;
  stringFromKilograms(numberInKilograms: number): NSString;
  unitStringFromValue_unit(value: number, unit: NSMassFormatterUnit): NSString;
  unitStringFromKilograms_usedUnit(numberInKilograms: number, unitp: NSMassFormatterUnit | null): NSString;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  forPersonMassUse(): boolean;
  setForPersonMassUse(forPersonMassUse: boolean): void;
}

declare enum NSMassFormatterUnit {
  NSMassFormatterUnitGram = 11,
  NSMassFormatterUnitKilogram = 14,
  NSMassFormatterUnitOunce,
  NSMassFormatterUnitPound,
  NSMassFormatterUnitStone,
}

class NSMeasurementAllocator<UnitType, T extends NSMeasurement<UnitType>> extends NSObjectAllocator<T> {
  initWithDoubleValue_unit(doubleValue: number, unit: UnitType): T;
}
declare class NSMeasurement<UnitType> extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSMeasurement<UnitType>>(): NSMeasurementAllocator<UnitType, T>;
  canBeConvertedToUnit(unit: NSUnit): boolean;
  measurementByConvertingToUnit(unit: NSUnit): NSMeasurement<any>;
  measurementByAddingMeasurement(measurement: NSMeasurement<any>): NSMeasurement<any>;
  measurementBySubtractingMeasurement(measurement: NSMeasurement<any>): NSMeasurement<any>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  unit(): UnitType;
  doubleValue(): number;
  static supportsSecureCoding(): boolean;
}

class NSMeasurementFormatterAllocator<T extends NSMeasurementFormatter> extends NSFormatterAllocator<T> {}
declare class NSMeasurementFormatter extends NSFormatter implements INSSecureCoding {
  alloc<T extends NSMeasurementFormatter>(): NSMeasurementFormatterAllocator<T>;
  stringFromMeasurement(measurement: NSMeasurement<any>): NSString;
  stringFromUnit(unit: NSUnit): NSString;

  unitOptions(): NSMeasurementFormatterUnitOptions;
  setUnitOptions(unitOptions: NSMeasurementFormatterUnitOptions): void;
  unitStyle(): NSFormattingUnitStyle;
  setUnitStyle(unitStyle: NSFormattingUnitStyle): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  static supportsSecureCoding(): boolean;
}

declare enum NSMeasurementFormatterUnitOptions {
  NSMeasurementFormatterUnitOptionsProvidedUnit,
  NSMeasurementFormatterUnitOptionsNaturalScale,
  NSMeasurementFormatterUnitOptionsTemperatureWithoutUnit,
}

class NSMetadataQueryAllocator<T extends NSMetadataQuery> extends NSObjectAllocator<T> {}
declare class NSMetadataQuery extends NSObject {
  alloc<T extends NSMetadataQuery>(): NSMetadataQueryAllocator<T>;
  startQuery(): boolean;
  stopQuery(): void;
  disableUpdates(): void;
  enableUpdates(): void;
  resultAtIndex(idx: NSUInteger): any;
  enumerateResultsUsingBlock(block: Block): void;
  enumerateResultsWithOptions_usingBlock(opts: NSEnumerationOptions, block: Block): void;
  indexOfResult(result: any): NSUInteger;
  valueOfAttribute_forResultAtIndex(attrName: NSString | string, idx: NSUInteger): any;

  delegate(): any;
  setDelegate(delegate: any): void;
  predicate(): NSPredicate;
  setPredicate(predicate: NSPredicate): void;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  valueListAttributes(): NSArray<any>;
  setValueListAttributes(valueListAttributes: NSArray<any> | any[]): void;
  groupingAttributes(): NSArray<any>;
  setGroupingAttributes(groupingAttributes: NSArray<any> | any[]): void;
  notificationBatchingInterval(): NSTimeInterval;
  setNotificationBatchingInterval(notificationBatchingInterval: NSTimeInterval): void;
  searchScopes(): NSArray<any>;
  setSearchScopes(searchScopes: NSArray<any> | any[]): void;
  searchItems(): NSArray<any>;
  setSearchItems(searchItems: NSArray<any> | any[]): void;
  operationQueue(): NSOperationQueue;
  setOperationQueue(operationQueue: NSOperationQueue): void;
  started(): boolean;
  gathering(): boolean;
  stopped(): boolean;
  resultCount(): NSUInteger;
  results(): NSArray<any>;
  valueLists(): NSDictionary<any, any>;
  groupedResults(): NSArray<any>;
}

class NSMetadataItemAllocator<T extends NSMetadataItem> extends NSObjectAllocator<T> {
  initWithURL(url: NSURL): T;
}
declare class NSMetadataItem extends NSObject {
  alloc<T extends NSMetadataItem>(): NSMetadataItemAllocator<T>;
  valueForAttribute(key: NSString | string): any;
  valuesForAttributes(keys: NSArray<any> | any[]): NSDictionary<any, any>;

  attributes(): NSArray<any>;
}

class NSMetadataQueryAttributeValueTupleAllocator<T extends NSMetadataQueryAttributeValueTuple> extends NSObjectAllocator<T> {}
declare class NSMetadataQueryAttributeValueTuple extends NSObject {
  alloc<T extends NSMetadataQueryAttributeValueTuple>(): NSMetadataQueryAttributeValueTupleAllocator<T>;

  attribute(): NSString;
  value(): any;
  count(): NSUInteger;
}

class NSMetadataQueryResultGroupAllocator<T extends NSMetadataQueryResultGroup> extends NSObjectAllocator<T> {}
declare class NSMetadataQueryResultGroup extends NSObject {
  alloc<T extends NSMetadataQueryResultGroup>(): NSMetadataQueryResultGroupAllocator<T>;
  resultAtIndex(idx: NSUInteger): any;

  attribute(): NSString;
  value(): any;
  subgroups(): NSArray<any>;
  resultCount(): NSUInteger;
  results(): NSArray<any>;
}

declare interface INSMetadataQueryDelegate {
  metadataQuery_replacementObjectForResultObject(query: NSMetadataQuery, result: NSMetadataItem): any;
  metadataQuery_replacementValueForAttribute_value(query: NSMetadataQuery, attrName: NSString | string, attrValue: any): any;
}

class NSMethodSignatureAllocator<T extends NSMethodSignature> extends NSObjectAllocator<T> {}
declare class NSMethodSignature extends NSObject {
  alloc<T extends NSMethodSignature>(): NSMethodSignatureAllocator<T>;
  static signatureWithObjCTypes(types: string): NSMethodSignature;
  getArgumentTypeAtIndex(idx: NSUInteger): string;
  isOneway(): boolean;

  numberOfArguments(): NSUInteger;
  frameLength(): NSUInteger;
  methodReturnType(): string;
  methodReturnLength(): NSUInteger;
}

class NSNetServiceAllocator<T extends NSNetService> extends NSObjectAllocator<T> {
  initWithDomain_type_name_port(domain: NSString | string, type: NSString | string, name: NSString | string, port: number): T;
  initWithDomain_type_name(domain: NSString | string, type: NSString | string, name: NSString | string): T;
}
declare class NSNetService extends NSObject {
  alloc<T extends NSNetService>(): NSNetServiceAllocator<T>;
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  publish(): void;
  publishWithOptions(options: NSNetServiceOptions): void;
  resolve(): void;
  stop(): void;
  static dictionaryFromTXTRecordData(txtData: NSData): NSDictionary<any, any>;
  static dataFromTXTRecordDictionary(txtDictionary: NSDictionary<any, any> | {[key: string]: any}): NSData;
  resolveWithTimeout(timeout: NSTimeInterval): void;
  getInputStream_outputStream(inputStream: NSInputStream, outputStream: NSOutputStream): boolean;
  setTXTRecordData(recordData: NSData | null): boolean;
  TXTRecordData(): NSData;
  startMonitoring(): void;
  stopMonitoring(): void;
  static addressStringWithData(data: NSData): NSString;

  delegate(): any;
  setDelegate(delegate: any): void;
  includesPeerToPeer(): boolean;
  setIncludesPeerToPeer(includesPeerToPeer: boolean): void;
  name(): NSString;
  type(): NSString;
  domain(): NSString;
  hostName(): NSString;
  addresses(): NSArray<any>;
  port(): NSInteger;
  addressStrings(): NSArray<any>;
}

class NSNetServiceBrowserAllocator<T extends NSNetServiceBrowser> extends NSObjectAllocator<T> {
  init(): T;
}
declare class NSNetServiceBrowser extends NSObject {
  alloc<T extends NSNetServiceBrowser>(): NSNetServiceBrowserAllocator<T>;
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  searchForBrowsableDomains(): void;
  searchForRegistrationDomains(): void;
  searchForServicesOfType_inDomain(type: NSString | string, domainString: NSString | string): void;
  stop(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  includesPeerToPeer(): boolean;
  setIncludesPeerToPeer(includesPeerToPeer: boolean): void;
}

declare interface INSNetServiceDelegate {
  netServiceWillPublish(sender: NSNetService): void;
  netServiceDidPublish(sender: NSNetService): void;
  netService_didNotPublish(sender: NSNetService, errorDict: NSDictionary<any, any> | {[key: string]: any}): void;
  netServiceWillResolve(sender: NSNetService): void;
  netServiceDidResolveAddress(sender: NSNetService): void;
  netService_didNotResolve(sender: NSNetService, errorDict: NSDictionary<any, any> | {[key: string]: any}): void;
  netServiceDidStop(sender: NSNetService): void;
  netService_didUpdateTXTRecordData(sender: NSNetService, data: NSData): void;
  netService_didAcceptConnectionWithInputStream_outputStream(sender: NSNetService, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

declare interface INSNetServiceBrowserDelegate {
  netServiceBrowserWillSearch(browser: NSNetServiceBrowser): void;
  netServiceBrowserDidStopSearch(browser: NSNetServiceBrowser): void;
  netServiceBrowser_didNotSearch(browser: NSNetServiceBrowser, errorDict: NSDictionary<any, any> | {[key: string]: any}): void;
  netServiceBrowser_didFindDomain_moreComing(browser: NSNetServiceBrowser, domainString: NSString | string, moreComing: boolean): void;
  netServiceBrowser_didFindService_moreComing(browser: NSNetServiceBrowser, service: NSNetService, moreComing: boolean): void;
  netServiceBrowser_didRemoveDomain_moreComing(browser: NSNetServiceBrowser, domainString: NSString | string, moreComing: boolean): void;
  netServiceBrowser_didRemoveService_moreComing(browser: NSNetServiceBrowser, service: NSNetService, moreComing: boolean): void;
}

declare enum NSNetServicesError {
  NSNetServicesUnknownError = -72000,
  NSNetServicesCollisionError = -72001,
  NSNetServicesNotFoundError = -72002,
  NSNetServicesActivityInProgress = -72003,
  NSNetServicesBadArgumentError = -72004,
  NSNetServicesCancelledError = -72005,
  NSNetServicesInvalidError = -72006,
  NSNetServicesTimeoutError = -72007,
}

declare enum NSNetServiceOptions {
  NSNetServiceNoAutoRename = 1 << 0,
  NSNetServiceListenForConnections = 1 << 1,
}

class NSNotificationAllocator<T extends NSNotification> extends NSObjectAllocator<T> {
  initWithName_object_userInfo(name: NSNotificationName, object: any | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null): T;
  initWithCoder(aDecoder: NSCoder): T;
  init(): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSNotification extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSNotification>(): NSNotificationAllocator<T>;
  static notificationWithName_object(aName: NSNotificationName, anObject: any | null): NSNotification;
  static notificationWithName_object_userInfo(aName: NSNotificationName, anObject: any | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): NSNotification;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  name(): NSNotificationName;
  object(): any;
  userInfo(): NSDictionary<any, any>;
}

class NSNotificationCenterAllocator<T extends NSNotificationCenter> extends NSObjectAllocator<T> {}
declare class NSNotificationCenter extends NSObject {
  alloc<T extends NSNotificationCenter>(): NSNotificationCenterAllocator<T>;
  addObserver_selector_name_object(observer: any, aSelector: string, aName: NSNotificationName | null, anObject: any | null): void;
  postNotification(notification: NSNotification): void;
  postNotificationName_object(aName: NSNotificationName, anObject: any | null): void;
  postNotificationName_object_userInfo(aName: NSNotificationName, anObject: any | null, aUserInfo: NSDictionary<any, any> | {[key: string]: any} | null): void;
  removeObserver(observer: any): void;
  removeObserver_name_object(observer: any, aName: NSNotificationName | null, anObject: any | null): void;
  addObserverForName_object_queue_usingBlock(name: NSNotificationName | null, obj: any | null, queue: NSOperationQueue | null, block: Block): any;

  static defaultCenter(): NSNotificationCenter;
}

declare type NSNotificationName = NSString

class NSNotificationQueueAllocator<T extends NSNotificationQueue> extends NSObjectAllocator<T> {
  initWithNotificationCenter(notificationCenter: NSNotificationCenter): T;
}
declare class NSNotificationQueue extends NSObject {
  alloc<T extends NSNotificationQueue>(): NSNotificationQueueAllocator<T>;
  enqueueNotification_postingStyle(notification: NSNotification, postingStyle: NSPostingStyle): void;
  enqueueNotification_postingStyle_coalesceMask_forModes(notification: NSNotification, postingStyle: NSPostingStyle, coalesceMask: NSNotificationCoalescing, modes: NSArray<any> | any[] | null): void;
  dequeueNotificationsMatching_coalesceMask(notification: NSNotification, coalesceMask: NSUInteger): void;

  static defaultQueue(): NSNotificationQueue;
}

declare enum NSPostingStyle {
  NSPostWhenIdle = 1,
  NSPostASAP = 2,
  NSPostNow = 3,
}

declare enum NSNotificationCoalescing {
  NSNotificationNoCoalescing = 0,
  NSNotificationCoalescingOnName = 1,
  NSNotificationCoalescingOnSender = 2,
}

class NSNumberFormatterAllocator<T extends NSNumberFormatter> extends NSFormatterAllocator<T> {}
declare class NSNumberFormatter extends NSFormatter {
  alloc<T extends NSNumberFormatter>(): NSNumberFormatterAllocator<T>;
  getObjectValue_forString_range_error(obj: any, string: NSString | string, rangep: NSRange, error: NSError): boolean;
  stringFromNumber(number: NSNumber | number): NSString;
  numberFromString(string: NSString | string): NSNumber;
  static localizedStringFromNumber_numberStyle(num: NSNumber | number, nstyle: NSNumberFormatterStyle): NSString;
  static defaultFormatterBehavior(): NSNumberFormatterBehavior;
  static setDefaultFormatterBehavior(behavior: NSNumberFormatterBehavior): void;

  formattingContext(): NSFormattingContext;
  setFormattingContext(formattingContext: NSFormattingContext): void;
  numberStyle(): NSNumberFormatterStyle;
  setNumberStyle(numberStyle: NSNumberFormatterStyle): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  generatesDecimalNumbers(): boolean;
  setGeneratesDecimalNumbers(generatesDecimalNumbers: boolean): void;
  formatterBehavior(): NSNumberFormatterBehavior;
  setFormatterBehavior(formatterBehavior: NSNumberFormatterBehavior): void;
  negativeFormat(): NSString;
  setNegativeFormat(negativeFormat: NSString | string): void;
  textAttributesForNegativeValues(): NSDictionary<any, any>;
  setTextAttributesForNegativeValues(textAttributesForNegativeValues: NSDictionary<any, any> | {[key: string]: any}): void;
  positiveFormat(): NSString;
  setPositiveFormat(positiveFormat: NSString | string): void;
  textAttributesForPositiveValues(): NSDictionary<any, any>;
  setTextAttributesForPositiveValues(textAttributesForPositiveValues: NSDictionary<any, any> | {[key: string]: any}): void;
  allowsFloats(): boolean;
  setAllowsFloats(allowsFloats: boolean): void;
  decimalSeparator(): NSString;
  setDecimalSeparator(decimalSeparator: NSString | string): void;
  alwaysShowsDecimalSeparator(): boolean;
  setAlwaysShowsDecimalSeparator(alwaysShowsDecimalSeparator: boolean): void;
  currencyDecimalSeparator(): NSString;
  setCurrencyDecimalSeparator(currencyDecimalSeparator: NSString | string): void;
  usesGroupingSeparator(): boolean;
  setUsesGroupingSeparator(usesGroupingSeparator: boolean): void;
  groupingSeparator(): NSString;
  setGroupingSeparator(groupingSeparator: NSString | string): void;
  zeroSymbol(): NSString;
  setZeroSymbol(zeroSymbol: NSString | string): void;
  textAttributesForZero(): NSDictionary<any, any>;
  setTextAttributesForZero(textAttributesForZero: NSDictionary<any, any> | {[key: string]: any}): void;
  nilSymbol(): NSString;
  setNilSymbol(nilSymbol: NSString | string): void;
  textAttributesForNil(): NSDictionary<any, any>;
  setTextAttributesForNil(textAttributesForNil: NSDictionary<any, any> | {[key: string]: any}): void;
  notANumberSymbol(): NSString;
  setNotANumberSymbol(notANumberSymbol: NSString | string): void;
  textAttributesForNotANumber(): NSDictionary<any, any>;
  setTextAttributesForNotANumber(textAttributesForNotANumber: NSDictionary<any, any> | {[key: string]: any}): void;
  positiveInfinitySymbol(): NSString;
  setPositiveInfinitySymbol(positiveInfinitySymbol: NSString | string): void;
  textAttributesForPositiveInfinity(): NSDictionary<any, any>;
  setTextAttributesForPositiveInfinity(textAttributesForPositiveInfinity: NSDictionary<any, any> | {[key: string]: any}): void;
  negativeInfinitySymbol(): NSString;
  setNegativeInfinitySymbol(negativeInfinitySymbol: NSString | string): void;
  textAttributesForNegativeInfinity(): NSDictionary<any, any>;
  setTextAttributesForNegativeInfinity(textAttributesForNegativeInfinity: NSDictionary<any, any> | {[key: string]: any}): void;
  positivePrefix(): NSString;
  setPositivePrefix(positivePrefix: NSString | string): void;
  positiveSuffix(): NSString;
  setPositiveSuffix(positiveSuffix: NSString | string): void;
  negativePrefix(): NSString;
  setNegativePrefix(negativePrefix: NSString | string): void;
  negativeSuffix(): NSString;
  setNegativeSuffix(negativeSuffix: NSString | string): void;
  currencyCode(): NSString;
  setCurrencyCode(currencyCode: NSString | string): void;
  currencySymbol(): NSString;
  setCurrencySymbol(currencySymbol: NSString | string): void;
  internationalCurrencySymbol(): NSString;
  setInternationalCurrencySymbol(internationalCurrencySymbol: NSString | string): void;
  percentSymbol(): NSString;
  setPercentSymbol(percentSymbol: NSString | string): void;
  perMillSymbol(): NSString;
  setPerMillSymbol(perMillSymbol: NSString | string): void;
  minusSign(): NSString;
  setMinusSign(minusSign: NSString | string): void;
  plusSign(): NSString;
  setPlusSign(plusSign: NSString | string): void;
  exponentSymbol(): NSString;
  setExponentSymbol(exponentSymbol: NSString | string): void;
  groupingSize(): NSUInteger;
  setGroupingSize(groupingSize: NSUInteger): void;
  secondaryGroupingSize(): NSUInteger;
  setSecondaryGroupingSize(secondaryGroupingSize: NSUInteger): void;
  multiplier(): NSNumber;
  setMultiplier(multiplier: NSNumber | number): void;
  formatWidth(): NSUInteger;
  setFormatWidth(formatWidth: NSUInteger): void;
  paddingCharacter(): NSString;
  setPaddingCharacter(paddingCharacter: NSString | string): void;
  paddingPosition(): NSNumberFormatterPadPosition;
  setPaddingPosition(paddingPosition: NSNumberFormatterPadPosition): void;
  roundingMode(): NSNumberFormatterRoundingMode;
  setRoundingMode(roundingMode: NSNumberFormatterRoundingMode): void;
  roundingIncrement(): NSNumber;
  setRoundingIncrement(roundingIncrement: NSNumber | number): void;
  minimumIntegerDigits(): NSUInteger;
  setMinimumIntegerDigits(minimumIntegerDigits: NSUInteger): void;
  maximumIntegerDigits(): NSUInteger;
  setMaximumIntegerDigits(maximumIntegerDigits: NSUInteger): void;
  minimumFractionDigits(): NSUInteger;
  setMinimumFractionDigits(minimumFractionDigits: NSUInteger): void;
  maximumFractionDigits(): NSUInteger;
  setMaximumFractionDigits(maximumFractionDigits: NSUInteger): void;
  minimum(): NSNumber;
  setMinimum(minimum: NSNumber | number): void;
  maximum(): NSNumber;
  setMaximum(maximum: NSNumber | number): void;
  currencyGroupingSeparator(): NSString;
  setCurrencyGroupingSeparator(currencyGroupingSeparator: NSString | string): void;
  lenient(): boolean;
  setLenient(lenient: boolean): void;
  usesSignificantDigits(): boolean;
  setUsesSignificantDigits(usesSignificantDigits: boolean): void;
  minimumSignificantDigits(): NSUInteger;
  setMinimumSignificantDigits(minimumSignificantDigits: NSUInteger): void;
  maximumSignificantDigits(): NSUInteger;
  setMaximumSignificantDigits(maximumSignificantDigits: NSUInteger): void;
  partialStringValidationEnabled(): boolean;
  setPartialStringValidationEnabled(partialStringValidationEnabled: boolean): void;
  hasThousandSeparators(): boolean;
  setHasThousandSeparators(hasThousandSeparators: boolean): void;
  thousandSeparator(): NSString;
  setThousandSeparator(thousandSeparator: NSString | string): void;
  localizesFormat(): boolean;
  setLocalizesFormat(localizesFormat: boolean): void;
  format(): NSString;
  setFormat(format: NSString | string): void;
  attributedStringForZero(): NSAttributedString;
  setAttributedStringForZero(attributedStringForZero: NSAttributedString): void;
  attributedStringForNil(): NSAttributedString;
  setAttributedStringForNil(attributedStringForNil: NSAttributedString): void;
  attributedStringForNotANumber(): NSAttributedString;
  setAttributedStringForNotANumber(attributedStringForNotANumber: NSAttributedString): void;
  roundingBehavior(): NSDecimalNumberHandler;
  setRoundingBehavior(roundingBehavior: NSDecimalNumberHandler): void;
}

declare enum NSNumberFormatterBehavior {
  NSNumberFormatterBehaviorDefault = 0,
  NSNumberFormatterBehavior10_0 = 1000,
}

declare enum NSNumberFormatterStyle {
  NSNumberFormatterNoStyle,
  NSNumberFormatterDecimalStyle,
  NSNumberFormatterCurrencyStyle,
  NSNumberFormatterPercentStyle,
  NSNumberFormatterScientificStyle,
  NSNumberFormatterSpellOutStyle,
  NSNumberFormatterOrdinalStyle,
  NSNumberFormatterCurrencyISOCodeStyle,
  NSNumberFormatterCurrencyPluralStyle,
  NSNumberFormatterCurrencyAccountingStyle,
}

declare enum NSNumberFormatterPadPosition {
  NSNumberFormatterPadBeforePrefix,
  NSNumberFormatterPadAfterPrefix,
  NSNumberFormatterPadBeforeSuffix,
  NSNumberFormatterPadAfterSuffix,
}

declare enum NSNumberFormatterRoundingMode {
  NSNumberFormatterRoundCeiling,
  NSNumberFormatterRoundFloor,
  NSNumberFormatterRoundDown,
  NSNumberFormatterRoundUp,
  NSNumberFormatterRoundHalfEven,
  NSNumberFormatterRoundHalfDown,
  NSNumberFormatterRoundHalfUp,
}

declare type NSInteger = number

declare type NSUInteger = number

declare type NSExceptionName = NSString

declare type NSRunLoopMode = NSString

declare enum NSComparisonResult {
  NSOrderedAscending = -1,
  NSOrderedSame,
  NSOrderedDescending,
}

declare enum NSEnumerationOptions {
  NSEnumerationConcurrent,
  NSEnumerationReverse,
}

declare enum NSSortOptions {
  NSSortConcurrent,
  NSSortStable,
}

declare enum NSQualityOfService {
  NSQualityOfServiceUserInteractive = 0x21,
  NSQualityOfServiceUserInitiated = 0x19,
  NSQualityOfServiceUtility = 0x11,
  NSQualityOfServiceBackground = 0x09,
  NSQualityOfServiceDefault = -1,
}

declare interface INSCopying {
  copyWithZone(zone: NSZone | null): any;
}

declare interface INSMutableCopying {
  mutableCopyWithZone(zone: NSZone | null): any;
}

declare interface INSCoding {
  encodeWithCoder(aCoder: NSCoder): void;
}

declare interface INSSecureCoding {

  // static supportsSecureCoding(): boolean;
}

declare interface INSDiscardableContent {
  beginContentAccess(): boolean;
  endContentAccess(): void;
  discardContentIfPossible(): void;
  isContentDiscarded(): boolean;
}

class NSOperationAllocator<T extends NSOperation> extends NSObjectAllocator<T> {}
declare class NSOperation extends NSObject {
  alloc<T extends NSOperation>(): NSOperationAllocator<T>;
  start(): void;
  main(): void;
  cancel(): void;
  addDependency(op: NSOperation): void;
  removeDependency(op: NSOperation): void;
  waitUntilFinished(): void;

  cancelled(): boolean;
  executing(): boolean;
  finished(): boolean;
  concurrent(): boolean;
  asynchronous(): boolean;
  ready(): boolean;
  dependencies(): NSArray<any>;
  queuePriority(): NSOperationQueuePriority;
  setQueuePriority(queuePriority: NSOperationQueuePriority): void;
  threadPriority(): number;
  setThreadPriority(threadPriority: number): void;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  name(): NSString;
  setName(name: NSString | string): void;
}

class NSBlockOperationAllocator<T extends NSBlockOperation> extends NSOperationAllocator<T> {}
declare class NSBlockOperation extends NSOperation {
  alloc<T extends NSBlockOperation>(): NSBlockOperationAllocator<T>;
  static blockOperationWithBlock(block: Block): NSBlockOperation;
  addExecutionBlock(block: Block): void;

  executionBlocks(): NSArray<any>;
}

class NSInvocationOperationAllocator<T extends NSInvocationOperation> extends NSOperationAllocator<T> {
  initWithTarget_selector_object(target: any, sel: string, arg: any | null): T;
  initWithInvocation(inv: NSInvocation): T;
}
declare class NSInvocationOperation extends NSOperation {
  alloc<T extends NSInvocationOperation>(): NSInvocationOperationAllocator<T>;

  invocation(): NSInvocation;
  result(): any;
}

class NSOperationQueueAllocator<T extends NSOperationQueue> extends NSObjectAllocator<T> {}
declare class NSOperationQueue extends NSObject {
  alloc<T extends NSOperationQueue>(): NSOperationQueueAllocator<T>;
  addOperation(op: NSOperation): void;
  addOperations_waitUntilFinished(ops: NSArray<any> | any[], wait: boolean): void;
  addOperationWithBlock(block: Block): void;
  cancelAllOperations(): void;
  waitUntilAllOperationsAreFinished(): void;

  operations(): NSArray<any>;
  operationCount(): NSUInteger;
  maxConcurrentOperationCount(): NSInteger;
  setMaxConcurrentOperationCount(maxConcurrentOperationCount: NSInteger): void;
  suspended(): boolean;
  setSuspended(suspended: boolean): void;
  name(): NSString;
  setName(name: NSString | string): void;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  underlyingQueue(): dispatch_queue_t;
  setUnderlyingQueue(underlyingQueue: dispatch_queue_t): void;
  static currentQueue(): NSOperationQueue;
  static mainQueue(): NSOperationQueue;
}

declare enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow = -8,
  NSOperationQueuePriorityLow = -4,
  NSOperationQueuePriorityNormal = 0,
  NSOperationQueuePriorityHigh = 4,
  NSOperationQueuePriorityVeryHigh = 8,
}

class NSMutableOrderedSetAllocator<ObjectType, T extends NSMutableOrderedSet<ObjectType>> extends NSOrderedSetAllocator<ObjectType, T> {
  initWithCapacity(numItems: NSUInteger): T;
}
declare class NSMutableOrderedSet<ObjectType> extends NSOrderedSet<ObjectType> {
  alloc<T extends NSMutableOrderedSet<ObjectType>>(): NSMutableOrderedSetAllocator<ObjectType, T>;
  insertObject_atIndex(object: ObjectType, idx: NSUInteger): void;
  removeObjectAtIndex(idx: NSUInteger): void;
  replaceObjectAtIndex_withObject(idx: NSUInteger, object: ObjectType): void;
  addObject(object: ObjectType): void;
  addObjects_count(objects: ObjectType[], count: NSUInteger): void;
  addObjectsFromArray(array: NSArray<any> | any[]): void;
  exchangeObjectAtIndex_withObjectAtIndex(idx1: NSUInteger, idx2: NSUInteger): void;
  moveObjectsAtIndexes_toIndex(indexes: NSIndexSet, idx: NSUInteger): void;
  insertObjects_atIndexes(objects: NSArray<any> | any[], indexes: NSIndexSet): void;
  setObject_atIndex(obj: ObjectType, idx: NSUInteger): void;
  setObject_atIndexedSubscript(obj: ObjectType, idx: NSUInteger): void;
  replaceObjectsInRange_withObjects_count(range: NSRange, objects: ObjectType[], count: NSUInteger): void;
  replaceObjectsAtIndexes_withObjects(indexes: NSIndexSet, objects: NSArray<any> | any[]): void;
  removeObjectsInRange(range: NSRange): void;
  removeObjectsAtIndexes(indexes: NSIndexSet): void;
  removeAllObjects(): void;
  removeObject(object: ObjectType): void;
  removeObjectsInArray(array: NSArray<any> | any[]): void;
  intersectOrderedSet(other: NSOrderedSet<any>): void;
  minusOrderedSet(other: NSOrderedSet<any>): void;
  unionOrderedSet(other: NSOrderedSet<any>): void;
  intersectSet(other: NSSet<any>): void;
  minusSet(other: NSSet<any>): void;
  unionSet(other: NSSet<any>): void;
  sortUsingComparator(cmptr: NSComparator): void;
  sortWithOptions_usingComparator(opts: NSSortOptions, cmptr: NSComparator): void;
  sortRange_options_usingComparator(range: NSRange, opts: NSSortOptions, cmptr: NSComparator): void;
  static orderedSetWithCapacity<ObjectType>(numItems: NSUInteger): NSMutableOrderedSet<ObjectType>;
  filterUsingPredicate(p: NSPredicate): void;
  sortUsingDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  mo_setObject_forIndexedSubscript(obj: any, idx: NSUInteger): void;
}

class NSOrthographyAllocator<T extends NSOrthography> extends NSObjectAllocator<T> {
  initWithDominantScript_languageMap(script: NSString | string, map: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSOrthography extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSOrthography>(): NSOrthographyAllocator<T>;
  languagesForScript(script: NSString | string): NSArray<any>;
  dominantLanguageForScript(script: NSString | string): NSString;
  static defaultOrthographyForLanguage(language: NSString | string): NSOrthography;
  static orthographyWithDominantScript_languageMap(script: NSString | string, map: NSDictionary<any, any> | {[key: string]: any}): NSOrthography;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  dominantScript(): NSString;
  languageMap(): NSDictionary<any, any>;
  dominantLanguage(): NSString;
  allScripts(): NSArray<any>;
  allLanguages(): NSArray<any>;
  static supportsSecureCoding(): boolean;
}

declare enum NSSearchPathDirectory {
  NSApplicationDirectory = 1,
  NSDemoApplicationDirectory,
  NSDeveloperApplicationDirectory,
  NSAdminApplicationDirectory,
  NSLibraryDirectory,
  NSDeveloperDirectory,
  NSUserDirectory,
  NSDocumentationDirectory,
  NSDocumentDirectory,
  NSCoreServiceDirectory,
  NSAutosavedInformationDirectory = 11,
  NSDesktopDirectory = 12,
  NSCachesDirectory = 13,
  NSApplicationSupportDirectory = 14,
  NSDownloadsDirectory = 15,
  NSInputMethodsDirectory = 16,
  NSMoviesDirectory = 17,
  NSMusicDirectory = 18,
  NSPicturesDirectory = 19,
  NSPrinterDescriptionDirectory = 20,
  NSSharedPublicDirectory = 21,
  NSPreferencePanesDirectory = 22,
  NSApplicationScriptsDirectory = 23,
  NSItemReplacementDirectory = 99,
  NSAllApplicationsDirectory = 100,
  NSAllLibrariesDirectory = 101,
  NSTrashDirectory = 102,
}

declare enum NSSearchPathDomainMask {
  NSUserDomainMask = 1,
  NSLocalDomainMask = 2,
  NSNetworkDomainMask = 4,
  NSSystemDomainMask = 8,
  NSAllDomainsMask = 0x0ffff,
}

class NSPersonNameComponentsAllocator<T extends NSPersonNameComponents> extends NSObjectAllocator<T> {}
declare class NSPersonNameComponents extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSPersonNameComponents>(): NSPersonNameComponentsAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  namePrefix(): NSString;
  setNamePrefix(namePrefix: NSString | string): void;
  givenName(): NSString;
  setGivenName(givenName: NSString | string): void;
  middleName(): NSString;
  setMiddleName(middleName: NSString | string): void;
  familyName(): NSString;
  setFamilyName(familyName: NSString | string): void;
  nameSuffix(): NSString;
  setNameSuffix(nameSuffix: NSString | string): void;
  nickname(): NSString;
  setNickname(nickname: NSString | string): void;
  phoneticRepresentation(): NSPersonNameComponents;
  setPhoneticRepresentation(phoneticRepresentation: NSPersonNameComponents): void;
  static supportsSecureCoding(): boolean;
}

class NSPersonNameComponentsFormatterAllocator<T extends NSPersonNameComponentsFormatter> extends NSFormatterAllocator<T> {}
declare class NSPersonNameComponentsFormatter extends NSFormatter {
  alloc<T extends NSPersonNameComponentsFormatter>(): NSPersonNameComponentsFormatterAllocator<T>;
  static localizedStringFromPersonNameComponents_style_options(components: NSPersonNameComponents, nameFormatStyle: NSPersonNameComponentsFormatterStyle, nameOptions: NSPersonNameComponentsFormatterOptions): NSString;
  stringFromPersonNameComponents(components: NSPersonNameComponents): NSString;
  annotatedStringFromPersonNameComponents(components: NSPersonNameComponents): NSAttributedString;
  personNameComponentsFromString(string: NSString | string): NSPersonNameComponents;
  getObjectValue_forString_errorDescription(obj: any, string: NSString | string, error: NSString | string): boolean;

  style(): NSPersonNameComponentsFormatterStyle;
  setStyle(style: NSPersonNameComponentsFormatterStyle): void;
  phonetic(): boolean;
  setPhonetic(phonetic: boolean): void;
}

declare enum NSPersonNameComponentsFormatterStyle {
  NSPersonNameComponentsFormatterStyleDefault = 0,
  NSPersonNameComponentsFormatterStyleShort,
  NSPersonNameComponentsFormatterStyleMedium,
  NSPersonNameComponentsFormatterStyleLong,
  NSPersonNameComponentsFormatterStyleAbbreviated,
}

declare enum NSPersonNameComponentsFormatterOptions {
  NSPersonNameComponentsFormatterPhonetic,
}

class NSPointerArrayAllocator<T extends NSPointerArray> extends NSObjectAllocator<T> {
  initWithOptions(options: NSPointerFunctionsOptions): T;
  initWithPointerFunctions(functions: NSPointerFunctions): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSPointerArray extends NSObject implements INSFastEnumeration, INSCopying, INSCoding {
  alloc<T extends NSPointerArray>(): NSPointerArrayAllocator<T>;
  static pointerArrayWithOptions(options: NSPointerFunctionsOptions): NSPointerArray;
  static pointerArrayWithPointerFunctions(functions: NSPointerFunctions): NSPointerArray;
  pointerAtIndex(index: NSUInteger): void;
  addPointer(pointer: void | null): void;
  removePointerAtIndex(index: NSUInteger): void;
  insertPointer_atIndex(item: void | null, index: NSUInteger): void;
  replacePointerAtIndex_withPointer(index: NSUInteger, item: void | null): void;
  compact(): void;
  static pointerArrayWithStrongObjects(): any;
  static pointerArrayWithWeakObjects(): any;
  static strongObjectsPointerArray(): NSPointerArray;
  static weakObjectsPointerArray(): NSPointerArray;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  pointerFunctions(): NSPointerFunctions;
  count(): NSUInteger;
  setCount(count: NSUInteger): void;
  allObjects(): NSArray<any>;
}

class NSPointerFunctionsAllocator<T extends NSPointerFunctions> extends NSObjectAllocator<T> {
  initWithOptions(options: NSPointerFunctionsOptions): T;
}
declare class NSPointerFunctions extends NSObject implements INSCopying {
  alloc<T extends NSPointerFunctions>(): NSPointerFunctionsAllocator<T>;
  static pointerFunctionsWithOptions(options: NSPointerFunctionsOptions): NSPointerFunctions;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  usesStrongWriteBarrier(): boolean;
  setUsesStrongWriteBarrier(usesStrongWriteBarrier: boolean): void;
  usesWeakReadAndWriteBarriers(): boolean;
  setUsesWeakReadAndWriteBarriers(usesWeakReadAndWriteBarriers: boolean): void;
}

declare enum NSPointerFunctionsOptions {
  NSPointerFunctionsStrongMemory = (0 << 0),
  NSPointerFunctionsZeroingWeakMemory = (1 << 0),
  NSPointerFunctionsMallocMemory = (3 << 0),
  NSPointerFunctionsMachVirtualMemory = (4 << 0),
  NSPointerFunctionsWeakMemory = (5 << 0),
  NSPointerFunctionsObjectPersonality = (0 << 8),
  NSPointerFunctionsOpaquePersonality = (1 << 8),
  NSPointerFunctionsObjectPointerPersonality = (2 << 8),
  NSPointerFunctionsCStringPersonality = (3 << 8),
  NSPointerFunctionsStructPersonality = (4 << 8),
  NSPointerFunctionsIntegerPersonality = (5 << 8),
  NSPointerFunctionsCopyIn = (1 << 16),
}

class NSPortAllocator<T extends NSPort> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSPort extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSPort>(): NSPortAllocator<T>;
  static port(): NSPort;
  invalidate(): void;
  setDelegate(anObject: any | null): void;
  delegate(): any;
  scheduleInRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  sendBeforeDate_components_from_reserved(limitDate: NSDate, components: NSMutableArray<any> | any[] | null, receivePort: NSPort | null, headerSpaceReserved: NSUInteger): boolean;
  sendBeforeDate_msgid_components_from_reserved(limitDate: NSDate, msgID: NSUInteger, components: NSMutableArray<any> | any[] | null, receivePort: NSPort | null, headerSpaceReserved: NSUInteger): boolean;
  addConnection_toRunLoop_forMode(conn: NSConnection, runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeConnection_fromRunLoop_forMode(conn: NSConnection, runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  valid(): boolean;
  reservedSpaceLength(): NSUInteger;
}

class NSMachPortAllocator<T extends NSMachPort> extends NSPortAllocator<T> {
  initWithMachPort(machPort: number): T;
  initWithMachPort_options(machPort: number, f: NSMachPortOptions): T;
}
declare class NSMachPort extends NSPort {
  alloc<T extends NSMachPort>(): NSMachPortAllocator<T>;
  static portWithMachPort(machPort: number): NSPort;
  setDelegate(anObject: any | null): void;
  delegate(): any;
  static portWithMachPort_options(machPort: number, f: NSMachPortOptions): NSPort;
  scheduleInRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(runLoop: NSRunLoop, mode: NSRunLoopMode): void;

  machPort(): number;
}

class NSMessagePortAllocator<T extends NSMessagePort> extends NSPortAllocator<T> {}
declare class NSMessagePort extends NSPort {
  alloc<T extends NSMessagePort>(): NSMessagePortAllocator<T>;
}

class NSSocketPortAllocator<T extends NSSocketPort> extends NSPortAllocator<T> {
  init(): T;
  initWithTCPPort(port: number): T;
  initWithProtocolFamily_socketType_protocol_address(family: number, type: number, protocol: number, address: NSData): T;
  initWithProtocolFamily_socketType_protocol_socket(family: number, type: number, protocol: number, sock: NSSocketNativeHandle): T;
  initRemoteWithTCPPort_host(port: number, hostName: NSString | string | null): T;
  initRemoteWithProtocolFamily_socketType_protocol_address(family: number, type: number, protocol: number, address: NSData): T;
}
declare class NSSocketPort extends NSPort {
  alloc<T extends NSSocketPort>(): NSSocketPortAllocator<T>;

  protocolFamily(): number;
  socketType(): number;
  protocol(): number;
  address(): NSData;
  socket(): NSSocketNativeHandle;
}

declare interface INSPortDelegate {
  handlePortMessage(message: NSPortMessage): void;
}

declare interface INSMachPortDelegate {
  handleMachMessage(msg: void): void;
}

declare type NSSocketNativeHandle = number

declare enum NSMachPortOptions {
  NSMachPortDeallocateNone = 0,
  NSMachPortDeallocateSendRight,
  NSMachPortDeallocateReceiveRight,
}

class NSPortCoderAllocator<T extends NSPortCoder> extends NSCoderAllocator<T> {
  initWithReceivePort_sendPort_components(rcvPort: NSPort | null, sndPort: NSPort | null, comps: NSArray<any> | any[] | null): T;
}
declare class NSPortCoder extends NSCoder {
  alloc<T extends NSPortCoder>(): NSPortCoderAllocator<T>;
  isBycopy(): boolean;
  isByref(): boolean;
  encodePortObject(aport: NSPort): void;
  decodePortObject(): NSPort;
  connection(): NSConnection;
  static portCoderWithReceivePort_sendPort_components(rcvPort: NSPort | null, sndPort: NSPort | null, comps: NSArray<any> | any[] | null): any;
  dispatch(): void;
}

class NSPortMessageAllocator<T extends NSPortMessage> extends NSObjectAllocator<T> {
  initWithSendPort_receivePort_components(sendPort: NSPort | null, replyPort: NSPort | null, components: NSArray<any> | any[] | null): T;
}
declare class NSPortMessage extends NSObject {
  alloc<T extends NSPortMessage>(): NSPortMessageAllocator<T>;
  sendBeforeDate(date: NSDate): boolean;

  components(): NSArray<any>;
  receivePort(): NSPort;
  sendPort(): NSPort;
  msgid(): number;
  setMsgid(msgid: number): void;
}

class NSPortNameServerAllocator<T extends NSPortNameServer> extends NSObjectAllocator<T> {}
declare class NSPortNameServer extends NSObject {
  alloc<T extends NSPortNameServer>(): NSPortNameServerAllocator<T>;
  static systemDefaultPortNameServer(): NSPortNameServer;
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
  registerPort_name(port: NSPort, name: NSString | string): boolean;
  removePortForName(name: NSString | string): boolean;
}

class NSMachBootstrapServerAllocator<T extends NSMachBootstrapServer> extends NSPortNameServerAllocator<T> {}
declare class NSMachBootstrapServer extends NSPortNameServer {
  alloc<T extends NSMachBootstrapServer>(): NSMachBootstrapServerAllocator<T>;
  static sharedInstance(): any;
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
  registerPort_name(port: NSPort, name: NSString | string): boolean;
  servicePortWithName(name: NSString | string): NSPort;
}

class NSMessagePortNameServerAllocator<T extends NSMessagePortNameServer> extends NSPortNameServerAllocator<T> {}
declare class NSMessagePortNameServer extends NSPortNameServer {
  alloc<T extends NSMessagePortNameServer>(): NSMessagePortNameServerAllocator<T>;
  static sharedInstance(): any;
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
}

class NSSocketPortNameServerAllocator<T extends NSSocketPortNameServer> extends NSPortNameServerAllocator<T> {}
declare class NSSocketPortNameServer extends NSPortNameServer {
  alloc<T extends NSSocketPortNameServer>(): NSSocketPortNameServerAllocator<T>;
  static sharedInstance(): any;
  portForName(name: NSString | string): NSPort;
  portForName_host(name: NSString | string, host: NSString | string | null): NSPort;
  registerPort_name(port: NSPort, name: NSString | string): boolean;
  removePortForName(name: NSString | string): boolean;
  portForName_host_nameServerPortNumber(name: NSString | string, host: NSString | string | null, portNumber: number): NSPort;
  registerPort_name_nameServerPortNumber(port: NSPort, name: NSString | string, portNumber: number): boolean;

  defaultNameServerPortNumber(): number;
  setDefaultNameServerPortNumber(defaultNameServerPortNumber: number): void;
}

class NSPredicateAllocator<T extends NSPredicate> extends NSObjectAllocator<T> {}
declare class NSPredicate extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSPredicate>(): NSPredicateAllocator<T>;
  static predicateWithFormat_argumentArray(predicateFormat: NSString | string, arguments: NSArray<any> | any[] | null): NSPredicate;
  static predicateWithFormat(predicateFormat: NSString | string, ...args: any[]): NSPredicate;
  static predicateWithFormat_arguments(predicateFormat: NSString | string, ...argList: any[]): NSPredicate;
  static predicateFromMetadataQueryString(queryString: NSString | string): NSPredicate;
  static predicateWithValue(value: boolean): NSPredicate;
  static predicateWithBlock(block: Block): NSPredicate;
  predicateWithSubstitutionVariables(variables: NSDictionary<any, any> | {[key: string]: any}): NSPredicate;
  evaluateWithObject(object: any | null): boolean;
  evaluateWithObject_substitutionVariables(object: any | null, bindings: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  allowEvaluation(): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  predicateFormat(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSMutableSetAllocator<ObjectType, T extends NSMutableSet<ObjectType>> extends NSSetAllocator<ObjectType, T> {
  initWithCapacity(numItems: NSUInteger): T;
}
declare class NSMutableSet<ObjectType> extends NSSet<ObjectType> {
  alloc<T extends NSMutableSet<ObjectType>>(): NSMutableSetAllocator<ObjectType, T>;
  filterUsingPredicate(predicate: NSPredicate): void;
  addObject(object: ObjectType): void;
  removeObject(object: ObjectType): void;
  addObjectsFromArray(array: NSArray<any> | any[]): void;
  intersectSet(otherSet: NSSet<any>): void;
  minusSet(otherSet: NSSet<any>): void;
  removeAllObjects(): void;
  unionSet(otherSet: NSSet<any>): void;
  setSet(otherSet: NSSet<any>): void;
  static setWithCapacity<ObjectType>(numItems: NSUInteger): NSMutableSet<ObjectType>;
  addObjectIfNotNil(anObject: any): void;
}

class NSProcessInfoAllocator<T extends NSProcessInfo> extends NSObjectAllocator<T> {}
declare class NSProcessInfo extends NSObject {
  alloc<T extends NSProcessInfo>(): NSProcessInfoAllocator<T>;
  operatingSystem(): NSUInteger;
  operatingSystemName(): NSString;
  isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
  disableSuddenTermination(): void;
  enableSuddenTermination(): void;
  disableAutomaticTermination(reason: NSString | string): void;
  enableAutomaticTermination(reason: NSString | string): void;
  beginActivityWithOptions_reason(options: NSActivityOptions, reason: NSString | string): any;
  endActivity(activity: any): void;
  performActivityWithOptions_reason_usingBlock(options: NSActivityOptions, reason: NSString | string, block: Block): void;
  performExpiringActivityWithReason_usingBlock(reason: NSString | string, block: Block): void;

  static processInfo(): NSProcessInfo;
  environment(): NSDictionary<any, any>;
  arguments(): NSArray<any>;
  hostName(): NSString;
  processName(): NSString;
  setProcessName(processName: NSString | string): void;
  processIdentifier(): number;
  globallyUniqueString(): NSString;
  operatingSystemVersionString(): NSString;
  operatingSystemVersion(): NSOperatingSystemVersion;
  processorCount(): NSUInteger;
  activeProcessorCount(): NSUInteger;
  physicalMemory(): number;
  systemUptime(): NSTimeInterval;
  automaticTerminationSupportEnabled(): boolean;
  setAutomaticTerminationSupportEnabled(automaticTerminationSupportEnabled: boolean): void;
  userName(): NSString;
  fullUserName(): NSString;
  thermalState(): NSProcessInfoThermalState;
  lowPowerModeEnabled(): boolean;
}

declare type NSOperatingSystemVersion = {
  majorVersion: NSInteger
  minorVersion: NSInteger
  patchVersion: NSInteger
}

declare enum NSActivityOptions {
  NSActivityIdleDisplaySleepDisabled,
  NSActivityIdleSystemSleepDisabled,
  NSActivitySuddenTerminationDisabled,
  NSActivityAutomaticTerminationDisabled,
  NSActivityUserInitiated,
  NSActivityUserInitiatedAllowingIdleSystemSleep,
  NSActivityBackground = 0x000000FF,
  NSActivityLatencyCritical = 0xFF00000000,
}

declare enum NSProcessInfoThermalState {
  NSProcessInfoThermalStateNominal,
  NSProcessInfoThermalStateFair,
  NSProcessInfoThermalStateSerious,
  NSProcessInfoThermalStateCritical,
}

class NSProgressAllocator<T extends NSProgress> extends NSObjectAllocator<T> {
  initWithParent_userInfo(parentProgressOrNil: NSProgress | null, userInfoOrNil: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class NSProgress extends NSObject {
  alloc<T extends NSProgress>(): NSProgressAllocator<T>;
  static currentProgress(): NSProgress;
  static progressWithTotalUnitCount(unitCount: number): NSProgress;
  static discreteProgressWithTotalUnitCount(unitCount: number): NSProgress;
  static progressWithTotalUnitCount_parent_pendingUnitCount(unitCount: number, parent: NSProgress, portionOfParentTotalUnitCount: number): NSProgress;
  becomeCurrentWithPendingUnitCount(unitCount: number): void;
  performAsCurrentWithPendingUnitCount_usingBlock(unitCount: number, work: Block): void;
  resignCurrent(): void;
  addChild_withPendingUnitCount(child: NSProgress, inUnitCount: number): void;
  setUserInfoObject_forKey(objectOrNil: any | null, key: NSProgressUserInfoKey): void;
  cancel(): void;
  pause(): void;
  resume(): void;
  publish(): void;
  unpublish(): void;
  static addSubscriberForFileURL_withPublishingHandler(url: NSURL, publishingHandler: NSProgressPublishingHandler): any;
  static removeSubscriber(subscriber: any): void;

  totalUnitCount(): number;
  setTotalUnitCount(totalUnitCount: number): void;
  completedUnitCount(): number;
  setCompletedUnitCount(completedUnitCount: number): void;
  localizedDescription(): NSString;
  setLocalizedDescription(localizedDescription: NSString | string): void;
  localizedAdditionalDescription(): NSString;
  setLocalizedAdditionalDescription(localizedAdditionalDescription: NSString | string): void;
  cancellable(): boolean;
  setCancellable(cancellable: boolean): void;
  pausable(): boolean;
  setPausable(pausable: boolean): void;
  cancelled(): boolean;
  paused(): boolean;
  indeterminate(): boolean;
  fractionCompleted(): number;
  finished(): boolean;
  userInfo(): NSDictionary<any, any>;
  kind(): NSProgressKind;
  setKind(kind: NSProgressKind): void;
  estimatedTimeRemaining(): NSNumber;
  setEstimatedTimeRemaining(estimatedTimeRemaining: NSNumber | number): void;
  throughput(): NSNumber;
  setThroughput(throughput: NSNumber | number): void;
  fileOperationKind(): NSProgressFileOperationKind;
  setFileOperationKind(fileOperationKind: NSProgressFileOperationKind): void;
  fileURL(): NSURL;
  setFileURL(fileURL: NSURL): void;
  fileTotalCount(): NSNumber;
  setFileTotalCount(fileTotalCount: NSNumber | number): void;
  fileCompletedCount(): NSNumber;
  setFileCompletedCount(fileCompletedCount: NSNumber | number): void;
  old(): boolean;
}

declare interface INSProgressReporting {

  progress(): NSProgress;
}

declare type NSProgressKind = NSString

declare type NSProgressUserInfoKey = NSString

declare type NSProgressFileOperationKind = NSString

class NSPropertyListSerializationAllocator<T extends NSPropertyListSerialization> extends NSObjectAllocator<T> {}
declare class NSPropertyListSerialization extends NSObject {
  alloc<T extends NSPropertyListSerialization>(): NSPropertyListSerializationAllocator<T>;
  static propertyList_isValidForFormat(plist: any, format: NSPropertyListFormat): boolean;
  static dataWithPropertyList_format_options_error(plist: any, format: NSPropertyListFormat, opt: NSPropertyListWriteOptions, error: NSError): NSData;
  static writePropertyList_toStream_format_options_error(plist: any, stream: NSOutputStream, format: NSPropertyListFormat, opt: NSPropertyListWriteOptions, error: NSError): NSInteger;
  static propertyListWithData_options_format_error(data: NSData, opt: NSPropertyListReadOptions, format: NSPropertyListFormat | null, error: NSError): any;
  static propertyListWithStream_options_format_error(stream: NSInputStream, opt: NSPropertyListReadOptions, format: NSPropertyListFormat | null, error: NSError): any;
  static dataFromPropertyList_format_errorDescription(plist: any, format: NSPropertyListFormat, errorString: NSString | string): NSData;
  static propertyListFromData_mutabilityOption_format_errorDescription(data: NSData, opt: NSPropertyListMutabilityOptions, format: NSPropertyListFormat | null, errorString: NSString | string): any;
}

declare type NSPropertyListReadOptions = NSPropertyListMutabilityOptions

declare type NSPropertyListWriteOptions = NSUInteger

declare enum NSPropertyListMutabilityOptions {
  NSPropertyListImmutable,
  NSPropertyListMutableContainers,
  NSPropertyListMutableContainersAndLeaves,
}

declare enum NSPropertyListFormat {
  NSPropertyListOpenStepFormat,
  NSPropertyListXMLFormat_v1_0,
  NSPropertyListBinaryFormat_v1_0,
}

class NSProtocolCheckerAllocator<T extends NSProtocolChecker> extends NSProxyAllocator<T> {
  initWithTarget_protocol(anObject: NSObject, aProtocol: Protocol): T;
}
declare class NSProtocolChecker extends NSProxy {
  alloc<T extends NSProtocolChecker>(): NSProtocolCheckerAllocator<T>;
  static protocolCheckerWithTarget_protocol(anObject: NSObject, aProtocol: Protocol): NSProtocolChecker;

  protocol(): Protocol;
  target(): NSObject;
}

class NSProxyAllocator<T extends NSProxy> {}
declare class NSProxy {
  alloc<T extends NSProxy>(): NSProxyAllocator<T>;
  static alloc(): any;
  static class(): any;
  forwardInvocation(invocation: NSInvocation): void;
  methodSignatureForSelector(sel: string): NSMethodSignature;
  dealloc(): void;
  finalize(): void;
  static respondsToSelector(aSelector: string): boolean;

  description(): NSString;
  debugDescription(): NSString;
}

declare type NSRange = {
  location: NSUInteger
  length: NSUInteger
}

declare type NSRangePointer = NSRange

class NSRegularExpressionAllocator<T extends NSRegularExpression> extends NSObjectAllocator<T> {
  initWithPattern_options_error(pattern: NSString | string, options: NSRegularExpressionOptions, error: NSError): T;
}
declare class NSRegularExpression extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSRegularExpression>(): NSRegularExpressionAllocator<T>;
  static regularExpressionWithPattern_options_error(pattern: NSString | string, options: NSRegularExpressionOptions, error: NSError): NSRegularExpression;
  static escapedPatternForString(string: NSString | string): NSString;
  enumerateMatchesInString_options_range_usingBlock(string: NSString | string, options: NSMatchingOptions, range: NSRange, block: Block): void;
  matchesInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSArray<any>;
  numberOfMatchesInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSUInteger;
  firstMatchInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSTextCheckingResult;
  rangeOfFirstMatchInString_options_range(string: NSString | string, options: NSMatchingOptions, range: NSRange): NSRange;
  stringByReplacingMatchesInString_options_range_withTemplate(string: NSString | string, options: NSMatchingOptions, range: NSRange, templ: NSString | string): NSString;
  replaceMatchesInString_options_range_withTemplate(string: NSMutableString, options: NSMatchingOptions, range: NSRange, templ: NSString | string): NSUInteger;
  replacementStringForResult_inString_offset_template(result: NSTextCheckingResult, string: NSString | string, offset: NSInteger, templ: NSString | string): NSString;
  static escapedTemplateForString(string: NSString | string): NSString;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  pattern(): NSString;
  options(): NSRegularExpressionOptions;
  numberOfCaptureGroups(): NSUInteger;
  static supportsSecureCoding(): boolean;
}

class NSDataDetectorAllocator<T extends NSDataDetector> extends NSRegularExpressionAllocator<T> {
  initWithTypes_error(checkingTypes: NSTextCheckingTypes, error: NSError): T;
}
declare class NSDataDetector extends NSRegularExpression {
  alloc<T extends NSDataDetector>(): NSDataDetectorAllocator<T>;
  static dataDetectorWithTypes_error(checkingTypes: NSTextCheckingTypes, error: NSError): NSDataDetector;

  checkingTypes(): NSTextCheckingTypes;
}

declare enum NSRegularExpressionOptions {
  NSRegularExpressionCaseInsensitive = 1 << 0,
  NSRegularExpressionAllowCommentsAndWhitespace = 1 << 1,
  NSRegularExpressionIgnoreMetacharacters = 1 << 2,
  NSRegularExpressionDotMatchesLineSeparators = 1 << 3,
  NSRegularExpressionAnchorsMatchLines = 1 << 4,
  NSRegularExpressionUseUnixLineSeparators = 1 << 5,
  NSRegularExpressionUseUnicodeWordBoundaries = 1 << 6,
}

declare enum NSMatchingOptions {
  NSMatchingReportProgress = 1 << 0,
  NSMatchingReportCompletion = 1 << 1,
  NSMatchingAnchored = 1 << 2,
  NSMatchingWithTransparentBounds = 1 << 3,
  NSMatchingWithoutAnchoringBounds = 1 << 4,
}

declare enum NSMatchingFlags {
  NSMatchingProgress = 1 << 0,
  NSMatchingCompleted = 1 << 1,
  NSMatchingHitEnd = 1 << 2,
  NSMatchingRequiredEnd = 1 << 3,
  NSMatchingInternalError = 1 << 4,
}

class NSRunLoopAllocator<T extends NSRunLoop> extends NSObjectAllocator<T> {}
declare class NSRunLoop extends NSObject {
  alloc<T extends NSRunLoop>(): NSRunLoopAllocator<T>;
  addTimer_forMode(timer: NSTimer, mode: NSRunLoopMode): void;
  addPort_forMode(aPort: NSPort, mode: NSRunLoopMode): void;
  removePort_forMode(aPort: NSPort, mode: NSRunLoopMode): void;
  limitDateForMode(mode: NSRunLoopMode): NSDate;
  acceptInputForMode_beforeDate(mode: NSRunLoopMode, limitDate: NSDate): void;
  run(): void;
  runUntilDate(limitDate: NSDate): void;
  runMode_beforeDate(mode: NSRunLoopMode, limitDate: NSDate): boolean;
  configureAsServer(): void;
  performInModes_block(modes: NSArray<any> | any[], block: Block): void;
  performBlock(block: Block): void;
  performSelector_target_argument_order_modes(aSelector: string, target: any, arg: any | null, order: NSUInteger, modes: NSArray<any> | any[]): void;
  cancelPerformSelector_target_argument(aSelector: string, target: any, arg: any | null): void;
  cancelPerformSelectorsWithTarget(target: any): void;

  static currentRunLoop(): NSRunLoop;
  static mainRunLoop(): NSRunLoop;
  currentMode(): NSRunLoopMode;
}

class NSScriptClassDescriptionAllocator<T extends NSScriptClassDescription> extends NSClassDescriptionAllocator<T> {
  initWithSuiteName_className_dictionary(suiteName: NSString | string, className: NSString | string, classDeclaration: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class NSScriptClassDescription extends NSClassDescription {
  alloc<T extends NSScriptClassDescription>(): NSScriptClassDescriptionAllocator<T>;
  static classDescriptionForClass(aClass: any): NSScriptClassDescription;
  matchesAppleEventCode(appleEventCode: number): boolean;
  supportsCommand(commandDescription: NSScriptCommandDescription): boolean;
  selectorForCommand(commandDescription: NSScriptCommandDescription): string;
  typeForKey(key: NSString | string): NSString;
  classDescriptionForKey(key: NSString | string): NSScriptClassDescription;
  appleEventCodeForKey(key: NSString | string): number;
  keyWithAppleEventCode(appleEventCode: number): NSString;
  isLocationRequiredToCreateForKey(toManyRelationshipKey: NSString | string): boolean;
  hasPropertyForKey(key: NSString | string): boolean;
  hasOrderedToManyRelationshipForKey(key: NSString | string): boolean;
  hasReadablePropertyForKey(key: NSString | string): boolean;
  hasWritablePropertyForKey(key: NSString | string): boolean;
  isReadOnlyKey(key: NSString | string): boolean;

  suiteName(): NSString;
  className(): NSString;
  implementationClassName(): NSString;
  superclassDescription(): NSScriptClassDescription;
  appleEventCode(): number;
  defaultSubcontainerAttributeKey(): NSString;
}

class NSScriptCoercionHandlerAllocator<T extends NSScriptCoercionHandler> extends NSObjectAllocator<T> {}
declare class NSScriptCoercionHandler extends NSObject {
  alloc<T extends NSScriptCoercionHandler>(): NSScriptCoercionHandlerAllocator<T>;
  static sharedCoercionHandler(): NSScriptCoercionHandler;
  coerceValue_toClass(value: any, toClass: any): any;
  registerCoercer_selector_toConvertFromClass_toClass(coercer: any, selector: string, fromClass: any, toClass: any): void;
}

class NSScriptCommandAllocator<T extends NSScriptCommand> extends NSObjectAllocator<T> {
  initWithCommandDescription(commandDef: NSScriptCommandDescription): T;
  initWithCoder(inCoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSScriptCommand extends NSObject implements INSCoding {
  alloc<T extends NSScriptCommand>(): NSScriptCommandAllocator<T>;
  performDefaultImplementation(): any;
  executeCommand(): any;
  static currentCommand(): NSScriptCommand;
  suspendExecution(): void;
  resumeExecutionWithResult(result: any | null): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  commandDescription(): NSScriptCommandDescription;
  directParameter(): any;
  setDirectParameter(directParameter: any): void;
  receiversSpecifier(): NSScriptObjectSpecifier;
  setReceiversSpecifier(receiversSpecifier: NSScriptObjectSpecifier): void;
  evaluatedReceivers(): any;
  arguments(): NSDictionary<any, any>;
  setArguments(arguments: NSDictionary<any, any> | {[key: string]: any}): void;
  evaluatedArguments(): NSDictionary<any, any>;
  wellFormed(): boolean;
  scriptErrorNumber(): NSInteger;
  setScriptErrorNumber(scriptErrorNumber: NSInteger): void;
  scriptErrorOffendingObjectDescriptor(): NSAppleEventDescriptor;
  setScriptErrorOffendingObjectDescriptor(scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptor): void;
  scriptErrorExpectedTypeDescriptor(): NSAppleEventDescriptor;
  setScriptErrorExpectedTypeDescriptor(scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptor): void;
  scriptErrorString(): NSString;
  setScriptErrorString(scriptErrorString: NSString | string): void;
  appleEvent(): NSAppleEventDescriptor;
}

class NSScriptCommandDescriptionAllocator<T extends NSScriptCommandDescription> extends NSObjectAllocator<T> {
  initWithSuiteName_commandName_dictionary(suiteName: NSString | string, commandName: NSString | string, commandDeclaration: NSDictionary<any, any> | {[key: string]: any} | null): T;
  initWithCoder(inCoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSScriptCommandDescription extends NSObject implements INSCoding {
  alloc<T extends NSScriptCommandDescription>(): NSScriptCommandDescriptionAllocator<T>;
  typeForArgumentWithName(argumentName: NSString | string): NSString;
  appleEventCodeForArgumentWithName(argumentName: NSString | string): number;
  isOptionalArgumentWithName(argumentName: NSString | string): boolean;
  createCommandInstance(): NSScriptCommand;
  createCommandInstanceWithZone(zone: NSZone | null): NSScriptCommand;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  suiteName(): NSString;
  commandName(): NSString;
  appleEventClassCode(): number;
  appleEventCode(): number;
  commandClassName(): NSString;
  returnType(): NSString;
  appleEventCodeForReturnType(): number;
  argumentNames(): NSArray<any>;
}

class NSScriptExecutionContextAllocator<T extends NSScriptExecutionContext> extends NSObjectAllocator<T> {}
declare class NSScriptExecutionContext extends NSObject {
  alloc<T extends NSScriptExecutionContext>(): NSScriptExecutionContextAllocator<T>;
  static sharedScriptExecutionContext(): NSScriptExecutionContext;

  topLevelObject(): any;
  setTopLevelObject(topLevelObject: any): void;
  objectBeingTested(): any;
  setObjectBeingTested(objectBeingTested: any): void;
  rangeContainerObject(): any;
  setRangeContainerObject(rangeContainerObject: any): void;
}

class NSScriptObjectSpecifierAllocator<T extends NSScriptObjectSpecifier> extends NSObjectAllocator<T> {
  initWithContainerSpecifier_key(container: NSScriptObjectSpecifier, property: NSString | string): T;
  initWithContainerClassDescription_containerSpecifier_key(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string): T;
  initWithCoder(inCoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSScriptObjectSpecifier extends NSObject implements INSCoding {
  alloc<T extends NSScriptObjectSpecifier>(): NSScriptObjectSpecifierAllocator<T>;
  static objectSpecifierWithDescriptor(descriptor: NSAppleEventDescriptor): NSScriptObjectSpecifier;
  indicesOfObjectsByEvaluatingWithContainer_count(container: any, count: NSInteger): NSInteger;
  objectsByEvaluatingWithContainers(containers: any): any;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  childSpecifier(): NSScriptObjectSpecifier;
  setChildSpecifier(childSpecifier: NSScriptObjectSpecifier): void;
  containerSpecifier(): NSScriptObjectSpecifier;
  setContainerSpecifier(containerSpecifier: NSScriptObjectSpecifier): void;
  containerIsObjectBeingTested(): boolean;
  setContainerIsObjectBeingTested(containerIsObjectBeingTested: boolean): void;
  containerIsRangeContainerObject(): boolean;
  setContainerIsRangeContainerObject(containerIsRangeContainerObject: boolean): void;
  key(): NSString;
  setKey(key: NSString | string): void;
  containerClassDescription(): NSScriptClassDescription;
  setContainerClassDescription(containerClassDescription: NSScriptClassDescription): void;
  keyClassDescription(): NSScriptClassDescription;
  objectsByEvaluatingSpecifier(): any;
  evaluationErrorNumber(): NSInteger;
  setEvaluationErrorNumber(evaluationErrorNumber: NSInteger): void;
  evaluationErrorSpecifier(): NSScriptObjectSpecifier;
  descriptor(): NSAppleEventDescriptor;
}

class NSIndexSpecifierAllocator<T extends NSIndexSpecifier> extends NSScriptObjectSpecifierAllocator<T> {
  initWithContainerClassDescription_containerSpecifier_key_index(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, index: NSInteger): T;
}
declare class NSIndexSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSIndexSpecifier>(): NSIndexSpecifierAllocator<T>;

  index(): NSInteger;
  setIndex(index: NSInteger): void;
}

class NSMiddleSpecifierAllocator<T extends NSMiddleSpecifier> extends NSScriptObjectSpecifierAllocator<T> {}
declare class NSMiddleSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSMiddleSpecifier>(): NSMiddleSpecifierAllocator<T>;
}

class NSNameSpecifierAllocator<T extends NSNameSpecifier> extends NSScriptObjectSpecifierAllocator<T> {
  initWithContainerClassDescription_containerSpecifier_key_name(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, name: NSString | string): T;
}
declare class NSNameSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSNameSpecifier>(): NSNameSpecifierAllocator<T>;

  name(): NSString;
  setName(name: NSString | string): void;
}

class NSPositionalSpecifierAllocator<T extends NSPositionalSpecifier> extends NSObjectAllocator<T> {
  initWithPosition_objectSpecifier(position: NSInsertionPosition, specifier: NSScriptObjectSpecifier): T;
}
declare class NSPositionalSpecifier extends NSObject {
  alloc<T extends NSPositionalSpecifier>(): NSPositionalSpecifierAllocator<T>;
  setInsertionClassDescription(classDescription: NSScriptClassDescription): void;
  evaluate(): void;

  position(): NSInsertionPosition;
  objectSpecifier(): NSScriptObjectSpecifier;
  insertionContainer(): any;
  insertionKey(): NSString;
  insertionIndex(): NSInteger;
  insertionReplaces(): boolean;
}

class NSPropertySpecifierAllocator<T extends NSPropertySpecifier> extends NSScriptObjectSpecifierAllocator<T> {}
declare class NSPropertySpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSPropertySpecifier>(): NSPropertySpecifierAllocator<T>;
}

class NSRandomSpecifierAllocator<T extends NSRandomSpecifier> extends NSScriptObjectSpecifierAllocator<T> {}
declare class NSRandomSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSRandomSpecifier>(): NSRandomSpecifierAllocator<T>;
}

class NSRangeSpecifierAllocator<T extends NSRangeSpecifier> extends NSScriptObjectSpecifierAllocator<T> {
  initWithContainerClassDescription_containerSpecifier_key_startSpecifier_endSpecifier(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, startSpec: NSScriptObjectSpecifier | null, endSpec: NSScriptObjectSpecifier | null): T;
}
declare class NSRangeSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSRangeSpecifier>(): NSRangeSpecifierAllocator<T>;

  startSpecifier(): NSScriptObjectSpecifier;
  setStartSpecifier(startSpecifier: NSScriptObjectSpecifier): void;
  endSpecifier(): NSScriptObjectSpecifier;
  setEndSpecifier(endSpecifier: NSScriptObjectSpecifier): void;
}

class NSRelativeSpecifierAllocator<T extends NSRelativeSpecifier> extends NSScriptObjectSpecifierAllocator<T> {
  initWithContainerClassDescription_containerSpecifier_key_relativePosition_baseSpecifier(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, relPos: NSRelativePosition, baseSpecifier: NSScriptObjectSpecifier | null): T;
}
declare class NSRelativeSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSRelativeSpecifier>(): NSRelativeSpecifierAllocator<T>;

  relativePosition(): NSRelativePosition;
  setRelativePosition(relativePosition: NSRelativePosition): void;
  baseSpecifier(): NSScriptObjectSpecifier;
  setBaseSpecifier(baseSpecifier: NSScriptObjectSpecifier): void;
}

class NSUniqueIDSpecifierAllocator<T extends NSUniqueIDSpecifier> extends NSScriptObjectSpecifierAllocator<T> {
  initWithContainerClassDescription_containerSpecifier_key_uniqueID(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, uniqueID: any): T;
}
declare class NSUniqueIDSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSUniqueIDSpecifier>(): NSUniqueIDSpecifierAllocator<T>;

  uniqueID(): any;
  setUniqueID(uniqueID: any): void;
}

class NSWhoseSpecifierAllocator<T extends NSWhoseSpecifier> extends NSScriptObjectSpecifierAllocator<T> {
  initWithContainerClassDescription_containerSpecifier_key_test(classDesc: NSScriptClassDescription, container: NSScriptObjectSpecifier | null, property: NSString | string, test: NSScriptWhoseTest): T;
}
declare class NSWhoseSpecifier extends NSScriptObjectSpecifier {
  alloc<T extends NSWhoseSpecifier>(): NSWhoseSpecifierAllocator<T>;

  test(): NSScriptWhoseTest;
  setTest(test: NSScriptWhoseTest): void;
  startSubelementIdentifier(): NSWhoseSubelementIdentifier;
  setStartSubelementIdentifier(startSubelementIdentifier: NSWhoseSubelementIdentifier): void;
  startSubelementIndex(): NSInteger;
  setStartSubelementIndex(startSubelementIndex: NSInteger): void;
  endSubelementIdentifier(): NSWhoseSubelementIdentifier;
  setEndSubelementIdentifier(endSubelementIdentifier: NSWhoseSubelementIdentifier): void;
  endSubelementIndex(): NSInteger;
  setEndSubelementIndex(endSubelementIndex: NSInteger): void;
}

declare enum NSInsertionPosition {
  NSPositionAfter,
  NSPositionBefore,
  NSPositionBeginning,
  NSPositionEnd,
  NSPositionReplace,
}

declare enum NSRelativePosition {
  NSRelativeAfter = 0,
  NSRelativeBefore,
}

declare enum NSWhoseSubelementIdentifier {
  NSIndexSubelement = 0,
  NSEverySubelement = 1,
  NSMiddleSubelement = 2,
  NSRandomSubelement = 3,
  NSNoSubelement = 4,
}

class NSCloneCommandAllocator<T extends NSCloneCommand> extends NSScriptCommandAllocator<T> {}
declare class NSCloneCommand extends NSScriptCommand {
  alloc<T extends NSCloneCommand>(): NSCloneCommandAllocator<T>;
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}

class NSCloseCommandAllocator<T extends NSCloseCommand> extends NSScriptCommandAllocator<T> {}
declare class NSCloseCommand extends NSScriptCommand {
  alloc<T extends NSCloseCommand>(): NSCloseCommandAllocator<T>;

  saveOptions(): NSSaveOptions;
}

class NSCountCommandAllocator<T extends NSCountCommand> extends NSScriptCommandAllocator<T> {}
declare class NSCountCommand extends NSScriptCommand {
  alloc<T extends NSCountCommand>(): NSCountCommandAllocator<T>;
}

class NSCreateCommandAllocator<T extends NSCreateCommand> extends NSScriptCommandAllocator<T> {}
declare class NSCreateCommand extends NSScriptCommand {
  alloc<T extends NSCreateCommand>(): NSCreateCommandAllocator<T>;

  createClassDescription(): NSScriptClassDescription;
  resolvedKeyDictionary(): NSDictionary<any, any>;
}

class NSDeleteCommandAllocator<T extends NSDeleteCommand> extends NSScriptCommandAllocator<T> {}
declare class NSDeleteCommand extends NSScriptCommand {
  alloc<T extends NSDeleteCommand>(): NSDeleteCommandAllocator<T>;
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}

class NSExistsCommandAllocator<T extends NSExistsCommand> extends NSScriptCommandAllocator<T> {}
declare class NSExistsCommand extends NSScriptCommand {
  alloc<T extends NSExistsCommand>(): NSExistsCommandAllocator<T>;
}

class NSGetCommandAllocator<T extends NSGetCommand> extends NSScriptCommandAllocator<T> {}
declare class NSGetCommand extends NSScriptCommand {
  alloc<T extends NSGetCommand>(): NSGetCommandAllocator<T>;
}

class NSMoveCommandAllocator<T extends NSMoveCommand> extends NSScriptCommandAllocator<T> {}
declare class NSMoveCommand extends NSScriptCommand {
  alloc<T extends NSMoveCommand>(): NSMoveCommandAllocator<T>;
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}

class NSQuitCommandAllocator<T extends NSQuitCommand> extends NSScriptCommandAllocator<T> {}
declare class NSQuitCommand extends NSScriptCommand {
  alloc<T extends NSQuitCommand>(): NSQuitCommandAllocator<T>;

  saveOptions(): NSSaveOptions;
}

class NSSetCommandAllocator<T extends NSSetCommand> extends NSScriptCommandAllocator<T> {}
declare class NSSetCommand extends NSScriptCommand {
  alloc<T extends NSSetCommand>(): NSSetCommandAllocator<T>;
  setReceiversSpecifier(receiversRef: NSScriptObjectSpecifier | null): void;

  keySpecifier(): NSScriptObjectSpecifier;
}

declare enum NSSaveOptions {
  NSSaveOptionsYes = 0,
  NSSaveOptionsNo,
  NSSaveOptionsAsk,
}

class NSScriptSuiteRegistryAllocator<T extends NSScriptSuiteRegistry> extends NSObjectAllocator<T> {}
declare class NSScriptSuiteRegistry extends NSObject {
  alloc<T extends NSScriptSuiteRegistry>(): NSScriptSuiteRegistryAllocator<T>;
  static sharedScriptSuiteRegistry(): NSScriptSuiteRegistry;
  static setSharedScriptSuiteRegistry(registry: NSScriptSuiteRegistry): void;
  loadSuitesFromBundle(bundle: NSBundle): void;
  loadSuiteWithDictionary_fromBundle(suiteDeclaration: NSDictionary<any, any> | {[key: string]: any}, bundle: NSBundle): void;
  registerClassDescription(classDescription: NSScriptClassDescription): void;
  registerCommandDescription(commandDescription: NSScriptCommandDescription): void;
  appleEventCodeForSuite(suiteName: NSString | string): number;
  bundleForSuite(suiteName: NSString | string): NSBundle;
  classDescriptionsInSuite(suiteName: NSString | string): NSDictionary<any, any>;
  commandDescriptionsInSuite(suiteName: NSString | string): NSDictionary<any, any>;
  suiteForAppleEventCode(appleEventCode: number): NSString;
  classDescriptionWithAppleEventCode(appleEventCode: number): NSScriptClassDescription;
  commandDescriptionWithAppleEventClass_andAppleEventCode(appleEventClassCode: number, appleEventIDCode: number): NSScriptCommandDescription;
  aeteResource(languageName: NSString | string): NSData;

  suiteNames(): NSArray<any>;
}

class NSScriptWhoseTestAllocator<T extends NSScriptWhoseTest> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(inCoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSScriptWhoseTest extends NSObject implements INSCoding {
  alloc<T extends NSScriptWhoseTest>(): NSScriptWhoseTestAllocator<T>;
  isTrue(): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
}

class NSLogicalTestAllocator<T extends NSLogicalTest> extends NSScriptWhoseTestAllocator<T> {
  initAndTestWithTests(subTests: NSArray<any> | any[]): T;
  initOrTestWithTests(subTests: NSArray<any> | any[]): T;
  initNotTestWithTest(subTest: NSScriptWhoseTest): T;
}
declare class NSLogicalTest extends NSScriptWhoseTest {
  alloc<T extends NSLogicalTest>(): NSLogicalTestAllocator<T>;
}

class NSSpecifierTestAllocator<T extends NSSpecifierTest> extends NSScriptWhoseTestAllocator<T> {
  initWithObjectSpecifier_comparisonOperator_testObject(obj1: NSScriptObjectSpecifier | null, compOp: NSTestComparisonOperation, obj2: any | null): T;
}
declare class NSSpecifierTest extends NSScriptWhoseTest {
  alloc<T extends NSSpecifierTest>(): NSSpecifierTestAllocator<T>;
}

declare enum NSTestComparisonOperation {
  NSEqualToComparison = 0,
  NSLessThanOrEqualToComparison,
  NSLessThanComparison,
  NSGreaterThanOrEqualToComparison,
  NSGreaterThanComparison,
  NSBeginsWithComparison,
  NSEndsWithComparison,
  NSContainsComparison,
}

class NSCountedSetAllocator<ObjectType, T extends NSCountedSet<ObjectType>> extends NSMutableSetAllocator<ObjectType, T> {}
declare class NSCountedSet<ObjectType> extends NSMutableSet<ObjectType> {
  alloc<T extends NSCountedSet<ObjectType>>(): NSCountedSetAllocator<ObjectType, T>;
  countForObject(object: ObjectType): NSUInteger;
  objectEnumerator(): NSEnumerator<any>;
  addObject(object: ObjectType): void;
  removeObject(object: ObjectType): void;
}

class NSSortDescriptorAllocator<T extends NSSortDescriptor> extends NSObjectAllocator<T> {
  initWithKey_ascending(key: NSString | string | null, ascending: boolean): T;
  initWithKey_ascending_selector(key: NSString | string | null, ascending: boolean, selector: string | null): T;
  initWithCoder(coder: NSCoder): T;
  initWithKey_ascending_comparator(key: NSString | string | null, ascending: boolean, cmptr: NSComparator): T;
}
declare class NSSortDescriptor extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSSortDescriptor>(): NSSortDescriptorAllocator<T>;
  static sortDescriptorWithKey_ascending(key: NSString | string | null, ascending: boolean): NSSortDescriptor;
  static sortDescriptorWithKey_ascending_selector(key: NSString | string | null, ascending: boolean, selector: string | null): NSSortDescriptor;
  allowEvaluation(): void;
  static sortDescriptorWithKey_ascending_comparator(key: NSString | string | null, ascending: boolean, cmptr: NSComparator): NSSortDescriptor;
  compareObject_toObject(object1: any, object2: any): NSComparisonResult;
  static localizedCaseInsensitiveSortDescriptorWithKey_ascending(key: NSString | string | null, ascending: boolean): NSSortDescriptor;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  key(): NSString;
  ascending(): boolean;
  selector(): string;
  comparator(): NSComparator;
  reversedSortDescriptor(): any;
  static supportsSecureCoding(): boolean;
}

class NSSpellServerAllocator<T extends NSSpellServer> extends NSObjectAllocator<T> {}
declare class NSSpellServer extends NSObject {
  alloc<T extends NSSpellServer>(): NSSpellServerAllocator<T>;
  registerLanguage_byVendor(language: NSString | string | null, vendor: NSString | string | null): boolean;
  isWordInUserDictionaries_caseSensitive(word: NSString | string, flag: boolean): boolean;
  run(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface INSSpellServerDelegate {
  spellServer_findMisspelledWordInString_language_wordCount_countOnly(sender: NSSpellServer, stringToCheck: NSString | string, language: NSString | string, wordCount: NSInteger, countOnly: boolean): NSRange;
  spellServer_suggestGuessesForWord_inLanguage(sender: NSSpellServer, word: NSString | string, language: NSString | string): NSArray<any>;
  spellServer_didLearnWord_inLanguage(sender: NSSpellServer, word: NSString | string, language: NSString | string): void;
  spellServer_didForgetWord_inLanguage(sender: NSSpellServer, word: NSString | string, language: NSString | string): void;
  spellServer_suggestCompletionsForPartialWordRange_inString_language(sender: NSSpellServer, range: NSRange, string: NSString | string, language: NSString | string): NSArray<any>;
  spellServer_checkGrammarInString_language_details(sender: NSSpellServer, stringToCheck: NSString | string, language: NSString | string | null, details: NSArray<any> | any[]): NSRange;
  spellServer_checkString_offset_types_options_orthography_wordCount(sender: NSSpellServer, stringToCheck: NSString | string, offset: NSUInteger, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, orthography: NSOrthography | null, wordCount: NSInteger): NSArray<any>;
  spellServer_recordResponse_toCorrection_forWord_language(sender: NSSpellServer, response: NSUInteger, correction: NSString | string, word: NSString | string, language: NSString | string): void;
}

class NSStreamAllocator<T extends NSStream> extends NSObjectAllocator<T> {}
declare class NSStream extends NSObject {
  alloc<T extends NSStream>(): NSStreamAllocator<T>;
  open(): void;
  close(): void;
  propertyForKey(key: NSStreamPropertyKey): any;
  setProperty_forKey(property: any | null, key: NSStreamPropertyKey): boolean;
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  removeFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  static getStreamsToHostWithName_port_inputStream_outputStream(hostname: NSString | string, port: NSInteger, inputStream: NSInputStream, outputStream: NSOutputStream): void;
  static getStreamsToHost_port_inputStream_outputStream(host: NSHost, port: NSInteger, inputStream: NSInputStream, outputStream: NSOutputStream): void;
  static getBoundStreamsWithBufferSize_inputStream_outputStream(bufferSize: NSUInteger, inputStream: NSInputStream, outputStream: NSOutputStream): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  streamStatus(): NSStreamStatus;
  streamError(): NSError;
}

class NSInputStreamAllocator<T extends NSInputStream> extends NSStreamAllocator<T> {
  initWithData(data: NSData): T;
  initWithURL(url: NSURL): T;
  initWithFileAtPath(path: NSString | string): T;
}
declare class NSInputStream extends NSStream {
  alloc<T extends NSInputStream>(): NSInputStreamAllocator<T>;
  read_maxLength(buffer: number, len: NSUInteger): NSInteger;
  getBuffer_length(buffer: number, len: NSUInteger): boolean;
  static inputStreamWithData(data: NSData): NSInputStream;
  static inputStreamWithFileAtPath(path: NSString | string): NSInputStream;
  static inputStreamWithURL(url: NSURL): NSInputStream;

  hasBytesAvailable(): boolean;
}

class NSOutputStreamAllocator<T extends NSOutputStream> extends NSStreamAllocator<T> {
  initToMemory(): T;
  initToBuffer_capacity(buffer: number, capacity: NSUInteger): T;
  initWithURL_append(url: NSURL, shouldAppend: boolean): T;
  initToFileAtPath_append(path: NSString | string, shouldAppend: boolean): T;
}
declare class NSOutputStream extends NSStream {
  alloc<T extends NSOutputStream>(): NSOutputStreamAllocator<T>;
  write_maxLength(buffer: number, len: NSUInteger): NSInteger;
  static outputStreamToMemory(): NSOutputStream;
  static outputStreamToBuffer_capacity(buffer: number, capacity: NSUInteger): NSOutputStream;
  static outputStreamToFileAtPath_append(path: NSString | string, shouldAppend: boolean): NSOutputStream;
  static outputStreamWithURL_append(url: NSURL, shouldAppend: boolean): NSOutputStream;

  hasSpaceAvailable(): boolean;
}

declare interface INSStreamDelegate {
  stream_handleEvent(aStream: NSStream, eventCode: NSStreamEvent): void;
}

declare type NSStreamPropertyKey = NSString

declare type NSStreamSocketSecurityLevel = NSString

declare type NSStreamSOCKSProxyConfiguration = NSString

declare type NSStreamSOCKSProxyVersion = NSString

declare type NSStreamNetworkServiceTypeValue = NSString

declare enum NSStreamStatus {
  NSStreamStatusNotOpen = 0,
  NSStreamStatusOpening = 1,
  NSStreamStatusOpen = 2,
  NSStreamStatusReading = 3,
  NSStreamStatusWriting = 4,
  NSStreamStatusAtEnd = 5,
  NSStreamStatusClosed = 6,
  NSStreamStatusError = 7,
}

declare enum NSStreamEvent {
  NSStreamEventNone = 0,
  NSStreamEventOpenCompleted = 1 << 0,
  NSStreamEventHasBytesAvailable = 1 << 1,
  NSStreamEventHasSpaceAvailable = 1 << 2,
  NSStreamEventErrorOccurred = 1 << 3,
  NSStreamEventEndEncountered = 1 << 4,
}

class NSMutableStringAllocator<T extends NSMutableString> extends NSStringAllocator<T> {
  initWithCapacity(capacity: NSUInteger): T;
}
declare class NSMutableString extends NSString {
  alloc<T extends NSMutableString>(): NSMutableStringAllocator<T>;
  replaceCharactersInRange_withString(range: NSRange, aString: NSString | string): void;
  insertString_atIndex(aString: NSString | string, loc: NSUInteger): void;
  deleteCharactersInRange(range: NSRange): void;
  appendString(aString: NSString | string): void;
  appendFormat(format: NSString | string, ...args: any[]): void;
  setString(aString: NSString | string): void;
  replaceOccurrencesOfString_withString_options_range(target: NSString | string, replacement: NSString | string, options: NSStringCompareOptions, searchRange: NSRange): NSUInteger;
  applyTransform_reverse_range_updatedRange(transform: NSStringTransform, reverse: boolean, range: NSRange, resultingRange: NSRangePointer | null): boolean;
  static stringWithCapacity(capacity: NSUInteger): NSMutableString;
}

class NSSimpleCStringAllocator<T extends NSSimpleCString> extends NSStringAllocator<T> {}
declare class NSSimpleCString extends NSString {
  alloc<T extends NSSimpleCString>(): NSSimpleCStringAllocator<T>;
}

class NSConstantStringAllocator<T extends NSConstantString> extends NSSimpleCStringAllocator<T> {}
declare class NSConstantString extends NSSimpleCString {
  alloc<T extends NSConstantString>(): NSConstantStringAllocator<T>;
}

declare type unichar = number

declare type NSStringEncoding = NSUInteger

declare type NSStringTransform = NSString

declare type NSStringEncodingDetectionOptionsKey = NSString

declare enum NSStringCompareOptions {
  NSCaseInsensitiveSearch = 1,
  NSLiteralSearch = 2,
  NSBackwardsSearch = 4,
  NSAnchoredSearch = 8,
  NSNumericSearch = 64,
  NSDiacriticInsensitiveSearch = 128,
  NSWidthInsensitiveSearch = 256,
  NSForcedOrderingSearch = 512,
  NSRegularExpressionSearch = 1024,
}

declare enum NSStringEncodingConversionOptions {
  NSStringEncodingConversionAllowLossy = 1,
  NSStringEncodingConversionExternalRepresentation = 2,
}

declare enum NSStringEnumerationOptions {
  NSStringEnumerationByLines = 0,
  NSStringEnumerationByParagraphs = 1,
  NSStringEnumerationByComposedCharacterSequences = 2,
  NSStringEnumerationByWords = 3,
  NSStringEnumerationBySentences = 4,
  NSStringEnumerationReverse = 1 << 8,
  NSStringEnumerationSubstringNotRequired = 1 << 9,
  NSStringEnumerationLocalized = 1 << 10,
}

class NSTaskAllocator<T extends NSTask> extends NSObjectAllocator<T> {
  init(): T;
}
declare class NSTask extends NSObject {
  alloc<T extends NSTask>(): NSTaskAllocator<T>;
  launchAndReturnError(error: NSError): boolean;
  interrupt(): void;
  terminate(): void;
  suspend(): boolean;
  resume(): boolean;
  static launchedTaskWithExecutableURL_arguments_error_terminationHandler(url: NSURL, arguments: NSArray<any> | any[], error: NSError, terminationHandler: Block): NSTask;
  waitUntilExit(): void;
  launch(): void;
  static launchedTaskWithLaunchPath_arguments(path: NSString | string, arguments: NSArray<any> | any[]): NSTask;

  executableURL(): NSURL;
  setExecutableURL(executableURL: NSURL): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  environment(): NSDictionary<any, any>;
  setEnvironment(environment: NSDictionary<any, any> | {[key: string]: any}): void;
  currentDirectoryURL(): NSURL;
  setCurrentDirectoryURL(currentDirectoryURL: NSURL): void;
  standardInput(): any;
  setStandardInput(standardInput: any): void;
  standardOutput(): any;
  setStandardOutput(standardOutput: any): void;
  standardError(): any;
  setStandardError(standardError: any): void;
  processIdentifier(): number;
  running(): boolean;
  terminationStatus(): number;
  terminationReason(): NSTaskTerminationReason;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  launchPath(): NSString;
  setLaunchPath(launchPath: NSString | string): void;
  currentDirectoryPath(): NSString;
  setCurrentDirectoryPath(currentDirectoryPath: NSString | string): void;
}

declare enum NSTaskTerminationReason {
  NSTaskTerminationReasonExit = 1,
  NSTaskTerminationReasonUncaughtSignal = 2,
}

class NSTextCheckingResultAllocator<T extends NSTextCheckingResult> extends NSObjectAllocator<T> {}
declare class NSTextCheckingResult extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSTextCheckingResult>(): NSTextCheckingResultAllocator<T>;
  rangeAtIndex(idx: NSUInteger): NSRange;
  rangeWithName(name: NSString | string): NSRange;
  resultByAdjustingRangesWithOffset(offset: NSInteger): NSTextCheckingResult;
  static orthographyCheckingResultWithRange_orthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
  static spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
  static grammarCheckingResultWithRange_details(range: NSRange, details: NSArray<any> | any[]): NSTextCheckingResult;
  static dateCheckingResultWithRange_date(range: NSRange, date: NSDate): NSTextCheckingResult;
  static dateCheckingResultWithRange_date_timeZone_duration(range: NSRange, date: NSDate, timeZone: NSTimeZone, duration: NSTimeInterval): NSTextCheckingResult;
  static addressCheckingResultWithRange_components(range: NSRange, components: NSDictionary<any, any> | {[key: string]: any}): NSTextCheckingResult;
  static linkCheckingResultWithRange_URL(range: NSRange, url: NSURL): NSTextCheckingResult;
  static quoteCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  static dashCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  static replacementCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  static correctionCheckingResultWithRange_replacementString(range: NSRange, replacementString: NSString | string): NSTextCheckingResult;
  static correctionCheckingResultWithRange_replacementString_alternativeStrings(range: NSRange, replacementString: NSString | string, alternativeStrings: NSArray<any> | any[]): NSTextCheckingResult;
  static regularExpressionCheckingResultWithRanges_count_regularExpression(ranges: NSRangePointer, count: NSUInteger, regularExpression: NSRegularExpression): NSTextCheckingResult;
  static phoneNumberCheckingResultWithRange_phoneNumber(range: NSRange, phoneNumber: NSString | string): NSTextCheckingResult;
  static transitInformationCheckingResultWithRange_components(range: NSRange, components: NSDictionary<any, any> | {[key: string]: any}): NSTextCheckingResult;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  resultType(): NSTextCheckingType;
  range(): NSRange;
  orthography(): NSOrthography;
  grammarDetails(): NSArray<any>;
  date(): NSDate;
  timeZone(): NSTimeZone;
  duration(): NSTimeInterval;
  components(): NSDictionary<any, any>;
  URL(): NSURL;
  replacementString(): NSString;
  alternativeStrings(): NSArray<any>;
  regularExpression(): NSRegularExpression;
  phoneNumber(): NSString;
  numberOfRanges(): NSUInteger;
  addressComponents(): NSDictionary<any, any>;
  static supportsSecureCoding(): boolean;
}

declare type NSTextCheckingTypes = number

declare type NSTextCheckingKey = NSString

declare enum NSTextCheckingType {
  NSTextCheckingTypeOrthography = 1 << 0,
  NSTextCheckingTypeSpelling = 1 << 1,
  NSTextCheckingTypeGrammar = 1 << 2,
  NSTextCheckingTypeDate = 1 << 3,
  NSTextCheckingTypeAddress = 1 << 4,
  NSTextCheckingTypeLink = 1 << 5,
  NSTextCheckingTypeQuote = 1 << 6,
  NSTextCheckingTypeDash = 1 << 7,
  NSTextCheckingTypeReplacement = 1 << 8,
  NSTextCheckingTypeCorrection = 1 << 9,
  NSTextCheckingTypeRegularExpression = 1 << 10,
  NSTextCheckingTypePhoneNumber = 1 << 11,
  NSTextCheckingTypeTransitInformation = 1 << 12,
}

class NSThreadAllocator<T extends NSThread> extends NSObjectAllocator<T> {
  init(): T;
  initWithTarget_selector_object(target: any, selector: string, argument: any | null): T;
  initWithBlock(block: Block): T;
}
declare class NSThread extends NSObject {
  alloc<T extends NSThread>(): NSThreadAllocator<T>;
  static detachNewThreadWithBlock(block: Block): void;
  static detachNewThreadSelector_toTarget_withObject(selector: string, target: any, argument: any | null): void;
  static isMultiThreaded(): boolean;
  static sleepUntilDate(date: NSDate): void;
  static sleepForTimeInterval(ti: NSTimeInterval): void;
  static exit(): void;
  static threadPriority(): number;
  static setThreadPriority(p: number): boolean;
  cancel(): void;
  start(): void;
  main(): void;

  static currentThread(): NSThread;
  threadDictionary(): NSMutableDictionary<any, any>;
  threadPriority(): number;
  setThreadPriority(threadPriority: number): void;
  qualityOfService(): NSQualityOfService;
  setQualityOfService(qualityOfService: NSQualityOfService): void;
  static callStackReturnAddresses(): NSArray<any>;
  static callStackSymbols(): NSArray<any>;
  name(): NSString;
  setName(name: NSString | string): void;
  stackSize(): NSUInteger;
  setStackSize(stackSize: NSUInteger): void;
  static isMainThread(): boolean;
  static mainThread(): NSThread;
  executing(): boolean;
  finished(): boolean;
  cancelled(): boolean;
}

class NSTimeZoneAllocator<T extends NSTimeZone> extends NSObjectAllocator<T> {
  initWithName(tzName: NSString | string): T;
  initWithName_data(tzName: NSString | string, aData: NSData | null): T;
}
declare class NSTimeZone extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSTimeZone>(): NSTimeZoneAllocator<T>;
  secondsFromGMTForDate(aDate: NSDate): NSInteger;
  abbreviationForDate(aDate: NSDate): NSString;
  isDaylightSavingTimeForDate(aDate: NSDate): boolean;
  daylightSavingTimeOffsetForDate(aDate: NSDate): NSTimeInterval;
  nextDaylightSavingTimeTransitionAfterDate(aDate: NSDate): NSDate;
  static resetSystemTimeZone(): void;
  static abbreviationDictionary(): NSDictionary<any, any>;
  isEqualToTimeZone(aTimeZone: NSTimeZone): boolean;
  localizedName_locale(style: NSTimeZoneNameStyle, locale: NSLocale | null): NSString;
  static timeZoneWithName(tzName: NSString | string): NSTimeZone;
  static timeZoneWithName_data(tzName: NSString | string, aData: NSData | null): NSTimeZone;
  static timeZoneForSecondsFromGMT(seconds: NSInteger): NSTimeZone;
  static timeZoneWithAbbreviation(abbreviation: NSString | string): NSTimeZone;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  name(): NSString;
  data(): NSData;
  static systemTimeZone(): NSTimeZone;
  static defaultTimeZone(): NSTimeZone;
  static setDefaultTimeZone(defaultTimeZone: NSTimeZone): void;
  static localTimeZone(): NSTimeZone;
  static knownTimeZoneNames(): NSArray<any>;
  static abbreviationDictionary(): NSDictionary<any, any>;
  static setAbbreviationDictionary(abbreviationDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  static timeZoneDataVersion(): NSString;
  secondsFromGMT(): NSInteger;
  abbreviation(): NSString;
  daylightSavingTime(): boolean;
  daylightSavingTimeOffset(): NSTimeInterval;
  nextDaylightSavingTimeTransition(): NSDate;
  description(): NSString;
  static supportsSecureCoding(): boolean;
}

declare enum NSTimeZoneNameStyle {
  NSTimeZoneNameStyleStandard,
  NSTimeZoneNameStyleShortStandard,
  NSTimeZoneNameStyleDaylightSaving,
  NSTimeZoneNameStyleShortDaylightSaving,
  NSTimeZoneNameStyleGeneric,
  NSTimeZoneNameStyleShortGeneric,
}

class NSTimerAllocator<T extends NSTimer> extends NSObjectAllocator<T> {
  initWithFireDate_interval_repeats_block(date: NSDate, interval: NSTimeInterval, repeats: boolean, block: Block): T;
  initWithFireDate_interval_target_selector_userInfo_repeats(date: NSDate, ti: NSTimeInterval, t: any, s: string, ui: any | null, rep: boolean): T;
}
declare class NSTimer extends NSObject {
  alloc<T extends NSTimer>(): NSTimerAllocator<T>;
  static timerWithTimeInterval_invocation_repeats(ti: NSTimeInterval, invocation: NSInvocation, yesOrNo: boolean): NSTimer;
  static scheduledTimerWithTimeInterval_invocation_repeats(ti: NSTimeInterval, invocation: NSInvocation, yesOrNo: boolean): NSTimer;
  static timerWithTimeInterval_target_selector_userInfo_repeats(ti: NSTimeInterval, aTarget: any, aSelector: string, userInfo: any | null, yesOrNo: boolean): NSTimer;
  static scheduledTimerWithTimeInterval_target_selector_userInfo_repeats(ti: NSTimeInterval, aTarget: any, aSelector: string, userInfo: any | null, yesOrNo: boolean): NSTimer;
  static timerWithTimeInterval_repeats_block(interval: NSTimeInterval, repeats: boolean, block: Block): NSTimer;
  static scheduledTimerWithTimeInterval_repeats_block(interval: NSTimeInterval, repeats: boolean, block: Block): NSTimer;
  fire(): void;
  invalidate(): void;
  static scheduledTimerWithTimeInterval_repeats_block_ch(interval: NSTimeInterval, repeats: boolean, block: BCTimerBlock): NSTimer;

  fireDate(): NSDate;
  setFireDate(fireDate: NSDate): void;
  timeInterval(): NSTimeInterval;
  tolerance(): NSTimeInterval;
  setTolerance(tolerance: NSTimeInterval): void;
  valid(): boolean;
  userInfo(): any;
}

class NSURLAllocator<T extends NSURL> extends NSObjectAllocator<T> {
  initWithScheme_host_path(scheme: NSString | string, host: NSString | string | null, path: NSString | string): T;
  initFileURLWithPath_isDirectory_relativeToURL(path: NSString | string, isDir: boolean, baseURL: NSURL | null): T;
  initFileURLWithPath_relativeToURL(path: NSString | string, baseURL: NSURL | null): T;
  initFileURLWithPath_isDirectory(path: NSString | string, isDir: boolean): T;
  initFileURLWithPath(path: NSString | string): T;
  initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): T;
  initWithString(URLString: NSString | string): T;
  initWithString_relativeToURL(URLString: NSString | string, baseURL: NSURL | null): T;
  initWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): T;
  initAbsoluteURLWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): T;
  initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(bookmarkData: NSData, options: NSURLBookmarkResolutionOptions, relativeURL: NSURL | null, isStale: boolean, error: NSError): T;
}
declare class NSURL extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSURL>(): NSURLAllocator<T>;
  static fileURLWithPath_isDirectory_relativeToURL(path: NSString | string, isDir: boolean, baseURL: NSURL | null): NSURL;
  static fileURLWithPath_relativeToURL(path: NSString | string, baseURL: NSURL | null): NSURL;
  static fileURLWithPath_isDirectory(path: NSString | string, isDir: boolean): NSURL;
  static fileURLWithPath(path: NSString | string): NSURL;
  static fileURLWithFileSystemRepresentation_isDirectory_relativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): NSURL;
  static URLWithString(URLString: NSString | string): NSURL;
  static URLWithString_relativeToURL(URLString: NSString | string, baseURL: NSURL | null): NSURL;
  static URLWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): NSURL;
  static absoluteURLWithDataRepresentation_relativeToURL(data: NSData, baseURL: NSURL | null): NSURL;
  getFileSystemRepresentation_maxLength(buffer: string, maxBufferLength: NSUInteger): boolean;
  checkResourceIsReachableAndReturnError_NS_SWIFT_NOTHROW(error: NSError): boolean;
  isFileReferenceURL(): boolean;
  fileReferenceURL(): NSURL;
  getResourceValue_forKey_error(value: any, key: NSURLResourceKey, error: NSError): boolean;
  resourceValuesForKeys_error(keys: NSArray<any> | any[], error: NSError): NSDictionary<any, any>;
  setResourceValue_forKey_error(value: any | null, key: NSURLResourceKey, error: NSError): boolean;
  setResourceValues_error(keyedValues: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  removeCachedResourceValueForKey(key: NSURLResourceKey): void;
  removeAllCachedResourceValues(): void;
  setTemporaryResourceValue_forKey(value: any | null, key: NSURLResourceKey): void;
  bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error(options: NSURLBookmarkCreationOptions, keys: NSArray<any> | any[] | null, relativeURL: NSURL | null, error: NSError): NSData;
  static URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(bookmarkData: NSData, options: NSURLBookmarkResolutionOptions, relativeURL: NSURL | null, isStale: boolean, error: NSError): NSURL;
  static resourceValuesForKeys_fromBookmarkData(keys: NSArray<any> | any[], bookmarkData: NSData): NSDictionary<any, any>;
  static writeBookmarkData_toURL_options_error(bookmarkData: NSData, bookmarkFileURL: NSURL, options: NSURLBookmarkFileCreationOptions, error: NSError): boolean;
  static bookmarkDataWithContentsOfURL_error(bookmarkFileURL: NSURL, error: NSError): NSData;
  static URLByResolvingAliasFileAtURL_options_error(url: NSURL, options: NSURLBookmarkResolutionOptions, error: NSError): NSURL;
  startAccessingSecurityScopedResource(): boolean;
  stopAccessingSecurityScopedResource(): void;
  getPromisedItemResourceValue_forKey_error(value: any, key: NSURLResourceKey, error: NSError): boolean;
  promisedItemResourceValuesForKeys_error(keys: NSArray<any> | any[], error: NSError): NSDictionary<any, any>;
  checkPromisedItemIsReachableAndReturnError_NS_SWIFT_NOTHROW(error: NSError): boolean;
  static fileURLWithPathComponents(components: NSArray<any> | any[]): NSURL;
  URLByAppendingPathComponent(pathComponent: NSString | string): NSURL;
  URLByAppendingPathComponent_isDirectory(pathComponent: NSString | string, isDirectory: boolean): NSURL;
  URLByAppendingPathExtension(pathExtension: NSString | string): NSURL;
  resourceDataUsingCache(shouldUseCache: boolean): NSData;
  loadResourceDataNotifyingClient_usingCache(client: any, shouldUseCache: boolean): void;
  propertyForKey(propertyKey: NSString | string): any;
  setResourceData(data: NSData): boolean;
  setProperty_forKey(property: any, propertyKey: NSString | string): boolean;
  URLHandleUsingCache(shouldUseCache: boolean): NSURLHandle;
  static URLFromPasteboard(pasteBoard: NSPasteboard): NSURL;
  writeToPasteboard(pasteBoard: NSPasteboard): void;
  URLByStrippingInvisiblePeriod_bc(): NSURL;
  URLByAppendingNameWithSeparators_defaultName(name: NSString | string, defaultName: NSString | string): NSURL;
  hasExtension(extension: NSString | string): boolean;
  withExtension(extension: NSString | string): NSURL;
  URLByResolvingSymlinksAndAliases(): NSURL;
  isEqualToFileURL_bc(otherURL: NSURL): boolean;
  appendingCloudDeeplinkComponentsToArtboard(artboard: SCKArtboard | null): NSURL;
  appendingCloudDeeplinkComponentsInPageToArtboard(artboard: SCKArtboard | null): NSURL;
  appendingCloudAuthentication(authentication: any | null): NSURL;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  dataRepresentation(): NSData;
  absoluteString(): NSString;
  relativeString(): NSString;
  baseURL(): NSURL;
  absoluteURL(): NSURL;
  scheme(): NSString;
  resourceSpecifier(): NSString;
  host(): NSString;
  port(): NSNumber;
  user(): NSString;
  password(): NSString;
  path(): NSString;
  fragment(): NSString;
  parameterString(): NSString;
  query(): NSString;
  relativePath(): NSString;
  hasDirectoryPath(): boolean;
  fileSystemRepresentation(): string;
  fileURL(): boolean;
  standardizedURL(): NSURL;
  filePathURL(): NSURL;
  pathComponents(): NSArray<any>;
  lastPathComponent(): NSString;
  pathExtension(): NSString;
  URLByDeletingLastPathComponent(): NSURL;
  URLByDeletingPathExtension(): NSURL;
  URLByStandardizingPath(): NSURL;
  URLByResolvingSymlinksInPath(): NSURL;
  isInTrash_bc(): boolean;
  isCloudShare(): boolean;
  cloudShareURL(): NSURL;
  cloudShareShortID(): NSString;
  cloudPageSlug(): NSString;
  cloudArtboardSlug(): NSString;
  cloudAPIName(): NSString;
  cloudAPIEnvironment(): SCKAPIEnvironment;
  isExportRequest(): boolean;
  exportRootLayerID(): NSString;
  exportRect(): CGRect;
  exportScale(): CGFloat;
  constrainedExportSize(): CGSize;
  exportImageType(): NSString;
  mirrorCacheKey(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSURLQueryItemAllocator<T extends NSURLQueryItem> extends NSObjectAllocator<T> {
  initWithName_value(name: NSString | string, value: NSString | string | null): T;
}
declare class NSURLQueryItem extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSURLQueryItem>(): NSURLQueryItemAllocator<T>;
  static queryItemWithName_value(name: NSString | string, value: NSString | string | null): NSURLQueryItem;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  name(): NSString;
  value(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSURLComponentsAllocator<T extends NSURLComponents> extends NSObjectAllocator<T> {
  init(): T;
  initWithURL_resolvingAgainstBaseURL(url: NSURL, resolve: boolean): T;
  initWithString(URLString: NSString | string): T;
}
declare class NSURLComponents extends NSObject implements INSCopying {
  alloc<T extends NSURLComponents>(): NSURLComponentsAllocator<T>;
  static componentsWithURL_resolvingAgainstBaseURL(url: NSURL, resolve: boolean): NSURLComponents;
  static componentsWithString(URLString: NSString | string): NSURLComponents;
  URLRelativeToURL(baseURL: NSURL | null): NSURL;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  URL(): NSURL;
  string(): NSString;
  scheme(): NSString;
  setScheme(scheme: NSString | string): void;
  user(): NSString;
  setUser(user: NSString | string): void;
  password(): NSString;
  setPassword(password: NSString | string): void;
  host(): NSString;
  setHost(host: NSString | string): void;
  port(): NSNumber;
  setPort(port: NSNumber | number): void;
  path(): NSString;
  setPath(path: NSString | string): void;
  query(): NSString;
  setQuery(query: NSString | string): void;
  fragment(): NSString;
  setFragment(fragment: NSString | string): void;
  percentEncodedUser(): NSString;
  setPercentEncodedUser(percentEncodedUser: NSString | string): void;
  percentEncodedPassword(): NSString;
  setPercentEncodedPassword(percentEncodedPassword: NSString | string): void;
  percentEncodedHost(): NSString;
  setPercentEncodedHost(percentEncodedHost: NSString | string): void;
  percentEncodedPath(): NSString;
  setPercentEncodedPath(percentEncodedPath: NSString | string): void;
  percentEncodedQuery(): NSString;
  setPercentEncodedQuery(percentEncodedQuery: NSString | string): void;
  percentEncodedFragment(): NSString;
  setPercentEncodedFragment(percentEncodedFragment: NSString | string): void;
  rangeOfScheme(): NSRange;
  rangeOfUser(): NSRange;
  rangeOfPassword(): NSRange;
  rangeOfHost(): NSRange;
  rangeOfPort(): NSRange;
  rangeOfPath(): NSRange;
  rangeOfQuery(): NSRange;
  rangeOfFragment(): NSRange;
  queryItems(): NSArray<any>;
  setQueryItems(queryItems: NSArray<any> | any[]): void;
  percentEncodedQueryItems(): NSArray<any>;
  setPercentEncodedQueryItems(percentEncodedQueryItems: NSArray<any> | any[]): void;
}

class NSFileSecurityAllocator<T extends NSFileSecurity> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSFileSecurity extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSFileSecurity>(): NSFileSecurityAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  static supportsSecureCoding(): boolean;
}

declare type NSURLResourceKey = NSString

declare type NSURLFileResourceType = NSString

declare type NSURLThumbnailDictionaryItem = NSString

declare type NSURLFileProtectionType = NSString

declare type NSURLUbiquitousItemDownloadingStatus = NSString

declare type NSURLUbiquitousSharedItemRole = NSString

declare type NSURLUbiquitousSharedItemPermissions = NSString

declare type NSURLBookmarkFileCreationOptions = NSUInteger

declare enum NSURLBookmarkCreationOptions {
  NSURLBookmarkCreationPreferFileIDResolution,
  NSURLBookmarkCreationMinimalBookmark,
  NSURLBookmarkCreationSuitableForBookmarkFile,
  NSURLBookmarkCreationWithSecurityScope,
  NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess,
}

declare enum NSURLBookmarkResolutionOptions {
  NSURLBookmarkResolutionWithoutUI,
  NSURLBookmarkResolutionWithoutMounting,
  NSURLBookmarkResolutionWithSecurityScope,
}

class NSURLAuthenticationChallengeAllocator<T extends NSURLAuthenticationChallenge> extends NSObjectAllocator<T> {
  initWithProtectionSpace_proposedCredential_previousFailureCount_failureResponse_error_sender(space: NSURLProtectionSpace, credential: NSURLCredential | null, previousFailureCount: NSInteger, response: NSURLResponse | null, error: NSError | null, sender: any): T;
  initWithAuthenticationChallenge_sender(challenge: NSURLAuthenticationChallenge, sender: any): T;
}
declare class NSURLAuthenticationChallenge extends NSObject implements INSSecureCoding {
  alloc<T extends NSURLAuthenticationChallenge>(): NSURLAuthenticationChallengeAllocator<T>;

  protectionSpace(): NSURLProtectionSpace;
  proposedCredential(): NSURLCredential;
  previousFailureCount(): NSInteger;
  failureResponse(): NSURLResponse;
  error(): NSError;
  sender(): any;
  static supportsSecureCoding(): boolean;
}

declare interface INSURLAuthenticationChallengeSender {
  useCredential_forAuthenticationChallenge(credential: NSURLCredential, challenge: NSURLAuthenticationChallenge): void;
  continueWithoutCredentialForAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
  cancelAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
  performDefaultHandlingForAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
  rejectProtectionSpaceAndContinueWithChallenge(challenge: NSURLAuthenticationChallenge): void;
}

class NSCachedURLResponseAllocator<T extends NSCachedURLResponse> extends NSObjectAllocator<T> {
  initWithResponse_data(response: NSURLResponse, data: NSData): T;
  initWithResponse_data_userInfo_storagePolicy(response: NSURLResponse, data: NSData, userInfo: NSDictionary<any, any> | {[key: string]: any} | null, storagePolicy: NSURLCacheStoragePolicy): T;
}
declare class NSCachedURLResponse extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSCachedURLResponse>(): NSCachedURLResponseAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  response(): NSURLResponse;
  data(): NSData;
  userInfo(): NSDictionary<any, any>;
  storagePolicy(): NSURLCacheStoragePolicy;
  static supportsSecureCoding(): boolean;
}

class NSURLCacheAllocator<T extends NSURLCache> extends NSObjectAllocator<T> {
  initWithMemoryCapacity_diskCapacity_diskPath(memoryCapacity: NSUInteger, diskCapacity: NSUInteger, path: NSString | string | null): T;
}
declare class NSURLCache extends NSObject {
  alloc<T extends NSURLCache>(): NSURLCacheAllocator<T>;
  cachedResponseForRequest(request: NSURLRequest): NSCachedURLResponse;
  storeCachedResponse_forRequest(cachedResponse: NSCachedURLResponse, request: NSURLRequest): void;
  removeCachedResponseForRequest(request: NSURLRequest): void;
  removeAllCachedResponses(): void;
  removeCachedResponsesSinceDate(date: NSDate): void;
  storeCachedResponse_forDataTask(cachedResponse: NSCachedURLResponse, dataTask: NSURLSessionDataTask): void;
  getCachedResponseForDataTask_completionHandler(dataTask: NSURLSessionDataTask, completionHandler: Block): void;
  removeCachedResponseForDataTask(dataTask: NSURLSessionDataTask): void;

  static sharedURLCache(): NSURLCache;
  static setSharedURLCache(sharedURLCache: NSURLCache): void;
  memoryCapacity(): NSUInteger;
  setMemoryCapacity(memoryCapacity: NSUInteger): void;
  diskCapacity(): NSUInteger;
  setDiskCapacity(diskCapacity: NSUInteger): void;
  currentMemoryUsage(): NSUInteger;
  currentDiskUsage(): NSUInteger;
}

declare enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed,
  NSURLCacheStorageAllowedInMemoryOnly,
  NSURLCacheStorageNotAllowed,
}

class NSURLConnectionAllocator<T extends NSURLConnection> extends NSObjectAllocator<T> {
  initWithRequest_delegate_startImmediately(request: NSURLRequest, delegate: any | null, startImmediately: boolean): T;
  initWithRequest_delegate___WATCHOS_PROHIBITED(request: NSURLRequest, delegate: any | null): T;
}
declare class NSURLConnection extends NSObject {
  alloc<T extends NSURLConnection>(): NSURLConnectionAllocator<T>;
  static connectionWithRequest_delegate___WATCHOS_PROHIBITED(request: NSURLRequest, delegate: any | null): NSURLConnection;
  start(): void;
  cancel(): void;
  scheduleInRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  unscheduleFromRunLoop_forMode(aRunLoop: NSRunLoop, mode: NSRunLoopMode): void;
  setDelegateQueue(queue: NSOperationQueue | null): void;
  static canHandleRequest(request: NSURLRequest): boolean;
  static sendSynchronousRequest_returningResponse_error___WATCHOS_PROHIBITED(request: NSURLRequest, response: NSURLResponse, error: NSError): NSData;
  static sendAsynchronousRequest_queue_completionHandler___WATCHOS_PROHIBITED(request: NSURLRequest, queue: NSOperationQueue, handler: Block): void;

  originalRequest(): NSURLRequest;
  currentRequest(): NSURLRequest;
}

declare interface INSURLConnectionDelegate {
  connection_didFailWithError(connection: NSURLConnection, error: NSError): void;
  connectionShouldUseCredentialStorage(connection: NSURLConnection): boolean;
  connection_willSendRequestForAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_canAuthenticateAgainstProtectionSpace(connection: NSURLConnection, protectionSpace: NSURLProtectionSpace): boolean;
  connection_didReceiveAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_didCancelAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
}

declare interface INSURLConnectionDataDelegate {
  connection_willSendRequest_redirectResponse(connection: NSURLConnection, request: NSURLRequest, response: NSURLResponse | null): NSURLRequest;
  connection_didReceiveResponse(connection: NSURLConnection, response: NSURLResponse): void;
  connection_didReceiveData(connection: NSURLConnection, data: NSData): void;
  connection_needNewBodyStream(connection: NSURLConnection, request: NSURLRequest): NSInputStream;
  connection_didSendBodyData_totalBytesWritten_totalBytesExpectedToWrite(connection: NSURLConnection, bytesWritten: NSInteger, totalBytesWritten: NSInteger, totalBytesExpectedToWrite: NSInteger): void;
  connection_willCacheResponse(connection: NSURLConnection, cachedResponse: NSCachedURLResponse): NSCachedURLResponse;
  connectionDidFinishLoading(connection: NSURLConnection): void;
}

declare interface INSURLConnectionDownloadDelegate {
  connection_didWriteData_totalBytesWritten_expectedTotalBytes(connection: NSURLConnection, bytesWritten: number, totalBytesWritten: number, expectedTotalBytes: number): void;
  connectionDidResumeDownloading_totalBytesWritten_expectedTotalBytes(connection: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
  connectionDidFinishDownloading_destinationURL(connection: NSURLConnection, destinationURL: NSURL): void;
}

class NSURLCredentialAllocator<T extends NSURLCredential> extends NSObjectAllocator<T> {
  initWithUser_password_persistence(user: NSString | string, password: NSString | string, persistence: NSURLCredentialPersistence): T;
  initWithIdentity_certificates_persistence(identity: SecIdentityRef, certArray: NSArray<any> | any[] | null, persistence: NSURLCredentialPersistence): T;
  initWithTrust(trust: SecTrustRef): T;
}
declare class NSURLCredential extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSURLCredential>(): NSURLCredentialAllocator<T>;
  static credentialWithUser_password_persistence(user: NSString | string, password: NSString | string, persistence: NSURLCredentialPersistence): NSURLCredential;
  static credentialWithIdentity_certificates_persistence(identity: SecIdentityRef, certArray: NSArray<any> | any[] | null, persistence: NSURLCredentialPersistence): NSURLCredential;
  static credentialForTrust(trust: SecTrustRef): NSURLCredential;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  persistence(): NSURLCredentialPersistence;
  user(): NSString;
  password(): NSString;
  hasPassword(): boolean;
  identity(): SecIdentityRef;
  certificates(): NSArray<any>;
  static supportsSecureCoding(): boolean;
}

declare enum NSURLCredentialPersistence {
  NSURLCredentialPersistenceNone,
  NSURLCredentialPersistenceForSession,
  NSURLCredentialPersistencePermanent,
  NSURLCredentialPersistenceSynchronizable,
}

class NSURLCredentialStorageAllocator<T extends NSURLCredentialStorage> extends NSObjectAllocator<T> {}
declare class NSURLCredentialStorage extends NSObject {
  alloc<T extends NSURLCredentialStorage>(): NSURLCredentialStorageAllocator<T>;
  credentialsForProtectionSpace(space: NSURLProtectionSpace): NSDictionary<any, any>;
  setCredential_forProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
  removeCredential_forProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
  removeCredential_forProtectionSpace_options(credential: NSURLCredential, space: NSURLProtectionSpace, options: NSDictionary<any, any> | {[key: string]: any} | null): void;
  defaultCredentialForProtectionSpace(space: NSURLProtectionSpace): NSURLCredential;
  setDefaultCredential_forProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
  getCredentialsForProtectionSpace_task_completionHandler(protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: Block): void;
  setCredential_forProtectionSpace_task(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;
  removeCredential_forProtectionSpace_options_task(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, options: NSDictionary<any, any> | {[key: string]: any} | null, task: NSURLSessionTask): void;
  getDefaultCredentialForProtectionSpace_task_completionHandler(space: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: Block): void;
  setDefaultCredential_forProtectionSpace_task(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;

  static sharedCredentialStorage(): NSURLCredentialStorage;
  allCredentials(): NSDictionary<any, any>;
}

class NSURLDownloadAllocator<T extends NSURLDownload> extends NSObjectAllocator<T> {
  initWithRequest_delegate(request: NSURLRequest, delegate: any | null): T;
  initWithResumeData_delegate_path(resumeData: NSData, delegate: any | null, path: NSString | string): T;
}
declare class NSURLDownload extends NSObject {
  alloc<T extends NSURLDownload>(): NSURLDownloadAllocator<T>;
  static canResumeDownloadDecodedWithEncodingMIMEType(MIMEType: NSString | string): boolean;
  cancel(): void;
  setDestination_allowOverwrite(path: NSString | string, allowOverwrite: boolean): void;

  request(): NSURLRequest;
  resumeData(): NSData;
  deletesFileUponFailure(): boolean;
  setDeletesFileUponFailure(deletesFileUponFailure: boolean): void;
}

declare interface INSURLDownloadDelegate {
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
}

class NSURLHandleAllocator<T extends NSURLHandle> {}
declare class NSURLHandle {
  alloc<T extends NSURLHandle>(): NSURLHandleAllocator<T>;
  static registerURLHandleClass(anURLHandleSubclass: any): void;
  static URLHandleClassForURL(anURL: NSURL): any;
  status(): NSURLHandleStatus;
  failureReason(): NSString;
  addClient(client: any): void;
  removeClient(client: any): void;
  loadInBackground(): void;
  cancelLoadInBackground(): void;
  resourceData(): NSData;
  availableResourceData(): NSData;
  expectedResourceDataSize(): number;
  flushCachedData(): void;
  backgroundLoadDidFailWithReason(reason: NSString | string): void;
  didLoadBytes_loadComplete(newBytes: NSData, yorn: boolean): void;
  static canInitWithURL(anURL: NSURL): boolean;
  static cachedHandleForURL(anURL: NSURL): NSURLHandle;
  propertyForKey(propertyKey: NSString | string): any;
  propertyForKeyIfAvailable(propertyKey: NSString | string): any;
  writeProperty_forKey(propertyValue: any, propertyKey: NSString | string): boolean;
  writeData(data: NSData): boolean;
  loadInForeground(): NSData;
  beginLoadInBackground(): void;
  endLoadInBackground(): void;
}

declare interface INSURLHandleClient {
  URLHandle_resourceDataDidBecomeAvailable(sender: NSURLHandle, newBytes: NSData): void;
  URLHandleResourceDidBeginLoading(sender: NSURLHandle): void;
  URLHandleResourceDidFinishLoading(sender: NSURLHandle): void;
  URLHandleResourceDidCancelLoading(sender: NSURLHandle): void;
  URLHandle_resourceDidFailLoadingWithReason(sender: NSURLHandle, reason: NSString | string): void;
}

declare enum NSURLHandleStatus {
  NSURLHandleNotLoaded = 0,
  NSURLHandleLoadSucceeded,
  NSURLHandleLoadInProgress,
  NSURLHandleLoadFailed,
}

class NSURLProtectionSpaceAllocator<T extends NSURLProtectionSpace> extends NSObjectAllocator<T> {
  initWithHost_port_protocol_realm_authenticationMethod(host: NSString | string, port: NSInteger, protocol: NSString | string | null, realm: NSString | string | null, authenticationMethod: NSString | string | null): T;
  initWithProxyHost_port_type_realm_authenticationMethod(host: NSString | string, port: NSInteger, type: NSString | string | null, realm: NSString | string | null, authenticationMethod: NSString | string | null): T;
}
declare class NSURLProtectionSpace extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSURLProtectionSpace>(): NSURLProtectionSpaceAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  realm(): NSString;
  receivesCredentialSecurely(): boolean;
  isProxy(): boolean;
  host(): NSString;
  port(): NSInteger;
  proxyType(): NSString;
  protocol(): NSString;
  authenticationMethod(): NSString;
  distinguishedNames(): NSArray<any>;
  serverTrust(): SecTrustRef;
  static supportsSecureCoding(): boolean;
}

class NSURLProtocolAllocator<T extends NSURLProtocol> extends NSObjectAllocator<T> {
  initWithRequest_cachedResponse_client(request: NSURLRequest, cachedResponse: NSCachedURLResponse | null, client: any | null): T;
  initWithTask_cachedResponse_client(task: NSURLSessionTask, cachedResponse: NSCachedURLResponse | null, client: any | null): T;
}
declare class NSURLProtocol extends NSObject {
  alloc<T extends NSURLProtocol>(): NSURLProtocolAllocator<T>;
  static canInitWithRequest(request: NSURLRequest): boolean;
  static canonicalRequestForRequest(request: NSURLRequest): NSURLRequest;
  static requestIsCacheEquivalent_toRequest(a: NSURLRequest, b: NSURLRequest): boolean;
  startLoading(): void;
  stopLoading(): void;
  static propertyForKey_inRequest(key: NSString | string, request: NSURLRequest): any;
  static setProperty_forKey_inRequest(value: any, key: NSString | string, request: NSMutableURLRequest): void;
  static removePropertyForKey_inRequest(key: NSString | string, request: NSMutableURLRequest): void;
  static registerClass(protocolClass: any): boolean;
  static unregisterClass(protocolClass: any): void;
  static canInitWithTask(task: NSURLSessionTask): boolean;

  client(): any;
  request(): NSURLRequest;
  cachedResponse(): NSCachedURLResponse;
  task(): NSURLSessionTask;
}

declare interface INSURLProtocolClient {
  URLProtocol_wasRedirectedToRequest_redirectResponse(protocol: NSURLProtocol, request: NSURLRequest, redirectResponse: NSURLResponse): void;
  URLProtocol_cachedResponseIsValid(protocol: NSURLProtocol, cachedResponse: NSCachedURLResponse): void;
  URLProtocol_didReceiveResponse_cacheStoragePolicy(protocol: NSURLProtocol, response: NSURLResponse, policy: NSURLCacheStoragePolicy): void;
  URLProtocol_didLoadData(protocol: NSURLProtocol, data: NSData): void;
  URLProtocolDidFinishLoading(protocol: NSURLProtocol): void;
  URLProtocol_didFailWithError(protocol: NSURLProtocol, error: NSError): void;
  URLProtocol_didReceiveAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
  URLProtocol_didCancelAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
}

class NSURLRequestAllocator<T extends NSURLRequest> extends NSObjectAllocator<T> {
  initWithURL(URL: NSURL): T;
  initWithURL_cachePolicy_timeoutInterval(URL: NSURL, cachePolicy: NSURLRequestCachePolicy, timeoutInterval: NSTimeInterval): T;
}
declare class NSURLRequest extends NSObject implements INSSecureCoding, INSCopying, INSMutableCopying {
  alloc<T extends NSURLRequest>(): NSURLRequestAllocator<T>;
  static requestWithURL(URL: NSURL): NSURLRequest;
  static requestWithURL_cachePolicy_timeoutInterval(URL: NSURL, cachePolicy: NSURLRequestCachePolicy, timeoutInterval: NSTimeInterval): NSURLRequest;
  valueForHTTPHeaderField(field: NSString | string): NSString;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  static supportsSecureCoding(): boolean;
  URL(): NSURL;
  cachePolicy(): NSURLRequestCachePolicy;
  timeoutInterval(): NSTimeInterval;
  mainDocumentURL(): NSURL;
  networkServiceType(): NSURLRequestNetworkServiceType;
  allowsCellularAccess(): boolean;
  HTTPMethod(): NSString;
  allHTTPHeaderFields(): NSDictionary<any, any>;
  HTTPBody(): NSData;
  HTTPBodyStream(): NSInputStream;
  HTTPShouldHandleCookies(): boolean;
  HTTPShouldUsePipelining(): boolean;
}

class NSMutableURLRequestAllocator<T extends NSMutableURLRequest> extends NSURLRequestAllocator<T> {}
declare class NSMutableURLRequest extends NSURLRequest {
  alloc<T extends NSMutableURLRequest>(): NSMutableURLRequestAllocator<T>;
  setValue_forHTTPHeaderField(value: NSString | string | null, field: NSString | string): void;
  addValue_forHTTPHeaderField(value: NSString | string, field: NSString | string): void;

  URL(): NSURL;
  setURL(URL: NSURL): void;
  cachePolicy(): NSURLRequestCachePolicy;
  setCachePolicy(cachePolicy: NSURLRequestCachePolicy): void;
  timeoutInterval(): NSTimeInterval;
  setTimeoutInterval(timeoutInterval: NSTimeInterval): void;
  mainDocumentURL(): NSURL;
  setMainDocumentURL(mainDocumentURL: NSURL): void;
  networkServiceType(): NSURLRequestNetworkServiceType;
  setNetworkServiceType(networkServiceType: NSURLRequestNetworkServiceType): void;
  allowsCellularAccess(): boolean;
  setAllowsCellularAccess(allowsCellularAccess: boolean): void;
  HTTPMethod(): NSString;
  setHTTPMethod(HTTPMethod: NSString | string): void;
  allHTTPHeaderFields(): NSDictionary<any, any>;
  setAllHTTPHeaderFields(allHTTPHeaderFields: NSDictionary<any, any> | {[key: string]: any}): void;
  HTTPBody(): NSData;
  setHTTPBody(HTTPBody: NSData): void;
  HTTPBodyStream(): NSInputStream;
  setHTTPBodyStream(HTTPBodyStream: NSInputStream): void;
  HTTPShouldHandleCookies(): boolean;
  setHTTPShouldHandleCookies(HTTPShouldHandleCookies: boolean): void;
  HTTPShouldUsePipelining(): boolean;
  setHTTPShouldUsePipelining(HTTPShouldUsePipelining: boolean): void;
}

declare enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy = 0,
  NSURLRequestReloadIgnoringLocalCacheData = 1,
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4,
  NSURLRequestReloadIgnoringCacheData,
  NSURLRequestReturnCacheDataElseLoad = 2,
  NSURLRequestReturnCacheDataDontLoad = 3,
  NSURLRequestReloadRevalidatingCacheData = 5,
}

declare enum NSURLRequestNetworkServiceType {
  NSURLNetworkServiceTypeDefault = 0,
  NSURLNetworkServiceTypeVoIP = 1,
  NSURLNetworkServiceTypeVideo = 2,
  NSURLNetworkServiceTypeBackground = 3,
  NSURLNetworkServiceTypeVoice = 4,
  NSURLNetworkServiceTypeCallSignaling = 11,
}

class NSURLResponseAllocator<T extends NSURLResponse> extends NSObjectAllocator<T> {
  initWithURL_MIMEType_expectedContentLength_textEncodingName(URL: NSURL, MIMEType: NSString | string | null, length: NSInteger, name: NSString | string | null): T;
}
declare class NSURLResponse extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends NSURLResponse>(): NSURLResponseAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  URL(): NSURL;
  MIMEType(): NSString;
  expectedContentLength(): number;
  textEncodingName(): NSString;
  suggestedFilename(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSHTTPURLResponseAllocator<T extends NSHTTPURLResponse> extends NSURLResponseAllocator<T> {
  initWithURL_statusCode_HTTPVersion_headerFields(url: NSURL, statusCode: NSInteger, HTTPVersion: NSString | string | null, headerFields: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class NSHTTPURLResponse extends NSURLResponse {
  alloc<T extends NSHTTPURLResponse>(): NSHTTPURLResponseAllocator<T>;
  static localizedStringForStatusCode(statusCode: NSInteger): NSString;

  statusCode(): NSInteger;
  allHeaderFields(): NSDictionary<any, any>;
}

class NSURLSessionAllocator<T extends NSURLSession> extends NSObjectAllocator<T> {}
declare class NSURLSession extends NSObject {
  alloc<T extends NSURLSession>(): NSURLSessionAllocator<T>;
  static sessionWithConfiguration(configuration: NSURLSessionConfiguration): NSURLSession;
  static sessionWithConfiguration_delegate_delegateQueue(configuration: NSURLSessionConfiguration, delegate: any | null, queue: NSOperationQueue | null): NSURLSession;
  finishTasksAndInvalidate(): void;
  invalidateAndCancel(): void;
  resetWithCompletionHandler(completionHandler: Block): void;
  flushWithCompletionHandler(completionHandler: Block): void;
  getTasksWithCompletionHandler(completionHandler: Block): void;
  getAllTasksWithCompletionHandler(completionHandler: Block): void;
  dataTaskWithRequest(request: NSURLRequest): NSURLSessionDataTask;
  dataTaskWithURL(url: NSURL): NSURLSessionDataTask;
  uploadTaskWithRequest_fromFile(request: NSURLRequest, fileURL: NSURL): NSURLSessionUploadTask;
  uploadTaskWithRequest_fromData(request: NSURLRequest, bodyData: NSData): NSURLSessionUploadTask;
  uploadTaskWithStreamedRequest(request: NSURLRequest): NSURLSessionUploadTask;
  downloadTaskWithRequest(request: NSURLRequest): NSURLSessionDownloadTask;
  downloadTaskWithURL(url: NSURL): NSURLSessionDownloadTask;
  downloadTaskWithResumeData(resumeData: NSData): NSURLSessionDownloadTask;
  streamTaskWithHostName_port(hostname: NSString | string, port: NSInteger): NSURLSessionStreamTask;
  streamTaskWithNetService___WATCHOS_PROHIBITED(service: NSNetService): NSURLSessionStreamTask;
  dataTaskWithRequest_completionHandler(request: NSURLRequest, completionHandler: Block): NSURLSessionDataTask;
  dataTaskWithURL_completionHandler(url: NSURL, completionHandler: Block): NSURLSessionDataTask;
  uploadTaskWithRequest_fromFile_completionHandler(request: NSURLRequest, fileURL: NSURL, completionHandler: Block): NSURLSessionUploadTask;
  uploadTaskWithRequest_fromData_completionHandler(request: NSURLRequest, bodyData: NSData | null, completionHandler: Block): NSURLSessionUploadTask;
  downloadTaskWithRequest_completionHandler(request: NSURLRequest, completionHandler: Block): NSURLSessionDownloadTask;
  downloadTaskWithURL_completionHandler(url: NSURL, completionHandler: Block): NSURLSessionDownloadTask;
  downloadTaskWithResumeData_completionHandler(resumeData: NSData, completionHandler: Block): NSURLSessionDownloadTask;

  static sharedSession(): NSURLSession;
  delegateQueue(): NSOperationQueue;
  delegate(): any;
  configuration(): NSURLSessionConfiguration;
  sessionDescription(): NSString;
  setSessionDescription(sessionDescription: NSString | string): void;
}

class NSURLSessionTaskAllocator<T extends NSURLSessionTask> extends NSObjectAllocator<T> {}
declare class NSURLSessionTask extends NSObject implements INSCopying, INSProgressReporting {
  alloc<T extends NSURLSessionTask>(): NSURLSessionTaskAllocator<T>;
  cancel(): void;
  suspend(): void;
  resume(): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  taskIdentifier(): NSUInteger;
  originalRequest(): NSURLRequest;
  currentRequest(): NSURLRequest;
  response(): NSURLResponse;
  progress(): NSProgress;
  earliestBeginDate(): NSDate;
  setEarliestBeginDate(earliestBeginDate: NSDate): void;
  countOfBytesClientExpectsToSend(): number;
  setCountOfBytesClientExpectsToSend(countOfBytesClientExpectsToSend: number): void;
  countOfBytesClientExpectsToReceive(): number;
  setCountOfBytesClientExpectsToReceive(countOfBytesClientExpectsToReceive: number): void;
  countOfBytesReceived(): number;
  countOfBytesSent(): number;
  countOfBytesExpectedToSend(): number;
  countOfBytesExpectedToReceive(): number;
  taskDescription(): NSString;
  setTaskDescription(taskDescription: NSString | string): void;
  state(): NSURLSessionTaskState;
  error(): NSError;
  priority(): number;
  setPriority(priority: number): void;
}

class NSURLSessionDataTaskAllocator<T extends NSURLSessionDataTask> extends NSURLSessionTaskAllocator<T> {}
declare class NSURLSessionDataTask extends NSURLSessionTask {
  alloc<T extends NSURLSessionDataTask>(): NSURLSessionDataTaskAllocator<T>;
}

class NSURLSessionUploadTaskAllocator<T extends NSURLSessionUploadTask> extends NSURLSessionDataTaskAllocator<T> {}
declare class NSURLSessionUploadTask extends NSURLSessionDataTask {
  alloc<T extends NSURLSessionUploadTask>(): NSURLSessionUploadTaskAllocator<T>;
}

class NSURLSessionDownloadTaskAllocator<T extends NSURLSessionDownloadTask> extends NSURLSessionTaskAllocator<T> {}
declare class NSURLSessionDownloadTask extends NSURLSessionTask {
  alloc<T extends NSURLSessionDownloadTask>(): NSURLSessionDownloadTaskAllocator<T>;
  cancelByProducingResumeData(completionHandler: Block): void;
}

class NSURLSessionStreamTaskAllocator<T extends NSURLSessionStreamTask> extends NSURLSessionTaskAllocator<T> {}
declare class NSURLSessionStreamTask extends NSURLSessionTask {
  alloc<T extends NSURLSessionStreamTask>(): NSURLSessionStreamTaskAllocator<T>;
  readDataOfMinLength_maxLength_timeout_completionHandler(minBytes: NSUInteger, maxBytes: NSUInteger, timeout: NSTimeInterval, completionHandler: Block): void;
  writeData_timeout_completionHandler(data: NSData, timeout: NSTimeInterval, completionHandler: Block): void;
  captureStreams(): void;
  closeWrite(): void;
  closeRead(): void;
  startSecureConnection(): void;
  stopSecureConnection(): void;
}

class NSURLSessionConfigurationAllocator<T extends NSURLSessionConfiguration> extends NSObjectAllocator<T> {}
declare class NSURLSessionConfiguration extends NSObject implements INSCopying {
  alloc<T extends NSURLSessionConfiguration>(): NSURLSessionConfigurationAllocator<T>;
  static backgroundSessionConfigurationWithIdentifier(identifier: NSString | string): NSURLSessionConfiguration;
  static backgroundSessionConfiguration(identifier: NSString | string): NSURLSessionConfiguration;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  static defaultSessionConfiguration(): NSURLSessionConfiguration;
  static ephemeralSessionConfiguration(): NSURLSessionConfiguration;
  identifier(): NSString;
  requestCachePolicy(): NSURLRequestCachePolicy;
  setRequestCachePolicy(requestCachePolicy: NSURLRequestCachePolicy): void;
  timeoutIntervalForRequest(): NSTimeInterval;
  setTimeoutIntervalForRequest(timeoutIntervalForRequest: NSTimeInterval): void;
  timeoutIntervalForResource(): NSTimeInterval;
  setTimeoutIntervalForResource(timeoutIntervalForResource: NSTimeInterval): void;
  networkServiceType(): NSURLRequestNetworkServiceType;
  setNetworkServiceType(networkServiceType: NSURLRequestNetworkServiceType): void;
  allowsCellularAccess(): boolean;
  setAllowsCellularAccess(allowsCellularAccess: boolean): void;
  waitsForConnectivity(): boolean;
  setWaitsForConnectivity(waitsForConnectivity: boolean): void;
  discretionary(): boolean;
  setDiscretionary(discretionary: boolean): void;
  sharedContainerIdentifier(): NSString;
  setSharedContainerIdentifier(sharedContainerIdentifier: NSString | string): void;
  sessionSendsLaunchEvents(): boolean;
  setSessionSendsLaunchEvents(sessionSendsLaunchEvents: boolean): void;
  connectionProxyDictionary(): NSDictionary<any, any>;
  setConnectionProxyDictionary(connectionProxyDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  TLSMinimumSupportedProtocol(): SSLProtocol;
  setTLSMinimumSupportedProtocol(TLSMinimumSupportedProtocol: SSLProtocol): void;
  TLSMaximumSupportedProtocol(): SSLProtocol;
  setTLSMaximumSupportedProtocol(TLSMaximumSupportedProtocol: SSLProtocol): void;
  HTTPShouldUsePipelining(): boolean;
  setHTTPShouldUsePipelining(HTTPShouldUsePipelining: boolean): void;
  HTTPShouldSetCookies(): boolean;
  setHTTPShouldSetCookies(HTTPShouldSetCookies: boolean): void;
  HTTPCookieAcceptPolicy(): NSHTTPCookieAcceptPolicy;
  setHTTPCookieAcceptPolicy(HTTPCookieAcceptPolicy: NSHTTPCookieAcceptPolicy): void;
  HTTPAdditionalHeaders(): NSDictionary<any, any>;
  setHTTPAdditionalHeaders(HTTPAdditionalHeaders: NSDictionary<any, any> | {[key: string]: any}): void;
  HTTPMaximumConnectionsPerHost(): NSInteger;
  setHTTPMaximumConnectionsPerHost(HTTPMaximumConnectionsPerHost: NSInteger): void;
  HTTPCookieStorage(): NSHTTPCookieStorage;
  setHTTPCookieStorage(HTTPCookieStorage: NSHTTPCookieStorage): void;
  URLCredentialStorage(): NSURLCredentialStorage;
  setURLCredentialStorage(URLCredentialStorage: NSURLCredentialStorage): void;
  URLCache(): NSURLCache;
  setURLCache(URLCache: NSURLCache): void;
  shouldUseExtendedBackgroundIdleMode(): boolean;
  setShouldUseExtendedBackgroundIdleMode(shouldUseExtendedBackgroundIdleMode: boolean): void;
  protocolClasses(): NSArray<any>;
  setProtocolClasses(protocolClasses: NSArray<any> | any[]): void;
  multipathServiceType(): NSURLSessionMultipathServiceType;
  setMultipathServiceType(multipathServiceType: NSURLSessionMultipathServiceType): void;
}

class NSURLSessionTaskTransactionMetricsAllocator<T extends NSURLSessionTaskTransactionMetrics> extends NSObjectAllocator<T> {}
declare class NSURLSessionTaskTransactionMetrics extends NSObject {
  alloc<T extends NSURLSessionTaskTransactionMetrics>(): NSURLSessionTaskTransactionMetricsAllocator<T>;

  request(): NSURLRequest;
  response(): NSURLResponse;
  fetchStartDate(): NSDate;
  domainLookupStartDate(): NSDate;
  domainLookupEndDate(): NSDate;
  connectStartDate(): NSDate;
  secureConnectionStartDate(): NSDate;
  secureConnectionEndDate(): NSDate;
  connectEndDate(): NSDate;
  requestStartDate(): NSDate;
  requestEndDate(): NSDate;
  responseStartDate(): NSDate;
  responseEndDate(): NSDate;
  networkProtocolName(): NSString;
  proxyConnection(): boolean;
  reusedConnection(): boolean;
  resourceFetchType(): NSURLSessionTaskMetricsResourceFetchType;
}

class NSURLSessionTaskMetricsAllocator<T extends NSURLSessionTaskMetrics> extends NSObjectAllocator<T> {}
declare class NSURLSessionTaskMetrics extends NSObject {
  alloc<T extends NSURLSessionTaskMetrics>(): NSURLSessionTaskMetricsAllocator<T>;

  transactionMetrics(): NSArray<any>;
  taskInterval(): NSDateInterval;
  redirectCount(): NSUInteger;
}

declare interface INSURLSessionDelegate {
  URLSession_didBecomeInvalidWithError(session: NSURLSession, error: NSError | null): void;
  URLSession_didReceiveChallenge_completionHandler(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession): void;
}

declare interface INSURLSessionTaskDelegate {
  URLSession_task_willBeginDelayedRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: Block): void;
  URLSession_taskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;
  URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: Block): void;
  URLSession_task_didReceiveChallenge_completionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSession_task_needNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: Block): void;
  URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  URLSession_task_didFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;
  URLSession_task_didCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;
}

declare interface INSURLSessionDataDelegate {
  URLSession_dataTask_didReceiveResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: Block): void;
  URLSession_dataTask_didBecomeDownloadTask(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;
  URLSession_dataTask_didBecomeStreamTask(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): void;
  URLSession_dataTask_didReceiveData(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;
  URLSession_dataTask_willCacheResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: Block): void;
}

declare interface INSURLSessionDownloadDelegate {
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
}

declare interface INSURLSessionStreamDelegate {
  URLSession_readClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;
  URLSession_writeClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;
  URLSession_betterRouteDiscoveredForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;
  URLSession_streamTask_didBecomeInputStream_outputStream(session: NSURLSession, streamTask: NSURLSessionStreamTask, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

declare enum NSURLSessionTaskState {
  NSURLSessionTaskStateRunning = 0,
  NSURLSessionTaskStateSuspended = 1,
  NSURLSessionTaskStateCanceling = 2,
  NSURLSessionTaskStateCompleted = 3,
}

declare enum NSURLSessionMultipathServiceType {
  NSURLSessionMultipathServiceTypeNone = 0,
  NSURLSessionMultipathServiceTypeHandover = 1,
  NSURLSessionMultipathServiceTypeInteractive = 2,
  NSURLSessionMultipathServiceTypeAggregate = 3,
}

declare enum NSURLSessionDelayedRequestDisposition {
  NSURLSessionDelayedRequestContinueLoading = 0,
  NSURLSessionDelayedRequestUseNewRequest = 1,
  NSURLSessionDelayedRequestCancel = 2,
}

declare enum NSURLSessionAuthChallengeDisposition {
  NSURLSessionAuthChallengeUseCredential = 0,
  NSURLSessionAuthChallengePerformDefaultHandling = 1,
  NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2,
  NSURLSessionAuthChallengeRejectProtectionSpace = 3,
}

declare enum NSURLSessionResponseDisposition {
  NSURLSessionResponseCancel = 0,
  NSURLSessionResponseAllow = 1,
  NSURLSessionResponseBecomeDownload = 2,
  NSURLSessionResponseBecomeStream = 3,
}

declare enum NSURLSessionTaskMetricsResourceFetchType {
  NSURLSessionTaskMetricsResourceFetchTypeUnknown,
  NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad,
  NSURLSessionTaskMetricsResourceFetchTypeServerPush,
  NSURLSessionTaskMetricsResourceFetchTypeLocalCache,
}

class NSUUIDAllocator<T extends NSUUID> extends NSObjectAllocator<T> {
  init(): T;
  initWithUUIDString(string: NSString | string): T;
  initWithUUIDBytes(bytes: uuid_t): T;
}
declare class NSUUID extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSUUID>(): NSUUIDAllocator<T>;
  static UUID(): NSUUID;
  getUUIDBytes(uuid: uuid_t): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  UUIDString(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSUbiquitousKeyValueStoreAllocator<T extends NSUbiquitousKeyValueStore> extends NSObjectAllocator<T> {}
declare class NSUbiquitousKeyValueStore extends NSObject {
  alloc<T extends NSUbiquitousKeyValueStore>(): NSUbiquitousKeyValueStoreAllocator<T>;
  objectForKey(aKey: NSString | string): any;
  setObject_forKey(anObject: any | null, aKey: NSString | string): void;
  removeObjectForKey(aKey: NSString | string): void;
  stringForKey(aKey: NSString | string): NSString;
  arrayForKey(aKey: NSString | string): NSArray<any>;
  dictionaryForKey(aKey: NSString | string): NSDictionary<any, any>;
  dataForKey(aKey: NSString | string): NSData;
  longLongForKey(aKey: NSString | string): number;
  doubleForKey(aKey: NSString | string): number;
  boolForKey(aKey: NSString | string): boolean;
  setString_forKey(aString: NSString | string | null, aKey: NSString | string): void;
  setData_forKey(aData: NSData | null, aKey: NSString | string): void;
  setArray_forKey(anArray: NSArray<any> | any[] | null, aKey: NSString | string): void;
  setDictionary_forKey(aDictionary: NSDictionary<any, any> | {[key: string]: any} | null, aKey: NSString | string): void;
  setLongLong_forKey(value: number, aKey: NSString | string): void;
  setDouble_forKey(value: number, aKey: NSString | string): void;
  setBool_forKey(value: boolean, aKey: NSString | string): void;
  synchronize(): boolean;

  static defaultStore(): NSUbiquitousKeyValueStore;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class NSUndoManagerAllocator<T extends NSUndoManager> extends NSObjectAllocator<T> {}
declare class NSUndoManager extends NSObject {
  alloc<T extends NSUndoManager>(): NSUndoManagerAllocator<T>;
  beginUndoGrouping(): void;
  endUndoGrouping(): void;
  disableUndoRegistration(): void;
  enableUndoRegistration(): void;
  undo(): void;
  redo(): void;
  undoNestedGroup(): void;
  removeAllActions(): void;
  removeAllActionsWithTarget(target: any): void;
  registerUndoWithTarget_selector_object(target: any, selector: string, anObject: any | null): void;
  prepareWithInvocationTarget(target: any): any;
  registerUndoWithTarget_handler(target: any, undoHandler: Block): void;
  setActionIsDiscardable(discardable: boolean): void;
  setActionName(actionName: NSString | string): void;
  undoMenuTitleForUndoActionName(actionName: NSString | string): NSString;
  redoMenuTitleForUndoActionName(actionName: NSString | string): NSString;
  setActionName_sender(actionName: NSString | string, senderID: NSString | string): void;

  groupingLevel(): NSInteger;
  undoRegistrationEnabled(): boolean;
  groupsByEvent(): boolean;
  setGroupsByEvent(groupsByEvent: boolean): void;
  levelsOfUndo(): NSUInteger;
  setLevelsOfUndo(levelsOfUndo: NSUInteger): void;
  runLoopModes(): NSArray<any>;
  setRunLoopModes(runLoopModes: NSArray<any> | any[]): void;
  canUndo(): boolean;
  canRedo(): boolean;
  undoing(): boolean;
  redoing(): boolean;
  undoActionIsDiscardable(): boolean;
  redoActionIsDiscardable(): boolean;
  undoActionName(): NSString;
  redoActionName(): NSString;
  undoMenuItemTitle(): NSString;
  redoMenuItemTitle(): NSString;
}

class NSUnitConverterAllocator<T extends NSUnitConverter> extends NSObjectAllocator<T> {}
declare class NSUnitConverter extends NSObject {
  alloc<T extends NSUnitConverter>(): NSUnitConverterAllocator<T>;
  baseUnitValueFromValue(value: number): number;
  valueFromBaseUnitValue(baseUnitValue: number): number;
}

class NSUnitConverterLinearAllocator<T extends NSUnitConverterLinear> extends NSUnitConverterAllocator<T> {
  initWithCoefficient(coefficient: number): T;
  initWithCoefficient_constant(coefficient: number, constant: number): T;
}
declare class NSUnitConverterLinear extends NSUnitConverter implements INSSecureCoding {
  alloc<T extends NSUnitConverterLinear>(): NSUnitConverterLinearAllocator<T>;

  coefficient(): number;
  constant(): number;
  static supportsSecureCoding(): boolean;
}

class NSUnitAllocator<T extends NSUnit> extends NSObjectAllocator<T> {
  initWithSymbol(symbol: NSString | string): T;
}
declare class NSUnit extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSUnit>(): NSUnitAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  symbol(): NSString;
  static supportsSecureCoding(): boolean;
}

class NSDimensionAllocator<T extends NSDimension> extends NSUnitAllocator<T> {
  initWithSymbol_converter(symbol: NSString | string, converter: NSUnitConverter): T;
}
declare class NSDimension extends NSUnit implements INSSecureCoding {
  alloc<T extends NSDimension>(): NSDimensionAllocator<T>;
  static baseUnit(): NSDimension;

  converter(): NSUnitConverter;
  static supportsSecureCoding(): boolean;
}

class NSUnitAccelerationAllocator<T extends NSUnitAcceleration> extends NSDimensionAllocator<T> {}
declare class NSUnitAcceleration extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitAcceleration>(): NSUnitAccelerationAllocator<T>;

  static metersPerSecondSquared(): NSUnitAcceleration;
  static gravity(): NSUnitAcceleration;
  static supportsSecureCoding(): boolean;
}

class NSUnitAngleAllocator<T extends NSUnitAngle> extends NSDimensionAllocator<T> {}
declare class NSUnitAngle extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitAngle>(): NSUnitAngleAllocator<T>;

  static degrees(): NSUnitAngle;
  static arcMinutes(): NSUnitAngle;
  static arcSeconds(): NSUnitAngle;
  static radians(): NSUnitAngle;
  static gradians(): NSUnitAngle;
  static revolutions(): NSUnitAngle;
  static supportsSecureCoding(): boolean;
}

class NSUnitAreaAllocator<T extends NSUnitArea> extends NSDimensionAllocator<T> {}
declare class NSUnitArea extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitArea>(): NSUnitAreaAllocator<T>;

  static squareMegameters(): NSUnitArea;
  static squareKilometers(): NSUnitArea;
  static squareMeters(): NSUnitArea;
  static squareCentimeters(): NSUnitArea;
  static squareMillimeters(): NSUnitArea;
  static squareMicrometers(): NSUnitArea;
  static squareNanometers(): NSUnitArea;
  static squareInches(): NSUnitArea;
  static squareFeet(): NSUnitArea;
  static squareYards(): NSUnitArea;
  static squareMiles(): NSUnitArea;
  static acres(): NSUnitArea;
  static ares(): NSUnitArea;
  static hectares(): NSUnitArea;
  static supportsSecureCoding(): boolean;
}

class NSUnitConcentrationMassAllocator<T extends NSUnitConcentrationMass> extends NSDimensionAllocator<T> {}
declare class NSUnitConcentrationMass extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitConcentrationMass>(): NSUnitConcentrationMassAllocator<T>;
  static millimolesPerLiterWithGramsPerMole(gramsPerMole: number): NSUnitConcentrationMass;

  static gramsPerLiter(): NSUnitConcentrationMass;
  static milligramsPerDeciliter(): NSUnitConcentrationMass;
  static supportsSecureCoding(): boolean;
}

class NSUnitDispersionAllocator<T extends NSUnitDispersion> extends NSDimensionAllocator<T> {}
declare class NSUnitDispersion extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitDispersion>(): NSUnitDispersionAllocator<T>;

  static partsPerMillion(): NSUnitDispersion;
  static supportsSecureCoding(): boolean;
}

class NSUnitDurationAllocator<T extends NSUnitDuration> extends NSDimensionAllocator<T> {}
declare class NSUnitDuration extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitDuration>(): NSUnitDurationAllocator<T>;

  static seconds(): NSUnitDuration;
  static minutes(): NSUnitDuration;
  static hours(): NSUnitDuration;
  static supportsSecureCoding(): boolean;
}

class NSUnitElectricChargeAllocator<T extends NSUnitElectricCharge> extends NSDimensionAllocator<T> {}
declare class NSUnitElectricCharge extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitElectricCharge>(): NSUnitElectricChargeAllocator<T>;

  static coulombs(): NSUnitElectricCharge;
  static megaampereHours(): NSUnitElectricCharge;
  static kiloampereHours(): NSUnitElectricCharge;
  static ampereHours(): NSUnitElectricCharge;
  static milliampereHours(): NSUnitElectricCharge;
  static microampereHours(): NSUnitElectricCharge;
  static supportsSecureCoding(): boolean;
}

class NSUnitElectricCurrentAllocator<T extends NSUnitElectricCurrent> extends NSDimensionAllocator<T> {}
declare class NSUnitElectricCurrent extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitElectricCurrent>(): NSUnitElectricCurrentAllocator<T>;

  static megaamperes(): NSUnitElectricCurrent;
  static kiloamperes(): NSUnitElectricCurrent;
  static amperes(): NSUnitElectricCurrent;
  static milliamperes(): NSUnitElectricCurrent;
  static microamperes(): NSUnitElectricCurrent;
  static supportsSecureCoding(): boolean;
}

class NSUnitElectricPotentialDifferenceAllocator<T extends NSUnitElectricPotentialDifference> extends NSDimensionAllocator<T> {}
declare class NSUnitElectricPotentialDifference extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitElectricPotentialDifference>(): NSUnitElectricPotentialDifferenceAllocator<T>;

  static megavolts(): NSUnitElectricPotentialDifference;
  static kilovolts(): NSUnitElectricPotentialDifference;
  static volts(): NSUnitElectricPotentialDifference;
  static millivolts(): NSUnitElectricPotentialDifference;
  static microvolts(): NSUnitElectricPotentialDifference;
  static supportsSecureCoding(): boolean;
}

class NSUnitElectricResistanceAllocator<T extends NSUnitElectricResistance> extends NSDimensionAllocator<T> {}
declare class NSUnitElectricResistance extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitElectricResistance>(): NSUnitElectricResistanceAllocator<T>;

  static megaohms(): NSUnitElectricResistance;
  static kiloohms(): NSUnitElectricResistance;
  static ohms(): NSUnitElectricResistance;
  static milliohms(): NSUnitElectricResistance;
  static microohms(): NSUnitElectricResistance;
  static supportsSecureCoding(): boolean;
}

class NSUnitEnergyAllocator<T extends NSUnitEnergy> extends NSDimensionAllocator<T> {}
declare class NSUnitEnergy extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitEnergy>(): NSUnitEnergyAllocator<T>;

  static kilojoules(): NSUnitEnergy;
  static joules(): NSUnitEnergy;
  static kilocalories(): NSUnitEnergy;
  static calories(): NSUnitEnergy;
  static kilowattHours(): NSUnitEnergy;
  static supportsSecureCoding(): boolean;
}

class NSUnitFrequencyAllocator<T extends NSUnitFrequency> extends NSDimensionAllocator<T> {}
declare class NSUnitFrequency extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitFrequency>(): NSUnitFrequencyAllocator<T>;

  static terahertz(): NSUnitFrequency;
  static gigahertz(): NSUnitFrequency;
  static megahertz(): NSUnitFrequency;
  static kilohertz(): NSUnitFrequency;
  static hertz(): NSUnitFrequency;
  static millihertz(): NSUnitFrequency;
  static microhertz(): NSUnitFrequency;
  static nanohertz(): NSUnitFrequency;
  static supportsSecureCoding(): boolean;
}

class NSUnitFuelEfficiencyAllocator<T extends NSUnitFuelEfficiency> extends NSDimensionAllocator<T> {}
declare class NSUnitFuelEfficiency extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitFuelEfficiency>(): NSUnitFuelEfficiencyAllocator<T>;

  static litersPer100Kilometers(): NSUnitFuelEfficiency;
  static milesPerImperialGallon(): NSUnitFuelEfficiency;
  static milesPerGallon(): NSUnitFuelEfficiency;
  static supportsSecureCoding(): boolean;
}

class NSUnitLengthAllocator<T extends NSUnitLength> extends NSDimensionAllocator<T> {}
declare class NSUnitLength extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitLength>(): NSUnitLengthAllocator<T>;

  static megameters(): NSUnitLength;
  static kilometers(): NSUnitLength;
  static hectometers(): NSUnitLength;
  static decameters(): NSUnitLength;
  static meters(): NSUnitLength;
  static decimeters(): NSUnitLength;
  static centimeters(): NSUnitLength;
  static millimeters(): NSUnitLength;
  static micrometers(): NSUnitLength;
  static nanometers(): NSUnitLength;
  static picometers(): NSUnitLength;
  static inches(): NSUnitLength;
  static feet(): NSUnitLength;
  static yards(): NSUnitLength;
  static miles(): NSUnitLength;
  static scandinavianMiles(): NSUnitLength;
  static lightyears(): NSUnitLength;
  static nauticalMiles(): NSUnitLength;
  static fathoms(): NSUnitLength;
  static furlongs(): NSUnitLength;
  static astronomicalUnits(): NSUnitLength;
  static parsecs(): NSUnitLength;
  static supportsSecureCoding(): boolean;
}

class NSUnitIlluminanceAllocator<T extends NSUnitIlluminance> extends NSDimensionAllocator<T> {}
declare class NSUnitIlluminance extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitIlluminance>(): NSUnitIlluminanceAllocator<T>;

  static lux(): NSUnitIlluminance;
  static supportsSecureCoding(): boolean;
}

class NSUnitMassAllocator<T extends NSUnitMass> extends NSDimensionAllocator<T> {}
declare class NSUnitMass extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitMass>(): NSUnitMassAllocator<T>;

  static kilograms(): NSUnitMass;
  static grams(): NSUnitMass;
  static decigrams(): NSUnitMass;
  static centigrams(): NSUnitMass;
  static milligrams(): NSUnitMass;
  static micrograms(): NSUnitMass;
  static nanograms(): NSUnitMass;
  static picograms(): NSUnitMass;
  static ounces(): NSUnitMass;
  static poundsMass(): NSUnitMass;
  static stones(): NSUnitMass;
  static metricTons(): NSUnitMass;
  static shortTons(): NSUnitMass;
  static carats(): NSUnitMass;
  static ouncesTroy(): NSUnitMass;
  static slugs(): NSUnitMass;
  static supportsSecureCoding(): boolean;
}

class NSUnitPowerAllocator<T extends NSUnitPower> extends NSDimensionAllocator<T> {}
declare class NSUnitPower extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitPower>(): NSUnitPowerAllocator<T>;

  static terawatts(): NSUnitPower;
  static gigawatts(): NSUnitPower;
  static megawatts(): NSUnitPower;
  static kilowatts(): NSUnitPower;
  static watts(): NSUnitPower;
  static milliwatts(): NSUnitPower;
  static microwatts(): NSUnitPower;
  static nanowatts(): NSUnitPower;
  static picowatts(): NSUnitPower;
  static femtowatts(): NSUnitPower;
  static horsepower(): NSUnitPower;
  static supportsSecureCoding(): boolean;
}

class NSUnitPressureAllocator<T extends NSUnitPressure> extends NSDimensionAllocator<T> {}
declare class NSUnitPressure extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitPressure>(): NSUnitPressureAllocator<T>;

  static newtonsPerMetersSquared(): NSUnitPressure;
  static gigapascals(): NSUnitPressure;
  static megapascals(): NSUnitPressure;
  static kilopascals(): NSUnitPressure;
  static hectopascals(): NSUnitPressure;
  static inchesOfMercury(): NSUnitPressure;
  static bars(): NSUnitPressure;
  static millibars(): NSUnitPressure;
  static millimetersOfMercury(): NSUnitPressure;
  static poundsForcePerSquareInch(): NSUnitPressure;
  static supportsSecureCoding(): boolean;
}

class NSUnitSpeedAllocator<T extends NSUnitSpeed> extends NSDimensionAllocator<T> {}
declare class NSUnitSpeed extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitSpeed>(): NSUnitSpeedAllocator<T>;

  static metersPerSecond(): NSUnitSpeed;
  static kilometersPerHour(): NSUnitSpeed;
  static milesPerHour(): NSUnitSpeed;
  static knots(): NSUnitSpeed;
  static supportsSecureCoding(): boolean;
}

class NSUnitTemperatureAllocator<T extends NSUnitTemperature> extends NSDimensionAllocator<T> {}
declare class NSUnitTemperature extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitTemperature>(): NSUnitTemperatureAllocator<T>;

  static kelvin(): NSUnitTemperature;
  static celsius(): NSUnitTemperature;
  static fahrenheit(): NSUnitTemperature;
  static supportsSecureCoding(): boolean;
}

class NSUnitVolumeAllocator<T extends NSUnitVolume> extends NSDimensionAllocator<T> {}
declare class NSUnitVolume extends NSDimension implements INSSecureCoding {
  alloc<T extends NSUnitVolume>(): NSUnitVolumeAllocator<T>;

  static megaliters(): NSUnitVolume;
  static kiloliters(): NSUnitVolume;
  static liters(): NSUnitVolume;
  static deciliters(): NSUnitVolume;
  static centiliters(): NSUnitVolume;
  static milliliters(): NSUnitVolume;
  static cubicKilometers(): NSUnitVolume;
  static cubicMeters(): NSUnitVolume;
  static cubicDecimeters(): NSUnitVolume;
  static cubicCentimeters(): NSUnitVolume;
  static cubicMillimeters(): NSUnitVolume;
  static cubicInches(): NSUnitVolume;
  static cubicFeet(): NSUnitVolume;
  static cubicYards(): NSUnitVolume;
  static cubicMiles(): NSUnitVolume;
  static acreFeet(): NSUnitVolume;
  static bushels(): NSUnitVolume;
  static teaspoons(): NSUnitVolume;
  static tablespoons(): NSUnitVolume;
  static fluidOunces(): NSUnitVolume;
  static cups(): NSUnitVolume;
  static pints(): NSUnitVolume;
  static quarts(): NSUnitVolume;
  static gallons(): NSUnitVolume;
  static imperialTeaspoons(): NSUnitVolume;
  static imperialTablespoons(): NSUnitVolume;
  static imperialFluidOunces(): NSUnitVolume;
  static imperialPints(): NSUnitVolume;
  static imperialQuarts(): NSUnitVolume;
  static imperialGallons(): NSUnitVolume;
  static metricCups(): NSUnitVolume;
  static supportsSecureCoding(): boolean;
}

class NSUserActivityAllocator<T extends NSUserActivity> extends NSObjectAllocator<T> {
  initWithActivityType(activityType: NSString | string): T;
  init(): T;
}
declare class NSUserActivity extends NSObject {
  alloc<T extends NSUserActivity>(): NSUserActivityAllocator<T>;
  addUserInfoEntriesFromDictionary(otherDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  becomeCurrent(): void;
  resignCurrent(): void;
  invalidate(): void;
  getContinuationStreamsWithCompletionHandler(completionHandler: Block): void;

  activityType(): NSString;
  title(): NSString;
  setTitle(title: NSString | string): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  requiredUserInfoKeys(): NSSet<any>;
  setRequiredUserInfoKeys(requiredUserInfoKeys: NSSet<any>): void;
  needsSave(): boolean;
  setNeedsSave(needsSave: boolean): void;
  webpageURL(): NSURL;
  setWebpageURL(webpageURL: NSURL): void;
  referrerURL(): NSURL;
  setReferrerURL(referrerURL: NSURL): void;
  expirationDate(): NSDate;
  setExpirationDate(expirationDate: NSDate): void;
  keywords(): NSSet<any>;
  setKeywords(keywords: NSSet<any>): void;
  supportsContinuationStreams(): boolean;
  setSupportsContinuationStreams(supportsContinuationStreams: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  eligibleForHandoff(): boolean;
  setEligibleForHandoff(eligibleForHandoff: boolean): void;
  eligibleForSearch(): boolean;
  setEligibleForSearch(eligibleForSearch: boolean): void;
  eligibleForPublicIndexing(): boolean;
  setEligibleForPublicIndexing(eligibleForPublicIndexing: boolean): void;
}

declare interface INSUserActivityDelegate {
  userActivityWillSave(userActivity: NSUserActivity): void;
  userActivityWasContinued(userActivity: NSUserActivity): void;
  userActivity_didReceiveInputStream_outputStream(userActivity: NSUserActivity, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

class NSUserDefaultsAllocator<T extends NSUserDefaults> extends NSObjectAllocator<T> {
  init(): T;
  initWithSuiteName(suitename: NSString | string | null): T;
  initWithUser(username: NSString | string): T;
}
declare class NSUserDefaults extends NSObject {
  alloc<T extends NSUserDefaults>(): NSUserDefaultsAllocator<T>;
  static resetStandardUserDefaults(): void;
  objectForKey(defaultName: NSString | string): any;
  setObject_forKey(value: any | null, defaultName: NSString | string): void;
  removeObjectForKey(defaultName: NSString | string): void;
  stringForKey(defaultName: NSString | string): NSString;
  arrayForKey(defaultName: NSString | string): NSArray<any>;
  dictionaryForKey(defaultName: NSString | string): NSDictionary<any, any>;
  dataForKey(defaultName: NSString | string): NSData;
  stringArrayForKey(defaultName: NSString | string): NSArray<any>;
  integerForKey(defaultName: NSString | string): NSInteger;
  floatForKey(defaultName: NSString | string): number;
  doubleForKey(defaultName: NSString | string): number;
  boolForKey(defaultName: NSString | string): boolean;
  URLForKey(defaultName: NSString | string): NSURL;
  setInteger_forKey(value: NSInteger, defaultName: NSString | string): void;
  setFloat_forKey(value: number, defaultName: NSString | string): void;
  setDouble_forKey(value: number, defaultName: NSString | string): void;
  setBool_forKey(value: boolean, defaultName: NSString | string): void;
  setURL_forKey(url: NSURL | null, defaultName: NSString | string): void;
  registerDefaults(registrationDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  addSuiteNamed(suiteName: NSString | string): void;
  removeSuiteNamed(suiteName: NSString | string): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
  volatileDomainForName(domainName: NSString | string): NSDictionary<any, any>;
  setVolatileDomain_forName(domain: NSDictionary<any, any> | {[key: string]: any}, domainName: NSString | string): void;
  removeVolatileDomainForName(domainName: NSString | string): void;
  persistentDomainNames(): NSArray<any>;
  persistentDomainForName(domainName: NSString | string): NSDictionary<any, any>;
  setPersistentDomain_forName(domain: NSDictionary<any, any> | {[key: string]: any}, domainName: NSString | string): void;
  removePersistentDomainForName(domainName: NSString | string): void;
  synchronize(): boolean;
  objectIsForcedForKey(key: NSString | string): boolean;
  objectIsForcedForKey_inDomain(key: NSString | string, domain: NSString | string): boolean;
  setColor_forKey(color: NSColor, key: NSString | string): void;
  colorForKey(key: NSString | string): NSColor;

  static standardUserDefaults(): NSUserDefaults;
  volatileDomainNames(): NSArray<any>;
}

class NSUserNotificationAllocator<T extends NSUserNotification> extends NSObjectAllocator<T> {
  init(): T;
}
declare class NSUserNotification extends NSObject implements INSCopying {
  alloc<T extends NSUserNotification>(): NSUserNotificationAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  title(): NSString;
  setTitle(title: NSString | string): void;
  subtitle(): NSString;
  setSubtitle(subtitle: NSString | string): void;
  informativeText(): NSString;
  setInformativeText(informativeText: NSString | string): void;
  actionButtonTitle(): NSString;
  setActionButtonTitle(actionButtonTitle: NSString | string): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  deliveryDate(): NSDate;
  setDeliveryDate(deliveryDate: NSDate): void;
  deliveryTimeZone(): NSTimeZone;
  setDeliveryTimeZone(deliveryTimeZone: NSTimeZone): void;
  deliveryRepeatInterval(): NSDateComponents;
  setDeliveryRepeatInterval(deliveryRepeatInterval: NSDateComponents): void;
  actualDeliveryDate(): NSDate;
  presented(): boolean;
  remote(): boolean;
  soundName(): NSString;
  setSoundName(soundName: NSString | string): void;
  hasActionButton(): boolean;
  setHasActionButton(hasActionButton: boolean): void;
  activationType(): NSUserNotificationActivationType;
  otherButtonTitle(): NSString;
  setOtherButtonTitle(otherButtonTitle: NSString | string): void;
  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  contentImage(): NSImage;
  setContentImage(contentImage: NSImage): void;
  hasReplyButton(): boolean;
  setHasReplyButton(hasReplyButton: boolean): void;
  responsePlaceholder(): NSString;
  setResponsePlaceholder(responsePlaceholder: NSString | string): void;
  response(): NSAttributedString;
  additionalActions(): NSArray<any>;
  setAdditionalActions(additionalActions: NSArray<any> | any[]): void;
  additionalActivationAction(): NSUserNotificationAction;
}

class NSUserNotificationActionAllocator<T extends NSUserNotificationAction> extends NSObjectAllocator<T> {}
declare class NSUserNotificationAction extends NSObject implements INSCopying {
  alloc<T extends NSUserNotificationAction>(): NSUserNotificationActionAllocator<T>;
  static actionWithIdentifier_title(identifier: NSString | string | null, title: NSString | string | null): NSUserNotificationAction;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  identifier(): NSString;
  title(): NSString;
}

class NSUserNotificationCenterAllocator<T extends NSUserNotificationCenter> extends NSObjectAllocator<T> {}
declare class NSUserNotificationCenter extends NSObject {
  alloc<T extends NSUserNotificationCenter>(): NSUserNotificationCenterAllocator<T>;
  scheduleNotification(notification: NSUserNotification): void;
  removeScheduledNotification(notification: NSUserNotification): void;
  deliverNotification(notification: NSUserNotification): void;
  removeDeliveredNotification(notification: NSUserNotification): void;
  removeAllDeliveredNotifications(): void;

  static defaultUserNotificationCenter(): NSUserNotificationCenter;
  delegate(): any;
  setDelegate(delegate: any): void;
  scheduledNotifications(): NSArray<any>;
  setScheduledNotifications(scheduledNotifications: NSArray<any> | any[]): void;
  deliveredNotifications(): NSArray<any>;
}

declare interface INSUserNotificationCenterDelegate {
  userNotificationCenter_didDeliverNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_didActivateNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_shouldPresentNotification(center: NSUserNotificationCenter, notification: NSUserNotification): boolean;
}

declare enum NSUserNotificationActivationType {
  NSUserNotificationActivationTypeNone = 0,
  NSUserNotificationActivationTypeContentsClicked = 1,
  NSUserNotificationActivationTypeActionButtonClicked = 2,
  NSUserNotificationActivationTypeReplied = 3,
  NSUserNotificationActivationTypeAdditionalActionClicked = 4,
}

class NSUserScriptTaskAllocator<T extends NSUserScriptTask> extends NSObjectAllocator<T> {
  initWithURL_error(url: NSURL, error: NSError): T;
}
declare class NSUserScriptTask extends NSObject {
  alloc<T extends NSUserScriptTask>(): NSUserScriptTaskAllocator<T>;
  executeWithCompletionHandler(handler: NSUserScriptTaskCompletionHandler | null): void;

  scriptURL(): NSURL;
}

class NSUserUnixTaskAllocator<T extends NSUserUnixTask> extends NSUserScriptTaskAllocator<T> {}
declare class NSUserUnixTask extends NSUserScriptTask {
  alloc<T extends NSUserUnixTask>(): NSUserUnixTaskAllocator<T>;
  executeWithArguments_completionHandler(arguments: NSArray<any> | any[] | null, handler: NSUserUnixTaskCompletionHandler | null): void;

  standardInput(): NSFileHandle;
  setStandardInput(standardInput: NSFileHandle): void;
  standardOutput(): NSFileHandle;
  setStandardOutput(standardOutput: NSFileHandle): void;
  standardError(): NSFileHandle;
  setStandardError(standardError: NSFileHandle): void;
}

class NSUserAppleScriptTaskAllocator<T extends NSUserAppleScriptTask> extends NSUserScriptTaskAllocator<T> {}
declare class NSUserAppleScriptTask extends NSUserScriptTask {
  alloc<T extends NSUserAppleScriptTask>(): NSUserAppleScriptTaskAllocator<T>;
  executeWithAppleEvent_completionHandler(event: NSAppleEventDescriptor | null, handler: NSUserAppleScriptTaskCompletionHandler | null): void;
}

class NSUserAutomatorTaskAllocator<T extends NSUserAutomatorTask> extends NSUserScriptTaskAllocator<T> {}
declare class NSUserAutomatorTask extends NSUserScriptTask {
  alloc<T extends NSUserAutomatorTask>(): NSUserAutomatorTaskAllocator<T>;
  executeWithInput_completionHandler(input: any | null, handler: NSUserAutomatorTaskCompletionHandler | null): void;

  variables(): NSDictionary<any, any>;
  setVariables(variables: NSDictionary<any, any> | {[key: string]: any}): void;
}

class NSValueTransformerAllocator<T extends NSValueTransformer> extends NSObjectAllocator<T> {}
declare class NSValueTransformer extends NSObject {
  alloc<T extends NSValueTransformer>(): NSValueTransformerAllocator<T>;
  static setValueTransformer_forName(transformer: NSValueTransformer | null, name: NSValueTransformerName): void;
  static valueTransformerForName(name: NSValueTransformerName): NSValueTransformer;
  static valueTransformerNames(): NSArray<any>;
  static transformedValueClass(): any;
  static allowsReverseTransformation(): boolean;
  transformedValue(value: any | null): any;
  reverseTransformedValue(value: any | null): any;
}

declare type NSValueTransformerName = NSString

class NSXMLDTDAllocator<T extends NSXMLDTD> extends NSXMLNodeAllocator<T> {
  initWithContentsOfURL_options_error(url: NSURL, mask: NSXMLNodeOptions, error: NSError): T;
  initWithData_options_error(data: NSData, mask: NSXMLNodeOptions, error: NSError): T;
}
declare class NSXMLDTD extends NSXMLNode {
  alloc<T extends NSXMLDTD>(): NSXMLDTDAllocator<T>;
  insertChild_atIndex(child: NSXMLNode, index: NSUInteger): void;
  insertChildren_atIndex(children: NSArray<any> | any[], index: NSUInteger): void;
  removeChildAtIndex(index: NSUInteger): void;
  setChildren(children: NSArray<any> | any[] | null): void;
  addChild(child: NSXMLNode): void;
  replaceChildAtIndex_withNode(index: NSUInteger, node: NSXMLNode): void;
  entityDeclarationForName(name: NSString | string): NSXMLDTDNode;
  notationDeclarationForName(name: NSString | string): NSXMLDTDNode;
  elementDeclarationForName(name: NSString | string): NSXMLDTDNode;
  attributeDeclarationForName_elementName(name: NSString | string, elementName: NSString | string): NSXMLDTDNode;
  static predefinedEntityDeclarationForName(name: NSString | string): NSXMLDTDNode;

  publicID(): NSString;
  setPublicID(publicID: NSString | string): void;
  systemID(): NSString;
  setSystemID(systemID: NSString | string): void;
}

class NSXMLDTDNodeAllocator<T extends NSXMLDTDNode> extends NSXMLNodeAllocator<T> {
  initWithXMLString(string: NSString | string): T;
}
declare class NSXMLDTDNode extends NSXMLNode {
  alloc<T extends NSXMLDTDNode>(): NSXMLDTDNodeAllocator<T>;

  DTDKind(): NSXMLDTDNodeKind;
  setDTDKind(DTDKind: NSXMLDTDNodeKind): void;
  external(): boolean;
  publicID(): NSString;
  setPublicID(publicID: NSString | string): void;
  systemID(): NSString;
  setSystemID(systemID: NSString | string): void;
  notationName(): NSString;
  setNotationName(notationName: NSString | string): void;
}

declare enum NSXMLDTDNodeKind {
  NSXMLEntityGeneralKind = 1,
  NSXMLEntityParsedKind,
  NSXMLEntityUnparsedKind,
  NSXMLEntityParameterKind,
  NSXMLEntityPredefined,
  NSXMLAttributeCDATAKind,
  NSXMLAttributeIDKind,
  NSXMLAttributeIDRefKind,
  NSXMLAttributeIDRefsKind,
  NSXMLAttributeEntityKind,
  NSXMLAttributeEntitiesKind,
  NSXMLAttributeNMTokenKind,
  NSXMLAttributeNMTokensKind,
  NSXMLAttributeEnumerationKind,
  NSXMLAttributeNotationKind,
  NSXMLElementDeclarationUndefinedKind,
  NSXMLElementDeclarationEmptyKind,
  NSXMLElementDeclarationAnyKind,
  NSXMLElementDeclarationMixedKind,
  NSXMLElementDeclarationElementKind,
}

class NSXMLDocumentAllocator<T extends NSXMLDocument> extends NSXMLNodeAllocator<T> {
  initWithXMLString_options_error(string: NSString | string, mask: NSXMLNodeOptions, error: NSError): T;
  initWithContentsOfURL_options_error(url: NSURL, mask: NSXMLNodeOptions, error: NSError): T;
  initWithData_options_error(data: NSData, mask: NSXMLNodeOptions, error: NSError): T;
  initWithRootElement(element: NSXMLElement | null): T;
}
declare class NSXMLDocument extends NSXMLNode {
  alloc<T extends NSXMLDocument>(): NSXMLDocumentAllocator<T>;
  static replacementClassForClass(cls: any): any;
  setRootElement(root: NSXMLElement): void;
  rootElement(): NSXMLElement;
  insertChild_atIndex(child: NSXMLNode, index: NSUInteger): void;
  insertChildren_atIndex(children: NSArray<any> | any[], index: NSUInteger): void;
  removeChildAtIndex(index: NSUInteger): void;
  setChildren(children: NSArray<any> | any[] | null): void;
  addChild(child: NSXMLNode): void;
  replaceChildAtIndex_withNode(index: NSUInteger, node: NSXMLNode): void;
  XMLDataWithOptions(options: NSXMLNodeOptions): NSData;
  objectByApplyingXSLT_arguments_error(xslt: NSData, arguments: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): any;
  objectByApplyingXSLTString_arguments_error(xslt: NSString | string, arguments: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): any;
  objectByApplyingXSLTAtURL_arguments_error(xsltURL: NSURL, argument: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): any;
  validateAndReturnError(error: NSError): boolean;
  static SVGDocumentWithBezierPath(bezierPath: NSBezierPath): any;
  createSVGForBezierPath(bezierPath: NSBezierPath): any;
  bezierPathElement(path: NSBezierPath): NSXMLNode;
  data(): NSData;

  characterEncoding(): NSString;
  setCharacterEncoding(characterEncoding: NSString | string): void;
  version(): NSString;
  setVersion(version: NSString | string): void;
  standalone(): boolean;
  setStandalone(standalone: boolean): void;
  documentContentKind(): NSXMLDocumentContentKind;
  setDocumentContentKind(documentContentKind: NSXMLDocumentContentKind): void;
  MIMEType(): NSString;
  setMIMEType(MIMEType: NSString | string): void;
  DTD(): NSXMLDTD;
  setDTD(DTD: NSXMLDTD): void;
  XMLData(): NSData;
}

declare enum NSXMLDocumentContentKind {
  NSXMLDocumentXMLKind = 0,
  NSXMLDocumentXHTMLKind,
  NSXMLDocumentHTMLKind,
  NSXMLDocumentTextKind,
}

class NSXMLElementAllocator<T extends NSXMLElement> extends NSXMLNodeAllocator<T> {
  initWithName(name: NSString | string): T;
  initWithName_URI(name: NSString | string, URI: NSString | string | null): T;
  initWithName_stringValue(name: NSString | string, string: NSString | string | null): T;
  initWithXMLString_error(string: NSString | string, error: NSError): T;
}
declare class NSXMLElement extends NSXMLNode {
  alloc<T extends NSXMLElement>(): NSXMLElementAllocator<T>;
  elementsForName(name: NSString | string): NSArray<any>;
  elementsForLocalName_URI(localName: NSString | string, URI: NSString | string | null): NSArray<any>;
  addAttribute(attribute: NSXMLNode): void;
  removeAttributeForName(name: NSString | string): void;
  setAttributesWithDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  attributeForName(name: NSString | string): NSXMLNode;
  attributeForLocalName_URI(localName: NSString | string, URI: NSString | string | null): NSXMLNode;
  addNamespace(aNamespace: NSXMLNode): void;
  removeNamespaceForPrefix(name: NSString | string): void;
  namespaceForPrefix(name: NSString | string): NSXMLNode;
  resolveNamespaceForName(name: NSString | string): NSXMLNode;
  resolvePrefixForNamespaceURI(namespaceURI: NSString | string): NSString;
  insertChild_atIndex(child: NSXMLNode, index: NSUInteger): void;
  insertChildren_atIndex(children: NSArray<any> | any[], index: NSUInteger): void;
  removeChildAtIndex(index: NSUInteger): void;
  setChildren(children: NSArray<any> | any[] | null): void;
  addChild(child: NSXMLNode): void;
  replaceChildAtIndex_withNode(index: NSUInteger, node: NSXMLNode): void;
  normalizeAdjacentTextNodesPreservingCDATA(preserve: boolean): void;
  setAttributesAsDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  gotAttributeWithName(name: NSString | string): boolean;
  doubleValueFromAttributeWithName(name: NSString | string): number;
  doubleValueFromAttributeWithName_scale(name: NSString | string, scale: CGFloat): number;
  doubleValueFromAttributeWithName_orDefault(name: NSString | string, def: number): number;
  doubleValueFromPercentageAttributeWithName(name: NSString | string): number;
  doubleValueFromPercentageAttributeWithName_orDefault(name: NSString | string, def: number): number;
  doubleValueFromAttributeWithName_alternate(name: NSString | string, alternate: NSString | string): number;
  doubleValueFromPercentageAttributeWithName_alternate(name: NSString | string, alternate: NSString | string): number;
  numberFromAttributeWithName(name: NSString | string): NSNumber;
  numberFromAttributeWithName_scale(name: NSString | string, scale: CGFloat): NSNumber;
  numbersFromAttributeWithName(name: NSString | string): NSArray<any>;
  numbersFromAttributeWithName_scale(name: NSString | string, scale: CGFloat): NSArray<any>;
  intValueFromAttributeWithName(name: NSString | string): NSInteger;
  rectValueFromAttributeWithName(name: NSString | string): NSRect;
  rectValue(): NSRect;
  rectValueWithXScale_yScale(xScale: CGFloat, yScale: CGFloat): NSRect;
  colorFromAttributeWithName(name: NSString | string): MSImmutableColor;
  stringFromAttributeWithName(name: NSString | string): NSString;
  stringFromAttributeWithName_orDefault(name: NSString | string, def: NSString | string): NSString;
  stringForHREFLink(): NSString;
  nodeOrParentNodeWithName(name: NSString | string): NSXMLNode;
  attributesWithStyleMergedDefaults(defaults: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  simplifyAttributesIgnoringElements_attributes(elementsToIgnore: NSArray<any> | any[], attributesToIgnore: NSArray<any> | any[]): NSArray<any>;
  urlLink(): NSString;
  localLink(): NSString;
  cssClassNamesWithBase(base: NSString | string): NSArray<any>;
  addAttributeWithName_stringValue(name: NSString | string, value: NSString | string): void;
  addAttributeWithName_pixelValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_numberValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageValue(name: NSString | string, value: CGFloat): void;
  addAttributeWithName_percentageFractionalValue(name: NSString | string, value: CGFloat): void;

  attributes(): NSArray<any>;
  setAttributes(attributes: NSArray<any> | any[]): void;
  namespaces(): NSArray<any>;
  setNamespaces(namespaces: NSArray<any> | any[]): void;
}

class NSXMLNodeAllocator<T extends NSXMLNode> extends NSObjectAllocator<T> {
  init(): T;
  initWithKind(kind: NSXMLNodeKind): T;
  initWithKind_options(kind: NSXMLNodeKind, options: NSXMLNodeOptions): T;
}
declare class NSXMLNode extends NSObject implements INSCopying {
  alloc<T extends NSXMLNode>(): NSXMLNodeAllocator<T>;
  static document(): any;
  static documentWithRootElement(element: NSXMLElement): any;
  static elementWithName(name: NSString | string): any;
  static elementWithName_URI(name: NSString | string, URI: NSString | string): any;
  static elementWithName_stringValue(name: NSString | string, string: NSString | string): any;
  static elementWithName_children_attributes(name: NSString | string, children: NSArray<any> | any[] | null, attributes: NSArray<any> | any[] | null): any;
  static attributeWithName_stringValue(name: NSString | string, stringValue: NSString | string): any;
  static attributeWithName_URI_stringValue(name: NSString | string, URI: NSString | string, stringValue: NSString | string): any;
  static namespaceWithName_stringValue(name: NSString | string, stringValue: NSString | string): any;
  static processingInstructionWithName_stringValue(name: NSString | string, stringValue: NSString | string): any;
  static commentWithStringValue(stringValue: NSString | string): any;
  static textWithStringValue(stringValue: NSString | string): any;
  static DTDNodeWithXMLString(string: NSString | string): any;
  setStringValue_resolvingEntities(string: NSString | string, resolve: boolean): void;
  childAtIndex(index: NSUInteger): NSXMLNode;
  detach(): void;
  static localNameForName(name: NSString | string): NSString;
  static prefixForName(name: NSString | string): NSString;
  static predefinedNamespaceForPrefix(name: NSString | string): NSXMLNode;
  XMLStringWithOptions(options: NSXMLNodeOptions): NSString;
  canonicalXMLStringPreservingComments(comments: boolean): NSString;
  nodesForXPath_error(xpath: NSString | string, error: NSError): NSArray<any>;
  objectsForXQuery_constants_error(xquery: NSString | string, constants: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): NSArray<any>;
  objectsForXQuery_error(xquery: NSString | string, error: NSError): NSArray<any>;
  static doubleFromString_scale(string: NSString | string, scale: CGFloat): number;
  static numberFromString_scale(string: NSString | string, scale: CGFloat): NSNumber;
  static numbersFromString_scale(string: NSString | string, scale: CGFloat): NSArray<any>;
  doubleValueFromAttributeWithName(name: NSString | string): number;
  doubleValue(): number;
  doubleValueWithScale(scale: CGFloat): number;
  numberValue(): NSNumber;
  numberValueWithScale(scale: CGFloat): NSNumber;
  numberValues(): NSArray<any>;
  numberValuesWithScale(scale: CGFloat): NSArray<any>;
  integerValue(): NSInteger;
  rectValue(): NSRect;
  static attributeWithName_pixelValue(name: NSString | string, value: CGFloat): any;
  static attributeWithName_numberValue(name: NSString | string, value: CGFloat): any;
  static attributeWithName_percentageValue(name: NSString | string, value: CGFloat): any;
  static attributeWithName_percentageFractionalValue(name: NSString | string, value: CGFloat): any;
  simplifyAttributesIgnoringElements_attributes(elementsToIgnore: NSArray<any> | any[], attributesToIgnore: NSArray<any> | any[]): NSArray<any>;
  cssClassNamesWithBase(base: NSString | string): NSArray<any>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  kind(): NSXMLNodeKind;
  name(): NSString;
  setName(name: NSString | string): void;
  objectValue(): any;
  setObjectValue(objectValue: any): void;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  index(): NSUInteger;
  level(): NSUInteger;
  rootDocument(): NSXMLDocument;
  parent(): NSXMLNode;
  childCount(): NSUInteger;
  children(): NSArray<any>;
  previousSibling(): NSXMLNode;
  nextSibling(): NSXMLNode;
  previousNode(): NSXMLNode;
  nextNode(): NSXMLNode;
  XPath(): NSString;
  localName(): NSString;
  prefix(): NSString;
  URI(): NSString;
  setURI(URI: NSString | string): void;
  description(): NSString;
  XMLString(): NSString;
}

declare enum NSXMLNodeKind {
  NSXMLInvalidKind = 0,
  NSXMLDocumentKind,
  NSXMLElementKind,
  NSXMLAttributeKind,
  NSXMLNamespaceKind,
  NSXMLProcessingInstructionKind,
  NSXMLCommentKind,
  NSXMLTextKind,
  NSXMLDTDKind,
  NSXMLEntityDeclarationKind,
  NSXMLAttributeDeclarationKind,
  NSXMLElementDeclarationKind,
  NSXMLNotationDeclarationKind,
}

declare enum NSXMLNodeOptions {
  NSXMLNodeOptionsNone = 0,
  NSXMLNodeIsCDATA = 1 << 0,
  NSXMLNodeExpandEmptyElement = 1 << 1,
  NSXMLNodeCompactEmptyElement = 1 << 2,
  NSXMLNodeUseSingleQuotes = 1 << 3,
  NSXMLNodeUseDoubleQuotes = 1 << 4,
  NSXMLNodeNeverEscapeContents = 1 << 5,
  NSXMLDocumentTidyHTML = 1 << 9,
  NSXMLDocumentTidyXML = 1 << 10,
  NSXMLDocumentValidate = 1 << 13,
  NSXMLNodeLoadExternalEntitiesAlways = 1 << 14,
  NSXMLNodeLoadExternalEntitiesSameOriginOnly = 1 << 15,
  NSXMLNodeLoadExternalEntitiesNever = 1 << 19,
  NSXMLDocumentXInclude = 1 << 16,
  NSXMLNodePrettyPrint = 1 << 17,
  NSXMLDocumentIncludeContentTypeDeclaration = 1 << 18,
  NSXMLNodePreserveNamespaceOrder = 1 << 20,
  NSXMLNodePreserveAttributeOrder = 1 << 21,
  NSXMLNodePreserveEntities = 1 << 22,
  NSXMLNodePreservePrefixes = 1 << 23,
  NSXMLNodePreserveCDATA = 1 << 24,
  NSXMLNodePreserveWhitespace = 1 << 25,
  NSXMLNodePreserveDTD = 1 << 26,
  NSXMLNodePreserveCharacterReferences = 1 << 27,
  NSXMLNodePromoteSignificantWhitespace = 1 << 28,
  NSXMLNodePreserveEmptyElements,
  NSXMLNodePreserveQuotes,
  NSXMLNodePreserveAll,
}

class NSXMLParserAllocator<T extends NSXMLParser> extends NSObjectAllocator<T> {
  initWithContentsOfURL(url: NSURL): T;
  initWithData(data: NSData): T;
  initWithStream(stream: NSInputStream): T;
}
declare class NSXMLParser extends NSObject {
  alloc<T extends NSXMLParser>(): NSXMLParserAllocator<T>;
  parse(): boolean;
  abortParsing(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  shouldProcessNamespaces(): boolean;
  setShouldProcessNamespaces(shouldProcessNamespaces: boolean): void;
  shouldReportNamespacePrefixes(): boolean;
  setShouldReportNamespacePrefixes(shouldReportNamespacePrefixes: boolean): void;
  externalEntityResolvingPolicy(): NSXMLParserExternalEntityResolvingPolicy;
  setExternalEntityResolvingPolicy(externalEntityResolvingPolicy: NSXMLParserExternalEntityResolvingPolicy): void;
  allowedExternalEntityURLs(): NSSet<any>;
  setAllowedExternalEntityURLs(allowedExternalEntityURLs: NSSet<any>): void;
  parserError(): NSError;
  shouldResolveExternalEntities(): boolean;
  setShouldResolveExternalEntities(shouldResolveExternalEntities: boolean): void;
  publicID(): NSString;
  systemID(): NSString;
  lineNumber(): NSInteger;
  columnNumber(): NSInteger;
}

declare interface INSXMLParserDelegate {
  parserDidStartDocument(parser: NSXMLParser): void;
  parserDidEndDocument(parser: NSXMLParser): void;
  parser_foundNotationDeclarationWithName_publicID_systemID(parser: NSXMLParser, name: NSString | string, publicID: NSString | string | null, systemID: NSString | string | null): void;
  parser_foundUnparsedEntityDeclarationWithName_publicID_systemID_notationName(parser: NSXMLParser, name: NSString | string, publicID: NSString | string | null, systemID: NSString | string | null, notationName: NSString | string | null): void;
  parser_foundAttributeDeclarationWithName_forElement_type_defaultValue(parser: NSXMLParser, attributeName: NSString | string, elementName: NSString | string, type: NSString | string | null, defaultValue: NSString | string | null): void;
  parser_foundElementDeclarationWithName_model(parser: NSXMLParser, elementName: NSString | string, model: NSString | string): void;
  parser_foundInternalEntityDeclarationWithName_value(parser: NSXMLParser, name: NSString | string, value: NSString | string | null): void;
  parser_foundExternalEntityDeclarationWithName_publicID_systemID(parser: NSXMLParser, name: NSString | string, publicID: NSString | string | null, systemID: NSString | string | null): void;
  parser_didStartElement_namespaceURI_qualifiedName_attributes(parser: NSXMLParser, elementName: NSString | string, namespaceURI: NSString | string | null, qName: NSString | string | null, attributeDict: NSDictionary<any, any> | {[key: string]: any}): void;
  parser_didEndElement_namespaceURI_qualifiedName(parser: NSXMLParser, elementName: NSString | string, namespaceURI: NSString | string | null, qName: NSString | string | null): void;
  parser_didStartMappingPrefix_toURI(parser: NSXMLParser, prefix: NSString | string, namespaceURI: NSString | string): void;
  parser_didEndMappingPrefix(parser: NSXMLParser, prefix: NSString | string): void;
  parser_foundCharacters(parser: NSXMLParser, string: NSString | string): void;
  parser_foundIgnorableWhitespace(parser: NSXMLParser, whitespaceString: NSString | string): void;
  parser_foundProcessingInstructionWithTarget_data(parser: NSXMLParser, target: NSString | string, data: NSString | string | null): void;
  parser_foundComment(parser: NSXMLParser, comment: NSString | string): void;
  parser_foundCDATA(parser: NSXMLParser, CDATABlock: NSData): void;
  parser_resolveExternalEntityName_systemID(parser: NSXMLParser, name: NSString | string, systemID: NSString | string | null): NSData;
  parser_parseErrorOccurred(parser: NSXMLParser, parseError: NSError): void;
  parser_validationErrorOccurred(parser: NSXMLParser, validationError: NSError): void;
}

declare enum NSXMLParserExternalEntityResolvingPolicy {
  NSXMLParserResolveExternalEntitiesNever = 0,
  NSXMLParserResolveExternalEntitiesNoNetwork,
  NSXMLParserResolveExternalEntitiesSameOriginOnly,
  NSXMLParserResolveExternalEntitiesAlways,
}

declare enum NSXMLParserError {
  NSXMLParserInternalError = 1,
  NSXMLParserOutOfMemoryError = 2,
  NSXMLParserDocumentStartError = 3,
  NSXMLParserEmptyDocumentError = 4,
  NSXMLParserPrematureDocumentEndError = 5,
  NSXMLParserInvalidHexCharacterRefError = 6,
  NSXMLParserInvalidDecimalCharacterRefError = 7,
  NSXMLParserInvalidCharacterRefError = 8,
  NSXMLParserInvalidCharacterError = 9,
  NSXMLParserCharacterRefAtEOFError = 10,
  NSXMLParserCharacterRefInPrologError = 11,
  NSXMLParserCharacterRefInEpilogError = 12,
  NSXMLParserCharacterRefInDTDError = 13,
  NSXMLParserEntityRefAtEOFError = 14,
  NSXMLParserEntityRefInPrologError = 15,
  NSXMLParserEntityRefInEpilogError = 16,
  NSXMLParserEntityRefInDTDError = 17,
  NSXMLParserParsedEntityRefAtEOFError = 18,
  NSXMLParserParsedEntityRefInPrologError = 19,
  NSXMLParserParsedEntityRefInEpilogError = 20,
  NSXMLParserParsedEntityRefInInternalSubsetError = 21,
  NSXMLParserEntityReferenceWithoutNameError = 22,
  NSXMLParserEntityReferenceMissingSemiError = 23,
  NSXMLParserParsedEntityRefNoNameError = 24,
  NSXMLParserParsedEntityRefMissingSemiError = 25,
  NSXMLParserUndeclaredEntityError = 26,
  NSXMLParserUnparsedEntityError = 28,
  NSXMLParserEntityIsExternalError = 29,
  NSXMLParserEntityIsParameterError = 30,
  NSXMLParserUnknownEncodingError = 31,
  NSXMLParserEncodingNotSupportedError = 32,
  NSXMLParserStringNotStartedError = 33,
  NSXMLParserStringNotClosedError = 34,
  NSXMLParserNamespaceDeclarationError = 35,
  NSXMLParserEntityNotStartedError = 36,
  NSXMLParserEntityNotFinishedError = 37,
  NSXMLParserLessThanSymbolInAttributeError = 38,
  NSXMLParserAttributeNotStartedError = 39,
  NSXMLParserAttributeNotFinishedError = 40,
  NSXMLParserAttributeHasNoValueError = 41,
  NSXMLParserAttributeRedefinedError = 42,
  NSXMLParserLiteralNotStartedError = 43,
  NSXMLParserLiteralNotFinishedError = 44,
  NSXMLParserCommentNotFinishedError = 45,
  NSXMLParserProcessingInstructionNotStartedError = 46,
  NSXMLParserProcessingInstructionNotFinishedError = 47,
  NSXMLParserNotationNotStartedError = 48,
  NSXMLParserNotationNotFinishedError = 49,
  NSXMLParserAttributeListNotStartedError = 50,
  NSXMLParserAttributeListNotFinishedError = 51,
  NSXMLParserMixedContentDeclNotStartedError = 52,
  NSXMLParserMixedContentDeclNotFinishedError = 53,
  NSXMLParserElementContentDeclNotStartedError = 54,
  NSXMLParserElementContentDeclNotFinishedError = 55,
  NSXMLParserXMLDeclNotStartedError = 56,
  NSXMLParserXMLDeclNotFinishedError = 57,
  NSXMLParserConditionalSectionNotStartedError = 58,
  NSXMLParserConditionalSectionNotFinishedError = 59,
  NSXMLParserExternalSubsetNotFinishedError = 60,
  NSXMLParserDOCTYPEDeclNotFinishedError = 61,
  NSXMLParserMisplacedCDATAEndStringError = 62,
  NSXMLParserCDATANotFinishedError = 63,
  NSXMLParserMisplacedXMLDeclarationError = 64,
  NSXMLParserSpaceRequiredError = 65,
  NSXMLParserSeparatorRequiredError = 66,
  NSXMLParserNMTOKENRequiredError = 67,
  NSXMLParserNAMERequiredError = 68,
  NSXMLParserPCDATARequiredError = 69,
  NSXMLParserURIRequiredError = 70,
  NSXMLParserPublicIdentifierRequiredError = 71,
  NSXMLParserLTRequiredError = 72,
  NSXMLParserGTRequiredError = 73,
  NSXMLParserLTSlashRequiredError = 74,
  NSXMLParserEqualExpectedError = 75,
  NSXMLParserTagNameMismatchError = 76,
  NSXMLParserUnfinishedTagError = 77,
  NSXMLParserStandaloneValueError = 78,
  NSXMLParserInvalidEncodingNameError = 79,
  NSXMLParserCommentContainsDoubleHyphenError = 80,
  NSXMLParserInvalidEncodingError = 81,
  NSXMLParserExternalStandaloneEntityError = 82,
  NSXMLParserInvalidConditionalSectionError = 83,
  NSXMLParserEntityValueRequiredError = 84,
  NSXMLParserNotWellBalancedError = 85,
  NSXMLParserExtraContentError = 86,
  NSXMLParserInvalidCharacterInEntityError = 87,
  NSXMLParserParsedEntityRefInInternalError = 88,
  NSXMLParserEntityRefLoopError = 89,
  NSXMLParserEntityBoundaryError = 90,
  NSXMLParserInvalidURIError = 91,
  NSXMLParserURIFragmentError = 92,
  NSXMLParserNoDTDError = 94,
  NSXMLParserDelegateAbortedParseError = 512,
}

class NSXPCListenerAllocator<T extends NSXPCListener> extends NSObjectAllocator<T> {}
declare class NSXPCListener extends NSObject {
  alloc<T extends NSXPCListener>(): NSXPCListenerAllocator<T>;
  static serviceListener(): NSXPCListener;
  static anonymousListener(): NSXPCListener;
  resume(): void;
  suspend(): void;
  invalidate(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  endpoint(): NSXPCListenerEndpoint;
}

class NSXPCInterfaceAllocator<T extends NSXPCInterface> extends NSObjectAllocator<T> {}
declare class NSXPCInterface extends NSObject {
  alloc<T extends NSXPCInterface>(): NSXPCInterfaceAllocator<T>;
  static interfaceWithProtocol(protocol: Protocol): NSXPCInterface;
  setClasses_forSelector_argumentIndex_ofReply(classes: NSSet<any>, sel: string, arg: NSUInteger, ofReply: boolean): void;
  classesForSelector_argumentIndex_ofReply(sel: string, arg: NSUInteger, ofReply: boolean): NSSet<any>;
  setInterface_forSelector_argumentIndex_ofReply(ifc: NSXPCInterface, sel: string, arg: NSUInteger, ofReply: boolean): void;
  interfaceForSelector_argumentIndex_ofReply(sel: string, arg: NSUInteger, ofReply: boolean): NSXPCInterface;

  protocol(): Protocol;
  setProtocol(protocol: Protocol): void;
}

class NSXPCListenerEndpointAllocator<T extends NSXPCListenerEndpoint> extends NSObjectAllocator<T> {}
declare class NSXPCListenerEndpoint extends NSObject implements INSSecureCoding {
  alloc<T extends NSXPCListenerEndpoint>(): NSXPCListenerEndpointAllocator<T>;

  static supportsSecureCoding(): boolean;
}

declare enum NSXPCConnectionOptions {
  NSXPCConnectionPrivileged,
}

declare type NSZone = any

class NSATSTypesetterAllocator<T extends NSATSTypesetter> extends NSTypesetterAllocator<T> {}
declare class NSATSTypesetter extends NSTypesetter {
  alloc<T extends NSATSTypesetter>(): NSATSTypesetterAllocator<T>;
  lineFragmentRectForProposedRect_remainingRect(proposedRect: NSRect, remainingRect: NSRectPointer): NSRect;
  substituteFontForFont(originalFont: NSFont): NSFont;
  textTabForGlyphLocation_writingDirection_maxLocation(glyphLocation: CGFloat, direction: NSWritingDirection, maxLocation: CGFloat): NSTextTab;
  setParagraphGlyphRange_separatorGlyphRange(paragraphRange: NSRange, paragraphSeparatorRange: NSRange): void;
  layoutParagraphAtPoint(lineFragmentOrigin: NSPoint): NSUInteger;
  lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  setHardInvalidation_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  getLineFragmentRect_usedRect_forParagraphSeparatorGlyphRange_atProposedOrigin(lineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, paragraphSeparatorGlyphRange: NSRange, lineOrigin: NSPoint): void;
  willSetLineFragmentRect_forGlyphRange_usedRect_baselineOffset(lineRect: NSRect, glyphRange: NSRange, usedRect: NSRect, baselineOffset: CGFloat): void;
  shouldBreakLineByWordBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  shouldBreakLineByHyphenatingBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  hyphenationFactorForGlyphAtIndex(glyphIndex: NSUInteger): number;
  hyphenCharacterForGlyphAtIndex(glyphIndex: NSUInteger): string;
  boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(glyphIndex: NSUInteger, textContainer: NSTextContainer, proposedRect: NSRect, glyphPosition: NSPoint, charIndex: NSUInteger): NSRect;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits(glyphsRange: NSRange, glyphBuffer: NSGlyph, charIndexBuffer: NSUInteger, inscribeBuffer: NSGlyphInscription, elasticBuffer: boolean): NSUInteger;

  static sharedTypesetter(): NSATSTypesetter;
  usesFontLeading(): boolean;
  setUsesFontLeading(usesFontLeading: boolean): void;
  typesetterBehavior(): NSTypesetterBehavior;
  setTypesetterBehavior(typesetterBehavior: NSTypesetterBehavior): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  lineFragmentPadding(): CGFloat;
  setLineFragmentPadding(lineFragmentPadding: CGFloat): void;
  bidiProcessingEnabled(): boolean;
  setBidiProcessingEnabled(bidiProcessingEnabled: boolean): void;
  attributedString(): NSAttributedString;
  setAttributedString(attributedString: NSAttributedString): void;
  paragraphGlyphRange(): NSRange;
  paragraphSeparatorGlyphRange(): NSRange;
  layoutManager(): NSLayoutManager;
  currentTextContainer(): NSTextContainer;
}

class NSWorkspaceAllocator<T extends NSWorkspace> extends NSObjectAllocator<T> {}
declare class NSWorkspace extends NSObject {
  alloc<T extends NSWorkspace>(): NSWorkspaceAllocator<T>;
  openFile(fullPath: NSString | string): boolean;
  openFile_withApplication(fullPath: NSString | string, appName: NSString | string | null): boolean;
  openFile_withApplication_andDeactivate(fullPath: NSString | string, appName: NSString | string | null, flag: boolean): boolean;
  openURL(url: NSURL): boolean;
  launchApplication(appName: NSString | string): boolean;
  launchApplicationAtURL_options_configuration_error(url: NSURL, options: NSWorkspaceLaunchOptions, configuration: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSRunningApplication;
  openURL_options_configuration_error(url: NSURL, options: NSWorkspaceLaunchOptions, configuration: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSRunningApplication;
  openURLs_withApplicationAtURL_options_configuration_error(urls: NSArray<any> | any[], applicationURL: NSURL, options: NSWorkspaceLaunchOptions, configuration: NSDictionary<any, any> | {[key: string]: any}, error: NSError): NSRunningApplication;
  launchApplication_showIcon_autolaunch(appName: NSString | string, showIcon: boolean, autolaunch: boolean): boolean;
  fullPathForApplication(appName: NSString | string): NSString;
  selectFile_inFileViewerRootedAtPath(fullPath: NSString | string | null, rootFullPath: NSString | string): boolean;
  activateFileViewerSelectingURLs(fileURLs: NSArray<any> | any[]): void;
  showSearchResultsForQueryString(queryString: NSString | string): boolean;
  noteFileSystemChanged(path: NSString | string): void;
  getInfoForFile_application_type(fullPath: NSString | string, appName: NSString | string, type: NSString | string): boolean;
  isFilePackageAtPath(fullPath: NSString | string): boolean;
  iconForFile(fullPath: NSString | string): NSImage;
  iconForFiles(fullPaths: NSArray<any> | any[]): NSImage;
  iconForFileType(fileType: NSString | string): NSImage;
  setIcon_forFile_options(image: NSImage | null, fullPath: NSString | string, options: NSWorkspaceIconCreationOptions): boolean;
  recycleURLs_completionHandler(URLs: NSArray<any> | any[], handler: Block): void;
  duplicateURLs_completionHandler(URLs: NSArray<any> | any[], handler: Block): void;
  getFileSystemInfoForPath_isRemovable_isWritable_isUnmountable_description_type(fullPath: NSString | string, removableFlag: boolean | null, writableFlag: boolean | null, unmountableFlag: boolean | null, description: NSString | string, fileSystemType: NSString | string): boolean;
  unmountAndEjectDeviceAtPath(path: NSString | string): boolean;
  unmountAndEjectDeviceAtURL_error(url: NSURL, error: NSError): boolean;
  extendPowerOffBy(requested: NSInteger): NSInteger;
  hideOtherApplications(): void;
  URLForApplicationWithBundleIdentifier(bundleIdentifier: NSString | string): NSURL;
  URLForApplicationToOpenURL(url: NSURL): NSURL;
  absolutePathForAppBundleWithIdentifier(bundleIdentifier: NSString | string): NSString;
  launchAppWithBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifier(bundleIdentifier: NSString | string, options: NSWorkspaceLaunchOptions, descriptor: NSAppleEventDescriptor | null, identifier: NSNumber | number): boolean;
  openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers(urls: NSArray<any> | any[], bundleIdentifier: NSString | string | null, options: NSWorkspaceLaunchOptions, descriptor: NSAppleEventDescriptor | null, identifiers: NSArray<any> | any[]): boolean;
  typeOfFile_error(absoluteFilePath: NSString | string, outError: NSError): NSString;
  localizedDescriptionForType(typeName: NSString | string): NSString;
  preferredFilenameExtensionForType(typeName: NSString | string): NSString;
  filenameExtension_isValidForType(filenameExtension: NSString | string, typeName: NSString | string): boolean;
  type_conformsToType(firstTypeName: NSString | string, secondTypeName: NSString | string): boolean;
  setDesktopImageURL_forScreen_options_error(url: NSURL, screen: NSScreen, options: NSDictionary<any, any> | {[key: string]: any}, error: NSError): boolean;
  desktopImageURLForScreen(screen: NSScreen): NSURL;
  desktopImageOptionsForScreen(screen: NSScreen): NSDictionary<any, any>;
  openTempFile(fullPath: NSString | string): boolean;
  findApplications(): void;
  noteUserDefaultsChanged(): void;
  slideImage_from_to(image: NSImage, fromPoint: NSPoint, toPoint: NSPoint): void;
  checkForRemovableMedia(): void;
  noteFileSystemChanged(): void;
  fileSystemChanged(): boolean;
  userDefaultsChanged(): boolean;
  mountNewRemovableMedia(): NSArray<any>;
  activeApplication(): NSDictionary<any, any>;
  mountedLocalVolumePaths(): NSArray<any>;
  mountedRemovableMedia(): NSArray<any>;
  launchedApplications(): NSArray<any>;
  openFile_fromImage_at_inView(fullPath: NSString | string, image: NSImage | null, point: NSPoint, view: NSView | null): boolean;
  performFileOperation_source_destination_files_tag(operation: NSWorkspaceFileOperationName, source: NSString | string, destination: NSString | string, files: NSArray<any> | any[], tag: NSInteger | null): boolean;
  applicationSupportDirectory(): NSString;
  setApplicationSupportDirectory(path: NSString | string): void;
  applicationSupportDirectoryWithSubDirectory_createIfNeeded(directoryName: NSString | string, create: boolean): NSString;
  sharedApplicationSupportDirectory(): NSString;
  openCloudURLByAuthenticating(url: NSURL): void;

  accessibilityDisplayShouldIncreaseContrast(): boolean;
  accessibilityDisplayShouldDifferentiateWithoutColor(): boolean;
  accessibilityDisplayShouldReduceTransparency(): boolean;
  accessibilityDisplayShouldReduceMotion(): boolean;
  accessibilityDisplayShouldInvertColors(): boolean;
  voiceOverEnabled(): boolean;
  switchControlEnabled(): boolean;
  runningApplications(): NSArray<any>;
  static sharedWorkspace(): NSWorkspace;
  notificationCenter(): NSNotificationCenter;
  fileLabels(): NSArray<any>;
  fileLabelColors(): NSArray<any>;
  frontmostApplication(): NSRunningApplication;
  menuBarOwningApplication(): NSRunningApplication;
}

declare type NSAccessibilityAttributeName = NSString

declare type NSAccessibilityParameterizedAttributeName = NSString

declare type NSAccessibilityAnnotationAttributeKey = NSString

declare type NSAccessibilityFontAttributeKey = NSString

declare type NSAccessibilityOrientationValue = NSString

declare type NSAccessibilitySortDirectionValue = NSString

declare type NSAccessibilityRulerMarkerTypeValue = NSString

declare type NSAccessibilityRulerUnitValue = NSString

declare type NSAccessibilityActionName = NSString

declare type NSAccessibilityNotificationName = NSString

declare type NSAccessibilityRole = NSString

declare type NSAccessibilitySubrole = NSString

declare type NSAccessibilityNotificationUserInfoKey = NSString

declare type NSAccessibilityLoadingToken = any

declare enum NSAccessibilityAnnotationPosition {
  NSAccessibilityAnnotationPositionFullRange,
  NSAccessibilityAnnotationPositionStart,
  NSAccessibilityAnnotationPositionEnd,
}

declare enum NSAccessibilityOrientation {
  NSAccessibilityOrientationUnknown = 0,
  NSAccessibilityOrientationVertical = 1,
  NSAccessibilityOrientationHorizontal = 2,
}

declare enum NSAccessibilitySortDirection {
  NSAccessibilitySortDirectionUnknown = 0,
  NSAccessibilitySortDirectionAscending = 1,
  NSAccessibilitySortDirectionDescending = 2,
}

declare enum NSAccessibilityRulerMarkerType {
  NSAccessibilityRulerMarkerTypeUnknown = 0,
  NSAccessibilityRulerMarkerTypeTabStopLeft = 1,
  NSAccessibilityRulerMarkerTypeTabStopRight = 2,
  NSAccessibilityRulerMarkerTypeTabStopCenter = 3,
  NSAccessibilityRulerMarkerTypeTabStopDecimal = 4,
  NSAccessibilityRulerMarkerTypeIndentHead = 5,
  NSAccessibilityRulerMarkerTypeIndentTail = 6,
  NSAccessibilityRulerMarkerTypeIndentFirstLine = 7,
}

declare enum NSAccessibilityUnits {
  NSAccessibilityUnitsUnknown = 0,
  NSAccessibilityUnitsInches = 1,
  NSAccessibilityUnitsCentimeters = 2,
  NSAccessibilityUnitsPoints = 3,
  NSAccessibilityUnitsPicas = 4,
}

declare enum NSAccessibilityPriorityLevel {
  NSAccessibilityPriorityLow = 10,
  NSAccessibilityPriorityMedium = 50,
  NSAccessibilityPriorityHigh = 90,
}

class NSAccessibilityCustomActionAllocator<T extends NSAccessibilityCustomAction> extends NSObjectAllocator<T> {
  initWithName_handler(name: NSString | string, handler: Block): T;
  initWithName_target_selector(name: NSString | string, target: any, selector: string): T;
}
declare class NSAccessibilityCustomAction extends NSObject {
  alloc<T extends NSAccessibilityCustomAction>(): NSAccessibilityCustomActionAllocator<T>;

  name(): NSString;
  setName(name: NSString | string): void;
  target(): any;
  setTarget(target: any): void;
  selector(): string;
  setSelector(selector: string): void;
}

class NSAccessibilityCustomRotorAllocator<T extends NSAccessibilityCustomRotor> extends NSObjectAllocator<T> {
  initWithLabel_itemSearchDelegate(label: NSString | string, itemSearchDelegate: any): T;
  initWithRotorType_itemSearchDelegate(rotorType: NSAccessibilityCustomRotorType, itemSearchDelegate: any): T;
}
declare class NSAccessibilityCustomRotor extends NSObject {
  alloc<T extends NSAccessibilityCustomRotor>(): NSAccessibilityCustomRotorAllocator<T>;

  type(): NSAccessibilityCustomRotorType;
  setType(type: NSAccessibilityCustomRotorType): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  itemSearchDelegate(): any;
  setItemSearchDelegate(itemSearchDelegate: any): void;
  itemLoadingDelegate(): any;
  setItemLoadingDelegate(itemLoadingDelegate: any): void;
}

class NSAccessibilityCustomRotorSearchParametersAllocator<T extends NSAccessibilityCustomRotorSearchParameters> extends NSObjectAllocator<T> {}
declare class NSAccessibilityCustomRotorSearchParameters extends NSObject {
  alloc<T extends NSAccessibilityCustomRotorSearchParameters>(): NSAccessibilityCustomRotorSearchParametersAllocator<T>;

  currentItem(): NSAccessibilityCustomRotorItemResult;
  setCurrentItem(currentItem: NSAccessibilityCustomRotorItemResult): void;
  searchDirection(): NSAccessibilityCustomRotorSearchDirection;
  setSearchDirection(searchDirection: NSAccessibilityCustomRotorSearchDirection): void;
  filterString(): NSString;
  setFilterString(filterString: NSString | string): void;
}

class NSAccessibilityCustomRotorItemResultAllocator<T extends NSAccessibilityCustomRotorItemResult> extends NSObjectAllocator<T> {
  initWithTargetElement(targetElement: any): T;
  initWithItemLoadingToken_customLabel(itemLoadingToken: NSAccessibilityLoadingToken, customLabel: NSString | string): T;
}
declare class NSAccessibilityCustomRotorItemResult extends NSObject {
  alloc<T extends NSAccessibilityCustomRotorItemResult>(): NSAccessibilityCustomRotorItemResultAllocator<T>;

  targetElement(): any;
  itemLoadingToken(): NSAccessibilityLoadingToken;
  targetRange(): NSRange;
  setTargetRange(targetRange: NSRange): void;
  customLabel(): NSString;
  setCustomLabel(customLabel: NSString | string): void;
}

declare interface INSAccessibilityCustomRotorItemSearchDelegate {
  rotor_resultForSearchParameters(rotor: NSAccessibilityCustomRotor, searchParameters: NSAccessibilityCustomRotorSearchParameters): NSAccessibilityCustomRotorItemResult;
}

declare enum NSAccessibilityCustomRotorSearchDirection {
  NSAccessibilityCustomRotorSearchDirectionPrevious,
  NSAccessibilityCustomRotorSearchDirectionNext,
}

declare enum NSAccessibilityCustomRotorType {
  NSAccessibilityCustomRotorTypeCustom = 0,
  NSAccessibilityCustomRotorTypeAny = 1,
  NSAccessibilityCustomRotorTypeAnnotation,
  NSAccessibilityCustomRotorTypeBoldText,
  NSAccessibilityCustomRotorTypeHeading,
  NSAccessibilityCustomRotorTypeHeadingLevel1,
  NSAccessibilityCustomRotorTypeHeadingLevel2,
  NSAccessibilityCustomRotorTypeHeadingLevel3,
  NSAccessibilityCustomRotorTypeHeadingLevel4,
  NSAccessibilityCustomRotorTypeHeadingLevel5,
  NSAccessibilityCustomRotorTypeHeadingLevel6,
  NSAccessibilityCustomRotorTypeImage,
  NSAccessibilityCustomRotorTypeItalicText,
  NSAccessibilityCustomRotorTypeLandmark,
  NSAccessibilityCustomRotorTypeLink,
  NSAccessibilityCustomRotorTypeList,
  NSAccessibilityCustomRotorTypeMisspelledWord,
  NSAccessibilityCustomRotorTypeTable,
  NSAccessibilityCustomRotorTypeTextField,
  NSAccessibilityCustomRotorTypeUnderlinedText,
  NSAccessibilityCustomRotorTypeVisitedLink,
}

class NSAccessibilityElementAllocator<T extends NSAccessibilityElement> extends NSObjectAllocator<T> {}
declare class NSAccessibilityElement extends NSObject implements INSAccessibility {
  alloc<T extends NSAccessibilityElement>(): NSAccessibilityElementAllocator<T>;
  static accessibilityElementWithRole_frame_label_parent(role: NSAccessibilityRole, frame: NSRect, label: NSString | string | null, parent: any | null): any;
  accessibilityAddChildElement(childElement: NSAccessibilityElement): void;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  accessibilityFrameInParentSpace(): NSRect;
  setAccessibilityFrameInParentSpace(accessibilityFrameInParentSpace: NSRect): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare interface INSAccessibilityElement {
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
}

declare interface INSAccessibilityGroup {
}

declare interface INSAccessibilityButton {
  accessibilityLabel(): NSString;
  accessibilityPerformPress(): boolean;
}

declare interface INSAccessibilitySwitch {
  accessibilityValue(): NSString;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
}

declare interface INSAccessibilityRadioButton {
  accessibilityValue(): NSNumber;
}

declare interface INSAccessibilityCheckBox {
  accessibilityValue(): NSNumber;
}

declare interface INSAccessibilityStaticText {
  accessibilityValue(): NSString;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityVisibleCharacterRange(): NSRange;
}

declare interface INSAccessibilityNavigableStaticText {
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityRangeForLine(lineNumber: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
}

declare interface INSAccessibilityProgressIndicator {
  accessibilityValue(): NSNumber;
}

declare interface INSAccessibilityStepper {
  accessibilityLabel(): NSString;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityValue(): any;
}

declare interface INSAccessibilitySlider {
  accessibilityLabel(): NSString;
  accessibilityValue(): any;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
}

declare interface INSAccessibilityImage {
  accessibilityLabel(): NSString;
}

declare interface INSAccessibilityContainsTransientUI {
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  isAccessibilityAlternateUIVisible(): boolean;
}

declare interface INSAccessibilityOutline {
}

declare interface INSAccessibilityList {
}

declare interface INSAccessibilityRow {
  accessibilityIndex(): NSInteger;
  accessibilityDisclosureLevel(): NSInteger;
}

declare interface INSAccessibilityLayoutArea {
  accessibilityLabel(): NSString;
  accessibilityChildren(): NSArray<any>;
  accessibilitySelectedChildren(): NSArray<any>;

  accessibilityFocusedUIElement(): any;
}

declare interface INSAccessibilityLayoutItem {
  setAccessibilityFrame(frame: NSRect): void;
}

declare interface INSAccessibilityElementLoading {
  accessibilityElementWithToken(token: NSAccessibilityLoadingToken): any;
  accessibilityRangeInTargetElementWithToken(token: NSAccessibilityLoadingToken): NSRange;
}

declare interface INSAccessibility {
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

class NSActionCellAllocator<T extends NSActionCell> extends NSCellAllocator<T> {}
declare class NSActionCell extends NSCell {
  alloc<T extends NSActionCell>(): NSActionCellAllocator<T>;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
}

class NSAlertAllocator<T extends NSAlert> extends NSObjectAllocator<T> {}
declare class NSAlert extends NSObject {
  alloc<T extends NSAlert>(): NSAlertAllocator<T>;
  static alertWithError(error: NSError): NSAlert;
  addButtonWithTitle(title: NSString | string): NSButton;
  layout(): void;
  runModal(): NSModalResponse;
  beginSheetModalForWindow_completionHandler(sheetWindow: NSWindow, handler: Block): void;
  static alertWithMessageText_defaultButton_alternateButton_otherButton_informativeTextWithFormat(message: NSString | string | null, defaultButton: NSString | string | null, alternateButton: NSString | string | null, otherButton: NSString | string | null, format: NSString | string, ...args: any[]): NSAlert;
  beginSheetModalForWindow_modalDelegate_didEndSelector_contextInfo(window: NSWindow, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  static runModalWithMessage_info(message: NSString | string, info: NSString | string): NSModalResponse;
  static runSheetWithMessage_info(message: NSString | string, info: NSString | string): void;
  static runModalWithMessage_info_buttons(message: NSString | string, info: NSString | string, buttons: NSArray<any> | any[]): NSModalResponse;
  static runModalSessionWithMessage_info_buttons(message: NSString | string, info: NSString | string, buttons: NSArray<any> | any[]): NSModalResponse;
  static alertWithMessage_info_buttons(message: NSString | string, info: NSString | string, buttons: NSArray<any> | any[]): NSAlert;
  static runConfirmationSheetWithLocalizedStrings_completionBlock(dialogPrefix: NSString | string, block: BCVoidBlock): void;
  static runConfirmationSheetWithLocalizedStrings_withSuppressionButton_completionBlock(dialogPrefix: NSString | string, showSuppressionButton: boolean, block: BCVoidBlock): void;
  static runConfirmationSheetWithLocalizedStrings_format_withSuppressionButton_completionBlock(dialogPrefix: NSString | string, format: NSString | string, showSuppressionButton: boolean, block: BCVoidBlock): void;

  messageText(): NSString;
  setMessageText(messageText: NSString | string): void;
  informativeText(): NSString;
  setInformativeText(informativeText: NSString | string): void;
  icon(): NSImage;
  setIcon(icon: NSImage): void;
  buttons(): NSArray<any>;
  showsHelp(): boolean;
  setShowsHelp(showsHelp: boolean): void;
  helpAnchor(): NSHelpAnchorName;
  setHelpAnchor(helpAnchor: NSHelpAnchorName): void;
  alertStyle(): NSAlertStyle;
  setAlertStyle(alertStyle: NSAlertStyle): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  showsSuppressionButton(): boolean;
  setShowsSuppressionButton(showsSuppressionButton: boolean): void;
  suppressionButton(): NSButton;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  window(): NSWindow;
}

declare interface INSAlertDelegate {
  alertShowHelp(alert: NSAlert): boolean;
}

declare enum NSAlertStyle {
  NSAlertStyleWarning = 0,
  NSAlertStyleInformational = 1,
  NSAlertStyleCritical = 2,
}

class NSAlignmentFeedbackFilterAllocator<T extends NSAlignmentFeedbackFilter> extends NSObjectAllocator<T> {}
declare class NSAlignmentFeedbackFilter extends NSObject {
  alloc<T extends NSAlignmentFeedbackFilter>(): NSAlignmentFeedbackFilterAllocator<T>;
  updateWithEvent(event: NSEvent): void;
  updateWithPanRecognizer(panRecognizer: NSPanGestureRecognizer): void;
  alignmentFeedbackTokenForMovementInView_previousPoint_alignedPoint_defaultPoint(view: NSView | null, previousPoint: NSPoint, alignedPoint: NSPoint, defaultPoint: NSPoint): any;
  alignmentFeedbackTokenForHorizontalMovementInView_previousX_alignedX_defaultX(view: NSView | null, previousX: CGFloat, alignedX: CGFloat, defaultX: CGFloat): any;
  alignmentFeedbackTokenForVerticalMovementInView_previousY_alignedY_defaultY(view: NSView | null, previousY: CGFloat, alignedY: CGFloat, defaultY: CGFloat): any;
  performFeedback_performanceTime(alignmentFeedbackTokens: NSArray<any> | any[], performanceTime: NSHapticFeedbackPerformanceTime): void;

  static inputEventMask(): NSEventMask;
}

declare interface INSAlignmentFeedbackToken {
}

class NSAnimationAllocator<T extends NSAnimation> extends NSObjectAllocator<T> {
  initWithDuration_animationCurve(duration: NSTimeInterval, animationCurve: NSAnimationCurve): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSAnimation extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSAnimation>(): NSAnimationAllocator<T>;
  startAnimation(): void;
  stopAnimation(): void;
  addProgressMark(progressMark: NSAnimationProgress): void;
  removeProgressMark(progressMark: NSAnimationProgress): void;
  startWhenAnimation_reachesProgress(animation: NSAnimation, startProgress: NSAnimationProgress): void;
  stopWhenAnimation_reachesProgress(animation: NSAnimation, stopProgress: NSAnimationProgress): void;
  clearStartAnimation(): void;
  clearStopAnimation(): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  animating(): boolean;
  currentProgress(): NSAnimationProgress;
  setCurrentProgress(currentProgress: NSAnimationProgress): void;
  duration(): NSTimeInterval;
  setDuration(duration: NSTimeInterval): void;
  animationBlockingMode(): NSAnimationBlockingMode;
  setAnimationBlockingMode(animationBlockingMode: NSAnimationBlockingMode): void;
  frameRate(): number;
  setFrameRate(frameRate: number): void;
  animationCurve(): NSAnimationCurve;
  setAnimationCurve(animationCurve: NSAnimationCurve): void;
  currentValue(): number;
  delegate(): any;
  setDelegate(delegate: any): void;
  progressMarks(): NSArray<any>;
  setProgressMarks(progressMarks: NSArray<any> | any[]): void;
  runLoopModesForAnimating(): NSArray<any>;
}

class NSViewAnimationAllocator<T extends NSViewAnimation> extends NSAnimationAllocator<T> {
  initWithViewAnimations(viewAnimations: NSArray<any> | any[]): T;
}
declare class NSViewAnimation extends NSAnimation {
  alloc<T extends NSViewAnimation>(): NSViewAnimationAllocator<T>;

  viewAnimations(): NSArray<any>;
  setViewAnimations(viewAnimations: NSArray<any> | any[]): void;
}

declare interface INSAnimationDelegate {
  animationShouldStart(animation: NSAnimation): boolean;
  animationDidStop(animation: NSAnimation): void;
  animationDidEnd(animation: NSAnimation): void;
  animation_valueForProgress(animation: NSAnimation, progress: NSAnimationProgress): number;
  animation_didReachProgressMark(animation: NSAnimation, progress: NSAnimationProgress): void;
}

declare interface INSAnimatablePropertyContainer {
  animator(): INSAnimatablePropertyContainer;
  animationForKey(key: NSAnimatablePropertyKey): any;

  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
}

declare type NSAnimationProgress = number

declare type NSViewAnimationKey = NSString

declare type NSViewAnimationEffectName = NSString

declare type NSAnimatablePropertyKey = NSString

declare enum NSAnimationCurve {
  NSAnimationEaseInOut,
  NSAnimationEaseIn,
  NSAnimationEaseOut,
  NSAnimationLinear,
}

declare enum NSAnimationBlockingMode {
  NSAnimationBlocking,
  NSAnimationNonblocking,
  NSAnimationNonblockingThreaded,
}

class NSAnimationContextAllocator<T extends NSAnimationContext> extends NSObjectAllocator<T> {}
declare class NSAnimationContext extends NSObject {
  alloc<T extends NSAnimationContext>(): NSAnimationContextAllocator<T>;
  static runAnimationGroup_completionHandler(changes: Block, completionHandler: Block | null): void;
  static beginGrouping(): void;
  static endGrouping(): void;

  static currentContext(): NSAnimationContext;
  duration(): NSTimeInterval;
  setDuration(duration: NSTimeInterval): void;
  timingFunction(): CAMediaTimingFunction;
  setTimingFunction(timingFunction: CAMediaTimingFunction): void;
  allowsImplicitAnimation(): boolean;
  setAllowsImplicitAnimation(allowsImplicitAnimation: boolean): void;
}

class NSAppearanceAllocator<T extends NSAppearance> extends NSObjectAllocator<T> {
  initWithAppearanceNamed_bundle(name: NSAppearanceName, bundle: NSBundle | null): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSAppearance extends NSObject implements INSCoding {
  alloc<T extends NSAppearance>(): NSAppearanceAllocator<T>;
  static appearanceNamed(name: NSAppearanceName): NSAppearance;
  static sketchDefaultDarkAppearance(): NSAppearance;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  name(): NSAppearanceName;
  static currentAppearance(): NSAppearance;
  static setCurrentAppearance(currentAppearance: NSAppearance): void;
  allowsVibrancy(): boolean;
  isDark_bc(): boolean;
}

declare interface INSAppearanceCustomization {

  appearance(): NSAppearance;
  setAppearance(appearance: NSAppearance): void;
  effectiveAppearance(): NSAppearance;
}

declare type NSAppearanceName = NSString

class NSApplicationAllocator<T extends NSApplication> extends NSResponderAllocator<T> {}
declare class NSApplication extends NSResponder implements INSUserInterfaceValidations, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSApplication>(): NSApplicationAllocator<T>;
  hide(sender: any | null): void;
  unhide(sender: any | null): void;
  unhideWithoutActivation(): void;
  windowWithWindowNumber(windowNum: NSInteger): NSWindow;
  deactivate(): void;
  activateIgnoringOtherApps(flag: boolean): void;
  hideOtherApplications(sender: any | null): void;
  unhideAllApplications(sender: any | null): void;
  finishLaunching(): void;
  run(): void;
  runModalForWindow(window: NSWindow): NSModalResponse;
  stop(sender: any | null): void;
  stopModal(): void;
  stopModalWithCode(returnCode: NSModalResponse): void;
  abortModal(): void;
  beginModalSessionForWindow(window: NSWindow): NSModalSession;
  runModalSession(session: NSModalSession): NSModalResponse;
  endModalSession(session: NSModalSession): void;
  terminate(sender: any | null): void;
  requestUserAttention(requestType: NSRequestUserAttentionType): NSInteger;
  cancelUserAttentionRequest(request: NSInteger): void;
  enumerateWindowsWithOptions_usingBlock(options: NSWindowListOptions, block: Block): void;
  preventWindowOrdering(): void;
  setWindowsNeedUpdate(needUpdate: boolean): void;
  updateWindows(): void;
  activationPolicy(): NSApplicationActivationPolicy;
  setActivationPolicy(activationPolicy: NSApplicationActivationPolicy): boolean;
  reportException(exception: NSException | Error): void;
  static detachDrawingThread_toTarget_withObject(selector: string, target: any, argument: any | null): void;
  replyToApplicationShouldTerminate(shouldTerminate: boolean): void;
  replyToOpenOrPrint(reply: NSApplicationDelegateReply): void;
  orderFrontCharacterPalette(sender: any | null): void;
  sendEvent(event: NSEvent): void;
  postEvent_atStart(event: NSEvent, flag: boolean): void;
  nextEventMatchingMask_untilDate_inMode_dequeue(mask: NSUInteger, expiration: NSDate | null, mode: NSRunLoopMode, deqFlag: boolean): NSEvent;
  discardEventsMatchingMask_beforeEvent(mask: NSUInteger, lastEvent: NSEvent | null): void;
  sendAction_to_from(action: string, target: any | null, sender: any | null): boolean;
  targetForAction(action: string): any;
  targetForAction_to_from(action: string, target: any | null, sender: any | null): any;
  tryToPerform_with(action: string, object: any | null): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  arrangeInFront(sender: any | null): void;
  removeWindowsItem(win: NSWindow): void;
  addWindowsItem_title_filename(win: NSWindow, string: NSString | string, isFilename: boolean): void;
  changeWindowsItem_title_filename(win: NSWindow, string: NSString | string, isFilename: boolean): void;
  updateWindowsItem(win: NSWindow): void;
  miniaturizeAll(sender: any | null): void;
  registerServicesMenuSendTypes_returnTypes(sendTypes: NSArray<any> | any[], returnTypes: NSArray<any> | any[]): void;
  orderFrontStandardAboutPanel(sender: any | null): void;
  orderFrontStandardAboutPanelWithOptions(optionsDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  disableRelaunchOnLogin(): void;
  enableRelaunchOnLogin(): void;
  registerForRemoteNotificationTypes(types: NSRemoteNotificationType): void;
  unregisterForRemoteNotifications(): void;
  runModalForWindow_relativeToWindow(window: NSWindow, docWindow: NSWindow): NSInteger;
  beginModalSessionForWindow_relativeToWindow(window: NSWindow, docWindow: NSWindow): NSModalSession;
  application_printFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(sheet: NSWindow, docWindow: NSWindow, modalDelegate: any | null, didEndSelector: string | null, contextInfo: void): void;
  endSheet(sheet: NSWindow): void;
  endSheet_returnCode(sheet: NSWindow, returnCode: NSInteger): void;
  makeWindowsPerform_inOrder(selector: string, flag: boolean): NSWindow;
  orderFrontColorPanel(sender: any | null): void;
  activateContextHelpMode(sender: any | null): void;
  showHelp(sender: any | null): void;
  runPageLayout(sender: any | null): void;
  toggleTouchBarCustomizationPalette(sender: any | null): IBAction;
  registerUserInterfaceItemSearchHandler(handler: any): void;
  unregisterUserInterfaceItemSearchHandler(handler: any): void;
  searchString_inUserInterfaceItemString_searchRange_foundRange(searchString: NSString | string, stringToSearch: NSString | string, searchRange: NSRange, foundRange: NSRange | null): boolean;
  restoreWindowWithIdentifier_state_completionHandler(identifier: NSUserInterfaceItemIdentifier, state: NSCoder, completionHandler: Block): boolean;
  extendStateRestoration(): void;
  completeStateRestoration(): void;
  applicationName(): NSString;
  applicationVersion(): NSString;
  applicationBuild(): NSString;
  isActiveApplication(): boolean;
  open(pathToFile: NSString | string): any;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  static sharedApplication(): NSApplication;
  delegate(): any;
  setDelegate(delegate: any): void;
  mainWindow(): NSWindow;
  keyWindow(): NSWindow;
  active(): boolean;
  hidden(): boolean;
  running(): boolean;
  modalWindow(): NSWindow;
  windows(): NSArray<any>;
  mainMenu(): NSMenu;
  setMainMenu(mainMenu: NSMenu): void;
  helpMenu(): NSMenu;
  setHelpMenu(helpMenu: NSMenu): void;
  applicationIconImage(): NSImage;
  setApplicationIconImage(applicationIconImage: NSImage): void;
  dockTile(): NSDockTile;
  presentationOptions(): NSApplicationPresentationOptions;
  setPresentationOptions(presentationOptions: NSApplicationPresentationOptions): void;
  currentSystemPresentationOptions(): NSApplicationPresentationOptions;
  occlusionState(): NSApplicationOcclusionState;
  currentEvent(): NSEvent;
  windowsMenu(): NSMenu;
  setWindowsMenu(windowsMenu: NSMenu): void;
  fullKeyboardAccessEnabled(): boolean;
  servicesMenu(): NSMenu;
  setServicesMenu(servicesMenu: NSMenu): void;
  servicesProvider(): any;
  setServicesProvider(servicesProvider: any): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  enabledRemoteNotificationTypes(): NSRemoteNotificationType;
  context(): NSGraphicsContext;
  orderedDocuments(): NSArray<any>;
  orderedWindows(): NSArray<any>;
  automaticCustomizeTouchBarMenuItemEnabled(): boolean;
  setAutomaticCustomizeTouchBarMenuItemEnabled(automaticCustomizeTouchBarMenuItemEnabled: boolean): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare interface INSApplicationDelegate {
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
}

declare interface INSServicesMenuRequestor {
  writeSelectionToPasteboard_types(pboard: NSPasteboard, types: NSArray<any> | any[]): boolean;
  readSelectionFromPasteboard(pboard: NSPasteboard): boolean;
}

declare type NSAppKitVersion = number

declare type NSModalResponse = NSInteger

declare type NSModalSession = any

declare type NSAboutPanelOptionKey = NSString

declare type NSServiceProviderName = NSString

declare enum NSApplicationPresentationOptions {
  NSApplicationPresentationDefault = 0,
  NSApplicationPresentationAutoHideDock,
  NSApplicationPresentationHideDock,
  NSApplicationPresentationAutoHideMenuBar,
  NSApplicationPresentationHideMenuBar,
  NSApplicationPresentationDisableAppleMenu,
  NSApplicationPresentationDisableProcessSwitching,
  NSApplicationPresentationDisableForceQuit,
  NSApplicationPresentationDisableSessionTermination,
  NSApplicationPresentationDisableHideApplication,
  NSApplicationPresentationDisableMenuBarTransparency,
  NSApplicationPresentationFullScreen,
  NSApplicationPresentationAutoHideToolbar,
  NSApplicationPresentationDisableCursorLocationAssistance,
}

declare enum NSApplicationOcclusionState {
  NSApplicationOcclusionStateVisible = 1 << 1,
}

declare enum NSWindowListOptions {
  NSWindowListOrderedFrontToBack,
}

declare enum NSRequestUserAttentionType {
  NSCriticalRequest = 0,
  NSInformationalRequest = 10,
}

declare enum NSApplicationDelegateReply {
  NSApplicationDelegateReplySuccess = 0,
  NSApplicationDelegateReplyCancel = 1,
  NSApplicationDelegateReplyFailure = 2,
}

declare enum NSApplicationTerminateReply {
  NSTerminateCancel = 0,
  NSTerminateNow = 1,
  NSTerminateLater = 2,
}

declare enum NSApplicationPrintReply {
  NSPrintingCancelled = 0,
  NSPrintingSuccess = 1,
  NSPrintingFailure = 3,
  NSPrintingReplyLater = 2,
}

declare enum NSRemoteNotificationType {
  NSRemoteNotificationTypeNone = 0,
  NSRemoteNotificationTypeBadge = 1 << 0,
  NSRemoteNotificationTypeSound = 1 << 1,
  NSRemoteNotificationTypeAlert = 1 << 2,
}

class NSArrayControllerAllocator<T extends NSArrayController> extends NSObjectControllerAllocator<T> {}
declare class NSArrayController extends NSObjectController {
  alloc<T extends NSArrayController>(): NSArrayControllerAllocator<T>;
  rearrangeObjects(): void;
  didChangeArrangementCriteria(): void;
  arrangeObjects(objects: NSArray<any> | any[]): NSArray<any>;
  setSelectionIndexes(indexes: NSIndexSet): boolean;
  setSelectionIndex(index: NSUInteger): boolean;
  addSelectionIndexes(indexes: NSIndexSet): boolean;
  removeSelectionIndexes(indexes: NSIndexSet): boolean;
  setSelectedObjects(objects: NSArray<any> | any[]): boolean;
  addSelectedObjects(objects: NSArray<any> | any[]): boolean;
  removeSelectedObjects(objects: NSArray<any> | any[]): boolean;
  add(sender: any | null): IBAction;
  remove(sender: any | null): IBAction;
  insert(sender: any | null): IBAction;
  selectNext(sender: any | null): IBAction;
  selectPrevious(sender: any | null): IBAction;
  addObject(object: any): void;
  addObjects(objects: NSArray<any> | any[]): void;
  insertObject_atArrangedObjectIndex(object: any, index: NSUInteger): void;
  insertObjects_atArrangedObjectIndexes(objects: NSArray<any> | any[], indexes: NSIndexSet): void;
  removeObjectAtArrangedObjectIndex(index: NSUInteger): void;
  removeObjectsAtArrangedObjectIndexes(indexes: NSIndexSet): void;
  removeObject(object: any): void;
  removeObjects(objects: NSArray<any> | any[]): void;

  automaticallyRearrangesObjects(): boolean;
  setAutomaticallyRearrangesObjects(automaticallyRearrangesObjects: boolean): void;
  automaticRearrangementKeyPaths(): NSArray<any>;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  filterPredicate(): NSPredicate;
  setFilterPredicate(filterPredicate: NSPredicate): void;
  clearsFilterPredicateOnInsertion(): boolean;
  setClearsFilterPredicateOnInsertion(clearsFilterPredicateOnInsertion: boolean): void;
  arrangedObjects(): any;
  avoidsEmptySelection(): boolean;
  setAvoidsEmptySelection(avoidsEmptySelection: boolean): void;
  preservesSelection(): boolean;
  setPreservesSelection(preservesSelection: boolean): void;
  selectsInsertedObjects(): boolean;
  setSelectsInsertedObjects(selectsInsertedObjects: boolean): void;
  alwaysUsesMultipleValuesMarker(): boolean;
  setAlwaysUsesMultipleValuesMarker(alwaysUsesMultipleValuesMarker: boolean): void;
  selectionIndexes(): NSIndexSet;
  selectionIndex(): NSUInteger;
  selectedObjects(): NSArray<any>;
  canInsert(): boolean;
  canSelectNext(): boolean;
  canSelectPrevious(): boolean;
}

declare type NSTextEffectStyle = NSString

declare type NSAttributedStringDocumentType = NSString

declare type NSTextLayoutSectionKey = NSString

declare type NSAttributedStringDocumentAttributeKey = NSString

declare type NSAttributedStringDocumentReadingOptionKey = NSString

declare enum NSUnderlineStyle {
  NSUnderlineStyleNone = 0x00,
  NSUnderlineStyleSingle = 0x01,
  NSUnderlineStyleThick = 0x02,
  NSUnderlineStyleDouble = 0x09,
  NSUnderlinePatternSolid = 0x0000,
  NSUnderlinePatternDot = 0x0100,
  NSUnderlinePatternDash = 0x0200,
  NSUnderlinePatternDashDot = 0x0300,
  NSUnderlinePatternDashDotDot = 0x0400,
  NSUnderlineByWord = 0x8000,
}

declare enum NSWritingDirectionFormatType {
  NSWritingDirectionEmbedding,
  NSWritingDirectionOverride,
}

declare enum NSSpellingState {
  NSSpellingStateSpellingFlag,
  NSSpellingStateGrammarFlag,
}

class NSBezierPathAllocator<T extends NSBezierPath> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSBezierPath extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSBezierPath>(): NSBezierPathAllocator<T>;
  static bezierPath(): NSBezierPath;
  static bezierPathWithRect(rect: NSRect): NSBezierPath;
  static bezierPathWithOvalInRect(rect: NSRect): NSBezierPath;
  static bezierPathWithRoundedRect_xRadius_yRadius(rect: NSRect, xRadius: CGFloat, yRadius: CGFloat): NSBezierPath;
  static fillRect(rect: NSRect): void;
  static strokeRect(rect: NSRect): void;
  static clipRect(rect: NSRect): void;
  static strokeLineFromPoint_toPoint(point1: NSPoint, point2: NSPoint): void;
  static drawPackedGlyphs_atPoint(packedGlyphs: string, point: NSPoint): void;
  moveToPoint(point: NSPoint): void;
  lineToPoint(point: NSPoint): void;
  curveToPoint_controlPoint1_controlPoint2(endPoint: NSPoint, controlPoint1: NSPoint, controlPoint2: NSPoint): void;
  closePath(): void;
  removeAllPoints(): void;
  relativeMoveToPoint(point: NSPoint): void;
  relativeLineToPoint(point: NSPoint): void;
  relativeCurveToPoint_controlPoint1_controlPoint2(endPoint: NSPoint, controlPoint1: NSPoint, controlPoint2: NSPoint): void;
  getLineDash_count_phase(pattern: CGFloat | null, count: NSInteger | null, phase: CGFloat | null): void;
  setLineDash_count_phase(pattern: CGFloat | null, count: NSInteger, phase: CGFloat): void;
  stroke(): void;
  fill(): void;
  addClip(): void;
  setClip(): void;
  transformUsingAffineTransform(transform: NSAffineTransform): void;
  elementAtIndex_associatedPoints(index: NSInteger, points: NSPointArray | null): NSBezierPathElement;
  elementAtIndex(index: NSInteger): NSBezierPathElement;
  setAssociatedPoints_atIndex(points: NSPointArray | null, index: NSInteger): void;
  appendBezierPath(path: NSBezierPath): void;
  appendBezierPathWithRect(rect: NSRect): void;
  appendBezierPathWithPoints_count(points: NSPointArray, count: NSInteger): void;
  appendBezierPathWithOvalInRect(rect: NSRect): void;
  appendBezierPathWithArcWithCenter_radius_startAngle_endAngle_clockwise(center: NSPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: boolean): void;
  appendBezierPathWithArcWithCenter_radius_startAngle_endAngle(center: NSPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat): void;
  appendBezierPathWithArcFromPoint_toPoint_radius(point1: NSPoint, point2: NSPoint, radius: CGFloat): void;
  appendBezierPathWithCGGlyph_inFont(glyph: CGGlyph, font: NSFont): void;
  appendBezierPathWithCGGlyphs_count_inFont(glyphs: CGGlyph, count: NSInteger, font: NSFont): void;
  appendBezierPathWithRoundedRect_xRadius_yRadius(rect: NSRect, xRadius: CGFloat, yRadius: CGFloat): void;
  containsPoint(point: NSPoint): boolean;
  cachesBezierPath(): boolean;
  setCachesBezierPath(flag: boolean): void;
  appendBezierPathWithGlyph_inFont(glyph: NSGlyph, font: NSFont): void;
  appendBezierPathWithGlyphs_count_inFont(glyphs: NSGlyph, count: NSInteger, font: NSFont): void;
  appendBezierPathWithPackedGlyphs(packedGlyphs: string): void;
  static bezierPathWithCGPath(path: CGPathRef): NSBezierPath;
  strokeOutside(): void;
  strokeInside(): void;
  static bezierPathFromPoint_toPoint(p1: NSPoint, p2: NSPoint): NSBezierPath;
  static bezierCurveFromPoint_toPoint_controlPoint1_controlPoint2(from: NSPoint, to: NSPoint, cp1: NSPoint, cp2: NSPoint): NSBezierPath;
  outlinePath(): NSBezierPath;
  drawInnerShadow(shadow: NSShadow): void;
  bezierPathByGrowingBy(offset: CGFloat): NSBezierPath;
  bezierPathWithOuterPathOfSize(amount: CGFloat): NSBezierPath;
  safeBounds(): NSRect;
  isClosed(): boolean;
  clipInBlock(block: BCVoidBlock): void;
  writeDebugFileNamed(name: NSString | string): void;
  bezierPathByMakingClockwiseIfNecessary(): NSBezierPath;
  bezierPathByMakingAntiClockwiseIfNecessary(): NSBezierPath;
  subPathsOrderedBySizeAfterOutlining(): NSArray<any>;
  bezierPathByCurveFitting(): NSBezierPath;
  booleanOp_withPath(op: MSBooleanOperation, otherPath: NSBezierPath): NSBezierPath;
  booleanUnionWith(otherPath: NSBezierPath): NSBezierPath;
  booleanIntersectWith(otherPath: NSBezierPath): NSBezierPath;
  booleanSubtractWith(otherPath: NSBezierPath): NSBezierPath;
  booleanExclusiveOrWith(otherPath: NSBezierPath): NSBezierPath;
  bezierPathBySubtractingPaths(paths: NSArray<any> | any[]): NSBezierPath;
  debugScale_ms(): CGFloat;
  appendSquareAtPoint_ms_size_scale(point: NSPoint, size: CGFloat, scale: CGFloat): void;
  appendCircleAtPoint_ms_radius_scale(point: NSPoint, radius: CGFloat, scale: CGFloat): void;
  appendArrowAtPoint_ms_tangent_size_scale(point: NSPoint, tangent: MSLine, size: CGFloat, scale: CGFloat): void;
  enumerator(): any;
  reverseEnumerator(): any;
  itemAtIndex(index: NSInteger): any;
  lastItem(): any;
  appendBezierPathItem(item: any): void;
  bezierCurves(): NSArray<any>;
  customIsEqual(other: NSBezierPath): boolean;
  animatedGIFRepresentation_ms(): NSData;
  static bezierPathWithJSON_ms(json: any): NSBezierPath;
  static bezierPathWithJSONString_ms(json: NSString | string): NSBezierPath;
  JSONRepresetation_ms(): any;
  JSONDescription_ms(): NSString;
  static bezierPathWithPath(path: MSPath): NSBezierPath;
  lastPoint(): NSPoint;
  firstPoint(): NSPoint;
  slopeOnPathAtLength(length: CGFloat): CGFloat;
  pointOnPathAtLength(length: CGFloat): NSPoint;
  pointOnPathAtLength_slope(length: CGFloat, slope: CGFloat): NSPoint;
  bezierPathByTrimmingFromLength(trimLength: CGFloat): NSBezierPath;
  bezierPathByTrimmingFromLength_withMaximumError(trimLength: CGFloat, maxError: CGFloat): NSBezierPath;
  bezierPathByTrimmingToLength(trimLength: CGFloat): NSBezierPath;
  bezierPathByTrimmingToLength_withMaximumError(trimLength: CGFloat, maxError: CGFloat): NSBezierPath;
  bezierPathFromIndex_toIndex(from: NSUInteger, to: NSUInteger): NSBezierPath;
  length(): CGFloat;
  lengthWithMaximumError(maxError: CGFloat): CGFloat;
  appendBezierPathByRemovingMoveToPoint(path: NSBezierPath): void;
  isEqualToBezierPath(bezierPath: NSBezierPath): boolean;
  pointAtIndex(index: NSInteger): NSPoint;
  subDivideAtPoint(aPoint: NSPoint): NSArray<any>;
  bezierPathByApplyingModifierBlock(block: MSBezierPathModifierBlock): NSBezierPath;
  drawDebugWithZoom___unused(zoom: CGFloat): void;
  scaleBy(zoom: CGFloat): NSBezierPath;
  simplify(): NSBezierPath;
  simplifyWithMargin(margin: NSInteger): NSBezierPath;
  subPaths(): NSArray<any>;
  setDashPattern(dashPattern: NSArray<any> | any[]): void;
  static validDashLengthFromProposedDashLength(dashLength: CGFloat): CGFloat;
  static validDashPatternFromProposedDashPattern_padIfNeeded(proposed: NSArray<any> | any[], canPad: boolean): NSArray<any>;
  static impliedDashPatternFromDashPattern_paddingToLength(dashPattern: NSArray<any> | any[], length: NSUInteger): NSArray<any>;
  debugWriteToFileNamed(name: NSString | string): void;
  containsRect(rect: NSRect): boolean;
  outlinePathWithWidth(width: CGFloat): NSBezierPath;
  outlinePathWithWidth_containsPoint(width: CGFloat, point: NSPoint): boolean;
  insetPathBy(size: CGFloat): NSBezierPath;
  outerPathWithRect(rect: NSRect): NSBezierPath;
  bezierPathWithLineWidth(lineWidth: CGFloat): NSBezierPath;
  bezierPathWithSquareLineCapStyle(): NSBezierPath;
  fillNonZero(): void;
  strokeWithWidth(lineWidth: CGFloat): void;
  static bezierPathWithSubPaths(subPaths: NSArray<any> | any[]): NSBezierPath;
  static bezierPathFromSVGString(contents: NSString | string): NSBezierPath;
  addSVGArcWithAngle_radius_from_to_largeArc_sweep(angle: CGFloat, radius: NSSize, from: NSPoint, to: NSPoint, largeArcFlag: boolean, sweepFlag: boolean): void;
  svgPathAttribute(): NSXMLNode;
  fb_union(path: NSBezierPath): NSBezierPath;
  fb_intersect(path: NSBezierPath): NSBezierPath;
  fb_difference(path: NSBezierPath): NSBezierPath;
  fb_xor(path: NSBezierPath): NSBezierPath;
  fb_fitCurve(errorThreshold: CGFloat): NSBezierPath;
  fb_simplify(threshold: CGFloat): NSBezierPath;
  fb_pointAtIndex(index: NSUInteger): NSPoint;
  fb_elementAtIndex(index: NSUInteger): NSBezierElement;
  fb_subpathWithRange(range: NSRange): NSBezierPath;
  fb_copyAttributesFrom(path: NSBezierPath): void;
  fb_appendPath(path: NSBezierPath): void;
  fb_appendElement(element: NSBezierElement): void;
  static bezierPathFromEPSString(aString: NSString | string): NSBezierPath;
  static circleAtPoint(point: NSPoint): NSBezierPath;
  static rectAtPoint(point: NSPoint): NSBezierPath;
  static triangleAtPoint_direction(point: NSPoint, tangent: NSPoint): NSBezierPath;
  static smallCircleAtPoint(point: NSPoint): NSBezierPath;
  static smallRectAtPoint(point: NSPoint): NSBezierPath;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  static defaultMiterLimit(): CGFloat;
  static setDefaultMiterLimit(defaultMiterLimit: CGFloat): void;
  static defaultFlatness(): CGFloat;
  static setDefaultFlatness(defaultFlatness: CGFloat): void;
  static defaultWindingRule(): NSWindingRule;
  static setDefaultWindingRule(defaultWindingRule: NSWindingRule): void;
  static defaultLineCapStyle(): NSLineCapStyle;
  static setDefaultLineCapStyle(defaultLineCapStyle: NSLineCapStyle): void;
  static defaultLineJoinStyle(): NSLineJoinStyle;
  static setDefaultLineJoinStyle(defaultLineJoinStyle: NSLineJoinStyle): void;
  static defaultLineWidth(): CGFloat;
  static setDefaultLineWidth(defaultLineWidth: CGFloat): void;
  lineWidth(): CGFloat;
  setLineWidth(lineWidth: CGFloat): void;
  lineCapStyle(): NSLineCapStyle;
  setLineCapStyle(lineCapStyle: NSLineCapStyle): void;
  lineJoinStyle(): NSLineJoinStyle;
  setLineJoinStyle(lineJoinStyle: NSLineJoinStyle): void;
  windingRule(): NSWindingRule;
  setWindingRule(windingRule: NSWindingRule): void;
  miterLimit(): CGFloat;
  setMiterLimit(miterLimit: CGFloat): void;
  flatness(): CGFloat;
  setFlatness(flatness: CGFloat): void;
  bezierPathByFlatteningPath(): NSBezierPath;
  bezierPathByReversingPath(): NSBezierPath;
  empty(): boolean;
  currentPoint(): NSPoint;
  controlPointBounds(): NSRect;
  bounds(): NSRect;
  elementCount(): NSInteger;
}

declare enum NSLineCapStyle {
  NSButtLineCapStyle = 0,
  NSRoundLineCapStyle = 1,
  NSSquareLineCapStyle = 2,
}

declare enum NSLineJoinStyle {
  NSMiterLineJoinStyle = 0,
  NSRoundLineJoinStyle = 1,
  NSBevelLineJoinStyle = 2,
}

declare enum NSWindingRule {
  NSNonZeroWindingRule = 0,
  NSEvenOddWindingRule = 1,
}

declare enum NSBezierPathElement {
  NSMoveToBezierPathElement,
  NSLineToBezierPathElement,
  NSCurveToBezierPathElement,
  NSClosePathBezierPathElement,
}

class NSBitmapImageRepAllocator<T extends NSBitmapImageRep> extends NSImageRepAllocator<T> {
  initWithFocusedViewRect(rect: NSRect): T;
  initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bytesPerRow_bitsPerPixel(planes: string, width: NSInteger, height: NSInteger, bps: NSInteger, spp: NSInteger, alpha: boolean, isPlanar: boolean, colorSpaceName: NSColorSpaceName, rBytes: NSInteger, pBits: NSInteger): T;
  initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bitmapFormat_bytesPerRow_bitsPerPixel(planes: string, width: NSInteger, height: NSInteger, bps: NSInteger, spp: NSInteger, alpha: boolean, isPlanar: boolean, colorSpaceName: NSColorSpaceName, bitmapFormat: NSBitmapFormat, rBytes: NSInteger, pBits: NSInteger): T;
  initWithCGImage(cgImage: CGImageRef): T;
  initWithCIImage(ciImage: CIImage): T;
  initWithData(data: NSData): T;
  initForIncrementalLoad(): T;
}
declare class NSBitmapImageRep extends NSImageRep implements INSSecureCoding {
  alloc<T extends NSBitmapImageRep>(): NSBitmapImageRepAllocator<T>;
  static imageRepsWithData(data: NSData): NSArray<any>;
  static imageRepWithData(data: NSData): NSBitmapImageRep;
  getBitmapDataPlanes(data: string): void;
  getCompression_factor(compression: NSTIFFCompression | null, factor: number | null): void;
  setCompression_factor(compression: NSTIFFCompression, factor: number): void;
  TIFFRepresentationUsingCompression_factor(comp: NSTIFFCompression, factor: number): NSData;
  static TIFFRepresentationOfImageRepsInArray(array: NSArray<any> | any[]): NSData;
  static TIFFRepresentationOfImageRepsInArray_usingCompression_factor(array: NSArray<any> | any[], comp: NSTIFFCompression, factor: number): NSData;
  static getTIFFCompressionTypes_count(list: NSTIFFCompression, numTypes: NSInteger): void;
  static localizedNameForTIFFCompressionType(compression: NSTIFFCompression): NSString;
  canBeCompressedUsing(compression: NSTIFFCompression): boolean;
  colorizeByMappingGray_toColor_blackMapping_whiteMapping(midPoint: CGFloat, midPointColor: NSColor | null, shadowColor: NSColor | null, lightColor: NSColor | null): void;
  incrementalLoadFromData_complete(data: NSData, complete: boolean): NSInteger;
  setColor_atX_y(color: NSColor, x: NSInteger, y: NSInteger): void;
  colorAtX_y(x: NSInteger, y: NSInteger): NSColor;
  getPixel_atX_y(p: NSUInteger[], x: NSInteger, y: NSInteger): void;
  setPixel_atX_y(p: NSUInteger[], x: NSInteger, y: NSInteger): void;
  bitmapImageRepByConvertingToColorSpace_renderingIntent(targetSpace: NSColorSpace, renderingIntent: NSColorRenderingIntent): NSBitmapImageRep;
  bitmapImageRepByRetaggingWithColorSpace(newSpace: NSColorSpace): NSBitmapImageRep;
  static representationOfImageRepsInArray_usingType_properties(imageReps: NSArray<any> | any[], storageType: NSBitmapImageFileType, properties: NSDictionary<any, any> | {[key: string]: any}): NSData;
  representationUsingType_properties(storageType: NSBitmapImageFileType, properties: NSDictionary<any, any> | {[key: string]: any}): NSData;
  setProperty_withValue(property: NSBitmapImageRepPropertyKey, value: any | null): void;
  valueForProperty(property: NSBitmapImageRepPropertyKey): any;
  JPGRepresentationWithCompression_progressive(compression: CGFloat, progressive: boolean): NSData;
  PNGRepresentationWithInterlaced(interlaced: boolean): NSData;
  PNGRepresentationWithInterlaced_includeAlpha(interlaced: boolean, includeAlpha: boolean): NSData;
  static bitmapImageRepWithSize_flags_colorSpace_drawingBlock(size: NSSize, flags: DKCGContextCreateFlags, space: NSColorSpace, block: CGContextDrawBlock): NSBitmapImageRep;
  static bitmapImageRepWithSize_pixelSize_flags_colorSpace_drawingBlock(size: NSSize, pixelSize: NSSize, flags: DKCGContextCreateFlags, space: NSColorSpace, block: CGContextDrawBlock): NSBitmapImageRep;
  rectForTrimming(): NSRect;
  rectForTrimming(isBlankImage: boolean): NSRect;
  bitmapImageRepByCroppingToRect(r: NSRect): NSBitmapImageRep;
  bitmapImageRepByFlippingVertical(): NSBitmapImageRep;
  bitSafeBitmapImageRep(): NSBitmapImageRep;
  bitSafeFastRectForTrimming(): NSRect;
  bitSafeFastRectForTrimming(isBlankImage: boolean): NSRect;
  hasTransparentPixels(): boolean;

  bitmapData(): string;
  planar(): boolean;
  samplesPerPixel(): NSInteger;
  bitsPerPixel(): NSInteger;
  bytesPerRow(): NSInteger;
  bytesPerPlane(): NSInteger;
  numberOfPlanes(): NSInteger;
  bitmapFormat(): NSBitmapFormat;
  TIFFRepresentation(): NSData;
  CGImage(): CGImageRef;
  colorSpace(): NSColorSpace;
  static supportsSecureCoding(): boolean;
}

declare type NSBitmapImageRepPropertyKey = NSString

declare enum NSTIFFCompression {
  NSTIFFCompressionNone = 1,
  NSTIFFCompressionCCITTFAX3 = 3,
  NSTIFFCompressionCCITTFAX4 = 4,
  NSTIFFCompressionLZW = 5,
  NSTIFFCompressionJPEG = 6,
  NSTIFFCompressionNEXT = 32766,
  NSTIFFCompressionPackBits = 32773,
  NSTIFFCompressionOldJPEG = 32865,
}

declare enum NSBitmapImageFileType {
  NSBitmapImageFileTypeTIFF,
  NSBitmapImageFileTypeBMP,
  NSBitmapImageFileTypeGIF,
  NSBitmapImageFileTypeJPEG,
  NSBitmapImageFileTypePNG,
  NSBitmapImageFileTypeJPEG2000,
}

declare enum NSImageRepLoadStatus {
  NSImageRepLoadStatusUnknownType = -1,
  NSImageRepLoadStatusReadingHeader = -2,
  NSImageRepLoadStatusWillNeedAllData = -3,
  NSImageRepLoadStatusInvalidData = -4,
  NSImageRepLoadStatusUnexpectedEOF = -5,
  NSImageRepLoadStatusCompleted = -6,
}

declare enum NSBitmapFormat {
  NSBitmapFormatAlphaFirst = 1 << 0,
  NSBitmapFormatAlphaNonpremultiplied = 1 << 1,
  NSBitmapFormatFloatingPointSamples = 1 << 2,
  NSBitmapFormatSixteenBitLittleEndian,
  NSBitmapFormatThirtyTwoBitLittleEndian,
  NSBitmapFormatSixteenBitBigEndian,
  NSBitmapFormatThirtyTwoBitBigEndian,
}

class NSBoxAllocator<T extends NSBox> extends NSViewAllocator<T> {}
declare class NSBox extends NSView {
  alloc<T extends NSBox>(): NSBoxAllocator<T>;
  sizeToFit(): void;
  setFrameFromContentFrame(contentFrame: NSRect): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;

  borderType(): NSBorderType;
  setBorderType(borderType: NSBorderType): void;
  titlePosition(): NSTitlePosition;
  setTitlePosition(titlePosition: NSTitlePosition): void;
  boxType(): NSBoxType;
  setBoxType(boxType: NSBoxType): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  titleFont(): NSFont;
  setTitleFont(titleFont: NSFont): void;
  borderRect(): NSRect;
  titleRect(): NSRect;
  titleCell(): any;
  contentViewMargins(): NSSize;
  setContentViewMargins(contentViewMargins: NSSize): void;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  transparent(): boolean;
  setTransparent(transparent: boolean): void;
  borderWidth(): CGFloat;
  setBorderWidth(borderWidth: CGFloat): void;
  cornerRadius(): CGFloat;
  setCornerRadius(cornerRadius: CGFloat): void;
  borderColor(): NSColor;
  setBorderColor(borderColor: NSColor): void;
  fillColor(): NSColor;
  setFillColor(fillColor: NSColor): void;
}

declare enum NSTitlePosition {
  NSNoTitle = 0,
  NSAboveTop = 1,
  NSAtTop = 2,
  NSBelowTop = 3,
  NSAboveBottom = 4,
  NSAtBottom = 5,
  NSBelowBottom = 6,
}

declare enum NSBoxType {
  NSBoxPrimary = 0,
  NSBoxSecondary = 1,
  NSBoxSeparator = 2,
  NSBoxOldStyle = 3,
  NSBoxCustom = 4,
}

class NSBrowserAllocator<T extends NSBrowser> extends NSControlAllocator<T> {}
declare class NSBrowser extends NSControl {
  alloc<T extends NSBrowser>(): NSBrowserAllocator<T>;
  loadColumnZero(): void;
  setCellClass(factoryId: any): void;
  itemAtIndexPath(indexPath: NSIndexPath): any;
  itemAtRow_inColumn(row: NSInteger, column: NSInteger): any;
  indexPathForColumn(column: NSInteger): NSIndexPath;
  isLeafItem(item: any | null): boolean;
  reloadDataForRowIndexes_inColumn(rowIndexes: NSIndexSet, column: NSInteger): void;
  parentForItemsInColumn(column: NSInteger): any;
  scrollRowToVisible_inColumn(row: NSInteger, column: NSInteger): void;
  setTitle_ofColumn(string: NSString | string, column: NSInteger): void;
  titleOfColumn(column: NSInteger): NSString;
  setPath(path: NSString | string): boolean;
  path(): NSString;
  pathToColumn(column: NSInteger): NSString;
  selectedCellInColumn(column: NSInteger): any;
  selectRow_inColumn(row: NSInteger, column: NSInteger): void;
  selectedRowInColumn(column: NSInteger): NSInteger;
  selectRowIndexes_inColumn(indexes: NSIndexSet, column: NSInteger): void;
  selectedRowIndexesInColumn(column: NSInteger): NSIndexSet;
  reloadColumn(column: NSInteger): void;
  validateVisibleColumns(): void;
  scrollColumnsRightBy(shiftAmount: NSInteger): void;
  scrollColumnsLeftBy(shiftAmount: NSInteger): void;
  scrollColumnToVisible(column: NSInteger): void;
  addColumn(): void;
  loadedCellAtRow_column(row: NSInteger, col: NSInteger): any;
  selectAll(sender: any | null): void;
  tile(): void;
  doClick(sender: any | null): void;
  doDoubleClick(sender: any | null): void;
  sendAction(): boolean;
  titleFrameOfColumn(column: NSInteger): NSRect;
  drawTitleOfColumn_inRect(column: NSInteger, rect: NSRect): void;
  frameOfColumn(column: NSInteger): NSRect;
  frameOfInsideOfColumn(column: NSInteger): NSRect;
  frameOfRow_inColumn(row: NSInteger, column: NSInteger): NSRect;
  getRow_column_forPoint(row: NSInteger | null, column: NSInteger | null, point: NSPoint): boolean;
  columnWidthForColumnContentWidth(columnContentWidth: CGFloat): CGFloat;
  columnContentWidthForColumnWidth(columnWidth: CGFloat): CGFloat;
  setWidth_ofColumn(columnWidth: CGFloat, columnIndex: NSInteger): void;
  widthOfColumn(column: NSInteger): CGFloat;
  noteHeightOfRowsWithIndexesChanged_inColumn(indexSet: NSIndexSet, columnIndex: NSInteger): void;
  setDefaultColumnWidth(columnWidth: CGFloat): void;
  defaultColumnWidth(): CGFloat;
  static removeSavedColumnsWithAutosaveName(name: NSBrowserColumnsAutosaveName): void;
  canDragRowsWithIndexes_inColumn_withEvent(rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent): boolean;
  draggingImageForRowsWithIndexes_inColumn_withEvent_offset(rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent, dragImageOffset: NSPointPointer | null): NSImage;
  setDraggingSourceOperationMask_forLocal(mask: NSDragOperation, isLocal: boolean): void;
  editItemAtIndexPath_withEvent_select(indexPath: NSIndexPath, event: NSEvent | null, select: boolean): void;
  setAcceptsArrowKeys(flag: boolean): void;
  acceptsArrowKeys(): boolean;
  displayColumn(column: NSInteger): void;
  displayAllColumns(): void;
  scrollViaScroller(sender: NSScroller): void;
  updateScroller(): void;
  setMatrixClass(factoryId: any): void;
  matrixClass(): any;
  columnOfMatrix(matrix: NSMatrix): NSInteger;
  matrixInColumn(column: NSInteger): NSMatrix;

  static cellClass(): any;
  loaded(): boolean;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  cellPrototype(): any;
  setCellPrototype(cellPrototype: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  reusesColumns(): boolean;
  setReusesColumns(reusesColumns: boolean): void;
  hasHorizontalScroller(): boolean;
  setHasHorizontalScroller(hasHorizontalScroller: boolean): void;
  autohidesScroller(): boolean;
  setAutohidesScroller(autohidesScroller: boolean): void;
  separatesColumns(): boolean;
  setSeparatesColumns(separatesColumns: boolean): void;
  titled(): boolean;
  setTitled(titled: boolean): void;
  minColumnWidth(): CGFloat;
  setMinColumnWidth(minColumnWidth: CGFloat): void;
  maxVisibleColumns(): NSInteger;
  setMaxVisibleColumns(maxVisibleColumns: NSInteger): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  allowsBranchSelection(): boolean;
  setAllowsBranchSelection(allowsBranchSelection: boolean): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  takesTitleFromPreviousColumn(): boolean;
  setTakesTitleFromPreviousColumn(takesTitleFromPreviousColumn: boolean): void;
  sendsActionOnArrowKeys(): boolean;
  setSendsActionOnArrowKeys(sendsActionOnArrowKeys: boolean): void;
  pathSeparator(): NSString;
  setPathSeparator(pathSeparator: NSString | string): void;
  clickedColumn(): NSInteger;
  clickedRow(): NSInteger;
  selectedColumn(): NSInteger;
  selectedCell(): any;
  selectedCells(): NSArray<any>;
  selectionIndexPath(): NSIndexPath;
  setSelectionIndexPath(selectionIndexPath: NSIndexPath): void;
  selectionIndexPaths(): NSArray<any>;
  setSelectionIndexPaths(selectionIndexPaths: NSArray<any> | any[]): void;
  lastColumn(): NSInteger;
  setLastColumn(lastColumn: NSInteger): void;
  numberOfVisibleColumns(): NSInteger;
  firstVisibleColumn(): NSInteger;
  lastVisibleColumn(): NSInteger;
  titleHeight(): CGFloat;
  columnResizingType(): NSBrowserColumnResizingType;
  setColumnResizingType(columnResizingType: NSBrowserColumnResizingType): void;
  prefersAllColumnUserResizing(): boolean;
  setPrefersAllColumnUserResizing(prefersAllColumnUserResizing: boolean): void;
  rowHeight(): CGFloat;
  setRowHeight(rowHeight: CGFloat): void;
  columnsAutosaveName(): NSBrowserColumnsAutosaveName;
  setColumnsAutosaveName(columnsAutosaveName: NSBrowserColumnsAutosaveName): void;
  allowsTypeSelect(): boolean;
  setAllowsTypeSelect(allowsTypeSelect: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}

declare interface INSBrowserDelegate {
  browser_numberOfRowsInColumn(sender: NSBrowser, column: NSInteger): NSInteger;
  browser_createRowsForColumn_inMatrix(sender: NSBrowser, column: NSInteger, matrix: NSMatrix): void;
  browser_numberOfChildrenOfItem(browser: NSBrowser, item: any | null): NSInteger;
  browser_child_ofItem(browser: NSBrowser, index: NSInteger, item: any | null): any;
  browser_isLeafItem(browser: NSBrowser, item: any | null): boolean;
  browser_objectValueForItem(browser: NSBrowser, item: any | null): any;
  browser_heightOfRow_inColumn(browser: NSBrowser, row: NSInteger, columnIndex: NSInteger): CGFloat;
  rootItemForBrowser(browser: NSBrowser): any;
  browser_setObjectValue_forItem(browser: NSBrowser, object: any | null, item: any | null): void;
  browser_shouldEditItem(browser: NSBrowser, item: any | null): boolean;
  browser_willDisplayCell_atRow_column(sender: NSBrowser, cell: any, row: NSInteger, column: NSInteger): void;
  browser_titleOfColumn(sender: NSBrowser, column: NSInteger): NSString;
  browser_selectCellWithString_inColumn(sender: NSBrowser, title: NSString | string, column: NSInteger): boolean;
  browser_selectRow_inColumn(sender: NSBrowser, row: NSInteger, column: NSInteger): boolean;
  browser_isColumnValid(sender: NSBrowser, column: NSInteger): boolean;
  browserWillScroll(sender: NSBrowser): void;
  browserDidScroll(sender: NSBrowser): void;
  browser_shouldSizeColumn_forUserResize_toWidth(browser: NSBrowser, columnIndex: NSInteger, forUserResize: boolean, suggestedWidth: CGFloat): CGFloat;
  browser_sizeToFitWidthOfColumn(browser: NSBrowser, columnIndex: NSInteger): CGFloat;
  browserColumnConfigurationDidChange(notification: NSNotification): void;
  browser_shouldShowCellExpansionForRow_column(browser: NSBrowser, row: NSInteger, column: NSInteger): boolean;
  browser_writeRowsWithIndexes_inColumn_toPasteboard(browser: NSBrowser, rowIndexes: NSIndexSet, column: NSInteger, pasteboard: NSPasteboard): boolean;
  browser_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes_inColumn(browser: NSBrowser, dropDestination: NSURL, rowIndexes: NSIndexSet, column: NSInteger): NSArray<any>;
  browser_canDragRowsWithIndexes_inColumn_withEvent(browser: NSBrowser, rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent): boolean;
  browser_draggingImageForRowsWithIndexes_inColumn_withEvent_offset(browser: NSBrowser, rowIndexes: NSIndexSet, column: NSInteger, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  browser_validateDrop_proposedRow_column_dropOperation(browser: NSBrowser, info: any, row: NSInteger, column: NSInteger, dropOperation: NSBrowserDropOperation): NSDragOperation;
  browser_acceptDrop_atRow_column_dropOperation(browser: NSBrowser, info: any, row: NSInteger, column: NSInteger, dropOperation: NSBrowserDropOperation): boolean;
  browser_typeSelectStringForRow_inColumn(browser: NSBrowser, row: NSInteger, column: NSInteger): NSString;
  browser_shouldTypeSelectForEvent_withCurrentSearchString(browser: NSBrowser, event: NSEvent, searchString: NSString | string | null): boolean;
  browser_nextTypeSelectMatchFromRow_toRow_inColumn_forString(browser: NSBrowser, startRow: NSInteger, endRow: NSInteger, column: NSInteger, searchString: NSString | string | null): NSInteger;
  browser_previewViewControllerForLeafItem(browser: NSBrowser, item: any): NSViewController;
  browser_headerViewControllerForItem(browser: NSBrowser, item: any | null): NSViewController;
  browser_didChangeLastColumn_toColumn(browser: NSBrowser, oldLastColumn: NSInteger, column: NSInteger): void;
  browser_selectionIndexesForProposedSelection_inColumn(browser: NSBrowser, proposedSelectionIndexes: NSIndexSet, column: NSInteger): NSIndexSet;
}

declare type NSBrowserColumnsAutosaveName = NSString

declare enum NSBrowserColumnResizingType {
  NSBrowserNoColumnResizing = 0,
  NSBrowserAutoColumnResizing = 1,
  NSBrowserUserColumnResizing = 2,
}

declare enum NSBrowserDropOperation {
  NSBrowserDropOn,
  NSBrowserDropAbove,
}

class NSBrowserCellAllocator<T extends NSBrowserCell> extends NSCellAllocator<T> {}
declare class NSBrowserCell extends NSCell {
  alloc<T extends NSBrowserCell>(): NSBrowserCellAllocator<T>;
  highlightColorInView(controlView: NSView): NSColor;
  reset(): void;
  set(): void;

  static branchImage(): NSImage;
  static highlightedBranchImage(): NSImage;
  leaf(): boolean;
  setLeaf(leaf: boolean): void;
  loaded(): boolean;
  setLoaded(loaded: boolean): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
}

class NSButtonAllocator<T extends NSButton> extends NSControlAllocator<T> {}
declare class NSButton extends NSControl implements INSUserInterfaceValidations, INSAccessibilityButton, INSUserInterfaceCompression {
  alloc<T extends NSButton>(): NSButtonAllocator<T>;
  setButtonType(type: NSButtonType): void;
  setPeriodicDelay_interval(delay: number, interval: number): void;
  getPeriodicDelay_interval(delay: number, interval: number): void;
  highlight(flag: boolean): void;
  performKeyEquivalent(key: NSEvent): boolean;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;
  static buttonWithTitle_image_target_action(title: NSString | string, image: NSImage, target: any | null, action: string | null): NSButton;
  static buttonWithTitle_target_action(title: NSString | string, target: any | null, action: string | null): NSButton;
  static buttonWithImage_target_action(image: NSImage, target: any | null, action: string | null): NSButton;
  static checkboxWithTitle_target_action(title: NSString | string, target: any | null, action: string | null): NSButton;
  static radioButtonWithTitle_target_action(title: NSString | string, target: any | null, action: string | null): NSButton;
  setNextState(): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityLabel(): NSString;
  accessibilityPerformPress(): boolean;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityLabel(): NSString;
  accessibilityPerformPress(): boolean;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;

  title(): NSString;
  setTitle(title: NSString | string): void;
  alternateTitle(): NSString;
  setAlternateTitle(alternateTitle: NSString | string): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
  imagePosition(): NSCellImagePosition;
  setImagePosition(imagePosition: NSCellImagePosition): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  imageHugsTitle(): boolean;
  setImageHugsTitle(imageHugsTitle: boolean): void;
  state(): NSControlStateValue;
  setState(state: NSControlStateValue): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  transparent(): boolean;
  setTransparent(transparent: boolean): void;
  keyEquivalent(): NSString;
  setKeyEquivalent(keyEquivalent: NSString | string): void;
  keyEquivalentModifierMask(): NSEventModifierFlags;
  setKeyEquivalentModifierMask(keyEquivalentModifierMask: NSEventModifierFlags): void;
  springLoaded(): boolean;
  setSpringLoaded(springLoaded: boolean): void;
  maxAcceleratorLevel(): NSInteger;
  setMaxAcceleratorLevel(maxAcceleratorLevel: NSInteger): void;
  bezelColor(): NSColor;
  setBezelColor(bezelColor: NSColor): void;
  activeCompressionOptions(): NSUserInterfaceCompressionOptions;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  attributedAlternateTitle(): NSAttributedString;
  setAttributedAlternateTitle(attributedAlternateTitle: NSAttributedString): void;
  bezelStyle(): NSBezelStyle;
  setBezelStyle(bezelStyle: NSBezelStyle): void;
  allowsMixedState(): boolean;
  setAllowsMixedState(allowsMixedState: boolean): void;
  showsBorderOnlyWhileMouseInside(): boolean;
  setShowsBorderOnlyWhileMouseInside(showsBorderOnlyWhileMouseInside: boolean): void;
  sound(): NSSound;
  setSound(sound: NSSound): void;
}

class NSButtonCellAllocator<T extends NSButtonCell> extends NSActionCellAllocator<T> {}
declare class NSButtonCell extends NSActionCell {
  alloc<T extends NSButtonCell>(): NSButtonCellAllocator<T>;
  setButtonType(type: NSButtonType): void;
  setPeriodicDelay_interval(delay: number, interval: number): void;
  getPeriodicDelay_interval(delay: number, interval: number): void;
  setKeyEquivalentFont_size(fontName: NSString | string, fontSize: CGFloat): void;
  performClick(sender: any | null): void;
  drawImage_withFrame_inView(image: NSImage, frame: NSRect, controlView: NSView): void;
  drawTitle_withFrame_inView(title: NSAttributedString, frame: NSRect, controlView: NSView): NSRect;
  drawBezelWithFrame_inView(frame: NSRect, controlView: NSView): void;
  mouseEntered(event: NSEvent): void;
  mouseExited(event: NSEvent): void;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  setAlternateTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  setAlternateMnemonicLocation(location: NSUInteger): void;
  alternateMnemonicLocation(): NSUInteger;
  alternateMnemonic(): NSString;

  title(): NSString;
  setTitle(title: NSString | string): void;
  alternateTitle(): NSString;
  setAlternateTitle(alternateTitle: NSString | string): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
  imagePosition(): NSCellImagePosition;
  setImagePosition(imagePosition: NSCellImagePosition): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  highlightsBy(): NSCellStyleMask;
  setHighlightsBy(highlightsBy: NSCellStyleMask): void;
  showsStateBy(): NSCellStyleMask;
  setShowsStateBy(showsStateBy: NSCellStyleMask): void;
  opaque(): boolean;
  transparent(): boolean;
  setTransparent(transparent: boolean): void;
  keyEquivalent(): NSString;
  setKeyEquivalent(keyEquivalent: NSString | string): void;
  keyEquivalentModifierMask(): NSEventModifierFlags;
  setKeyEquivalentModifierMask(keyEquivalentModifierMask: NSEventModifierFlags): void;
  keyEquivalentFont(): NSFont;
  setKeyEquivalentFont(keyEquivalentFont: NSFont): void;
  imageDimsWhenDisabled(): boolean;
  setImageDimsWhenDisabled(imageDimsWhenDisabled: boolean): void;
  showsBorderOnlyWhileMouseInside(): boolean;
  setShowsBorderOnlyWhileMouseInside(showsBorderOnlyWhileMouseInside: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  attributedAlternateTitle(): NSAttributedString;
  setAttributedAlternateTitle(attributedAlternateTitle: NSAttributedString): void;
  bezelStyle(): NSBezelStyle;
  setBezelStyle(bezelStyle: NSBezelStyle): void;
  sound(): NSSound;
  setSound(sound: NSSound): void;
  gradientType(): NSGradientType;
  setGradientType(gradientType: NSGradientType): void;
}

declare enum NSButtonType {
  NSButtonTypeMomentaryLight = 0,
  NSButtonTypePushOnPushOff = 1,
  NSButtonTypeToggle = 2,
  NSButtonTypeSwitch = 3,
  NSButtonTypeRadio = 4,
  NSButtonTypeMomentaryChange = 5,
  NSButtonTypeOnOff = 6,
  NSButtonTypeMomentaryPushIn = 7,
  NSButtonTypeAccelerator = 8,
  NSButtonTypeMultiLevelAccelerator = 9,
}

declare enum NSBezelStyle {
  NSBezelStyleRounded = 1,
  NSBezelStyleRegularSquare = 2,
  NSBezelStyleDisclosure = 5,
  NSBezelStyleShadowlessSquare = 6,
  NSBezelStyleCircular = 7,
  NSBezelStyleTexturedSquare = 8,
  NSBezelStyleHelpButton = 9,
  NSBezelStyleSmallSquare = 10,
  NSBezelStyleTexturedRounded = 11,
  NSBezelStyleRoundRect = 12,
  NSBezelStyleRecessed = 13,
  NSBezelStyleRoundedDisclosure = 14,
  NSBezelStyleInline = 15,
}

declare enum NSGradientType {
  NSGradientNone = 0,
  NSGradientConcaveWeak = 1,
  NSGradientConcaveStrong = 2,
  NSGradientConvexWeak = 3,
  NSGradientConvexStrong = 4,
}

class NSCIImageRepAllocator<T extends NSCIImageRep> extends NSImageRepAllocator<T> {
  initWithCIImage(image: CIImage): T;
}
declare class NSCIImageRep extends NSImageRep {
  alloc<T extends NSCIImageRep>(): NSCIImageRepAllocator<T>;
  static imageRepWithCIImage(image: CIImage): NSCIImageRep;

  CIImage(): CIImage;
}

class CIImageAllocator<T extends CIImage> {
  initWithBitmapImageRep(bitmapImageRep: NSBitmapImageRep): T;
}
declare class CIImage {
  alloc<T extends CIImage>(): CIImageAllocator<T>;
  drawInRect_fromRect_operation_fraction(rect: NSRect, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  drawAtPoint_fromRect_operation_fraction(point: NSPoint, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  PNGRepresentationWithInterlaced(interlaced: boolean): NSData;
  imageByFlippingVertically(): CIImage;
}

class NSCachedImageRepAllocator<T extends NSCachedImageRep> extends NSImageRepAllocator<T> {
  initWithWindow_rect(win: NSWindow, rect: NSRect): T;
  initWithSize_depth_separate_alpha(size: NSSize, depth: NSWindowDepth, flag: boolean, alpha: boolean): T;
}
declare class NSCachedImageRep extends NSImageRep {
  alloc<T extends NSCachedImageRep>(): NSCachedImageRepAllocator<T>;
  window(): NSWindow;
  rect(): NSRect;
}

class NSCandidateListTouchBarItemAllocator<CandidateType, T extends NSCandidateListTouchBarItem<CandidateType>> extends NSTouchBarItemAllocator<T> {}
declare class NSCandidateListTouchBarItem<CandidateType> extends NSTouchBarItem {
  alloc<T extends NSCandidateListTouchBarItem<CandidateType>>(): NSCandidateListTouchBarItemAllocator<CandidateType, T>;
  updateWithInsertionPointVisibility(isVisible: boolean): void;
  setCandidates_forSelectedRange_inString(candidates: NSArray<any> | any[], selectedRange: NSRange, originalString: NSString | string | null): void;

  client(): NSView;
  setClient(client: NSView): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
  allowsCollapsing(): boolean;
  setAllowsCollapsing(allowsCollapsing: boolean): void;
  candidateListVisible(): boolean;
  allowsTextInputContextCandidates(): boolean;
  setAllowsTextInputContextCandidates(allowsTextInputContextCandidates: boolean): void;
  candidates(): NSArray<any>;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
}

class NSViewAllocator<T extends NSView> extends NSResponderAllocator<T> {
  initWithFrame(frameRect: NSRect): T;
}
declare class NSView extends NSResponder implements INSAnimatablePropertyContainer, INSUserInterfaceItemIdentification, INSDraggingDestination, INSAppearanceCustomization, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSView>(): NSViewAllocator<T>;
  reflectScrolledClipView(clipView: NSClipView): void;
  scrollClipView_toPoint(clipView: NSClipView, point: NSPoint): void;
  addConstraint(constraint: NSLayoutConstraint): void;
  addConstraints(constraints: NSArray<any> | any[]): void;
  removeConstraint(constraint: NSLayoutConstraint): void;
  removeConstraints(constraints: NSArray<any> | any[]): void;
  updateConstraintsForSubtreeIfNeeded(): void;
  layoutSubtreeIfNeeded(): void;
  layout(): void;
  alignmentRectForFrame(frame: NSRect): NSRect;
  frameForAlignmentRect(alignmentRect: NSRect): NSRect;
  invalidateIntrinsicContentSize(): void;
  contentHuggingPriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setContentHuggingPriority_forOrientation(priority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  contentCompressionResistancePriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setContentCompressionResistancePriority_forOrientation(priority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  constraintsAffectingLayoutForOrientation(orientation: NSLayoutConstraintOrientation): NSArray<any>;
  exerciseAmbiguityInLayout(): void;
  addLayoutGuide(guide: NSLayoutGuide): void;
  removeLayoutGuide(guide: NSLayoutGuide): void;
  rulerView_shouldMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willMoveMarker_toLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_didMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_shouldRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_didRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_shouldAddMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willAddMarker_atLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_didAddMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_handleMouseDown(ruler: NSRulerView, event: NSEvent): void;
  rulerView_willSetClientView(ruler: NSRulerView, newClient: NSView): void;
  rulerView_locationForPoint(ruler: NSRulerView, point: NSPoint): CGFloat;
  rulerView_pointForLocation(ruler: NSRulerView, point: CGFloat): NSPoint;
  isDescendantOf(view: NSView): boolean;
  ancestorSharedWithView(view: NSView): NSView;
  getRectsBeingDrawn_count(rects: NSRect, count: NSInteger | null): void;
  needsToDrawRect(rect: NSRect): boolean;
  viewDidHide(): void;
  viewDidUnhide(): void;
  addSubview(view: NSView): void;
  addSubview_positioned_relativeTo(view: NSView, place: NSWindowOrderingMode, otherView: NSView | null): void;
  viewWillMoveToWindow(newWindow: NSWindow | null): void;
  viewDidMoveToWindow(): void;
  viewWillMoveToSuperview(newSuperview: NSView | null): void;
  viewDidMoveToSuperview(): void;
  didAddSubview(subview: NSView): void;
  willRemoveSubview(subview: NSView): void;
  removeFromSuperview(): void;
  replaceSubview_with(oldView: NSView, newView: NSView): void;
  removeFromSuperviewWithoutNeedingDisplay(): void;
  viewDidChangeBackingProperties(): void;
  resizeSubviewsWithOldSize(oldSize: NSSize): void;
  resizeWithOldSuperviewSize(oldSize: NSSize): void;
  setFrameOrigin(newOrigin: NSPoint): void;
  setFrameSize(newSize: NSSize): void;
  setBoundsOrigin(newOrigin: NSPoint): void;
  setBoundsSize(newSize: NSSize): void;
  translateOriginToPoint(translation: NSPoint): void;
  scaleUnitSquareToSize(newUnitSize: NSSize): void;
  rotateByAngle(angle: CGFloat): void;
  convertPoint_fromView(point: NSPoint, view: NSView | null): NSPoint;
  convertPoint_toView(point: NSPoint, view: NSView | null): NSPoint;
  convertSize_fromView(size: NSSize, view: NSView | null): NSSize;
  convertSize_toView(size: NSSize, view: NSView | null): NSSize;
  convertRect_fromView(rect: NSRect, view: NSView | null): NSRect;
  convertRect_toView(rect: NSRect, view: NSView | null): NSRect;
  backingAlignedRect_options(rect: NSRect, options: NSAlignmentOptions): NSRect;
  centerScanRect(rect: NSRect): NSRect;
  convertPointToBacking(point: NSPoint): NSPoint;
  convertPointFromBacking(point: NSPoint): NSPoint;
  convertSizeToBacking(size: NSSize): NSSize;
  convertSizeFromBacking(size: NSSize): NSSize;
  convertRectToBacking(rect: NSRect): NSRect;
  convertRectFromBacking(rect: NSRect): NSRect;
  convertPointToLayer(point: NSPoint): NSPoint;
  convertPointFromLayer(point: NSPoint): NSPoint;
  convertSizeToLayer(size: NSSize): NSSize;
  convertSizeFromLayer(size: NSSize): NSSize;
  convertRectToLayer(rect: NSRect): NSRect;
  convertRectFromLayer(rect: NSRect): NSRect;
  setNeedsDisplayInRect(invalidRect: NSRect): void;
  lockFocus(): void;
  unlockFocus(): void;
  lockFocusIfCanDraw(): boolean;
  lockFocusIfCanDrawInContext(context: NSGraphicsContext): boolean;
  display(): void;
  displayIfNeeded(): void;
  displayIfNeededIgnoringOpacity(): void;
  displayRect(rect: NSRect): void;
  displayIfNeededInRect(rect: NSRect): void;
  displayRectIgnoringOpacity(rect: NSRect): void;
  displayIfNeededInRectIgnoringOpacity(rect: NSRect): void;
  drawRect(dirtyRect: NSRect): void;
  displayRectIgnoringOpacity_inContext(rect: NSRect, context: NSGraphicsContext): void;
  bitmapImageRepForCachingDisplayInRect(rect: NSRect): NSBitmapImageRep;
  cacheDisplayInRect_toBitmapImageRep(rect: NSRect, bitmapImageRep: NSBitmapImageRep): void;
  viewWillDraw(): void;
  scrollPoint(point: NSPoint): void;
  scrollRectToVisible(rect: NSRect): boolean;
  autoscroll(event: NSEvent): boolean;
  adjustScroll(newVisible: NSRect): NSRect;
  scrollRect_by(rect: NSRect, delta: NSSize): void;
  translateRectsNeedingDisplayInRect_by(clipRect: NSRect, delta: NSSize): void;
  hitTest(point: NSPoint): NSView;
  mouse_inRect(point: NSPoint, rect: NSRect): boolean;
  viewWithTag(tag: NSInteger): NSView;
  performKeyEquivalent(event: NSEvent): boolean;
  acceptsFirstMouse(event: NSEvent | null): boolean;
  shouldDelayWindowOrderingForEvent(event: NSEvent): boolean;
  addCursorRect_cursor(rect: NSRect, object: NSCursor): void;
  removeCursorRect_cursor(rect: NSRect, object: NSCursor): void;
  discardCursorRects(): void;
  resetCursorRects(): void;
  addTrackingRect_owner_userData_assumeInside(rect: NSRect, owner: any, data: void | null, flag: boolean): NSTrackingRectTag;
  removeTrackingRect(tag: NSTrackingRectTag): void;
  makeBackingLayer(): CALayer;
  updateLayer(): void;
  addTrackingArea(trackingArea: NSTrackingArea): void;
  removeTrackingArea(trackingArea: NSTrackingArea): void;
  updateTrackingAreas(): void;
  menuForEvent(event: NSEvent): NSMenu;
  willOpenMenu_withEvent(menu: NSMenu, event: NSEvent): void;
  didCloseMenu_withEvent(menu: NSMenu, event: NSEvent | null): void;
  addToolTipRect_owner_userData(rect: NSRect, owner: any, data: void | null): NSToolTipTag;
  removeToolTip(tag: NSToolTipTag): void;
  removeAllToolTips(): void;
  viewWillStartLiveResize(): void;
  viewDidEndLiveResize(): void;
  getRectsExposedDuringLiveResize_count(exposedRects: [NSRect, NSRect, NSRect, NSRect], count: NSInteger): void;
  rectForSmartMagnificationAtPoint_inRect(location: NSPoint, visibleRect: NSRect): NSRect;
  prepareForReuse(): void;
  prepareContentInRect(rect: NSRect): void;
  setKeyboardFocusRingNeedsDisplayInRect(rect: NSRect): void;
  drawFocusRingMask(): void;
  noteFocusRingMaskChanged(): void;
  writeEPSInsideRect_toPasteboard(rect: NSRect, pasteboard: NSPasteboard): void;
  dataWithEPSInsideRect(rect: NSRect): NSData;
  writePDFInsideRect_toPasteboard(rect: NSRect, pasteboard: NSPasteboard): void;
  dataWithPDFInsideRect(rect: NSRect): NSData;
  print(sender: any | null): void;
  knowsPageRange(range: NSRangePointer): boolean;
  adjustPageWidthNew_left_right_limit(newRight: CGFloat, oldLeft: CGFloat, oldRight: CGFloat, rightLimit: CGFloat): void;
  adjustPageHeightNew_top_bottom_limit(newBottom: CGFloat, oldTop: CGFloat, oldBottom: CGFloat, bottomLimit: CGFloat): void;
  rectForPage(page: NSInteger): NSRect;
  locationOfPrintRect(rect: NSRect): NSPoint;
  drawPageBorderWithSize(borderSize: NSSize): void;
  drawSheetBorderWithSize(borderSize: NSSize): void;
  beginDocument(): void;
  endDocument(): void;
  beginPageInRect_atPlacement(rect: NSRect, location: NSPoint): void;
  endPage(): void;
  beginDraggingSessionWithItems_event_source(items: NSArray<any> | any[], event: NSEvent, source: any): NSDraggingSession;
  registerForDraggedTypes(newTypes: NSArray<any> | any[]): void;
  unregisterDraggedTypes(): void;
  enterFullScreenMode_withOptions(screen: NSScreen, options: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  exitFullScreenModeWithOptions(options: NSDictionary<any, any> | {[key: string]: any} | null): void;
  showDefinitionForAttributedString_atPoint(attrString: NSAttributedString | null, textBaselineOrigin: NSPoint): void;
  showDefinitionForAttributedString_range_options_baselineOriginProvider(attrString: NSAttributedString | null, targetRange: NSRange, options: NSDictionary<any, any> | {[key: string]: any} | null, originProvider: Block): void;
  addGestureRecognizer(gestureRecognizer: NSGestureRecognizer): void;
  removeGestureRecognizer(gestureRecognizer: NSGestureRecognizer): void;
  dragImage_at_offset_event_pasteboard_source_slideBack(image: NSImage, viewLocation: NSPoint, initialOffset: NSSize, event: NSEvent, pboard: NSPasteboard, sourceObj: any, slideFlag: boolean): void;
  dragFile_fromRect_slideBack_event(filename: NSString | string, rect: NSRect, flag: boolean, event: NSEvent): boolean;
  dragPromisedFilesOfTypes_fromRect_source_slideBack_event(typeArray: NSArray<any> | any[], rect: NSRect, sourceObject: any, flag: boolean, event: NSEvent): boolean;
  convertPointToBase(point: NSPoint): NSPoint;
  convertPointFromBase(point: NSPoint): NSPoint;
  convertSizeToBase(size: NSSize): NSSize;
  convertSizeFromBase(size: NSSize): NSSize;
  convertRectToBase(rect: NSRect): NSRect;
  convertRectFromBase(rect: NSRect): NSRect;
  performMnemonic(string: NSString | string): boolean;
  shouldDrawColor(): boolean;
  gState(): NSInteger;
  allocateGState(): void;
  releaseGState(): void;
  setUpGState(): void;
  renewGState(): void;
  addSubview_constrainedBy_priority(subview: NSView, insets: NSEdgeInsets, priority: NSLayoutPriority): void;
  constrainHeight(height: CGFloat): void;
  constrainHeight_priority(height: CGFloat, priority: NSLayoutPriority): void;
  constrainWidth(width: CGFloat): void;
  constrainWidth_priority(width: CGFloat, priority: NSLayoutPriority): void;
  heightConstraint(): NSLayoutConstraint;
  hideWithZeroHeight(): void;
  hideWithZeroWidth(): void;
  showWithHeight(height: CGFloat): void;
  showWithWidth(width: CGFloat): void;
  horizontalConstraintWithView(anotherView: NSView): NSLayoutConstraint;
  horizontalConstraintsWithView(anotherView: NSView): NSArray<any>;
  verticalConstraintWithView(anotherView: NSView): NSLayoutConstraint;
  verticalConstraintsWithView(anotherView: NSView): NSArray<any>;
  widthConstraint(): NSLayoutConstraint;
  setFrameHeight(height: CGFloat): void;
  setFrameWidth(width: CGFloat): void;
  setFrameOriginX(x: CGFloat): void;
  setFrameOriginY(y: CGFloat): void;
  setNeedsDisplay(): void;
  imageRepresentation(): NSImage;
  beginDragFromEvent_image_type_data(event: NSEvent, image: NSImage, type: NSString | string, propertyListData: any): void;
  beginDragFromEvent_image_writersBlock(event: NSEvent, image: NSImage, block: MSPasteboardItemWritingBlock): void;
  containingAncestorViewOfClass(ancestorViewClass: any): NSView;
  nestedSubviewWithIdentifier(identifer: NSUserInterfaceItemIdentifier): NSView;
  animateToFrameOrigin_completionBlock(origin: NSPoint, block: MSAnimationBlock): void;
  animateToFrameOriginX_completionBlock(x: NSInteger, block: MSAnimationBlock): void;
  animateToFrameOriginX(x: NSInteger): void;
  subViewsForResponderFixer(): NSArray<any>;
  enclosingStackView(): MSInspectorStackView;
  viewHistoryMaker(): MSHistoryMaker;
  clickShouldDismissPopover(popover: BCPopover): boolean;
  wantsSeparatorBetweenSelfAndView(view: NSView): boolean;
  separatorInsetBetweenSelfAndView(view: NSView): NSEdgeInsets;
  animator(): NSView;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  animator(): NSView;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
  leadingAnchor(): NSLayoutXAxisAnchor;
  trailingAnchor(): NSLayoutXAxisAnchor;
  leftAnchor(): NSLayoutXAxisAnchor;
  rightAnchor(): NSLayoutXAxisAnchor;
  topAnchor(): NSLayoutYAxisAnchor;
  bottomAnchor(): NSLayoutYAxisAnchor;
  widthAnchor(): NSLayoutDimension;
  heightAnchor(): NSLayoutDimension;
  centerXAnchor(): NSLayoutXAxisAnchor;
  centerYAnchor(): NSLayoutYAxisAnchor;
  firstBaselineAnchor(): NSLayoutYAxisAnchor;
  lastBaselineAnchor(): NSLayoutYAxisAnchor;
  constraints(): NSArray<any>;
  needsUpdateConstraints(): boolean;
  setNeedsUpdateConstraints(needsUpdateConstraints: boolean): void;
  needsLayout(): boolean;
  setNeedsLayout(needsLayout: boolean): void;
  translatesAutoresizingMaskIntoConstraints(): boolean;
  setTranslatesAutoresizingMaskIntoConstraints(translatesAutoresizingMaskIntoConstraints: boolean): void;
  static requiresConstraintBasedLayout(): boolean;
  alignmentRectInsets(): NSEdgeInsets;
  firstBaselineOffsetFromTop(): CGFloat;
  lastBaselineOffsetFromBottom(): CGFloat;
  baselineOffsetFromBottom(): CGFloat;
  intrinsicContentSize(): NSSize;
  fittingSize(): NSSize;
  hasAmbiguousLayout(): boolean;
  layoutGuides(): NSArray<any>;
  enclosingMenuItem(): NSMenuItem;
  wantsBestResolutionOpenGLSurface(): boolean;
  setWantsBestResolutionOpenGLSurface(wantsBestResolutionOpenGLSurface: boolean): void;
  wantsExtendedDynamicRangeOpenGLSurface(): boolean;
  setWantsExtendedDynamicRangeOpenGLSurface(wantsExtendedDynamicRangeOpenGLSurface: boolean): void;
  pressureConfiguration(): NSPressureConfiguration;
  setPressureConfiguration(pressureConfiguration: NSPressureConfiguration): void;
  window(): NSWindow;
  superview(): NSView;
  subviews(): NSArray<any>;
  setSubviews(subviews: NSArray<any> | any[]): void;
  opaqueAncestor(): NSView;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  hiddenOrHasHiddenAncestor(): boolean;
  wantsDefaultClipping(): boolean;
  postsFrameChangedNotifications(): boolean;
  setPostsFrameChangedNotifications(postsFrameChangedNotifications: boolean): void;
  autoresizesSubviews(): boolean;
  setAutoresizesSubviews(autoresizesSubviews: boolean): void;
  autoresizingMask(): NSAutoresizingMaskOptions;
  setAutoresizingMask(autoresizingMask: NSAutoresizingMaskOptions): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
  frameRotation(): CGFloat;
  setFrameRotation(frameRotation: CGFloat): void;
  frameCenterRotation(): CGFloat;
  setFrameCenterRotation(frameCenterRotation: CGFloat): void;
  boundsRotation(): CGFloat;
  setBoundsRotation(boundsRotation: CGFloat): void;
  bounds(): NSRect;
  setBounds(bounds: NSRect): void;
  flipped(): boolean;
  rotatedFromBase(): boolean;
  rotatedOrScaledFromBase(): boolean;
  opaque(): boolean;
  canDrawConcurrently(): boolean;
  setCanDrawConcurrently(canDrawConcurrently: boolean): void;
  canDraw(): boolean;
  needsDisplay(): boolean;
  setNeedsDisplay(needsDisplay: boolean): void;
  static focusView(): NSView;
  visibleRect(): NSRect;
  tag(): NSInteger;
  needsPanelToBecomeKey(): boolean;
  mouseDownCanMoveWindow(): boolean;
  acceptsTouchEvents(): boolean;
  setAcceptsTouchEvents(acceptsTouchEvents: boolean): void;
  wantsRestingTouches(): boolean;
  setWantsRestingTouches(wantsRestingTouches: boolean): void;
  layerContentsRedrawPolicy(): NSViewLayerContentsRedrawPolicy;
  setLayerContentsRedrawPolicy(layerContentsRedrawPolicy: NSViewLayerContentsRedrawPolicy): void;
  layerContentsPlacement(): NSViewLayerContentsPlacement;
  setLayerContentsPlacement(layerContentsPlacement: NSViewLayerContentsPlacement): void;
  wantsLayer(): boolean;
  setWantsLayer(wantsLayer: boolean): void;
  layer(): CALayer;
  setLayer(layer: CALayer): void;
  wantsUpdateLayer(): boolean;
  canDrawSubviewsIntoLayer(): boolean;
  setCanDrawSubviewsIntoLayer(canDrawSubviewsIntoLayer: boolean): void;
  alphaValue(): CGFloat;
  setAlphaValue(alphaValue: CGFloat): void;
  layerUsesCoreImageFilters(): boolean;
  setLayerUsesCoreImageFilters(layerUsesCoreImageFilters: boolean): void;
  backgroundFilters(): NSArray<any>;
  setBackgroundFilters(backgroundFilters: NSArray<any> | any[]): void;
  compositingFilter(): CIFilter;
  setCompositingFilter(compositingFilter: CIFilter): void;
  contentFilters(): NSArray<any>;
  setContentFilters(contentFilters: NSArray<any> | any[]): void;
  shadow(): NSShadow;
  setShadow(shadow: NSShadow): void;
  trackingAreas(): NSArray<any>;
  postsBoundsChangedNotifications(): boolean;
  setPostsBoundsChangedNotifications(postsBoundsChangedNotifications: boolean): void;
  enclosingScrollView(): NSScrollView;
  static defaultMenu(): NSMenu;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  inLiveResize(): boolean;
  preservesContentDuringLiveResize(): boolean;
  rectPreservedDuringLiveResize(): NSRect;
  inputContext(): NSTextInputContext;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  static compatibleWithResponsiveScrolling(): boolean;
  preparedContentRect(): NSRect;
  setPreparedContentRect(preparedContentRect: NSRect): void;
  allowsVibrancy(): boolean;
  nextKeyView(): NSView;
  setNextKeyView(nextKeyView: NSView): void;
  previousKeyView(): NSView;
  nextValidKeyView(): NSView;
  previousValidKeyView(): NSView;
  canBecomeKeyView(): boolean;
  focusRingType(): NSFocusRingType;
  setFocusRingType(focusRingType: NSFocusRingType): void;
  static defaultFocusRingType(): NSFocusRingType;
  focusRingMaskBounds(): NSRect;
  heightAdjustLimit(): CGFloat;
  widthAdjustLimit(): CGFloat;
  pageHeader(): NSAttributedString;
  pageFooter(): NSAttributedString;
  printJobTitle(): NSString;
  registeredDraggedTypes(): NSArray<any>;
  inFullScreenMode(): boolean;
  drawingFindIndicator(): boolean;
  gestureRecognizers(): NSArray<any>;
  setGestureRecognizers(gestureRecognizers: NSArray<any> | any[]): void;
  allowedTouchTypes(): NSTouchTypeMask;
  setAllowedTouchTypes(allowedTouchTypes: NSTouchTypeMask): void;
  dropDelegate_bc(): NSObject;
  setDropDelegate_bc(dropDelegate_bc: NSObject): void;
  allSubviews(): NSArray<any>;
  canBeKeyView(): boolean;
  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  appearance(): NSAppearance;
  setAppearance(appearance: NSAppearance): void;
  effectiveAppearance(): NSAppearance;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare interface INSCandidateListTouchBarItemDelegate {
  candidateListTouchBarItem_beginSelectingCandidateAtIndex(anItem: NSCandidateListTouchBarItem<any>, index: NSInteger): void;
  candidateListTouchBarItem_changeSelectionFromCandidateAtIndex_toIndex(anItem: NSCandidateListTouchBarItem<any>, previousIndex: NSInteger, index: NSInteger): void;
  candidateListTouchBarItem_endSelectingCandidateAtIndex(anItem: NSCandidateListTouchBarItem<any>, index: NSInteger): void;
  candidateListTouchBarItem_changedCandidateListVisibility(anItem: NSCandidateListTouchBarItem<any>, isVisible: boolean): void;
}

class NSCellAllocator<T extends NSCell> extends NSObjectAllocator<T> {
  init(): T;
  initTextCell(string: NSString | string): T;
  initImageCell(image: NSImage | null): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSCell extends NSObject implements INSCopying, INSCoding, INSUserInterfaceItemIdentification, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSCell>(): NSCellAllocator<T>;
  sendActionOn(mask: NSInteger): NSInteger;
  compare(otherCell: any): NSComparisonResult;
  takeIntValueFrom(sender: any | null): void;
  takeFloatValueFrom(sender: any | null): void;
  takeDoubleValueFrom(sender: any | null): void;
  takeStringValueFrom(sender: any | null): void;
  takeObjectValueFrom(sender: any | null): void;
  cellAttribute(parameter: NSCellAttribute): NSInteger;
  setCellAttribute_to(parameter: NSCellAttribute, value: NSInteger): void;
  imageRectForBounds(rect: NSRect): NSRect;
  titleRectForBounds(rect: NSRect): NSRect;
  drawingRectForBounds(rect: NSRect): NSRect;
  cellSizeForBounds(rect: NSRect): NSSize;
  highlightColorWithFrame_inView(cellFrame: NSRect, controlView: NSView): NSColor;
  calcDrawInfo(rect: NSRect): void;
  setUpFieldEditorAttributes(textObj: NSText): NSText;
  drawInteriorWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  highlight_withFrame_inView(flag: boolean, cellFrame: NSRect, controlView: NSView): void;
  getPeriodicDelay_interval(delay: number, interval: number): void;
  startTrackingAt_inView(startPoint: NSPoint, controlView: NSView): boolean;
  continueTracking_at_inView(lastPoint: NSPoint, currentPoint: NSPoint, controlView: NSView): boolean;
  stopTracking_at_inView_mouseIsUp(lastPoint: NSPoint, stopPoint: NSPoint, controlView: NSView, flag: boolean): void;
  trackMouse_inRect_ofView_untilMouseUp(event: NSEvent, cellFrame: NSRect, controlView: NSView, flag: boolean): boolean;
  editWithFrame_inView_editor_delegate_event(rect: NSRect, controlView: NSView, textObj: NSText, delegate: any | null, event: NSEvent | null): void;
  selectWithFrame_inView_editor_delegate_start_length(rect: NSRect, controlView: NSView, textObj: NSText, delegate: any | null, selStart: NSInteger, selLength: NSInteger): void;
  endEditing(textObj: NSText): void;
  resetCursorRect_inView(cellFrame: NSRect, controlView: NSView): void;
  menuForEvent_inRect_ofView(event: NSEvent, cellFrame: NSRect, view: NSView): NSMenu;
  takeIntegerValueFrom(sender: any | null): void;
  fieldEditorForView(controlView: NSView): NSTextView;
  draggingImageComponentsWithFrame_inView(frame: NSRect, view: NSView): NSArray<any>;
  performClick(sender: any | null): void;
  drawFocusRingMaskWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  focusRingMaskBoundsForFrame_inView(cellFrame: NSRect, controlView: NSView): NSRect;
  setNextState(): void;
  hitTestForEvent_inRect_ofView(event: NSEvent, cellFrame: NSRect, controlView: NSView): NSCellHitResult;
  expansionFrameWithFrame_inView(cellFrame: NSRect, view: NSView): NSRect;
  drawWithExpansionFrame_inView(cellFrame: NSRect, view: NSView): void;
  entryType(): NSInteger;
  setEntryType(type: NSInteger): void;
  isEntryAcceptable(string: NSString | string): boolean;
  setFloatingPointFormat_left_right(autoRange: boolean, leftDigits: NSUInteger, rightDigits: NSUInteger): void;
  setMnemonicLocation(location: NSUInteger): void;
  mnemonicLocation(): NSUInteger;
  mnemonic(): NSString;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  inheritedBackgroundStyle(): NSBackgroundStyle;
  currentInspectorIconColor(): NSColor;
  drawInspectorButtonImage_centeredInRect(image: NSImage, rect: NSRect): void;
  drawInspectorButtonImage_centeredInRect_accented(image: NSImage, rect: NSRect, accented: boolean): void;
  drawInspectorStatelessControlImage_centeredInRect(image: NSImage, rect: NSRect): void;
  drawInspectorButtonPath_accented_highlighted(path: NSBezierPath, accented: boolean, highlighted: boolean): void;
  drawInspectorTextFieldBackgroundWithPath(path: NSBezierPath): void;
  drawInspectorFocusRingMaskWithWithPath(path: NSBezierPath): void;
  inspectorFocusRingMaskBoundsForFrame_inView(cellFrame: NSRect, controlView: NSView): NSRect;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  static prefersTrackingUntilMouseUp(): boolean;
  controlView(): NSView;
  setControlView(controlView: NSView): void;
  type(): NSCellType;
  setType(type: NSCellType): void;
  state(): NSControlStateValue;
  setState(state: NSControlStateValue): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  opaque(): boolean;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  scrollable(): boolean;
  setScrollable(scrollable: boolean): void;
  highlighted(): boolean;
  setHighlighted(highlighted: boolean): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  wraps(): boolean;
  setWraps(wraps: boolean): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  keyEquivalent(): NSString;
  formatter(): NSFormatter;
  setFormatter(formatter: NSFormatter): void;
  objectValue(): any;
  setObjectValue(objectValue: any): void;
  hasValidObjectValue(): boolean;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  intValue(): number;
  setIntValue(intValue: number): void;
  floatValue(): number;
  setFloatValue(floatValue: number): void;
  doubleValue(): number;
  setDoubleValue(doubleValue: number): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  cellSize(): NSSize;
  mouseDownFlags(): NSInteger;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  static defaultMenu(): NSMenu;
  sendsActionOnEndEditing(): boolean;
  setSendsActionOnEndEditing(sendsActionOnEndEditing: boolean): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  allowsUndo(): boolean;
  setAllowsUndo(allowsUndo: boolean): void;
  integerValue(): NSInteger;
  setIntegerValue(integerValue: NSInteger): void;
  truncatesLastVisibleLine(): boolean;
  setTruncatesLastVisibleLine(truncatesLastVisibleLine: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  usesSingleLineMode(): boolean;
  setUsesSingleLineMode(usesSingleLineMode: boolean): void;
  refusesFirstResponder(): boolean;
  setRefusesFirstResponder(refusesFirstResponder: boolean): void;
  acceptsFirstResponder(): boolean;
  showsFirstResponder(): boolean;
  setShowsFirstResponder(showsFirstResponder: boolean): void;
  focusRingType(): NSFocusRingType;
  setFocusRingType(focusRingType: NSFocusRingType): void;
  static defaultFocusRingType(): NSFocusRingType;
  wantsNotificationForMarkedText(): boolean;
  attributedStringValue(): NSAttributedString;
  setAttributedStringValue(attributedStringValue: NSAttributedString): void;
  allowsEditingTextAttributes(): boolean;
  setAllowsEditingTextAttributes(allowsEditingTextAttributes: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
  allowsMixedState(): boolean;
  setAllowsMixedState(allowsMixedState: boolean): void;
  nextState(): NSInteger;
  backgroundStyle(): NSBackgroundStyle;
  setBackgroundStyle(backgroundStyle: NSBackgroundStyle): void;
  interiorBackgroundStyle(): NSBackgroundStyle;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare type NSControlStateValue = NSInteger

declare type NSCellStateValue = NSControlStateValue

declare enum NSCellType {
  NSNullCellType = 0,
  NSTextCellType = 1,
  NSImageCellType = 2,
}

declare enum NSCellAttribute {
  NSCellDisabled = 0,
  NSCellState = 1,
  NSPushInCell = 2,
  NSCellEditable = 3,
  NSChangeGrayCell = 4,
  NSCellHighlighted = 5,
  NSCellLightsByContents = 6,
  NSCellLightsByGray = 7,
  NSChangeBackgroundCell = 8,
  NSCellLightsByBackground = 9,
  NSCellIsBordered = 10,
  NSCellHasOverlappingImage = 11,
  NSCellHasImageHorizontal = 12,
  NSCellHasImageOnLeftOrBottom = 13,
  NSCellChangesContents = 14,
  NSCellIsInsetButton = 15,
  NSCellAllowsMixedState = 16,
}

declare enum NSCellImagePosition {
  NSNoImage = 0,
  NSImageOnly = 1,
  NSImageLeft = 2,
  NSImageRight = 3,
  NSImageBelow = 4,
  NSImageAbove = 5,
  NSImageOverlaps = 6,
  NSImageLeading = 7,
  NSImageTrailing = 8,
}

declare enum NSImageScaling {
  NSImageScaleProportionallyDown = 0,
  NSImageScaleAxesIndependently,
  NSImageScaleNone,
  NSImageScaleProportionallyUpOrDown,
  NSScaleProportionally = 0,
  NSScaleToFit,
  NSScaleNone,
}

declare enum NSCellStyleMask {
  NSNoCellMask = 0,
  NSContentsCellMask = 1,
  NSPushInCellMask = 2,
  NSChangeGrayCellMask = 4,
  NSChangeBackgroundCellMask = 8,
}

declare enum NSControlTint {
  NSDefaultControlTint = 0,
  NSBlueControlTint = 1,
  NSGraphiteControlTint = 6,
  NSClearControlTint = 7,
}

declare enum NSControlSize {
  NSControlSizeRegular,
  NSControlSizeSmall,
  NSControlSizeMini,
}

declare enum NSCellHitResult {
  NSCellHitNone = 0,
  NSCellHitContentArea = 1 << 0,
  NSCellHitEditableTextArea = 1 << 1,
  NSCellHitTrackableArea = 1 << 2,
}

declare enum NSBackgroundStyle {
  NSBackgroundStyleLight = 0,
  NSBackgroundStyleDark,
  NSBackgroundStyleRaised,
  NSBackgroundStyleLowered,
}

class NSClickGestureRecognizerAllocator<T extends NSClickGestureRecognizer> extends NSGestureRecognizerAllocator<T> {}
declare class NSClickGestureRecognizer extends NSGestureRecognizer implements INSCoding {
  alloc<T extends NSClickGestureRecognizer>(): NSClickGestureRecognizerAllocator<T>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  numberOfClicksRequired(): NSInteger;
  setNumberOfClicksRequired(numberOfClicksRequired: NSInteger): void;
  numberOfTouchesRequired(): NSInteger;
  setNumberOfTouchesRequired(numberOfTouchesRequired: NSInteger): void;
}

class NSClipViewAllocator<T extends NSClipView> extends NSViewAllocator<T> {}
declare class NSClipView extends NSView {
  alloc<T extends NSClipView>(): NSClipViewAllocator<T>;
  viewFrameChanged(notification: NSNotification): void;
  viewBoundsChanged(notification: NSNotification): void;
  autoscroll(event: NSEvent): boolean;
  scrollToPoint(newOrigin: NSPoint): void;
  constrainBoundsRect(proposedBounds: NSRect): NSRect;
  constrainScrollPoint(newOrigin: NSPoint): NSPoint;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  documentView(): NSView;
  setDocumentView(documentView: NSView): void;
  documentRect(): NSRect;
  documentCursor(): NSCursor;
  setDocumentCursor(documentCursor: NSCursor): void;
  documentVisibleRect(): NSRect;
  copiesOnScroll(): boolean;
  setCopiesOnScroll(copiesOnScroll: boolean): void;
  contentInsets(): NSEdgeInsets;
  setContentInsets(contentInsets: NSEdgeInsets): void;
  automaticallyAdjustsContentInsets(): boolean;
  setAutomaticallyAdjustsContentInsets(automaticallyAdjustsContentInsets: boolean): void;
}

class NSCollectionViewItemAllocator<T extends NSCollectionViewItem> extends NSViewControllerAllocator<T> {}
declare class NSCollectionViewItem extends NSViewController implements INSCopying, INSCollectionViewElement {
  alloc<T extends NSCollectionViewItem>(): NSCollectionViewItemAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  collectionView(): NSCollectionView;
  selected(): boolean;
  setSelected(selected: boolean): void;
  highlightState(): NSCollectionViewItemHighlightState;
  setHighlightState(highlightState: NSCollectionViewItemHighlightState): void;
  imageView(): NSImageView;
  setImageView(imageView: NSImageView): void;
  textField(): NSTextField;
  setTextField(textField: NSTextField): void;
  draggingImageComponents(): NSArray<any>;
}

class NSCollectionViewAllocator<T extends NSCollectionView> extends NSViewAllocator<T> {}
declare class NSCollectionView extends NSView implements INSDraggingSource, INSDraggingDestination {
  alloc<T extends NSCollectionView>(): NSCollectionViewAllocator<T>;
  reloadData(): void;
  layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryElementOfKind_atIndexPath(kind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  frameForItemAtIndex(index: NSUInteger): NSRect;
  frameForItemAtIndex_withNumberOfItems(index: NSUInteger, numberOfItems: NSUInteger): NSRect;
  numberOfItemsInSection(section: NSInteger): NSInteger;
  selectItemsAtIndexPaths_scrollPosition(indexPaths: NSSet<any>, scrollPosition: NSCollectionViewScrollPosition): void;
  deselectItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  selectAll(sender: any | null): IBAction;
  deselectAll(sender: any | null): IBAction;
  registerClass_forItemWithIdentifier(itemClass: any | null, identifier: NSUserInterfaceItemIdentifier): void;
  registerNib_forItemWithIdentifier(nib: NSNib | null, identifier: NSUserInterfaceItemIdentifier): void;
  registerClass_forSupplementaryViewOfKind_withIdentifier(viewClass: any | null, kind: NSCollectionViewSupplementaryElementKind, identifier: NSUserInterfaceItemIdentifier): void;
  registerNib_forSupplementaryViewOfKind_withIdentifier(nib: NSNib | null, kind: NSCollectionViewSupplementaryElementKind, identifier: NSUserInterfaceItemIdentifier): void;
  makeItemWithIdentifier_forIndexPath(identifier: NSUserInterfaceItemIdentifier, indexPath: NSIndexPath): NSCollectionViewItem;
  makeSupplementaryViewOfKind_withIdentifier_forIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, identifier: NSUserInterfaceItemIdentifier, indexPath: NSIndexPath): NSView;
  newItemForRepresentedObject(object: any): NSCollectionViewItem;
  itemAtIndex(index: NSUInteger): NSCollectionViewItem;
  itemAtIndexPath(indexPath: NSIndexPath): NSCollectionViewItem;
  visibleItems(): NSArray<any>;
  indexPathsForVisibleItems(): NSSet<any>;
  indexPathForItem(item: NSCollectionViewItem): NSIndexPath;
  indexPathForItemAtPoint(point: NSPoint): NSIndexPath;
  supplementaryViewForElementKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSView;
  visibleSupplementaryViewsOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSArray<any>;
  indexPathsForVisibleSupplementaryElementsOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSSet<any>;
  insertSections(sections: NSIndexSet): void;
  deleteSections(sections: NSIndexSet): void;
  reloadSections(sections: NSIndexSet): void;
  moveSection_toSection(section: NSInteger, newSection: NSInteger): void;
  insertItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  deleteItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  reloadItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  moveItemAtIndexPath_toIndexPath(indexPath: NSIndexPath, newIndexPath: NSIndexPath): void;
  performBatchUpdates_completionHandler(updates: Block, completionHandler: Block): void;
  toggleSectionCollapse(sender: any): IBAction;
  scrollToItemsAtIndexPaths_scrollPosition(indexPaths: NSSet<any>, scrollPosition: NSCollectionViewScrollPosition): void;
  setDraggingSourceOperationMask_forLocal(dragOperationMask: NSDragOperation, localDestination: boolean): void;
  draggingImageForItemsAtIndexPaths_withEvent_offset(indexPaths: NSSet<any>, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  draggingImageForItemsAtIndexes_withEvent_offset(indexes: NSIndexSet, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  prefetchDataSource(): any;
  setPrefetchDataSource(prefetchDataSource: any): void;
  content(): NSArray<any>;
  setContent(content: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  backgroundView(): NSView;
  setBackgroundView(backgroundView: NSView): void;
  backgroundViewScrollsWithContent(): boolean;
  setBackgroundViewScrollsWithContent(backgroundViewScrollsWithContent: boolean): void;
  collectionViewLayout(): NSCollectionViewLayout;
  setCollectionViewLayout(collectionViewLayout: NSCollectionViewLayout): void;
  maxNumberOfRows(): NSUInteger;
  setMaxNumberOfRows(maxNumberOfRows: NSUInteger): void;
  maxNumberOfColumns(): NSUInteger;
  setMaxNumberOfColumns(maxNumberOfColumns: NSUInteger): void;
  minItemSize(): NSSize;
  setMinItemSize(minItemSize: NSSize): void;
  maxItemSize(): NSSize;
  setMaxItemSize(maxItemSize: NSSize): void;
  backgroundColors(): NSArray<any>;
  setBackgroundColors(backgroundColors: NSArray<any> | any[]): void;
  numberOfSections(): NSInteger;
  firstResponder(): boolean;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  selectionIndexes(): NSIndexSet;
  setSelectionIndexes(selectionIndexes: NSIndexSet): void;
  selectionIndexPaths(): NSSet<any>;
  setSelectionIndexPaths(selectionIndexPaths: NSSet<any>): void;
  itemPrototype(): NSCollectionViewItem;
  setItemPrototype(itemPrototype: NSCollectionViewItem): void;
}

declare interface INSCollectionViewSectionHeaderView {

  sectionCollapseButton(): NSButton;
  setSectionCollapseButton(sectionCollapseButton: NSButton): void;
}

declare interface INSCollectionViewDataSource {
  collectionView_numberOfItemsInSection(collectionView: NSCollectionView, section: NSInteger): NSInteger;
  collectionView_itemForRepresentedObjectAtIndexPath(collectionView: NSCollectionView, indexPath: NSIndexPath): NSCollectionViewItem;
  numberOfSectionsInCollectionView(collectionView: NSCollectionView): NSInteger;
  collectionView_viewForSupplementaryElementOfKind_atIndexPath(collectionView: NSCollectionView, kind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSView;
}

declare interface INSCollectionViewPrefetching {
  collectionView_prefetchItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSArray<any> | any[]): void;
  collectionView_cancelPrefetchingForItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSArray<any> | any[]): void;
}

declare interface INSCollectionViewDelegate {
  collectionView_canDragItemsAtIndexPaths_withEvent(collectionView: NSCollectionView, indexPaths: NSSet<any>, event: NSEvent): boolean;
  collectionView_canDragItemsAtIndexes_withEvent(collectionView: NSCollectionView, indexes: NSIndexSet, event: NSEvent): boolean;
  collectionView_writeItemsAtIndexPaths_toPasteboard(collectionView: NSCollectionView, indexPaths: NSSet<any>, pasteboard: NSPasteboard): boolean;
  collectionView_writeItemsAtIndexes_toPasteboard(collectionView: NSCollectionView, indexes: NSIndexSet, pasteboard: NSPasteboard): boolean;
  collectionView_namesOfPromisedFilesDroppedAtDestination_forDraggedItemsAtIndexPaths(collectionView: NSCollectionView, dropURL: NSURL, indexPaths: NSSet<any>): NSArray<any>;
  collectionView_namesOfPromisedFilesDroppedAtDestination_forDraggedItemsAtIndexes(collectionView: NSCollectionView, dropURL: NSURL, indexes: NSIndexSet): NSArray<any>;
  collectionView_draggingImageForItemsAtIndexPaths_withEvent_offset(collectionView: NSCollectionView, indexPaths: NSSet<any>, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  collectionView_draggingImageForItemsAtIndexes_withEvent_offset(collectionView: NSCollectionView, indexes: NSIndexSet, event: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  collectionView_validateDrop_proposedIndexPath_dropOperation(collectionView: NSCollectionView, draggingInfo: any, proposedDropIndexPath: NSIndexPath, proposedDropOperation: NSCollectionViewDropOperation): NSDragOperation;
  collectionView_validateDrop_proposedIndex_dropOperation(collectionView: NSCollectionView, draggingInfo: any, proposedDropIndex: NSInteger, proposedDropOperation: NSCollectionViewDropOperation): NSDragOperation;
  collectionView_acceptDrop_indexPath_dropOperation(collectionView: NSCollectionView, draggingInfo: any, indexPath: NSIndexPath, dropOperation: NSCollectionViewDropOperation): boolean;
  collectionView_acceptDrop_index_dropOperation(collectionView: NSCollectionView, draggingInfo: any, index: NSInteger, dropOperation: NSCollectionViewDropOperation): boolean;
  collectionView_pasteboardWriterForItemAtIndexPath(collectionView: NSCollectionView, indexPath: NSIndexPath): any;
  collectionView_pasteboardWriterForItemAtIndex(collectionView: NSCollectionView, index: NSUInteger): any;
  collectionView_draggingSession_willBeginAtPoint_forItemsAtIndexPaths(collectionView: NSCollectionView, session: NSDraggingSession, screenPoint: NSPoint, indexPaths: NSSet<any>): void;
  collectionView_draggingSession_willBeginAtPoint_forItemsAtIndexes(collectionView: NSCollectionView, session: NSDraggingSession, screenPoint: NSPoint, indexes: NSIndexSet): void;
  collectionView_draggingSession_endedAtPoint_dragOperation(collectionView: NSCollectionView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  collectionView_updateDraggingItemsForDrag(collectionView: NSCollectionView, draggingInfo: any): void;
  collectionView_shouldChangeItemsAtIndexPaths_toHighlightState(collectionView: NSCollectionView, indexPaths: NSSet<any>, highlightState: NSCollectionViewItemHighlightState): NSSet<any>;
  collectionView_didChangeItemsAtIndexPaths_toHighlightState(collectionView: NSCollectionView, indexPaths: NSSet<any>, highlightState: NSCollectionViewItemHighlightState): void;
  collectionView_shouldSelectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): NSSet<any>;
  collectionView_shouldDeselectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): NSSet<any>;
  collectionView_didSelectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): void;
  collectionView_didDeselectItemsAtIndexPaths(collectionView: NSCollectionView, indexPaths: NSSet<any>): void;
  collectionView_willDisplayItem_forRepresentedObjectAtIndexPath(collectionView: NSCollectionView, item: NSCollectionViewItem, indexPath: NSIndexPath): void;
  collectionView_willDisplaySupplementaryView_forElementKind_atIndexPath(collectionView: NSCollectionView, view: NSView, elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): void;
  collectionView_didEndDisplayingItem_forRepresentedObjectAtIndexPath(collectionView: NSCollectionView, item: NSCollectionViewItem, indexPath: NSIndexPath): void;
  collectionView_didEndDisplayingSupplementaryView_forElementOfKind_atIndexPath(collectionView: NSCollectionView, view: NSView, elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): void;
  collectionView_transitionLayoutForOldLayout_newLayout(collectionView: NSCollectionView, fromLayout: NSCollectionViewLayout, toLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
}

declare type NSCollectionViewSupplementaryElementKind = NSString

declare enum NSCollectionViewDropOperation {
  NSCollectionViewDropOn = 0,
  NSCollectionViewDropBefore = 1,
}

declare enum NSCollectionViewItemHighlightState {
  NSCollectionViewItemHighlightNone = 0,
  NSCollectionViewItemHighlightForSelection = 1,
  NSCollectionViewItemHighlightForDeselection = 2,
  NSCollectionViewItemHighlightAsDropTarget = 3,
}

declare enum NSCollectionViewScrollPosition {
  NSCollectionViewScrollPositionNone = 0,
  NSCollectionViewScrollPositionTop = 1 << 0,
  NSCollectionViewScrollPositionCenteredVertically = 1 << 1,
  NSCollectionViewScrollPositionBottom = 1 << 2,
  NSCollectionViewScrollPositionNearestHorizontalEdge = 1 << 9,
  NSCollectionViewScrollPositionLeft = 1 << 3,
  NSCollectionViewScrollPositionCenteredHorizontally = 1 << 4,
  NSCollectionViewScrollPositionRight = 1 << 5,
  NSCollectionViewScrollPositionLeadingEdge = 1 << 6,
  NSCollectionViewScrollPositionTrailingEdge = 1 << 7,
  NSCollectionViewScrollPositionNearestVerticalEdge = 1 << 8,
}

class NSCollectionViewFlowLayoutInvalidationContextAllocator<T extends NSCollectionViewFlowLayoutInvalidationContext> extends NSCollectionViewLayoutInvalidationContextAllocator<T> {}
declare class NSCollectionViewFlowLayoutInvalidationContext extends NSCollectionViewLayoutInvalidationContext {
  alloc<T extends NSCollectionViewFlowLayoutInvalidationContext>(): NSCollectionViewFlowLayoutInvalidationContextAllocator<T>;

  invalidateFlowLayoutDelegateMetrics(): boolean;
  setInvalidateFlowLayoutDelegateMetrics(invalidateFlowLayoutDelegateMetrics: boolean): void;
  invalidateFlowLayoutAttributes(): boolean;
  setInvalidateFlowLayoutAttributes(invalidateFlowLayoutAttributes: boolean): void;
}

class NSCollectionViewFlowLayoutAllocator<T extends NSCollectionViewFlowLayout> extends NSCollectionViewLayoutAllocator<T> {}
declare class NSCollectionViewFlowLayout extends NSCollectionViewLayout {
  alloc<T extends NSCollectionViewFlowLayout>(): NSCollectionViewFlowLayoutAllocator<T>;
  sectionAtIndexIsCollapsed(sectionIndex: NSUInteger): boolean;
  collapseSectionAtIndex(sectionIndex: NSUInteger): void;
  expandSectionAtIndex(sectionIndex: NSUInteger): void;

  minimumLineSpacing(): CGFloat;
  setMinimumLineSpacing(minimumLineSpacing: CGFloat): void;
  minimumInteritemSpacing(): CGFloat;
  setMinimumInteritemSpacing(minimumInteritemSpacing: CGFloat): void;
  itemSize(): NSSize;
  setItemSize(itemSize: NSSize): void;
  estimatedItemSize(): NSSize;
  setEstimatedItemSize(estimatedItemSize: NSSize): void;
  scrollDirection(): NSCollectionViewScrollDirection;
  setScrollDirection(scrollDirection: NSCollectionViewScrollDirection): void;
  headerReferenceSize(): NSSize;
  setHeaderReferenceSize(headerReferenceSize: NSSize): void;
  footerReferenceSize(): NSSize;
  setFooterReferenceSize(footerReferenceSize: NSSize): void;
  sectionInset(): NSEdgeInsets;
  setSectionInset(sectionInset: NSEdgeInsets): void;
  sectionHeadersPinToVisibleBounds(): boolean;
  setSectionHeadersPinToVisibleBounds(sectionHeadersPinToVisibleBounds: boolean): void;
  sectionFootersPinToVisibleBounds(): boolean;
  setSectionFootersPinToVisibleBounds(sectionFootersPinToVisibleBounds: boolean): void;
}

declare interface INSCollectionViewDelegateFlowLayout {
  collectionView_layout_sizeForItemAtIndexPath(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, indexPath: NSIndexPath): NSSize;
  collectionView_layout_insetForSectionAtIndex(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): NSEdgeInsets;
  collectionView_layout_minimumLineSpacingForSectionAtIndex(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): CGFloat;
  collectionView_layout_minimumInteritemSpacingForSectionAtIndex(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): CGFloat;
  collectionView_layout_referenceSizeForHeaderInSection(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): NSSize;
  collectionView_layout_referenceSizeForFooterInSection(collectionView: NSCollectionView, collectionViewLayout: NSCollectionViewLayout, section: NSInteger): NSSize;
}

declare enum NSCollectionViewScrollDirection {
  NSCollectionViewScrollDirectionVertical,
  NSCollectionViewScrollDirectionHorizontal,
}

class NSCollectionViewGridLayoutAllocator<T extends NSCollectionViewGridLayout> extends NSCollectionViewLayoutAllocator<T> {}
declare class NSCollectionViewGridLayout extends NSCollectionViewLayout {
  alloc<T extends NSCollectionViewGridLayout>(): NSCollectionViewGridLayoutAllocator<T>;

  margins(): NSEdgeInsets;
  setMargins(margins: NSEdgeInsets): void;
  minimumInteritemSpacing(): CGFloat;
  setMinimumInteritemSpacing(minimumInteritemSpacing: CGFloat): void;
  minimumLineSpacing(): CGFloat;
  setMinimumLineSpacing(minimumLineSpacing: CGFloat): void;
  maximumNumberOfRows(): NSUInteger;
  setMaximumNumberOfRows(maximumNumberOfRows: NSUInteger): void;
  maximumNumberOfColumns(): NSUInteger;
  setMaximumNumberOfColumns(maximumNumberOfColumns: NSUInteger): void;
  minimumItemSize(): NSSize;
  setMinimumItemSize(minimumItemSize: NSSize): void;
  maximumItemSize(): NSSize;
  setMaximumItemSize(maximumItemSize: NSSize): void;
  backgroundColors(): NSArray<any>;
  setBackgroundColors(backgroundColors: NSArray<any> | any[]): void;
}

class NSCollectionViewLayoutAttributesAllocator<T extends NSCollectionViewLayoutAttributes> extends NSObjectAllocator<T> {}
declare class NSCollectionViewLayoutAttributes extends NSObject implements INSCopying {
  alloc<T extends NSCollectionViewLayoutAttributes>(): NSCollectionViewLayoutAttributesAllocator<T>;
  static layoutAttributesForItemWithIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  static layoutAttributesForInterItemGapBeforeIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  static layoutAttributesForSupplementaryViewOfKind_withIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  static layoutAttributesForDecorationViewOfKind_withIndexPath(decorationViewKind: NSCollectionViewDecorationElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  frame(): NSRect;
  setFrame(frame: NSRect): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  alpha(): CGFloat;
  setAlpha(alpha: CGFloat): void;
  zIndex(): NSInteger;
  setZIndex(zIndex: NSInteger): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  indexPath(): NSIndexPath;
  setIndexPath(indexPath: NSIndexPath): void;
  representedElementCategory(): NSCollectionElementCategory;
  representedElementKind(): NSString;
}

class NSCollectionViewUpdateItemAllocator<T extends NSCollectionViewUpdateItem> extends NSObjectAllocator<T> {}
declare class NSCollectionViewUpdateItem extends NSObject {
  alloc<T extends NSCollectionViewUpdateItem>(): NSCollectionViewUpdateItemAllocator<T>;

  indexPathBeforeUpdate(): NSIndexPath;
  indexPathAfterUpdate(): NSIndexPath;
  updateAction(): NSCollectionUpdateAction;
}

class NSCollectionViewLayoutInvalidationContextAllocator<T extends NSCollectionViewLayoutInvalidationContext> extends NSObjectAllocator<T> {}
declare class NSCollectionViewLayoutInvalidationContext extends NSObject {
  alloc<T extends NSCollectionViewLayoutInvalidationContext>(): NSCollectionViewLayoutInvalidationContextAllocator<T>;
  invalidateItemsAtIndexPaths(indexPaths: NSSet<any>): void;
  invalidateSupplementaryElementsOfKind_atIndexPaths(elementKind: NSCollectionViewSupplementaryElementKind, indexPaths: NSSet<any>): void;
  invalidateDecorationElementsOfKind_atIndexPaths(elementKind: NSCollectionViewDecorationElementKind, indexPaths: NSSet<any>): void;

  invalidateEverything(): boolean;
  invalidateDataSourceCounts(): boolean;
  invalidatedItemIndexPaths(): NSSet<any>;
  invalidatedSupplementaryIndexPaths(): NSDictionary<any, any>;
  invalidatedDecorationIndexPaths(): NSDictionary<any, any>;
  contentOffsetAdjustment(): NSPoint;
  setContentOffsetAdjustment(contentOffsetAdjustment: NSPoint): void;
  contentSizeAdjustment(): NSSize;
  setContentSizeAdjustment(contentSizeAdjustment: NSSize): void;
}

class NSCollectionViewLayoutAllocator<T extends NSCollectionViewLayout> extends NSObjectAllocator<T> {
  initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath): T;
  initialLayoutAttributesForAppearingSupplementaryElementOfKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, elementIndexPath: NSIndexPath): T;
  initialLayoutAttributesForAppearingDecorationElementOfKind_atIndexPath(elementKind: NSCollectionViewDecorationElementKind, decorationIndexPath: NSIndexPath): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSCollectionViewLayout extends NSObject implements INSCoding {
  alloc<T extends NSCollectionViewLayout>(): NSCollectionViewLayoutAllocator<T>;
  invalidateLayout(): void;
  invalidateLayoutWithContext(context: NSCollectionViewLayoutInvalidationContext): void;
  registerClass_forDecorationViewOfKind(viewClass: any | null, elementKind: NSCollectionViewDecorationElementKind): void;
  registerNib_forDecorationViewOfKind(nib: NSNib | null, elementKind: NSCollectionViewDecorationElementKind): void;
  prepareLayout(): void;
  layoutAttributesForElementsInRect(rect: NSRect): NSArray<any>;
  layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryViewOfKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForDecorationViewOfKind_atIndexPath(elementKind: NSCollectionViewDecorationElementKind, indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForDropTargetAtPoint(pointInCollectionView: NSPoint): NSCollectionViewLayoutAttributes;
  layoutAttributesForInterItemGapBeforeIndexPath(indexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  shouldInvalidateLayoutForBoundsChange(newBounds: NSRect): boolean;
  invalidationContextForBoundsChange(newBounds: NSRect): NSCollectionViewLayoutInvalidationContext;
  shouldInvalidateLayoutForPreferredLayoutAttributes_withOriginalAttributes(preferredAttributes: NSCollectionViewLayoutAttributes, originalAttributes: NSCollectionViewLayoutAttributes): boolean;
  invalidationContextForPreferredLayoutAttributes_withOriginalAttributes(preferredAttributes: NSCollectionViewLayoutAttributes, originalAttributes: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutInvalidationContext;
  targetContentOffsetForProposedContentOffset_withScrollingVelocity(proposedContentOffset: NSPoint, velocity: NSPoint): NSPoint;
  targetContentOffsetForProposedContentOffset(proposedContentOffset: NSPoint): NSPoint;
  prepareForCollectionViewUpdates(updateItems: NSArray<any> | any[]): void;
  finalizeCollectionViewUpdates(): void;
  prepareForAnimatedBoundsChange(oldBounds: NSRect): void;
  finalizeAnimatedBoundsChange(): void;
  prepareForTransitionToLayout(newLayout: NSCollectionViewLayout): void;
  prepareForTransitionFromLayout(oldLayout: NSCollectionViewLayout): void;
  finalizeLayoutTransition(): void;
  finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  finalLayoutAttributesForDisappearingSupplementaryElementOfKind_atIndexPath(elementKind: NSCollectionViewSupplementaryElementKind, elementIndexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  finalLayoutAttributesForDisappearingDecorationElementOfKind_atIndexPath(elementKind: NSCollectionViewDecorationElementKind, decorationIndexPath: NSIndexPath): NSCollectionViewLayoutAttributes;
  indexPathsToDeleteForSupplementaryViewOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSSet<any>;
  indexPathsToDeleteForDecorationViewOfKind(elementKind: NSCollectionViewDecorationElementKind): NSSet<any>;
  indexPathsToInsertForSupplementaryViewOfKind(elementKind: NSCollectionViewSupplementaryElementKind): NSSet<any>;
  indexPathsToInsertForDecorationViewOfKind(elementKind: NSCollectionViewDecorationElementKind): NSSet<any>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  collectionView(): NSCollectionView;
  static layoutAttributesClass(): any;
  static invalidationContextClass(): any;
  collectionViewContentSize(): NSSize;
}

declare type NSCollectionViewDecorationElementKind = NSString

declare enum NSCollectionElementCategory {
  NSCollectionElementCategoryItem,
  NSCollectionElementCategorySupplementaryView,
  NSCollectionElementCategoryDecorationView,
  NSCollectionElementCategoryInterItemGap,
}

declare enum NSCollectionUpdateAction {
  NSCollectionUpdateActionInsert,
  NSCollectionUpdateActionDelete,
  NSCollectionUpdateActionReload,
  NSCollectionUpdateActionMove,
  NSCollectionUpdateActionNone,
}

class NSCollectionViewTransitionLayoutAllocator<T extends NSCollectionViewTransitionLayout> extends NSCollectionViewLayoutAllocator<T> {
  initWithCurrentLayout_nextLayout(currentLayout: NSCollectionViewLayout, newLayout: NSCollectionViewLayout): T;
}
declare class NSCollectionViewTransitionLayout extends NSCollectionViewLayout {
  alloc<T extends NSCollectionViewTransitionLayout>(): NSCollectionViewTransitionLayoutAllocator<T>;
  updateValue_forAnimatedKey(value: CGFloat, key: NSCollectionViewTransitionLayoutAnimatedKey): void;
  valueForAnimatedKey(key: NSCollectionViewTransitionLayoutAnimatedKey): CGFloat;

  transitionProgress(): CGFloat;
  setTransitionProgress(transitionProgress: CGFloat): void;
  currentLayout(): NSCollectionViewLayout;
  nextLayout(): NSCollectionViewLayout;
}

declare type NSCollectionViewTransitionLayoutAnimatedKey = NSString

class NSColorAllocator<T extends NSColor> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): T;
}
declare class NSColor extends NSObject implements INSCopying, INSSecureCoding, INSPasteboardReading, INSPasteboardWriting {
  alloc<T extends NSColor>(): NSColorAllocator<T>;
  static colorWithColorSpace_components_count(space: NSColorSpace, components: CGFloat, numberOfComponents: NSInteger): NSColor;
  static colorWithSRGBRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  static colorWithGenericGamma22White_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  static colorWithDisplayP3Red_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  static colorWithWhite_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  static colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  static colorWithHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  static colorWithColorSpace_hue_saturation_brightness_alpha(space: NSColorSpace, hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  static colorWithCatalogName_colorName(listName: NSColorListName, colorName: NSColorName): NSColor;
  static colorNamed_bundle(name: NSColorName, bundle: NSBundle | null): NSColor;
  static colorNamed(name: NSColorName): NSColor;
  static colorWithDeviceWhite_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  static colorWithDeviceRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  static colorWithDeviceHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  static colorWithDeviceCyan_magenta_yellow_black_alpha(cyan: CGFloat, magenta: CGFloat, yellow: CGFloat, black: CGFloat, alpha: CGFloat): NSColor;
  static colorWithCalibratedWhite_alpha(white: CGFloat, alpha: CGFloat): NSColor;
  static colorWithCalibratedRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): NSColor;
  static colorWithCalibratedHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): NSColor;
  static colorWithPatternImage(image: NSImage): NSColor;
  colorUsingType(type: NSColorType): NSColor;
  colorUsingColorSpace(space: NSColorSpace): NSColor;
  static colorForControlTint(controlTint: NSControlTint): NSColor;
  highlightWithLevel(val: CGFloat): NSColor;
  shadowWithLevel(val: CGFloat): NSColor;
  set(): void;
  setFill(): void;
  setStroke(): void;
  blendedColorWithFraction_ofColor(fraction: CGFloat, color: NSColor): NSColor;
  colorWithAlphaComponent(alpha: CGFloat): NSColor;
  getRed_green_blue_alpha(red: CGFloat | null, green: CGFloat | null, blue: CGFloat | null, alpha: CGFloat | null): void;
  getHue_saturation_brightness_alpha(hue: CGFloat | null, saturation: CGFloat | null, brightness: CGFloat | null, alpha: CGFloat | null): void;
  getWhite_alpha(white: CGFloat | null, alpha: CGFloat | null): void;
  getCyan_magenta_yellow_black_alpha(cyan: CGFloat | null, magenta: CGFloat | null, yellow: CGFloat | null, black: CGFloat | null, alpha: CGFloat | null): void;
  getComponents(components: CGFloat): void;
  static colorFromPasteboard(pasteBoard: NSPasteboard): NSColor;
  writeToPasteboard(pasteBoard: NSPasteboard): void;
  drawSwatchInRect(rect: NSRect): void;
  static colorWithCGColor(cgColor: CGColorRef): NSColor;
  colorUsingColorSpaceName_device(name: NSColorSpaceName | null, deviceDescription: NSDictionary<any, any> | {[key: string]: any} | null): NSColor;
  colorUsingColorSpaceName(name: NSColorSpaceName): NSColor;
  static colorWithCIColor(color: CIColor): NSColor;
  static colorWithGray(gray: CGFloat): NSColor;
  static colorWithGray_alpha(gray: CGFloat, alpha: CGFloat): NSColor;
  fuzzyIsEqual(object: any): boolean;
  newCGColor(): CGColorRef;
  isWhite(): boolean;
  static tintColorIntense(): NSColor;
  static tintColorIntenseDark(): NSColor;
  static tintColorNormal(): NSColor;
  static tintColorNormalDark(): NSColor;
  static tintColorMild(): NSColor;
  static tintColorMildDark(): NSColor;
  colorByApplyingModifier(modifier: NSString | string): NSColor;
  colorByApplyingModifiers(modifiers: NSArray<any> | any[]): NSColor;
  stringValueWithAlpha(includeAlpha: boolean): NSString;
  hexValue(): NSString;
  static inspectorViewBackgroundColor(): NSColor;
  static inspectorLabelTextColor(): NSColor;
  static inspectorInlineLabelColor(): NSColor;
  static inspectorLabelBackgroundColor(): NSColor;
  static inspectorLabelBorderColor(): NSColor;
  static inspectorBorderColor(): NSColor;
  static inspectorHighlightedBorderColor(): NSColor;
  static inspectorAccentColor(): NSColor;
  static inspectorHighlightedAccentColor(): NSColor;
  static inspectorButtonBackgroundColor(): NSColor;
  static inspectorButtonHighlightedBackgroundColor(): NSColor;
  static inspectorIconColor(): NSColor;
  static inspectorDisabledIconColor(): NSColor;
  static inspectorHighlightedIconColor(): NSColor;
  static inspectorAccentedIconColor(): NSColor;
  static inspectorSliderRightTrackColor(): NSColor;
  static inspectorSliderKnobColor(): NSColor;
  static inspectorHighlightedSliderKnobColor(): NSColor;
  static inspectorSliderKnobBorderColor(): NSColor;
  static inspectorSectionHeaderForegroundColor(): NSColor;
  static inspectorResizePreviewBackgroundColor(): NSColor;
  static inspectorResizePreviewEdgeIndicatorColor(): NSColor;
  static inspectorResizePreviewInnerLayerColor(): NSColor;
  static inspectorResizePreviewInnerLayerBorderColor(): NSColor;
  colorTranslatedToColorSpace(colorSpace: NSColorSpace): NSColor;
  copyWithZone(zone: NSZone | null): any;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  copyWithZone(zone: NSZone | null): any;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;

  type(): NSColorType;
  static blackColor(): NSColor;
  static darkGrayColor(): NSColor;
  static lightGrayColor(): NSColor;
  static whiteColor(): NSColor;
  static grayColor(): NSColor;
  static redColor(): NSColor;
  static greenColor(): NSColor;
  static blueColor(): NSColor;
  static cyanColor(): NSColor;
  static yellowColor(): NSColor;
  static magentaColor(): NSColor;
  static orangeColor(): NSColor;
  static purpleColor(): NSColor;
  static brownColor(): NSColor;
  static clearColor(): NSColor;
  static controlShadowColor(): NSColor;
  static controlDarkShadowColor(): NSColor;
  static controlColor(): NSColor;
  static controlHighlightColor(): NSColor;
  static controlLightHighlightColor(): NSColor;
  static controlTextColor(): NSColor;
  static controlBackgroundColor(): NSColor;
  static selectedControlColor(): NSColor;
  static secondarySelectedControlColor(): NSColor;
  static selectedControlTextColor(): NSColor;
  static disabledControlTextColor(): NSColor;
  static textColor(): NSColor;
  static textBackgroundColor(): NSColor;
  static selectedTextColor(): NSColor;
  static selectedTextBackgroundColor(): NSColor;
  static gridColor(): NSColor;
  static keyboardFocusIndicatorColor(): NSColor;
  static windowBackgroundColor(): NSColor;
  static underPageBackgroundColor(): NSColor;
  static labelColor(): NSColor;
  static secondaryLabelColor(): NSColor;
  static tertiaryLabelColor(): NSColor;
  static quaternaryLabelColor(): NSColor;
  static scrollBarColor(): NSColor;
  static knobColor(): NSColor;
  static selectedKnobColor(): NSColor;
  static windowFrameColor(): NSColor;
  static windowFrameTextColor(): NSColor;
  static selectedMenuItemColor(): NSColor;
  static selectedMenuItemTextColor(): NSColor;
  static highlightColor(): NSColor;
  static shadowColor(): NSColor;
  static headerColor(): NSColor;
  static headerTextColor(): NSColor;
  static alternateSelectedControlColor(): NSColor;
  static alternateSelectedControlTextColor(): NSColor;
  static scrubberTexturedBackgroundColor(): NSColor;
  static controlAlternatingRowBackgroundColors(): NSArray<any>;
  static systemRedColor(): NSColor;
  static systemGreenColor(): NSColor;
  static systemBlueColor(): NSColor;
  static systemOrangeColor(): NSColor;
  static systemYellowColor(): NSColor;
  static systemBrownColor(): NSColor;
  static systemPinkColor(): NSColor;
  static systemPurpleColor(): NSColor;
  static systemGrayColor(): NSColor;
  static currentControlTint(): NSControlTint;
  catalogNameComponent(): NSColorListName;
  colorNameComponent(): NSColorName;
  localizedCatalogNameComponent(): NSString;
  localizedColorNameComponent(): NSString;
  redComponent(): CGFloat;
  greenComponent(): CGFloat;
  blueComponent(): CGFloat;
  hueComponent(): CGFloat;
  saturationComponent(): CGFloat;
  brightnessComponent(): CGFloat;
  whiteComponent(): CGFloat;
  cyanComponent(): CGFloat;
  magentaComponent(): CGFloat;
  yellowComponent(): CGFloat;
  blackComponent(): CGFloat;
  colorSpace(): NSColorSpace;
  numberOfComponents(): NSInteger;
  patternImage(): NSImage;
  alphaComponent(): CGFloat;
  CGColor(): CGColorRef;
  static ignoresAlpha(): boolean;
  static setIgnoresAlpha(ignoresAlpha: boolean): void;
  colorSpaceName(): NSColorSpaceName;
  themeCachingKey(): NSString;
  setThemeCachingKey(themeCachingKey: NSString | string): void;
  manifestComponents(): NSArray<any>;
  static supportsSecureCoding(): boolean;
}

class CIColorAllocator<T extends CIColor> {
  initWithColor(color: NSColor): T;
}
declare class CIColor {
  alloc<T extends CIColor>(): CIColorAllocator<T>;
}

declare enum NSColorType {
  NSColorTypeComponentBased,
  NSColorTypePattern,
  NSColorTypeCatalog,
}

class NSColorListAllocator<T extends NSColorList> extends NSObjectAllocator<T> {
  initWithName(name: NSColorListName): T;
  initWithName_fromFile(name: NSColorListName, path: NSString | string | null): T;
}
declare class NSColorList extends NSObject implements INSSecureCoding {
  alloc<T extends NSColorList>(): NSColorListAllocator<T>;
  static colorListNamed(name: NSColorListName): NSColorList;
  setColor_forKey(color: NSColor, key: NSColorName): void;
  insertColor_key_atIndex(color: NSColor, key: NSColorName, loc: NSUInteger): void;
  removeColorWithKey(key: NSColorName): void;
  colorWithKey(key: NSColorName): NSColor;
  writeToURL_error(url: NSURL | null, errPtr: NSError): boolean;
  writeToFile(path: NSString | string | null): boolean;
  removeFile(): void;

  static availableColorLists(): NSArray<any>;
  name(): NSColorListName;
  allKeys(): NSArray<any>;
  editable(): boolean;
  static supportsSecureCoding(): boolean;
}

declare type NSColorListName = NSString

declare type NSColorName = NSString

class NSColorPanelAllocator<T extends NSColorPanel> extends NSPanelAllocator<T> {}
declare class NSColorPanel extends NSPanel {
  alloc<T extends NSColorPanel>(): NSColorPanelAllocator<T>;
  static dragColor_withEvent_fromView(color: NSColor, event: NSEvent, sourceView: NSView): boolean;
  static setPickerMask(mask: NSColorPanelOptions): void;
  static setPickerMode(mode: NSColorPanelMode): void;
  setAction(selector: string | null): void;
  setTarget(target: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  shouldIgnoreChangeColorMessage(): boolean;
  shouldIgnoreNonInteractiveChangeColorMessage(): boolean;
  setColorWithoutNotifying(color: NSColor): void;

  static sharedColorPanel(): NSColorPanel;
  static sharedColorPanelExists(): boolean;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  showsAlpha(): boolean;
  setShowsAlpha(showsAlpha: boolean): void;
  mode(): NSColorPanelMode;
  setMode(mode: NSColorPanelMode): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  alpha(): CGFloat;
}

declare enum NSColorPanelMode {
  NSColorPanelModeNone = -1,
  NSColorPanelModeGray = 0,
  NSColorPanelModeRGB = 1,
  NSColorPanelModeCMYK = 2,
  NSColorPanelModeHSB = 3,
  NSColorPanelModeCustomPalette = 4,
  NSColorPanelModeColorList = 5,
  NSColorPanelModeWheel = 6,
  NSColorPanelModeCrayon = 7,
}

declare enum NSColorPanelOptions {
  NSColorPanelGrayModeMask = 0x00000001,
  NSColorPanelRGBModeMask = 0x00000002,
  NSColorPanelCMYKModeMask = 0x00000004,
  NSColorPanelHSBModeMask = 0x00000008,
  NSColorPanelCustomPaletteModeMask = 0x00000010,
  NSColorPanelColorListModeMask = 0x00000020,
  NSColorPanelWheelModeMask = 0x00000040,
  NSColorPanelCrayonModeMask = 0x00000080,
  NSColorPanelAllModesMask = 0x0000ffff,
}

class NSColorPickerAllocator<T extends NSColorPicker> extends NSObjectAllocator<T> {
  initWithPickerMask_colorPanel(mask: NSUInteger, owningColorPanel: NSColorPanel): T;
  initWithPickerMask_colorPanel(mask: NSUInteger, owningColorPanel: NSColorPanel): T;
}
declare class NSColorPicker extends NSObject implements INSColorPickingDefault {
  alloc<T extends NSColorPicker>(): NSColorPickerAllocator<T>;
  insertNewButtonImage_in(newButtonImage: NSImage, buttonCell: NSButtonCell): void;
  viewSizeChanged(sender: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  setMode(mode: NSColorPanelMode): void;
  provideNewButtonImage(): NSImage;
  insertNewButtonImage_in(newButtonImage: NSImage, buttonCell: NSButtonCell): void;
  viewSizeChanged(sender: any | null): void;
  alphaControlAddedOrRemoved(sender: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  setMode(mode: NSColorPanelMode): void;
  buttonToolTip(): NSString;
  minContentSize(): NSSize;
  provideNewButtonImage(): NSImage;
  insertNewButtonImage_in(newButtonImage: NSImage, buttonCell: NSButtonCell): void;
  viewSizeChanged(sender: any | null): void;
  alphaControlAddedOrRemoved(sender: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  setMode(mode: NSColorPanelMode): void;
  buttonToolTip(): NSString;
  minContentSize(): NSSize;

  colorPanel(): NSColorPanel;
  provideNewButtonImage(): NSImage;
  buttonToolTip(): NSString;
  minContentSize(): NSSize;
}

class NSColorPickerTouchBarItemAllocator<T extends NSColorPickerTouchBarItem> extends NSTouchBarItemAllocator<T> {}
declare class NSColorPickerTouchBarItem extends NSTouchBarItem {
  alloc<T extends NSColorPickerTouchBarItem>(): NSColorPickerTouchBarItemAllocator<T>;
  static colorPickerWithIdentifier(identifier: NSTouchBarItemIdentifier): NSColorPickerTouchBarItem;
  static textColorPickerWithIdentifier(identifier: NSTouchBarItemIdentifier): NSColorPickerTouchBarItem;
  static strokeColorPickerWithIdentifier(identifier: NSTouchBarItemIdentifier): NSColorPickerTouchBarItem;
  static colorPickerWithIdentifier_buttonImage(identifier: NSTouchBarItemIdentifier, image: NSImage): NSColorPickerTouchBarItem;

  color(): NSColor;
  setColor(color: NSColor): void;
  showsAlpha(): boolean;
  setShowsAlpha(showsAlpha: boolean): void;
  allowedColorSpaces(): NSArray<any>;
  setAllowedColorSpaces(allowedColorSpaces: NSArray<any> | any[]): void;
  colorList(): NSColorList;
  setColorList(colorList: NSColorList): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}

declare interface INSColorPickingDefault {
  provideNewButtonImage(): NSImage;
  insertNewButtonImage_in(newButtonImage: NSImage, buttonCell: NSButtonCell): void;
  viewSizeChanged(sender: any | null): void;
  alphaControlAddedOrRemoved(sender: any | null): void;
  attachColorList(colorList: NSColorList): void;
  detachColorList(colorList: NSColorList): void;
  setMode(mode: NSColorPanelMode): void;
  buttonToolTip(): NSString;
  minContentSize(): NSSize;
}

declare interface INSColorPickingCustom {
  supportsMode(mode: NSColorPanelMode): boolean;
  currentMode(): NSColorPanelMode;
  provideNewView(initialRequest: boolean): NSView;
  setColor(newColor: NSColor): void;
}

class NSColorSpaceAllocator<T extends NSColorSpace> extends NSObjectAllocator<T> {
  initWithICCProfileData(iccData: NSData): T;
  initWithColorSyncProfile(prof: void): T;
  initWithCGColorSpace(cgColorSpace: CGColorSpaceRef): T;
}
declare class NSColorSpace extends NSObject implements INSSecureCoding {
  alloc<T extends NSColorSpace>(): NSColorSpaceAllocator<T>;
  static availableColorSpacesWithModel(model: NSColorSpaceModel): NSArray<any>;
  static RGBColorSpaceNamed(colorSpaceName: NSString | string): NSColorSpace;
  static colorSpaceForSketchColorSpace(modelColorSpace: MSColorSpace): NSColorSpace;

  ICCProfileData(): NSData;
  colorSyncProfile(): void;
  CGColorSpace(): CGColorSpaceRef;
  numberOfColorComponents(): NSInteger;
  colorSpaceModel(): NSColorSpaceModel;
  localizedName(): NSString;
  static sRGBColorSpace(): NSColorSpace;
  static genericGamma22GrayColorSpace(): NSColorSpace;
  static extendedSRGBColorSpace(): NSColorSpace;
  static extendedGenericGamma22GrayColorSpace(): NSColorSpace;
  static displayP3ColorSpace(): NSColorSpace;
  static adobeRGB1998ColorSpace(): NSColorSpace;
  static genericRGBColorSpace(): NSColorSpace;
  static genericGrayColorSpace(): NSColorSpace;
  static genericCMYKColorSpace(): NSColorSpace;
  static deviceRGBColorSpace(): NSColorSpace;
  static deviceGrayColorSpace(): NSColorSpace;
  static deviceCMYKColorSpace(): NSColorSpace;
  static supportsSecureCoding(): boolean;
}

declare enum NSColorSpaceModel {
  NSColorSpaceModelUnknown = -1,
  NSColorSpaceModelGray,
  NSColorSpaceModelRGB,
  NSColorSpaceModelCMYK,
  NSColorSpaceModelLAB,
  NSColorSpaceModelDeviceN,
  NSColorSpaceModelIndexed,
  NSColorSpaceModelPatterned,
}

class NSColorWellAllocator<T extends NSColorWell> extends NSControlAllocator<T> {}
declare class NSColorWell extends NSControl {
  alloc<T extends NSColorWell>(): NSColorWellAllocator<T>;
  deactivate(): void;
  activate(exclusive: boolean): void;
  drawWellInside(insideRect: NSRect): void;
  takeColorFrom(sender: any | null): void;

  active(): boolean;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  color(): NSColor;
  setColor(color: NSColor): void;
}

class NSComboBoxAllocator<T extends NSComboBox> extends NSTextFieldAllocator<T> {}
declare class NSComboBox extends NSTextField {
  alloc<T extends NSComboBox>(): NSComboBoxAllocator<T>;
  reloadData(): void;
  noteNumberOfItemsChanged(): void;
  scrollItemAtIndexToTop(index: NSInteger): void;
  scrollItemAtIndexToVisible(index: NSInteger): void;
  selectItemAtIndex(index: NSInteger): void;
  deselectItemAtIndex(index: NSInteger): void;
  addItemWithObjectValue(object: any): void;
  addItemsWithObjectValues(objects: NSArray<any> | any[]): void;
  insertItemWithObjectValue_atIndex(object: any, index: NSInteger): void;
  removeItemWithObjectValue(object: any): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  selectItemWithObjectValue(object: any | null): void;
  itemObjectValueAtIndex(index: NSInteger): any;
  indexOfItemWithObjectValue(object: any): NSInteger;

  hasVerticalScroller(): boolean;
  setHasVerticalScroller(hasVerticalScroller: boolean): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  itemHeight(): CGFloat;
  setItemHeight(itemHeight: CGFloat): void;
  numberOfVisibleItems(): NSInteger;
  setNumberOfVisibleItems(numberOfVisibleItems: NSInteger): void;
  buttonBordered(): boolean;
  setButtonBordered(buttonBordered: boolean): void;
  usesDataSource(): boolean;
  setUsesDataSource(usesDataSource: boolean): void;
  indexOfSelectedItem(): NSInteger;
  numberOfItems(): NSInteger;
  completes(): boolean;
  setCompletes(completes: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  objectValueOfSelectedItem(): any;
  objectValues(): NSArray<any>;
}

declare interface INSComboBoxDataSource {
  numberOfItemsInComboBox(comboBox: NSComboBox): NSInteger;
  comboBox_objectValueForItemAtIndex(comboBox: NSComboBox, index: NSInteger): any;
  comboBox_indexOfItemWithStringValue(comboBox: NSComboBox, string: NSString | string): NSUInteger;
  comboBox_completedString(comboBox: NSComboBox, string: NSString | string): NSString;
}

declare interface INSComboBoxDelegate {
  comboBoxWillPopUp(notification: NSNotification): void;
  comboBoxWillDismiss(notification: NSNotification): void;
  comboBoxSelectionDidChange(notification: NSNotification): void;
  comboBoxSelectionIsChanging(notification: NSNotification): void;
}

class NSComboBoxCellAllocator<T extends NSComboBoxCell> extends NSTextFieldCellAllocator<T> {}
declare class NSComboBoxCell extends NSTextFieldCell {
  alloc<T extends NSComboBoxCell>(): NSComboBoxCellAllocator<T>;
  reloadData(): void;
  noteNumberOfItemsChanged(): void;
  scrollItemAtIndexToTop(index: NSInteger): void;
  scrollItemAtIndexToVisible(index: NSInteger): void;
  selectItemAtIndex(index: NSInteger): void;
  deselectItemAtIndex(index: NSInteger): void;
  completedString(string: NSString | string): NSString;
  addItemWithObjectValue(object: any): void;
  addItemsWithObjectValues(objects: NSArray<any> | any[]): void;
  insertItemWithObjectValue_atIndex(object: any, index: NSInteger): void;
  removeItemWithObjectValue(object: any): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  selectItemWithObjectValue(object: any | null): void;
  itemObjectValueAtIndex(index: NSInteger): any;
  indexOfItemWithObjectValue(object: any): NSInteger;

  hasVerticalScroller(): boolean;
  setHasVerticalScroller(hasVerticalScroller: boolean): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  itemHeight(): CGFloat;
  setItemHeight(itemHeight: CGFloat): void;
  numberOfVisibleItems(): NSInteger;
  setNumberOfVisibleItems(numberOfVisibleItems: NSInteger): void;
  buttonBordered(): boolean;
  setButtonBordered(buttonBordered: boolean): void;
  usesDataSource(): boolean;
  setUsesDataSource(usesDataSource: boolean): void;
  indexOfSelectedItem(): NSInteger;
  numberOfItems(): NSInteger;
  completes(): boolean;
  setCompletes(completes: boolean): void;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  objectValueOfSelectedItem(): any;
  objectValues(): NSArray<any>;
}

declare interface INSComboBoxCellDataSource {
  numberOfItemsInComboBoxCell(comboBoxCell: NSComboBoxCell): NSInteger;
  comboBoxCell_objectValueForItemAtIndex(comboBoxCell: NSComboBoxCell, index: NSInteger): any;
  comboBoxCell_indexOfItemWithStringValue(comboBoxCell: NSComboBoxCell, string: NSString | string): NSUInteger;
  comboBoxCell_completedString(comboBoxCell: NSComboBoxCell, uncompletedString: NSString | string): NSString;
}

class NSControlAllocator<T extends NSControl> extends NSViewAllocator<T> {}
declare class NSControl extends NSView {
  alloc<T extends NSControl>(): NSControlAllocator<T>;
  sizeThatFits(size: NSSize): NSSize;
  sizeToFit(): void;
  sendActionOn(mask: NSInteger): NSInteger;
  sendAction_to(action: string | null, target: any | null): boolean;
  takeIntValueFrom(sender: any | null): void;
  takeFloatValueFrom(sender: any | null): void;
  takeDoubleValueFrom(sender: any | null): void;
  takeStringValueFrom(sender: any | null): void;
  takeObjectValueFrom(sender: any | null): void;
  takeIntegerValueFrom(sender: any | null): void;
  mouseDown(event: NSEvent): void;
  performClick(sender: any | null): void;
  expansionFrameWithFrame(contentFrame: NSRect): NSRect;
  drawWithExpansionFrame_inView(contentFrame: NSRect, view: NSView): void;
  currentEditor(): NSText;
  abortEditing(): boolean;
  validateEditing(): void;
  editWithFrame_editor_delegate_event(rect: NSRect, textObj: NSText, delegate: any | null, event: NSEvent): void;
  selectWithFrame_editor_delegate_start_length(rect: NSRect, textObj: NSText, delegate: any | null, selStart: NSInteger, selLength: NSInteger): void;
  endEditing(textObj: NSText): void;
  setFloatingPointFormat_left_right(autoRange: boolean, leftDigits: NSUInteger, rightDigits: NSUInteger): void;
  selectedCell(): NSCell;
  selectedTag(): NSInteger;
  setNeedsDisplay(): void;
  calcSize(): void;
  updateCell(cell: NSCell): void;
  updateCellInside(cell: NSCell): void;
  drawCellInside(cell: NSCell): void;
  drawCell(cell: NSCell): void;
  selectCell(cell: NSCell): void;
  invalidateIntrinsicContentSizeForCell(cell: NSCell): void;
  static inpectorBorderPathForRect(rect: NSRect): NSBezierPath;
  static inpectorCheckmarkBorderPathForRect(rect: NSRect): NSBezierPath;
  static inpectorBorderPathForRectWithMaxRadius(rect: NSRect): NSBezierPath;
  static inpectorBorderPathForRect_borderRadius(rect: NSRect, borderRadius: CGFloat): NSBezierPath;
  static inpectorFocusRingPathForRect(rect: NSRect): NSBezierPath;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  ignoresMultiClick(): boolean;
  setIgnoresMultiClick(ignoresMultiClick: boolean): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  refusesFirstResponder(): boolean;
  setRefusesFirstResponder(refusesFirstResponder: boolean): void;
  highlighted(): boolean;
  setHighlighted(highlighted: boolean): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  formatter(): NSFormatter;
  setFormatter(formatter: NSFormatter): void;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  attributedStringValue(): NSAttributedString;
  setAttributedStringValue(attributedStringValue: NSAttributedString): void;
  objectValue(): any;
  setObjectValue(objectValue: any): void;
  intValue(): number;
  setIntValue(intValue: number): void;
  integerValue(): NSInteger;
  setIntegerValue(integerValue: NSInteger): void;
  floatValue(): number;
  setFloatValue(floatValue: number): void;
  doubleValue(): number;
  setDoubleValue(doubleValue: number): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  usesSingleLineMode(): boolean;
  setUsesSingleLineMode(usesSingleLineMode: boolean): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  allowsExpansionToolTips(): boolean;
  setAllowsExpansionToolTips(allowsExpansionToolTips: boolean): void;
  static cellClass(): any;
  static setCellClass(cellClass: any): void;
  cell(): NSCell;
  setCell(cell: NSCell): void;
}

declare interface INSControlTextEditingDelegate {
  control_textShouldBeginEditing(control: NSControl, fieldEditor: NSText): boolean;
  control_textShouldEndEditing(control: NSControl, fieldEditor: NSText): boolean;
  control_didFailToFormatString_errorDescription(control: NSControl, string: NSString | string, error: NSString | string | null): boolean;
  control_didFailToValidatePartialString_errorDescription(control: NSControl, string: NSString | string, error: NSString | string | null): void;
  control_isValidObject(control: NSControl, obj: any | null): boolean;
  control_textView_doCommandBySelector(control: NSControl, textView: NSTextView, commandSelector: string): boolean;
  control_textView_completions_forPartialWordRange_indexOfSelectedItem(control: NSControl, textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger): NSArray<any>;
}

class NSControllerAllocator<T extends NSController> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSController extends NSObject implements INSCoding {
  alloc<T extends NSController>(): NSControllerAllocator<T>;
  objectDidBeginEditing(editor: any): void;
  objectDidEndEditing(editor: any): void;
  discardEditing(): void;
  commitEditing(): boolean;
  commitEditingWithDelegate_didCommitSelector_contextInfo(delegate: any | null, didCommitSelector: string | null, contextInfo: void | null): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  editing(): boolean;
}

class NSCursorAllocator<T extends NSCursor> extends NSObjectAllocator<T> {
  initWithImage_hotSpot(newImage: NSImage, point: NSPoint): T;
  initWithCoder(coder: NSCoder): T;
  initWithImage_foregroundColorHint_backgroundColorHint_hotSpot(newImage: NSImage, fg: NSColor | null, bg: NSColor | null, hotSpot: NSPoint): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSCursor extends NSObject implements INSCoding {
  alloc<T extends NSCursor>(): NSCursorAllocator<T>;
  static hide(): void;
  static unhide(): void;
  static setHiddenUntilMouseMoves(flag: boolean): void;
  pop(): void;
  push(): void;
  set(): void;
  setOnMouseExited(flag: boolean): void;
  setOnMouseEntered(flag: boolean): void;
  mouseEntered(event: NSEvent): void;
  mouseExited(event: NSEvent): void;
  static cursorWithImageNamed(name: NSString | string): NSCursor;
  static cursorWithImageNamed_hotSpot(name: NSString | string, spot: NSPoint): NSCursor;
  static penCursor(): NSCursor;
  static penAddCursor(): NSCursor;
  static penCloseCursor(): NSCursor;
  static pencilCursor(): NSCursor;
  static resizeHorCursor(): NSCursor;
  static resizeHorCursorShort(): NSCursor;
  static resizeHorCursorLong(): NSCursor;
  static resizeVerCursor(): NSCursor;
  static resizeTopLeftToBottomRightCursor(): NSCursor;
  static resizeBottomLeftToTopRightCursor(): NSCursor;
  static rotateBottomRightCursor(): NSCursor;
  static rotateBottomLeftCursor(): NSCursor;
  static rotateTopLeftCursor(): NSCursor;
  static rotateTopRightCursor(): NSCursor;
  static rotateLeftCursor(): NSCursor;
  static rotateRightCursor(): NSCursor;
  static rotateTopCursor(): NSCursor;
  static rotateBottomCursor(): NSCursor;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  static currentCursor(): NSCursor;
  static currentSystemCursor(): NSCursor;
  static arrowCursor(): NSCursor;
  static IBeamCursor(): NSCursor;
  static pointingHandCursor(): NSCursor;
  static closedHandCursor(): NSCursor;
  static openHandCursor(): NSCursor;
  static resizeLeftCursor(): NSCursor;
  static resizeRightCursor(): NSCursor;
  static resizeLeftRightCursor(): NSCursor;
  static resizeUpCursor(): NSCursor;
  static resizeDownCursor(): NSCursor;
  static resizeUpDownCursor(): NSCursor;
  static crosshairCursor(): NSCursor;
  static disappearingItemCursor(): NSCursor;
  static operationNotAllowedCursor(): NSCursor;
  static dragLinkCursor(): NSCursor;
  static dragCopyCursor(): NSCursor;
  static contextualMenuCursor(): NSCursor;
  static IBeamCursorForVerticalLayout(): NSCursor;
  image(): NSImage;
  hotSpot(): NSPoint;
  setOnMouseExited(): boolean;
  setOnMouseEntered(): boolean;
}

class NSCustomImageRepAllocator<T extends NSCustomImageRep> extends NSImageRepAllocator<T> {
  initWithSize_flipped_drawingHandler(size: NSSize, drawingHandlerShouldBeCalledWithFlippedContext: boolean, drawingHandler: Block): T;
  initWithDrawSelector_delegate(selector: string, delegate: any): T;
}
declare class NSCustomImageRep extends NSImageRep {
  alloc<T extends NSCustomImageRep>(): NSCustomImageRepAllocator<T>;

  drawSelector(): string;
  delegate(): any;
}

class NSCustomTouchBarItemAllocator<T extends NSCustomTouchBarItem> extends NSTouchBarItemAllocator<T> {}
declare class NSCustomTouchBarItem extends NSTouchBarItem {
  alloc<T extends NSCustomTouchBarItem>(): NSCustomTouchBarItemAllocator<T>;

  view(): NSView;
  setView(view: NSView): void;
  viewController(): NSViewController;
  setViewController(viewController: NSViewController): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
}

class NSDataAssetAllocator<T extends NSDataAsset> extends NSObjectAllocator<T> {
  initWithName(name: NSDataAssetName): T;
  initWithName_bundle(name: NSDataAssetName, bundle: NSBundle): T;
}
declare class NSDataAsset extends NSObject implements INSCopying {
  alloc<T extends NSDataAsset>(): NSDataAssetAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  name(): NSDataAssetName;
  data(): NSData;
  typeIdentifier(): NSString;
}

declare type NSDataAssetName = NSString

class NSDatePickerAllocator<T extends NSDatePicker> extends NSControlAllocator<T> {}
declare class NSDatePicker extends NSControl {
  alloc<T extends NSDatePicker>(): NSDatePickerAllocator<T>;

  datePickerStyle(): NSDatePickerStyle;
  setDatePickerStyle(datePickerStyle: NSDatePickerStyle): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  datePickerMode(): NSDatePickerMode;
  setDatePickerMode(datePickerMode: NSDatePickerMode): void;
  datePickerElements(): NSDatePickerElementFlags;
  setDatePickerElements(datePickerElements: NSDatePickerElementFlags): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  dateValue(): NSDate;
  setDateValue(dateValue: NSDate): void;
  timeInterval(): NSTimeInterval;
  setTimeInterval(timeInterval: NSTimeInterval): void;
  minDate(): NSDate;
  setMinDate(minDate: NSDate): void;
  maxDate(): NSDate;
  setMaxDate(maxDate: NSDate): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

class NSDatePickerCellAllocator<T extends NSDatePickerCell> extends NSActionCellAllocator<T> {}
declare class NSDatePickerCell extends NSActionCell {
  alloc<T extends NSDatePickerCell>(): NSDatePickerCellAllocator<T>;

  datePickerStyle(): NSDatePickerStyle;
  setDatePickerStyle(datePickerStyle: NSDatePickerStyle): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  datePickerMode(): NSDatePickerMode;
  setDatePickerMode(datePickerMode: NSDatePickerMode): void;
  datePickerElements(): NSDatePickerElementFlags;
  setDatePickerElements(datePickerElements: NSDatePickerElementFlags): void;
  calendar(): NSCalendar;
  setCalendar(calendar: NSCalendar): void;
  locale(): NSLocale;
  setLocale(locale: NSLocale): void;
  timeZone(): NSTimeZone;
  setTimeZone(timeZone: NSTimeZone): void;
  dateValue(): NSDate;
  setDateValue(dateValue: NSDate): void;
  timeInterval(): NSTimeInterval;
  setTimeInterval(timeInterval: NSTimeInterval): void;
  minDate(): NSDate;
  setMinDate(minDate: NSDate): void;
  maxDate(): NSDate;
  setMaxDate(maxDate: NSDate): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface INSDatePickerCellDelegate {
  datePickerCell_validateProposedDateValue_timeInterval(datePickerCell: NSDatePickerCell, proposedDateValue: NSDate, proposedTimeInterval: NSTimeInterval | null): void;
}

declare enum NSDatePickerStyle {
  NSTextFieldAndStepperDatePickerStyle = 0,
  NSClockAndCalendarDatePickerStyle = 1,
  NSTextFieldDatePickerStyle = 2,
}

declare enum NSDatePickerMode {
  NSSingleDateMode = 0,
  NSRangeDateMode = 1,
}

declare enum NSDatePickerElementFlags {
  NSHourMinuteDatePickerElementFlag = 0x000c,
  NSHourMinuteSecondDatePickerElementFlag = 0x000e,
  NSTimeZoneDatePickerElementFlag = 0x0010,
  NSYearMonthDatePickerElementFlag = 0x00c0,
  NSYearMonthDayDatePickerElementFlag = 0x00e0,
  NSEraDatePickerElementFlag = 0x0100,
}

class NSDictionaryControllerKeyValuePairAllocator<T extends NSDictionaryControllerKeyValuePair> extends NSObjectAllocator<T> {}
declare class NSDictionaryControllerKeyValuePair extends NSObject {
  alloc<T extends NSDictionaryControllerKeyValuePair>(): NSDictionaryControllerKeyValuePairAllocator<T>;

  key(): NSString;
  setKey(key: NSString | string): void;
  value(): any;
  setValue(value: any): void;
  localizedKey(): NSString;
  setLocalizedKey(localizedKey: NSString | string): void;
  explicitlyIncluded(): boolean;
}

class NSDictionaryControllerAllocator<T extends NSDictionaryController> extends NSArrayControllerAllocator<T> {}
declare class NSDictionaryController extends NSArrayController {
  alloc<T extends NSDictionaryController>(): NSDictionaryControllerAllocator<T>;
  newObject(): NSDictionaryControllerKeyValuePair;

  initialKey(): NSString;
  setInitialKey(initialKey: NSString | string): void;
  initialValue(): any;
  setInitialValue(initialValue: any): void;
  includedKeys(): NSArray<any>;
  setIncludedKeys(includedKeys: NSArray<any> | any[]): void;
  excludedKeys(): NSArray<any>;
  setExcludedKeys(excludedKeys: NSArray<any> | any[]): void;
  localizedKeyDictionary(): NSDictionary<any, any>;
  setLocalizedKeyDictionary(localizedKeyDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  localizedKeyTable(): NSString;
  setLocalizedKeyTable(localizedKeyTable: NSString | string): void;
}

class NSDockTileAllocator<T extends NSDockTile> extends NSObjectAllocator<T> {}
declare class NSDockTile extends NSObject {
  alloc<T extends NSDockTile>(): NSDockTileAllocator<T>;
  display(): void;

  size(): NSSize;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  showsApplicationBadge(): boolean;
  setShowsApplicationBadge(showsApplicationBadge: boolean): void;
  badgeLabel(): NSString;
  setBadgeLabel(badgeLabel: NSString | string): void;
  owner(): any;
}

declare interface INSDockTilePlugIn {
  setDockTile(dockTile: NSDockTile | null): void;
  dockMenu(): NSMenu;
}

class NSDocumentAllocator<T extends NSDocument> extends NSObjectAllocator<T> {
  init(): T;
  initWithType_error(typeName: NSString | string, outError: NSError): T;
  initWithContentsOfURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): T;
  initForURL_withContentsOfURL_ofType_error(urlOrNil: NSURL | null, contentsURL: NSURL, typeName: NSString | string, outError: NSError): T;
  initWithContentsOfFile_ofType(absolutePath: NSString | string, typeName: NSString | string): T;
  initWithContentsOfURL_ofType(url: NSURL, typeName: NSString | string): T;
}
declare class NSDocument extends NSObject implements INSFilePresenter, INSUserInterfaceValidations {
  alloc<T extends NSDocument>(): NSDocumentAllocator<T>;
  static canConcurrentlyReadDocumentsOfType(typeName: NSString | string): boolean;
  performActivityWithSynchronousWaiting_usingBlock(waitSynchronously: boolean, block: Block): void;
  continueActivityUsingBlock(block: Block): void;
  continueAsynchronousWorkOnMainThreadUsingBlock(block: Block): void;
  performSynchronousFileAccessUsingBlock(block: Block): void;
  performAsynchronousFileAccessUsingBlock(block: Block): void;
  revertDocumentToSaved(sender: any | null): IBAction;
  revertToContentsOfURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): boolean;
  readFromURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): boolean;
  readFromFileWrapper_ofType_error(fileWrapper: NSFileWrapper, typeName: NSString | string, outError: NSError): boolean;
  readFromData_ofType_error(data: NSData, typeName: NSString | string, outError: NSError): boolean;
  writeToURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): boolean;
  fileWrapperOfType_error(typeName: NSString | string, outError: NSError): NSFileWrapper;
  dataOfType_error(typeName: NSString | string, outError: NSError): NSData;
  unblockUserInteraction(): void;
  writeSafelyToURL_ofType_forSaveOperation_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, outError: NSError): boolean;
  writeToURL_ofType_forSaveOperation_originalContentsURL_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, absoluteOriginalContentsURL: NSURL | null, outError: NSError): boolean;
  fileAttributesToWriteToURL_ofType_forSaveOperation_originalContentsURL_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, absoluteOriginalContentsURL: NSURL | null, outError: NSError): NSDictionary<any, any>;
  saveDocument(sender: any | null): IBAction;
  saveDocumentAs(sender: any | null): IBAction;
  saveDocumentTo(sender: any | null): IBAction;
  saveDocumentWithDelegate_didSaveSelector_contextInfo(delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  runModalSavePanelForSaveOperation_delegate_didSaveSelector_contextInfo(saveOperation: NSSaveOperationType, delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  prepareSavePanel(savePanel: NSSavePanel): boolean;
  saveToURL_ofType_forSaveOperation_delegate_didSaveSelector_contextInfo(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  saveToURL_ofType_forSaveOperation_completionHandler(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, completionHandler: Block): void;
  canAsynchronouslyWriteToURL_ofType_forSaveOperation(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType): boolean;
  checkAutosavingSafetyAndReturnError(outError: NSError): boolean;
  scheduleAutosaving(): void;
  autosaveDocumentWithDelegate_didAutosaveSelector_contextInfo(delegate: any | null, didAutosaveSelector: string | null, contextInfo: void | null): void;
  autosaveWithImplicitCancellability_completionHandler(autosavingIsImplicitlyCancellable: boolean, completionHandler: Block): void;
  browseDocumentVersions(sender: any | null): IBAction;
  stopBrowsingVersionsWithCompletionHandler(completionHandler: Block): void;
  canCloseDocumentWithDelegate_shouldCloseSelector_contextInfo(delegate: any, shouldCloseSelector: string | null, contextInfo: void | null): void;
  close(): void;
  duplicateDocument(sender: any | null): IBAction;
  duplicateDocumentWithDelegate_didDuplicateSelector_contextInfo(delegate: any | null, didDuplicateSelector: string | null, contextInfo: void | null): void;
  duplicateAndReturnError(outError: NSError): NSDocument;
  renameDocument(sender: any | null): IBAction;
  moveDocumentToUbiquityContainer(sender: any | null): IBAction;
  moveDocument(sender: any | null): IBAction;
  moveDocumentWithCompletionHandler(completionHandler: Block): void;
  moveToURL_completionHandler(url: NSURL, completionHandler: Block): void;
  lockDocument(sender: any | null): IBAction;
  unlockDocument(sender: any | null): IBAction;
  lockDocumentWithCompletionHandler(completionHandler: Block): void;
  lockWithCompletionHandler(completionHandler: Block): void;
  unlockDocumentWithCompletionHandler(completionHandler: Block): void;
  unlockWithCompletionHandler(completionHandler: Block): void;
  runPageLayout(sender: any | null): IBAction;
  runModalPageLayoutWithPrintInfo_delegate_didRunSelector_contextInfo(printInfo: NSPrintInfo, delegate: any | null, didRunSelector: string | null, contextInfo: void | null): void;
  preparePageLayout(pageLayout: NSPageLayout): boolean;
  shouldChangePrintInfo(newPrintInfo: NSPrintInfo): boolean;
  printDocument(sender: any | null): IBAction;
  printDocumentWithSettings_showPrintPanel_delegate_didPrintSelector_contextInfo(printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanel: boolean, delegate: any | null, didPrintSelector: string | null, contextInfo: void | null): void;
  printOperationWithSettings_error(printSettings: NSDictionary<any, any> | {[key: string]: any}, outError: NSError): NSPrintOperation;
  runModalPrintOperation_delegate_didRunSelector_contextInfo(printOperation: NSPrintOperation, delegate: any | null, didRunSelector: string | null, contextInfo: void | null): void;
  saveDocumentToPDF(sender: any | null): IBAction;
  shareDocumentWithSharingService_completionHandler(sharingService: NSSharingService, completionHandler: Block): void;
  prepareSharingServicePicker(sharingServicePicker: NSSharingServicePicker): void;
  updateChangeCount(change: NSDocumentChangeType): void;
  changeCountTokenForSaveOperation(saveOperation: NSSaveOperationType): any;
  updateChangeCountWithToken_forSaveOperation(changeCountToken: any, saveOperation: NSSaveOperationType): void;
  presentError_modalForWindow_delegate_didPresentSelector_contextInfo(error: NSError, window: NSWindow, delegate: any | null, didPresentSelector: string | null, contextInfo: void | null): void;
  presentError(error: NSError): boolean;
  willPresentError(error: NSError): NSError;
  willNotPresentError(error: NSError): void;
  makeWindowControllers(): void;
  windowControllerWillLoadNib(windowController: NSWindowController): void;
  windowControllerDidLoadNib(windowController: NSWindowController): void;
  setWindow(window: NSWindow | null): void;
  addWindowController(windowController: NSWindowController): void;
  removeWindowController(windowController: NSWindowController): void;
  showWindows(): void;
  shouldCloseWindowController_delegate_shouldCloseSelector_contextInfo(windowController: NSWindowController, delegate: any | null, shouldCloseSelector: string | null, contextInfo: void | null): void;
  setDisplayName(displayNameOrNil: NSString | string | null): void;
  defaultDraftName(): NSString;
  static isNativeType(type: NSString | string): boolean;
  writableTypesForSaveOperation(saveOperation: NSSaveOperationType): NSArray<any>;
  fileNameExtensionForType_saveOperation(typeName: NSString | string, saveOperation: NSSaveOperationType): NSString;
  validateUserInterfaceItem(item: any): boolean;
  saveToURL_ofType_forSaveOperation_error(url: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, outError: NSError): boolean;
  dataRepresentationOfType(type: NSString | string): NSData;
  fileAttributesToWriteToFile_ofType_saveOperation(fullDocumentPath: NSString | string, documentTypeName: NSString | string, saveOperationType: NSSaveOperationType): NSDictionary<any, any>;
  fileName(): NSString;
  fileWrapperRepresentationOfType(type: NSString | string): NSFileWrapper;
  loadDataRepresentation_ofType(data: NSData, type: NSString | string): boolean;
  loadFileWrapperRepresentation_ofType(wrapper: NSFileWrapper, type: NSString | string): boolean;
  printShowingPrintPanel(flag: boolean): void;
  readFromFile_ofType(fileName: NSString | string, type: NSString | string): boolean;
  readFromURL_ofType(url: NSURL, type: NSString | string): boolean;
  revertToSavedFromFile_ofType(fileName: NSString | string, type: NSString | string): boolean;
  revertToSavedFromURL_ofType(url: NSURL, type: NSString | string): boolean;
  runModalPageLayoutWithPrintInfo(printInfo: NSPrintInfo): NSInteger;
  saveToFile_saveOperation_delegate_didSaveSelector_contextInfo(fileName: NSString | string, saveOperation: NSSaveOperationType, delegate: any | null, didSaveSelector: string | null, contextInfo: void | null): void;
  setFileName(fileName: NSString | string | null): void;
  writeToFile_ofType(fileName: NSString | string, type: NSString | string): boolean;
  writeToFile_ofType_originalFile_saveOperation(fullDocumentPath: NSString | string, documentTypeName: NSString | string, fullOriginalDocumentPath: NSString | string | null, saveOperationType: NSSaveOperationType): boolean;
  writeToURL_ofType(url: NSURL, type: NSString | string): boolean;
  writeWithBackupToFile_ofType_saveOperation(fullDocumentPath: NSString | string, documentTypeName: NSString | string, saveOperationType: NSSaveOperationType): boolean;
  handleSaveScriptCommand(command: NSScriptCommand): any;
  handleCloseScriptCommand(command: NSCloseCommand): any;
  handlePrintScriptCommand(command: NSScriptCommand): any;
  updateUserActivityState(activity: NSUserActivity): void;
  restoreUserActivityState(activity: NSUserActivity): void;
  restoreDocumentWindowWithIdentifier_state_completionHandler(identifier: NSUserInterfaceItemIdentifier, state: NSCoder, completionHandler: Block): void;
  encodeRestorableStateWithCoder(coder: NSCoder): void;
  encodeRestorableStateWithCoder_backgroundQueue(coder: NSCoder, queue: NSOperationQueue): void;
  restoreStateWithCoder(coder: NSCoder): void;
  invalidateRestorableState(): void;
  menuNeedsUpdate(menu: NSMenu): void;
  relinquishPresentedItemToReader(reader: Block): void;
  relinquishPresentedItemToWriter(writer: Block): void;
  savePresentedItemChangesWithCompletionHandler(completionHandler: Block): void;
  accommodatePresentedItemDeletionWithCompletionHandler(completionHandler: Block): void;
  presentedItemDidMoveToURL(newURL: NSURL): void;
  presentedItemDidChange(): void;
  presentedItemDidChangeUbiquityAttributes(attributes: NSSet<any>): void;
  presentedItemDidGainVersion(version: NSFileVersion): void;
  presentedItemDidLoseVersion(version: NSFileVersion): void;
  presentedItemDidResolveConflictVersion(version: NSFileVersion): void;
  accommodatePresentedSubitemDeletionAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  presentedSubitemDidAppearAtURL(url: NSURL): void;
  presentedSubitemAtURL_didMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  presentedSubitemDidChangeAtURL(url: NSURL): void;
  presentedSubitemAtURL_didGainVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didLoseVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didResolveConflictVersion(url: NSURL, version: NSFileVersion): void;
  validateUserInterfaceItem(item: any): boolean;
  relinquishPresentedItemToReader(reader: Block): void;
  relinquishPresentedItemToWriter(writer: Block): void;
  savePresentedItemChangesWithCompletionHandler(completionHandler: Block): void;
  accommodatePresentedItemDeletionWithCompletionHandler(completionHandler: Block): void;
  presentedItemDidMoveToURL(newURL: NSURL): void;
  presentedItemDidChange(): void;
  presentedItemDidChangeUbiquityAttributes(attributes: NSSet<any>): void;
  presentedItemDidGainVersion(version: NSFileVersion): void;
  presentedItemDidLoseVersion(version: NSFileVersion): void;
  presentedItemDidResolveConflictVersion(version: NSFileVersion): void;
  accommodatePresentedSubitemDeletionAtURL_completionHandler(url: NSURL, completionHandler: Block): void;
  presentedSubitemDidAppearAtURL(url: NSURL): void;
  presentedSubitemAtURL_didMoveToURL(oldURL: NSURL, newURL: NSURL): void;
  presentedSubitemDidChangeAtURL(url: NSURL): void;
  presentedSubitemAtURL_didGainVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didLoseVersion(url: NSURL, version: NSFileVersion): void;
  presentedSubitemAtURL_didResolveConflictVersion(url: NSURL, version: NSFileVersion): void;
  validateUserInterfaceItem(item: any): boolean;

  fileType(): NSString;
  setFileType(fileType: NSString | string): void;
  fileURL(): NSURL;
  setFileURL(fileURL: NSURL): void;
  fileModificationDate(): NSDate;
  setFileModificationDate(fileModificationDate: NSDate): void;
  draft(): boolean;
  setDraft(draft: boolean): void;
  entireFileLoaded(): boolean;
  autosavingIsImplicitlyCancellable(): boolean;
  keepBackupFile(): boolean;
  backupFileURL(): NSURL;
  shouldRunSavePanelWithAccessoryView(): boolean;
  fileNameExtensionWasHiddenInLastRunSavePanel(): boolean;
  fileTypeFromLastRunSavePanel(): NSString;
  hasUnautosavedChanges(): boolean;
  static autosavesInPlace(): boolean;
  static preservesVersions(): boolean;
  browsingVersions(): boolean;
  static autosavesDrafts(): boolean;
  autosavingFileType(): NSString;
  autosavedContentsFileURL(): NSURL;
  setAutosavedContentsFileURL(autosavedContentsFileURL: NSURL): void;
  locked(): boolean;
  printInfo(): NSPrintInfo;
  setPrintInfo(printInfo: NSPrintInfo): void;
  PDFPrintOperation(): NSPrintOperation;
  allowsDocumentSharing(): boolean;
  documentEdited(): boolean;
  inViewingMode(): boolean;
  undoManager(): NSUndoManager;
  setUndoManager(undoManager: NSUndoManager): void;
  hasUndoManager(): boolean;
  setHasUndoManager(hasUndoManager: boolean): void;
  windowNibName(): NSNibName;
  windowControllers(): NSArray<any>;
  displayName(): NSString;
  setDisplayName(displayName: NSString | string): void;
  windowForSheet(): NSWindow;
  static readableTypes(): NSArray<any>;
  static writableTypes(): NSArray<any>;
  static usesUbiquitousStorage(): boolean;
  lastComponentOfFileName(): NSString;
  setLastComponentOfFileName(lastComponentOfFileName: NSString | string): void;
  objectSpecifier(): NSScriptObjectSpecifier;
  userActivity(): NSUserActivity;
  setUserActivity(userActivity: NSUserActivity): void;
  static restorableStateKeyPaths(): NSArray<any>;
  presentedItemURL(): NSURL;
  presentedItemOperationQueue(): NSOperationQueue;
  primaryPresentedItemURL(): NSURL;
  observedPresentedItemUbiquityAttributes(): NSSet<any>;
}

declare enum NSDocumentChangeType {
  NSChangeDone = 0,
  NSChangeUndone = 1,
  NSChangeRedone = 5,
  NSChangeCleared = 2,
  NSChangeReadOtherContents = 3,
  NSChangeAutosaved = 4,
  NSChangeDiscardable = 256,
}

declare enum NSSaveOperationType {
  NSSaveOperation = 0,
  NSSaveAsOperation = 1,
  NSSaveToOperation = 2,
  NSAutosaveInPlaceOperation = 4,
  NSAutosaveElsewhereOperation = 3,
  NSAutosaveAsOperation = 5,
  NSAutosaveOperation = 3,
}

class NSDocumentControllerAllocator<T extends NSDocumentController> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSDocumentController extends NSObject implements INSCoding, INSUserInterfaceValidations {
  alloc<T extends NSDocumentController>(): NSDocumentControllerAllocator<T>;
  documentForURL(url: NSURL): NSDocument;
  documentForWindow(window: NSWindow): NSDocument;
  addDocument(document: NSDocument): void;
  removeDocument(document: NSDocument): void;
  newDocument(sender: any | null): IBAction;
  openUntitledDocumentAndDisplay_error(displayDocument: boolean, outError: NSError): NSDocument;
  makeUntitledDocumentOfType_error(typeName: NSString | string, outError: NSError): NSDocument;
  openDocument(sender: any | null): IBAction;
  URLsFromRunningOpenPanel(): NSArray<any>;
  runModalOpenPanel_forTypes(openPanel: NSOpenPanel, types: NSArray<any> | any[] | null): NSInteger;
  beginOpenPanelWithCompletionHandler(completionHandler: Block): void;
  beginOpenPanel_forTypes_completionHandler(openPanel: NSOpenPanel, inTypes: NSArray<any> | any[] | null, completionHandler: Block): void;
  openDocumentWithContentsOfURL_display_completionHandler(url: NSURL, displayDocument: boolean, completionHandler: Block): void;
  makeDocumentWithContentsOfURL_ofType_error(url: NSURL, typeName: NSString | string, outError: NSError): NSDocument;
  reopenDocumentForURL_withContentsOfURL_display_completionHandler(urlOrNil: NSURL | null, contentsURL: NSURL, displayDocument: boolean, completionHandler: Block): void;
  makeDocumentForURL_withContentsOfURL_ofType_error(urlOrNil: NSURL | null, contentsURL: NSURL, typeName: NSString | string, outError: NSError): NSDocument;
  saveAllDocuments(sender: any | null): IBAction;
  reviewUnsavedDocumentsWithAlertTitle_cancellable_delegate_didReviewAllSelector_contextInfo(title: NSString | string | null, cancellable: boolean, delegate: any | null, didReviewAllSelector: string | null, contextInfo: void | null): void;
  closeAllDocumentsWithDelegate_didCloseAllSelector_contextInfo(delegate: any | null, didCloseAllSelector: string | null, contextInfo: void | null): void;
  duplicateDocumentWithContentsOfURL_copying_displayName_error(url: NSURL, duplicateByCopying: boolean, displayNameOrNil: NSString | string | null, outError: NSError): NSDocument;
  standardShareMenuItem(): NSMenuItem;
  presentError_modalForWindow_delegate_didPresentSelector_contextInfo(error: NSError, window: NSWindow, delegate: any | null, didPresentSelector: string | null, contextInfo: void | null): void;
  presentError(error: NSError): boolean;
  willPresentError(error: NSError): NSError;
  clearRecentDocuments(sender: any | null): IBAction;
  noteNewRecentDocument(document: NSDocument): void;
  noteNewRecentDocumentURL(url: NSURL): void;
  typeForContentsOfURL_error(url: NSURL, outError: NSError): NSString;
  documentClassForType(typeName: NSString | string): any;
  displayNameForType(typeName: NSString | string): NSString;
  validateUserInterfaceItem(item: any): boolean;
  openDocumentWithContentsOfURL_display_error(url: NSURL, displayDocument: boolean, outError: NSError): any;
  reopenDocumentForURL_withContentsOfURL_error(url: NSURL | null, contentsURL: NSURL, outError: NSError): boolean;
  fileExtensionsFromType(typeName: NSString | string): NSArray<any>;
  typeFromFileExtension(fileNameExtensionOrHFSFileType: NSString | string): NSString;
  documentForFileName(fileName: NSString | string): any;
  fileNamesFromRunningOpenPanel(): NSArray<any>;
  makeDocumentWithContentsOfFile_ofType(fileName: NSString | string, type: NSString | string): any;
  makeDocumentWithContentsOfURL_ofType(url: NSURL, type: NSString | string): any;
  makeUntitledDocumentOfType(type: NSString | string): any;
  openDocumentWithContentsOfFile_display(fileName: NSString | string, display: boolean): any;
  openDocumentWithContentsOfURL_display(url: NSURL, display: boolean): any;
  openUntitledDocumentOfType_display(type: NSString | string, display: boolean): any;
  setShouldCreateUI(flag: boolean): void;
  shouldCreateUI(): boolean;
  static enumerateOpenDocuments(block: MSDocumentIteratorBlock): void;
  encodeWithCoder(aCoder: NSCoder): void;
  validateUserInterfaceItem(item: any): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  validateUserInterfaceItem(item: any): boolean;

  static sharedDocumentController(): NSDocumentController;
  documents(): NSArray<any>;
  currentDocument(): NSDocument;
  currentDirectory(): NSString;
  autosavingDelay(): NSTimeInterval;
  setAutosavingDelay(autosavingDelay: NSTimeInterval): void;
  hasEditedDocuments(): boolean;
  allowsAutomaticShareMenu(): boolean;
  maximumRecentDocumentCount(): NSUInteger;
  recentDocumentURLs(): NSArray<any>;
  defaultType(): NSString;
  documentClassNames(): NSArray<any>;
}

declare interface INSDraggingDestination {
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
}

declare interface INSDraggingSource {
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
}

declare interface INSSpringLoadingDestination {
  springLoadingActivated_draggingInfo(activated: boolean, draggingInfo: any): void;
  springLoadingHighlightChanged(draggingInfo: any): void;
  springLoadingEntered(draggingInfo: any): NSSpringLoadingOptions;
  springLoadingUpdated(draggingInfo: any): NSSpringLoadingOptions;
  springLoadingExited(draggingInfo: any): void;
  draggingEnded(draggingInfo: any): void;
}

declare enum NSDragOperation {
  NSDragOperationNone = 0,
  NSDragOperationCopy = 1,
  NSDragOperationLink = 2,
  NSDragOperationGeneric = 4,
  NSDragOperationPrivate = 8,
  NSDragOperationMove = 16,
  NSDragOperationDelete = 32,
  NSDragOperationEvery,
  NSDragOperationAll_Obsolete = 15,
  NSDragOperationAll,
}

declare enum NSDraggingFormation {
  NSDraggingFormationDefault = 0,
  NSDraggingFormationNone,
  NSDraggingFormationPile,
  NSDraggingFormationList,
  NSDraggingFormationStack,
}

declare enum NSDraggingContext {
  NSDraggingContextOutsideApplication = 0,
  NSDraggingContextWithinApplication,
}

declare enum NSDraggingItemEnumerationOptions {
  NSDraggingItemEnumerationConcurrent,
  NSDraggingItemEnumerationClearNonenumeratedImages,
}

declare enum NSSpringLoadingHighlight {
  NSSpringLoadingHighlightNone = 0,
  NSSpringLoadingHighlightStandard,
  NSSpringLoadingHighlightEmphasized,
}

declare enum NSSpringLoadingOptions {
  NSSpringLoadingDisabled = 0,
  NSSpringLoadingEnabled = 1 << 0,
  NSSpringLoadingContinuousActivation = 1 << 1,
  NSSpringLoadingNoHover = 1 << 3,
}

class NSDraggingImageComponentAllocator<T extends NSDraggingImageComponent> extends NSObjectAllocator<T> {
  initWithKey(key: NSDraggingImageComponentKey): T;
}
declare class NSDraggingImageComponent extends NSObject {
  alloc<T extends NSDraggingImageComponent>(): NSDraggingImageComponentAllocator<T>;
  static draggingImageComponentWithKey(key: NSDraggingImageComponentKey): NSDraggingImageComponent;

  key(): NSDraggingImageComponentKey;
  setKey(key: NSDraggingImageComponentKey): void;
  contents(): any;
  setContents(contents: any): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
}

class NSDraggingItemAllocator<T extends NSDraggingItem> extends NSObjectAllocator<T> {
  initWithPasteboardWriter(pasteboardWriter: any): T;
}
declare class NSDraggingItem extends NSObject {
  alloc<T extends NSDraggingItem>(): NSDraggingItemAllocator<T>;
  setDraggingFrame_contents(frame: NSRect, contents: any | null): void;

  item(): any;
  draggingFrame(): NSRect;
  setDraggingFrame(draggingFrame: NSRect): void;
  imageComponents(): NSArray<any>;
}

declare type NSDraggingImageComponentKey = NSString

class NSDraggingSessionAllocator<T extends NSDraggingSession> extends NSObjectAllocator<T> {}
declare class NSDraggingSession extends NSObject {
  alloc<T extends NSDraggingSession>(): NSDraggingSessionAllocator<T>;
  enumerateDraggingItemsWithOptions_forView_classes_searchOptions_usingBlock(enumOpts: NSDraggingItemEnumerationOptions, view: NSView | null, classArray: NSArray<any> | any[], searchOptions: NSDictionary<any, any> | {[key: string]: any}, block: Block): void;

  draggingFormation(): NSDraggingFormation;
  setDraggingFormation(draggingFormation: NSDraggingFormation): void;
  animatesToStartingPositionsOnCancelOrFail(): boolean;
  setAnimatesToStartingPositionsOnCancelOrFail(animatesToStartingPositionsOnCancelOrFail: boolean): void;
  draggingLeaderIndex(): NSInteger;
  setDraggingLeaderIndex(draggingLeaderIndex: NSInteger): void;
  draggingPasteboard(): NSPasteboard;
  draggingSequenceNumber(): NSInteger;
  draggingLocation(): NSPoint;
}

class NSDrawerAllocator<T extends NSDrawer> extends NSResponderAllocator<T> {
  initWithContentSize_preferredEdge(contentSize: NSSize, edge: NSRectEdge): T;
}
declare class NSDrawer extends NSResponder implements INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSDrawer>(): NSDrawerAllocator<T>;
  open(): void;
  openOnEdge(edge: NSRectEdge): void;
  close(): void;
  open(sender: any | null): void;
  close(sender: any | null): void;
  toggle(sender: any | null): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  parentWindow(): NSWindow;
  setParentWindow(parentWindow: NSWindow): void;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  state(): NSInteger;
  edge(): NSRectEdge;
  contentSize(): NSSize;
  setContentSize(contentSize: NSSize): void;
  minContentSize(): NSSize;
  setMinContentSize(minContentSize: NSSize): void;
  maxContentSize(): NSSize;
  setMaxContentSize(maxContentSize: NSSize): void;
  leadingOffset(): CGFloat;
  setLeadingOffset(leadingOffset: CGFloat): void;
  trailingOffset(): CGFloat;
  setTrailingOffset(trailingOffset: CGFloat): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

class NSWindowAllocator<T extends NSWindow> extends NSResponderAllocator<T> {
  initWithContentRect_styleMask_backing_defer(contentRect: NSRect, style: NSWindowStyleMask, backingStoreType: NSBackingStoreType, flag: boolean): T;
  initWithContentRect_styleMask_backing_defer_screen(contentRect: NSRect, style: NSWindowStyleMask, backingStoreType: NSBackingStoreType, flag: boolean, screen: NSScreen | null): T;
  initWithWindowRef(windowRef: void): T;
}
declare class NSWindow extends NSResponder implements INSAnimatablePropertyContainer, INSUserInterfaceValidations, INSUserInterfaceItemIdentification, INSAppearanceCustomization, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSWindow>(): NSWindowAllocator<T>;
  updateConstraintsIfNeeded(): void;
  layoutIfNeeded(): void;
  anchorAttributeForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutAttribute;
  setAnchorAttribute_forOrientation(attr: NSLayoutAttribute, orientation: NSLayoutConstraintOrientation): void;
  visualizeConstraints(constraints: NSArray<any> | any[] | null): void;
  static frameRectForContentRect_styleMask(cRect: NSRect, style: NSWindowStyleMask): NSRect;
  static contentRectForFrameRect_styleMask(fRect: NSRect, style: NSWindowStyleMask): NSRect;
  static minFrameWidthWithTitle_styleMask(title: NSString | string, style: NSWindowStyleMask): CGFloat;
  frameRectForContentRect(contentRect: NSRect): NSRect;
  contentRectForFrameRect(frameRect: NSRect): NSRect;
  addTitlebarAccessoryViewController(childViewController: NSTitlebarAccessoryViewController): void;
  insertTitlebarAccessoryViewController_atIndex(childViewController: NSTitlebarAccessoryViewController, index: NSInteger): void;
  removeTitlebarAccessoryViewControllerAtIndex(index: NSInteger): void;
  setTitleWithRepresentedFilename(filename: NSString | string): void;
  fieldEditor_forObject(createFlag: boolean, object: any | null): NSText;
  endEditingFor(object: any | null): void;
  constrainFrameRect_toScreen(frameRect: NSRect, screen: NSScreen | null): NSRect;
  setFrame_display(frameRect: NSRect, flag: boolean): void;
  setContentSize(size: NSSize): void;
  setFrameOrigin(point: NSPoint): void;
  setFrameTopLeftPoint(point: NSPoint): void;
  cascadeTopLeftFromPoint(topLeftPoint: NSPoint): NSPoint;
  animationResizeTime(newFrame: NSRect): NSTimeInterval;
  setFrame_display_animate(frameRect: NSRect, displayFlag: boolean, animateFlag: boolean): void;
  disableFlushWindow(): void;
  enableFlushWindow(): void;
  flushWindow(): void;
  flushWindowIfNeeded(): void;
  displayIfNeeded(): void;
  display(): void;
  update(): void;
  makeFirstResponder(responder: NSResponder | null): boolean;
  keyDown(event: NSEvent): void;
  close(): void;
  miniaturize(sender: any | null): void;
  deminiaturize(sender: any | null): void;
  zoom(sender: any | null): void;
  tryToPerform_with(action: string, object: any | null): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  setContentBorderThickness_forEdge(thickness: CGFloat, edge: NSRectEdge): void;
  contentBorderThicknessForEdge(edge: NSRectEdge): CGFloat;
  setAutorecalculatesContentBorderThickness_forEdge(flag: boolean, edge: NSRectEdge): void;
  autorecalculatesContentBorderThicknessForEdge(edge: NSRectEdge): boolean;
  center(): void;
  makeKeyAndOrderFront(sender: any | null): void;
  orderFront(sender: any | null): void;
  orderBack(sender: any | null): void;
  orderOut(sender: any | null): void;
  orderWindow_relativeTo(place: NSWindowOrderingMode, otherWin: NSInteger): void;
  orderFrontRegardless(): void;
  makeKeyWindow(): void;
  makeMainWindow(): void;
  becomeKeyWindow(): void;
  resignKeyWindow(): void;
  becomeMainWindow(): void;
  resignMainWindow(): void;
  convertRectToScreen(rect: NSRect): NSRect;
  convertRectFromScreen(rect: NSRect): NSRect;
  convertRectToBacking(rect: NSRect): NSRect;
  convertRectFromBacking(rect: NSRect): NSRect;
  backingAlignedRect_options(rect: NSRect, options: NSAlignmentOptions): NSRect;
  performClose(sender: any | null): void;
  performMiniaturize(sender: any | null): void;
  performZoom(sender: any | null): void;
  dataWithEPSInsideRect(rect: NSRect): NSData;
  dataWithPDFInsideRect(rect: NSRect): NSData;
  print(sender: any | null): void;
  setDynamicDepthLimit(flag: boolean): void;
  invalidateShadow(): void;
  disableScreenUpdatesUntilFlush(): void;
  toggleFullScreen(sender: any | null): void;
  setFrameFromString(string: NSString | string): void;
  saveFrameUsingName(name: NSWindowFrameAutosaveName): void;
  setFrameUsingName_force(name: NSWindowFrameAutosaveName, force: boolean): boolean;
  setFrameUsingName(name: NSWindowFrameAutosaveName): boolean;
  setFrameAutosaveName(name: NSWindowFrameAutosaveName): boolean;
  static removeFrameUsingName(name: NSWindowFrameAutosaveName): void;
  beginSheet_completionHandler(sheetWindow: NSWindow, handler: Block): void;
  beginCriticalSheet_completionHandler(sheetWindow: NSWindow, handler: Block): void;
  endSheet(sheetWindow: NSWindow): void;
  endSheet_returnCode(sheetWindow: NSWindow, returnCode: NSModalResponse): void;
  static standardWindowButton_forStyleMask(b: NSWindowButton, styleMask: NSWindowStyleMask): NSButton;
  standardWindowButton(b: NSWindowButton): NSButton;
  addChildWindow_ordered(childWin: NSWindow, place: NSWindowOrderingMode): void;
  removeChildWindow(childWin: NSWindow): void;
  canRepresentDisplayGamut(displayGamut: NSDisplayGamut): boolean;
  static windowNumbersWithOptions(options: NSWindowNumberListOptions): NSArray<any>;
  static windowNumberAtPoint_belowWindowWithWindowNumber(point: NSPoint, windowNumber: NSInteger): NSInteger;
  static windowWithContentViewController(contentViewController: NSViewController): NSWindow;
  performWindowDragWithEvent(event: NSEvent): void;
  selectNextKeyView(sender: any | null): void;
  selectPreviousKeyView(sender: any | null): void;
  selectKeyViewFollowingView(view: NSView): void;
  selectKeyViewPrecedingView(view: NSView): void;
  disableKeyEquivalentForDefaultButtonCell(): void;
  enableKeyEquivalentForDefaultButtonCell(): void;
  recalculateKeyViewLoop(): void;
  toggleToolbarShown(sender: any | null): void;
  runToolbarCustomizationPalette(sender: any | null): void;
  selectNextTab(sender: any | null): IBAction;
  selectPreviousTab(sender: any | null): IBAction;
  moveTabToNewWindow(sender: any | null): IBAction;
  mergeAllWindows(sender: any | null): IBAction;
  toggleTabBar(sender: any | null): IBAction;
  toggleTabOverview(sender: any | null): IBAction;
  addTabbedWindow_ordered(window: NSWindow, ordered: NSWindowOrderingMode): void;
  trackEventsMatchingMask_timeout_mode_handler(mask: NSEventMask, timeout: NSTimeInterval, mode: NSRunLoopMode, trackingHandler: Block): void;
  nextEventMatchingMask(mask: NSUInteger): NSEvent;
  nextEventMatchingMask_untilDate_inMode_dequeue(mask: NSUInteger, expiration: NSDate | null, mode: NSRunLoopMode, deqFlag: boolean): NSEvent;
  discardEventsMatchingMask_beforeEvent(mask: NSUInteger, lastEvent: NSEvent | null): void;
  postEvent_atStart(event: NSEvent, flag: boolean): void;
  sendEvent(event: NSEvent): void;
  disableCursorRects(): void;
  enableCursorRects(): void;
  discardCursorRects(): void;
  invalidateCursorRectsForView(view: NSView): void;
  resetCursorRects(): void;
  dragImage_at_offset_event_pasteboard_source_slideBack(image: NSImage, baseLocation: NSPoint, initialOffset: NSSize, event: NSEvent, pboard: NSPasteboard, sourceObj: any, slideFlag: boolean): void;
  registerForDraggedTypes(newTypes: NSArray<any> | any[]): void;
  unregisterDraggedTypes(): void;
  cacheImageInRect(rect: NSRect): void;
  restoreCachedImage(): void;
  discardCachedImage(): void;
  static menuChanged(menu: NSMenu): void;
  gState(): NSInteger;
  convertBaseToScreen(point: NSPoint): NSPoint;
  convertScreenToBase(point: NSPoint): NSPoint;
  userSpaceScaleFactor(): CGFloat;
  useOptimizedDrawing(flag: boolean): void;
  canStoreColor(): boolean;
  disableSnapshotRestoration(): void;
  enableSnapshotRestoration(): void;
  setIsMiniaturized(flag: boolean): void;
  setIsVisible(flag: boolean): void;
  setIsZoomed(flag: boolean): void;
  handleCloseScriptCommand(command: NSCloseCommand): any;
  handlePrintScriptCommand(command: NSScriptCommand): any;
  handleSaveScriptCommand(command: NSScriptCommand): any;
  convertPointFromScreen_ch(point: NSPoint): NSPoint;
  closePopovers(): boolean;
  commitEditedTextRetainingFirstResponder(): void;
  animator(): NSWindow;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  animator(): NSWindow;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  drawers(): NSArray<any>;
  static defaultDepthLimit(): NSWindowDepth;
  title(): NSString;
  setTitle(title: NSString | string): void;
  titleVisibility(): NSWindowTitleVisibility;
  setTitleVisibility(titleVisibility: NSWindowTitleVisibility): void;
  titlebarAppearsTransparent(): boolean;
  setTitlebarAppearsTransparent(titlebarAppearsTransparent: boolean): void;
  contentLayoutRect(): NSRect;
  contentLayoutGuide(): any;
  titlebarAccessoryViewControllers(): NSArray<any>;
  setTitlebarAccessoryViewControllers(titlebarAccessoryViewControllers: NSArray<any> | any[]): void;
  representedURL(): NSURL;
  setRepresentedURL(representedURL: NSURL): void;
  representedFilename(): NSString;
  setRepresentedFilename(representedFilename: NSString | string): void;
  excludedFromWindowsMenu(): boolean;
  setExcludedFromWindowsMenu(excludedFromWindowsMenu: boolean): void;
  contentView(): NSView;
  setContentView(contentView: NSView): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  windowNumber(): NSInteger;
  styleMask(): NSWindowStyleMask;
  setStyleMask(styleMask: NSWindowStyleMask): void;
  frame(): NSRect;
  inLiveResize(): boolean;
  showsResizeIndicator(): boolean;
  setShowsResizeIndicator(showsResizeIndicator: boolean): void;
  resizeIncrements(): NSSize;
  setResizeIncrements(resizeIncrements: NSSize): void;
  aspectRatio(): NSSize;
  setAspectRatio(aspectRatio: NSSize): void;
  contentResizeIncrements(): NSSize;
  setContentResizeIncrements(contentResizeIncrements: NSSize): void;
  contentAspectRatio(): NSSize;
  setContentAspectRatio(contentAspectRatio: NSSize): void;
  flushWindowDisabled(): boolean;
  viewsNeedDisplay(): boolean;
  setViewsNeedDisplay(viewsNeedDisplay: boolean): void;
  autodisplay(): boolean;
  setAutodisplay(autodisplay: boolean): void;
  preservesContentDuringLiveResize(): boolean;
  setPreservesContentDuringLiveResize(preservesContentDuringLiveResize: boolean): void;
  firstResponder(): NSResponder;
  resizeFlags(): NSEventModifierFlags;
  releasedWhenClosed(): boolean;
  setReleasedWhenClosed(releasedWhenClosed: boolean): void;
  zoomed(): boolean;
  miniaturized(): boolean;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  movable(): boolean;
  setMovable(movable: boolean): void;
  movableByWindowBackground(): boolean;
  setMovableByWindowBackground(movableByWindowBackground: boolean): void;
  hidesOnDeactivate(): boolean;
  setHidesOnDeactivate(hidesOnDeactivate: boolean): void;
  canHide(): boolean;
  setCanHide(canHide: boolean): void;
  miniwindowImage(): NSImage;
  setMiniwindowImage(miniwindowImage: NSImage): void;
  miniwindowTitle(): NSString;
  setMiniwindowTitle(miniwindowTitle: NSString | string): void;
  dockTile(): NSDockTile;
  documentEdited(): boolean;
  setDocumentEdited(documentEdited: boolean): void;
  visible(): boolean;
  keyWindow(): boolean;
  mainWindow(): boolean;
  canBecomeKeyWindow(): boolean;
  canBecomeMainWindow(): boolean;
  worksWhenModal(): boolean;
  preventsApplicationTerminationWhenModal(): boolean;
  setPreventsApplicationTerminationWhenModal(preventsApplicationTerminationWhenModal: boolean): void;
  backingScaleFactor(): CGFloat;
  oneShot(): boolean;
  setOneShot(oneShot: boolean): void;
  allowsToolTipsWhenApplicationIsInactive(): boolean;
  setAllowsToolTipsWhenApplicationIsInactive(allowsToolTipsWhenApplicationIsInactive: boolean): void;
  backingType(): NSBackingStoreType;
  setBackingType(backingType: NSBackingStoreType): void;
  level(): NSWindowLevel;
  setLevel(level: NSWindowLevel): void;
  depthLimit(): NSWindowDepth;
  setDepthLimit(depthLimit: NSWindowDepth): void;
  hasDynamicDepthLimit(): boolean;
  screen(): NSScreen;
  deepestScreen(): NSScreen;
  hasShadow(): boolean;
  setHasShadow(hasShadow: boolean): void;
  alphaValue(): CGFloat;
  setAlphaValue(alphaValue: CGFloat): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
  sharingType(): NSWindowSharingType;
  setSharingType(sharingType: NSWindowSharingType): void;
  preferredBackingLocation(): NSWindowBackingLocation;
  setPreferredBackingLocation(preferredBackingLocation: NSWindowBackingLocation): void;
  backingLocation(): NSWindowBackingLocation;
  allowsConcurrentViewDrawing(): boolean;
  setAllowsConcurrentViewDrawing(allowsConcurrentViewDrawing: boolean): void;
  displaysWhenScreenProfileChanges(): boolean;
  setDisplaysWhenScreenProfileChanges(displaysWhenScreenProfileChanges: boolean): void;
  canBecomeVisibleWithoutLogin(): boolean;
  setCanBecomeVisibleWithoutLogin(canBecomeVisibleWithoutLogin: boolean): void;
  collectionBehavior(): NSWindowCollectionBehavior;
  setCollectionBehavior(collectionBehavior: NSWindowCollectionBehavior): void;
  animationBehavior(): NSWindowAnimationBehavior;
  setAnimationBehavior(animationBehavior: NSWindowAnimationBehavior): void;
  onActiveSpace(): boolean;
  stringWithSavedFrame(): NSString;
  frameAutosaveName(): NSWindowFrameAutosaveName;
  minSize(): NSSize;
  setMinSize(minSize: NSSize): void;
  maxSize(): NSSize;
  setMaxSize(maxSize: NSSize): void;
  contentMinSize(): NSSize;
  setContentMinSize(contentMinSize: NSSize): void;
  contentMaxSize(): NSSize;
  setContentMaxSize(contentMaxSize: NSSize): void;
  minFullScreenContentSize(): NSSize;
  setMinFullScreenContentSize(minFullScreenContentSize: NSSize): void;
  maxFullScreenContentSize(): NSSize;
  setMaxFullScreenContentSize(maxFullScreenContentSize: NSSize): void;
  deviceDescription(): NSDictionary<any, any>;
  windowController(): NSWindowController;
  setWindowController(windowController: NSWindowController): void;
  sheets(): NSArray<any>;
  attachedSheet(): NSWindow;
  sheet(): boolean;
  sheetParent(): NSWindow;
  childWindows(): NSArray<any>;
  parentWindow(): NSWindow;
  setParentWindow(parentWindow: NSWindow): void;
  graphicsContext(): NSGraphicsContext;
  colorSpace(): NSColorSpace;
  setColorSpace(colorSpace: NSColorSpace): void;
  occlusionState(): NSWindowOcclusionState;
  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  initialFirstResponder(): NSView;
  setInitialFirstResponder(initialFirstResponder: NSView): void;
  keyViewSelectionDirection(): NSSelectionDirection;
  defaultButtonCell(): NSButtonCell;
  setDefaultButtonCell(defaultButtonCell: NSButtonCell): void;
  autorecalculatesKeyViewLoop(): boolean;
  setAutorecalculatesKeyViewLoop(autorecalculatesKeyViewLoop: boolean): void;
  toolbar(): NSToolbar;
  setToolbar(toolbar: NSToolbar): void;
  showsToolbarButton(): boolean;
  setShowsToolbarButton(showsToolbarButton: boolean): void;
  static allowsAutomaticWindowTabbing(): boolean;
  static setAllowsAutomaticWindowTabbing(allowsAutomaticWindowTabbing: boolean): void;
  static userTabbingPreference(): NSWindowUserTabbingPreference;
  tabbingMode(): NSWindowTabbingMode;
  setTabbingMode(tabbingMode: NSWindowTabbingMode): void;
  tabbingIdentifier(): NSWindowTabbingIdentifier;
  setTabbingIdentifier(tabbingIdentifier: NSWindowTabbingIdentifier): void;
  tabbedWindows(): NSArray<any>;
  tab(): NSWindowTab;
  tabGroup(): NSWindowTabGroup;
  windowTitlebarLayoutDirection(): NSUserInterfaceLayoutDirection;
  currentEvent(): NSEvent;
  acceptsMouseMovedEvents(): boolean;
  setAcceptsMouseMovedEvents(acceptsMouseMovedEvents: boolean): void;
  ignoresMouseEvents(): boolean;
  setIgnoresMouseEvents(ignoresMouseEvents: boolean): void;
  mouseLocationOutsideOfEventStream(): NSPoint;
  areCursorRectsEnabled(): boolean;
  windowRef(): void;
  restorable(): boolean;
  setRestorable(restorable: boolean): void;
  restorationClass(): any;
  setRestorationClass(restorationClass: any): void;
  hasCloseBox(): boolean;
  hasTitleBar(): boolean;
  floatingPanel(): boolean;
  miniaturizable(): boolean;
  modalPanel(): boolean;
  resizable(): boolean;
  zoomable(): boolean;
  orderedIndex(): NSInteger;
  setOrderedIndex(orderedIndex: NSInteger): void;
  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  appearance(): NSAppearance;
  setAppearance(appearance: NSAppearance): void;
  effectiveAppearance(): NSAppearance;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare interface INSDrawerDelegate {
  drawerShouldOpen(sender: NSDrawer): boolean;
  drawerShouldClose(sender: NSDrawer): boolean;
  drawerWillResizeContents_toSize(sender: NSDrawer, contentSize: NSSize): NSSize;
  drawerWillOpen(notification: NSNotification): void;
  drawerDidOpen(notification: NSNotification): void;
  drawerWillClose(notification: NSNotification): void;
  drawerDidClose(notification: NSNotification): void;
}

declare enum NSDrawerState {
  NSDrawerClosedState = 0,
  NSDrawerOpeningState = 1,
  NSDrawerOpenState = 2,
  NSDrawerClosingState = 3,
}

class NSEPSImageRepAllocator<T extends NSEPSImageRep> extends NSImageRepAllocator<T> {
  initWithData(epsData: NSData): T;
}
declare class NSEPSImageRep extends NSImageRep {
  alloc<T extends NSEPSImageRep>(): NSEPSImageRepAllocator<T>;
  static imageRepWithData(epsData: NSData): NSEPSImageRep;
  prepareGState(): void;
  PDFRepresentation_ms(): NSData;

  EPSRepresentation(): NSData;
  boundingBox(): NSRect;
}

class NSEventAllocator<T extends NSEvent> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSEvent extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSEvent>(): NSEventAllocator<T>;
  static eventWithEventRef(eventRef: void): NSEvent;
  static eventWithCGEvent(cgEvent: CGEventRef): NSEvent;
  touchesMatchingPhase_inView(phase: NSTouchPhase, view: NSView | null): NSSet<any>;
  allTouches(): NSSet<any>;
  touchesForView(view: NSView): NSSet<any>;
  coalescedTouchesForTouch(touch: NSTouch): NSArray<any>;
  trackSwipeEventWithOptions_dampenAmountThresholdMin_max_usingHandler(options: NSEventSwipeTrackingOptions, minDampenThreshold: CGFloat, maxDampenThreshold: CGFloat, trackingHandler: Block): void;
  static startPeriodicEventsAfterDelay_withPeriod(delay: NSTimeInterval, period: NSTimeInterval): void;
  static stopPeriodicEvents(): void;
  static mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, eNum: NSInteger, cNum: NSInteger, pressure: number): NSEvent;
  static keyEventWithType_location_modifierFlags_timestamp_windowNumber_context_characters_charactersIgnoringModifiers_isARepeat_keyCode(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, keys: NSString | string, ukeys: NSString | string, flag: boolean, code: number): NSEvent;
  static enterExitEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_trackingNumber_userData(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, eNum: NSInteger, tNum: NSInteger, data: void | null): NSEvent;
  static otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2(type: NSEventType, location: NSPoint, flags: NSEventModifierFlags, time: NSTimeInterval, wNum: NSInteger, unusedPassNil: NSGraphicsContext | null, subtype: number, d1: NSInteger, d2: NSInteger): NSEvent;
  static addGlobalMonitorForEventsMatchingMask_handler(mask: NSEventMask, block: Block): any;
  static addLocalMonitorForEventsMatchingMask_handler(mask: NSEventMask, block: Block): any;
  static removeMonitor(eventMonitor: any): void;
  shouldStartDrag(): boolean;
  isDoubleClick(): boolean;
  isRightClick(): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  type(): NSEventType;
  static modifierFlags(): NSEventModifierFlags;
  timestamp(): NSTimeInterval;
  window(): NSWindow;
  windowNumber(): NSInteger;
  context(): NSGraphicsContext;
  clickCount(): NSInteger;
  buttonNumber(): NSInteger;
  eventNumber(): NSInteger;
  pressure(): number;
  locationInWindow(): NSPoint;
  deltaX(): CGFloat;
  deltaY(): CGFloat;
  deltaZ(): CGFloat;
  hasPreciseScrollingDeltas(): boolean;
  scrollingDeltaX(): CGFloat;
  scrollingDeltaY(): CGFloat;
  momentumPhase(): NSEventPhase;
  directionInvertedFromDevice(): boolean;
  characters(): NSString;
  charactersIgnoringModifiers(): NSString;
  ARepeat(): boolean;
  keyCode(): number;
  trackingNumber(): NSInteger;
  userData(): void;
  trackingArea(): NSTrackingArea;
  subtype(): NSEventSubtype;
  data1(): NSInteger;
  data2(): NSInteger;
  eventRef(): void;
  CGEvent(): CGEventRef;
  static mouseCoalescingEnabled(): boolean;
  static setMouseCoalescingEnabled(mouseCoalescingEnabled: boolean): void;
  magnification(): CGFloat;
  deviceID(): NSUInteger;
  rotation(): number;
  absoluteX(): NSInteger;
  absoluteY(): NSInteger;
  absoluteZ(): NSInteger;
  buttonMask(): NSEventButtonMask;
  tilt(): NSPoint;
  tangentialPressure(): number;
  vendorDefined(): any;
  vendorID(): NSUInteger;
  tabletID(): NSUInteger;
  pointingDeviceID(): NSUInteger;
  systemTabletID(): NSUInteger;
  vendorPointingDeviceType(): NSUInteger;
  pointingDeviceSerialNumber(): NSUInteger;
  uniqueID(): number;
  capabilityMask(): NSUInteger;
  pointingDeviceType(): NSPointingDeviceType;
  enteringProximity(): boolean;
  phase(): NSEventPhase;
  stage(): NSInteger;
  stageTransition(): CGFloat;
  associatedEventsMask(): NSEventMask;
  pressureBehavior(): NSPressureBehavior;
  static swipeTrackingFromScrollEventsEnabled(): boolean;
  static mouseLocation(): NSPoint;
  static pressedMouseButtons(): NSUInteger;
  static doubleClickInterval(): NSTimeInterval;
  static keyRepeatDelay(): NSTimeInterval;
  static keyRepeatInterval(): NSTimeInterval;
}

declare enum NSEventType {
  NSEventTypeLeftMouseDown = 1,
  NSEventTypeLeftMouseUp = 2,
  NSEventTypeRightMouseDown = 3,
  NSEventTypeRightMouseUp = 4,
  NSEventTypeMouseMoved = 5,
  NSEventTypeLeftMouseDragged = 6,
  NSEventTypeRightMouseDragged = 7,
  NSEventTypeMouseEntered = 8,
  NSEventTypeMouseExited = 9,
  NSEventTypeKeyDown = 10,
  NSEventTypeKeyUp = 11,
  NSEventTypeFlagsChanged = 12,
  NSEventTypeAppKitDefined = 13,
  NSEventTypeSystemDefined = 14,
  NSEventTypeApplicationDefined = 15,
  NSEventTypePeriodic = 16,
  NSEventTypeCursorUpdate = 17,
  NSEventTypeScrollWheel = 22,
  NSEventTypeTabletPoint = 23,
  NSEventTypeTabletProximity = 24,
  NSEventTypeOtherMouseDown = 25,
  NSEventTypeOtherMouseUp = 26,
  NSEventTypeOtherMouseDragged = 27,
  NSEventTypeGesture = 29,
  NSEventTypeMagnify = 30,
  NSEventTypeSwipe = 31,
  NSEventTypeRotate = 18,
  NSEventTypeBeginGesture = 19,
  NSEventTypeEndGesture = 20,
  NSEventTypeSmartMagnify = 32,
  NSEventTypeQuickLook = 33,
  NSEventTypePressure = 34,
  NSEventTypeDirectTouch = 37,
}

declare enum NSEventMask {
  NSEventMaskLeftMouseDown = 1 << NSEventType.NSEventTypeLeftMouseDown,
  NSEventMaskLeftMouseUp = 1 << NSEventType.NSEventTypeLeftMouseUp,
  NSEventMaskRightMouseDown = 1 << NSEventType.NSEventTypeRightMouseDown,
  NSEventMaskRightMouseUp = 1 << NSEventType.NSEventTypeRightMouseUp,
  NSEventMaskMouseMoved = 1 << NSEventType.NSEventTypeMouseMoved,
  NSEventMaskLeftMouseDragged = 1 << NSEventType.NSEventTypeLeftMouseDragged,
  NSEventMaskRightMouseDragged = 1 << NSEventType.NSEventTypeRightMouseDragged,
  NSEventMaskMouseEntered = 1 << NSEventType.NSEventTypeMouseEntered,
  NSEventMaskMouseExited = 1 << NSEventType.NSEventTypeMouseExited,
  NSEventMaskKeyDown = 1 << NSEventType.NSEventTypeKeyDown,
  NSEventMaskKeyUp = 1 << NSEventType.NSEventTypeKeyUp,
  NSEventMaskFlagsChanged = 1 << NSEventType.NSEventTypeFlagsChanged,
  NSEventMaskAppKitDefined = 1 << NSEventType.NSEventTypeAppKitDefined,
  NSEventMaskSystemDefined = 1 << NSEventType.NSEventTypeSystemDefined,
  NSEventMaskApplicationDefined = 1 << NSEventType.NSEventTypeApplicationDefined,
  NSEventMaskPeriodic = 1 << NSEventType.NSEventTypePeriodic,
  NSEventMaskCursorUpdate = 1 << NSEventType.NSEventTypeCursorUpdate,
  NSEventMaskScrollWheel = 1 << NSEventType.NSEventTypeScrollWheel,
  NSEventMaskTabletPoint = 1 << NSEventType.NSEventTypeTabletPoint,
  NSEventMaskTabletProximity = 1 << NSEventType.NSEventTypeTabletProximity,
  NSEventMaskOtherMouseDown = 1 << NSEventType.NSEventTypeOtherMouseDown,
  NSEventMaskOtherMouseUp = 1 << NSEventType.NSEventTypeOtherMouseUp,
  NSEventMaskOtherMouseDragged = 1 << NSEventType.NSEventTypeOtherMouseDragged,
  NSEventMaskGesture = 1 << NSEventType.NSEventTypeGesture,
  NSEventMaskMagnify = 1 << NSEventType.NSEventTypeMagnify,
  NSEventMaskSwipe = 1 << NSEventType.NSEventTypeSwipe,
  NSEventMaskRotate = 1 << NSEventType.NSEventTypeRotate,
  NSEventMaskBeginGesture = 1 << NSEventType.NSEventTypeBeginGesture,
  NSEventMaskEndGesture = 1 << NSEventType.NSEventTypeEndGesture,
  NSEventMaskSmartMagnify = 1 << NSEventType.NSEventTypeSmartMagnify,
  NSEventMaskPressure = 1 << NSEventType.NSEventTypePressure,
  NSEventMaskDirectTouch = 1 << NSEventType.NSEventTypeDirectTouch,
  NSEventMaskAny,
}

declare enum NSEventModifierFlags {
  NSEventModifierFlagCapsLock = 1 << 16,
  NSEventModifierFlagShift = 1 << 17,
  NSEventModifierFlagControl = 1 << 18,
  NSEventModifierFlagOption = 1 << 19,
  NSEventModifierFlagCommand = 1 << 20,
  NSEventModifierFlagNumericPad = 1 << 21,
  NSEventModifierFlagHelp = 1 << 22,
  NSEventModifierFlagFunction = 1 << 23,
  NSEventModifierFlagDeviceIndependentFlagsMask = 0xffff0000,
}

declare enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown,
  NSPointingDeviceTypePen,
  NSPointingDeviceTypeCursor,
  NSPointingDeviceTypeEraser,
}

declare enum NSEventButtonMask {
  NSEventButtonMaskPenTip,
  NSEventButtonMaskPenLowerSide,
  NSEventButtonMaskPenUpperSide,
}

declare enum NSEventPhase {
  NSEventPhaseNone = 0,
  NSEventPhaseBegan = 0x1 << 0,
  NSEventPhaseStationary = 0x1 << 1,
  NSEventPhaseChanged = 0x1 << 2,
  NSEventPhaseEnded = 0x1 << 3,
  NSEventPhaseCancelled = 0x1 << 4,
  NSEventPhaseMayBegin = 0x1 << 5,
}

declare enum NSEventGestureAxis {
  NSEventGestureAxisNone = 0,
  NSEventGestureAxisHorizontal,
  NSEventGestureAxisVertical,
}

declare enum NSEventSwipeTrackingOptions {
  NSEventSwipeTrackingLockDirection = 0x1 << 0,
  NSEventSwipeTrackingClampGestureAmount = 0x1 << 1,
}

declare enum NSEventSubtype {
  NSEventSubtypeWindowExposed = 0,
  NSEventSubtypeApplicationActivated = 1,
  NSEventSubtypeApplicationDeactivated = 2,
  NSEventSubtypeWindowMoved = 4,
  NSEventSubtypeScreenChanged = 8,
  NSEventSubtypePowerOff = 1,
  NSEventSubtypeMouseEvent,
  NSEventSubtypeTabletPoint,
  NSEventSubtypeTabletProximity,
  NSEventSubtypeTouch,
}

declare enum NSPressureBehavior {
  NSPressureBehaviorUnknown = -1,
  NSPressureBehaviorPrimaryDefault = 0,
  NSPressureBehaviorPrimaryClick = 1,
  NSPressureBehaviorPrimaryGeneric = 2,
  NSPressureBehaviorPrimaryAccelerator = 3,
  NSPressureBehaviorPrimaryDeepClick = 5,
  NSPressureBehaviorPrimaryDeepDrag = 6,
}

class NSFilePromiseProviderAllocator<T extends NSFilePromiseProvider> extends NSObjectAllocator<T> {
  initWithFileType_delegate(fileType: NSString | string, delegate: any): T;
  init(): T;
}
declare class NSFilePromiseProvider extends NSObject implements INSPasteboardWriting {
  alloc<T extends NSFilePromiseProvider>(): NSFilePromiseProviderAllocator<T>;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;

  fileType(): NSString;
  setFileType(fileType: NSString | string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  userInfo(): any;
  setUserInfo(userInfo: any): void;
}

declare interface INSFilePromiseProviderDelegate {
  filePromiseProvider_fileNameForType(filePromiseProvider: NSFilePromiseProvider, fileType: NSString | string): NSString;
  filePromiseProvider_writePromiseToURL_completionHandler(filePromiseProvider: NSFilePromiseProvider, url: NSURL, completionHandler: Block): void;
  operationQueueForFilePromiseProvider(filePromiseProvider: NSFilePromiseProvider): NSOperationQueue;
}

class NSFilePromiseReceiverAllocator<T extends NSFilePromiseReceiver> extends NSObjectAllocator<T> {
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): T;
}
declare class NSFilePromiseReceiver extends NSObject implements INSPasteboardReading {
  alloc<T extends NSFilePromiseReceiver>(): NSFilePromiseReceiverAllocator<T>;
  receivePromisedFilesAtDestination_options_operationQueue_reader(destinationDir: NSURL, options: NSDictionary<any, any> | {[key: string]: any}, operationQueue: NSOperationQueue, reader: Block): void;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;

  static readableDraggedTypes(): NSArray<any>;
  fileTypes(): NSArray<any>;
  fileNames(): NSArray<any>;
}

class NSFontAllocator<T extends NSFont> extends NSObjectAllocator<T> {}
declare class NSFont extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSFont>(): NSFontAllocator<T>;
  static fontWithName_size(fontName: NSString | string, fontSize: CGFloat): NSFont;
  static fontWithName_matrix(fontName: NSString | string, fontMatrix: CGFloat): NSFont;
  static fontWithDescriptor_size(fontDescriptor: NSFontDescriptor, fontSize: CGFloat): NSFont;
  static fontWithDescriptor_textTransform(fontDescriptor: NSFontDescriptor, textTransform: NSAffineTransform | null): NSFont;
  static userFontOfSize(fontSize: CGFloat): NSFont;
  static userFixedPitchFontOfSize(fontSize: CGFloat): NSFont;
  static setUserFont(font: NSFont | null): void;
  static setUserFixedPitchFont(font: NSFont | null): void;
  static systemFontOfSize(fontSize: CGFloat): NSFont;
  static boldSystemFontOfSize(fontSize: CGFloat): NSFont;
  static labelFontOfSize(fontSize: CGFloat): NSFont;
  static titleBarFontOfSize(fontSize: CGFloat): NSFont;
  static menuFontOfSize(fontSize: CGFloat): NSFont;
  static menuBarFontOfSize(fontSize: CGFloat): NSFont;
  static messageFontOfSize(fontSize: CGFloat): NSFont;
  static paletteFontOfSize(fontSize: CGFloat): NSFont;
  static toolTipsFontOfSize(fontSize: CGFloat): NSFont;
  static controlContentFontOfSize(fontSize: CGFloat): NSFont;
  static systemFontOfSize_weight(fontSize: CGFloat, weight: NSFontWeight): NSFont;
  static monospacedDigitSystemFontOfSize_weight(fontSize: CGFloat, weight: NSFontWeight): NSFont;
  static systemFontSizeForControlSize(controlSize: NSControlSize): CGFloat;
  boundingRectForCGGlyph(glyph: CGGlyph): NSRect;
  advancementForCGGlyph(glyph: CGGlyph): NSSize;
  getBoundingRects_forCGGlyphs_count(bounds: NSRectArray, glyphs: CGGlyph, glyphCount: NSUInteger): void;
  getAdvancements_forCGGlyphs_count(advancements: NSSizeArray, glyphs: CGGlyph, glyphCount: NSUInteger): void;
  set(): void;
  setInContext(graphicsContext: NSGraphicsContext): void;
  glyphWithName(name: NSString | string): NSGlyph;
  boundingRectForGlyph(glyph: NSGlyph): NSRect;
  advancementForGlyph(glyph: NSGlyph): NSSize;
  getBoundingRects_forGlyphs_count(bounds: NSRectArray, glyphs: NSGlyph, glyphCount: NSUInteger): void;
  getAdvancements_forGlyphs_count(advancements: NSSizeArray, glyphs: NSGlyph, glyphCount: NSUInteger): void;
  getAdvancements_forPackedGlyphs_length(advancements: NSSizeArray, packedGlyphs: void, length: NSUInteger): void;
  screenFontWithRenderingMode(renderingMode: NSFontRenderingMode): NSFont;
  static useFont(fontName: NSString | string): void;
  widthOfString(string: NSString | string): CGFloat;
  isBaseFont(): boolean;
  afmDictionary(): NSDictionary<any, any>;
  glyphIsEncoded(glyph: NSGlyph): boolean;
  defaultLineHeightForFont(): CGFloat;
  static preferredFontNames(): NSArray<any>;
  static setPreferredFontNames(fontNameArray: NSArray<any> | any[]): void;
  encodingScheme(): NSString;
  glyphPacking(): NSMultibyteGlyphPacking;
  positionOfGlyph_precededByGlyph_isNominal(glyph: NSGlyph, prevGlyph: NSGlyph, nominal: boolean): NSPoint;
  positionsForCompositeSequence_numberOfGlyphs_pointArray(someGlyphs: NSGlyph, numGlyphs: NSInteger, points: NSPointArray): NSInteger;
  positionOfGlyph_struckOverGlyph_metricsExist(glyph: NSGlyph, prevGlyph: NSGlyph, exist: boolean): NSPoint;
  positionOfGlyph_struckOverRect_metricsExist(glyph: NSGlyph, rect: NSRect, exist: boolean): NSPoint;
  positionOfGlyph_forCharacter_struckOverRect(glyph: NSGlyph, character: unichar, rect: NSRect): NSPoint;
  positionOfGlyph_withRelation_toBaseGlyph_totalAdvancement_metricsExist(thisGlyph: NSGlyph, rel: NSGlyphRelation, baseGlyph: NSGlyph, adv: NSSizePointer, exist: boolean): NSPoint;
  static preventsAutoActivation_bc(): boolean;
  static setPreventsAutoActivation_bc(flag: boolean): void;
  static fontWithName_size_bc(fontName: NSString | string, fontSize: CGFloat): NSFont;
  static fontPreventingAutoActivationWithName_size_bc(fontName: NSString | string, fontSize: CGFloat): NSFont;
  addSVGAttributes(attributes: NSMutableArray<any> | any[]): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  static systemFontSize(): CGFloat;
  static smallSystemFontSize(): CGFloat;
  static labelFontSize(): CGFloat;
  fontName(): NSString;
  pointSize(): CGFloat;
  matrix(): CGFloat;
  familyName(): NSString;
  displayName(): NSString;
  fontDescriptor(): NSFontDescriptor;
  textTransform(): NSAffineTransform;
  numberOfGlyphs(): NSUInteger;
  mostCompatibleStringEncoding(): NSStringEncoding;
  coveredCharacterSet(): NSCharacterSet;
  boundingRectForFont(): NSRect;
  maximumAdvancement(): NSSize;
  ascender(): CGFloat;
  descender(): CGFloat;
  leading(): CGFloat;
  underlinePosition(): CGFloat;
  underlineThickness(): CGFloat;
  italicAngle(): CGFloat;
  capHeight(): CGFloat;
  xHeight(): CGFloat;
  fixedPitch(): boolean;
  verticalFont(): NSFont;
  vertical(): boolean;
  printerFont(): NSFont;
  screenFont(): NSFont;
  renderingMode(): NSFontRenderingMode;
  static supportsSecureCoding(): boolean;
}

declare type NSGlyph = number

declare type NSGlyphRelation = NSUInteger

declare enum NSFontRenderingMode {
  NSFontDefaultRenderingMode = 0,
  NSFontAntialiasedRenderingMode = 1,
  NSFontIntegerAdvancementsRenderingMode = 2,
  NSFontAntialiasedIntegerAdvancementsRenderingMode = 3,
}

declare enum NSMultibyteGlyphPacking {
  NSNativeShortGlyphPacking = 5,
}

class NSFontAssetRequestAllocator<T extends NSFontAssetRequest> extends NSObjectAllocator<T> {
  initWithFontDescriptors_options(fontDescriptors: NSArray<any> | any[], options: NSFontAssetRequestOptions): T;
}
declare class NSFontAssetRequest extends NSObject implements INSProgressReporting {
  alloc<T extends NSFontAssetRequest>(): NSFontAssetRequestAllocator<T>;
  downloadFontAssetsWithCompletionHandler(completionHandler: Block): void;

  downloadedFontDescriptors(): NSArray<any>;
  progress(): NSProgress;
}

declare enum NSFontAssetRequestOptions {
  NSFontAssetRequestOptionUsesStandardUI = 1 << 0,
}

class NSFontCollectionAllocator<T extends NSFontCollection> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSFontCollection extends NSObject implements INSCopying, INSMutableCopying, INSCoding {
  alloc<T extends NSFontCollection>(): NSFontCollectionAllocator<T>;
  static fontCollectionWithDescriptors(queryDescriptors: NSArray<any> | any[]): NSFontCollection;
  static fontCollectionWithLocale(locale: NSLocale): NSFontCollection;
  static showFontCollection_withName_visibility_error(collection: NSFontCollection, name: NSFontCollectionName, visibility: NSFontCollectionVisibility, error: NSError): boolean;
  static hideFontCollectionWithName_visibility_error(name: NSFontCollectionName, visibility: NSFontCollectionVisibility, error: NSError): boolean;
  static renameFontCollectionWithName_visibility_toName_error(name: NSFontCollectionName, visibility: NSFontCollectionVisibility, name2: NSFontCollectionName, error: NSError): boolean;
  static fontCollectionWithName(name: NSFontCollectionName): NSFontCollection;
  static fontCollectionWithName_visibility(name: NSFontCollectionName, visibility: NSFontCollectionVisibility): NSFontCollection;
  matchingDescriptorsWithOptions(options: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  matchingDescriptorsForFamily(family: NSString | string): NSArray<any>;
  matchingDescriptorsForFamily_options(family: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  static fontCollectionWithAllAvailableDescriptors(): NSFontCollection;
  static allFontCollectionNames(): NSArray<any>;
  queryDescriptors(): NSArray<any>;
  exclusionDescriptors(): NSArray<any>;
  matchingDescriptors(): NSArray<any>;
}

class NSMutableFontCollectionAllocator<T extends NSMutableFontCollection> extends NSFontCollectionAllocator<T> {}
declare class NSMutableFontCollection extends NSFontCollection {
  alloc<T extends NSMutableFontCollection>(): NSMutableFontCollectionAllocator<T>;
  static fontCollectionWithDescriptors(queryDescriptors: NSArray<any> | any[]): NSMutableFontCollection;
  static fontCollectionWithLocale(locale: NSLocale): NSMutableFontCollection;
  static fontCollectionWithName(name: NSFontCollectionName): NSMutableFontCollection;
  static fontCollectionWithName_visibility(name: NSFontCollectionName, visibility: NSFontCollectionVisibility): NSMutableFontCollection;
  addQueryForDescriptors(descriptors: NSArray<any> | any[]): void;
  removeQueryForDescriptors(descriptors: NSArray<any> | any[]): void;

  static fontCollectionWithAllAvailableDescriptors(): NSMutableFontCollection;
  queryDescriptors(): NSArray<any>;
  setQueryDescriptors(queryDescriptors: NSArray<any> | any[]): void;
  exclusionDescriptors(): NSArray<any>;
  setExclusionDescriptors(exclusionDescriptors: NSArray<any> | any[]): void;
}

declare type NSFontCollectionMatchingOptionKey = NSString

declare type NSFontCollectionName = NSString

declare type NSFontCollectionUserInfoKey = NSString

declare type NSFontCollectionActionTypeKey = NSString

declare enum NSFontCollectionVisibility {
  NSFontCollectionVisibilityProcess,
  NSFontCollectionVisibilityUser,
  NSFontCollectionVisibilityComputer,
}

class NSFontDescriptorAllocator<T extends NSFontDescriptor> extends NSObjectAllocator<T> {
  initWithFontAttributes(attributes: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class NSFontDescriptor extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSFontDescriptor>(): NSFontDescriptorAllocator<T>;
  objectForKey(attribute: NSFontDescriptorAttributeName): any;
  static fontDescriptorWithFontAttributes(attributes: NSDictionary<any, any> | {[key: string]: any} | null): NSFontDescriptor;
  static fontDescriptorWithName_size(fontName: NSString | string, size: CGFloat): NSFontDescriptor;
  static fontDescriptorWithName_matrix(fontName: NSString | string, matrix: NSAffineTransform): NSFontDescriptor;
  matchingFontDescriptorsWithMandatoryKeys(mandatoryKeys: NSSet<any> | null): NSArray<any>;
  matchingFontDescriptorWithMandatoryKeys(mandatoryKeys: NSSet<any> | null): NSFontDescriptor;
  fontDescriptorByAddingAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSFontDescriptor;
  fontDescriptorWithSymbolicTraits(symbolicTraits: NSFontDescriptorSymbolicTraits): NSFontDescriptor;
  fontDescriptorWithSize(newPointSize: CGFloat): NSFontDescriptor;
  fontDescriptorWithMatrix(matrix: NSAffineTransform): NSFontDescriptor;
  fontDescriptorWithFace(newFace: NSString | string): NSFontDescriptor;
  fontDescriptorWithFamily(newFamily: NSString | string): NSFontDescriptor;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  postscriptName(): NSString;
  pointSize(): CGFloat;
  matrix(): NSAffineTransform;
  symbolicTraits(): NSFontDescriptorSymbolicTraits;
  requiresFontAssetRequest(): boolean;
  fontAttributes(): NSDictionary<any, any>;
  static supportsSecureCoding(): boolean;
}

declare type NSFontSymbolicTraits = number

declare type NSFontDescriptorAttributeName = NSString

declare type NSFontDescriptorTraitKey = NSString

declare type NSFontDescriptorVariationKey = NSString

declare type NSFontDescriptorFeatureKey = NSString

declare type NSFontWeight = CGFloat

declare type NSFontFamilyClass = number

declare enum NSFontDescriptorSymbolicTraits {
  NSFontDescriptorTraitItalic = 1 << 0,
  NSFontDescriptorTraitBold = 1 << 1,
  NSFontDescriptorTraitExpanded = 1 << 5,
  NSFontDescriptorTraitCondensed = 1 << 6,
  NSFontDescriptorTraitMonoSpace = 1 << 10,
  NSFontDescriptorTraitVertical = 1 << 11,
  NSFontDescriptorTraitUIOptimized = 1 << 12,
  NSFontDescriptorTraitTightLeading = 1 << 15,
  NSFontDescriptorTraitLooseLeading = 1 << 16,
  NSFontDescriptorClassMask = 0xF0000000,
  NSFontDescriptorClassUnknown = 0 << 28,
  NSFontDescriptorClassOldStyleSerifs = 1 << 28,
  NSFontDescriptorClassTransitionalSerifs = 2 << 28,
  NSFontDescriptorClassModernSerifs = 3 << 28,
  NSFontDescriptorClassClarendonSerifs = 4 << 28,
  NSFontDescriptorClassSlabSerifs = 5 << 28,
  NSFontDescriptorClassFreeformSerifs = 7 << 28,
  NSFontDescriptorClassSansSerif = 8 << 28,
  NSFontDescriptorClassOrnamentals = 9 << 28,
  NSFontDescriptorClassScripts = 10 << 28,
  NSFontDescriptorClassSymbolic = 12 << 28,
}

class NSFontManagerAllocator<T extends NSFontManager> extends NSObjectAllocator<T> {}
declare class NSFontManager extends NSObject {
  alloc<T extends NSFontManager>(): NSFontManagerAllocator<T>;
  static setFontPanelFactory(factoryId: any | null): void;
  static setFontManagerFactory(factoryId: any | null): void;
  setSelectedFont_isMultiple(fontObj: NSFont, flag: boolean): void;
  setFontMenu(newMenu: NSMenu): void;
  fontMenu(create: boolean): NSMenu;
  fontPanel(create: boolean): NSFontPanel;
  fontWithFamily_traits_weight_size(family: NSString | string, traits: NSFontTraitMask, weight: NSInteger, size: CGFloat): NSFont;
  traitsOfFont(fontObj: NSFont): NSFontTraitMask;
  weightOfFont(fontObj: NSFont): NSInteger;
  availableMembersOfFontFamily(fam: NSString | string): NSArray<any>;
  convertFont(fontObj: NSFont): NSFont;
  convertFont_toSize(fontObj: NSFont, size: CGFloat): NSFont;
  convertFont_toFace(fontObj: NSFont, typeface: NSString | string): NSFont;
  convertFont_toFamily(fontObj: NSFont, family: NSString | string): NSFont;
  convertFont_toHaveTrait(fontObj: NSFont, trait: NSFontTraitMask): NSFont;
  convertFont_toNotHaveTrait(fontObj: NSFont, trait: NSFontTraitMask): NSFont;
  convertWeight_ofFont(upFlag: boolean, fontObj: NSFont): NSFont;
  sendAction(): boolean;
  localizedNameForFamily_face(family: NSString | string, faceKey: NSString | string | null): NSString;
  setSelectedAttributes_isMultiple(attributes: NSDictionary<any, any> | {[key: string]: any}, flag: boolean): void;
  convertAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  availableFontNamesMatchingFontDescriptor(descriptor: NSFontDescriptor): NSArray<any>;
  fontDescriptorsInCollection(collectionNames: NSString | string): NSArray<any>;
  addCollection_options(collectionName: NSString | string, collectionOptions: NSFontCollectionOptions): boolean;
  removeCollection(collectionName: NSString | string): boolean;
  addFontDescriptors_toCollection(descriptors: NSArray<any> | any[], collectionName: NSString | string): void;
  removeFontDescriptor_fromCollection(descriptor: NSFontDescriptor, collection: NSString | string): void;
  convertFontTraits(traits: NSFontTraitMask): NSFontTraitMask;
  fontNamed_hasTraits(fName: NSString | string, someTraits: NSFontTraitMask): boolean;
  availableFontNamesWithTraits(someTraits: NSFontTraitMask): NSArray<any>;
  addFontTrait(sender: any | null): void;
  removeFontTrait(sender: any | null): void;
  modifyFontViaPanel(sender: any | null): void;
  modifyFont(sender: any | null): void;
  orderFrontFontPanel(sender: any | null): void;
  orderFrontStylesPanel(sender: any | null): void;

  static sharedFontManager(): NSFontManager;
  multiple(): boolean;
  selectedFont(): NSFont;
  availableFonts(): NSArray<any>;
  availableFontFamilies(): NSArray<any>;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  action(): string;
  setAction(action: string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  collectionNames(): NSArray<any>;
  currentFontAction(): NSFontAction;
  target(): any;
  setTarget(target: any): void;
}

declare enum NSFontTraitMask {
  NSItalicFontMask = 0x00000001,
  NSBoldFontMask = 0x00000002,
  NSUnboldFontMask = 0x00000004,
  NSNonStandardCharacterSetFontMask = 0x00000008,
  NSNarrowFontMask = 0x00000010,
  NSExpandedFontMask = 0x00000020,
  NSCondensedFontMask = 0x00000040,
  NSSmallCapsFontMask = 0x00000080,
  NSPosterFontMask = 0x00000100,
  NSCompressedFontMask = 0x00000200,
  NSFixedPitchFontMask = 0x00000400,
  NSUnitalicFontMask = 0x01000000,
}

declare enum NSFontCollectionOptions {
  NSFontCollectionApplicationOnlyMask = 1 << 0,
}

declare enum NSFontAction {
  NSNoFontChangeAction = 0,
  NSViaPanelFontAction = 1,
  NSAddTraitFontAction = 2,
  NSSizeUpFontAction = 3,
  NSSizeDownFontAction = 4,
  NSHeavierFontAction = 5,
  NSLighterFontAction = 6,
  NSRemoveTraitFontAction = 7,
}

class NSFontPanelAllocator<T extends NSFontPanel> extends NSPanelAllocator<T> {}
declare class NSFontPanel extends NSPanel {
  alloc<T extends NSFontPanel>(): NSFontPanelAllocator<T>;
  setPanelFont_isMultiple(fontObj: NSFont, flag: boolean): void;
  panelConvertFont(fontObj: NSFont): NSFont;
  reloadDefaultFontFamilies(): void;

  static sharedFontPanel(): NSFontPanel;
  static sharedFontPanelExists(): boolean;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  worksWhenModal(): boolean;
  setWorksWhenModal(worksWhenModal: boolean): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}

declare enum NSFontPanelModeMask {
  NSFontPanelModeMaskFace = 1 << 0,
  NSFontPanelModeMaskSize = 1 << 1,
  NSFontPanelModeMaskCollection = 1 << 2,
  NSFontPanelModeMaskUnderlineEffect = 1<<8,
  NSFontPanelModeMaskStrikethroughEffect = 1<<9,
  NSFontPanelModeMaskTextColorEffect = 1<< 10,
  NSFontPanelModeMaskDocumentColorEffect = 1<<11,
  NSFontPanelModeMaskShadowEffect = 1<<12,
  NSFontPanelModeMaskAllEffects = 0XFFF00,
  NSFontPanelModesMaskStandardModes = 0xFFFF,
  NSFontPanelModesMaskAllModes = 0xFFFFFFFF,
}

class NSFormCellAllocator<T extends NSFormCell> extends NSActionCellAllocator<T> {}
declare class NSFormCell extends NSActionCell {
  alloc<T extends NSFormCell>(): NSFormCellAllocator<T>;
  titleWidth(size: NSSize): CGFloat;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;

  titleWidth(): CGFloat;
  setTitleWidth(titleWidth: CGFloat): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  titleFont(): NSFont;
  setTitleFont(titleFont: NSFont): void;
  titleAlignment(): NSTextAlignment;
  setTitleAlignment(titleAlignment: NSTextAlignment): void;
  opaque(): boolean;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  titleBaseWritingDirection(): NSWritingDirection;
  setTitleBaseWritingDirection(titleBaseWritingDirection: NSWritingDirection): void;
  preferredTextFieldWidth(): CGFloat;
  setPreferredTextFieldWidth(preferredTextFieldWidth: CGFloat): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
}

class NSGestureRecognizerAllocator<T extends NSGestureRecognizer> extends NSObjectAllocator<T> {
  initWithTarget_action(target: any | null, action: string | null): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSGestureRecognizer extends NSObject implements INSCoding {
  alloc<T extends NSGestureRecognizer>(): NSGestureRecognizerAllocator<T>;
  locationInView(view: NSView | null): NSPoint;
  reset(): void;
  canPreventGestureRecognizer(preventedGestureRecognizer: NSGestureRecognizer): boolean;
  canBePreventedByGestureRecognizer(preventingGestureRecognizer: NSGestureRecognizer): boolean;
  shouldRequireFailureOfGestureRecognizer(otherGestureRecognizer: NSGestureRecognizer): boolean;
  shouldBeRequiredToFailByGestureRecognizer(otherGestureRecognizer: NSGestureRecognizer): boolean;
  mouseDown(event: NSEvent): void;
  rightMouseDown(event: NSEvent): void;
  otherMouseDown(event: NSEvent): void;
  mouseUp(event: NSEvent): void;
  rightMouseUp(event: NSEvent): void;
  otherMouseUp(event: NSEvent): void;
  mouseDragged(event: NSEvent): void;
  rightMouseDragged(event: NSEvent): void;
  otherMouseDragged(event: NSEvent): void;
  keyDown(event: NSEvent): void;
  keyUp(event: NSEvent): void;
  flagsChanged(event: NSEvent): void;
  tabletPoint(event: NSEvent): void;
  magnifyWithEvent(event: NSEvent): void;
  rotateWithEvent(event: NSEvent): void;
  pressureChangeWithEvent(event: NSEvent): void;
  touchesBeganWithEvent(event: NSEvent): void;
  touchesMovedWithEvent(event: NSEvent): void;
  touchesEndedWithEvent(event: NSEvent): void;
  touchesCancelledWithEvent(event: NSEvent): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  state(): NSGestureRecognizerState;
  setState(state: NSGestureRecognizerState): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  view(): NSView;
  pressureConfiguration(): NSPressureConfiguration;
  setPressureConfiguration(pressureConfiguration: NSPressureConfiguration): void;
  delaysPrimaryMouseButtonEvents(): boolean;
  setDelaysPrimaryMouseButtonEvents(delaysPrimaryMouseButtonEvents: boolean): void;
  delaysSecondaryMouseButtonEvents(): boolean;
  setDelaysSecondaryMouseButtonEvents(delaysSecondaryMouseButtonEvents: boolean): void;
  delaysOtherMouseButtonEvents(): boolean;
  setDelaysOtherMouseButtonEvents(delaysOtherMouseButtonEvents: boolean): void;
  delaysKeyEvents(): boolean;
  setDelaysKeyEvents(delaysKeyEvents: boolean): void;
  delaysMagnificationEvents(): boolean;
  setDelaysMagnificationEvents(delaysMagnificationEvents: boolean): void;
  delaysRotationEvents(): boolean;
  setDelaysRotationEvents(delaysRotationEvents: boolean): void;
  allowedTouchTypes(): NSTouchTypeMask;
  setAllowedTouchTypes(allowedTouchTypes: NSTouchTypeMask): void;
}

declare interface INSGestureRecognizerDelegate {
  gestureRecognizer_shouldAttemptToRecognizeWithEvent(gestureRecognizer: NSGestureRecognizer, event: NSEvent): boolean;
  gestureRecognizerShouldBegin(gestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer(gestureRecognizer: NSGestureRecognizer, otherGestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldRequireFailureOfGestureRecognizer(gestureRecognizer: NSGestureRecognizer, otherGestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer(gestureRecognizer: NSGestureRecognizer, otherGestureRecognizer: NSGestureRecognizer): boolean;
  gestureRecognizer_shouldReceiveTouch(gestureRecognizer: NSGestureRecognizer, touch: NSTouch): boolean;
}

declare enum NSGestureRecognizerState {
  NSGestureRecognizerStatePossible,
  NSGestureRecognizerStateBegan,
  NSGestureRecognizerStateChanged,
  NSGestureRecognizerStateEnded,
  NSGestureRecognizerStateCancelled,
  NSGestureRecognizerStateFailed,
  NSGestureRecognizerStateRecognized,
}

class NSGlyphGeneratorAllocator<T extends NSGlyphGenerator> extends NSObjectAllocator<T> {}
declare class NSGlyphGenerator extends NSObject {
  alloc<T extends NSGlyphGenerator>(): NSGlyphGeneratorAllocator<T>;
  generateGlyphsForGlyphStorage_desiredNumberOfCharacters_glyphIndex_characterIndex(glyphStorage: any, nChars: NSUInteger, glyphIndex: NSUInteger | null, charIndex: NSUInteger | null): void;

  static sharedGlyphGenerator(): NSGlyphGenerator;
}

declare interface INSGlyphStorage {
  insertGlyphs_length_forStartingGlyphAtIndex_characterIndex(glyphs: NSGlyph, length: NSUInteger, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  setIntAttribute_value_forGlyphAtIndex(attributeTag: NSInteger, val: NSInteger, glyphIndex: NSUInteger): void;
  attributedString(): NSAttributedString;
  layoutOptions(): NSUInteger;
}

class NSGlyphInfoAllocator<T extends NSGlyphInfo> extends NSObjectAllocator<T> {}
declare class NSGlyphInfo extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends NSGlyphInfo>(): NSGlyphInfoAllocator<T>;
  static glyphInfoWithCGGlyph_forFont_baseString(glyph: CGGlyph, font: NSFont, string: NSString | string): NSGlyphInfo;
  static glyphInfoWithGlyphName_forFont_baseString(glyphName: NSString | string, font: NSFont, string: NSString | string): NSGlyphInfo;
  static glyphInfoWithGlyph_forFont_baseString(glyph: NSGlyph, font: NSFont, string: NSString | string): NSGlyphInfo;
  static glyphInfoWithCharacterIdentifier_collection_baseString(cid: NSUInteger, characterCollection: NSCharacterCollection, string: NSString | string): NSGlyphInfo;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  glyphID(): CGGlyph;
  baseString(): NSString;
  glyphName(): NSString;
  characterIdentifier(): NSUInteger;
  characterCollection(): NSCharacterCollection;
  static supportsSecureCoding(): boolean;
}

declare enum NSCharacterCollection {
  NSIdentityMappingCharacterCollection = 0,
  NSAdobeCNS1CharacterCollection = 1,
  NSAdobeGB1CharacterCollection = 2,
  NSAdobeJapan1CharacterCollection = 3,
  NSAdobeJapan2CharacterCollection = 4,
  NSAdobeKorea1CharacterCollection = 5,
}

class NSGradientAllocator<T extends NSGradient> extends NSObjectAllocator<T> {
  initWithStartingColor_endingColor(startingColor: NSColor, endingColor: NSColor): T;
  initWithColors(colorArray: NSArray<any> | any[]): T;
  initWithColorsAndLocations(firstColor: NSColor, ...args: any[]): T;
  initWithColors_atLocations_colorSpace(colorArray: NSArray<any> | any[], locations: CGFloat | null, colorSpace: NSColorSpace): T;
  initWithCoder(decoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSGradient extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSGradient>(): NSGradientAllocator<T>;
  drawFromPoint_toPoint_options(startingPoint: NSPoint, endingPoint: NSPoint, options: NSGradientDrawingOptions): void;
  drawInRect_angle(rect: NSRect, angle: CGFloat): void;
  drawInBezierPath_angle(path: NSBezierPath, angle: CGFloat): void;
  drawFromCenter_radius_toCenter_radius_options(startCenter: NSPoint, startRadius: CGFloat, endCenter: NSPoint, endRadius: CGFloat, options: NSGradientDrawingOptions): void;
  drawInRect_relativeCenterPosition(rect: NSRect, relativeCenterPosition: NSPoint): void;
  drawInBezierPath_relativeCenterPosition(path: NSBezierPath, relativeCenterPosition: NSPoint): void;
  getColor_location_atIndex(color: NSColor, location: CGFloat | null, index: NSInteger): void;
  interpolatedColorAtLocation(location: CGFloat): NSColor;
  interpolatedGradientWithExtraStops_function(extraStops: NSUInteger, functionName: GradientInterpolationFunction): NSGradient;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  colorSpace(): NSColorSpace;
  numberOfColorStops(): NSInteger;
}

declare enum NSGradientDrawingOptions {
  NSGradientDrawsBeforeStartingLocation,
  NSGradientDrawsAfterEndingLocation,
}

declare type NSColorSpaceName = NSString

declare type NSDeviceDescriptionKey = NSString

declare enum NSCompositingOperation {
  NSCompositingOperationClear,
  NSCompositingOperationCopy,
  NSCompositingOperationSourceOver,
  NSCompositingOperationSourceIn,
  NSCompositingOperationSourceOut,
  NSCompositingOperationSourceAtop,
  NSCompositingOperationDestinationOver,
  NSCompositingOperationDestinationIn,
  NSCompositingOperationDestinationOut,
  NSCompositingOperationDestinationAtop,
  NSCompositingOperationXOR,
  NSCompositingOperationPlusDarker,
  NSCompositingOperationHighlight,
  NSCompositingOperationPlusLighter,
  NSCompositingOperationMultiply,
  NSCompositingOperationScreen,
  NSCompositingOperationOverlay,
  NSCompositingOperationDarken,
  NSCompositingOperationLighten,
  NSCompositingOperationColorDodge,
  NSCompositingOperationColorBurn,
  NSCompositingOperationSoftLight,
  NSCompositingOperationHardLight,
  NSCompositingOperationDifference,
  NSCompositingOperationExclusion,
  NSCompositingOperationHue,
  NSCompositingOperationSaturation,
  NSCompositingOperationColor,
  NSCompositingOperationLuminosity,
}

declare enum NSBackingStoreType {
  NSBackingStoreRetained = 0,
  NSBackingStoreNonretained = 1,
  NSBackingStoreBuffered = 2,
}

declare enum NSWindowOrderingMode {
  NSWindowAbove = 1,
  NSWindowBelow = -1,
  NSWindowOut = 0,
}

declare enum NSFocusRingPlacement {
  NSFocusRingOnly = 0,
  NSFocusRingBelow = 1,
  NSFocusRingAbove = 2,
}

declare enum NSFocusRingType {
  NSFocusRingTypeDefault = 0,
  NSFocusRingTypeNone = 1,
  NSFocusRingTypeExterior = 2,
}

declare enum NSColorRenderingIntent {
  NSColorRenderingIntentDefault,
  NSColorRenderingIntentAbsoluteColorimetric,
  NSColorRenderingIntentRelativeColorimetric,
  NSColorRenderingIntentPerceptual,
  NSColorRenderingIntentSaturation,
}

declare enum NSWindowDepth {
  NSWindowDepthTwentyfourBitRGB = 0x208,
  NSWindowDepthSixtyfourBitRGB = 0x210,
  NSWindowDepthOnehundredtwentyeightBitRGB = 0x220,
}

declare enum NSDisplayGamut {
  NSDisplayGamutSRGB = 1,
  NSDisplayGamutP3,
}

declare enum NSAnimationEffect {
  NSAnimationEffectDisappearingItemDefault = 0,
  NSAnimationEffectPoof = 10,
}

class NSGraphicsContextAllocator<T extends NSGraphicsContext> extends NSObjectAllocator<T> {}
declare class NSGraphicsContext extends NSObject {
  alloc<T extends NSGraphicsContext>(): NSGraphicsContextAllocator<T>;
  static graphicsContextWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSGraphicsContext;
  static graphicsContextWithWindow(window: NSWindow): NSGraphicsContext;
  static graphicsContextWithBitmapImageRep(bitmapRep: NSBitmapImageRep): NSGraphicsContext;
  static graphicsContextWithCGContext_flipped(graphicsPort: CGContextRef, initialFlippedState: boolean): NSGraphicsContext;
  static currentContextDrawingToScreen(): boolean;
  saveGraphicsState(): void;
  restoreGraphicsState(): void;
  flushGraphics(): void;
  static setGraphicsState(gState: NSInteger): void;
  focusStack(): any;
  setFocusStack(stack: any): void;
  static graphicsContextWithGraphicsPort_flipped(graphicsPort: void, initialFlippedState: boolean): NSGraphicsContext;

  static currentContext(): NSGraphicsContext;
  static setCurrentContext(currentContext: NSGraphicsContext): void;
  attributes(): NSDictionary<any, any>;
  drawingToScreen(): boolean;
  CGContext(): CGContextRef;
  flipped(): boolean;
  shouldAntialias(): boolean;
  setShouldAntialias(shouldAntialias: boolean): void;
  imageInterpolation(): NSImageInterpolation;
  setImageInterpolation(imageInterpolation: NSImageInterpolation): void;
  patternPhase(): NSPoint;
  setPatternPhase(patternPhase: NSPoint): void;
  compositingOperation(): NSCompositingOperation;
  setCompositingOperation(compositingOperation: NSCompositingOperation): void;
  colorRenderingIntent(): NSColorRenderingIntent;
  setColorRenderingIntent(colorRenderingIntent: NSColorRenderingIntent): void;
  CIContext(): CIContext;
  graphicsPort(): void;
}

declare type NSGraphicsContextAttributeKey = NSString

declare type NSGraphicsContextRepresentationFormatName = NSString

declare enum NSImageInterpolation {
  NSImageInterpolationDefault = 0,
  NSImageInterpolationNone = 1,
  NSImageInterpolationLow = 2,
  NSImageInterpolationMedium = 4,
  NSImageInterpolationHigh = 3,
}

class NSGridViewAllocator<T extends NSGridView> extends NSViewAllocator<T> {}
declare class NSGridView extends NSView {
  alloc<T extends NSGridView>(): NSGridViewAllocator<T>;
  static gridViewWithNumberOfColumns_rows(columnCount: NSInteger, rowCount: NSInteger): NSGridView;
  static gridViewWithViews(rows: NSArray<any> | any[]): NSGridView;
  rowAtIndex(index: NSInteger): NSGridRow;
  indexOfRow(row: NSGridRow): NSInteger;
  columnAtIndex(index: NSInteger): NSGridColumn;
  indexOfColumn(column: NSGridColumn): NSInteger;
  cellAtColumnIndex_rowIndex(columnIndex: NSInteger, rowIndex: NSInteger): NSGridCell;
  cellForView(view: NSView): NSGridCell;
  addRowWithViews(views: NSArray<any> | any[]): NSGridRow;
  insertRowAtIndex_withViews(index: NSInteger, views: NSArray<any> | any[]): NSGridRow;
  moveRowAtIndex_toIndex(fromIndex: NSInteger, toIndex: NSInteger): void;
  removeRowAtIndex(index: NSInteger): void;
  addColumnWithViews(views: NSArray<any> | any[]): NSGridColumn;
  insertColumnAtIndex_withViews(index: NSInteger, views: NSArray<any> | any[]): NSGridColumn;
  moveColumnAtIndex_toIndex(fromIndex: NSInteger, toIndex: NSInteger): void;
  removeColumnAtIndex(index: NSInteger): void;
  mergeCellsInHorizontalRange_verticalRange(hRange: NSRange, vRange: NSRange): void;

  numberOfRows(): NSInteger;
  numberOfColumns(): NSInteger;
  xPlacement(): NSGridCellPlacement;
  setXPlacement(xPlacement: NSGridCellPlacement): void;
  yPlacement(): NSGridCellPlacement;
  setYPlacement(yPlacement: NSGridCellPlacement): void;
  rowAlignment(): NSGridRowAlignment;
  setRowAlignment(rowAlignment: NSGridRowAlignment): void;
  rowSpacing(): CGFloat;
  setRowSpacing(rowSpacing: CGFloat): void;
  columnSpacing(): CGFloat;
  setColumnSpacing(columnSpacing: CGFloat): void;
}

class NSGridRowAllocator<T extends NSGridRow> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSGridRow extends NSObject implements INSCoding {
  alloc<T extends NSGridRow>(): NSGridRowAllocator<T>;
  cellAtIndex(index: NSInteger): NSGridCell;
  mergeCellsInRange(range: NSRange): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  gridView(): NSGridView;
  numberOfCells(): NSInteger;
  yPlacement(): NSGridCellPlacement;
  setYPlacement(yPlacement: NSGridCellPlacement): void;
  rowAlignment(): NSGridRowAlignment;
  setRowAlignment(rowAlignment: NSGridRowAlignment): void;
  height(): CGFloat;
  setHeight(height: CGFloat): void;
  topPadding(): CGFloat;
  setTopPadding(topPadding: CGFloat): void;
  bottomPadding(): CGFloat;
  setBottomPadding(bottomPadding: CGFloat): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
}

class NSGridColumnAllocator<T extends NSGridColumn> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSGridColumn extends NSObject implements INSCoding {
  alloc<T extends NSGridColumn>(): NSGridColumnAllocator<T>;
  cellAtIndex(index: NSInteger): NSGridCell;
  mergeCellsInRange(range: NSRange): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  gridView(): NSGridView;
  numberOfCells(): NSInteger;
  xPlacement(): NSGridCellPlacement;
  setXPlacement(xPlacement: NSGridCellPlacement): void;
  width(): CGFloat;
  setWidth(width: CGFloat): void;
  leadingPadding(): CGFloat;
  setLeadingPadding(leadingPadding: CGFloat): void;
  trailingPadding(): CGFloat;
  setTrailingPadding(trailingPadding: CGFloat): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
}

class NSGridCellAllocator<T extends NSGridCell> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSGridCell extends NSObject implements INSCoding {
  alloc<T extends NSGridCell>(): NSGridCellAllocator<T>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  contentView(): NSView;
  setContentView(contentView: NSView): void;
  static emptyContentView(): NSView;
  row(): NSGridRow;
  column(): NSGridColumn;
  xPlacement(): NSGridCellPlacement;
  setXPlacement(xPlacement: NSGridCellPlacement): void;
  yPlacement(): NSGridCellPlacement;
  setYPlacement(yPlacement: NSGridCellPlacement): void;
  rowAlignment(): NSGridRowAlignment;
  setRowAlignment(rowAlignment: NSGridRowAlignment): void;
  customPlacementConstraints(): NSArray<any>;
  setCustomPlacementConstraints(customPlacementConstraints: NSArray<any> | any[]): void;
}

declare enum NSGridCellPlacement {
  NSGridCellPlacementInherited = 0,
  NSGridCellPlacementNone,
  NSGridCellPlacementLeading,
  NSGridCellPlacementTop,
  NSGridCellPlacementTrailing,
  NSGridCellPlacementBottom,
  NSGridCellPlacementCenter,
  NSGridCellPlacementFill,
}

declare enum NSGridRowAlignment {
  NSGridRowAlignmentInherited = 0,
  NSGridRowAlignmentNone,
  NSGridRowAlignmentFirstBaseline,
  NSGridRowAlignmentLastBaseline,
}

class NSGroupTouchBarItemAllocator<T extends NSGroupTouchBarItem> extends NSTouchBarItemAllocator<T> {}
declare class NSGroupTouchBarItem extends NSTouchBarItem {
  alloc<T extends NSGroupTouchBarItem>(): NSGroupTouchBarItemAllocator<T>;
  static groupItemWithIdentifier_items(identifier: NSTouchBarItemIdentifier, items: NSArray<any> | any[]): NSGroupTouchBarItem;
  static groupItemWithIdentifier_items_allowedCompressionOptions(identifier: NSTouchBarItemIdentifier, items: NSArray<any> | any[], allowedCompressionOptions: NSUserInterfaceCompressionOptions): NSGroupTouchBarItem;
  static alertStyleGroupItemWithIdentifier(identifier: NSTouchBarItemIdentifier): NSGroupTouchBarItem;

  groupTouchBar(): NSTouchBar;
  setGroupTouchBar(groupTouchBar: NSTouchBar): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
  groupUserInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setGroupUserInterfaceLayoutDirection(groupUserInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  prefersEqualWidths(): boolean;
  setPrefersEqualWidths(prefersEqualWidths: boolean): void;
  preferredItemWidth(): CGFloat;
  setPreferredItemWidth(preferredItemWidth: CGFloat): void;
  effectiveCompressionOptions(): NSUserInterfaceCompressionOptions;
  prioritizedCompressionOptions(): NSArray<any>;
  setPrioritizedCompressionOptions(prioritizedCompressionOptions: NSArray<any> | any[]): void;
}

class NSHapticFeedbackManagerAllocator<T extends NSHapticFeedbackManager> extends NSObjectAllocator<T> {}
declare class NSHapticFeedbackManager extends NSObject {
  alloc<T extends NSHapticFeedbackManager>(): NSHapticFeedbackManagerAllocator<T>;

  static defaultPerformer(): any;
}

declare interface INSHapticFeedbackPerformer {
  performFeedbackPattern_performanceTime(pattern: NSHapticFeedbackPattern, performanceTime: NSHapticFeedbackPerformanceTime): void;
}

declare enum NSHapticFeedbackPattern {
  NSHapticFeedbackPatternGeneric = 0,
  NSHapticFeedbackPatternAlignment,
  NSHapticFeedbackPatternLevelChange,
}

declare enum NSHapticFeedbackPerformanceTime {
  NSHapticFeedbackPerformanceTimeDefault = 0,
  NSHapticFeedbackPerformanceTimeNow,
  NSHapticFeedbackPerformanceTimeDrawCompleted,
}

class NSHelpManagerAllocator<T extends NSHelpManager> extends NSObjectAllocator<T> {}
declare class NSHelpManager extends NSObject {
  alloc<T extends NSHelpManager>(): NSHelpManagerAllocator<T>;
  setContextHelp_forObject(attrString: NSAttributedString, object: any): void;
  removeContextHelpForObject(object: any): void;
  contextHelpForObject(object: any): NSAttributedString;
  showContextHelpForObject_locationHint(object: any, pt: NSPoint): boolean;
  openHelpAnchor_inBook(anchor: NSHelpAnchorName, book: NSHelpBookName | null): void;
  findString_inBook(query: NSString | string, book: NSHelpBookName | null): void;
  registerBooksInBundle(bundle: NSBundle): boolean;

  static sharedHelpManager(): NSHelpManager;
  static contextHelpModeActive(): boolean;
  static setContextHelpModeActive(contextHelpModeActive: boolean): void;
}

declare type NSHelpBookName = NSString

declare type NSHelpAnchorName = NSString

declare type NSHelpManagerContextHelpKey = NSString

class NSImageAllocator<T extends NSImage> extends NSObjectAllocator<T> {
  initWithSize(size: NSSize): T;
  initWithCoder(coder: NSCoder): T;
  initWithData(data: NSData): T;
  initWithContentsOfFile(fileName: NSString | string): T;
  initWithContentsOfURL(url: NSURL): T;
  initByReferencingFile(fileName: NSString | string): T;
  initByReferencingURL(url: NSURL): T;
  initWithIconRef(iconRef: IconRef): T;
  initWithPasteboard(pasteboard: NSPasteboard): T;
  initWithDataIgnoringOrientation(data: NSData): T;
  initWithCGImage_size(cgImage: CGImageRef, size: NSSize): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): T;
}
declare class NSImage extends NSObject implements INSCopying, INSCoding, INSSecureCoding, INSPasteboardReading, INSPasteboardWriting {
  alloc<T extends NSImage>(): NSImageAllocator<T>;
  static imageNamed(name: NSImageName): NSImage;
  static imageWithSize_flipped_drawingHandler(size: NSSize, drawingHandlerShouldBeCalledWithFlippedContext: boolean, drawingHandler: Block): NSImage;
  setName(string: NSImageName | null): boolean;
  name(): NSImageName;
  drawAtPoint_fromRect_operation_fraction(point: NSPoint, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  drawInRect_fromRect_operation_fraction(rect: NSRect, fromRect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  drawInRect_fromRect_operation_fraction_respectFlipped_hints(dstSpacePortionRect: NSRect, srcSpacePortionRect: NSRect, op: NSCompositingOperation, requestedAlpha: CGFloat, respectContextIsFlipped: boolean, hints: NSDictionary<any, any> | {[key: string]: any} | null): void;
  drawRepresentation_inRect(imageRep: NSImageRep, rect: NSRect): boolean;
  drawInRect(rect: NSRect): void;
  recache(): void;
  TIFFRepresentationUsingCompression_factor(comp: NSTIFFCompression, factor: number): NSData;
  addRepresentations(imageReps: NSArray<any> | any[]): void;
  addRepresentation(imageRep: NSImageRep): void;
  removeRepresentation(imageRep: NSImageRep): void;
  lockFocus(): void;
  lockFocusFlipped(flipped: boolean): void;
  unlockFocus(): void;
  bestRepresentationForDevice(deviceDescription: NSDictionary<any, any> | {[key: string]: any}): NSImageRep;
  static imageUnfilteredFileTypes(): NSArray<any>;
  static imageUnfilteredPasteboardTypes(): NSArray<any>;
  static imageFileTypes(): NSArray<any>;
  static imagePasteboardTypes(): NSArray<any>;
  static canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  cancelIncrementalLoad(): void;
  isTemplate(): boolean;
  setTemplate(isTemplate: boolean): void;
  CGImageForProposedRect_context_hints_CF_RETURNS_NOT_RETAINED(proposedDestRect: NSRect | null, referenceContext: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null): CGImageRef;
  bestRepresentationForRect_context_hints(rect: NSRect, referenceContext: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null): NSImageRep;
  hitTestRect_withImageDestinationRect_context_hints_flipped(testRectDestSpace: NSRect, imageRectDestSpace: NSRect, context: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null, flipped: boolean): boolean;
  recommendedLayerContentsScale(preferredContentsScale: CGFloat): CGFloat;
  layerContentsForContentsScale(layerContentsScale: CGFloat): any;
  setFlipped(flag: boolean): void;
  isFlipped(): boolean;
  dissolveToPoint_fraction(point: NSPoint, fraction: CGFloat): void;
  dissolveToPoint_fromRect_fraction(point: NSPoint, rect: NSRect, fraction: CGFloat): void;
  compositeToPoint_operation(point: NSPoint, op: NSCompositingOperation): void;
  compositeToPoint_fromRect_operation(point: NSPoint, rect: NSRect, op: NSCompositingOperation): void;
  compositeToPoint_operation_fraction(point: NSPoint, op: NSCompositingOperation, delta: CGFloat): void;
  compositeToPoint_fromRect_operation_fraction(point: NSPoint, rect: NSRect, op: NSCompositingOperation, delta: CGFloat): void;
  lockFocusOnRepresentation(imageRepresentation: NSImageRep): void;
  setScalesWhenResized(flag: boolean): void;
  scalesWhenResized(): boolean;
  setDataRetained(flag: boolean): void;
  isDataRetained(): boolean;
  setCachedSeparately(flag: boolean): void;
  isCachedSeparately(): boolean;
  setCacheDepthMatchesImageDepth(flag: boolean): void;
  cacheDepthMatchesImageDepth(): boolean;
  static bundledImageNamed(imageName: NSString | string): NSImage;
  tintedAsPrimaryImageForOwner(owner: any): NSImage;
  tintedAsSecondaryImageForOwner(owner: any): NSImage;
  tintedAsUnselectedImageForOwner_isSharedObject(owner: any, isShared: boolean): NSImage;
  tintedAsSelectedImageForOwner(owner: any): NSImage;
  badgedAs_forOwner(badgeType: MSLayerPreviewBadgeType, owner: any): NSImage;
  badgedWithImage_maskImage_offset_forOwner(badgeImage: NSImage, maskImage: NSImage, offset: NSPoint, owner: any): NSImage;
  badgedWithImageNamed_maskImageNamed_offset_forOwner(badgeName: NSString | string, badgeMaskName: NSString | string, offset: NSPoint, owner: any): NSImage;
  drawAtPoint(point: NSPoint): void;
  drawAtPoint_fraction(point: NSPoint, delta: CGFloat): void;
  scaledImageToSize(aSize: NSSize): any;
  drawProportionallyInRect_operation_fraction(rect: NSRect, op: NSCompositingOperation, frac: CGFloat): void;
  drawInRect_fraction(rect: NSRect, delta: CGFloat): void;
  selectedImage(): NSImage;
  hoverImage(): NSImage;
  pressedImage(): NSImage;
  altImage(): NSImage;
  highlightImage(): NSImage;
  drawFlippedAtPoint(point: NSPoint): void;
  drawFlippedAtPoint_fraction(point: NSPoint, fraction: CGFloat): void;
  firstBitmapImageRepOrCreateIfNecessary(): NSBitmapImageRep;
  firstBitmapImageRepOrCreateIfNecessaryPreservingPixelSize(preservePixelSize: boolean): NSBitmapImageRep;
  firstBitmapImageRep(): NSBitmapImageRep;
  firstBitmapImageRepOfScale(scale: CGFloat): NSBitmapImageRep;
  bitSafeBitmapImageRep(): NSBitmapImageRep;
  drawInRect_fromRect_fraction_respectFlipped_colorSpace(inRect: NSRect, fromRect: NSRect, fraction: CGFloat, isFlipped: boolean, space: NSColorSpace): void;
  isVectorImage(): boolean;
  static PDFImageWithSize_flipped_drawingHandler(size: NSSize, drawingHandlerShouldBeCalledWithFlippedContext: boolean, drawingHandler: Block): NSImage;
  imageWithPadding(padding: NSUInteger): NSImage;
  isImageSizeLargerThan(targetSize: NSSize): boolean;
  pixelSize(): NSSize;
  imageWithShadow_padding(shadow: NSShadow, padding: NSUInteger): NSImage;
  thumbWithSize_cornerRadius(size: NSSize, cornerRadius: CGFloat): NSImage;
  static pngDataByFixingInvalidGamma(data: NSData): NSData;
  tintedWithColor(color: NSColor): NSImage;
  tintedWithColor_compositingOperation(color: NSColor, op: NSCompositingOperation): NSImage;
  tintedWithColor_forOwner(color: NSColor, imageOwner: any | null): NSImage;
  horizontallyFlipped(): NSImage;
  verticallyFlipped(): NSImage;
  static drawImageWithSize_withBlock(aSize: NSSize, aBlock: BCVoidBlock): NSImage;
  static drawImageFlippedWithSize_withBlock(aSize: NSSize, aBlock: BCVoidBlock): NSImage;
  static drawImageFlipped_withSize_withBlock(shouldFlip: boolean, aSize: NSSize, aBlock: BCVoidBlock): NSImage;
  imageHasAlpha(): boolean;
  static imageFromDataArchive(data: NSData): NSImage;
  dataForArchiving(): NSData;
  hasPDFData(): boolean;
  PDFImageRep(): NSPDFImageRep;
  hasEPSData(): boolean;
  EPSImageRep(): NSEPSImageRep;
  bitmapData(): NSData;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;

  size(): NSSize;
  setSize(size: NSSize): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  usesEPSOnResolutionMismatch(): boolean;
  setUsesEPSOnResolutionMismatch(usesEPSOnResolutionMismatch: boolean): void;
  prefersColorMatch(): boolean;
  setPrefersColorMatch(prefersColorMatch: boolean): void;
  matchesOnMultipleResolution(): boolean;
  setMatchesOnMultipleResolution(matchesOnMultipleResolution: boolean): void;
  matchesOnlyOnBestFittingAxis(): boolean;
  setMatchesOnlyOnBestFittingAxis(matchesOnlyOnBestFittingAxis: boolean): void;
  TIFFRepresentation(): NSData;
  representations(): NSArray<any>;
  valid(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  static imageTypes(): NSArray<any>;
  static imageUnfilteredTypes(): NSArray<any>;
  cacheMode(): NSImageCacheMode;
  setCacheMode(cacheMode: NSImageCacheMode): void;
  alignmentRect(): NSRect;
  setAlignmentRect(alignmentRect: NSRect): void;
  template(): boolean;
  setTemplate(template: boolean): void;
  accessibilityDescription(): NSString;
  setAccessibilityDescription(accessibilityDescription: NSString | string): void;
  capInsets(): NSEdgeInsets;
  setCapInsets(capInsets: NSEdgeInsets): void;
  resizingMode(): NSImageResizingMode;
  setResizingMode(resizingMode: NSImageResizingMode): void;
  embeddedXlinkValue(): NSString;
  static supportsSecureCoding(): boolean;
}

declare interface INSImageDelegate {
  imageDidNotDraw_inRect(sender: NSImage, rect: NSRect): NSImage;
  image_willLoadRepresentation(image: NSImage, rep: NSImageRep): void;
  image_didLoadRepresentationHeader(image: NSImage, rep: NSImageRep): void;
  image_didLoadPartOfRepresentation_withValidRows(image: NSImage, rep: NSImageRep, rows: NSInteger): void;
  image_didLoadRepresentation_withStatus(image: NSImage, rep: NSImageRep, status: NSImageLoadStatus): void;
}

declare type NSImageName = NSString

declare enum NSImageLoadStatus {
  NSImageLoadStatusCompleted,
  NSImageLoadStatusCancelled,
  NSImageLoadStatusInvalidData,
  NSImageLoadStatusUnexpectedEOF,
  NSImageLoadStatusReadError,
}

declare enum NSImageCacheMode {
  NSImageCacheDefault,
  NSImageCacheAlways,
  NSImageCacheBySize,
  NSImageCacheNever,
}

declare enum NSImageResizingMode {
  NSImageResizingModeStretch,
  NSImageResizingModeTile,
}

class NSImageCellAllocator<T extends NSImageCell> extends NSCellAllocator<T> {}
declare class NSImageCell extends NSCell implements INSCopying, INSCoding {
  alloc<T extends NSImageCell>(): NSImageCellAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  imageAlignment(): NSImageAlignment;
  setImageAlignment(imageAlignment: NSImageAlignment): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  imageFrameStyle(): NSImageFrameStyle;
  setImageFrameStyle(imageFrameStyle: NSImageFrameStyle): void;
}

declare enum NSImageAlignment {
  NSImageAlignCenter = 0,
  NSImageAlignTop,
  NSImageAlignTopLeft,
  NSImageAlignTopRight,
  NSImageAlignLeft,
  NSImageAlignBottom,
  NSImageAlignBottomLeft,
  NSImageAlignBottomRight,
  NSImageAlignRight,
}

declare enum NSImageFrameStyle {
  NSImageFrameNone = 0,
  NSImageFramePhoto,
  NSImageFrameGrayBezel,
  NSImageFrameGroove,
  NSImageFrameButton,
}

class NSImageRepAllocator<T extends NSImageRep> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSImageRep extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSImageRep>(): NSImageRepAllocator<T>;
  draw(): boolean;
  drawAtPoint(point: NSPoint): boolean;
  drawInRect(rect: NSRect): boolean;
  drawInRect_fromRect_operation_fraction_respectFlipped_hints(dstSpacePortionRect: NSRect, srcSpacePortionRect: NSRect, op: NSCompositingOperation, requestedAlpha: CGFloat, respectContextIsFlipped: boolean, hints: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  static registerImageRepClass(imageRepClass: any): void;
  static unregisterImageRepClass(imageRepClass: any): void;
  static imageRepClassForFileType(type: NSString | string): any;
  static imageRepClassForPasteboardType(type: NSPasteboardType): any;
  static imageRepClassForType(type: NSString | string): any;
  static imageRepClassForData(data: NSData): any;
  static canInitWithData(data: NSData): boolean;
  static imageUnfilteredFileTypes(): NSArray<any>;
  static imageUnfilteredPasteboardTypes(): NSArray<any>;
  static imageFileTypes(): NSArray<any>;
  static imagePasteboardTypes(): NSArray<any>;
  static canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  static imageRepsWithContentsOfFile(filename: NSString | string): NSArray<any>;
  static imageRepWithContentsOfFile(filename: NSString | string): NSImageRep;
  static imageRepsWithContentsOfURL(url: NSURL): NSArray<any>;
  static imageRepWithContentsOfURL(url: NSURL): NSImageRep;
  static imageRepsWithPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static imageRepWithPasteboard(pasteboard: NSPasteboard): NSImageRep;
  CGImageForProposedRect_context_hints_CF_RETURNS_NOT_RETAINED(proposedDestRect: NSRect | null, context: NSGraphicsContext | null, hints: NSDictionary<any, any> | {[key: string]: any} | null): CGImageRef;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  size(): NSSize;
  setSize(size: NSSize): void;
  alpha(): boolean;
  setAlpha(alpha: boolean): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
  colorSpaceName(): NSColorSpaceName;
  setColorSpaceName(colorSpaceName: NSColorSpaceName): void;
  bitsPerSample(): NSInteger;
  setBitsPerSample(bitsPerSample: NSInteger): void;
  pixelsWide(): NSInteger;
  setPixelsWide(pixelsWide: NSInteger): void;
  pixelsHigh(): NSInteger;
  setPixelsHigh(pixelsHigh: NSInteger): void;
  layoutDirection(): NSImageLayoutDirection;
  setLayoutDirection(layoutDirection: NSImageLayoutDirection): void;
  static registeredImageRepClasses(): NSArray<any>;
  static imageUnfilteredTypes(): NSArray<any>;
  static imageTypes(): NSArray<any>;
}

declare type NSImageHintKey = NSString

declare enum NSImageLayoutDirection {
  NSImageLayoutDirectionUnspecified = -1,
  NSImageLayoutDirectionLeftToRight = 2,
  NSImageLayoutDirectionRightToLeft = 3,
}

class NSImageViewAllocator<T extends NSImageView> extends NSControlAllocator<T> {}
declare class NSImageView extends NSControl implements INSAccessibilityImage {
  alloc<T extends NSImageView>(): NSImageViewAllocator<T>;
  static imageViewWithImage(image: NSImage): NSImageView;
  accessibilityLabel(): NSString;
  accessibilityLabel(): NSString;

  image(): NSImage;
  setImage(image: NSImage): void;
  imageAlignment(): NSImageAlignment;
  setImageAlignment(imageAlignment: NSImageAlignment): void;
  imageScaling(): NSImageScaling;
  setImageScaling(imageScaling: NSImageScaling): void;
  imageFrameStyle(): NSImageFrameStyle;
  setImageFrameStyle(imageFrameStyle: NSImageFrameStyle): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  animates(): boolean;
  setAnimates(animates: boolean): void;
  allowsCutCopyPaste(): boolean;
  setAllowsCutCopyPaste(allowsCutCopyPaste: boolean): void;
}

class NSInputManagerAllocator<T extends NSInputManager> extends NSObjectAllocator<T> {
  initWithName_host(inputServerName: NSString | string, hostName: NSString | string): T;
}
declare class NSInputManager extends NSObject implements INSTextInput {
  alloc<T extends NSInputManager>(): NSInputManagerAllocator<T>;
  static currentInputManager(): NSInputManager;
  static cycleToNextInputLanguage(sender: any | null): void;
  static cycleToNextInputServerInLanguage(sender: any | null): void;
  localizedInputManagerName(): NSString;
  markedTextAbandoned(cli: any): void;
  markedTextSelectionChanged_client(newSel: NSRange, cli: any): void;
  wantsToInterpretAllKeystrokes(): boolean;
  language(): NSString;
  image(): NSImage;
  server(): NSInputServer;
  wantsToHandleMouseEvents(): boolean;
  handleMouseEvent(mouseEvent: NSEvent): boolean;
  wantsToDelayTextChangeNotifications(): boolean;
  insertText(string: any): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange(string: any, selRange: NSRange): void;
  unmarkText(): void;
  hasMarkedText(): boolean;
  conversationIdentifier(): NSInteger;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  firstRectForCharacterRange(range: NSRange): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  validAttributesForMarkedText(): NSArray<any>;
  insertText(string: any): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange(string: any, selRange: NSRange): void;
  unmarkText(): void;
  hasMarkedText(): boolean;
  conversationIdentifier(): NSInteger;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  firstRectForCharacterRange(range: NSRange): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  validAttributesForMarkedText(): NSArray<any>;
}

declare interface INSTextInput {
  insertText(string: any): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange(string: any, selRange: NSRange): void;
  unmarkText(): void;
  hasMarkedText(): boolean;
  conversationIdentifier(): NSInteger;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  firstRectForCharacterRange(range: NSRange): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  validAttributesForMarkedText(): NSArray<any>;
}

class NSInputServerAllocator<T extends NSInputServer> extends NSObjectAllocator<T> {
  initWithDelegate_name(delegate: any, name: NSString | string): T;
}
declare class NSInputServer extends NSObject implements INSInputServiceProvider, INSInputServerMouseTracker {
  alloc<T extends NSInputServer>(): NSInputServerAllocator<T>;
  insertText_client(string: any, sender: any): void;
  doCommandBySelector_client(selector: string, sender: any): void;
  markedTextAbandoned(sender: any | null): void;
  markedTextSelectionChanged_client(newSel: NSRange, sender: any): void;
  terminate(sender: any | null): void;
  canBeDisabled(): boolean;
  wantsToInterpretAllKeystrokes(): boolean;
  wantsToHandleMouseEvents(): boolean;
  wantsToDelayTextChangeNotifications(): boolean;
  inputClientBecomeActive(sender: any | null): void;
  inputClientResignActive(sender: any | null): void;
  inputClientEnabled(sender: any | null): void;
  inputClientDisabled(sender: any | null): void;
  activeConversationWillChange_fromOldConversation(sender: any, oldConversation: NSInteger): void;
  activeConversationChanged_toNewConversation(sender: any, newConversation: NSInteger): void;
  mouseDownOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseDraggedOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseUpOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): void;
  insertText_client(string: any, sender: any): void;
  doCommandBySelector_client(selector: string, sender: any): void;
  markedTextAbandoned(sender: any | null): void;
  markedTextSelectionChanged_client(newSel: NSRange, sender: any): void;
  terminate(sender: any | null): void;
  canBeDisabled(): boolean;
  wantsToInterpretAllKeystrokes(): boolean;
  wantsToHandleMouseEvents(): boolean;
  wantsToDelayTextChangeNotifications(): boolean;
  inputClientBecomeActive(sender: any | null): void;
  inputClientResignActive(sender: any | null): void;
  inputClientEnabled(sender: any | null): void;
  inputClientDisabled(sender: any | null): void;
  activeConversationWillChange_fromOldConversation(sender: any, oldConversation: NSInteger): void;
  activeConversationChanged_toNewConversation(sender: any, newConversation: NSInteger): void;
  mouseDownOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseDraggedOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseUpOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): void;
}

declare interface INSInputServiceProvider {
  insertText_client(string: any, sender: any): void;
  doCommandBySelector_client(selector: string, sender: any): void;
  markedTextAbandoned(sender: any | null): void;
  markedTextSelectionChanged_client(newSel: NSRange, sender: any): void;
  terminate(sender: any | null): void;
  canBeDisabled(): boolean;
  wantsToInterpretAllKeystrokes(): boolean;
  wantsToHandleMouseEvents(): boolean;
  wantsToDelayTextChangeNotifications(): boolean;
  inputClientBecomeActive(sender: any | null): void;
  inputClientResignActive(sender: any | null): void;
  inputClientEnabled(sender: any | null): void;
  inputClientDisabled(sender: any | null): void;
  activeConversationWillChange_fromOldConversation(sender: any, oldConversation: NSInteger): void;
  activeConversationChanged_toNewConversation(sender: any, newConversation: NSInteger): void;
}

declare interface INSInputServerMouseTracker {
  mouseDownOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseDraggedOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): boolean;
  mouseUpOnCharacterIndex_atCoordinate_withModifier_client(index: NSUInteger, point: NSPoint, flags: NSUInteger, sender: any): void;
}

class NSResponderAllocator<T extends NSResponder> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSResponder extends NSObject implements INSCoding {
  alloc<T extends NSResponder>(): NSResponderAllocator<T>;
  interfaceStyle(): NSInterfaceStyle;
  setInterfaceStyle(interfaceStyle: NSInterfaceStyle): void;
  tryToPerform_with(action: string, object: any | null): boolean;
  performKeyEquivalent(event: NSEvent): boolean;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  mouseDown(event: NSEvent): void;
  rightMouseDown(event: NSEvent): void;
  otherMouseDown(event: NSEvent): void;
  mouseUp(event: NSEvent): void;
  rightMouseUp(event: NSEvent): void;
  otherMouseUp(event: NSEvent): void;
  mouseMoved(event: NSEvent): void;
  mouseDragged(event: NSEvent): void;
  scrollWheel(event: NSEvent): void;
  rightMouseDragged(event: NSEvent): void;
  otherMouseDragged(event: NSEvent): void;
  mouseEntered(event: NSEvent): void;
  mouseExited(event: NSEvent): void;
  keyDown(event: NSEvent): void;
  keyUp(event: NSEvent): void;
  flagsChanged(event: NSEvent): void;
  tabletPoint(event: NSEvent): void;
  tabletProximity(event: NSEvent): void;
  cursorUpdate(event: NSEvent): void;
  magnifyWithEvent(event: NSEvent): void;
  rotateWithEvent(event: NSEvent): void;
  swipeWithEvent(event: NSEvent): void;
  beginGestureWithEvent(event: NSEvent): void;
  endGestureWithEvent(event: NSEvent): void;
  smartMagnifyWithEvent(event: NSEvent): void;
  touchesBeganWithEvent(event: NSEvent): void;
  touchesMovedWithEvent(event: NSEvent): void;
  touchesEndedWithEvent(event: NSEvent): void;
  touchesCancelledWithEvent(event: NSEvent): void;
  quickLookWithEvent(event: NSEvent): void;
  pressureChangeWithEvent(event: NSEvent): void;
  noResponderFor(eventSelector: string): void;
  becomeFirstResponder(): boolean;
  resignFirstResponder(): boolean;
  interpretKeyEvents(eventArray: NSArray<any> | any[]): void;
  flushBufferedKeyEvents(): void;
  showContextHelp(sender: any | null): void;
  helpRequested(eventPtr: NSEvent): void;
  shouldBeTreatedAsInkEvent(event: NSEvent): boolean;
  wantsScrollEventsForSwipeTrackingOnAxis(axis: NSEventGestureAxis): boolean;
  wantsForwardedScrollEventsForAxis(axis: NSEventGestureAxis): boolean;
  supplementalTargetForAction_sender(action: string, sender: any | null): any;
  insertText(insertString: any): void;
  doCommandBySelector(selector: string): void;
  moveForward(sender: any | null): void;
  moveRight(sender: any | null): void;
  moveBackward(sender: any | null): void;
  moveLeft(sender: any | null): void;
  moveUp(sender: any | null): void;
  moveDown(sender: any | null): void;
  moveWordForward(sender: any | null): void;
  moveWordBackward(sender: any | null): void;
  moveToBeginningOfLine(sender: any | null): void;
  moveToEndOfLine(sender: any | null): void;
  moveToBeginningOfParagraph(sender: any | null): void;
  moveToEndOfParagraph(sender: any | null): void;
  moveToEndOfDocument(sender: any | null): void;
  moveToBeginningOfDocument(sender: any | null): void;
  pageDown(sender: any | null): void;
  pageUp(sender: any | null): void;
  centerSelectionInVisibleArea(sender: any | null): void;
  moveBackwardAndModifySelection(sender: any | null): void;
  moveForwardAndModifySelection(sender: any | null): void;
  moveWordForwardAndModifySelection(sender: any | null): void;
  moveWordBackwardAndModifySelection(sender: any | null): void;
  moveUpAndModifySelection(sender: any | null): void;
  moveDownAndModifySelection(sender: any | null): void;
  moveToBeginningOfLineAndModifySelection(sender: any | null): void;
  moveToEndOfLineAndModifySelection(sender: any | null): void;
  moveToBeginningOfParagraphAndModifySelection(sender: any | null): void;
  moveToEndOfParagraphAndModifySelection(sender: any | null): void;
  moveToEndOfDocumentAndModifySelection(sender: any | null): void;
  moveToBeginningOfDocumentAndModifySelection(sender: any | null): void;
  pageDownAndModifySelection(sender: any | null): void;
  pageUpAndModifySelection(sender: any | null): void;
  moveParagraphForwardAndModifySelection(sender: any | null): void;
  moveParagraphBackwardAndModifySelection(sender: any | null): void;
  moveWordRight(sender: any | null): void;
  moveWordLeft(sender: any | null): void;
  moveRightAndModifySelection(sender: any | null): void;
  moveLeftAndModifySelection(sender: any | null): void;
  moveWordRightAndModifySelection(sender: any | null): void;
  moveWordLeftAndModifySelection(sender: any | null): void;
  moveToLeftEndOfLine(sender: any | null): void;
  moveToRightEndOfLine(sender: any | null): void;
  moveToLeftEndOfLineAndModifySelection(sender: any | null): void;
  moveToRightEndOfLineAndModifySelection(sender: any | null): void;
  scrollPageUp(sender: any | null): void;
  scrollPageDown(sender: any | null): void;
  scrollLineUp(sender: any | null): void;
  scrollLineDown(sender: any | null): void;
  scrollToBeginningOfDocument(sender: any | null): void;
  scrollToEndOfDocument(sender: any | null): void;
  transpose(sender: any | null): void;
  transposeWords(sender: any | null): void;
  selectAll(sender: any | null): void;
  selectParagraph(sender: any | null): void;
  selectLine(sender: any | null): void;
  selectWord(sender: any | null): void;
  indent(sender: any | null): void;
  insertTab(sender: any | null): void;
  insertBacktab(sender: any | null): void;
  insertNewline(sender: any | null): void;
  insertParagraphSeparator(sender: any | null): void;
  insertNewlineIgnoringFieldEditor(sender: any | null): void;
  insertTabIgnoringFieldEditor(sender: any | null): void;
  insertLineBreak(sender: any | null): void;
  insertContainerBreak(sender: any | null): void;
  insertSingleQuoteIgnoringSubstitution(sender: any | null): void;
  insertDoubleQuoteIgnoringSubstitution(sender: any | null): void;
  changeCaseOfLetter(sender: any | null): void;
  uppercaseWord(sender: any | null): void;
  lowercaseWord(sender: any | null): void;
  capitalizeWord(sender: any | null): void;
  deleteForward(sender: any | null): void;
  deleteBackward(sender: any | null): void;
  deleteBackwardByDecomposingPreviousCharacter(sender: any | null): void;
  deleteWordForward(sender: any | null): void;
  deleteWordBackward(sender: any | null): void;
  deleteToBeginningOfLine(sender: any | null): void;
  deleteToEndOfLine(sender: any | null): void;
  deleteToBeginningOfParagraph(sender: any | null): void;
  deleteToEndOfParagraph(sender: any | null): void;
  yank(sender: any | null): void;
  complete(sender: any | null): void;
  setMark(sender: any | null): void;
  deleteToMark(sender: any | null): void;
  selectToMark(sender: any | null): void;
  swapWithMark(sender: any | null): void;
  cancelOperation(sender: any | null): void;
  makeBaseWritingDirectionNatural(sender: any | null): void;
  makeBaseWritingDirectionLeftToRight(sender: any | null): void;
  makeBaseWritingDirectionRightToLeft(sender: any | null): void;
  makeTextWritingDirectionNatural(sender: any | null): void;
  makeTextWritingDirectionLeftToRight(sender: any | null): void;
  makeTextWritingDirectionRightToLeft(sender: any | null): void;
  quickLookPreviewItems(sender: any | null): void;
  validateProposedFirstResponder_forEvent(responder: NSResponder, event: NSEvent | null): boolean;
  presentError_modalForWindow_delegate_didPresentSelector_contextInfo(error: NSError, window: NSWindow, delegate: any | null, didPresentSelector: string | null, contextInfo: void | null): void;
  presentError(error: NSError): boolean;
  willPresentError(error: NSError): NSError;
  performTextFinderAction(sender: any | null): void;
  newWindowForTab(sender: any | null): IBAction;
  performMnemonic(string: NSString | string): boolean;
  makeTouchBar(): NSTouchBar;
  updateUserActivityState(userActivity: NSUserActivity): void;
  restoreUserActivityState(userActivity: NSUserActivity): void;
  encodeRestorableStateWithCoder(coder: NSCoder): void;
  encodeRestorableStateWithCoder_backgroundQueue(coder: NSCoder, queue: NSOperationQueue): void;
  restoreStateWithCoder(coder: NSCoder): void;
  invalidateRestorableState(): void;
  followsResponder(aResponder: NSResponder): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  nextResponder(): NSResponder;
  setNextResponder(nextResponder: NSResponder): void;
  acceptsFirstResponder(): boolean;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  undoManager(): NSUndoManager;
  touchBar(): NSTouchBar;
  setTouchBar(touchBar: NSTouchBar): void;
  userActivity(): NSUserActivity;
  setUserActivity(userActivity: NSUserActivity): void;
  static restorableStateKeyPaths(): NSArray<any>;
  supportsTouchBar(): boolean;
}

declare type NSInterfaceStyle = NSUInteger

declare type NSBindingName = NSString

declare type NSBindingOption = NSString

declare type NSBindingInfoKey = NSString

// @ts-ignore
class NSLayoutAnchorAllocator<T extends NSLayoutAnchor> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
// @ts-ignore
declare class NSLayoutAnchor extends NSObject implements INSCopying, INSCoding {
  // @ts-ignore
  alloc<T extends NSLayoutAnchor>(): NSLayoutAnchorAllocator<T>;
  constraintEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;
  constraintEqualToAnchor_constant(anchor: NSLayoutAnchor, c: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor_constant(anchor: NSLayoutAnchor, c: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor_constant(anchor: NSLayoutAnchor, c: CGFloat): NSLayoutConstraint;
  copyWithZone(zone: NSZone): any;
  encodeWithCoder(aCoder: NSCoder): void;

  name(): NSString;
  setName(name: NSString): void;
  item(): any;
  setItem(item: any): void;
  hasAmbiguousLayout(): boolean;
  setHasAmbiguousLayout(hasAmbiguousLayout: boolean): void;
  constraintsAffectingLayout(): NSArray<any>;
  setConstraintsAffectingLayout(constraintsAffectingLayout: NSArray<any>): void;
}

// @ts-ignore
class NSLayoutXAxisAnchorAllocator<T extends NSLayoutXAxisAnchor> extends NSLayoutAnchorAllocator<T> {}
// @ts-ignore
declare class NSLayoutXAxisAnchor extends NSLayoutAnchor {
  // @ts-ignore
  alloc<T extends NSLayoutXAxisAnchor>(): NSLayoutXAxisAnchorAllocator<T>;
  anchorWithOffsetToAnchor(otherAnchor: NSLayoutXAxisAnchor): NSLayoutDimension;
}

// @ts-ignore
class NSLayoutYAxisAnchorAllocator<T extends NSLayoutYAxisAnchor> extends NSLayoutAnchorAllocator<T> {}
// @ts-ignore
declare class NSLayoutYAxisAnchor extends NSLayoutAnchor {
  // @ts-ignore
  alloc<T extends NSLayoutYAxisAnchor>(): NSLayoutYAxisAnchorAllocator<T>;
  anchorWithOffsetToAnchor(otherAnchor: NSLayoutYAxisAnchor): NSLayoutDimension;
}

// @ts-ignore
class NSLayoutDimensionAllocator<T extends NSLayoutDimension> extends NSLayoutAnchorAllocator<T> {}
// @ts-ignore
declare class NSLayoutDimension extends NSLayoutAnchor {
  // @ts-ignore
  alloc<T extends NSLayoutDimension>(): NSLayoutDimensionAllocator<T>;
  constraintEqualToConstant(c: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToConstant(c: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToConstant(c: CGFloat): NSLayoutConstraint;
  constraintEqualToAnchor_multiplier(anchor: NSLayoutDimension, m: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor_multiplier(anchor: NSLayoutDimension, m: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor_multiplier(anchor: NSLayoutDimension, m: CGFloat): NSLayoutConstraint;
  constraintEqualToAnchor_multiplier_constant(anchor: NSLayoutDimension, m: CGFloat, c: CGFloat): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor_multiplier_constant(anchor: NSLayoutDimension, m: CGFloat, c: CGFloat): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor_multiplier_constant(anchor: NSLayoutDimension, m: CGFloat, c: CGFloat): NSLayoutConstraint;
}

class NSLayoutConstraintAllocator<T extends NSLayoutConstraint> extends NSObjectAllocator<T> {}
declare class NSLayoutConstraint extends NSObject implements INSAnimatablePropertyContainer {
  alloc<T extends NSLayoutConstraint>(): NSLayoutConstraintAllocator<T>;
  static constraintsWithVisualFormat_options_metrics_views(format: NSString | string, opts: NSLayoutFormatOptions, metrics: NSDictionary<any, any> | {[key: string]: any} | null, views: NSDictionary<any, any> | {[key: string]: any}): NSArray<any>;
  static constraintWithItem_attribute_relatedBy_toItem_attribute_multiplier_constant(view1: any, attr1: NSLayoutAttribute, relation: NSLayoutRelation, view2: any | null, attr2: NSLayoutAttribute, multiplier: CGFloat, c: CGFloat): NSLayoutConstraint;
  static activateConstraints(constraints: NSArray<any> | any[]): void;
  static deactivateConstraints(constraints: NSArray<any> | any[]): void;
  animator(): NSLayoutConstraint;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  animator(): NSLayoutConstraint;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;

  priority(): NSLayoutPriority;
  setPriority(priority: NSLayoutPriority): void;
  shouldBeArchived(): boolean;
  setShouldBeArchived(shouldBeArchived: boolean): void;
  firstItem(): any;
  firstAttribute(): NSLayoutAttribute;
  secondItem(): any;
  secondAttribute(): NSLayoutAttribute;
  firstAnchor(): NSLayoutAnchor;
  secondAnchor(): NSLayoutAnchor;
  relation(): NSLayoutRelation;
  multiplier(): CGFloat;
  constant(): CGFloat;
  setConstant(constant: CGFloat): void;
  active(): boolean;
  setActive(active: boolean): void;
  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
}

declare type NSLayoutPriority = number

declare enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual = -1,
  NSLayoutRelationEqual = 0,
  NSLayoutRelationGreaterThanOrEqual = 1,
}

declare enum NSLayoutAttribute {
  NSLayoutAttributeLeft = 1,
  NSLayoutAttributeRight,
  NSLayoutAttributeTop,
  NSLayoutAttributeBottom,
  NSLayoutAttributeLeading,
  NSLayoutAttributeTrailing,
  NSLayoutAttributeWidth,
  NSLayoutAttributeHeight,
  NSLayoutAttributeCenterX,
  NSLayoutAttributeCenterY,
  NSLayoutAttributeLastBaseline,
  NSLayoutAttributeBaseline,
  NSLayoutAttributeFirstBaseline,
  NSLayoutAttributeNotAnAttribute = 0,
}

declare enum NSLayoutFormatOptions {
  NSLayoutFormatAlignAllLeft,
  NSLayoutFormatAlignAllRight,
  NSLayoutFormatAlignAllTop,
  NSLayoutFormatAlignAllBottom,
  NSLayoutFormatAlignAllLeading,
  NSLayoutFormatAlignAllTrailing,
  NSLayoutFormatAlignAllCenterX,
  NSLayoutFormatAlignAllCenterY,
  NSLayoutFormatAlignAllBaseline,
  NSLayoutFormatAlignAllLastBaseline,
  NSLayoutFormatAlignAllFirstBaseline,
  NSLayoutFormatAlignmentMask = 0xFFFF,
  NSLayoutFormatDirectionLeadingToTrailing = 0 << 16,
  NSLayoutFormatDirectionLeftToRight = 1 << 16,
  NSLayoutFormatDirectionRightToLeft = 2 << 16,
  NSLayoutFormatDirectionMask = 0x3 << 16,
}

declare enum NSLayoutConstraintOrientation {
  NSLayoutConstraintOrientationHorizontal = 0,
  NSLayoutConstraintOrientationVertical = 1,
}

class NSLayoutGuideAllocator<T extends NSLayoutGuide> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSLayoutGuide extends NSObject implements INSCoding, INSUserInterfaceItemIdentification {
  alloc<T extends NSLayoutGuide>(): NSLayoutGuideAllocator<T>;
  constraintsAffectingLayoutForOrientation(orientation: NSLayoutConstraintOrientation): NSArray<any>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  frame(): NSRect;
  owningView(): NSView;
  setOwningView(owningView: NSView): void;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  leadingAnchor(): NSLayoutXAxisAnchor;
  trailingAnchor(): NSLayoutXAxisAnchor;
  leftAnchor(): NSLayoutXAxisAnchor;
  rightAnchor(): NSLayoutXAxisAnchor;
  topAnchor(): NSLayoutYAxisAnchor;
  bottomAnchor(): NSLayoutYAxisAnchor;
  widthAnchor(): NSLayoutDimension;
  heightAnchor(): NSLayoutDimension;
  centerXAnchor(): NSLayoutXAxisAnchor;
  centerYAnchor(): NSLayoutYAxisAnchor;
  hasAmbiguousLayout(): boolean;
}

class NSLayoutManagerAllocator<T extends NSLayoutManager> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSLayoutManager extends NSObject implements INSCoding {
  alloc<T extends NSLayoutManager>(): NSLayoutManagerAllocator<T>;
  replaceTextStorage(newTextStorage: NSTextStorage): void;
  addTextContainer(container: NSTextContainer): void;
  insertTextContainer_atIndex(container: NSTextContainer, index: NSUInteger): void;
  removeTextContainerAtIndex(index: NSUInteger): void;
  textContainerChangedGeometry(container: NSTextContainer): void;
  textContainerChangedTextView(container: NSTextContainer): void;
  invalidateGlyphsForCharacterRange_changeInLength_actualCharacterRange(charRange: NSRange, delta: NSInteger, actualCharRange: NSRangePointer | null): void;
  invalidateLayoutForCharacterRange_actualCharacterRange(charRange: NSRange, actualCharRange: NSRangePointer | null): void;
  invalidateDisplayForCharacterRange(charRange: NSRange): void;
  invalidateDisplayForGlyphRange(glyphRange: NSRange): void;
  processEditingForTextStorage_edited_range_changeInLength_invalidatedRange(textStorage: NSTextStorage, editMask: NSTextStorageEditActions, newCharRange: NSRange, delta: NSInteger, invalidatedCharRange: NSRange): void;
  ensureGlyphsForCharacterRange(charRange: NSRange): void;
  ensureGlyphsForGlyphRange(glyphRange: NSRange): void;
  ensureLayoutForCharacterRange(charRange: NSRange): void;
  ensureLayoutForGlyphRange(glyphRange: NSRange): void;
  ensureLayoutForTextContainer(container: NSTextContainer): void;
  ensureLayoutForBoundingRect_inTextContainer(bounds: NSRect, container: NSTextContainer): void;
  setGlyphs_properties_characterIndexes_font_forGlyphRange(glyphs: CGGlyph, props: NSGlyphProperty, charIndexes: NSUInteger, aFont: NSFont, glyphRange: NSRange): void;
  CGGlyphAtIndex_isValidIndex(glyphIndex: NSUInteger, isValidIndex: boolean | null): CGGlyph;
  CGGlyphAtIndex(glyphIndex: NSUInteger): CGGlyph;
  isValidGlyphIndex(glyphIndex: NSUInteger): boolean;
  propertyForGlyphAtIndex(glyphIndex: NSUInteger): NSGlyphProperty;
  characterIndexForGlyphAtIndex(glyphIndex: NSUInteger): NSUInteger;
  glyphIndexForCharacterAtIndex(charIndex: NSUInteger): NSUInteger;
  getGlyphsInRange_glyphs_properties_characterIndexes_bidiLevels(glyphRange: NSRange, glyphBuffer: CGGlyph | null, props: NSGlyphProperty | null, charIndexBuffer: NSUInteger | null, bidiLevelBuffer: string | null): NSUInteger;
  setTextContainer_forGlyphRange(container: NSTextContainer, glyphRange: NSRange): void;
  setLineFragmentRect_forGlyphRange_usedRect(fragmentRect: NSRect, glyphRange: NSRange, usedRect: NSRect): void;
  setExtraLineFragmentRect_usedRect_textContainer(fragmentRect: NSRect, usedRect: NSRect, container: NSTextContainer): void;
  setLocation_forStartOfGlyphRange(location: NSPoint, glyphRange: NSRange): void;
  setNotShownAttribute_forGlyphAtIndex(flag: boolean, glyphIndex: NSUInteger): void;
  setDrawsOutsideLineFragment_forGlyphAtIndex(flag: boolean, glyphIndex: NSUInteger): void;
  setAttachmentSize_forGlyphRange(attachmentSize: NSSize, glyphRange: NSRange): void;
  getFirstUnlaidCharacterIndex_glyphIndex(charIndex: NSUInteger | null, glyphIndex: NSUInteger | null): void;
  firstUnlaidCharacterIndex(): NSUInteger;
  firstUnlaidGlyphIndex(): NSUInteger;
  textContainerForGlyphAtIndex_effectiveRange(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSTextContainer;
  textContainerForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null, flag: boolean): NSTextContainer;
  usedRectForTextContainer(container: NSTextContainer): NSRect;
  lineFragmentRectForGlyphAtIndex_effectiveRange(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  lineFragmentRectForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null, flag: boolean): NSRect;
  lineFragmentUsedRectForGlyphAtIndex_effectiveRange(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  lineFragmentUsedRectForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null, flag: boolean): NSRect;
  locationForGlyphAtIndex(glyphIndex: NSUInteger): NSPoint;
  notShownAttributeForGlyphAtIndex(glyphIndex: NSUInteger): boolean;
  drawsOutsideLineFragmentForGlyphAtIndex(glyphIndex: NSUInteger): boolean;
  attachmentSizeForGlyphAtIndex(glyphIndex: NSUInteger): NSSize;
  truncatedGlyphRangeInLineFragmentForGlyphAtIndex(glyphIndex: NSUInteger): NSRange;
  glyphRangeForCharacterRange_actualCharacterRange(charRange: NSRange, actualCharRange: NSRangePointer | null): NSRange;
  characterRangeForGlyphRange_actualGlyphRange(glyphRange: NSRange, actualGlyphRange: NSRangePointer | null): NSRange;
  glyphRangeForTextContainer(container: NSTextContainer): NSRange;
  rangeOfNominallySpacedGlyphsContainingIndex(glyphIndex: NSUInteger): NSRange;
  boundingRectForGlyphRange_inTextContainer(glyphRange: NSRange, container: NSTextContainer): NSRect;
  glyphRangeForBoundingRect_inTextContainer(bounds: NSRect, container: NSTextContainer): NSRange;
  glyphRangeForBoundingRectWithoutAdditionalLayout_inTextContainer(bounds: NSRect, container: NSTextContainer): NSRange;
  glyphIndexForPoint_inTextContainer_fractionOfDistanceThroughGlyph(point: NSPoint, container: NSTextContainer, partialFraction: CGFloat | null): NSUInteger;
  glyphIndexForPoint_inTextContainer(point: NSPoint, container: NSTextContainer): NSUInteger;
  fractionOfDistanceThroughGlyphForPoint_inTextContainer(point: NSPoint, container: NSTextContainer): CGFloat;
  characterIndexForPoint_inTextContainer_fractionOfDistanceBetweenInsertionPoints(point: NSPoint, container: NSTextContainer, partialFraction: CGFloat | null): NSUInteger;
  getLineFragmentInsertionPointsForCharacterAtIndex_alternatePositions_inDisplayOrder_positions_characterIndexes(charIndex: NSUInteger, aFlag: boolean, dFlag: boolean, positions: CGFloat | null, charIndexes: NSUInteger | null): NSUInteger;
  enumerateLineFragmentsForGlyphRange_usingBlock(glyphRange: NSRange, block: Block): void;
  enumerateEnclosingRectsForGlyphRange_withinSelectedGlyphRange_inTextContainer_usingBlock(glyphRange: NSRange, selectedRange: NSRange, textContainer: NSTextContainer, block: Block): void;
  drawBackgroundForGlyphRange_atPoint(glyphsToShow: NSRange, origin: NSPoint): void;
  drawGlyphsForGlyphRange_atPoint(glyphsToShow: NSRange, origin: NSPoint): void;
  showCGGlyphs_positions_count_font_matrix_attributes_inContext(glyphs: CGGlyph, positions: NSPoint, glyphCount: NSUInteger, font: NSFont, textMatrix: NSAffineTransform, attributes: NSDictionary<any, any> | {[key: string]: any}, graphicsContext: NSGraphicsContext): void;
  fillBackgroundRectArray_count_forCharacterRange_color(rectArray: NSRect, rectCount: NSUInteger, charRange: NSRange, color: NSColor): void;
  drawUnderlineForGlyphRange_underlineType_baselineOffset_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, underlineVal: NSUnderlineStyle, baselineOffset: CGFloat, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  underlineGlyphRange_underlineType_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, underlineVal: NSUnderlineStyle, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  drawStrikethroughForGlyphRange_strikethroughType_baselineOffset_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, strikethroughVal: NSUnderlineStyle, baselineOffset: CGFloat, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  strikethroughGlyphRange_strikethroughType_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(glyphRange: NSRange, strikethroughVal: NSUnderlineStyle, lineRect: NSRect, lineGlyphRange: NSRange, containerOrigin: NSPoint): void;
  showAttachmentCell_inRect_characterIndex(cell: NSCell, rect: NSRect, attachmentIndex: NSUInteger): void;
  setLayoutRect_forTextBlock_glyphRange(rect: NSRect, block: NSTextBlock, glyphRange: NSRange): void;
  setBoundsRect_forTextBlock_glyphRange(rect: NSRect, block: NSTextBlock, glyphRange: NSRange): void;
  layoutRectForTextBlock_glyphRange(block: NSTextBlock, glyphRange: NSRange): NSRect;
  boundsRectForTextBlock_glyphRange(block: NSTextBlock, glyphRange: NSRange): NSRect;
  layoutRectForTextBlock_atIndex_effectiveRange(block: NSTextBlock, glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  boundsRectForTextBlock_atIndex_effectiveRange(block: NSTextBlock, glyphIndex: NSUInteger, effectiveGlyphRange: NSRangePointer | null): NSRect;
  temporaryAttributesAtCharacterIndex_effectiveRange(charIndex: NSUInteger, effectiveCharRange: NSRangePointer | null): NSDictionary<any, any>;
  setTemporaryAttributes_forCharacterRange(attrs: NSDictionary<any, any> | {[key: string]: any}, charRange: NSRange): void;
  addTemporaryAttributes_forCharacterRange(attrs: NSDictionary<any, any> | {[key: string]: any}, charRange: NSRange): void;
  removeTemporaryAttribute_forCharacterRange(attrName: NSAttributedStringKey, charRange: NSRange): void;
  temporaryAttribute_atCharacterIndex_effectiveRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null): any;
  temporaryAttribute_atCharacterIndex_longestEffectiveRange_inRange(attrName: NSAttributedStringKey, location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): any;
  temporaryAttributesAtCharacterIndex_longestEffectiveRange_inRange(location: NSUInteger, range: NSRangePointer | null, rangeLimit: NSRange): NSDictionary<any, any>;
  addTemporaryAttribute_value_forCharacterRange(attrName: NSAttributedStringKey, value: any, charRange: NSRange): void;
  defaultLineHeightForFont(theFont: NSFont): CGFloat;
  defaultBaselineOffsetForFont(theFont: NSFont): CGFloat;
  rulerMarkersForTextView_paragraphStyle_ruler(view: NSTextView, style: NSParagraphStyle, ruler: NSRulerView): NSArray<any>;
  rulerAccessoryViewForTextView_paragraphStyle_ruler_enabled(view: NSTextView, style: NSParagraphStyle, ruler: NSRulerView, isEnabled: boolean): NSView;
  layoutManagerOwnsFirstResponderInWindow(window: NSWindow): boolean;
  glyphAtIndex_isValidIndex(glyphIndex: NSUInteger, isValidIndex: boolean | null): NSGlyph;
  glyphAtIndex(glyphIndex: NSUInteger): NSGlyph;
  rectArrayForCharacterRange_withinSelectedCharacterRange_inTextContainer_rectCount(charRange: NSRange, selCharRange: NSRange, container: NSTextContainer, rectCount: NSUInteger): NSRectArray;
  rectArrayForGlyphRange_withinSelectedGlyphRange_inTextContainer_rectCount(glyphRange: NSRange, selGlyphRange: NSRange, container: NSTextContainer, rectCount: NSUInteger): NSRectArray;
  substituteFontForFont(originalFont: NSFont): NSFont;
  insertGlyphs_length_forStartingGlyphAtIndex_characterIndex(glyphs: NSGlyph, length: NSUInteger, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  insertGlyph_atGlyphIndex_characterIndex(glyph: NSGlyph, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  replaceGlyphAtIndex_withGlyph(glyphIndex: NSUInteger, newGlyph: NSGlyph): void;
  deleteGlyphsInRange(glyphRange: NSRange): void;
  setCharacterIndex_forGlyphAtIndex(charIndex: NSUInteger, glyphIndex: NSUInteger): void;
  setIntAttribute_value_forGlyphAtIndex(attributeTag: NSInteger, val: NSInteger, glyphIndex: NSUInteger): void;
  invalidateGlyphsOnLayoutInvalidationForGlyphRange(glyphRange: NSRange): void;
  intAttribute_forGlyphAtIndex(attributeTag: NSInteger, glyphIndex: NSUInteger): NSInteger;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits(glyphRange: NSRange, glyphBuffer: NSGlyph | null, charIndexBuffer: NSUInteger | null, inscribeBuffer: NSGlyphInscription | null, elasticBuffer: boolean | null): NSUInteger;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits_bidiLevels(glyphRange: NSRange, glyphBuffer: NSGlyph | null, charIndexBuffer: NSUInteger | null, inscribeBuffer: NSGlyphInscription | null, elasticBuffer: boolean | null, bidiLevelBuffer: string | null): NSUInteger;
  getGlyphs_range(glyphArray: NSGlyph | null, glyphRange: NSRange): NSUInteger;
  invalidateLayoutForCharacterRange_isSoft_actualCharacterRange(charRange: NSRange, flag: boolean, actualCharRange: NSRangePointer | null): void;
  textStorage_edited_range_changeInLength_invalidatedRange(str: NSTextStorage, editedMask: NSTextStorageEditedOptions, newCharRange: NSRange, delta: NSInteger, invalidatedCharRange: NSRange): void;
  setLocations_startingGlyphIndexes_count_forGlyphRange(locations: NSPointArray, glyphIndexes: NSUInteger, count: NSUInteger, glyphRange: NSRange): void;
  showPackedGlyphs_length_glyphRange_atPoint_font_color_printingAdjustment(glyphs: string, glyphLen: NSUInteger, glyphRange: NSRange, point: NSPoint, font: NSFont, color: NSColor, printingAdjustment: NSSize): void;
  temporaryAttributesForKey(key: NSString | string): NSDictionary<any, any>;
  setTemporaryAttributes_forKey(attrs: NSDictionary<any, any> | {[key: string]: any}, key: NSString | string): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  textStorage(): NSTextStorage;
  setTextStorage(textStorage: NSTextStorage): void;
  textContainers(): NSArray<any>;
  delegate(): any;
  setDelegate(delegate: any): void;
  showsInvisibleCharacters(): boolean;
  setShowsInvisibleCharacters(showsInvisibleCharacters: boolean): void;
  showsControlCharacters(): boolean;
  setShowsControlCharacters(showsControlCharacters: boolean): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  usesFontLeading(): boolean;
  setUsesFontLeading(usesFontLeading: boolean): void;
  allowsNonContiguousLayout(): boolean;
  setAllowsNonContiguousLayout(allowsNonContiguousLayout: boolean): void;
  hasNonContiguousLayout(): boolean;
  backgroundLayoutEnabled(): boolean;
  setBackgroundLayoutEnabled(backgroundLayoutEnabled: boolean): void;
  defaultAttachmentScaling(): NSImageScaling;
  setDefaultAttachmentScaling(defaultAttachmentScaling: NSImageScaling): void;
  typesetter(): NSTypesetter;
  setTypesetter(typesetter: NSTypesetter): void;
  typesetterBehavior(): NSTypesetterBehavior;
  setTypesetterBehavior(typesetterBehavior: NSTypesetterBehavior): void;
  numberOfGlyphs(): NSUInteger;
  extraLineFragmentRect(): NSRect;
  extraLineFragmentUsedRect(): NSRect;
  extraLineFragmentTextContainer(): NSTextContainer;
  firstTextView(): NSTextView;
  textViewForBeginningOfSelection(): NSTextView;
  usesScreenFonts(): boolean;
  setUsesScreenFonts(usesScreenFonts: boolean): void;
  glyphGenerator(): NSGlyphGenerator;
  setGlyphGenerator(glyphGenerator: NSGlyphGenerator): void;
}

declare interface INSLayoutManagerDelegate {
  layoutManager_shouldGenerateGlyphs_properties_characterIndexes_font_forGlyphRange(layoutManager: NSLayoutManager, glyphs: CGGlyph, props: NSGlyphProperty, charIndexes: NSUInteger, aFont: NSFont, glyphRange: NSRange): NSUInteger;
  layoutManager_lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  layoutManager_paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  layoutManager_paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  layoutManager_shouldUseAction_forControlCharacterAtIndex(layoutManager: NSLayoutManager, action: NSControlCharacterAction, charIndex: NSUInteger): NSControlCharacterAction;
  layoutManager_shouldBreakLineByWordBeforeCharacterAtIndex(layoutManager: NSLayoutManager, charIndex: NSUInteger): boolean;
  layoutManager_shouldBreakLineByHyphenatingBeforeCharacterAtIndex(layoutManager: NSLayoutManager, charIndex: NSUInteger): boolean;
  layoutManager_boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(layoutManager: NSLayoutManager, glyphIndex: NSUInteger, textContainer: NSTextContainer, proposedRect: NSRect, glyphPosition: NSPoint, charIndex: NSUInteger): NSRect;
  layoutManager_shouldSetLineFragmentRect_lineFragmentUsedRect_baselineOffset_inTextContainer_forGlyphRange(layoutManager: NSLayoutManager, lineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, baselineOffset: CGFloat, textContainer: NSTextContainer, glyphRange: NSRange): boolean;
  layoutManagerDidInvalidateLayout(sender: NSLayoutManager): void;
  layoutManager_didCompleteLayoutForTextContainer_atEnd(layoutManager: NSLayoutManager, textContainer: NSTextContainer | null, layoutFinishedFlag: boolean): void;
  layoutManager_textContainer_didChangeGeometryFromSize(layoutManager: NSLayoutManager, textContainer: NSTextContainer, oldSize: NSSize): void;
  layoutManager_shouldUseTemporaryAttributes_forDrawingToScreen_atCharacterIndex_effectiveRange(layoutManager: NSLayoutManager, attrs: NSDictionary<any, any> | {[key: string]: any}, toScreen: boolean, charIndex: NSUInteger, effectiveCharRange: NSRangePointer | null): NSDictionary<any, any>;
}

declare enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal = 0,
  NSTextLayoutOrientationVertical = 1,
}

declare enum NSGlyphProperty {
  NSGlyphPropertyNull,
  NSGlyphPropertyControlCharacter,
  NSGlyphPropertyElastic,
  NSGlyphPropertyNonBaseCharacter,
}

declare enum NSControlCharacterAction {
  NSControlCharacterActionZeroAdvancement,
  NSControlCharacterActionWhitespace,
  NSControlCharacterActionHorizontalTab,
  NSControlCharacterActionLineBreak,
  NSControlCharacterActionParagraphBreak,
  NSControlCharacterActionContainerBreak,
}

declare enum NSTypesetterBehavior {
  NSTypesetterLatestBehavior = -1,
  NSTypesetterOriginalBehavior = 0,
  NSTypesetterBehavior_10_2_WithCompatibility = 1,
  NSTypesetterBehavior_10_2 = 2,
  NSTypesetterBehavior_10_3 = 3,
  NSTypesetterBehavior_10_4 = 4,
}

declare enum NSGlyphInscription {
  NSGlyphInscribeBase = 0,
  NSGlyphInscribeBelow = 1,
  NSGlyphInscribeAbove = 2,
  NSGlyphInscribeOverstrike = 3,
  NSGlyphInscribeOverBelow = 4,
}

class NSLevelIndicatorAllocator<T extends NSLevelIndicator> extends NSControlAllocator<T> {}
declare class NSLevelIndicator extends NSControl {
  alloc<T extends NSLevelIndicator>(): NSLevelIndicatorAllocator<T>;
  tickMarkValueAtIndex(index: NSInteger): number;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;

  levelIndicatorStyle(): NSLevelIndicatorStyle;
  setLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicatorStyle): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  warningValue(): number;
  setWarningValue(warningValue: number): void;
  criticalValue(): number;
  setCriticalValue(criticalValue: number): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  numberOfMajorTickMarks(): NSInteger;
  setNumberOfMajorTickMarks(numberOfMajorTickMarks: NSInteger): void;
  fillColor(): NSColor;
  setFillColor(fillColor: NSColor): void;
  warningFillColor(): NSColor;
  setWarningFillColor(warningFillColor: NSColor): void;
  criticalFillColor(): NSColor;
  setCriticalFillColor(criticalFillColor: NSColor): void;
  drawsTieredCapacityLevels(): boolean;
  setDrawsTieredCapacityLevels(drawsTieredCapacityLevels: boolean): void;
  placeholderVisibility(): NSLevelIndicatorPlaceholderVisibility;
  setPlaceholderVisibility(placeholderVisibility: NSLevelIndicatorPlaceholderVisibility): void;
  ratingImage(): NSImage;
  setRatingImage(ratingImage: NSImage): void;
  ratingPlaceholderImage(): NSImage;
  setRatingPlaceholderImage(ratingPlaceholderImage: NSImage): void;
}

declare enum NSLevelIndicatorPlaceholderVisibility {
  NSLevelIndicatorPlaceholderVisibilityAutomatic = 0,
  NSLevelIndicatorPlaceholderVisibilityAlways = 1,
  NSLevelIndicatorPlaceholderVisibilityWhileEditing = 2,
}

class NSLevelIndicatorCellAllocator<T extends NSLevelIndicatorCell> extends NSActionCellAllocator<T> {
  initWithLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicatorStyle): T;
}
declare class NSLevelIndicatorCell extends NSActionCell {
  alloc<T extends NSLevelIndicatorCell>(): NSLevelIndicatorCellAllocator<T>;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;
  tickMarkValueAtIndex(index: NSInteger): number;

  levelIndicatorStyle(): NSLevelIndicatorStyle;
  setLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicatorStyle): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  warningValue(): number;
  setWarningValue(warningValue: number): void;
  criticalValue(): number;
  setCriticalValue(criticalValue: number): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  numberOfMajorTickMarks(): NSInteger;
  setNumberOfMajorTickMarks(numberOfMajorTickMarks: NSInteger): void;
}

declare enum NSLevelIndicatorStyle {
  NSLevelIndicatorStyleRelevancy,
  NSLevelIndicatorStyleContinuousCapacity,
  NSLevelIndicatorStyleDiscreteCapacity,
  NSLevelIndicatorStyleRating,
}

class NSMagnificationGestureRecognizerAllocator<T extends NSMagnificationGestureRecognizer> extends NSGestureRecognizerAllocator<T> {}
declare class NSMagnificationGestureRecognizer extends NSGestureRecognizer {
  alloc<T extends NSMagnificationGestureRecognizer>(): NSMagnificationGestureRecognizerAllocator<T>;

  magnification(): CGFloat;
  setMagnification(magnification: CGFloat): void;
}

class NSMatrixAllocator<T extends NSMatrix> extends NSControlAllocator<T> {
  initWithFrame_mode_prototype_numberOfRows_numberOfColumns(frameRect: NSRect, mode: NSMatrixMode, cell: NSCell, rowsHigh: NSInteger, colsWide: NSInteger): T;
  initWithFrame_mode_cellClass_numberOfRows_numberOfColumns(frameRect: NSRect, mode: NSMatrixMode, factoryId: any | null, rowsHigh: NSInteger, colsWide: NSInteger): T;
}
declare class NSMatrix extends NSControl implements INSUserInterfaceValidations {
  alloc<T extends NSMatrix>(): NSMatrixAllocator<T>;
  makeCellAtRow_column(row: NSInteger, col: NSInteger): NSCell;
  sendAction_to_forAllCells(selector: string, object: any, flag: boolean): void;
  sortUsingSelector(comparator: string): void;
  setSelectionFrom_to_anchor_highlight(startPos: NSInteger, endPos: NSInteger, anchorPos: NSInteger, lit: boolean): void;
  deselectSelectedCell(): void;
  deselectAllCells(): void;
  selectCellAtRow_column(row: NSInteger, col: NSInteger): void;
  selectAll(sender: any | null): void;
  selectCellWithTag(tag: NSInteger): boolean;
  setScrollable(flag: boolean): void;
  setState_atRow_column(value: NSInteger, row: NSInteger, col: NSInteger): void;
  getNumberOfRows_columns(rowCount: NSInteger | null, colCount: NSInteger | null): void;
  cellAtRow_column(row: NSInteger, col: NSInteger): NSCell;
  cellFrameAtRow_column(row: NSInteger, col: NSInteger): NSRect;
  getRow_column_ofCell(row: NSInteger, col: NSInteger, cell: NSCell): boolean;
  getRow_column_forPoint(row: NSInteger, col: NSInteger, point: NSPoint): boolean;
  renewRows_columns(newRows: NSInteger, newCols: NSInteger): void;
  putCell_atRow_column(newCell: NSCell, row: NSInteger, col: NSInteger): void;
  addRow(): void;
  addRowWithCells(newCells: NSArray<any> | any[]): void;
  insertRow(row: NSInteger): void;
  insertRow_withCells(row: NSInteger, newCells: NSArray<any> | any[] | null): void;
  removeRow(row: NSInteger): void;
  addColumn(): void;
  addColumnWithCells(newCells: NSArray<any> | any[]): void;
  insertColumn(column: NSInteger): void;
  insertColumn_withCells(column: NSInteger, newCells: NSArray<any> | any[] | null): void;
  removeColumn(col: NSInteger): void;
  cellWithTag(tag: NSInteger): NSCell;
  sizeToCells(): void;
  setValidateSize(flag: boolean): void;
  drawCellAtRow_column(row: NSInteger, col: NSInteger): void;
  highlightCell_atRow_column(flag: boolean, row: NSInteger, col: NSInteger): void;
  scrollCellToVisibleAtRow_column(row: NSInteger, col: NSInteger): void;
  mouseDown(event: NSEvent): void;
  performKeyEquivalent(event: NSEvent): boolean;
  sendAction(): boolean;
  sendDoubleAction(): void;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  selectText(sender: any | null): void;
  selectTextAtRow_column(row: NSInteger, col: NSInteger): NSCell;
  acceptsFirstMouse(event: NSEvent | null): boolean;
  resetCursorRects(): void;
  setToolTip_forCell(toolTipString: NSString | string | null, cell: NSCell): void;
  toolTipForCell(cell: NSCell): NSString;
  validateUserInterfaceItem(item: any): boolean;
  validateUserInterfaceItem(item: any): boolean;

  cellClass(): any;
  setCellClass(cellClass: any): void;
  prototype(): NSCell;
  setPrototype(prototype: NSCell): void;
  mode(): NSMatrixMode;
  setMode(mode: NSMatrixMode): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  cells(): NSArray<any>;
  selectedCell(): NSCell;
  selectedCells(): NSArray<any>;
  selectedRow(): NSInteger;
  selectedColumn(): NSInteger;
  selectionByRect(): boolean;
  setSelectionByRect(selectionByRect: boolean): void;
  cellSize(): NSSize;
  setCellSize(cellSize: NSSize): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  cellBackgroundColor(): NSColor;
  setCellBackgroundColor(cellBackgroundColor: NSColor): void;
  drawsCellBackground(): boolean;
  setDrawsCellBackground(drawsCellBackground: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  numberOfRows(): NSInteger;
  numberOfColumns(): NSInteger;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  autosizesCells(): boolean;
  setAutosizesCells(autosizesCells: boolean): void;
  autoscroll(): boolean;
  setAutoscroll(autoscroll: boolean): void;
  mouseDownFlags(): NSInteger;
  delegate(): any;
  setDelegate(delegate: any): void;
  autorecalculatesCellSize(): boolean;
  setAutorecalculatesCellSize(autorecalculatesCellSize: boolean): void;
  tabKeyTraversesCells(): boolean;
  setTabKeyTraversesCells(tabKeyTraversesCells: boolean): void;
  keyCell(): NSCell;
  setKeyCell(keyCell: NSCell): void;
}

declare interface INSMatrixDelegate {
}

declare enum NSMatrixMode {
  NSRadioModeMatrix = 0,
  NSHighlightModeMatrix = 1,
  NSListModeMatrix = 2,
  NSTrackModeMatrix = 3,
}

class NSMediaLibraryBrowserControllerAllocator<T extends NSMediaLibraryBrowserController> extends NSObjectAllocator<T> {}
declare class NSMediaLibraryBrowserController extends NSObject {
  alloc<T extends NSMediaLibraryBrowserController>(): NSMediaLibraryBrowserControllerAllocator<T>;
  togglePanel(sender: any | null): IBAction;

  visible(): boolean;
  setVisible(visible: boolean): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
  mediaLibraries(): NSMediaLibrary;
  setMediaLibraries(mediaLibraries: NSMediaLibrary): void;
  static sharedMediaLibraryBrowserController(): NSMediaLibraryBrowserController;
}

declare enum NSMediaLibrary {
  NSMediaLibraryAudio = 1 << 0,
  NSMediaLibraryImage = 1 << 1,
  NSMediaLibraryMovie = 1 << 2,
}

class NSMenuAllocator<T extends NSMenu> extends NSObjectAllocator<T> {
  initWithTitle(title: NSString | string): T;
  initWithCoder(decoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSMenu extends NSObject implements INSCopying, INSCoding, INSUserInterfaceItemIdentification, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSMenu>(): NSMenuAllocator<T>;
  static popUpContextMenu_withEvent_forView(menu: NSMenu, event: NSEvent, view: NSView): void;
  static popUpContextMenu_withEvent_forView_withFont(menu: NSMenu, event: NSEvent, view: NSView, font: NSFont | null): void;
  popUpMenuPositioningItem_atLocation_inView(item: NSMenuItem | null, location: NSPoint, view: NSView | null): boolean;
  static setMenuBarVisible(visible: boolean): void;
  static menuBarVisible(): boolean;
  insertItem_atIndex(newItem: NSMenuItem, index: NSInteger): void;
  addItem(newItem: NSMenuItem): void;
  insertItemWithTitle_action_keyEquivalent_atIndex(string: NSString | string, selector: string | null, charCode: NSString | string, index: NSInteger): NSMenuItem;
  addItemWithTitle_action_keyEquivalent(string: NSString | string, selector: string | null, charCode: NSString | string): NSMenuItem;
  removeItemAtIndex(index: NSInteger): void;
  removeItem(item: NSMenuItem): void;
  setSubmenu_forItem(menu: NSMenu | null, item: NSMenuItem): void;
  removeAllItems(): void;
  itemAtIndex(index: NSInteger): NSMenuItem;
  indexOfItem(item: NSMenuItem): NSInteger;
  indexOfItemWithTitle(title: NSString | string): NSInteger;
  indexOfItemWithTag(tag: NSInteger): NSInteger;
  indexOfItemWithRepresentedObject(object: any | null): NSInteger;
  indexOfItemWithSubmenu(submenu: NSMenu | null): NSInteger;
  indexOfItemWithTarget_andAction(target: any | null, actionSelector: string | null): NSInteger;
  itemWithTitle(title: NSString | string): NSMenuItem;
  itemWithTag(tag: NSInteger): NSMenuItem;
  update(): void;
  performKeyEquivalent(event: NSEvent): boolean;
  itemChanged(item: NSMenuItem): void;
  performActionForItemAtIndex(index: NSInteger): void;
  cancelTracking(): void;
  cancelTrackingWithoutAnimation(): void;
  submenuAction(sender: any | null): void;
  setMenuRepresentation(menuRep: any): void;
  menuRepresentation(): any;
  setContextMenuRepresentation(menuRep: any): void;
  contextMenuRepresentation(): any;
  setTearOffMenuRepresentation(menuRep: any): void;
  tearOffMenuRepresentation(): any;
  static menuZone(): NSZone;
  static setMenuZone(zone: NSZone): void;
  attachedMenu(): NSMenu;
  isAttached(): boolean;
  sizeToFit(): void;
  locationForSubmenu(submenu: NSMenu): NSPoint;
  helpRequested(eventPtr: NSEvent): void;
  addItemWithTitle_action(title: NSString | string, aSelector: string): NSMenuItem;
  addItemWithTitle_small_target_action(title: NSString | string, smallFont: boolean, action: any, aSelector: string): NSMenuItem;
  addItemWithTitle_target_action(title: NSString | string, aTarget: any, action: string): NSMenuItem;
  addItemWithTitle_target_action_representedObject(title: NSString | string, aTarget: any, action: string, anObject: any): NSMenuItem;
  addItemWithTitle_target_action_submenu(title: NSString | string, aTarget: any, action: string, submenu: NSMenu): NSMenuItem;
  addItemWithTitle_target_action_image(title: NSString | string, target: any, action: string, image: NSImage): NSMenuItem;
  addItemWithTitle_target_action_imageNamed(title: NSString | string, aTarget: any, action: string, image: NSString | string): NSMenuItem;
  addSmallItalicItemWithTitle_target_action(aString: NSString | string, aTarget: any, aSelector: string): NSMenuItem;
  addSmallItemWithTitle_target_action(aString: NSString | string, aTarget: any, aSelector: string): NSMenuItem;
  addItemWithTitle_font_target_action(title: NSString | string, font: NSFont, aTarget: any, aSelector: string): NSMenuItem;
  addItemsFromArray(array: NSArray<any> | any[]): void;
  replaceItemWithAction_withMenuItem_ms(action: string, newItem: NSMenuItem): NSMenuItem;
  replaceMenuItem_withMenuItem_ms(oldItem: NSMenuItem, newItem: NSMenuItem): void;
  showPopUpMenuForEvent_relativeToRect_ofView(event: NSEvent, rect: NSRect, view: NSView): void;
  showPopUpMenuForEvent_relativeToRect_ofView_deferred(event: NSEvent, rect: NSRect, view: NSView, defer: boolean): void;
  static menuWithItems(menuItems: NSArray<any> | any[]): NSMenu;
  parentMenuItem_bc(): NSMenuItem;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  title(): NSString;
  setTitle(title: NSString | string): void;
  supermenu(): NSMenu;
  setSupermenu(supermenu: NSMenu): void;
  itemArray(): NSArray<any>;
  numberOfItems(): NSInteger;
  autoenablesItems(): boolean;
  setAutoenablesItems(autoenablesItems: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  menuBarHeight(): CGFloat;
  highlightedItem(): NSMenuItem;
  minimumWidth(): CGFloat;
  setMinimumWidth(minimumWidth: CGFloat): void;
  size(): NSSize;
  font(): NSFont;
  setFont(font: NSFont): void;
  allowsContextMenuPlugIns(): boolean;
  setAllowsContextMenuPlugIns(allowsContextMenuPlugIns: boolean): void;
  showsStateColumn(): boolean;
  setShowsStateColumn(showsStateColumn: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  propertiesToUpdate(): NSMenuProperties;
  menuChangedMessagesEnabled(): boolean;
  setMenuChangedMessagesEnabled(menuChangedMessagesEnabled: boolean): void;
  tornOff(): boolean;
  isInMainMenu(): boolean;
  isDarkMode_ms(): boolean;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare interface INSMenuDelegate {
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

declare enum NSMenuProperties {
  NSMenuPropertyItemTitle = 1 << 0,
  NSMenuPropertyItemAttributedTitle = 1 << 1,
  NSMenuPropertyItemKeyEquivalent = 1 << 2,
  NSMenuPropertyItemImage = 1 << 3,
  NSMenuPropertyItemEnabled = 1 << 4,
  NSMenuPropertyItemAccessibilityDescription = 1 << 5,
}

class NSMenuItemAllocator<T extends NSMenuItem> extends NSObjectAllocator<T> {
  initWithTitle_action_keyEquivalent(string: NSString | string, selector: string | null, charCode: NSString | string): T;
  initWithCoder(decoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSMenuItem extends NSObject implements INSCopying, INSCoding, INSValidatedUserInterfaceItem, INSUserInterfaceItemIdentification, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSMenuItem>(): NSMenuItemAllocator<T>;
  static separatorItem(): NSMenuItem;
  setMnemonicLocation(location: NSUInteger): void;
  mnemonicLocation(): NSUInteger;
  mnemonic(): NSString;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  static itemWithTitle_action(title: NSString | string, action: string): NSMenuItem;
  static itemWithTitle_target_action(title: NSString | string, aTarget: any, action: string): NSMenuItem;
  static itemWithTitle_small_target_action(title: NSString | string, smallFont: boolean, aTarget: any, action: string): NSMenuItem;
  isInMainMenu(): boolean;
  setSmallFont(): void;
  static menuItemWithTruncatedTitle_target_action(aString: NSString | string, aTarget: any, anAction: string): NSMenuItem;
  generatePreviewWithColorSpace_backingScale_completionHandler(colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  static usesUserKeyEquivalents(): boolean;
  static setUsesUserKeyEquivalents(usesUserKeyEquivalents: boolean): void;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  hasSubmenu(): boolean;
  submenu(): NSMenu;
  setSubmenu(submenu: NSMenu): void;
  parentItem(): NSMenuItem;
  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  separatorItem(): boolean;
  keyEquivalent(): NSString;
  setKeyEquivalent(keyEquivalent: NSString | string): void;
  keyEquivalentModifierMask(): NSEventModifierFlags;
  setKeyEquivalentModifierMask(keyEquivalentModifierMask: NSEventModifierFlags): void;
  userKeyEquivalent(): NSString;
  allowsKeyEquivalentWhenHidden(): boolean;
  setAllowsKeyEquivalentWhenHidden(allowsKeyEquivalentWhenHidden: boolean): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  state(): NSControlStateValue;
  setState(state: NSControlStateValue): void;
  onStateImage(): NSImage;
  setOnStateImage(onStateImage: NSImage): void;
  offStateImage(): NSImage;
  setOffStateImage(offStateImage: NSImage): void;
  mixedStateImage(): NSImage;
  setMixedStateImage(mixedStateImage: NSImage): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  alternate(): boolean;
  setAlternate(alternate: boolean): void;
  indentationLevel(): NSInteger;
  setIndentationLevel(indentationLevel: NSInteger): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  view(): NSView;
  setView(view: NSView): void;
  highlighted(): boolean;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  hiddenOrHasHiddenAncestor(): boolean;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  shareableObjectReferences(): NSArray<any>;
  setShareableObjectReferences(shareableObjectReferences: NSArray<any> | any[]): void;
  symbolMasterReferences(): NSArray<any>;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

class NSMenuItemCellAllocator<T extends NSMenuItemCell> extends NSButtonCellAllocator<T> {}
declare class NSMenuItemCell extends NSButtonCell {
  alloc<T extends NSMenuItemCell>(): NSMenuItemCellAllocator<T>;
  setMenuView(menuView: NSMenuView): void;
  menuView(): NSMenuView;
  calcSize(): void;
  stateImageRectForBounds(cellFrame: NSRect): NSRect;
  titleRectForBounds(cellFrame: NSRect): NSRect;
  keyEquivalentRectForBounds(cellFrame: NSRect): NSRect;
  drawSeparatorItemWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawStateImageWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawImageWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawTitleWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawKeyEquivalentWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  drawBorderAndBackgroundWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;

  menuItem(): NSMenuItem;
  setMenuItem(menuItem: NSMenuItem): void;
  needsSizing(): boolean;
  setNeedsSizing(needsSizing: boolean): void;
  needsDisplay(): boolean;
  setNeedsDisplay(needsDisplay: boolean): void;
  stateImageWidth(): CGFloat;
  imageWidth(): CGFloat;
  titleWidth(): CGFloat;
  keyEquivalentWidth(): CGFloat;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
}

class NSMenuViewAllocator<T extends NSMenuView> extends NSViewAllocator<T> {
  initAsTearOff(): T;
}
declare class NSMenuView extends NSView {
  alloc<T extends NSMenuView>(): NSMenuViewAllocator<T>;
  static menuBarHeight(): CGFloat;
  setMenu(menu: NSMenu): void;
  menu(): NSMenu;
  itemChanged(notification: NSNotification): void;
  itemAdded(notification: NSNotification): void;
  itemRemoved(notification: NSNotification): void;
  update(): void;
  setHorizontal(flag: boolean): void;
  isHorizontal(): boolean;
  setFont(font: NSFont): void;
  font(): NSFont;
  innerRect(): NSRect;
  rectOfItemAtIndex(index: NSInteger): NSRect;
  indexOfItemAtPoint(point: NSPoint): NSInteger;
  setNeedsDisplayForItemAtIndex(index: NSInteger): void;
  setHighlightedItemIndex(index: NSInteger): void;
  highlightedItemIndex(): NSInteger;
  stateImageOffset(): CGFloat;
  stateImageWidth(): CGFloat;
  imageAndTitleOffset(): CGFloat;
  imageAndTitleWidth(): CGFloat;
  keyEquivalentOffset(): CGFloat;
  keyEquivalentWidth(): CGFloat;
  setMenuItemCell_forItemAtIndex(cell: NSMenuItemCell, index: NSInteger): void;
  menuItemCellForItemAtIndex(index: NSInteger): NSMenuItemCell;
  attachedMenuView(): NSMenuView;
  setNeedsSizing(flag: boolean): void;
  needsSizing(): boolean;
  sizeToFit(): void;
  attachedMenu(): NSMenu;
  isAttached(): boolean;
  isTornOff(): boolean;
  locationForSubmenu(submenu: NSMenu): NSPoint;
  setWindowFrameForAttachingToRect_onScreen_preferredEdge_popUpSelectedItem(screenRect: NSRect, screen: NSScreen, edge: NSRectEdge, selectedItemIndex: NSInteger): void;
  detachSubmenu(): void;
  attachSubmenuForItemAtIndex(index: NSInteger): void;
  performActionWithHighlightingForItemAtIndex(index: NSInteger): void;
  trackWithEvent(event: NSEvent): boolean;
  horizontalEdgePadding(): CGFloat;
  setHorizontalEdgePadding(pad: CGFloat): void;
}

class NSMovieAllocator<T extends NSMovie> extends NSObjectAllocator<T> {
  initWithMovie(movie: QTMovie): T;
  initWithURL_byReference(url: NSURL, byRef: boolean): T;
  initWithPasteboard(pasteboard: NSPasteboard): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSMovie extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSMovie>(): NSMovieAllocator<T>;
  QTMovie(): QTMovie;
  URL(): NSURL;
  static movieUnfilteredFileTypes(): NSArray<any>;
  static movieUnfilteredPasteboardTypes(): NSArray<any>;
  static canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
}

class NSMovieViewAllocator<T extends NSMovieView> extends NSViewAllocator<T> {}
declare class NSMovieView extends NSView implements INSUserInterfaceValidations {
  alloc<T extends NSMovieView>(): NSMovieViewAllocator<T>;
  setMovie(movie: NSMovie): void;
  movie(): NSMovie;
  movieController(): void;
  movieRect(): NSRect;
  start(sender: any): void;
  stop(sender: any): void;
  isPlaying(): boolean;
  gotoPosterFrame(sender: any): void;
  gotoBeginning(sender: any): void;
  gotoEnd(sender: any): void;
  stepForward(sender: any): void;
  stepBack(sender: any): void;
  setRate(rate: number): void;
  rate(): number;
  setVolume(volume: number): void;
  volume(): number;
  setMuted(mute: boolean): void;
  isMuted(): boolean;
  setLoopMode(mode: NSQTMovieLoopMode): void;
  loopMode(): NSQTMovieLoopMode;
  setPlaysSelectionOnly(flag: boolean): void;
  playsSelectionOnly(): boolean;
  setPlaysEveryFrame(flag: boolean): void;
  playsEveryFrame(): boolean;
  showController_adjustingSize(show: boolean, adjustSize: boolean): void;
  isControllerVisible(): boolean;
  resizeWithMagnification(magnification: CGFloat): void;
  sizeForMagnification(magnification: CGFloat): NSSize;
  setEditable(editable: boolean): void;
  isEditable(): boolean;
  cut(sender: any): void;
  copy(sender: any): void;
  paste(sender: any): void;
  delete(sender: any): void;
  selectAll(sender: any): void;
  clear(sender: any): void;
  validateUserInterfaceItem(item: any): boolean;
  validateUserInterfaceItem(item: any): boolean;
}

declare type NSQTMovieLoopMode = NSUInteger

class NSNibAllocator<T extends NSNib> extends NSObjectAllocator<T> {
  initWithNibNamed_bundle(nibName: NSNibName, bundle: NSBundle | null): T;
  initWithNibData_bundle(nibData: NSData, bundle: NSBundle | null): T;
  initWithContentsOfURL(nibFileURL: NSURL): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSNib extends NSObject implements INSCoding {
  alloc<T extends NSNib>(): NSNibAllocator<T>;
  instantiateWithOwner_topLevelObjects(owner: any | null, topLevelObjects: NSArray<any> | any[]): boolean;
  instantiateNibWithExternalNameTable(externalNameTable: NSDictionary<any, any> | {[key: string]: any}): boolean;
  instantiateNibWithOwner_topLevelObjects(owner: any, topLevelObjects: NSArray<any> | any[]): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
}

declare type NSNibName = NSString

class NSNibConnectorAllocator<T extends NSNibConnector> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSNibConnector extends NSObject implements INSCoding {
  alloc<T extends NSNibConnector>(): NSNibConnectorAllocator<T>;
  replaceObject_withObject(oldObject: any, newObject: any): void;
  establishConnection(): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  source(): any;
  setSource(source: any): void;
  destination(): any;
  setDestination(destination: any): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
}

class NSNibControlConnectorAllocator<T extends NSNibControlConnector> extends NSNibConnectorAllocator<T> {}
declare class NSNibControlConnector extends NSNibConnector {
  alloc<T extends NSNibControlConnector>(): NSNibControlConnectorAllocator<T>;
  establishConnection(): void;
}

class NSNibOutletConnectorAllocator<T extends NSNibOutletConnector> extends NSNibConnectorAllocator<T> {}
declare class NSNibOutletConnector extends NSNibConnector {
  alloc<T extends NSNibOutletConnector>(): NSNibOutletConnectorAllocator<T>;
  establishConnection(): void;
}

class NSObjectControllerAllocator<T extends NSObjectController> extends NSControllerAllocator<T> {
  initWithContent(content: any | null): T;
}
declare class NSObjectController extends NSController {
  alloc<T extends NSObjectController>(): NSObjectControllerAllocator<T>;
  prepareContent(): void;
  newObject(): any;
  addObject(object: any): void;
  removeObject(object: any): void;
  add(sender: any | null): IBAction;
  remove(sender: any | null): IBAction;
  validateUserInterfaceItem(item: any): boolean;
  fetchWithRequest_merge_error(fetchRequest: NSFetchRequest | null, merge: boolean, error: NSError): boolean;
  fetch(sender: any | null): IBAction;
  defaultFetchRequest(): NSFetchRequest;

  content(): any;
  setContent(content: any): void;
  selection(): any;
  selectedObjects(): NSArray<any>;
  automaticallyPreparesContent(): boolean;
  setAutomaticallyPreparesContent(automaticallyPreparesContent: boolean): void;
  objectClass(): any;
  setObjectClass(objectClass: any): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  canAdd(): boolean;
  canRemove(): boolean;
  managedObjectContext(): NSManagedObjectContext;
  setManagedObjectContext(managedObjectContext: NSManagedObjectContext): void;
  entityName(): NSString;
  setEntityName(entityName: NSString | string): void;
  fetchPredicate(): NSPredicate;
  setFetchPredicate(fetchPredicate: NSPredicate): void;
  usesLazyFetching(): boolean;
  setUsesLazyFetching(usesLazyFetching: boolean): void;
}

class NSOpenGLPixelFormatAllocator<T extends NSOpenGLPixelFormat> extends NSObjectAllocator<T> {
  initWithCGLPixelFormatObj(format: _CGLPixelFormatObject): T;
  initWithAttributes(attribs: NSOpenGLPixelFormatAttribute): T;
  initWithData(attribs: NSData): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSOpenGLPixelFormat extends NSObject implements INSCoding {
  alloc<T extends NSOpenGLPixelFormat>(): NSOpenGLPixelFormatAllocator<T>;
  attributes(): NSData;
  setAttributes(attribs: NSData): void;
  getValues_forAttribute_forVirtualScreen(vals: GLint, attrib: NSOpenGLPixelFormatAttribute, screen: GLint): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  numberOfVirtualScreens(): GLint;
  CGLPixelFormatObj(): _CGLPixelFormatObject;
}

class NSOpenGLPixelBufferAllocator<T extends NSOpenGLPixelBuffer> extends NSObjectAllocator<T> {
  initWithTextureTarget_textureInternalFormat_textureMaxMipMapLevel_pixelsWide_pixelsHigh(target: GLenum, format: GLenum, maxLevel: GLint, pixelsWide: GLsizei, pixelsHigh: GLsizei): T;
  initWithCGLPBufferObj(pbuffer: _CGLPBufferObject): T;
}
declare class NSOpenGLPixelBuffer extends NSObject {
  alloc<T extends NSOpenGLPixelBuffer>(): NSOpenGLPixelBufferAllocator<T>;
  CGLPBufferObj(): _CGLPBufferObject;
  pixelsWide(): GLsizei;
  pixelsHigh(): GLsizei;
  textureTarget(): GLenum;
  textureInternalFormat(): GLenum;
  textureMaxMipMapLevel(): GLint;
}

class NSOpenGLContextAllocator<T extends NSOpenGLContext> extends NSObjectAllocator<T> {
  initWithFormat_shareContext(format: NSOpenGLPixelFormat, share: NSOpenGLContext | null): T;
  initWithCGLContextObj(context: _CGLContextObject): T;
}
declare class NSOpenGLContext extends NSObject implements INSLocking {
  alloc<T extends NSOpenGLContext>(): NSOpenGLContextAllocator<T>;
  setFullScreen(): void;
  setOffScreen_width_height_rowbytes(baseaddr: void, width: GLsizei, height: GLsizei, rowbytes: GLint): void;
  clearDrawable(): void;
  update(): void;
  flushBuffer(): void;
  makeCurrentContext(): void;
  static clearCurrentContext(): void;
  copyAttributesFromContext_withMask(context: NSOpenGLContext, mask: GLbitfield): void;
  setValues_forParameter(vals: GLint, param: NSOpenGLContextParameter): void;
  getValues_forParameter(vals: GLint, param: NSOpenGLContextParameter): void;
  createTexture_fromView_internalFormat(target: GLenum, view: NSView, format: GLenum): void;
  setPixelBuffer_cubeMapFace_mipMapLevel_currentVirtualScreen(pixelBuffer: NSOpenGLPixelBuffer, face: GLenum, level: GLint, screen: GLint): void;
  pixelBuffer(): NSOpenGLPixelBuffer;
  pixelBufferCubeMapFace(): GLenum;
  pixelBufferMipMapLevel(): GLint;
  setTextureImageToPixelBuffer_colorBuffer(pixelBuffer: NSOpenGLPixelBuffer, source: GLenum): void;
  lock(): void;
  unlock(): void;
  lock(): void;
  unlock(): void;

  pixelFormat(): NSOpenGLPixelFormat;
  view(): NSView;
  setView(view: NSView): void;
  static currentContext(): NSOpenGLContext;
  currentVirtualScreen(): GLint;
  setCurrentVirtualScreen(currentVirtualScreen: GLint): void;
  CGLContextObj(): _CGLContextObject;
}

declare type NSOpenGLPixelFormatAttribute = number

declare type NSOpenGLContextAuxiliary = _CGLContextObject

declare enum NSOpenGLGlobalOption {
  NSOpenGLGOFormatCacheSize = 501,
  NSOpenGLGOClearFormatCache = 502,
  NSOpenGLGORetainRenderers = 503,
  NSOpenGLGOUseBuildCache = 506,
  NSOpenGLGOResetLibrary = 504,
}

declare enum NSOpenGLContextParameter {
  NSOpenGLContextParameterSwapInterval = 222,
  NSOpenGLContextParameterSurfaceOrder = 235,
  NSOpenGLContextParameterSurfaceOpacity = 236,
  NSOpenGLContextParameterSurfaceBackingSize = 304,
  NSOpenGLContextParameterReclaimResources = 308,
  NSOpenGLContextParameterCurrentRendererID = 309,
  NSOpenGLContextParameterGPUVertexProcessing = 310,
  NSOpenGLContextParameterGPUFragmentProcessing = 311,
  NSOpenGLContextParameterHasDrawable = 314,
  NSOpenGLContextParameterMPSwapsInFlight = 315,
  NSOpenGLContextParameterSwapRectangle = 200,
  NSOpenGLContextParameterSwapRectangleEnable = 201,
  NSOpenGLContextParameterRasterizationEnable = 221,
  NSOpenGLContextParameterStateValidation = 301,
  NSOpenGLContextParameterSurfaceSurfaceVolatile = 306,
}

class NSOpenGLViewAllocator<T extends NSOpenGLView> extends NSViewAllocator<T> {
  initWithFrame_pixelFormat(frameRect: NSRect, format: NSOpenGLPixelFormat | null): T;
}
declare class NSOpenGLView extends NSView {
  alloc<T extends NSOpenGLView>(): NSOpenGLViewAllocator<T>;
  static defaultPixelFormat(): NSOpenGLPixelFormat;
  clearGLContext(): void;
  update(): void;
  reshape(): void;
  prepareOpenGL(): void;

  openGLContext(): NSOpenGLContext;
  setOpenGLContext(openGLContext: NSOpenGLContext): void;
  pixelFormat(): NSOpenGLPixelFormat;
  setPixelFormat(pixelFormat: NSOpenGLPixelFormat): void;
}

class NSOpenPanelAllocator<T extends NSOpenPanel> extends NSSavePanelAllocator<T> {}
declare class NSOpenPanel extends NSSavePanel {
  alloc<T extends NSOpenPanel>(): NSOpenPanelAllocator<T>;
  static openPanel(): NSOpenPanel;
  filenames(): NSArray<any>;
  beginSheetForDirectory_file_types_modalForWindow_modalDelegate_didEndSelector_contextInfo(path: NSString | string | null, name: NSString | string | null, fileTypes: NSArray<any> | any[] | null, docWindow: NSWindow | null, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  beginForDirectory_file_types_modelessDelegate_didEndSelector_contextInfo(path: NSString | string | null, name: NSString | string | null, fileTypes: NSArray<any> | any[] | null, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalForDirectory_file_types(path: NSString | string | null, name: NSString | string | null, fileTypes: NSArray<any> | any[] | null): NSInteger;
  runModalForTypes(fileTypes: NSArray<any> | any[] | null): NSInteger;

  URLs(): NSArray<any>;
  resolvesAliases(): boolean;
  setResolvesAliases(resolvesAliases: boolean): void;
  canChooseDirectories(): boolean;
  setCanChooseDirectories(canChooseDirectories: boolean): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  canChooseFiles(): boolean;
  setCanChooseFiles(canChooseFiles: boolean): void;
  canResolveUbiquitousConflicts(): boolean;
  setCanResolveUbiquitousConflicts(canResolveUbiquitousConflicts: boolean): void;
  canDownloadUbiquitousContents(): boolean;
  setCanDownloadUbiquitousContents(canDownloadUbiquitousContents: boolean): void;
  accessoryViewDisclosed(): boolean;
  setAccessoryViewDisclosed(accessoryViewDisclosed: boolean): void;
}

class NSOutlineViewAllocator<T extends NSOutlineView> extends NSTableViewAllocator<T> {}
declare class NSOutlineView extends NSTableView implements INSAccessibilityOutline {
  alloc<T extends NSOutlineView>(): NSOutlineViewAllocator<T>;
  isExpandable(item: any | null): boolean;
  numberOfChildrenOfItem(item: any | null): NSInteger;
  child_ofItem(index: NSInteger, item: any | null): any;
  expandItem_expandChildren(item: any | null, expandChildren: boolean): void;
  expandItem(item: any | null): void;
  collapseItem_collapseChildren(item: any | null, collapseChildren: boolean): void;
  collapseItem(item: any | null): void;
  reloadItem_reloadChildren(item: any | null, reloadChildren: boolean): void;
  reloadItem(item: any | null): void;
  parentForItem(item: any | null): any;
  childIndexForItem(item: any): NSInteger;
  itemAtRow(row: NSInteger): any;
  rowForItem(item: any | null): NSInteger;
  levelForItem(item: any | null): NSInteger;
  levelForRow(row: NSInteger): NSInteger;
  isItemExpanded(item: any | null): boolean;
  frameOfOutlineCellAtRow(row: NSInteger): NSRect;
  setDropItem_dropChildIndex(item: any | null, index: NSInteger): void;
  shouldCollapseAutoExpandedItemsForDeposited(deposited: boolean): boolean;
  insertItemsAtIndexes_inParent_withAnimation(indexes: NSIndexSet, parent: any | null, animationOptions: NSTableViewAnimationOptions): void;
  removeItemsAtIndexes_inParent_withAnimation(indexes: NSIndexSet, parent: any | null, animationOptions: NSTableViewAnimationOptions): void;
  moveItemAtIndex_inParent_toIndex_inParent(fromIndex: NSInteger, oldParent: any | null, toIndex: NSInteger, newParent: any | null): void;
  insertRowsAtIndexes_withAnimation_UNAVAILABLE_ATTRIBUTE(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  removeRowsAtIndexes_withAnimation_UNAVAILABLE_ATTRIBUTE(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  moveRowAtIndex_toIndex_UNAVAILABLE_ATTRIBUTE(oldIndex: NSInteger, newIndex: NSInteger): void;
  selectItems_byExtendingSelection(items: NSArray<any> | any[], extend: boolean): void;
  selectItem_byExtendingSelection(item: any, extend: boolean): void;
  selectItem(item: any): void;
  simpleExpandedState(): any;
  setSimpleExpandedState(state: any): void;
  saveSimpleExpandedState(): void;
  restoreSimpleExpandedState(): void;
  expandAllItems(): void;
  collapseAllItems(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  outlineTableColumn(): NSTableColumn;
  setOutlineTableColumn(outlineTableColumn: NSTableColumn): void;
  indentationPerLevel(): CGFloat;
  setIndentationPerLevel(indentationPerLevel: CGFloat): void;
  indentationMarkerFollowsCell(): boolean;
  setIndentationMarkerFollowsCell(indentationMarkerFollowsCell: boolean): void;
  autoresizesOutlineColumn(): boolean;
  setAutoresizesOutlineColumn(autoresizesOutlineColumn: boolean): void;
  autosaveExpandedItems(): boolean;
  setAutosaveExpandedItems(autosaveExpandedItems: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  stronglyReferencesItems(): boolean;
  setStronglyReferencesItems(stronglyReferencesItems: boolean): void;
}

declare interface INSOutlineViewDataSource {
  outlineView_numberOfChildrenOfItem(outlineView: NSOutlineView, item: any | null): NSInteger;
  outlineView_child_ofItem(outlineView: NSOutlineView, index: NSInteger, item: any | null): any;
  outlineView_isItemExpandable(outlineView: NSOutlineView, item: any): boolean;
  outlineView_objectValueForTableColumn_byItem(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any | null): any;
  outlineView_setObjectValue_forTableColumn_byItem(outlineView: NSOutlineView, object: any | null, tableColumn: NSTableColumn | null, item: any | null): void;
  outlineView_itemForPersistentObject(outlineView: NSOutlineView, object: any): any;
  outlineView_persistentObjectForItem(outlineView: NSOutlineView, item: any | null): any;
  outlineView_sortDescriptorsDidChange(outlineView: NSOutlineView, oldDescriptors: NSArray<any> | any[]): void;
  outlineView_pasteboardWriterForItem(outlineView: NSOutlineView, item: any): any;
  outlineView_draggingSession_willBeginAtPoint_forItems(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, draggedItems: NSArray<any> | any[]): void;
  outlineView_draggingSession_endedAtPoint_operation(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  outlineView_writeItems_toPasteboard(outlineView: NSOutlineView, items: NSArray<any> | any[], pasteboard: NSPasteboard): boolean;
  outlineView_updateDraggingItemsForDrag(outlineView: NSOutlineView, draggingInfo: any): void;
  outlineView_validateDrop_proposedItem_proposedChildIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): NSDragOperation;
  outlineView_acceptDrop_item_childIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): boolean;
  outlineView_namesOfPromisedFilesDroppedAtDestination_forDraggedItems(outlineView: NSOutlineView, dropDestination: NSURL, items: NSArray<any> | any[]): NSArray<any>;
}

declare interface INSOutlineViewDelegate {
  outlineView_viewForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSView;
  outlineView_rowViewForItem(outlineView: NSOutlineView, item: any): NSTableRowView;
  outlineView_didAddRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_didRemoveRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_willDisplayCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_shouldEditTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  selectionShouldChangeInOutlineView(outlineView: NSOutlineView): boolean;
  outlineView_shouldSelectItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_selectionIndexesForProposedSelection(outlineView: NSOutlineView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  outlineView_shouldSelectTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn | null): boolean;
  outlineView_mouseDownInHeaderOfTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didClickTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didDragTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_toolTipForCell_rect_tableColumn_item_mouseLocation(outlineView: NSOutlineView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, item: any, mouseLocation: NSPoint): NSString;
  outlineView_heightOfRowByItem(outlineView: NSOutlineView, item: any): CGFloat;
  outlineView_typeSelectStringForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSString;
  outlineView_nextTypeSelectMatchFromItem_toItem_forString(outlineView: NSOutlineView, startItem: any, endItem: any, searchString: NSString | string): any;
  outlineView_shouldTypeSelectForEvent_withCurrentSearchString(outlineView: NSOutlineView, event: NSEvent, searchString: NSString | string | null): boolean;
  outlineView_shouldShowCellExpansionForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_shouldTrackCell_forTableColumn_item(outlineView: NSOutlineView, cell: NSCell, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_dataCellForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSCell;
  outlineView_isGroupItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldExpandItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldCollapseItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_willDisplayOutlineCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_sizeToFitWidthOfColumn(outlineView: NSOutlineView, column: NSInteger): CGFloat;
  outlineView_shouldReorderColumn_toColumn(outlineView: NSOutlineView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  outlineView_shouldShowOutlineCellForItem(outlineView: NSOutlineView, item: any): boolean;
  outlineViewSelectionDidChange(notification: NSNotification): void;
  outlineViewColumnDidMove(notification: NSNotification): void;
  outlineViewColumnDidResize(notification: NSNotification): void;
  outlineViewSelectionIsChanging(notification: NSNotification): void;
  outlineViewItemWillExpand(notification: NSNotification): void;
  outlineViewItemDidExpand(notification: NSNotification): void;
  outlineViewItemWillCollapse(notification: NSNotification): void;
  outlineViewItemDidCollapse(notification: NSNotification): void;
}

class NSPDFImageRepAllocator<T extends NSPDFImageRep> extends NSImageRepAllocator<T> {
  initWithData(pdfData: NSData): T;
}
declare class NSPDFImageRep extends NSImageRep {
  alloc<T extends NSPDFImageRep>(): NSPDFImageRepAllocator<T>;
  static imageRepWithData(pdfData: NSData): NSPDFImageRep;

  PDFRepresentation(): NSData;
  bounds(): NSRect;
  currentPage(): NSInteger;
  setCurrentPage(currentPage: NSInteger): void;
  pageCount(): NSInteger;
}

class NSPDFInfoAllocator<T extends NSPDFInfo> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSPDFInfo extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSPDFInfo>(): NSPDFInfoAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  URL(): NSURL;
  setURL(URL: NSURL): void;
  fileExtensionHidden(): boolean;
  setFileExtensionHidden(fileExtensionHidden: boolean): void;
  tagNames(): NSArray<any>;
  setTagNames(tagNames: NSArray<any> | any[]): void;
  orientation(): NSPaperOrientation;
  setOrientation(orientation: NSPaperOrientation): void;
  paperSize(): NSSize;
  setPaperSize(paperSize: NSSize): void;
  attributes(): NSMutableDictionary<any, any>;
}

class NSPDFPanelAllocator<T extends NSPDFPanel> extends NSObjectAllocator<T> {}
declare class NSPDFPanel extends NSObject {
  alloc<T extends NSPDFPanel>(): NSPDFPanelAllocator<T>;
  static panel(): NSPDFPanel;
  beginSheetWithPDFInfo_modalForWindow_completionHandler(pdfInfo: NSPDFInfo, docWindow: NSWindow | null, completionHandler: Block): void;

  accessoryController(): NSViewController;
  setAccessoryController(accessoryController: NSViewController): void;
  options(): NSPDFPanelOptions;
  setOptions(options: NSPDFPanelOptions): void;
  defaultFileName(): NSString;
  setDefaultFileName(defaultFileName: NSString | string): void;
}

declare enum NSPDFPanelOptions {
  NSPDFPanelShowsPaperSize = 1 << 2,
  NSPDFPanelShowsOrientation = 1 << 3,
  NSPDFPanelRequestsParentDirectory = 1 << 24,
}

class NSPICTImageRepAllocator<T extends NSPICTImageRep> extends NSImageRepAllocator<T> {
  initWithData(pictData: NSData): T;
}
declare class NSPICTImageRep extends NSImageRep {
  alloc<T extends NSPICTImageRep>(): NSPICTImageRepAllocator<T>;
  static imageRepWithData(pictData: NSData): NSPICTImageRep;

  PICTRepresentation(): NSData;
  boundingBox(): NSRect;
}

class NSPageControllerAllocator<T extends NSPageController> extends NSViewControllerAllocator<T> {}
declare class NSPageController extends NSViewController implements INSAnimatablePropertyContainer, INSCoding {
  alloc<T extends NSPageController>(): NSPageControllerAllocator<T>;
  navigateForwardToObject(object: any): void;
  completeTransition(): void;
  navigateBack(sender: any | null): IBAction;
  navigateForward(sender: any | null): IBAction;
  takeSelectedIndexFrom(sender: any | null): IBAction;
  animator(): NSPageController;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  encodeWithCoder(aCoder: NSCoder): void;
  animator(): NSPageController;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  encodeWithCoder(aCoder: NSCoder): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  selectedViewController(): NSViewController;
  transitionStyle(): NSPageControllerTransitionStyle;
  setTransitionStyle(transitionStyle: NSPageControllerTransitionStyle): void;
  arrangedObjects(): NSArray<any>;
  setArrangedObjects(arrangedObjects: NSArray<any> | any[]): void;
  selectedIndex(): NSInteger;
  setSelectedIndex(selectedIndex: NSInteger): void;
  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
}

declare interface INSPageControllerDelegate {
  pageController_identifierForObject(pageController: NSPageController, object: any): NSPageControllerObjectIdentifier;
  pageController_viewControllerForIdentifier(pageController: NSPageController, identifier: NSPageControllerObjectIdentifier): NSViewController;
  pageController_frameForObject(pageController: NSPageController, object: any | null): NSRect;
  pageController_prepareViewController_withObject(pageController: NSPageController, viewController: NSViewController, object: any | null): void;
  pageController_didTransitionToObject(pageController: NSPageController, object: any): void;
  pageControllerWillStartLiveTransition(pageController: NSPageController): void;
  pageControllerDidEndLiveTransition(pageController: NSPageController): void;
}

declare type NSPageControllerObjectIdentifier = NSString

declare enum NSPageControllerTransitionStyle {
  NSPageControllerTransitionStyleStackHistory,
  NSPageControllerTransitionStyleStackBook,
  NSPageControllerTransitionStyleHorizontalStrip,
}

class NSPageLayoutAllocator<T extends NSPageLayout> extends NSObjectAllocator<T> {}
declare class NSPageLayout extends NSObject {
  alloc<T extends NSPageLayout>(): NSPageLayoutAllocator<T>;
  static pageLayout(): NSPageLayout;
  addAccessoryController(accessoryController: NSViewController): void;
  removeAccessoryController(accessoryController: NSViewController): void;
  beginSheetWithPrintInfo_modalForWindow_delegate_didEndSelector_contextInfo(printInfo: NSPrintInfo, docWindow: NSWindow, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalWithPrintInfo(printInfo: NSPrintInfo): NSInteger;
  runModal(): NSInteger;
  setAccessoryView(accessoryView: NSView): void;
  accessoryView(): NSView;
  readPrintInfo(): void;
  writePrintInfo(): void;

  accessoryControllers(): NSArray<any>;
  printInfo(): NSPrintInfo;
}

class NSPanGestureRecognizerAllocator<T extends NSPanGestureRecognizer> extends NSGestureRecognizerAllocator<T> {}
declare class NSPanGestureRecognizer extends NSGestureRecognizer implements INSCoding {
  alloc<T extends NSPanGestureRecognizer>(): NSPanGestureRecognizerAllocator<T>;
  translationInView(view: NSView | null): NSPoint;
  setTranslation_inView(translation: NSPoint, view: NSView | null): void;
  velocityInView(view: NSView | null): NSPoint;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  numberOfTouchesRequired(): NSInteger;
  setNumberOfTouchesRequired(numberOfTouchesRequired: NSInteger): void;
}

class NSPanelAllocator<T extends NSPanel> extends NSWindowAllocator<T> {}
declare class NSPanel extends NSWindow {
  alloc<T extends NSPanel>(): NSPanelAllocator<T>;

  floatingPanel(): boolean;
  setFloatingPanel(floatingPanel: boolean): void;
  becomesKeyOnlyIfNeeded(): boolean;
  setBecomesKeyOnlyIfNeeded(becomesKeyOnlyIfNeeded: boolean): void;
  worksWhenModal(): boolean;
  setWorksWhenModal(worksWhenModal: boolean): void;
}

class NSTextTabAllocator<T extends NSTextTab> extends NSObjectAllocator<T> {
  initWithTextAlignment_location_options(alignment: NSTextAlignment, loc: CGFloat, options: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithType_location(type: NSTextTabType, loc: CGFloat): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTextTab extends NSObject implements INSCopying, INSCoding, INSSecureCoding {
  alloc<T extends NSTextTab>(): NSTextTabAllocator<T>;
  static columnTerminatorsForLocale(aLocale: NSLocale | null): NSCharacterSet;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  alignment(): NSTextAlignment;
  location(): CGFloat;
  options(): NSDictionary<any, any>;
  tabStopType(): NSTextTabType;
  static supportsSecureCoding(): boolean;
}

class NSParagraphStyleAllocator<T extends NSParagraphStyle> extends NSObjectAllocator<T> {}
declare class NSParagraphStyle extends NSObject implements INSCopying, INSMutableCopying, INSSecureCoding {
  alloc<T extends NSParagraphStyle>(): NSParagraphStyleAllocator<T>;
  static defaultWritingDirectionForLanguage(languageName: NSString | string | null): NSWritingDirection;
  addSVGAttributes(attributes: NSMutableArray<any> | any[]): void;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
  mutableCopyWithZone(zone: NSZone | null): any;

  static defaultParagraphStyle(): NSParagraphStyle;
  lineSpacing(): CGFloat;
  paragraphSpacing(): CGFloat;
  alignment(): NSTextAlignment;
  headIndent(): CGFloat;
  tailIndent(): CGFloat;
  firstLineHeadIndent(): CGFloat;
  minimumLineHeight(): CGFloat;
  maximumLineHeight(): CGFloat;
  lineBreakMode(): NSLineBreakMode;
  baseWritingDirection(): NSWritingDirection;
  lineHeightMultiple(): CGFloat;
  paragraphSpacingBefore(): CGFloat;
  hyphenationFactor(): number;
  tabStops(): NSArray<any>;
  defaultTabInterval(): CGFloat;
  allowsDefaultTighteningForTruncation(): boolean;
  tighteningFactorForTruncation(): number;
  textBlocks(): NSArray<any>;
  textLists(): NSArray<any>;
  headerLevel(): NSInteger;
  fixedLineHeight_ms(): CGFloat;
  static supportsSecureCoding(): boolean;
}

class NSMutableParagraphStyleAllocator<T extends NSMutableParagraphStyle> extends NSParagraphStyleAllocator<T> {}
declare class NSMutableParagraphStyle extends NSParagraphStyle {
  alloc<T extends NSMutableParagraphStyle>(): NSMutableParagraphStyleAllocator<T>;
  addTabStop(anObject: NSTextTab): void;
  removeTabStop(anObject: NSTextTab): void;
  setParagraphStyle(obj: NSParagraphStyle): void;
  removeUnsupportedAttributes(): void;

  lineSpacing(): CGFloat;
  setLineSpacing(lineSpacing: CGFloat): void;
  paragraphSpacing(): CGFloat;
  setParagraphSpacing(paragraphSpacing: CGFloat): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  firstLineHeadIndent(): CGFloat;
  setFirstLineHeadIndent(firstLineHeadIndent: CGFloat): void;
  headIndent(): CGFloat;
  setHeadIndent(headIndent: CGFloat): void;
  tailIndent(): CGFloat;
  setTailIndent(tailIndent: CGFloat): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  minimumLineHeight(): CGFloat;
  setMinimumLineHeight(minimumLineHeight: CGFloat): void;
  maximumLineHeight(): CGFloat;
  setMaximumLineHeight(maximumLineHeight: CGFloat): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  lineHeightMultiple(): CGFloat;
  setLineHeightMultiple(lineHeightMultiple: CGFloat): void;
  paragraphSpacingBefore(): CGFloat;
  setParagraphSpacingBefore(paragraphSpacingBefore: CGFloat): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  tabStops(): NSArray<any>;
  setTabStops(tabStops: NSArray<any> | any[]): void;
  defaultTabInterval(): CGFloat;
  setDefaultTabInterval(defaultTabInterval: CGFloat): void;
  allowsDefaultTighteningForTruncation(): boolean;
  setAllowsDefaultTighteningForTruncation(allowsDefaultTighteningForTruncation: boolean): void;
  tighteningFactorForTruncation(): number;
  setTighteningFactorForTruncation(tighteningFactorForTruncation: number): void;
  textBlocks(): NSArray<any>;
  setTextBlocks(textBlocks: NSArray<any> | any[]): void;
  textLists(): NSArray<any>;
  setTextLists(textLists: NSArray<any> | any[]): void;
  headerLevel(): NSInteger;
  setHeaderLevel(headerLevel: NSInteger): void;
  fixedLineHeight_ms(): CGFloat;
  setFixedLineHeight_ms(fixedLineHeight_ms: CGFloat): void;
}

declare type NSTextTabOptionKey = NSString

declare enum NSLineBreakMode {
  NSLineBreakByWordWrapping = 0,
  NSLineBreakByCharWrapping,
  NSLineBreakByClipping,
  NSLineBreakByTruncatingHead,
  NSLineBreakByTruncatingTail,
  NSLineBreakByTruncatingMiddle,
}

declare enum NSTextTabType {
  NSLeftTabStopType = 0,
  NSRightTabStopType,
  NSCenterTabStopType,
  NSDecimalTabStopType,
}

class NSPasteboardAllocator<T extends NSPasteboard> extends NSObjectAllocator<T> {}
declare class NSPasteboard extends NSObject {
  alloc<T extends NSPasteboard>(): NSPasteboardAllocator<T>;
  static pasteboardWithName(name: NSPasteboardName): NSPasteboard;
  static pasteboardWithUniqueName(): NSPasteboard;
  releaseGlobally(): void;
  prepareForNewContentsWithOptions(options: NSPasteboardContentsOptions): NSInteger;
  clearContents(): NSInteger;
  writeObjects(objects: NSArray<any> | any[]): boolean;
  readObjectsForClasses_options(classArray: NSArray<any> | any[], options: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  indexOfPasteboardItem(pasteboardItem: NSPasteboardItem): NSUInteger;
  canReadItemWithDataConformingToTypes(types: NSArray<any> | any[]): boolean;
  canReadObjectForClasses_options(classArray: NSArray<any> | any[], options: NSDictionary<any, any> | {[key: string]: any} | null): boolean;
  declareTypes_owner(newTypes: NSArray<any> | any[], newOwner: any | null): NSInteger;
  addTypes_owner(newTypes: NSArray<any> | any[], newOwner: any | null): NSInteger;
  availableTypeFromArray(types: NSArray<any> | any[]): NSPasteboardType;
  setData_forType(data: NSData | null, dataType: NSPasteboardType): boolean;
  setPropertyList_forType(plist: any, dataType: NSPasteboardType): boolean;
  setString_forType(string: NSString | string, dataType: NSPasteboardType): boolean;
  dataForType(dataType: NSPasteboardType): NSData;
  propertyListForType(dataType: NSPasteboardType): any;
  stringForType(dataType: NSPasteboardType): NSString;
  static typesFilterableTo(type: NSPasteboardType): NSArray<any>;
  static pasteboardByFilteringFile(filename: NSString | string): NSPasteboard;
  static pasteboardByFilteringData_ofType(data: NSData, type: NSPasteboardType): NSPasteboard;
  static pasteboardByFilteringTypesInPasteboard(pboard: NSPasteboard): NSPasteboard;
  writeFileContents(filename: NSString | string): boolean;
  readFileContentsType_toFile(type: NSPasteboardType | null, filename: NSString | string): NSString;
  writeFileWrapper(wrapper: NSFileWrapper): boolean;
  readFileWrapper(): NSFileWrapper;

  static generalPasteboard(): NSPasteboard;
  name(): NSPasteboardName;
  changeCount(): NSInteger;
  pasteboardItems(): NSArray<any>;
  types(): NSArray<any>;
}

declare interface INSPasteboardWriting {
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
}

declare interface INSPasteboardReading {
}

declare type NSPasteboardType = NSString

declare type NSPasteboardName = NSString

declare type NSPasteboardReadingOptionKey = NSString

declare enum NSPasteboardContentsOptions {
  NSPasteboardContentsCurrentHostOnly = 1 << 0,
}

declare enum NSPasteboardWritingOptions {
  NSPasteboardWritingPromised = 1 << 9,
}

declare enum NSPasteboardReadingOptions {
  NSPasteboardReadingAsData = 0,
  NSPasteboardReadingAsString = 1 << 0,
  NSPasteboardReadingAsPropertyList = 1 << 1,
  NSPasteboardReadingAsKeyedArchive = 1 << 2,
}

class NSPasteboardItemAllocator<T extends NSPasteboardItem> extends NSObjectAllocator<T> {
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): T;
}
declare class NSPasteboardItem extends NSObject implements INSPasteboardWriting, INSPasteboardReading {
  alloc<T extends NSPasteboardItem>(): NSPasteboardItemAllocator<T>;
  availableTypeFromArray(types: NSArray<any> | any[]): NSPasteboardType;
  setDataProvider_forTypes(dataProvider: any, types: NSArray<any> | any[]): boolean;
  setData_forType(data: NSData, type: NSPasteboardType): boolean;
  setString_forType(string: NSString | string, type: NSPasteboardType): boolean;
  setPropertyList_forType(propertyList: any, type: NSPasteboardType): boolean;
  dataForType(type: NSPasteboardType): NSData;
  stringForType(type: NSPasteboardType): NSString;
  propertyListForType(type: NSPasteboardType): any;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;

  types(): NSArray<any>;
}

declare interface INSPasteboardItemDataProvider {
  pasteboard_item_provideDataForType(pasteboard: NSPasteboard | null, item: NSPasteboardItem, type: NSPasteboardType): void;
  pasteboardFinishedWithDataProvider(pasteboard: NSPasteboard): void;
}

class NSPathCellAllocator<T extends NSPathCell> extends NSActionCellAllocator<T> {}
declare class NSPathCell extends NSActionCell implements INSOpenSavePanelDelegate {
  alloc<T extends NSPathCell>(): NSPathCellAllocator<T>;
  setObjectValue(obj: any | null): void;
  rectOfPathComponentCell_withFrame_inView(cell: NSPathComponentCell, frame: NSRect, view: NSView): NSRect;
  pathComponentCellAtPoint_withFrame_inView(point: NSPoint, frame: NSRect, view: NSView): NSPathComponentCell;
  mouseEntered_withFrame_inView(event: NSEvent, frame: NSRect, view: NSView): void;
  mouseExited_withFrame_inView(event: NSEvent, frame: NSRect, view: NSView): void;
  panel_shouldEnableURL(sender: any, url: NSURL): boolean;
  panel_validateURL_error(sender: any, url: NSURL, outError: NSError): boolean;
  panel_didChangeToDirectoryURL(sender: any, url: NSURL | null): void;
  panel_userEnteredFilename_confirmed(sender: any, filename: NSString | string, okFlag: boolean): NSString;
  panel_willExpand(sender: any, expanding: boolean): void;
  panelSelectionDidChange(sender: any | null): void;
  panel_shouldEnableURL(sender: any, url: NSURL): boolean;
  panel_validateURL_error(sender: any, url: NSURL, outError: NSError): boolean;
  panel_didChangeToDirectoryURL(sender: any, url: NSURL | null): void;
  panel_userEnteredFilename_confirmed(sender: any, filename: NSString | string, okFlag: boolean): NSString;
  panel_willExpand(sender: any, expanding: boolean): void;
  panelSelectionDidChange(sender: any | null): void;

  pathStyle(): NSPathStyle;
  setPathStyle(pathStyle: NSPathStyle): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
  allowedTypes(): NSArray<any>;
  setAllowedTypes(allowedTypes: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  static pathComponentCellClass(): any;
  pathComponentCells(): NSArray<any>;
  setPathComponentCells(pathComponentCells: NSArray<any> | any[]): void;
  clickedPathComponentCell(): NSPathComponentCell;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
}

declare interface INSPathCellDelegate {
  pathCell_willDisplayOpenPanel(pathCell: NSPathCell, openPanel: NSOpenPanel): void;
  pathCell_willPopUpMenu(pathCell: NSPathCell, menu: NSMenu): void;
}

declare enum NSPathStyle {
  NSPathStyleStandard,
  NSPathStylePopUp = 2,
  NSPathStyleNavigationBar = 1,
}

class NSPathComponentCellAllocator<T extends NSPathComponentCell> extends NSTextFieldCellAllocator<T> {}
declare class NSPathComponentCell extends NSTextFieldCell {
  alloc<T extends NSPathComponentCell>(): NSPathComponentCellAllocator<T>;

  image(): NSImage;
  setImage(image: NSImage): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
}

class NSPathControlAllocator<T extends NSPathControl> extends NSControlAllocator<T> {}
declare class NSPathControl extends NSControl {
  alloc<T extends NSPathControl>(): NSPathControlAllocator<T>;
  setDraggingSourceOperationMask_forLocal(mask: NSDragOperation, isLocal: boolean): void;
  clickedPathComponentCell(): NSPathComponentCell;
  pathComponentCells(): NSArray<any>;
  setPathComponentCells(cells: NSArray<any> | any[]): void;

  editable(): boolean;
  setEditable(editable: boolean): void;
  allowedTypes(): NSArray<any>;
  setAllowedTypes(allowedTypes: NSArray<any> | any[]): void;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  pathStyle(): NSPathStyle;
  setPathStyle(pathStyle: NSPathStyle): void;
  clickedPathItem(): NSPathControlItem;
  pathItems(): NSArray<any>;
  setPathItems(pathItems: NSArray<any> | any[]): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
}

declare interface INSPathControlDelegate {
  pathControl_shouldDragItem_withPasteboard(pathControl: NSPathControl, pathItem: NSPathControlItem, pasteboard: NSPasteboard): boolean;
  pathControl_shouldDragPathComponentCell_withPasteboard(pathControl: NSPathControl, pathComponentCell: NSPathComponentCell, pasteboard: NSPasteboard): boolean;
  pathControl_validateDrop(pathControl: NSPathControl, info: any): NSDragOperation;
  pathControl_acceptDrop(pathControl: NSPathControl, info: any): boolean;
  pathControl_willDisplayOpenPanel(pathControl: NSPathControl, openPanel: NSOpenPanel): void;
  pathControl_willPopUpMenu(pathControl: NSPathControl, menu: NSMenu): void;
}

class NSPathControlItemAllocator<T extends NSPathControlItem> extends NSObjectAllocator<T> {}
declare class NSPathControlItem extends NSObject {
  alloc<T extends NSPathControlItem>(): NSPathControlItemAllocator<T>;

  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  URL(): NSURL;
}

class NSPersistentDocumentAllocator<T extends NSPersistentDocument> extends NSDocumentAllocator<T> {}
declare class NSPersistentDocument extends NSDocument {
  alloc<T extends NSPersistentDocument>(): NSPersistentDocumentAllocator<T>;
  configurePersistentStoreCoordinatorForURL_ofType_modelConfiguration_storeOptions_error(url: NSURL, fileType: NSString | string, configuration: NSString | string | null, storeOptions: NSDictionary<any, any> | {[key: string]: any} | null, error: NSError): boolean;
  persistentStoreTypeForFileType(fileType: NSString | string): NSString;
  writeToURL_ofType_forSaveOperation_originalContentsURL_error(absoluteURL: NSURL, typeName: NSString | string, saveOperation: NSSaveOperationType, absoluteOriginalContentsURL: NSURL | null, error: NSError): boolean;
  readFromURL_ofType_error(absoluteURL: NSURL, typeName: NSString | string, error: NSError): boolean;
  revertToContentsOfURL_ofType_error(inAbsoluteURL: NSURL, inTypeName: NSString | string, outError: NSError): boolean;
  configurePersistentStoreCoordinatorForURL_ofType_error(url: NSURL, fileType: NSString | string, error: NSError): boolean;

  managedObjectContext(): NSManagedObjectContext;
  setManagedObjectContext(managedObjectContext: NSManagedObjectContext): void;
  managedObjectModel(): NSManagedObjectModel;
}

class NSPopUpButtonAllocator<T extends NSPopUpButton> extends NSButtonAllocator<T> {
  initWithFrame_pullsDown(buttonFrame: NSRect, flag: boolean): T;
}
declare class NSPopUpButton extends NSButton {
  alloc<T extends NSPopUpButton>(): NSPopUpButtonAllocator<T>;
  addItemWithTitle(title: NSString | string): void;
  addItemsWithTitles(itemTitles: NSArray<any> | any[]): void;
  insertItemWithTitle_atIndex(title: NSString | string, index: NSInteger): void;
  removeItemWithTitle(title: NSString | string): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  indexOfItem(item: NSMenuItem): NSInteger;
  indexOfItemWithTitle(title: NSString | string): NSInteger;
  indexOfItemWithTag(tag: NSInteger): NSInteger;
  indexOfItemWithRepresentedObject(obj: any | null): NSInteger;
  indexOfItemWithTarget_andAction(target: any | null, actionSelector: string | null): NSInteger;
  itemAtIndex(index: NSInteger): NSMenuItem;
  itemWithTitle(title: NSString | string): NSMenuItem;
  selectItem(item: NSMenuItem | null): void;
  selectItemAtIndex(index: NSInteger): void;
  selectItemWithTitle(title: NSString | string): void;
  selectItemWithTag(tag: NSInteger): boolean;
  setTitle(string: NSString | string): void;
  synchronizeTitleAndSelectedItem(): void;
  itemTitleAtIndex(index: NSInteger): NSString;

  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  pullsDown(): boolean;
  setPullsDown(pullsDown: boolean): void;
  autoenablesItems(): boolean;
  setAutoenablesItems(autoenablesItems: boolean): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
  itemArray(): NSArray<any>;
  numberOfItems(): NSInteger;
  lastItem(): NSMenuItem;
  selectedItem(): NSMenuItem;
  indexOfSelectedItem(): NSInteger;
  selectedTag(): NSInteger;
  itemTitles(): NSArray<any>;
  titleOfSelectedItem(): NSString;
}

class NSPopUpButtonCellAllocator<T extends NSPopUpButtonCell> extends NSMenuItemCellAllocator<T> {
  initTextCell_pullsDown(stringValue: NSString | string, pullDown: boolean): T;
}
declare class NSPopUpButtonCell extends NSMenuItemCell {
  alloc<T extends NSPopUpButtonCell>(): NSPopUpButtonCellAllocator<T>;
  addItemWithTitle(title: NSString | string): void;
  addItemsWithTitles(itemTitles: NSArray<any> | any[]): void;
  insertItemWithTitle_atIndex(title: NSString | string, index: NSInteger): void;
  removeItemWithTitle(title: NSString | string): void;
  removeItemAtIndex(index: NSInteger): void;
  removeAllItems(): void;
  indexOfItem(item: NSMenuItem): NSInteger;
  indexOfItemWithTitle(title: NSString | string): NSInteger;
  indexOfItemWithTag(tag: NSInteger): NSInteger;
  indexOfItemWithRepresentedObject(obj: any | null): NSInteger;
  indexOfItemWithTarget_andAction(target: any | null, actionSelector: string | null): NSInteger;
  itemAtIndex(index: NSInteger): NSMenuItem;
  itemWithTitle(title: NSString | string): NSMenuItem;
  selectItem(item: NSMenuItem | null): void;
  selectItemAtIndex(index: NSInteger): void;
  selectItemWithTitle(title: NSString | string): void;
  selectItemWithTag(tag: NSInteger): boolean;
  setTitle(string: NSString | string | null): void;
  synchronizeTitleAndSelectedItem(): void;
  itemTitleAtIndex(index: NSInteger): NSString;
  attachPopUpWithFrame_inView(cellFrame: NSRect, controlView: NSView): void;
  dismissPopUp(): void;
  performClickWithFrame_inView(frame: NSRect, controlView: NSView): void;

  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  pullsDown(): boolean;
  setPullsDown(pullsDown: boolean): void;
  autoenablesItems(): boolean;
  setAutoenablesItems(autoenablesItems: boolean): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
  usesItemFromMenu(): boolean;
  setUsesItemFromMenu(usesItemFromMenu: boolean): void;
  altersStateOfSelectedItem(): boolean;
  setAltersStateOfSelectedItem(altersStateOfSelectedItem: boolean): void;
  itemArray(): NSArray<any>;
  numberOfItems(): NSInteger;
  lastItem(): NSMenuItem;
  selectedItem(): NSMenuItem;
  indexOfSelectedItem(): NSInteger;
  itemTitles(): NSArray<any>;
  titleOfSelectedItem(): NSString;
  arrowPosition(): NSPopUpArrowPosition;
  setArrowPosition(arrowPosition: NSPopUpArrowPosition): void;
}

declare enum NSPopUpArrowPosition {
  NSPopUpNoArrow = 0,
  NSPopUpArrowAtCenter = 1,
  NSPopUpArrowAtBottom = 2,
}

class NSPopoverAllocator<T extends NSPopover> extends NSResponderAllocator<T> {}
declare class NSPopover extends NSResponder implements INSAppearanceCustomization, INSAccessibilityElement, INSAccessibility {
  alloc<T extends NSPopover>(): NSPopoverAllocator<T>;
  showRelativeToRect_ofView_preferredEdge(positioningRect: NSRect, positioningView: NSView, preferredEdge: NSRectEdge): void;
  performClose(sender: any | null): IBAction;
  close(): void;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;

  delegate(): any;
  setDelegate(delegate: any): void;
  appearance(): NSPopoverAppearance;
  setAppearance(appearance: NSPopoverAppearance): void;
  effectiveAppearance(): NSAppearance;
  behavior(): NSPopoverBehavior;
  setBehavior(behavior: NSPopoverBehavior): void;
  animates(): boolean;
  setAnimates(animates: boolean): void;
  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  contentSize(): NSSize;
  setContentSize(contentSize: NSSize): void;
  shown(): boolean;
  detached(): boolean;
  positioningRect(): NSRect;
  setPositioningRect(positioningRect: NSRect): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

declare interface INSPopoverDelegate {
  popoverShouldClose(popover: NSPopover): boolean;
  popoverShouldDetach(popover: NSPopover): boolean;
  popoverDidDetach(popover: NSPopover): void;
  detachableWindowForPopover(popover: NSPopover): NSWindow;
  popoverWillShow(notification: NSNotification): void;
  popoverDidShow(notification: NSNotification): void;
  popoverWillClose(notification: NSNotification): void;
  popoverDidClose(notification: NSNotification): void;
}

declare type NSPopoverCloseReasonValue = NSString

// @ts-ignore
class NSPopoverAppearanceAllocator<T extends NSPopoverAppearance> extends NSAppearanceAllocator<T> {}
// @ts-ignore
declare class NSPopoverAppearance extends NSAppearance {
  // @ts-ignore
  alloc<T extends NSPopoverAppearance>(): NSPopoverAppearanceAllocator<T>;
}

declare enum NSPopoverBehavior {
  NSPopoverBehaviorApplicationDefined = 0,
  NSPopoverBehaviorTransient = 1,
  NSPopoverBehaviorSemitransient = 2,
}

class NSPopoverTouchBarItemAllocator<T extends NSPopoverTouchBarItem> extends NSTouchBarItemAllocator<T> {}
declare class NSPopoverTouchBarItem extends NSTouchBarItem {
  alloc<T extends NSPopoverTouchBarItem>(): NSPopoverTouchBarItemAllocator<T>;
  showPopover(sender: any | null): void;
  dismissPopover(sender: any | null): void;
  makeStandardActivatePopoverGestureRecognizer(): NSGestureRecognizer;

  popoverTouchBar(): NSTouchBar;
  setPopoverTouchBar(popoverTouchBar: NSTouchBar): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
  collapsedRepresentation(): NSView;
  setCollapsedRepresentation(collapsedRepresentation: NSView): void;
  collapsedRepresentationImage(): NSImage;
  setCollapsedRepresentationImage(collapsedRepresentationImage: NSImage): void;
  collapsedRepresentationLabel(): NSString;
  setCollapsedRepresentationLabel(collapsedRepresentationLabel: NSString | string): void;
  pressAndHoldTouchBar(): NSTouchBar;
  setPressAndHoldTouchBar(pressAndHoldTouchBar: NSTouchBar): void;
  showsCloseButton(): boolean;
  setShowsCloseButton(showsCloseButton: boolean): void;
}

class NSPredicateEditorAllocator<T extends NSPredicateEditor> extends NSRuleEditorAllocator<T> {}
declare class NSPredicateEditor extends NSRuleEditor {
  alloc<T extends NSPredicateEditor>(): NSPredicateEditorAllocator<T>;

  rowTemplates(): NSArray<any>;
  setRowTemplates(rowTemplates: NSArray<any> | any[]): void;
}

class NSPredicateEditorRowTemplateAllocator<T extends NSPredicateEditorRowTemplate> extends NSObjectAllocator<T> {
  initWithLeftExpressions_rightExpressions_modifier_operators_options(leftExpressions: NSArray<any> | any[], rightExpressions: NSArray<any> | any[], modifier: NSComparisonPredicateModifier, operators: NSArray<any> | any[], options: NSUInteger): T;
  initWithLeftExpressions_rightExpressionAttributeType_modifier_operators_options(leftExpressions: NSArray<any> | any[], attributeType: NSAttributeType, modifier: NSComparisonPredicateModifier, operators: NSArray<any> | any[], options: NSUInteger): T;
  initWithCompoundTypes(compoundTypes: NSArray<any> | any[]): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSPredicateEditorRowTemplate extends NSObject implements INSCoding, INSCopying {
  alloc<T extends NSPredicateEditorRowTemplate>(): NSPredicateEditorRowTemplateAllocator<T>;
  matchForPredicate(predicate: NSPredicate): number;
  setPredicate(predicate: NSPredicate): void;
  predicateWithSubpredicates(subpredicates: NSArray<any> | any[] | null): NSPredicate;
  displayableSubpredicatesOfPredicate(predicate: NSPredicate): NSArray<any>;
  static templatesWithAttributeKeyPaths_inEntityDescription(keyPaths: NSArray<any> | any[], entityDescription: NSEntityDescription): NSArray<any>;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;

  templateViews(): NSArray<any>;
  leftExpressions(): NSArray<any>;
  rightExpressions(): NSArray<any>;
  rightExpressionAttributeType(): NSAttributeType;
  modifier(): NSComparisonPredicateModifier;
  operators(): NSArray<any>;
  options(): NSUInteger;
  compoundTypes(): NSArray<any>;
}

class NSPressGestureRecognizerAllocator<T extends NSPressGestureRecognizer> extends NSGestureRecognizerAllocator<T> {}
declare class NSPressGestureRecognizer extends NSGestureRecognizer implements INSCoding {
  alloc<T extends NSPressGestureRecognizer>(): NSPressGestureRecognizerAllocator<T>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  minimumPressDuration(): NSTimeInterval;
  setMinimumPressDuration(minimumPressDuration: NSTimeInterval): void;
  allowableMovement(): CGFloat;
  setAllowableMovement(allowableMovement: CGFloat): void;
  numberOfTouchesRequired(): NSInteger;
  setNumberOfTouchesRequired(numberOfTouchesRequired: NSInteger): void;
}

class NSPressureConfigurationAllocator<T extends NSPressureConfiguration> extends NSObjectAllocator<T> {
  initWithPressureBehavior(pressureBehavior: NSPressureBehavior): T;
}
declare class NSPressureConfiguration extends NSObject {
  alloc<T extends NSPressureConfiguration>(): NSPressureConfigurationAllocator<T>;
  set(): void;

  pressureBehavior(): NSPressureBehavior;
}

class NSPrintInfoAllocator<T extends NSPrintInfo> extends NSObjectAllocator<T> {
  initWithDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithCoder(inDecoder: NSCoder): T;
  init(): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSPrintInfo extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSPrintInfo>(): NSPrintInfoAllocator<T>;
  dictionary(): NSMutableDictionary<any, any>;
  setUpPrintOperationDefaultValues(): void;
  PMPrintSession(): void;
  PMPageFormat(): void;
  PMPrintSettings(): void;
  updateFromPMPageFormat(): void;
  updateFromPMPrintSettings(): void;
  takeSettingsFromPDFInfo(inPDFInfo: NSPDFInfo): void;
  static setDefaultPrinter(printer: NSPrinter | null): void;
  static sizeForPaperName(name: NSPrinterPaperName | null): NSSize;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  static sharedPrintInfo(): NSPrintInfo;
  static setSharedPrintInfo(sharedPrintInfo: NSPrintInfo): void;
  paperName(): NSPrinterPaperName;
  setPaperName(paperName: NSPrinterPaperName): void;
  paperSize(): NSSize;
  setPaperSize(paperSize: NSSize): void;
  orientation(): NSPaperOrientation;
  setOrientation(orientation: NSPaperOrientation): void;
  scalingFactor(): CGFloat;
  setScalingFactor(scalingFactor: CGFloat): void;
  leftMargin(): CGFloat;
  setLeftMargin(leftMargin: CGFloat): void;
  rightMargin(): CGFloat;
  setRightMargin(rightMargin: CGFloat): void;
  topMargin(): CGFloat;
  setTopMargin(topMargin: CGFloat): void;
  bottomMargin(): CGFloat;
  setBottomMargin(bottomMargin: CGFloat): void;
  horizontallyCentered(): boolean;
  setHorizontallyCentered(horizontallyCentered: boolean): void;
  verticallyCentered(): boolean;
  setVerticallyCentered(verticallyCentered: boolean): void;
  horizontalPagination(): NSPrintingPaginationMode;
  setHorizontalPagination(horizontalPagination: NSPrintingPaginationMode): void;
  verticalPagination(): NSPrintingPaginationMode;
  setVerticalPagination(verticalPagination: NSPrintingPaginationMode): void;
  jobDisposition(): NSPrintJobDispositionValue;
  setJobDisposition(jobDisposition: NSPrintJobDispositionValue): void;
  printer(): NSPrinter;
  setPrinter(printer: NSPrinter): void;
  imageablePageBounds(): NSRect;
  localizedPaperName(): NSString;
  static defaultPrinter(): NSPrinter;
  printSettings(): NSMutableDictionary<any, any>;
  selectionOnly(): boolean;
  setSelectionOnly(selectionOnly: boolean): void;
}

declare type NSPrintInfoAttributeKey = NSString

declare type NSPrintJobDispositionValue = NSString

declare type NSPrintInfoSettingKey = NSString

declare enum NSPaperOrientation {
  NSPaperOrientationPortrait = 0,
  NSPaperOrientationLandscape = 1,
}

declare enum NSPrintingPaginationMode {
  NSAutoPagination = 0,
  NSFitPagination = 1,
  NSClipPagination = 2,
}

declare enum NSPrintingOrientation {
  NSPortraitOrientation = 0,
  NSLandscapeOrientation = 1,
}

class NSPrintOperationAllocator<T extends NSPrintOperation> extends NSObjectAllocator<T> {}
declare class NSPrintOperation extends NSObject {
  alloc<T extends NSPrintOperation>(): NSPrintOperationAllocator<T>;
  static printOperationWithView_printInfo(view: NSView, printInfo: NSPrintInfo): NSPrintOperation;
  static PDFOperationWithView_insideRect_toData_printInfo(view: NSView, rect: NSRect, data: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
  static PDFOperationWithView_insideRect_toPath_printInfo(view: NSView, rect: NSRect, path: NSString | string, printInfo: NSPrintInfo): NSPrintOperation;
  static EPSOperationWithView_insideRect_toData_printInfo(view: NSView, rect: NSRect, data: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
  static EPSOperationWithView_insideRect_toPath_printInfo(view: NSView, rect: NSRect, path: NSString | string, printInfo: NSPrintInfo): NSPrintOperation;
  static printOperationWithView(view: NSView): NSPrintOperation;
  static PDFOperationWithView_insideRect_toData(view: NSView, rect: NSRect, data: NSMutableData): NSPrintOperation;
  static EPSOperationWithView_insideRect_toData(view: NSView, rect: NSRect, data: NSMutableData | null): NSPrintOperation;
  runOperationModalForWindow_delegate_didRunSelector_contextInfo(docWindow: NSWindow, delegate: any | null, didRunSelector: string | null, contextInfo: void | null): void;
  runOperation(): boolean;
  createContext(): NSGraphicsContext;
  destroyContext(): void;
  deliverResult(): boolean;
  cleanUpOperation(): void;
  setAccessoryView(view: NSView | null): void;
  accessoryView(): NSView;
  setJobStyleHint(hint: NSString | string | null): void;
  jobStyleHint(): NSString;
  setShowPanels(flag: boolean): void;
  showPanels(): boolean;

  static currentOperation(): NSPrintOperation;
  static setCurrentOperation(currentOperation: NSPrintOperation): void;
  copyingOperation(): boolean;
  preferredRenderingQuality(): NSPrintRenderingQuality;
  jobTitle(): NSString;
  setJobTitle(jobTitle: NSString | string): void;
  showsPrintPanel(): boolean;
  setShowsPrintPanel(showsPrintPanel: boolean): void;
  showsProgressPanel(): boolean;
  setShowsProgressPanel(showsProgressPanel: boolean): void;
  printPanel(): NSPrintPanel;
  setPrintPanel(printPanel: NSPrintPanel): void;
  PDFPanel(): NSPDFPanel;
  setPDFPanel(PDFPanel: NSPDFPanel): void;
  canSpawnSeparateThread(): boolean;
  setCanSpawnSeparateThread(canSpawnSeparateThread: boolean): void;
  pageOrder(): NSPrintingPageOrder;
  setPageOrder(pageOrder: NSPrintingPageOrder): void;
  view(): NSView;
  printInfo(): NSPrintInfo;
  setPrintInfo(printInfo: NSPrintInfo): void;
  context(): NSGraphicsContext;
  pageRange(): NSRange;
  currentPage(): NSInteger;
}

declare enum NSPrintingPageOrder {
  NSDescendingPageOrder = -1,
  NSSpecialPageOrder = 0,
  NSAscendingPageOrder = 1,
  NSUnknownPageOrder = 2,
}

declare enum NSPrintRenderingQuality {
  NSPrintRenderingQualityBest,
  NSPrintRenderingQualityResponsive,
}

class NSPrintPanelAllocator<T extends NSPrintPanel> extends NSObjectAllocator<T> {}
declare class NSPrintPanel extends NSObject {
  alloc<T extends NSPrintPanel>(): NSPrintPanelAllocator<T>;
  static printPanel(): NSPrintPanel;
  addAccessoryController(accessoryController: NSViewController): void;
  removeAccessoryController(accessoryController: NSViewController): void;
  setDefaultButtonTitle(defaultButtonTitle: NSString | string | null): void;
  defaultButtonTitle(): NSString;
  beginSheetWithPrintInfo_modalForWindow_delegate_didEndSelector_contextInfo(printInfo: NSPrintInfo, docWindow: NSWindow, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalWithPrintInfo(printInfo: NSPrintInfo): NSInteger;
  runModal(): NSInteger;
  setAccessoryView(accessoryView: NSView | null): void;
  accessoryView(): NSView;
  updateFromPrintInfo(): void;
  finalWritePrintInfo(): void;

  accessoryControllers(): NSArray<any>;
  options(): NSPrintPanelOptions;
  setOptions(options: NSPrintPanelOptions): void;
  helpAnchor(): NSHelpAnchorName;
  setHelpAnchor(helpAnchor: NSHelpAnchorName): void;
  jobStyleHint(): NSPrintPanelJobStyleHint;
  setJobStyleHint(jobStyleHint: NSPrintPanelJobStyleHint): void;
  printInfo(): NSPrintInfo;
}

declare interface INSPrintPanelAccessorizing {
  localizedSummaryItems(): NSArray<any>;
  keyPathsForValuesAffectingPreview(): NSSet<any>;
}

declare type NSPrintPanelJobStyleHint = NSString

declare type NSPrintPanelAccessorySummaryKey = NSString

declare enum NSPrintPanelOptions {
  NSPrintPanelShowsCopies = 1 << 0,
  NSPrintPanelShowsPageRange = 1 << 1,
  NSPrintPanelShowsPaperSize = 1 << 2,
  NSPrintPanelShowsOrientation = 1 << 3,
  NSPrintPanelShowsScaling = 1 << 4,
  NSPrintPanelShowsPrintSelection = 1 << 5,
  NSPrintPanelShowsPageSetupAccessory = 1 << 8,
  NSPrintPanelShowsPreview = 1 << 17,
}

class NSPrinterAllocator<T extends NSPrinter> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSPrinter extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSPrinter>(): NSPrinterAllocator<T>;
  static printerWithName(name: NSString | string): NSPrinter;
  static printerWithType(type: NSPrinterTypeName): NSPrinter;
  pageSizeForPaper(paperName: NSPrinterPaperName): NSSize;
  statusForTable(tableName: NSString | string): NSPrinterTableStatus;
  isKey_inTable(key: NSString | string | null, table: NSString | string): boolean;
  booleanForKey_inTable(key: NSString | string | null, table: NSString | string): boolean;
  floatForKey_inTable(key: NSString | string | null, table: NSString | string): number;
  intForKey_inTable(key: NSString | string | null, table: NSString | string): number;
  rectForKey_inTable(key: NSString | string | null, table: NSString | string): NSRect;
  sizeForKey_inTable(key: NSString | string | null, table: NSString | string): NSSize;
  stringForKey_inTable(key: NSString | string | null, table: NSString | string): NSString;
  stringListForKey_inTable(key: NSString | string | null, table: NSString | string): NSArray<any>;
  imageRectForPaper(paperName: NSString | string | null): NSRect;
  acceptsBinary(): boolean;
  isColor(): boolean;
  isFontAvailable(faceName: NSString | string | null): boolean;
  isOutputStackInReverseOrder(): boolean;
  static printerWithName_domain_includeUnavailable(name: NSString | string, domain: NSString | string | null, flag: boolean): NSPrinter;
  domain(): NSString;
  host(): NSString;
  note(): NSString;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  static printerNames(): NSArray<any>;
  static printerTypes(): NSArray<any>;
  name(): NSString;
  type(): NSPrinterTypeName;
  languageLevel(): NSInteger;
  deviceDescription(): NSDictionary<any, any>;
}

declare type NSPrinterTypeName = NSString

declare type NSPrinterPaperName = NSString

declare enum NSPrinterTableStatus {
  NSPrinterTableOK = 0,
  NSPrinterTableNotFound = 1,
  NSPrinterTableError = 2,
}

class NSProgressIndicatorAllocator<T extends NSProgressIndicator> extends NSViewAllocator<T> {}
declare class NSProgressIndicator extends NSView implements INSAccessibilityProgressIndicator {
  alloc<T extends NSProgressIndicator>(): NSProgressIndicatorAllocator<T>;
  incrementBy(delta: number): void;
  startAnimation(sender: any | null): void;
  stopAnimation(sender: any | null): void;
  sizeToFit(): void;
  animationDelay(): NSTimeInterval;
  setAnimationDelay(delay: NSTimeInterval): void;
  animate(sender: any | null): void;
  accessibilityValue(): NSNumber;
  accessibilityValue(): NSNumber;

  indeterminate(): boolean;
  setIndeterminate(indeterminate: boolean): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  doubleValue(): number;
  setDoubleValue(doubleValue: number): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  usesThreadedAnimation(): boolean;
  setUsesThreadedAnimation(usesThreadedAnimation: boolean): void;
  style(): NSProgressIndicatorStyle;
  setStyle(style: NSProgressIndicatorStyle): void;
  displayedWhenStopped(): boolean;
  setDisplayedWhenStopped(displayedWhenStopped: boolean): void;
}

declare enum NSProgressIndicatorStyle {
  NSProgressIndicatorStyleBar = 0,
  NSProgressIndicatorStyleSpinning = 1,
}

declare enum NSProgressIndicatorThickness {
  NSProgressIndicatorPreferredThickness = 14,
  NSProgressIndicatorPreferredSmallThickness = 10,
  NSProgressIndicatorPreferredLargeThickness = 18,
  NSProgressIndicatorPreferredAquaThickness = 12,
}

class NSQuickDrawViewAllocator<T extends NSQuickDrawView> extends NSViewAllocator<T> {}
declare class NSQuickDrawView extends NSView {
  alloc<T extends NSQuickDrawView>(): NSQuickDrawViewAllocator<T>;
  qdPort(): void;
}

class NSRotationGestureRecognizerAllocator<T extends NSRotationGestureRecognizer> extends NSGestureRecognizerAllocator<T> {}
declare class NSRotationGestureRecognizer extends NSGestureRecognizer {
  alloc<T extends NSRotationGestureRecognizer>(): NSRotationGestureRecognizerAllocator<T>;

  rotation(): CGFloat;
  setRotation(rotation: CGFloat): void;
  rotationInDegrees(): CGFloat;
  setRotationInDegrees(rotationInDegrees: CGFloat): void;
}

class NSRuleEditorAllocator<T extends NSRuleEditor> extends NSControlAllocator<T> {}
declare class NSRuleEditor extends NSControl {
  alloc<T extends NSRuleEditor>(): NSRuleEditorAllocator<T>;
  reloadCriteria(): void;
  reloadPredicate(): void;
  predicateForRow(row: NSInteger): NSPredicate;
  subrowIndexesForRow(rowIndex: NSInteger): NSIndexSet;
  criteriaForRow(row: NSInteger): NSArray<any>;
  displayValuesForRow(row: NSInteger): NSArray<any>;
  rowForDisplayValue(displayValue: any): NSInteger;
  rowTypeForRow(rowIndex: NSInteger): NSRuleEditorRowType;
  parentRowForRow(rowIndex: NSInteger): NSInteger;
  addRow(sender: any | null): void;
  insertRowAtIndex_withType_asSubrowOfRow_animate(rowIndex: NSInteger, rowType: NSRuleEditorRowType, parentRow: NSInteger, shouldAnimate: boolean): void;
  setCriteria_andDisplayValues_forRowAtIndex(criteria: NSArray<any> | any[], values: NSArray<any> | any[], rowIndex: NSInteger): void;
  removeRowAtIndex(rowIndex: NSInteger): void;
  removeRowsAtIndexes_includeSubrows(rowIndexes: NSIndexSet, includeSubrows: boolean): void;
  selectRowIndexes_byExtendingSelection(indexes: NSIndexSet, extend: boolean): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  formattingStringsFilename(): NSString;
  setFormattingStringsFilename(formattingStringsFilename: NSString | string): void;
  formattingDictionary(): NSDictionary<any, any>;
  setFormattingDictionary(formattingDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  nestingMode(): NSRuleEditorNestingMode;
  setNestingMode(nestingMode: NSRuleEditorNestingMode): void;
  rowHeight(): CGFloat;
  setRowHeight(rowHeight: CGFloat): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  canRemoveAllRows(): boolean;
  setCanRemoveAllRows(canRemoveAllRows: boolean): void;
  predicate(): NSPredicate;
  numberOfRows(): NSInteger;
  selectedRowIndexes(): NSIndexSet;
  rowClass(): any;
  setRowClass(rowClass: any): void;
  rowTypeKeyPath(): NSString;
  setRowTypeKeyPath(rowTypeKeyPath: NSString | string): void;
  subrowsKeyPath(): NSString;
  setSubrowsKeyPath(subrowsKeyPath: NSString | string): void;
  criteriaKeyPath(): NSString;
  setCriteriaKeyPath(criteriaKeyPath: NSString | string): void;
  displayValuesKeyPath(): NSString;
  setDisplayValuesKeyPath(displayValuesKeyPath: NSString | string): void;
}

declare interface INSRuleEditorDelegate {
  ruleEditor_numberOfChildrenForCriterion_withRowType(editor: NSRuleEditor, criterion: any | null, rowType: NSRuleEditorRowType): NSInteger;
  ruleEditor_child_forCriterion_withRowType(editor: NSRuleEditor, index: NSInteger, criterion: any | null, rowType: NSRuleEditorRowType): any;
  ruleEditor_displayValueForCriterion_inRow(editor: NSRuleEditor, criterion: any, row: NSInteger): any;
  ruleEditor_predicatePartsForCriterion_withDisplayValue_inRow(editor: NSRuleEditor, criterion: any, value: any, row: NSInteger): NSDictionary<any, any>;
  ruleEditorRowsDidChange(notification: NSNotification): void;
}

declare type NSRuleEditorPredicatePartKey = NSString

declare enum NSRuleEditorNestingMode {
  NSRuleEditorNestingModeSingle,
  NSRuleEditorNestingModeList,
  NSRuleEditorNestingModeCompound,
  NSRuleEditorNestingModeSimple,
}

declare enum NSRuleEditorRowType {
  NSRuleEditorRowTypeSimple,
  NSRuleEditorRowTypeCompound,
}

class NSRulerMarkerAllocator<T extends NSRulerMarker> extends NSObjectAllocator<T> {
  initWithRulerView_markerLocation_image_imageOrigin(ruler: NSRulerView, location: CGFloat, image: NSImage, imageOrigin: NSPoint): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSRulerMarker extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSRulerMarker>(): NSRulerMarkerAllocator<T>;
  drawRect(rect: NSRect): void;
  trackMouse_adding(mouseDownEvent: NSEvent, isAdding: boolean): boolean;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  ruler(): NSRulerView;
  markerLocation(): CGFloat;
  setMarkerLocation(markerLocation: CGFloat): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  imageOrigin(): NSPoint;
  setImageOrigin(imageOrigin: NSPoint): void;
  movable(): boolean;
  setMovable(movable: boolean): void;
  removable(): boolean;
  setRemovable(removable: boolean): void;
  dragging(): boolean;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  imageRectInRuler(): NSRect;
  thicknessRequiredInRuler(): CGFloat;
}

class NSRulerViewAllocator<T extends NSRulerView> extends NSViewAllocator<T> {
  initWithScrollView_orientation(scrollView: NSScrollView | null, orientation: NSRulerOrientation): T;
}
declare class NSRulerView extends NSView {
  alloc<T extends NSRulerView>(): NSRulerViewAllocator<T>;
  static registerUnitWithName_abbreviation_unitToPointsConversionFactor_stepUpCycle_stepDownCycle(unitName: NSRulerViewUnitName, abbreviation: NSString | string, conversionFactor: CGFloat, stepUpCycle: NSArray<any> | any[], stepDownCycle: NSArray<any> | any[]): void;
  addMarker(marker: NSRulerMarker): void;
  removeMarker(marker: NSRulerMarker): void;
  trackMarker_withMouseEvent(marker: NSRulerMarker, event: NSEvent): boolean;
  moveRulerlineFromLocation_toLocation(oldLocation: CGFloat, newLocation: CGFloat): void;
  invalidateHashMarks(): void;
  drawHashMarksAndLabelsInRect(rect: NSRect): void;
  drawMarkersInRect(rect: NSRect): void;

  scrollView(): NSScrollView;
  setScrollView(scrollView: NSScrollView): void;
  orientation(): NSRulerOrientation;
  setOrientation(orientation: NSRulerOrientation): void;
  baselineLocation(): CGFloat;
  requiredThickness(): CGFloat;
  ruleThickness(): CGFloat;
  setRuleThickness(ruleThickness: CGFloat): void;
  reservedThicknessForMarkers(): CGFloat;
  setReservedThicknessForMarkers(reservedThicknessForMarkers: CGFloat): void;
  reservedThicknessForAccessoryView(): CGFloat;
  setReservedThicknessForAccessoryView(reservedThicknessForAccessoryView: CGFloat): void;
  measurementUnits(): NSRulerViewUnitName;
  setMeasurementUnits(measurementUnits: NSRulerViewUnitName): void;
  originOffset(): CGFloat;
  setOriginOffset(originOffset: CGFloat): void;
  clientView(): NSView;
  setClientView(clientView: NSView): void;
  markers(): NSArray<any>;
  setMarkers(markers: NSArray<any> | any[]): void;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  flipped(): boolean;
}

declare type NSRulerViewUnitName = NSString

declare enum NSRulerOrientation {
  NSHorizontalRuler,
  NSVerticalRuler,
}

class NSRunningApplicationAllocator<T extends NSRunningApplication> extends NSObjectAllocator<T> {}
declare class NSRunningApplication extends NSObject {
  alloc<T extends NSRunningApplication>(): NSRunningApplicationAllocator<T>;
  hide(): boolean;
  unhide(): boolean;
  activateWithOptions(options: NSApplicationActivationOptions): boolean;
  terminate(): boolean;
  forceTerminate(): boolean;
  static runningApplicationsWithBundleIdentifier(bundleIdentifier: NSString | string): NSArray<any>;
  static runningApplicationWithProcessIdentifier(pid: pid_t): NSRunningApplication;
  static terminateAutomaticallyTerminableApplications(): void;

  terminated(): boolean;
  finishedLaunching(): boolean;
  hidden(): boolean;
  active(): boolean;
  ownsMenuBar(): boolean;
  activationPolicy(): NSApplicationActivationPolicy;
  localizedName(): NSString;
  bundleIdentifier(): NSString;
  bundleURL(): NSURL;
  executableURL(): NSURL;
  processIdentifier(): pid_t;
  launchDate(): NSDate;
  icon(): NSImage;
  executableArchitecture(): NSInteger;
  static currentApplication(): NSRunningApplication;
}

declare enum NSApplicationActivationOptions {
  NSApplicationActivateAllWindows = 1 << 0,
  NSApplicationActivateIgnoringOtherApps = 1 << 1,
}

declare enum NSApplicationActivationPolicy {
  NSApplicationActivationPolicyRegular,
  NSApplicationActivationPolicyAccessory,
  NSApplicationActivationPolicyProhibited,
}

class NSSavePanelAllocator<T extends NSSavePanel> extends NSPanelAllocator<T> {}
declare class NSSavePanel extends NSPanel {
  alloc<T extends NSSavePanel>(): NSSavePanelAllocator<T>;
  static savePanel(): NSSavePanel;
  validateVisibleColumns(): void;
  ok(sender: any | null): IBAction;
  cancel(sender: any | null): IBAction;
  beginSheetModalForWindow_completionHandler(window: NSWindow, handler: Block): void;
  beginWithCompletionHandler(handler: Block): void;
  runModal(): NSModalResponse;
  filename(): NSString;
  directory(): NSString;
  setDirectory(path: NSString | string | null): void;
  requiredFileType(): NSString;
  setRequiredFileType(type: NSString | string | null): void;
  beginSheetForDirectory_file_modalForWindow_modalDelegate_didEndSelector_contextInfo(path: NSString | string, name: NSString | string | null, docWindow: NSWindow | null, delegate: any | null, didEndSelector: string | null, contextInfo: void | null): void;
  runModalForDirectory_file(path: NSString | string | null, name: NSString | string | null): NSInteger;
  selectText(sender: any | null): IBAction;

  URL(): NSURL;
  directoryURL(): NSURL;
  setDirectoryURL(directoryURL: NSURL): void;
  allowedFileTypes(): NSArray<any>;
  setAllowedFileTypes(allowedFileTypes: NSArray<any> | any[]): void;
  allowsOtherFileTypes(): boolean;
  setAllowsOtherFileTypes(allowsOtherFileTypes: boolean): void;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  expanded(): boolean;
  canCreateDirectories(): boolean;
  setCanCreateDirectories(canCreateDirectories: boolean): void;
  canSelectHiddenExtension(): boolean;
  setCanSelectHiddenExtension(canSelectHiddenExtension: boolean): void;
  extensionHidden(): boolean;
  setExtensionHidden(extensionHidden: boolean): void;
  treatsFilePackagesAsDirectories(): boolean;
  setTreatsFilePackagesAsDirectories(treatsFilePackagesAsDirectories: boolean): void;
  prompt(): NSString;
  setPrompt(prompt: NSString | string): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  nameFieldLabel(): NSString;
  setNameFieldLabel(nameFieldLabel: NSString | string): void;
  nameFieldStringValue(): NSString;
  setNameFieldStringValue(nameFieldStringValue: NSString | string): void;
  message(): NSString;
  setMessage(message: NSString | string): void;
  showsHiddenFiles(): boolean;
  setShowsHiddenFiles(showsHiddenFiles: boolean): void;
  showsTagField(): boolean;
  setShowsTagField(showsTagField: boolean): void;
  tagNames(): NSArray<any>;
  setTagNames(tagNames: NSArray<any> | any[]): void;
}

declare interface INSOpenSavePanelDelegate {
  panel_shouldEnableURL(sender: any, url: NSURL): boolean;
  panel_validateURL_error(sender: any, url: NSURL, outError: NSError): boolean;
  panel_didChangeToDirectoryURL(sender: any, url: NSURL | null): void;
  panel_userEnteredFilename_confirmed(sender: any, filename: NSString | string, okFlag: boolean): NSString;
  panel_willExpand(sender: any, expanding: boolean): void;
  panelSelectionDidChange(sender: any | null): void;
}

class NSScreenAllocator<T extends NSScreen> extends NSObjectAllocator<T> {}
declare class NSScreen extends NSObject {
  alloc<T extends NSScreen>(): NSScreenAllocator<T>;
  canRepresentDisplayGamut(displayGamut: NSDisplayGamut): boolean;
  convertRectToBacking(rect: NSRect): NSRect;
  convertRectFromBacking(rect: NSRect): NSRect;
  backingAlignedRect_options(rect: NSRect, options: NSAlignmentOptions): NSRect;
  userSpaceScaleFactor(): CGFloat;
  isOnRetinaScreen(): boolean;

  static screens(): NSArray<any>;
  static mainScreen(): NSScreen;
  static deepestScreen(): NSScreen;
  static screensHaveSeparateSpaces(): boolean;
  depth(): NSWindowDepth;
  frame(): NSRect;
  visibleFrame(): NSRect;
  deviceDescription(): NSDictionary<any, any>;
  colorSpace(): NSColorSpace;
  supportedWindowDepths(): NSWindowDepth;
  backingScaleFactor(): CGFloat;
  maximumExtendedDynamicRangeColorComponentValue(): CGFloat;
  static highestBackingScale_bc(): CGFloat;
}

class NSScrollViewAllocator<T extends NSScrollView> extends NSViewAllocator<T> {}
declare class NSScrollView extends NSView implements INSTextFinderBarContainer {
  alloc<T extends NSScrollView>(): NSScrollViewAllocator<T>;
  static frameSizeForContentSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(cSize: NSSize, horizontalScrollerClass: any | null, verticalScrollerClass: any | null, type: NSBorderType, controlSize: NSControlSize, scrollerStyle: NSScrollerStyle): NSSize;
  static contentSizeForFrameSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(fSize: NSSize, horizontalScrollerClass: any | null, verticalScrollerClass: any | null, type: NSBorderType, controlSize: NSControlSize, scrollerStyle: NSScrollerStyle): NSSize;
  static frameSizeForContentSize_hasHorizontalScroller_hasVerticalScroller_borderType(cSize: NSSize, hFlag: boolean, vFlag: boolean, type: NSBorderType): NSSize;
  static contentSizeForFrameSize_hasHorizontalScroller_hasVerticalScroller_borderType(fSize: NSSize, hFlag: boolean, vFlag: boolean, type: NSBorderType): NSSize;
  tile(): void;
  reflectScrolledClipView(cView: NSClipView): void;
  scrollWheel(event: NSEvent): void;
  flashScrollers(): void;
  magnifyToFitRect(rect: NSRect): void;
  setMagnification_centeredAtPoint(magnification: CGFloat, point: NSPoint): void;
  addFloatingSubview_forAxis(view: NSView, axis: NSEventGestureAxis): void;
  findBarViewDidChangeHeight(): void;
  contentView(): NSView;
  findBarViewDidChangeHeight(): void;
  contentView(): NSView;

  documentVisibleRect(): NSRect;
  contentSize(): NSSize;
  documentView(): NSView;
  setDocumentView(documentView: NSView): void;
  contentView(): NSClipView;
  setContentView(contentView: NSClipView): void;
  documentCursor(): NSCursor;
  setDocumentCursor(documentCursor: NSCursor): void;
  borderType(): NSBorderType;
  setBorderType(borderType: NSBorderType): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  hasVerticalScroller(): boolean;
  setHasVerticalScroller(hasVerticalScroller: boolean): void;
  hasHorizontalScroller(): boolean;
  setHasHorizontalScroller(hasHorizontalScroller: boolean): void;
  verticalScroller(): NSScroller;
  setVerticalScroller(verticalScroller: NSScroller): void;
  horizontalScroller(): NSScroller;
  setHorizontalScroller(horizontalScroller: NSScroller): void;
  autohidesScrollers(): boolean;
  setAutohidesScrollers(autohidesScrollers: boolean): void;
  horizontalLineScroll(): CGFloat;
  setHorizontalLineScroll(horizontalLineScroll: CGFloat): void;
  verticalLineScroll(): CGFloat;
  setVerticalLineScroll(verticalLineScroll: CGFloat): void;
  lineScroll(): CGFloat;
  setLineScroll(lineScroll: CGFloat): void;
  horizontalPageScroll(): CGFloat;
  setHorizontalPageScroll(horizontalPageScroll: CGFloat): void;
  verticalPageScroll(): CGFloat;
  setVerticalPageScroll(verticalPageScroll: CGFloat): void;
  pageScroll(): CGFloat;
  setPageScroll(pageScroll: CGFloat): void;
  scrollsDynamically(): boolean;
  setScrollsDynamically(scrollsDynamically: boolean): void;
  scrollerStyle(): NSScrollerStyle;
  setScrollerStyle(scrollerStyle: NSScrollerStyle): void;
  scrollerKnobStyle(): NSScrollerKnobStyle;
  setScrollerKnobStyle(scrollerKnobStyle: NSScrollerKnobStyle): void;
  horizontalScrollElasticity(): NSScrollElasticity;
  setHorizontalScrollElasticity(horizontalScrollElasticity: NSScrollElasticity): void;
  verticalScrollElasticity(): NSScrollElasticity;
  setVerticalScrollElasticity(verticalScrollElasticity: NSScrollElasticity): void;
  usesPredominantAxisScrolling(): boolean;
  setUsesPredominantAxisScrolling(usesPredominantAxisScrolling: boolean): void;
  allowsMagnification(): boolean;
  setAllowsMagnification(allowsMagnification: boolean): void;
  magnification(): CGFloat;
  setMagnification(magnification: CGFloat): void;
  maxMagnification(): CGFloat;
  setMaxMagnification(maxMagnification: CGFloat): void;
  minMagnification(): CGFloat;
  setMinMagnification(minMagnification: CGFloat): void;
  automaticallyAdjustsContentInsets(): boolean;
  setAutomaticallyAdjustsContentInsets(automaticallyAdjustsContentInsets: boolean): void;
  contentInsets(): NSEdgeInsets;
  setContentInsets(contentInsets: NSEdgeInsets): void;
  scrollerInsets(): NSEdgeInsets;
  setScrollerInsets(scrollerInsets: NSEdgeInsets): void;
  static rulerViewClass(): any;
  static setRulerViewClass(rulerViewClass: any): void;
  rulersVisible(): boolean;
  setRulersVisible(rulersVisible: boolean): void;
  hasHorizontalRuler(): boolean;
  setHasHorizontalRuler(hasHorizontalRuler: boolean): void;
  hasVerticalRuler(): boolean;
  setHasVerticalRuler(hasVerticalRuler: boolean): void;
  horizontalRulerView(): NSRulerView;
  setHorizontalRulerView(horizontalRulerView: NSRulerView): void;
  verticalRulerView(): NSRulerView;
  setVerticalRulerView(verticalRulerView: NSRulerView): void;
  findBarPosition(): NSScrollViewFindBarPosition;
  setFindBarPosition(findBarPosition: NSScrollViewFindBarPosition): void;
  findBarView(): NSView;
  setFindBarView(findBarView: NSView): void;
  findBarVisible(): boolean;
  setFindBarVisible(findBarVisible: boolean): void;
}

declare enum NSScrollElasticity {
  NSScrollElasticityAutomatic = 0,
  NSScrollElasticityNone = 1,
  NSScrollElasticityAllowed = 2,
}

declare enum NSScrollViewFindBarPosition {
  NSScrollViewFindBarPositionAboveHorizontalRuler = 0,
  NSScrollViewFindBarPositionAboveContent = 1,
  NSScrollViewFindBarPositionBelowContent = 2,
}

class NSScrollerAllocator<T extends NSScroller> extends NSControlAllocator<T> {}
declare class NSScroller extends NSControl {
  alloc<T extends NSScroller>(): NSScrollerAllocator<T>;
  static scrollerWidthForControlSize_scrollerStyle(controlSize: NSControlSize, scrollerStyle: NSScrollerStyle): CGFloat;
  static scrollerWidthForControlSize(controlSize: NSControlSize): CGFloat;
  static scrollerWidth(): CGFloat;
  drawParts(): void;
  rectForPart(partCode: NSScrollerPart): NSRect;
  checkSpaceForParts(): void;
  drawArrow_highlight(whichArrow: NSScrollerArrow, flag: boolean): void;
  drawKnob(): void;
  drawKnobSlotInRect_highlight(slotRect: NSRect, flag: boolean): void;
  highlight(flag: boolean): void;
  testPart(point: NSPoint): NSScrollerPart;
  trackKnob(event: NSEvent): void;
  trackScrollButtons(event: NSEvent): void;
  setKnobProportion(proportion: CGFloat): void;
  setFloatValue_knobProportion(value: number, proportion: CGFloat): void;

  static compatibleWithOverlayScrollers(): boolean;
  static preferredScrollerStyle(): NSScrollerStyle;
  scrollerStyle(): NSScrollerStyle;
  setScrollerStyle(scrollerStyle: NSScrollerStyle): void;
  knobStyle(): NSScrollerKnobStyle;
  setKnobStyle(knobStyle: NSScrollerKnobStyle): void;
  usableParts(): NSUsableScrollerParts;
  arrowsPosition(): NSScrollArrowPosition;
  setArrowsPosition(arrowsPosition: NSScrollArrowPosition): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  hitPart(): NSScrollerPart;
  knobProportion(): CGFloat;
  setKnobProportion(knobProportion: CGFloat): void;
}

declare enum NSScrollArrowPosition {
  NSScrollerArrowsMaxEnd = 0,
  NSScrollerArrowsMinEnd = 1,
  NSScrollerArrowsDefaultSetting = 0,
  NSScrollerArrowsNone = 2,
}

declare enum NSUsableScrollerParts {
  NSNoScrollerParts = 0,
  NSOnlyScrollerArrows = 1,
  NSAllScrollerParts = 2,
}

declare enum NSScrollerPart {
  NSScrollerNoPart = 0,
  NSScrollerDecrementPage = 1,
  NSScrollerKnob = 2,
  NSScrollerIncrementPage = 3,
  NSScrollerDecrementLine = 4,
  NSScrollerIncrementLine = 5,
  NSScrollerKnobSlot = 6,
}

declare enum NSScrollerArrow {
  NSScrollerIncrementArrow = 0,
  NSScrollerDecrementArrow = 1,
}

declare enum NSScrollerStyle {
  NSScrollerStyleLegacy = 0,
  NSScrollerStyleOverlay = 1,
}

declare enum NSScrollerKnobStyle {
  NSScrollerKnobStyleDefault = 0,
  NSScrollerKnobStyleDark = 1,
  NSScrollerKnobStyleLight = 2,
}

class NSScrubberSelectionStyleAllocator<T extends NSScrubberSelectionStyle> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSScrubberSelectionStyle extends NSObject implements INSCoding {
  alloc<T extends NSScrubberSelectionStyle>(): NSScrubberSelectionStyleAllocator<T>;
  makeSelectionView(): NSScrubberSelectionView;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  static outlineOverlayStyle(): NSScrubberSelectionStyle;
  static roundedBackgroundStyle(): NSScrubberSelectionStyle;
}

class NSScrubberAllocator<T extends NSScrubber> extends NSViewAllocator<T> {}
declare class NSScrubber extends NSView {
  alloc<T extends NSScrubber>(): NSScrubberAllocator<T>;
  reloadData(): void;
  performSequentialBatchUpdates(updateBlock: Block): void;
  insertItemsAtIndexes(indexes: NSIndexSet): void;
  removeItemsAtIndexes(indexes: NSIndexSet): void;
  reloadItemsAtIndexes(indexes: NSIndexSet): void;
  moveItemAtIndex_toIndex(oldIndex: NSInteger, newIndex: NSInteger): void;
  scrollItemAtIndex_toAlignment(index: NSInteger, alignment: NSScrubberAlignment): void;
  itemViewForItemAtIndex(index: NSInteger): NSScrubberItemView;
  registerClass_forItemIdentifier(itemViewClass: any | null, itemIdentifier: NSUserInterfaceItemIdentifier): void;
  registerNib_forItemIdentifier(nib: NSNib | null, itemIdentifier: NSUserInterfaceItemIdentifier): void;
  makeItemWithIdentifier_owner(itemIdentifier: NSUserInterfaceItemIdentifier, owner: any | null): NSScrubberItemView;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  scrubberLayout(): NSScrubberLayout;
  setScrubberLayout(scrubberLayout: NSScrubberLayout): void;
  numberOfItems(): NSInteger;
  highlightedIndex(): NSInteger;
  selectedIndex(): NSInteger;
  setSelectedIndex(selectedIndex: NSInteger): void;
  mode(): NSScrubberMode;
  setMode(mode: NSScrubberMode): void;
  itemAlignment(): NSScrubberAlignment;
  setItemAlignment(itemAlignment: NSScrubberAlignment): void;
  continuous(): boolean;
  setContinuous(continuous: boolean): void;
  floatsSelectionViews(): boolean;
  setFloatsSelectionViews(floatsSelectionViews: boolean): void;
  selectionBackgroundStyle(): NSScrubberSelectionStyle;
  setSelectionBackgroundStyle(selectionBackgroundStyle: NSScrubberSelectionStyle): void;
  selectionOverlayStyle(): NSScrubberSelectionStyle;
  setSelectionOverlayStyle(selectionOverlayStyle: NSScrubberSelectionStyle): void;
  showsArrowButtons(): boolean;
  setShowsArrowButtons(showsArrowButtons: boolean): void;
  showsAdditionalContentIndicators(): boolean;
  setShowsAdditionalContentIndicators(showsAdditionalContentIndicators: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  backgroundView(): NSView;
  setBackgroundView(backgroundView: NSView): void;
}

declare interface INSScrubberDataSource {
  numberOfItemsForScrubber(scrubber: NSScrubber): NSInteger;
  scrubber_viewForItemAtIndex(scrubber: NSScrubber, index: NSInteger): NSScrubberItemView;
}

declare interface INSScrubberDelegate {
  scrubber_didSelectItemAtIndex(scrubber: NSScrubber, selectedIndex: NSInteger): void;
  scrubber_didHighlightItemAtIndex(scrubber: NSScrubber, highlightedIndex: NSInteger): void;
  scrubber_didChangeVisibleRange(scrubber: NSScrubber, visibleRange: NSRange): void;
  didBeginInteractingWithScrubber(scrubber: NSScrubber): void;
  didFinishInteractingWithScrubber(scrubber: NSScrubber): void;
  didCancelInteractingWithScrubber(scrubber: NSScrubber): void;
}

declare enum NSScrubberMode {
  NSScrubberModeFixed = 0,
  NSScrubberModeFree,
}

declare enum NSScrubberAlignment {
  NSScrubberAlignmentNone = 0,
  NSScrubberAlignmentLeading,
  NSScrubberAlignmentTrailing,
  NSScrubberAlignmentCenter,
}

class NSScrubberArrangedViewAllocator<T extends NSScrubberArrangedView> extends NSViewAllocator<T> {}
declare class NSScrubberArrangedView extends NSView {
  alloc<T extends NSScrubberArrangedView>(): NSScrubberArrangedViewAllocator<T>;

  selected(): boolean;
  setSelected(selected: boolean): void;
  highlighted(): boolean;
  setHighlighted(highlighted: boolean): void;
}

class NSScrubberSelectionViewAllocator<T extends NSScrubberSelectionView> extends NSScrubberArrangedViewAllocator<T> {}
declare class NSScrubberSelectionView extends NSScrubberArrangedView {
  alloc<T extends NSScrubberSelectionView>(): NSScrubberSelectionViewAllocator<T>;
}

class NSScrubberItemViewAllocator<T extends NSScrubberItemView> extends NSScrubberArrangedViewAllocator<T> {}
declare class NSScrubberItemView extends NSScrubberArrangedView {
  alloc<T extends NSScrubberItemView>(): NSScrubberItemViewAllocator<T>;
}

class NSScrubberTextItemViewAllocator<T extends NSScrubberTextItemView> extends NSScrubberItemViewAllocator<T> {}
declare class NSScrubberTextItemView extends NSScrubberItemView {
  alloc<T extends NSScrubberTextItemView>(): NSScrubberTextItemViewAllocator<T>;

  textField(): NSTextField;
  title(): NSString;
  setTitle(title: NSString | string): void;
}

class NSScrubberImageItemViewAllocator<T extends NSScrubberImageItemView> extends NSScrubberItemViewAllocator<T> {}
declare class NSScrubberImageItemView extends NSScrubberItemView {
  alloc<T extends NSScrubberImageItemView>(): NSScrubberImageItemViewAllocator<T>;

  imageView(): NSImageView;
  image(): NSImage;
  setImage(image: NSImage): void;
  imageAlignment(): NSImageAlignment;
  setImageAlignment(imageAlignment: NSImageAlignment): void;
}

class NSScrubberLayoutAttributesAllocator<T extends NSScrubberLayoutAttributes> extends NSObjectAllocator<T> {}
declare class NSScrubberLayoutAttributes extends NSObject implements INSCopying {
  alloc<T extends NSScrubberLayoutAttributes>(): NSScrubberLayoutAttributesAllocator<T>;
  static layoutAttributesForItemAtIndex(index: NSInteger): NSScrubberLayoutAttributes;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  itemIndex(): NSInteger;
  setItemIndex(itemIndex: NSInteger): void;
  frame(): NSRect;
  setFrame(frame: NSRect): void;
  alpha(): CGFloat;
  setAlpha(alpha: CGFloat): void;
}

class NSScrubberLayoutAllocator<T extends NSScrubberLayout> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSScrubberLayout extends NSObject implements INSCoding {
  alloc<T extends NSScrubberLayout>(): NSScrubberLayoutAllocator<T>;
  prepareLayout(): void;
  layoutAttributesForItemAtIndex(index: NSInteger): NSScrubberLayoutAttributes;
  layoutAttributesForItemsInRect(rect: NSRect): NSSet<any>;
  shouldInvalidateLayoutForChangeFromVisibleRect_toVisibleRect(fromVisibleRect: NSRect, toVisibleRect: NSRect): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  static layoutAttributesClass(): any;
  scrubber(): NSScrubber;
  visibleRect(): NSRect;
  scrubberContentSize(): NSSize;
  shouldInvalidateLayoutForSelectionChange(): boolean;
  shouldInvalidateLayoutForHighlightChange(): boolean;
  automaticallyMirrorsInRightToLeftLayout(): boolean;
}

class NSScrubberFlowLayoutAllocator<T extends NSScrubberFlowLayout> extends NSScrubberLayoutAllocator<T> {}
declare class NSScrubberFlowLayout extends NSScrubberLayout {
  alloc<T extends NSScrubberFlowLayout>(): NSScrubberFlowLayoutAllocator<T>;
  invalidateLayoutForItemsAtIndexes(invalidItemIndexes: NSIndexSet): void;

  itemSpacing(): CGFloat;
  setItemSpacing(itemSpacing: CGFloat): void;
  itemSize(): NSSize;
  setItemSize(itemSize: NSSize): void;
}

class NSScrubberProportionalLayoutAllocator<T extends NSScrubberProportionalLayout> extends NSScrubberLayoutAllocator<T> {
  initWithNumberOfVisibleItems(numberOfVisibleItems: NSInteger): T;
}
declare class NSScrubberProportionalLayout extends NSScrubberLayout {
  alloc<T extends NSScrubberProportionalLayout>(): NSScrubberProportionalLayoutAllocator<T>;

  numberOfVisibleItems(): NSInteger;
  setNumberOfVisibleItems(numberOfVisibleItems: NSInteger): void;
}

declare interface INSScrubberFlowLayoutDelegate {
  scrubber_layout_sizeForItemAtIndex(scrubber: NSScrubber, layout: NSScrubberFlowLayout, itemIndex: NSInteger): NSSize;
}

class NSSearchFieldAllocator<T extends NSSearchField> extends NSTextFieldAllocator<T> {}
declare class NSSearchField extends NSTextField {
  alloc<T extends NSSearchField>(): NSSearchFieldAllocator<T>;
  rectForSearchTextWhenCentered(isCentered: boolean): NSRect;
  rectForSearchButtonWhenCentered(isCentered: boolean): NSRect;
  rectForCancelButtonWhenCentered(isCentered: boolean): NSRect;

  recentSearches(): NSArray<any>;
  setRecentSearches(recentSearches: NSArray<any> | any[]): void;
  recentsAutosaveName(): NSSearchFieldRecentsAutosaveName;
  setRecentsAutosaveName(recentsAutosaveName: NSSearchFieldRecentsAutosaveName): void;
  searchMenuTemplate(): NSMenu;
  setSearchMenuTemplate(searchMenuTemplate: NSMenu): void;
  sendsWholeSearchString(): boolean;
  setSendsWholeSearchString(sendsWholeSearchString: boolean): void;
  maximumRecents(): NSInteger;
  setMaximumRecents(maximumRecents: NSInteger): void;
  sendsSearchStringImmediately(): boolean;
  setSendsSearchStringImmediately(sendsSearchStringImmediately: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  centersPlaceholder(): boolean;
  setCentersPlaceholder(centersPlaceholder: boolean): void;
}

declare interface INSSearchFieldDelegate {
  searchFieldDidStartSearching(sender: NSSearchField): void;
  searchFieldDidEndSearching(sender: NSSearchField): void;
}

declare type NSSearchFieldRecentsAutosaveName = NSString

class NSSearchFieldCellAllocator<T extends NSSearchFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class NSSearchFieldCell extends NSTextFieldCell {
  alloc<T extends NSSearchFieldCell>(): NSSearchFieldCellAllocator<T>;
  resetSearchButtonCell(): void;
  resetCancelButtonCell(): void;
  searchTextRectForBounds(rect: NSRect): NSRect;
  searchButtonRectForBounds(rect: NSRect): NSRect;
  cancelButtonRectForBounds(rect: NSRect): NSRect;

  searchButtonCell(): NSButtonCell;
  setSearchButtonCell(searchButtonCell: NSButtonCell): void;
  cancelButtonCell(): NSButtonCell;
  setCancelButtonCell(cancelButtonCell: NSButtonCell): void;
  searchMenuTemplate(): NSMenu;
  setSearchMenuTemplate(searchMenuTemplate: NSMenu): void;
  sendsWholeSearchString(): boolean;
  setSendsWholeSearchString(sendsWholeSearchString: boolean): void;
  maximumRecents(): NSInteger;
  setMaximumRecents(maximumRecents: NSInteger): void;
  recentSearches(): NSArray<any>;
  setRecentSearches(recentSearches: NSArray<any> | any[]): void;
  recentsAutosaveName(): NSSearchFieldRecentsAutosaveName;
  setRecentsAutosaveName(recentsAutosaveName: NSSearchFieldRecentsAutosaveName): void;
  sendsSearchStringImmediately(): boolean;
  setSendsSearchStringImmediately(sendsSearchStringImmediately: boolean): void;
}

class NSSecureTextFieldAllocator<T extends NSSecureTextField> extends NSTextFieldAllocator<T> {}
declare class NSSecureTextField extends NSTextField {
  alloc<T extends NSSecureTextField>(): NSSecureTextFieldAllocator<T>;
}

class NSSecureTextFieldCellAllocator<T extends NSSecureTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class NSSecureTextFieldCell extends NSTextFieldCell {
  alloc<T extends NSSecureTextFieldCell>(): NSSecureTextFieldCellAllocator<T>;

  echosBullets(): boolean;
  setEchosBullets(echosBullets: boolean): void;
}

class NSSegmentedCellAllocator<T extends NSSegmentedCell> extends NSActionCellAllocator<T> {}
declare class NSSegmentedCell extends NSActionCell {
  alloc<T extends NSSegmentedCell>(): NSSegmentedCellAllocator<T>;
  selectSegmentWithTag(tag: NSInteger): boolean;
  makeNextSegmentKey(): void;
  makePreviousSegmentKey(): void;
  setWidth_forSegment(width: CGFloat, segment: NSInteger): void;
  widthForSegment(segment: NSInteger): CGFloat;
  setImage_forSegment(image: NSImage | null, segment: NSInteger): void;
  imageForSegment(segment: NSInteger): NSImage;
  setImageScaling_forSegment(scaling: NSImageScaling, segment: NSInteger): void;
  imageScalingForSegment(segment: NSInteger): NSImageScaling;
  setLabel_forSegment(label: NSString | string, segment: NSInteger): void;
  labelForSegment(segment: NSInteger): NSString;
  setSelected_forSegment(selected: boolean, segment: NSInteger): void;
  isSelectedForSegment(segment: NSInteger): boolean;
  setEnabled_forSegment(enabled: boolean, segment: NSInteger): void;
  isEnabledForSegment(segment: NSInteger): boolean;
  setMenu_forSegment(menu: NSMenu | null, segment: NSInteger): void;
  menuForSegment(segment: NSInteger): NSMenu;
  setToolTip_forSegment(toolTip: NSString | string | null, segment: NSInteger): void;
  toolTipForSegment(segment: NSInteger): NSString;
  setTag_forSegment(tag: NSInteger, segment: NSInteger): void;
  tagForSegment(segment: NSInteger): NSInteger;
  drawSegment_inFrame_withView(segment: NSInteger, frame: NSRect, controlView: NSView): void;
  interiorBackgroundStyleForSegment(segment: NSInteger): NSBackgroundStyle;

  segmentCount(): NSInteger;
  setSegmentCount(segmentCount: NSInteger): void;
  selectedSegment(): NSInteger;
  setSelectedSegment(selectedSegment: NSInteger): void;
  trackingMode(): NSSegmentSwitchTracking;
  setTrackingMode(trackingMode: NSSegmentSwitchTracking): void;
  segmentStyle(): NSSegmentStyle;
  setSegmentStyle(segmentStyle: NSSegmentStyle): void;
}

class NSSegmentedControlAllocator<T extends NSSegmentedControl> extends NSControlAllocator<T> {}
declare class NSSegmentedControl extends NSControl implements INSUserInterfaceCompression {
  alloc<T extends NSSegmentedControl>(): NSSegmentedControlAllocator<T>;
  selectSegmentWithTag(tag: NSInteger): boolean;
  setWidth_forSegment(width: CGFloat, segment: NSInteger): void;
  widthForSegment(segment: NSInteger): CGFloat;
  setImage_forSegment(image: NSImage | null, segment: NSInteger): void;
  imageForSegment(segment: NSInteger): NSImage;
  setImageScaling_forSegment(scaling: NSImageScaling, segment: NSInteger): void;
  imageScalingForSegment(segment: NSInteger): NSImageScaling;
  setLabel_forSegment(label: NSString | string, segment: NSInteger): void;
  labelForSegment(segment: NSInteger): NSString;
  setMenu_forSegment(menu: NSMenu | null, segment: NSInteger): void;
  menuForSegment(segment: NSInteger): NSMenu;
  setSelected_forSegment(selected: boolean, segment: NSInteger): void;
  isSelectedForSegment(segment: NSInteger): boolean;
  setEnabled_forSegment(enabled: boolean, segment: NSInteger): void;
  isEnabledForSegment(segment: NSInteger): boolean;
  setToolTip_forSegment(toolTip: NSString | string | null, segment: NSInteger): void;
  toolTipForSegment(segment: NSInteger): NSString;
  setTag_forSegment(tag: NSInteger, segment: NSInteger): void;
  tagForSegment(segment: NSInteger): NSInteger;
  setShowsMenuIndicator_forSegment(showsMenuIndicator: boolean, segment: NSInteger): void;
  showsMenuIndicatorForSegment(segment: NSInteger): boolean;
  setAlignment_forSegment(alignment: NSTextAlignment, segment: NSInteger): void;
  alignmentForSegment(segment: NSInteger): NSTextAlignment;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;
  static segmentedControlWithLabels_trackingMode_target_action(labels: NSArray<any> | any[], trackingMode: NSSegmentSwitchTracking, target: any | null, action: string | null): NSSegmentedControl;
  static segmentedControlWithImages_trackingMode_target_action(images: NSArray<any> | any[], trackingMode: NSSegmentSwitchTracking, target: any | null, action: string | null): NSSegmentedControl;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;

  segmentCount(): NSInteger;
  setSegmentCount(segmentCount: NSInteger): void;
  selectedSegment(): NSInteger;
  setSelectedSegment(selectedSegment: NSInteger): void;
  segmentStyle(): NSSegmentStyle;
  setSegmentStyle(segmentStyle: NSSegmentStyle): void;
  springLoaded(): boolean;
  setSpringLoaded(springLoaded: boolean): void;
  trackingMode(): NSSegmentSwitchTracking;
  setTrackingMode(trackingMode: NSSegmentSwitchTracking): void;
  doubleValueForSelectedSegment(): number;
  selectedSegmentBezelColor(): NSColor;
  setSelectedSegmentBezelColor(selectedSegmentBezelColor: NSColor): void;
  indexOfSelectedItem(): NSInteger;
  segmentDistribution(): NSSegmentDistribution;
  setSegmentDistribution(segmentDistribution: NSSegmentDistribution): void;
  activeCompressionOptions(): NSUserInterfaceCompressionOptions;
}

declare enum NSSegmentSwitchTracking {
  NSSegmentSwitchTrackingSelectOne = 0,
  NSSegmentSwitchTrackingSelectAny = 1,
  NSSegmentSwitchTrackingMomentary = 2,
  NSSegmentSwitchTrackingMomentaryAccelerator = 3,
}

declare enum NSSegmentStyle {
  NSSegmentStyleAutomatic = 0,
  NSSegmentStyleRounded = 1,
  NSSegmentStyleRoundRect = 3,
  NSSegmentStyleTexturedSquare = 4,
  NSSegmentStyleSmallSquare = 6,
  NSSegmentStyleSeparated = 8,
  NSSegmentStyleTexturedRounded = 2,
  NSSegmentStyleCapsule = 5,
}

declare enum NSSegmentDistribution {
  NSSegmentDistributionFit = 0,
  NSSegmentDistributionFill,
  NSSegmentDistributionFillEqually,
  NSSegmentDistributionFillProportionally,
}

class NSShadowAllocator<T extends NSShadow> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSShadow extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSShadow>(): NSShadowAllocator<T>;
  set(): void;
  static shadowWithColor_offset_blur(color: NSColor, offset: NSSize, blur: CGFloat): NSShadow;
  static clearShadow(): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  shadowOffset(): NSSize;
  setShadowOffset(shadowOffset: NSSize): void;
  shadowBlurRadius(): CGFloat;
  setShadowBlurRadius(shadowBlurRadius: CGFloat): void;
  shadowColor(): NSColor;
  setShadowColor(shadowColor: NSColor): void;
}

class NSSharingServiceAllocator<T extends NSSharingService> extends NSObjectAllocator<T> {
  initWithTitle_image_alternateImage_handler(title: NSString | string, image: NSImage, alternateImage: NSImage | null, block: Block): T;
}
declare class NSSharingService extends NSObject {
  alloc<T extends NSSharingService>(): NSSharingServiceAllocator<T>;
  static sharingServicesForItems(items: NSArray<any> | any[]): NSArray<any>;
  static sharingServiceNamed(serviceName: NSSharingServiceName): NSSharingService;
  canPerformWithItems(items: NSArray<any> | any[] | null): boolean;
  performWithItems(items: NSArray<any> | any[]): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  title(): NSString;
  image(): NSImage;
  alternateImage(): NSImage;
  menuItemTitle(): NSString;
  setMenuItemTitle(menuItemTitle: NSString | string): void;
  recipients(): NSArray<any>;
  setRecipients(recipients: NSArray<any> | any[]): void;
  subject(): NSString;
  setSubject(subject: NSString | string): void;
  messageBody(): NSString;
  permanentLink(): NSURL;
  accountName(): NSString;
  attachmentFileURLs(): NSArray<any>;
}

class NSSharingServicePickerAllocator<T extends NSSharingServicePicker> extends NSObjectAllocator<T> {
  initWithItems(items: NSArray<any> | any[]): T;
}
declare class NSSharingServicePicker extends NSObject {
  alloc<T extends NSSharingServicePicker>(): NSSharingServicePickerAllocator<T>;
  showRelativeToRect_ofView_preferredEdge(rect: NSRect, view: NSView, preferredEdge: NSRectEdge): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface INSSharingServiceDelegate {
  sharingService_willShareItems(sharingService: NSSharingService, items: NSArray<any> | any[]): void;
  sharingService_didFailToShareItems_error(sharingService: NSSharingService, items: NSArray<any> | any[], error: NSError): void;
  sharingService_didShareItems(sharingService: NSSharingService, items: NSArray<any> | any[]): void;
  sharingService_sourceFrameOnScreenForShareItem(sharingService: NSSharingService, item: any): NSRect;
  sharingService_transitionImageForShareItem_contentRect(sharingService: NSSharingService, item: any, contentRect: NSRect): NSImage;
  sharingService_sourceWindowForShareItems_sharingContentScope(sharingService: NSSharingService, items: NSArray<any> | any[], sharingContentScope: NSSharingContentScope): NSWindow;
  anchoringViewForSharingService_showRelativeToRect_preferredEdge(sharingService: NSSharingService, positioningRect: NSRect, preferredEdge: NSRectEdge): NSView;
}

declare interface INSCloudSharingServiceDelegate {
  sharingService_didCompleteForItems_error(sharingService: NSSharingService, items: NSArray<any> | any[], error: NSError | null): void;
  optionsForSharingService_shareProvider(cloudKitSharingService: NSSharingService, provider: NSItemProvider): NSCloudKitSharingServiceOptions;
  sharingService_didSaveShare(sharingService: NSSharingService, share: CKShare): void;
  sharingService_didStopSharing(sharingService: NSSharingService, share: CKShare): void;
}

declare interface INSSharingServicePickerDelegate {
  sharingServicePicker_sharingServicesForItems_proposedSharingServices(sharingServicePicker: NSSharingServicePicker, items: NSArray<any> | any[], proposedServices: NSArray<any> | any[]): NSArray<any>;
  sharingServicePicker_delegateForSharingService(sharingServicePicker: NSSharingServicePicker, sharingService: NSSharingService): any;
  sharingServicePicker_didChooseSharingService(sharingServicePicker: NSSharingServicePicker, service: NSSharingService | null): void;
}

declare type NSSharingServiceName = NSString

declare enum NSSharingContentScope {
  NSSharingContentScopeItem,
  NSSharingContentScopePartial,
  NSSharingContentScopeFull,
}

declare enum NSCloudKitSharingServiceOptions {
  NSCloudKitSharingServiceStandard = 0,
  NSCloudKitSharingServiceAllowPublic = 1 << 0,
  NSCloudKitSharingServiceAllowPrivate = 1 << 1,
  NSCloudKitSharingServiceAllowReadOnly = 1 << 4,
  NSCloudKitSharingServiceAllowReadWrite = 1 << 5,
}

class NSSharingServicePickerTouchBarItemAllocator<T extends NSSharingServicePickerTouchBarItem> extends NSTouchBarItemAllocator<T> {}
declare class NSSharingServicePickerTouchBarItem extends NSTouchBarItem {
  alloc<T extends NSSharingServicePickerTouchBarItem>(): NSSharingServicePickerTouchBarItemAllocator<T>;

  delegate(): any;
  setDelegate(delegate: any): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  buttonTitle(): NSString;
  setButtonTitle(buttonTitle: NSString | string): void;
  buttonImage(): NSImage;
  setButtonImage(buttonImage: NSImage): void;
}

declare interface INSSharingServicePickerTouchBarItemDelegate {
  itemsForSharingServicePickerTouchBarItem(pickerTouchBarItem: NSSharingServicePickerTouchBarItem): NSArray<any>;
}

class NSSimpleHorizontalTypesetterAllocator<T extends NSSimpleHorizontalTypesetter> extends NSTypesetterAllocator<T> {}
declare class NSSimpleHorizontalTypesetter extends NSTypesetter {
  alloc<T extends NSSimpleHorizontalTypesetter>(): NSSimpleHorizontalTypesetterAllocator<T>;
  static sharedInstance(): any;
  currentLayoutManager(): NSLayoutManager;
  currentContainer(): NSTextContainer;
  currentParagraphStyle(): NSParagraphStyle;
  currentTextStorage(): NSTextStorage;
  baseOfTypesetterGlyphInfo(): NSTypesetterGlyphInfo;
  sizeOfTypesetterGlyphInfo(): NSUInteger;
  capacityOfTypesetterGlyphInfo(): NSUInteger;
  firstGlyphIndexOfCurrentLineFragment(): NSUInteger;
  layoutGlyphsInLayoutManager_startingAtGlyphIndex_maxNumberOfLineFragments_nextGlyphIndex(layoutManager: NSLayoutManager, startGlyphIndex: NSUInteger, maxNumLines: NSUInteger, nextGlyph: NSUInteger): void;
  layoutGlyphsInHorizontalLineFragment_baseline(lineFragmentRect: NSRect, baseline: number): NSLayoutStatus;
  clearGlyphCache(): void;
  fillAttributesCache(): void;
  clearAttributesCache(): void;
  growGlyphCaches_fillGlyphInfo(desiredCapacity: NSUInteger, fillGlyphInfo: boolean): NSUInteger;
  updateCurGlyphOffset(): void;
  insertGlyph_atGlyphIndex_characterIndex(glyph: NSGlyph, glyphIndex: NSUInteger, charIndex: NSUInteger): void;
  layoutControlGlyphForLineFragment(lineFrag: NSRect): NSLayoutStatus;
  layoutTab(): void;
  breakLineAtIndex(location: NSUInteger): void;
  glyphIndexToBreakLineByHyphenatingWordAtIndex(charIndex: NSUInteger): NSUInteger;
  glyphIndexToBreakLineByWordWrappingAtIndex(charIndex: NSUInteger): NSUInteger;
  fullJustifyLineAtGlyphIndex(glyphIndexForLineBreak: NSUInteger): void;
  typesetterLaidOneGlyph(gl: NSTypesetterGlyphInfo): void;
  willSetLineFragmentRect_forGlyphRange_usedRect(rect: NSRect, range: NSRange, bRect: NSRect): void;
}

declare enum NSLayoutStatus {
  NSLayoutNotDone = 0,
  NSLayoutDone,
  NSLayoutCantFit,
  NSLayoutOutOfGlyphs,
}

declare enum NSGlyphLayoutMode {
  NSGlyphLayoutAtAPoint = 0,
  NSGlyphLayoutAgainstAPoint,
  NSGlyphLayoutWithPrevious,
}

declare enum NSLayoutDirection {
  NSLayoutLeftToRight = 0,
  NSLayoutRightToLeft,
}

class NSSliderAllocator<T extends NSSlider> extends NSControlAllocator<T> {}
declare class NSSlider extends NSControl implements INSAccessibilitySlider {
  alloc<T extends NSSlider>(): NSSliderAllocator<T>;
  acceptsFirstMouse(event: NSEvent | null): boolean;
  tickMarkValueAtIndex(index: NSInteger): number;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;
  indexOfTickMarkAtPoint(point: NSPoint): NSInteger;
  closestTickMarkValueToValue(value: number): number;
  static sliderWithTarget_action(target: any | null, action: string | null): NSSlider;
  static sliderWithValue_minValue_maxValue_target_action(value: number, minValue: number, maxValue: number, target: any | null, action: string | null): NSSlider;
  setTitleCell(cell: NSCell): void;
  titleCell(): any;
  setTitleColor(newColor: NSColor): void;
  titleColor(): NSColor;
  setTitleFont(fontObj: NSFont): void;
  titleFont(): NSFont;
  title(): NSString;
  setTitle(string: NSString | string): void;
  setKnobThickness(thickness: CGFloat): void;
  setImage(backgroundImage: NSImage): void;
  image(): NSImage;
  accessibilityLabel(): NSString;
  accessibilityValue(): any;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityLabel(): NSString;
  accessibilityValue(): any;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;

  sliderType(): NSSliderType;
  setSliderType(sliderType: NSSliderType): void;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  altIncrementValue(): number;
  setAltIncrementValue(altIncrementValue: number): void;
  knobThickness(): CGFloat;
  vertical(): boolean;
  trackFillColor(): NSColor;
  setTrackFillColor(trackFillColor: NSColor): void;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  allowsTickMarkValuesOnly(): boolean;
  setAllowsTickMarkValuesOnly(allowsTickMarkValuesOnly: boolean): void;
}

class NSSliderAccessoryAllocator<T extends NSSliderAccessory> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSSliderAccessory extends NSObject implements INSCoding, INSAccessibility, INSAccessibilityElement {
  alloc<T extends NSSliderAccessory>(): NSSliderAccessoryAllocator<T>;
  static accessoryWithImage(image: NSImage): NSSliderAccessory;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;
  encodeWithCoder(aCoder: NSCoder): void;
  accessibilityLayoutPointForScreenPoint(point: NSPoint): NSPoint;
  accessibilityLayoutSizeForScreenSize(size: NSSize): NSSize;
  accessibilityScreenPointForLayoutPoint(point: NSPoint): NSPoint;
  accessibilityScreenSizeForLayoutSize(size: NSSize): NSSize;
  accessibilityCellForColumn_row(column: NSInteger, row: NSInteger): any;
  accessibilityAttributedStringForRange(range: NSRange): NSAttributedString;
  accessibilityRangeForLine(line: NSInteger): NSRange;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityRangeForPosition(point: NSPoint): NSRange;
  accessibilityRangeForIndex(index: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  accessibilityRTFForRange(range: NSRange): NSData;
  accessibilityStyleRangeForIndex(index: NSInteger): NSRange;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  isAccessibilitySelectorAllowed(selector: string): boolean;
  accessibilityFrame(): NSRect;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
  accessibilityIdentifier(): NSString;

  behavior(): NSSliderAccessoryBehavior;
  setBehavior(behavior: NSSliderAccessoryBehavior): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  accessibilityElement(): boolean;
  setAccessibilityElement(accessibilityElement: boolean): void;
  accessibilityFrame(): NSRect;
  setAccessibilityFrame(accessibilityFrame: NSRect): void;
  accessibilityFocused(): boolean;
  setAccessibilityFocused(accessibilityFocused: boolean): void;
  accessibilityActivationPoint(): NSPoint;
  setAccessibilityActivationPoint(accessibilityActivationPoint: NSPoint): void;
  accessibilityTopLevelUIElement(): any;
  setAccessibilityTopLevelUIElement(accessibilityTopLevelUIElement: any): void;
  accessibilityURL(): NSURL;
  setAccessibilityURL(accessibilityURL: NSURL): void;
  accessibilityValue(): any;
  setAccessibilityValue(accessibilityValue: any): void;
  accessibilityValueDescription(): NSString;
  setAccessibilityValueDescription(accessibilityValueDescription: NSString | string): void;
  accessibilityVisibleChildren(): NSArray<any>;
  setAccessibilityVisibleChildren(accessibilityVisibleChildren: NSArray<any> | any[]): void;
  accessibilitySubrole(): NSAccessibilitySubrole;
  setAccessibilitySubrole(accessibilitySubrole: NSAccessibilitySubrole): void;
  accessibilityTitle(): NSString;
  setAccessibilityTitle(accessibilityTitle: NSString | string): void;
  accessibilityTitleUIElement(): any;
  setAccessibilityTitleUIElement(accessibilityTitleUIElement: any): void;
  accessibilityNextContents(): NSArray<any>;
  setAccessibilityNextContents(accessibilityNextContents: NSArray<any> | any[]): void;
  accessibilityOrientation(): NSAccessibilityOrientation;
  setAccessibilityOrientation(accessibilityOrientation: NSAccessibilityOrientation): void;
  accessibilityOverflowButton(): any;
  setAccessibilityOverflowButton(accessibilityOverflowButton: any): void;
  accessibilityParent(): any;
  setAccessibilityParent(accessibilityParent: any): void;
  accessibilityPlaceholderValue(): NSString;
  setAccessibilityPlaceholderValue(accessibilityPlaceholderValue: NSString | string): void;
  accessibilityPreviousContents(): NSArray<any>;
  setAccessibilityPreviousContents(accessibilityPreviousContents: NSArray<any> | any[]): void;
  accessibilityRole(): NSAccessibilityRole;
  setAccessibilityRole(accessibilityRole: NSAccessibilityRole): void;
  accessibilityRoleDescription(): NSString;
  setAccessibilityRoleDescription(accessibilityRoleDescription: NSString | string): void;
  accessibilitySearchButton(): any;
  setAccessibilitySearchButton(accessibilitySearchButton: any): void;
  accessibilitySearchMenu(): any;
  setAccessibilitySearchMenu(accessibilitySearchMenu: any): void;
  accessibilitySelected(): boolean;
  setAccessibilitySelected(accessibilitySelected: boolean): void;
  accessibilitySelectedChildren(): NSArray<any>;
  setAccessibilitySelectedChildren(accessibilitySelectedChildren: NSArray<any> | any[]): void;
  accessibilityServesAsTitleForUIElements(): NSArray<any>;
  setAccessibilityServesAsTitleForUIElements(accessibilityServesAsTitleForUIElements: NSArray<any> | any[]): void;
  accessibilityShownMenu(): any;
  setAccessibilityShownMenu(accessibilityShownMenu: any): void;
  accessibilityMinValue(): any;
  setAccessibilityMinValue(accessibilityMinValue: any): void;
  accessibilityMaxValue(): any;
  setAccessibilityMaxValue(accessibilityMaxValue: any): void;
  accessibilityLinkedUIElements(): NSArray<any>;
  setAccessibilityLinkedUIElements(accessibilityLinkedUIElements: NSArray<any> | any[]): void;
  accessibilityWindow(): any;
  setAccessibilityWindow(accessibilityWindow: any): void;
  accessibilityIdentifier(): NSString;
  setAccessibilityIdentifier(accessibilityIdentifier: NSString | string): void;
  accessibilityHelp(): NSString;
  setAccessibilityHelp(accessibilityHelp: NSString | string): void;
  accessibilityFilename(): NSString;
  setAccessibilityFilename(accessibilityFilename: NSString | string): void;
  accessibilityExpanded(): boolean;
  setAccessibilityExpanded(accessibilityExpanded: boolean): void;
  accessibilityEdited(): boolean;
  setAccessibilityEdited(accessibilityEdited: boolean): void;
  accessibilityEnabled(): boolean;
  setAccessibilityEnabled(accessibilityEnabled: boolean): void;
  accessibilityChildren(): NSArray<any>;
  setAccessibilityChildren(accessibilityChildren: NSArray<any> | any[]): void;
  accessibilityChildrenInNavigationOrder(): NSArray<any>;
  setAccessibilityChildrenInNavigationOrder(accessibilityChildrenInNavigationOrder: NSArray<any> | any[]): void;
  accessibilityClearButton(): any;
  setAccessibilityClearButton(accessibilityClearButton: any): void;
  accessibilityCancelButton(): any;
  setAccessibilityCancelButton(accessibilityCancelButton: any): void;
  accessibilityProtectedContent(): boolean;
  setAccessibilityProtectedContent(accessibilityProtectedContent: boolean): void;
  accessibilityContents(): NSArray<any>;
  setAccessibilityContents(accessibilityContents: NSArray<any> | any[]): void;
  accessibilityLabel(): NSString;
  setAccessibilityLabel(accessibilityLabel: NSString | string): void;
  accessibilityAlternateUIVisible(): boolean;
  setAccessibilityAlternateUIVisible(accessibilityAlternateUIVisible: boolean): void;
  accessibilitySharedFocusElements(): NSArray<any>;
  setAccessibilitySharedFocusElements(accessibilitySharedFocusElements: NSArray<any> | any[]): void;
  accessibilityRequired(): boolean;
  setAccessibilityRequired(accessibilityRequired: boolean): void;
  accessibilityCustomRotors(): NSArray<any>;
  setAccessibilityCustomRotors(accessibilityCustomRotors: NSArray<any> | any[]): void;
  accessibilityApplicationFocusedUIElement(): any;
  setAccessibilityApplicationFocusedUIElement(accessibilityApplicationFocusedUIElement: any): void;
  accessibilityMainWindow(): any;
  setAccessibilityMainWindow(accessibilityMainWindow: any): void;
  accessibilityHidden(): boolean;
  setAccessibilityHidden(accessibilityHidden: boolean): void;
  accessibilityFrontmost(): boolean;
  setAccessibilityFrontmost(accessibilityFrontmost: boolean): void;
  accessibilityFocusedWindow(): any;
  setAccessibilityFocusedWindow(accessibilityFocusedWindow: any): void;
  accessibilityWindows(): NSArray<any>;
  setAccessibilityWindows(accessibilityWindows: NSArray<any> | any[]): void;
  accessibilityExtrasMenuBar(): any;
  setAccessibilityExtrasMenuBar(accessibilityExtrasMenuBar: any): void;
  accessibilityMenuBar(): any;
  setAccessibilityMenuBar(accessibilityMenuBar: any): void;
  accessibilityColumnTitles(): NSArray<any>;
  setAccessibilityColumnTitles(accessibilityColumnTitles: NSArray<any> | any[]): void;
  accessibilityOrderedByRow(): boolean;
  setAccessibilityOrderedByRow(accessibilityOrderedByRow: boolean): void;
  accessibilityHorizontalUnits(): NSAccessibilityUnits;
  setAccessibilityHorizontalUnits(accessibilityHorizontalUnits: NSAccessibilityUnits): void;
  accessibilityVerticalUnits(): NSAccessibilityUnits;
  setAccessibilityVerticalUnits(accessibilityVerticalUnits: NSAccessibilityUnits): void;
  accessibilityHorizontalUnitDescription(): NSString;
  setAccessibilityHorizontalUnitDescription(accessibilityHorizontalUnitDescription: NSString | string): void;
  accessibilityVerticalUnitDescription(): NSString;
  setAccessibilityVerticalUnitDescription(accessibilityVerticalUnitDescription: NSString | string): void;
  accessibilityHandles(): NSArray<any>;
  setAccessibilityHandles(accessibilityHandles: NSArray<any> | any[]): void;
  accessibilityWarningValue(): any;
  setAccessibilityWarningValue(accessibilityWarningValue: any): void;
  accessibilityCriticalValue(): any;
  setAccessibilityCriticalValue(accessibilityCriticalValue: any): void;
  accessibilityDisclosed(): boolean;
  setAccessibilityDisclosed(accessibilityDisclosed: boolean): void;
  accessibilityDisclosedByRow(): any;
  setAccessibilityDisclosedByRow(accessibilityDisclosedByRow: any): void;
  accessibilityDisclosedRows(): any;
  setAccessibilityDisclosedRows(accessibilityDisclosedRows: any): void;
  accessibilityDisclosureLevel(): NSInteger;
  setAccessibilityDisclosureLevel(accessibilityDisclosureLevel: NSInteger): void;
  accessibilityMarkerUIElements(): NSArray<any>;
  setAccessibilityMarkerUIElements(accessibilityMarkerUIElements: NSArray<any> | any[]): void;
  accessibilityMarkerValues(): any;
  setAccessibilityMarkerValues(accessibilityMarkerValues: any): void;
  accessibilityMarkerGroupUIElement(): any;
  setAccessibilityMarkerGroupUIElement(accessibilityMarkerGroupUIElement: any): void;
  accessibilityUnits(): NSAccessibilityUnits;
  setAccessibilityUnits(accessibilityUnits: NSAccessibilityUnits): void;
  accessibilityUnitDescription(): NSString;
  setAccessibilityUnitDescription(accessibilityUnitDescription: NSString | string): void;
  accessibilityRulerMarkerType(): NSAccessibilityRulerMarkerType;
  setAccessibilityRulerMarkerType(accessibilityRulerMarkerType: NSAccessibilityRulerMarkerType): void;
  accessibilityMarkerTypeDescription(): NSString;
  setAccessibilityMarkerTypeDescription(accessibilityMarkerTypeDescription: NSString | string): void;
  accessibilityHorizontalScrollBar(): any;
  setAccessibilityHorizontalScrollBar(accessibilityHorizontalScrollBar: any): void;
  accessibilityVerticalScrollBar(): any;
  setAccessibilityVerticalScrollBar(accessibilityVerticalScrollBar: any): void;
  accessibilityAllowedValues(): NSArray<any>;
  setAccessibilityAllowedValues(accessibilityAllowedValues: NSArray<any> | any[]): void;
  accessibilityLabelUIElements(): NSArray<any>;
  setAccessibilityLabelUIElements(accessibilityLabelUIElements: NSArray<any> | any[]): void;
  accessibilityLabelValue(): number;
  setAccessibilityLabelValue(accessibilityLabelValue: number): void;
  accessibilitySplitters(): NSArray<any>;
  setAccessibilitySplitters(accessibilitySplitters: NSArray<any> | any[]): void;
  accessibilityDecrementButton(): any;
  setAccessibilityDecrementButton(accessibilityDecrementButton: any): void;
  accessibilityIncrementButton(): any;
  setAccessibilityIncrementButton(accessibilityIncrementButton: any): void;
  accessibilityTabs(): NSArray<any>;
  setAccessibilityTabs(accessibilityTabs: NSArray<any> | any[]): void;
  accessibilityHeader(): any;
  setAccessibilityHeader(accessibilityHeader: any): void;
  accessibilityColumnCount(): NSInteger;
  setAccessibilityColumnCount(accessibilityColumnCount: NSInteger): void;
  accessibilityRowCount(): NSInteger;
  setAccessibilityRowCount(accessibilityRowCount: NSInteger): void;
  accessibilityIndex(): NSInteger;
  setAccessibilityIndex(accessibilityIndex: NSInteger): void;
  accessibilityColumns(): NSArray<any>;
  setAccessibilityColumns(accessibilityColumns: NSArray<any> | any[]): void;
  accessibilityRows(): NSArray<any>;
  setAccessibilityRows(accessibilityRows: NSArray<any> | any[]): void;
  accessibilityVisibleRows(): NSArray<any>;
  setAccessibilityVisibleRows(accessibilityVisibleRows: NSArray<any> | any[]): void;
  accessibilitySelectedRows(): NSArray<any>;
  setAccessibilitySelectedRows(accessibilitySelectedRows: NSArray<any> | any[]): void;
  accessibilityVisibleColumns(): NSArray<any>;
  setAccessibilityVisibleColumns(accessibilityVisibleColumns: NSArray<any> | any[]): void;
  accessibilitySelectedColumns(): NSArray<any>;
  setAccessibilitySelectedColumns(accessibilitySelectedColumns: NSArray<any> | any[]): void;
  accessibilitySortDirection(): NSAccessibilitySortDirection;
  setAccessibilitySortDirection(accessibilitySortDirection: NSAccessibilitySortDirection): void;
  accessibilityRowHeaderUIElements(): NSArray<any>;
  setAccessibilityRowHeaderUIElements(accessibilityRowHeaderUIElements: NSArray<any> | any[]): void;
  accessibilitySelectedCells(): NSArray<any>;
  setAccessibilitySelectedCells(accessibilitySelectedCells: NSArray<any> | any[]): void;
  accessibilityVisibleCells(): NSArray<any>;
  setAccessibilityVisibleCells(accessibilityVisibleCells: NSArray<any> | any[]): void;
  accessibilityColumnHeaderUIElements(): NSArray<any>;
  setAccessibilityColumnHeaderUIElements(accessibilityColumnHeaderUIElements: NSArray<any> | any[]): void;
  accessibilityRowIndexRange(): NSRange;
  setAccessibilityRowIndexRange(accessibilityRowIndexRange: NSRange): void;
  accessibilityColumnIndexRange(): NSRange;
  setAccessibilityColumnIndexRange(accessibilityColumnIndexRange: NSRange): void;
  accessibilityInsertionPointLineNumber(): NSInteger;
  setAccessibilityInsertionPointLineNumber(accessibilityInsertionPointLineNumber: NSInteger): void;
  accessibilitySharedCharacterRange(): NSRange;
  setAccessibilitySharedCharacterRange(accessibilitySharedCharacterRange: NSRange): void;
  accessibilitySharedTextUIElements(): NSArray<any>;
  setAccessibilitySharedTextUIElements(accessibilitySharedTextUIElements: NSArray<any> | any[]): void;
  accessibilityVisibleCharacterRange(): NSRange;
  setAccessibilityVisibleCharacterRange(accessibilityVisibleCharacterRange: NSRange): void;
  accessibilityNumberOfCharacters(): NSInteger;
  setAccessibilityNumberOfCharacters(accessibilityNumberOfCharacters: NSInteger): void;
  accessibilitySelectedText(): NSString;
  setAccessibilitySelectedText(accessibilitySelectedText: NSString | string): void;
  accessibilitySelectedTextRange(): NSRange;
  setAccessibilitySelectedTextRange(accessibilitySelectedTextRange: NSRange): void;
  accessibilitySelectedTextRanges(): NSArray<any>;
  setAccessibilitySelectedTextRanges(accessibilitySelectedTextRanges: NSArray<any> | any[]): void;
  accessibilityToolbarButton(): any;
  setAccessibilityToolbarButton(accessibilityToolbarButton: any): void;
  accessibilityModal(): boolean;
  setAccessibilityModal(accessibilityModal: boolean): void;
  accessibilityProxy(): any;
  setAccessibilityProxy(accessibilityProxy: any): void;
  accessibilityMain(): boolean;
  setAccessibilityMain(accessibilityMain: boolean): void;
  accessibilityFullScreenButton(): any;
  setAccessibilityFullScreenButton(accessibilityFullScreenButton: any): void;
  accessibilityGrowArea(): any;
  setAccessibilityGrowArea(accessibilityGrowArea: any): void;
  accessibilityDocument(): NSString;
  setAccessibilityDocument(accessibilityDocument: NSString | string): void;
  accessibilityDefaultButton(): any;
  setAccessibilityDefaultButton(accessibilityDefaultButton: any): void;
  accessibilityCloseButton(): any;
  setAccessibilityCloseButton(accessibilityCloseButton: any): void;
  accessibilityZoomButton(): any;
  setAccessibilityZoomButton(accessibilityZoomButton: any): void;
  accessibilityMinimizeButton(): any;
  setAccessibilityMinimizeButton(accessibilityMinimizeButton: any): void;
  accessibilityMinimized(): boolean;
  setAccessibilityMinimized(accessibilityMinimized: boolean): void;
  accessibilityCustomActions(): NSArray<any>;
  setAccessibilityCustomActions(accessibilityCustomActions: NSArray<any> | any[]): void;
}

class NSSliderAccessoryBehaviorAllocator<T extends NSSliderAccessoryBehavior> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSSliderAccessoryBehavior extends NSObject implements INSCoding, INSCopying {
  alloc<T extends NSSliderAccessoryBehavior>(): NSSliderAccessoryBehaviorAllocator<T>;
  static behaviorWithTarget_action(target: any | null, action: string): NSSliderAccessoryBehavior;
  static behaviorWithHandler(handler: Block): NSSliderAccessoryBehavior;
  handleAction(sender: NSSliderAccessory): void;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;

  static automaticBehavior(): NSSliderAccessoryBehavior;
  static valueStepBehavior(): NSSliderAccessoryBehavior;
  static valueResetBehavior(): NSSliderAccessoryBehavior;
}

class NSSliderCellAllocator<T extends NSSliderCell> extends NSActionCellAllocator<T> {}
declare class NSSliderCell extends NSActionCell {
  alloc<T extends NSSliderCell>(): NSSliderCellAllocator<T>;
  knobRectFlipped(flipped: boolean): NSRect;
  barRectFlipped(flipped: boolean): NSRect;
  drawKnob(knobRect: NSRect): void;
  drawKnob(): void;
  drawBarInside_flipped(rect: NSRect, flipped: boolean): void;
  tickMarkValueAtIndex(index: NSInteger): number;
  rectOfTickMarkAtIndex(index: NSInteger): NSRect;
  indexOfTickMarkAtPoint(point: NSPoint): NSInteger;
  closestTickMarkValueToValue(value: number): number;
  drawTickMarks(): void;
  setTitleColor(newColor: NSColor): void;
  titleColor(): NSColor;
  setTitleFont(fontObj: NSFont): void;
  titleFont(): NSFont;
  title(): NSString;
  setTitle(string: NSString | string): void;
  setTitleCell(cell: NSCell): void;
  titleCell(): any;
  setKnobThickness(thickness: CGFloat): void;

  static prefersTrackingUntilMouseUp(): boolean;
  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  altIncrementValue(): number;
  setAltIncrementValue(altIncrementValue: number): void;
  sliderType(): NSSliderType;
  setSliderType(sliderType: NSSliderType): void;
  vertical(): boolean;
  trackRect(): NSRect;
  knobThickness(): CGFloat;
  numberOfTickMarks(): NSInteger;
  setNumberOfTickMarks(numberOfTickMarks: NSInteger): void;
  tickMarkPosition(): NSTickMarkPosition;
  setTickMarkPosition(tickMarkPosition: NSTickMarkPosition): void;
  allowsTickMarkValuesOnly(): boolean;
  setAllowsTickMarkValuesOnly(allowsTickMarkValuesOnly: boolean): void;
}

declare enum NSTickMarkPosition {
  NSTickMarkPositionBelow = 0,
  NSTickMarkPositionAbove = 1,
  NSTickMarkPositionLeading,
  NSTickMarkPositionTrailing,
}

declare enum NSSliderType {
  NSSliderTypeLinear = 0,
  NSSliderTypeCircular = 1,
}

class NSSliderTouchBarItemAllocator<T extends NSSliderTouchBarItem> extends NSTouchBarItemAllocator<T> {}
declare class NSSliderTouchBarItem extends NSTouchBarItem {
  alloc<T extends NSSliderTouchBarItem>(): NSSliderTouchBarItemAllocator<T>;

  view(): NSView;
  slider(): NSSlider;
  setSlider(slider: NSSlider): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  minimumValueAccessory(): NSSliderAccessory;
  setMinimumValueAccessory(minimumValueAccessory: NSSliderAccessory): void;
  maximumValueAccessory(): NSSliderAccessory;
  setMaximumValueAccessory(maximumValueAccessory: NSSliderAccessory): void;
  valueAccessoryWidth(): NSSliderAccessoryWidth;
  setValueAccessoryWidth(valueAccessoryWidth: NSSliderAccessoryWidth): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  customizationLabel(): NSString;
  setCustomizationLabel(customizationLabel: NSString | string): void;
}

declare type NSSliderAccessoryWidth = CGFloat

class NSSoundAllocator<T extends NSSound> extends NSObjectAllocator<T> {
  initWithContentsOfURL_byReference(url: NSURL, byRef: boolean): T;
  initWithContentsOfFile_byReference(path: NSString | string, byRef: boolean): T;
  initWithData(data: NSData): T;
  initWithPasteboard(pasteboard: NSPasteboard): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): T;
}
declare class NSSound extends NSObject implements INSCopying, INSCoding, INSPasteboardReading, INSPasteboardWriting {
  alloc<T extends NSSound>(): NSSoundAllocator<T>;
  static soundNamed(name: NSSoundName): NSSound;
  setName(string: NSSoundName | null): boolean;
  static canInitWithPasteboard(pasteboard: NSPasteboard): boolean;
  writeToPasteboard(pasteboard: NSPasteboard): void;
  play(): boolean;
  pause(): boolean;
  resume(): boolean;
  stop(): boolean;
  setChannelMapping(channelMapping: NSArray<any> | any[]): void;
  channelMapping(): NSArray<any>;
  static soundUnfilteredFileTypes(): NSArray<any>;
  static soundUnfilteredPasteboardTypes(): NSArray<any>;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;

  name(): NSSoundName;
  static soundUnfilteredTypes(): NSArray<any>;
  playing(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  duration(): NSTimeInterval;
  volume(): number;
  setVolume(volume: number): void;
  currentTime(): NSTimeInterval;
  setCurrentTime(currentTime: NSTimeInterval): void;
  loops(): boolean;
  setLoops(loops: boolean): void;
  playbackDeviceIdentifier(): NSSoundPlaybackDeviceIdentifier;
  setPlaybackDeviceIdentifier(playbackDeviceIdentifier: NSSoundPlaybackDeviceIdentifier): void;
}

declare interface INSSoundDelegate {
  sound_didFinishPlaying(sound: NSSound, flag: boolean): void;
}

declare type NSSoundName = NSString

declare type NSSoundPlaybackDeviceIdentifier = NSString

class NSSpeechRecognizerAllocator<T extends NSSpeechRecognizer> extends NSObjectAllocator<T> {
  init(): T;
}
declare class NSSpeechRecognizer extends NSObject {
  alloc<T extends NSSpeechRecognizer>(): NSSpeechRecognizerAllocator<T>;
  startListening(): void;
  stopListening(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  commands(): NSArray<any>;
  setCommands(commands: NSArray<any> | any[]): void;
  displayedCommandsTitle(): NSString;
  setDisplayedCommandsTitle(displayedCommandsTitle: NSString | string): void;
  listensInForegroundOnly(): boolean;
  setListensInForegroundOnly(listensInForegroundOnly: boolean): void;
  blocksOtherRecognizers(): boolean;
  setBlocksOtherRecognizers(blocksOtherRecognizers: boolean): void;
}

declare interface INSSpeechRecognizerDelegate {
  speechRecognizer_didRecognizeCommand(sender: NSSpeechRecognizer, command: NSString | string): void;
}

class NSSpeechSynthesizerAllocator<T extends NSSpeechSynthesizer> extends NSObjectAllocator<T> {
  initWithVoice(voice: NSSpeechSynthesizerVoiceName | null): T;
}
declare class NSSpeechSynthesizer extends NSObject {
  alloc<T extends NSSpeechSynthesizer>(): NSSpeechSynthesizerAllocator<T>;
  startSpeakingString(string: NSString | string): boolean;
  startSpeakingString_toURL(string: NSString | string, url: NSURL): boolean;
  stopSpeaking(): void;
  stopSpeakingAtBoundary(boundary: NSSpeechBoundary): void;
  pauseSpeakingAtBoundary(boundary: NSSpeechBoundary): void;
  continueSpeaking(): void;
  voice(): NSSpeechSynthesizerVoiceName;
  setVoice(voice: NSSpeechSynthesizerVoiceName | null): boolean;
  addSpeechDictionary(speechDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  phonemesFromText(text: NSString | string): NSString;
  objectForProperty_error(property: NSSpeechPropertyKey, outError: NSError): any;
  setObject_forProperty_error(object: any | null, property: NSSpeechPropertyKey, outError: NSError): boolean;
  static attributesForVoice(voice: NSSpeechSynthesizerVoiceName): NSDictionary<any, any>;

  speaking(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  rate(): number;
  setRate(rate: number): void;
  volume(): number;
  setVolume(volume: number): void;
  usesFeedbackWindow(): boolean;
  setUsesFeedbackWindow(usesFeedbackWindow: boolean): void;
  static anyApplicationSpeaking(): boolean;
  static defaultVoice(): NSSpeechSynthesizerVoiceName;
  static availableVoices(): NSArray<any>;
}

declare interface INSSpeechSynthesizerDelegate {
  speechSynthesizer_didFinishSpeaking(sender: NSSpeechSynthesizer, finishedSpeaking: boolean): void;
  speechSynthesizer_willSpeakWord_ofString(sender: NSSpeechSynthesizer, characterRange: NSRange, string: NSString | string): void;
  speechSynthesizer_willSpeakPhoneme(sender: NSSpeechSynthesizer, phonemeOpcode: number): void;
  speechSynthesizer_didEncounterErrorAtIndex_ofString_message(sender: NSSpeechSynthesizer, characterIndex: NSUInteger, string: NSString | string, message: NSString | string): void;
  speechSynthesizer_didEncounterSyncMessage(sender: NSSpeechSynthesizer, message: NSString | string): void;
}

declare type NSSpeechSynthesizerVoiceName = NSString

declare type NSVoiceAttributeKey = NSString

declare type NSSpeechDictionaryKey = NSString

declare type NSVoiceGenderName = NSString

declare type NSSpeechPropertyKey = NSString

declare type NSSpeechMode = NSString

declare type NSSpeechStatusKey = NSString

declare type NSSpeechErrorKey = NSString

declare type NSSpeechSynthesizerInfoKey = NSString

declare type NSSpeechPhonemeInfoKey = NSString

declare type NSSpeechCommandDelimiterKey = NSString

declare enum NSSpeechBoundary {
  NSSpeechImmediateBoundary = 0,
  NSSpeechWordBoundary,
  NSSpeechSentenceBoundary,
}

class NSSpellCheckerAllocator<T extends NSSpellChecker> extends NSObjectAllocator<T> {}
declare class NSSpellChecker extends NSObject {
  alloc<T extends NSSpellChecker>(): NSSpellCheckerAllocator<T>;
  static uniqueSpellDocumentTag(): NSInteger;
  checkSpellingOfString_startingAt_language_wrap_inSpellDocumentWithTag_wordCount(stringToCheck: NSString | string, startingOffset: NSInteger, language: NSString | string | null, wrapFlag: boolean, tag: NSInteger, wordCount: NSInteger | null): NSRange;
  checkSpellingOfString_startingAt(stringToCheck: NSString | string, startingOffset: NSInteger): NSRange;
  countWordsInString_language(stringToCount: NSString | string, language: NSString | string | null): NSInteger;
  checkGrammarOfString_startingAt_language_wrap_inSpellDocumentWithTag_details(stringToCheck: NSString | string, startingOffset: NSInteger, language: NSString | string | null, wrapFlag: boolean, tag: NSInteger, details: NSArray<any> | any[]): NSRange;
  checkString_range_types_options_inSpellDocumentWithTag_orthography_wordCount(stringToCheck: NSString | string, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, tag: NSInteger, orthography: NSOrthography, wordCount: NSInteger | null): NSArray<any>;
  requestCheckingOfString_range_types_options_inSpellDocumentWithTag_completionHandler(stringToCheck: NSString | string, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, tag: NSInteger, completionHandler: Block): NSInteger;
  requestCandidatesForSelectedRange_inString_types_options_inSpellDocumentWithTag_completionHandler(selectedRange: NSRange, stringToCheck: NSString | string, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any} | null, tag: NSInteger, completionHandler: Block): NSInteger;
  menuForResult_string_options_atLocation_inView(result: NSTextCheckingResult, checkedString: NSString | string, options: NSDictionary<any, any> | {[key: string]: any} | null, location: NSPoint, view: NSView): NSMenu;
  userQuotesArrayForLanguage(language: NSString | string): NSArray<any>;
  updateSpellingPanelWithMisspelledWord(word: NSString | string): void;
  updateSpellingPanelWithGrammarString_detail(string: NSString | string, detail: NSDictionary<any, any> | {[key: string]: any}): void;
  updatePanels(): void;
  ignoreWord_inSpellDocumentWithTag(wordToIgnore: NSString | string, tag: NSInteger): void;
  ignoredWordsInSpellDocumentWithTag(tag: NSInteger): NSArray<any>;
  setIgnoredWords_inSpellDocumentWithTag(words: NSArray<any> | any[], tag: NSInteger): void;
  guessesForWordRange_inString_language_inSpellDocumentWithTag(range: NSRange, string: NSString | string, language: NSString | string | null, tag: NSInteger): NSArray<any>;
  correctionForWordRange_inString_language_inSpellDocumentWithTag(range: NSRange, string: NSString | string, language: NSString | string, tag: NSInteger): NSString;
  completionsForPartialWordRange_inString_language_inSpellDocumentWithTag(range: NSRange, string: NSString | string, language: NSString | string | null, tag: NSInteger): NSArray<any>;
  languageForWordRange_inString_orthography(range: NSRange, string: NSString | string, orthography: NSOrthography | null): NSString;
  closeSpellDocumentWithTag(tag: NSInteger): void;
  recordResponse_toCorrection_forWord_language_inSpellDocumentWithTag(response: NSCorrectionResponse, correction: NSString | string, word: NSString | string, language: NSString | string | null, tag: NSInteger): void;
  showCorrectionIndicatorOfType_primaryString_alternativeStrings_forStringInRect_view_completionHandler(type: NSCorrectionIndicatorType, primaryString: NSString | string, alternativeStrings: NSArray<any> | any[], rectOfTypedString: NSRect, view: NSView, completionBlock: Block): void;
  dismissCorrectionIndicatorForView(view: NSView): void;
  preventsAutocorrectionBeforeString_language(string: NSString | string, language: NSString | string | null): boolean;
  deletesAutospaceBetweenString_andString_language(precedingString: NSString | string, followingString: NSString | string, language: NSString | string | null): boolean;
  setWordFieldStringValue(string: NSString | string): void;
  learnWord(word: NSString | string): void;
  hasLearnedWord(word: NSString | string): boolean;
  unlearnWord(word: NSString | string): void;
  language(): NSString;
  setLanguage(language: NSString | string): boolean;
  guessesForWord(word: NSString | string): NSArray<any>;
  forgetWord(word: NSString | string): void;

  static sharedSpellChecker(): NSSpellChecker;
  static sharedSpellCheckerExists(): boolean;
  userReplacementsDictionary(): NSDictionary<any, any>;
  spellingPanel(): NSPanel;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
  substitutionsPanel(): NSPanel;
  substitutionsPanelAccessoryViewController(): NSViewController;
  setSubstitutionsPanelAccessoryViewController(substitutionsPanelAccessoryViewController: NSViewController): void;
  availableLanguages(): NSArray<any>;
  userPreferredLanguages(): NSArray<any>;
  automaticallyIdentifiesLanguages(): boolean;
  setAutomaticallyIdentifiesLanguages(automaticallyIdentifiesLanguages: boolean): void;
  static automaticTextReplacementEnabled(): boolean;
  static automaticSpellingCorrectionEnabled(): boolean;
  static automaticQuoteSubstitutionEnabled(): boolean;
  static automaticDashSubstitutionEnabled(): boolean;
  static automaticCapitalizationEnabled(): boolean;
  static automaticPeriodSubstitutionEnabled(): boolean;
  static automaticTextCompletionEnabled(): boolean;
}

declare type NSTextCheckingOptionKey = NSString

declare enum NSCorrectionResponse {
  NSCorrectionResponseNone,
  NSCorrectionResponseAccepted,
  NSCorrectionResponseRejected,
  NSCorrectionResponseIgnored,
  NSCorrectionResponseEdited,
  NSCorrectionResponseReverted,
}

declare enum NSCorrectionIndicatorType {
  NSCorrectionIndicatorTypeDefault = 0,
  NSCorrectionIndicatorTypeReversion,
  NSCorrectionIndicatorTypeGuesses,
}

declare interface INSChangeSpelling {
  changeSpelling(sender: any | null): void;
}

declare interface INSIgnoreMisspelledWords {
  ignoreSpelling(sender: any | null): void;
}

class NSSplitViewAllocator<T extends NSSplitView> extends NSViewAllocator<T> {}
declare class NSSplitView extends NSView {
  alloc<T extends NSSplitView>(): NSSplitViewAllocator<T>;
  drawDividerInRect(rect: NSRect): void;
  adjustSubviews(): void;
  isSubviewCollapsed(subview: NSView): boolean;
  minPossiblePositionOfDividerAtIndex(dividerIndex: NSInteger): CGFloat;
  maxPossiblePositionOfDividerAtIndex(dividerIndex: NSInteger): CGFloat;
  setPosition_ofDividerAtIndex(position: CGFloat, dividerIndex: NSInteger): void;
  holdingPriorityForSubviewAtIndex(subviewIndex: NSInteger): NSLayoutPriority;
  setHoldingPriority_forSubviewAtIndex(priority: NSLayoutPriority, subviewIndex: NSInteger): void;
  addArrangedSubview(view: NSView): void;
  insertArrangedSubview_atIndex(view: NSView, index: NSInteger): void;
  removeArrangedSubview(view: NSView): void;
  setIsPaneSplitter(flag: boolean): void;
  isPaneSplitter(): boolean;

  vertical(): boolean;
  setVertical(vertical: boolean): void;
  dividerStyle(): NSSplitViewDividerStyle;
  setDividerStyle(dividerStyle: NSSplitViewDividerStyle): void;
  autosaveName(): NSSplitViewAutosaveName;
  setAutosaveName(autosaveName: NSSplitViewAutosaveName): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  dividerColor(): NSColor;
  dividerThickness(): CGFloat;
  arrangesAllSubviews(): boolean;
  setArrangesAllSubviews(arrangesAllSubviews: boolean): void;
  arrangedSubviews(): NSArray<any>;
}

declare interface INSSplitViewDelegate {
  splitView_canCollapseSubview(splitView: NSSplitView, subview: NSView): boolean;
  splitView_shouldCollapseSubview_forDoubleClickOnDividerAtIndex(splitView: NSSplitView, subview: NSView, dividerIndex: NSInteger): boolean;
  splitView_constrainMinCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMinimumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainMaxCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMaximumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainSplitPosition_ofSubviewAt(splitView: NSSplitView, proposedPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_resizeSubviewsWithOldSize(splitView: NSSplitView, oldSize: NSSize): void;
  splitView_shouldAdjustSizeOfSubview(splitView: NSSplitView, view: NSView): boolean;
  splitView_shouldHideDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): boolean;
  splitView_effectiveRect_forDrawnRect_ofDividerAtIndex(splitView: NSSplitView, proposedEffectiveRect: NSRect, drawnRect: NSRect, dividerIndex: NSInteger): NSRect;
  splitView_additionalEffectiveRectOfDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): NSRect;
  splitViewWillResizeSubviews(notification: NSNotification): void;
  splitViewDidResizeSubviews(notification: NSNotification): void;
}

declare type NSSplitViewAutosaveName = NSString

declare enum NSSplitViewDividerStyle {
  NSSplitViewDividerStyleThick = 1,
  NSSplitViewDividerStyleThin = 2,
  NSSplitViewDividerStylePaneSplitter = 3,
}

class NSSplitViewControllerAllocator<T extends NSSplitViewController> extends NSViewControllerAllocator<T> {}
declare class NSSplitViewController extends NSViewController implements INSSplitViewDelegate, INSUserInterfaceValidations {
  alloc<T extends NSSplitViewController>(): NSSplitViewControllerAllocator<T>;
  addSplitViewItem(splitViewItem: NSSplitViewItem): void;
  insertSplitViewItem_atIndex(splitViewItem: NSSplitViewItem, index: NSInteger): void;
  removeSplitViewItem(splitViewItem: NSSplitViewItem): void;
  splitViewItemForViewController(viewController: NSViewController): NSSplitViewItem;
  validateUserInterfaceItem(item: any): boolean;
  toggleSidebar(sender: any | null): IBAction;
  splitView_canCollapseSubview(splitView: NSSplitView, subview: NSView): boolean;
  splitView_shouldCollapseSubview_forDoubleClickOnDividerAtIndex(splitView: NSSplitView, subview: NSView, dividerIndex: NSInteger): boolean;
  splitView_constrainMinCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMinimumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainMaxCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMaximumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainSplitPosition_ofSubviewAt(splitView: NSSplitView, proposedPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_resizeSubviewsWithOldSize(splitView: NSSplitView, oldSize: NSSize): void;
  splitView_shouldAdjustSizeOfSubview(splitView: NSSplitView, view: NSView): boolean;
  splitView_shouldHideDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): boolean;
  splitView_effectiveRect_forDrawnRect_ofDividerAtIndex(splitView: NSSplitView, proposedEffectiveRect: NSRect, drawnRect: NSRect, dividerIndex: NSInteger): NSRect;
  splitView_additionalEffectiveRectOfDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): NSRect;
  splitViewWillResizeSubviews(notification: NSNotification): void;
  splitViewDidResizeSubviews(notification: NSNotification): void;
  validateUserInterfaceItem(item: any): boolean;
  splitView_canCollapseSubview(splitView: NSSplitView, subview: NSView): boolean;
  splitView_shouldCollapseSubview_forDoubleClickOnDividerAtIndex(splitView: NSSplitView, subview: NSView, dividerIndex: NSInteger): boolean;
  splitView_constrainMinCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMinimumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainMaxCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMaximumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainSplitPosition_ofSubviewAt(splitView: NSSplitView, proposedPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_resizeSubviewsWithOldSize(splitView: NSSplitView, oldSize: NSSize): void;
  splitView_shouldAdjustSizeOfSubview(splitView: NSSplitView, view: NSView): boolean;
  splitView_shouldHideDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): boolean;
  splitView_effectiveRect_forDrawnRect_ofDividerAtIndex(splitView: NSSplitView, proposedEffectiveRect: NSRect, drawnRect: NSRect, dividerIndex: NSInteger): NSRect;
  splitView_additionalEffectiveRectOfDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): NSRect;
  splitViewWillResizeSubviews(notification: NSNotification): void;
  splitViewDidResizeSubviews(notification: NSNotification): void;
  validateUserInterfaceItem(item: any): boolean;

  splitView(): NSSplitView;
  setSplitView(splitView: NSSplitView): void;
  splitViewItems(): NSArray<any>;
  setSplitViewItems(splitViewItems: NSArray<any> | any[]): void;
  minimumThicknessForInlineSidebars(): CGFloat;
  setMinimumThicknessForInlineSidebars(minimumThicknessForInlineSidebars: CGFloat): void;
}

class NSSplitViewItemAllocator<T extends NSSplitViewItem> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSSplitViewItem extends NSObject implements INSAnimatablePropertyContainer, INSCoding {
  alloc<T extends NSSplitViewItem>(): NSSplitViewItemAllocator<T>;
  static splitViewItemWithViewController(viewController: NSViewController): NSSplitViewItem;
  static sidebarWithViewController(viewController: NSViewController): NSSplitViewItem;
  static contentListWithViewController(viewController: NSViewController): NSSplitViewItem;
  animator(): NSSplitViewItem;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  encodeWithCoder(aCoder: NSCoder): void;
  animator(): NSSplitViewItem;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  encodeWithCoder(aCoder: NSCoder): void;

  behavior(): NSSplitViewItemBehavior;
  viewController(): NSViewController;
  setViewController(viewController: NSViewController): void;
  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
  canCollapse(): boolean;
  setCanCollapse(canCollapse: boolean): void;
  collapseBehavior(): NSSplitViewItemCollapseBehavior;
  setCollapseBehavior(collapseBehavior: NSSplitViewItemCollapseBehavior): void;
  minimumThickness(): CGFloat;
  setMinimumThickness(minimumThickness: CGFloat): void;
  maximumThickness(): CGFloat;
  setMaximumThickness(maximumThickness: CGFloat): void;
  preferredThicknessFraction(): CGFloat;
  setPreferredThicknessFraction(preferredThicknessFraction: CGFloat): void;
  holdingPriority(): NSLayoutPriority;
  setHoldingPriority(holdingPriority: NSLayoutPriority): void;
  automaticMaximumThickness(): CGFloat;
  setAutomaticMaximumThickness(automaticMaximumThickness: CGFloat): void;
  springLoaded(): boolean;
  setSpringLoaded(springLoaded: boolean): void;
  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
}

declare enum NSSplitViewItemBehavior {
  NSSplitViewItemBehaviorDefault,
  NSSplitViewItemBehaviorSidebar,
  NSSplitViewItemBehaviorContentList,
}

declare enum NSSplitViewItemCollapseBehavior {
  NSSplitViewItemCollapseBehaviorDefault,
  NSSplitViewItemCollapseBehaviorPreferResizingSplitViewWithFixedSiblings,
  NSSplitViewItemCollapseBehaviorPreferResizingSiblingsWithFixedSplitView,
  NSSplitViewItemCollapseBehaviorUseConstraints,
}

class NSStackViewAllocator<T extends NSStackView> extends NSViewAllocator<T> {}
declare class NSStackView extends NSView {
  alloc<T extends NSStackView>(): NSStackViewAllocator<T>;
  static stackViewWithViews(views: NSArray<any> | any[]): NSStackView;
  setCustomSpacing_afterView(spacing: CGFloat, view: NSView): void;
  customSpacingAfterView(view: NSView): CGFloat;
  addArrangedSubview(view: NSView): void;
  insertArrangedSubview_atIndex(view: NSView, index: NSInteger): void;
  removeArrangedSubview(view: NSView): void;
  setVisibilityPriority_forView(priority: NSStackViewVisibilityPriority, view: NSView): void;
  visibilityPriorityForView(view: NSView): NSStackViewVisibilityPriority;
  clippingResistancePriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setClippingResistancePriority_forOrientation(clippingResistancePriority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  huggingPriorityForOrientation(orientation: NSLayoutConstraintOrientation): NSLayoutPriority;
  setHuggingPriority_forOrientation(huggingPriority: NSLayoutPriority, orientation: NSLayoutConstraintOrientation): void;
  addView_inGravity(view: NSView, gravity: NSStackViewGravity): void;
  insertView_atIndex_inGravity(view: NSView, index: NSUInteger, gravity: NSStackViewGravity): void;
  removeView(view: NSView): void;
  viewsInGravity(gravity: NSStackViewGravity): NSArray<any>;
  setViews_inGravity(views: NSArray<any> | any[], gravity: NSStackViewGravity): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  orientation(): NSUserInterfaceLayoutOrientation;
  setOrientation(orientation: NSUserInterfaceLayoutOrientation): void;
  alignment(): NSLayoutAttribute;
  setAlignment(alignment: NSLayoutAttribute): void;
  edgeInsets(): NSEdgeInsets;
  setEdgeInsets(edgeInsets: NSEdgeInsets): void;
  distribution(): NSStackViewDistribution;
  setDistribution(distribution: NSStackViewDistribution): void;
  spacing(): CGFloat;
  setSpacing(spacing: CGFloat): void;
  detachesHiddenViews(): boolean;
  setDetachesHiddenViews(detachesHiddenViews: boolean): void;
  arrangedSubviews(): NSArray<any>;
  detachedViews(): NSArray<any>;
  views(): NSArray<any>;
  hasEqualSpacing(): boolean;
  setHasEqualSpacing(hasEqualSpacing: boolean): void;
}

declare interface INSStackViewDelegate {
  stackView_willDetachViews(stackView: NSStackView, views: NSArray<any> | any[]): void;
  stackView_didReattachViews(stackView: NSStackView, views: NSArray<any> | any[]): void;
}

declare type NSStackViewVisibilityPriority = number

declare enum NSStackViewGravity {
  NSStackViewGravityTop = 1,
  NSStackViewGravityLeading = 1,
  NSStackViewGravityCenter = 2,
  NSStackViewGravityBottom = 3,
  NSStackViewGravityTrailing = 3,
}

declare enum NSStackViewDistribution {
  NSStackViewDistributionGravityAreas = -1,
  NSStackViewDistributionFill = 0,
  NSStackViewDistributionFillEqually,
  NSStackViewDistributionFillProportionally,
  NSStackViewDistributionEqualSpacing,
  NSStackViewDistributionEqualCentering,
}

class NSStatusBarAllocator<T extends NSStatusBar> extends NSObjectAllocator<T> {}
declare class NSStatusBar extends NSObject {
  alloc<T extends NSStatusBar>(): NSStatusBarAllocator<T>;
  statusItemWithLength(length: CGFloat): NSStatusItem;
  removeStatusItem(item: NSStatusItem): void;

  static systemStatusBar(): NSStatusBar;
  vertical(): boolean;
  thickness(): CGFloat;
}

class NSStatusBarButtonAllocator<T extends NSStatusBarButton> extends NSButtonAllocator<T> {}
declare class NSStatusBarButton extends NSButton {
  alloc<T extends NSStatusBarButton>(): NSStatusBarButtonAllocator<T>;

  appearsDisabled(): boolean;
  setAppearsDisabled(appearsDisabled: boolean): void;
}

class NSStatusItemAllocator<T extends NSStatusItem> extends NSObjectAllocator<T> {}
declare class NSStatusItem extends NSObject {
  alloc<T extends NSStatusItem>(): NSStatusItemAllocator<T>;
  sendActionOn(mask: NSInteger): NSInteger;
  drawStatusBarBackgroundInRect_withHighlight(rect: NSRect, highlight: boolean): void;
  popUpStatusItemMenu(menu: NSMenu): void;

  statusBar(): NSStatusBar;
  length(): CGFloat;
  setLength(length: CGFloat): void;
  menu(): NSMenu;
  setMenu(menu: NSMenu): void;
  button(): NSStatusBarButton;
  behavior(): NSStatusItemBehavior;
  setBehavior(behavior: NSStatusItemBehavior): void;
  visible(): boolean;
  setVisible(visible: boolean): void;
  autosaveName(): NSStatusItemAutosaveName;
  setAutosaveName(autosaveName: NSStatusItemAutosaveName): void;
  action(): string;
  setAction(action: string): void;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  target(): any;
  setTarget(target: any): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  alternateImage(): NSImage;
  setAlternateImage(alternateImage: NSImage): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  highlightMode(): boolean;
  setHighlightMode(highlightMode: boolean): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  view(): NSView;
  setView(view: NSView): void;
}

declare type NSStatusItemAutosaveName = NSString

declare enum NSStatusItemBehavior {
  NSStatusItemBehaviorRemovalAllowed,
  NSStatusItemBehaviorTerminationOnRemoval,
}

class NSStepperAllocator<T extends NSStepper> extends NSControlAllocator<T> {}
declare class NSStepper extends NSControl implements INSAccessibilityStepper {
  alloc<T extends NSStepper>(): NSStepperAllocator<T>;
  accessibilityLabel(): NSString;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityValue(): any;
  accessibilityLabel(): NSString;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityValue(): any;

  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  increment(): number;
  setIncrement(increment: number): void;
  valueWraps(): boolean;
  setValueWraps(valueWraps: boolean): void;
  autorepeat(): boolean;
  setAutorepeat(autorepeat: boolean): void;
}

class NSStepperCellAllocator<T extends NSStepperCell> extends NSActionCellAllocator<T> {}
declare class NSStepperCell extends NSActionCell {
  alloc<T extends NSStepperCell>(): NSStepperCellAllocator<T>;

  minValue(): number;
  setMinValue(minValue: number): void;
  maxValue(): number;
  setMaxValue(maxValue: number): void;
  increment(): number;
  setIncrement(increment: number): void;
  valueWraps(): boolean;
  setValueWraps(valueWraps: boolean): void;
  autorepeat(): boolean;
  setAutorepeat(autorepeat: boolean): void;
}

class NSStoryboardAllocator<T extends NSStoryboard> extends NSObjectAllocator<T> {}
declare class NSStoryboard extends NSObject {
  alloc<T extends NSStoryboard>(): NSStoryboardAllocator<T>;
  static storyboardWithName_bundle(name: NSStoryboardName, storyboardBundleOrNil: NSBundle | null): NSStoryboard;
  instantiateInitialController(): any;
  instantiateControllerWithIdentifier(identifier: NSStoryboardSceneIdentifier): any;

  static mainStoryboard(): NSStoryboard;
}

declare type NSStoryboardName = NSString

declare type NSStoryboardSceneIdentifier = NSString

class NSStoryboardSegueAllocator<T extends NSStoryboardSegue> extends NSObjectAllocator<T> {
  initWithIdentifier_source_destination(identifier: NSStoryboardSegueIdentifier, sourceController: any, destinationController: any): T;
}
declare class NSStoryboardSegue extends NSObject {
  alloc<T extends NSStoryboardSegue>(): NSStoryboardSegueAllocator<T>;
  static segueWithIdentifier_source_destination_performHandler(identifier: NSStoryboardSegueIdentifier, sourceController: any, destinationController: any, performHandler: Block): NSStoryboardSegue;
  perform(): void;

  identifier(): NSStoryboardSegueIdentifier;
  sourceController(): any;
  destinationController(): any;
}

declare interface INSSeguePerforming {
  prepareForSegue_sender(segue: NSStoryboardSegue, sender: any | null): void;
  performSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): void;
  shouldPerformSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): boolean;
}

declare type NSStoryboardSegueIdentifier = NSString

class NSStringDrawingContextAllocator<T extends NSStringDrawingContext> extends NSObjectAllocator<T> {}
declare class NSStringDrawingContext extends NSObject {
  alloc<T extends NSStringDrawingContext>(): NSStringDrawingContextAllocator<T>;

  minimumScaleFactor(): CGFloat;
  setMinimumScaleFactor(minimumScaleFactor: CGFloat): void;
  actualScaleFactor(): CGFloat;
  totalBounds(): NSRect;
}

declare enum NSStringDrawingOptions {
  NSStringDrawingUsesLineFragmentOrigin = 1 << 0,
  NSStringDrawingUsesFontLeading = 1 << 1,
  NSStringDrawingUsesDeviceMetrics = 1 << 3,
  NSStringDrawingTruncatesLastVisibleLine = 1 << 5,
  NSStringDrawingDisableScreenFontSubstitution,
  NSStringDrawingOneShot,
}

class NSTabViewAllocator<T extends NSTabView> extends NSViewAllocator<T> {}
declare class NSTabView extends NSView {
  alloc<T extends NSTabView>(): NSTabViewAllocator<T>;
  selectTabViewItem(tabViewItem: NSTabViewItem | null): void;
  selectTabViewItemAtIndex(index: NSInteger): void;
  selectTabViewItemWithIdentifier(identifier: any): void;
  takeSelectedTabViewItemFromSender(sender: any | null): void;
  selectFirstTabViewItem(sender: any | null): void;
  selectLastTabViewItem(sender: any | null): void;
  selectNextTabViewItem(sender: any | null): void;
  selectPreviousTabViewItem(sender: any | null): void;
  addTabViewItem(tabViewItem: NSTabViewItem): void;
  insertTabViewItem_atIndex(tabViewItem: NSTabViewItem, index: NSInteger): void;
  removeTabViewItem(tabViewItem: NSTabViewItem): void;
  tabViewItemAtPoint(point: NSPoint): NSTabViewItem;
  indexOfTabViewItem(tabViewItem: NSTabViewItem): NSInteger;
  tabViewItemAtIndex(index: NSInteger): NSTabViewItem;
  indexOfTabViewItemWithIdentifier(identifier: any): NSInteger;

  selectedTabViewItem(): NSTabViewItem;
  font(): NSFont;
  setFont(font: NSFont): void;
  tabViewType(): NSTabViewType;
  setTabViewType(tabViewType: NSTabViewType): void;
  tabPosition(): NSTabPosition;
  setTabPosition(tabPosition: NSTabPosition): void;
  tabViewBorderType(): NSTabViewBorderType;
  setTabViewBorderType(tabViewBorderType: NSTabViewBorderType): void;
  tabViewItems(): NSArray<any>;
  allowsTruncatedLabels(): boolean;
  setAllowsTruncatedLabels(allowsTruncatedLabels: boolean): void;
  minimumSize(): NSSize;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  controlTint(): NSControlTint;
  setControlTint(controlTint: NSControlTint): void;
  controlSize(): NSControlSize;
  setControlSize(controlSize: NSControlSize): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  contentRect(): NSRect;
  numberOfTabViewItems(): NSInteger;
}

declare interface INSTabViewDelegate {
  tabView_shouldSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): boolean;
  tabView_willSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabView_didSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabViewDidChangeNumberOfTabViewItems(tabView: NSTabView): void;
}

declare enum NSTabViewType {
  NSTopTabsBezelBorder = 0,
  NSLeftTabsBezelBorder = 1,
  NSBottomTabsBezelBorder = 2,
  NSRightTabsBezelBorder = 3,
  NSNoTabsBezelBorder = 4,
  NSNoTabsLineBorder = 5,
  NSNoTabsNoBorder = 6,
}

declare enum NSTabPosition {
  NSTabPositionNone = 0,
  NSTabPositionTop = 1,
  NSTabPositionLeft = 2,
  NSTabPositionBottom = 3,
  NSTabPositionRight = 4,
}

declare enum NSTabViewBorderType {
  NSTabViewBorderTypeNone = 0,
  NSTabViewBorderTypeLine = 1,
  NSTabViewBorderTypeBezel = 2,
}

class NSTabViewControllerAllocator<T extends NSTabViewController> extends NSViewControllerAllocator<T> {}
declare class NSTabViewController extends NSViewController implements INSTabViewDelegate, INSToolbarDelegate {
  alloc<T extends NSTabViewController>(): NSTabViewControllerAllocator<T>;
  addTabViewItem(tabViewItem: NSTabViewItem): void;
  insertTabViewItem_atIndex(tabViewItem: NSTabViewItem, index: NSInteger): void;
  removeTabViewItem(tabViewItem: NSTabViewItem): void;
  tabViewItemForViewController(viewController: NSViewController): NSTabViewItem;
  tabView_shouldSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): boolean;
  tabView_willSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabView_didSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabViewDidChangeNumberOfTabViewItems(tabView: NSTabView): void;
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;
  tabView_shouldSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): boolean;
  tabView_willSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabView_didSelectTabViewItem(tabView: NSTabView, tabViewItem: NSTabViewItem | null): void;
  tabViewDidChangeNumberOfTabViewItems(tabView: NSTabView): void;
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;

  tabStyle(): NSTabViewControllerTabStyle;
  setTabStyle(tabStyle: NSTabViewControllerTabStyle): void;
  tabView(): NSTabView;
  setTabView(tabView: NSTabView): void;
  transitionOptions(): NSViewControllerTransitionOptions;
  setTransitionOptions(transitionOptions: NSViewControllerTransitionOptions): void;
  canPropagateSelectedChildViewControllerTitle(): boolean;
  setCanPropagateSelectedChildViewControllerTitle(canPropagateSelectedChildViewControllerTitle: boolean): void;
  tabViewItems(): NSArray<any>;
  setTabViewItems(tabViewItems: NSArray<any> | any[]): void;
  selectedTabViewItemIndex(): NSInteger;
  setSelectedTabViewItemIndex(selectedTabViewItemIndex: NSInteger): void;
}

declare enum NSTabViewControllerTabStyle {
  NSTabViewControllerTabStyleSegmentedControlOnTop = 0,
  NSTabViewControllerTabStyleSegmentedControlOnBottom,
  NSTabViewControllerTabStyleToolbar,
  NSTabViewControllerTabStyleUnspecified = -1,
}

class NSTabViewItemAllocator<T extends NSTabViewItem> extends NSObjectAllocator<T> {
  initWithIdentifier(identifier: any | null): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTabViewItem extends NSObject implements INSCoding {
  alloc<T extends NSTabViewItem>(): NSTabViewItemAllocator<T>;
  static tabViewItemWithViewController(viewController: NSViewController): NSTabViewItem;
  drawLabel_inRect(shouldTruncateLabel: boolean, labelRect: NSRect): void;
  sizeOfLabel(computeMin: boolean): NSSize;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  identifier(): any;
  setIdentifier(identifier: any): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  view(): NSView;
  setView(view: NSView): void;
  viewController(): NSViewController;
  setViewController(viewController: NSViewController): void;
  tabState(): NSTabState;
  tabView(): NSTabView;
  initialFirstResponder(): NSView;
  setInitialFirstResponder(initialFirstResponder: NSView): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
}

declare enum NSTabState {
  NSSelectedTab = 0,
  NSBackgroundTab = 1,
  NSPressedTab = 2,
}

class NSTableCellViewAllocator<T extends NSTableCellView> extends NSViewAllocator<T> {}
declare class NSTableCellView extends NSView {
  alloc<T extends NSTableCellView>(): NSTableCellViewAllocator<T>;

  objectValue(): any;
  setObjectValue(objectValue: any): void;
  textField(): NSTextField;
  setTextField(textField: NSTextField): void;
  imageView(): NSImageView;
  setImageView(imageView: NSImageView): void;
  backgroundStyle(): NSBackgroundStyle;
  setBackgroundStyle(backgroundStyle: NSBackgroundStyle): void;
  rowSizeStyle(): NSTableViewRowSizeStyle;
  setRowSizeStyle(rowSizeStyle: NSTableViewRowSizeStyle): void;
  draggingImageComponents(): NSArray<any>;
}

class NSTableColumnAllocator<T extends NSTableColumn> extends NSObjectAllocator<T> {
  initWithIdentifier(identifier: NSUserInterfaceItemIdentifier): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTableColumn extends NSObject implements INSCoding, INSUserInterfaceItemIdentification {
  alloc<T extends NSTableColumn>(): NSTableColumnAllocator<T>;
  sizeToFit(): void;
  setResizable(flag: boolean): void;
  isResizable(): boolean;
  dataCellForRow(row: NSInteger): any;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  width(): CGFloat;
  setWidth(width: CGFloat): void;
  minWidth(): CGFloat;
  setMinWidth(minWidth: CGFloat): void;
  maxWidth(): CGFloat;
  setMaxWidth(maxWidth: CGFloat): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  headerCell(): NSTableHeaderCell;
  setHeaderCell(headerCell: NSTableHeaderCell): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  sortDescriptorPrototype(): NSSortDescriptor;
  setSortDescriptorPrototype(sortDescriptorPrototype: NSSortDescriptor): void;
  resizingMask(): NSTableColumnResizingOptions;
  setResizingMask(resizingMask: NSTableColumnResizingOptions): void;
  headerToolTip(): NSString;
  setHeaderToolTip(headerToolTip: NSString | string): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  dataCell(): any;
  setDataCell(dataCell: any): void;
}

declare enum NSTableColumnResizingOptions {
  NSTableColumnNoResizing = 0,
  NSTableColumnAutoresizingMask,
  NSTableColumnUserResizingMask,
}

class NSTableHeaderCellAllocator<T extends NSTableHeaderCell> extends NSTextFieldCellAllocator<T> {}
declare class NSTableHeaderCell extends NSTextFieldCell {
  alloc<T extends NSTableHeaderCell>(): NSTableHeaderCellAllocator<T>;
  drawSortIndicatorWithFrame_inView_ascending_priority(cellFrame: NSRect, controlView: NSView, ascending: boolean, priority: NSInteger): void;
  sortIndicatorRectForBounds(rect: NSRect): NSRect;
}

class NSTableHeaderViewAllocator<T extends NSTableHeaderView> extends NSViewAllocator<T> {}
declare class NSTableHeaderView extends NSView {
  alloc<T extends NSTableHeaderView>(): NSTableHeaderViewAllocator<T>;
  headerRectOfColumn(column: NSInteger): NSRect;
  columnAtPoint(point: NSPoint): NSInteger;

  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  draggedColumn(): NSInteger;
  draggedDistance(): CGFloat;
  resizedColumn(): NSInteger;
}

class NSTableRowViewAllocator<T extends NSTableRowView> extends NSViewAllocator<T> {}
declare class NSTableRowView extends NSView implements INSAccessibilityRow {
  alloc<T extends NSTableRowView>(): NSTableRowViewAllocator<T>;
  drawBackgroundInRect(dirtyRect: NSRect): void;
  drawSelectionInRect(dirtyRect: NSRect): void;
  drawSeparatorInRect(dirtyRect: NSRect): void;
  drawDraggingDestinationFeedbackInRect(dirtyRect: NSRect): void;
  viewAtColumn(column: NSInteger): any;
  accessibilityIndex(): NSInteger;
  accessibilityDisclosureLevel(): NSInteger;
  accessibilityIndex(): NSInteger;
  accessibilityDisclosureLevel(): NSInteger;

  selectionHighlightStyle(): NSTableViewSelectionHighlightStyle;
  setSelectionHighlightStyle(selectionHighlightStyle: NSTableViewSelectionHighlightStyle): void;
  emphasized(): boolean;
  setEmphasized(emphasized: boolean): void;
  groupRowStyle(): boolean;
  setGroupRowStyle(groupRowStyle: boolean): void;
  selected(): boolean;
  setSelected(selected: boolean): void;
  previousRowSelected(): boolean;
  setPreviousRowSelected(previousRowSelected: boolean): void;
  nextRowSelected(): boolean;
  setNextRowSelected(nextRowSelected: boolean): void;
  floating(): boolean;
  setFloating(floating: boolean): void;
  targetForDropOperation(): boolean;
  setTargetForDropOperation(targetForDropOperation: boolean): void;
  draggingDestinationFeedbackStyle(): NSTableViewDraggingDestinationFeedbackStyle;
  setDraggingDestinationFeedbackStyle(draggingDestinationFeedbackStyle: NSTableViewDraggingDestinationFeedbackStyle): void;
  indentationForDropOperation(): CGFloat;
  setIndentationForDropOperation(indentationForDropOperation: CGFloat): void;
  interiorBackgroundStyle(): NSBackgroundStyle;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  numberOfColumns(): NSInteger;
}

class NSTableViewAllocator<T extends NSTableView> extends NSControlAllocator<T> {}
declare class NSTableView extends NSControl implements INSUserInterfaceValidations, INSTextViewDelegate, INSDraggingSource, INSAccessibilityTable {
  alloc<T extends NSTableView>(): NSTableViewAllocator<T>;
  noteHeightOfRowsWithIndexesChanged(indexSet: NSIndexSet): void;
  addTableColumn(tableColumn: NSTableColumn): void;
  removeTableColumn(tableColumn: NSTableColumn): void;
  moveColumn_toColumn(oldIndex: NSInteger, newIndex: NSInteger): void;
  columnWithIdentifier(identifier: NSUserInterfaceItemIdentifier): NSInteger;
  tableColumnWithIdentifier(identifier: NSUserInterfaceItemIdentifier): NSTableColumn;
  tile(): void;
  sizeToFit(): void;
  sizeLastColumnToFit(): void;
  scrollRowToVisible(row: NSInteger): void;
  scrollColumnToVisible(column: NSInteger): void;
  reloadData(): void;
  noteNumberOfRowsChanged(): void;
  reloadDataForRowIndexes_columnIndexes(rowIndexes: NSIndexSet, columnIndexes: NSIndexSet): void;
  setIndicatorImage_inTableColumn(image: NSImage | null, tableColumn: NSTableColumn): void;
  indicatorImageInTableColumn(tableColumn: NSTableColumn): NSImage;
  canDragRowsWithIndexes_atPoint(rowIndexes: NSIndexSet, mouseDownPoint: NSPoint): boolean;
  dragImageForRowsWithIndexes_tableColumns_event_offset(dragRows: NSIndexSet, tableColumns: NSArray<any> | any[], dragEvent: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  setDraggingSourceOperationMask_forLocal(mask: NSDragOperation, isLocal: boolean): void;
  setDropRow_dropOperation(row: NSInteger, dropOperation: NSTableViewDropOperation): void;
  selectAll(sender: any | null): void;
  deselectAll(sender: any | null): void;
  selectColumnIndexes_byExtendingSelection(indexes: NSIndexSet, extend: boolean): void;
  selectRowIndexes_byExtendingSelection(indexes: NSIndexSet, extend: boolean): void;
  deselectColumn(column: NSInteger): void;
  deselectRow(row: NSInteger): void;
  isColumnSelected(column: NSInteger): boolean;
  isRowSelected(row: NSInteger): boolean;
  rectOfColumn(column: NSInteger): NSRect;
  rectOfRow(row: NSInteger): NSRect;
  columnIndexesInRect(rect: NSRect): NSIndexSet;
  rowsInRect(rect: NSRect): NSRange;
  columnAtPoint(point: NSPoint): NSInteger;
  rowAtPoint(point: NSPoint): NSInteger;
  frameOfCellAtColumn_row(column: NSInteger, row: NSInteger): NSRect;
  editColumn_row_withEvent_select(column: NSInteger, row: NSInteger, event: NSEvent | null, select: boolean): void;
  drawRow_clipRect(row: NSInteger, clipRect: NSRect): void;
  highlightSelectionInClipRect(clipRect: NSRect): void;
  drawGridInClipRect(clipRect: NSRect): void;
  drawBackgroundInClipRect(clipRect: NSRect): void;
  viewAtColumn_row_makeIfNecessary(column: NSInteger, row: NSInteger, makeIfNecessary: boolean): NSView;
  rowViewAtRow_makeIfNecessary(row: NSInteger, makeIfNecessary: boolean): NSTableRowView;
  rowForView(view: NSView): NSInteger;
  columnForView(view: NSView): NSInteger;
  makeViewWithIdentifier_owner(identifier: NSUserInterfaceItemIdentifier, owner: any | null): NSView;
  enumerateAvailableRowViewsUsingBlock(handler: Block): void;
  beginUpdates(): void;
  endUpdates(): void;
  insertRowsAtIndexes_withAnimation(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  removeRowsAtIndexes_withAnimation(indexes: NSIndexSet, animationOptions: NSTableViewAnimationOptions): void;
  moveRowAtIndex_toIndex(oldIndex: NSInteger, newIndex: NSInteger): void;
  hideRowsAtIndexes_withAnimation(indexes: NSIndexSet, rowAnimation: NSTableViewAnimationOptions): void;
  unhideRowsAtIndexes_withAnimation(indexes: NSIndexSet, rowAnimation: NSTableViewAnimationOptions): void;
  registerNib_forIdentifier(nib: NSNib | null, identifier: NSUserInterfaceItemIdentifier): void;
  didAddRowView_forRow(rowView: NSTableRowView, row: NSInteger): void;
  didRemoveRowView_forRow(rowView: NSTableRowView, row: NSInteger): void;
  setDrawsGrid(flag: boolean): void;
  drawsGrid(): boolean;
  selectColumn_byExtendingSelection(column: NSInteger, extend: boolean): void;
  selectRow_byExtendingSelection(row: NSInteger, extend: boolean): void;
  selectedColumnEnumerator(): NSEnumerator<any>;
  selectedRowEnumerator(): NSEnumerator<any>;
  dragImageForRows_event_dragImageOffset(dragRows: NSArray<any> | any[], dragEvent: NSEvent, dragImageOffset: NSPointPointer): NSImage;
  setAutoresizesAllColumnsToFit(flag: boolean): void;
  autoresizesAllColumnsToFit(): boolean;
  columnsInRect(rect: NSRect): NSRange;
  preparedCellAtColumn_row(column: NSInteger, row: NSInteger): NSCell;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  shouldFocusCell_atColumn_row(cell: NSCell, column: NSInteger, row: NSInteger): boolean;
  focusedColumn(): NSInteger;
  setFocusedColumn(focusedColumn: NSInteger): void;
  performClickOnCellAtColumn_row(column: NSInteger, row: NSInteger): void;
  selectRow_extendSelection(rowIndex: NSInteger, flag: boolean): void;
  validateUserInterfaceItem(item: any): boolean;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  validateUserInterfaceItem(item: any): boolean;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  headerView(): NSTableHeaderView;
  setHeaderView(headerView: NSTableHeaderView): void;
  cornerView(): NSView;
  setCornerView(cornerView: NSView): void;
  allowsColumnReordering(): boolean;
  setAllowsColumnReordering(allowsColumnReordering: boolean): void;
  allowsColumnResizing(): boolean;
  setAllowsColumnResizing(allowsColumnResizing: boolean): void;
  columnAutoresizingStyle(): NSTableViewColumnAutoresizingStyle;
  setColumnAutoresizingStyle(columnAutoresizingStyle: NSTableViewColumnAutoresizingStyle): void;
  gridStyleMask(): NSTableViewGridLineStyle;
  setGridStyleMask(gridStyleMask: NSTableViewGridLineStyle): void;
  intercellSpacing(): NSSize;
  setIntercellSpacing(intercellSpacing: NSSize): void;
  usesAlternatingRowBackgroundColors(): boolean;
  setUsesAlternatingRowBackgroundColors(usesAlternatingRowBackgroundColors: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  gridColor(): NSColor;
  setGridColor(gridColor: NSColor): void;
  rowSizeStyle(): NSTableViewRowSizeStyle;
  setRowSizeStyle(rowSizeStyle: NSTableViewRowSizeStyle): void;
  effectiveRowSizeStyle(): NSTableViewRowSizeStyle;
  rowHeight(): CGFloat;
  setRowHeight(rowHeight: CGFloat): void;
  tableColumns(): NSArray<any>;
  numberOfColumns(): NSInteger;
  numberOfRows(): NSInteger;
  editedColumn(): NSInteger;
  editedRow(): NSInteger;
  clickedColumn(): NSInteger;
  clickedRow(): NSInteger;
  doubleAction(): string;
  setDoubleAction(doubleAction: string): void;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  highlightedTableColumn(): NSTableColumn;
  setHighlightedTableColumn(highlightedTableColumn: NSTableColumn): void;
  verticalMotionCanBeginDrag(): boolean;
  setVerticalMotionCanBeginDrag(verticalMotionCanBeginDrag: boolean): void;
  allowsMultipleSelection(): boolean;
  setAllowsMultipleSelection(allowsMultipleSelection: boolean): void;
  allowsEmptySelection(): boolean;
  setAllowsEmptySelection(allowsEmptySelection: boolean): void;
  allowsColumnSelection(): boolean;
  setAllowsColumnSelection(allowsColumnSelection: boolean): void;
  selectedColumnIndexes(): NSIndexSet;
  selectedRowIndexes(): NSIndexSet;
  selectedColumn(): NSInteger;
  selectedRow(): NSInteger;
  numberOfSelectedColumns(): NSInteger;
  numberOfSelectedRows(): NSInteger;
  allowsTypeSelect(): boolean;
  setAllowsTypeSelect(allowsTypeSelect: boolean): void;
  selectionHighlightStyle(): NSTableViewSelectionHighlightStyle;
  setSelectionHighlightStyle(selectionHighlightStyle: NSTableViewSelectionHighlightStyle): void;
  draggingDestinationFeedbackStyle(): NSTableViewDraggingDestinationFeedbackStyle;
  setDraggingDestinationFeedbackStyle(draggingDestinationFeedbackStyle: NSTableViewDraggingDestinationFeedbackStyle): void;
  autosaveName(): NSTableViewAutosaveName;
  setAutosaveName(autosaveName: NSTableViewAutosaveName): void;
  autosaveTableColumns(): boolean;
  setAutosaveTableColumns(autosaveTableColumns: boolean): void;
  floatsGroupRows(): boolean;
  setFloatsGroupRows(floatsGroupRows: boolean): void;
  rowActionsVisible(): boolean;
  setRowActionsVisible(rowActionsVisible: boolean): void;
  hiddenRowIndexes(): NSIndexSet;
  registeredNibsByIdentifier(): NSDictionary<any, any>;
  usesStaticContents(): boolean;
  setUsesStaticContents(usesStaticContents: boolean): void;
  userInterfaceLayoutDirection(): NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection): void;
  usesAutomaticRowHeights(): boolean;
  setUsesAutomaticRowHeights(usesAutomaticRowHeights: boolean): void;
}

declare interface INSTableViewDelegate {
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
}

declare interface INSTableViewDataSource {
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
}

declare type NSTableViewAutosaveName = NSString

declare enum NSTableViewDropOperation {
  NSTableViewDropOn,
  NSTableViewDropAbove,
}

declare enum NSTableViewColumnAutoresizingStyle {
  NSTableViewNoColumnAutoresizing = 0,
  NSTableViewUniformColumnAutoresizingStyle,
  NSTableViewSequentialColumnAutoresizingStyle,
  NSTableViewReverseSequentialColumnAutoresizingStyle,
  NSTableViewLastColumnOnlyAutoresizingStyle,
  NSTableViewFirstColumnOnlyAutoresizingStyle,
}

declare enum NSTableViewGridLineStyle {
  NSTableViewGridNone = 0,
  NSTableViewSolidVerticalGridLineMask = 1 << 0,
  NSTableViewSolidHorizontalGridLineMask = 1 << 1,
  NSTableViewDashedHorizontalGridLineMask = 1 << 3,
}

declare enum NSTableViewRowSizeStyle {
  NSTableViewRowSizeStyleDefault = -1,
  NSTableViewRowSizeStyleCustom = 0,
  NSTableViewRowSizeStyleSmall = 1,
  NSTableViewRowSizeStyleMedium = 2,
  NSTableViewRowSizeStyleLarge = 3,
}

declare enum NSTableViewSelectionHighlightStyle {
  NSTableViewSelectionHighlightStyleNone = -1,
  NSTableViewSelectionHighlightStyleRegular = 0,
  NSTableViewSelectionHighlightStyleSourceList = 1,
}

declare enum NSTableViewDraggingDestinationFeedbackStyle {
  NSTableViewDraggingDestinationFeedbackStyleNone = -1,
  NSTableViewDraggingDestinationFeedbackStyleRegular = 0,
  NSTableViewDraggingDestinationFeedbackStyleSourceList = 1,
  NSTableViewDraggingDestinationFeedbackStyleGap = 2,
}

declare enum NSTableRowActionEdge {
  NSTableRowActionEdgeLeading,
  NSTableRowActionEdgeTrailing,
}

declare enum NSTableViewAnimationOptions {
  NSTableViewAnimationEffectNone = 0x0,
  NSTableViewAnimationEffectFade = 0x1,
  NSTableViewAnimationEffectGap = 0x2,
  NSTableViewAnimationSlideUp = 0x10,
  NSTableViewAnimationSlideDown = 0x20,
  NSTableViewAnimationSlideLeft = 0x30,
  NSTableViewAnimationSlideRight = 0x40,
}

class NSTableViewRowActionAllocator<T extends NSTableViewRowAction> extends NSObjectAllocator<T> {}
declare class NSTableViewRowAction extends NSObject implements INSCopying {
  alloc<T extends NSTableViewRowAction>(): NSTableViewRowActionAllocator<T>;
  static rowActionWithStyle_title_handler(style: NSTableViewRowActionStyle, title: NSString | string, handler: Block): NSTableViewRowAction;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  style(): NSTableViewRowActionStyle;
  title(): NSString;
  setTitle(title: NSString | string): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  image(): NSImage;
  setImage(image: NSImage): void;
}

declare enum NSTableViewRowActionStyle {
  NSTableViewRowActionStyleRegular,
  NSTableViewRowActionStyleDestructive,
}

class NSTextAllocator<T extends NSText> extends NSViewAllocator<T> {}
declare class NSText extends NSView implements INSChangeSpelling, INSIgnoreMisspelledWords {
  alloc<T extends NSText>(): NSTextAllocator<T>;
  replaceCharactersInRange_withString(range: NSRange, string: NSString | string): void;
  replaceCharactersInRange_withRTF(range: NSRange, rtfData: NSData): void;
  replaceCharactersInRange_withRTFD(range: NSRange, rtfdData: NSData): void;
  RTFFromRange(range: NSRange): NSData;
  RTFDFromRange(range: NSRange): NSData;
  writeRTFDToFile_atomically(path: NSString | string, flag: boolean): boolean;
  readRTFDFromFile(path: NSString | string): boolean;
  scrollRangeToVisible(range: NSRange): void;
  setTextColor_range(color: NSColor | null, range: NSRange): void;
  setFont_range(font: NSFont, range: NSRange): void;
  sizeToFit(): void;
  copy(sender: any | null): void;
  copyFont(sender: any | null): void;
  copyRuler(sender: any | null): void;
  cut(sender: any | null): void;
  delete(sender: any | null): void;
  paste(sender: any | null): void;
  pasteFont(sender: any | null): void;
  pasteRuler(sender: any | null): void;
  selectAll(sender: any | null): void;
  changeFont(sender: any | null): void;
  alignLeft(sender: any | null): void;
  alignRight(sender: any | null): void;
  alignCenter(sender: any | null): void;
  subscript(sender: any | null): void;
  superscript(sender: any | null): void;
  underline(sender: any | null): void;
  unscript(sender: any | null): void;
  showGuessPanel(sender: any | null): void;
  checkSpelling(sender: any | null): void;
  toggleRuler(sender: any | null): void;
  changeSpelling(sender: any | null): void;
  ignoreSpelling(sender: any | null): void;
  changeSpelling(sender: any | null): void;
  ignoreSpelling(sender: any | null): void;

  string(): NSString;
  setString(string: NSString | string): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  richText(): boolean;
  setRichText(richText: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
  fieldEditor(): boolean;
  setFieldEditor(fieldEditor: boolean): void;
  usesFontPanel(): boolean;
  setUsesFontPanel(usesFontPanel: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  rulerVisible(): boolean;
  selectedRange(): NSRange;
  setSelectedRange(selectedRange: NSRange): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  baseWritingDirection(): NSWritingDirection;
  setBaseWritingDirection(baseWritingDirection: NSWritingDirection): void;
  maxSize(): NSSize;
  setMaxSize(maxSize: NSSize): void;
  minSize(): NSSize;
  setMinSize(minSize: NSSize): void;
  horizontallyResizable(): boolean;
  setHorizontallyResizable(horizontallyResizable: boolean): void;
  verticallyResizable(): boolean;
  setVerticallyResizable(verticallyResizable: boolean): void;
}

declare interface INSTextDelegate {
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
}

declare enum NSTextAlignment {
  NSTextAlignmentLeft = 0,
  NSTextAlignmentRight = 1,
  NSTextAlignmentCenter = 2,
  NSTextAlignmentJustified = 3,
  NSTextAlignmentNatural = 4,
}

declare enum NSWritingDirection {
  NSWritingDirectionNatural = -1,
  NSWritingDirectionLeftToRight = 0,
  NSWritingDirectionRightToLeft = 1,
}

declare enum NSTextMovement {
  NSTextMovementReturn = 0x10,
  NSTextMovementTab = 0x11,
  NSTextMovementBacktab = 0x12,
  NSTextMovementLeft = 0x13,
  NSTextMovementRight = 0x14,
  NSTextMovementUp = 0x15,
  NSTextMovementDown = 0x16,
  NSTextMovementCancel = 0x17,
  NSTextMovementOther = 0,
}

class NSTextAlternativesAllocator<T extends NSTextAlternatives> extends NSObjectAllocator<T> {
  initWithPrimaryString_alternativeStrings(primaryString: NSString | string, alternativeStrings: NSArray<any> | any[]): T;
}
declare class NSTextAlternatives extends NSObject {
  alloc<T extends NSTextAlternatives>(): NSTextAlternativesAllocator<T>;
  noteSelectedAlternativeString(alternativeString: NSString | string): void;

  primaryString(): NSString;
  alternativeStrings(): NSArray<any>;
}

class NSTextAttachmentAllocator<T extends NSTextAttachment> extends NSObjectAllocator<T> {
  initWithData_ofType(contentData: NSData | null, uti: NSString | string | null): T;
  initWithFileWrapper(fileWrapper: NSFileWrapper | null): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTextAttachment extends NSObject implements INSTextAttachmentContainer, INSCoding {
  alloc<T extends NSTextAttachment>(): NSTextAttachmentAllocator<T>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  contents(): NSData;
  setContents(contents: NSData): void;
  fileType(): NSString;
  setFileType(fileType: NSString | string): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  bounds(): NSRect;
  setBounds(bounds: NSRect): void;
  fileWrapper(): NSFileWrapper;
  setFileWrapper(fileWrapper: NSFileWrapper): void;
  attachmentCell(): any;
  setAttachmentCell(attachmentCell: any): void;
}

class NSTextAttachmentCellAllocator<T extends NSTextAttachmentCell> extends NSCellAllocator<T> {}
declare class NSTextAttachmentCell extends NSCell implements INSTextAttachmentCell {
  alloc<T extends NSTextAttachmentCell>(): NSTextAttachmentCellAllocator<T>;
  drawWithFrame_inView(cellFrame: NSRect, controlView: NSView | null): void;
  wantsToTrackMouse(): boolean;
  highlight_withFrame_inView(flag: boolean, cellFrame: NSRect, controlView: NSView | null): void;
  trackMouse_inRect_ofView_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, flag: boolean): boolean;
  cellSize(): NSSize;
  cellBaselineOffset(): NSPoint;
  drawWithFrame_inView_characterIndex(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): void;
  drawWithFrame_inView_characterIndex_layoutManager(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, layoutManager: NSLayoutManager): void;
  wantsToTrackMouseForEvent_inRect_ofView_atCharacterIndex(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): boolean;
  trackMouse_inRect_ofView_atCharacterIndex_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, flag: boolean): boolean;
  cellFrameForTextContainer_proposedLineFragment_glyphPosition_characterIndex(textContainer: NSTextContainer, lineFrag: NSRect, position: NSPoint, charIndex: NSUInteger): NSRect;
  drawWithFrame_inView(cellFrame: NSRect, controlView: NSView | null): void;
  wantsToTrackMouse(): boolean;
  highlight_withFrame_inView(flag: boolean, cellFrame: NSRect, controlView: NSView | null): void;
  trackMouse_inRect_ofView_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, flag: boolean): boolean;
  cellSize(): NSSize;
  cellBaselineOffset(): NSPoint;
  drawWithFrame_inView_characterIndex(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): void;
  drawWithFrame_inView_characterIndex_layoutManager(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, layoutManager: NSLayoutManager): void;
  wantsToTrackMouseForEvent_inRect_ofView_atCharacterIndex(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): boolean;
  trackMouse_inRect_ofView_atCharacterIndex_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, flag: boolean): boolean;
  cellFrameForTextContainer_proposedLineFragment_glyphPosition_characterIndex(textContainer: NSTextContainer, lineFrag: NSRect, position: NSPoint, charIndex: NSUInteger): NSRect;

  attachment(): NSTextAttachment;
  setAttachment(attachment: NSTextAttachment): void;
}

declare interface INSTextAttachmentCell {
  drawWithFrame_inView(cellFrame: NSRect, controlView: NSView | null): void;
  wantsToTrackMouse(): boolean;
  highlight_withFrame_inView(flag: boolean, cellFrame: NSRect, controlView: NSView | null): void;
  trackMouse_inRect_ofView_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, flag: boolean): boolean;
  cellSize(): NSSize;
  cellBaselineOffset(): NSPoint;
  drawWithFrame_inView_characterIndex(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): void;
  drawWithFrame_inView_characterIndex_layoutManager(cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, layoutManager: NSLayoutManager): void;
  wantsToTrackMouseForEvent_inRect_ofView_atCharacterIndex(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger): boolean;
  trackMouse_inRect_ofView_atCharacterIndex_untilMouseUp(theEvent: NSEvent, cellFrame: NSRect, controlView: NSView | null, charIndex: NSUInteger, flag: boolean): boolean;
  cellFrameForTextContainer_proposedLineFragment_glyphPosition_characterIndex(textContainer: NSTextContainer, lineFrag: NSRect, position: NSPoint, charIndex: NSUInteger): NSRect;

  attachment(): NSTextAttachment;
  setAttachment(attachment: NSTextAttachment): void;
}

class NSTextContainerAllocator<T extends NSTextContainer> extends NSObjectAllocator<T> {
  initWithSize(size: NSSize): T;
  initWithCoder(coder: NSCoder): T;
  initWithContainerSize(aContainerSize: NSSize): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTextContainer extends NSObject implements INSCoding, INSTextLayoutOrientationProvider {
  alloc<T extends NSTextContainer>(): NSTextContainerAllocator<T>;
  replaceLayoutManager(newLayoutManager: NSLayoutManager): void;
  lineFragmentRectForProposedRect_atIndex_writingDirection_remainingRect(proposedRect: NSRect, characterIndex: NSUInteger, baseWritingDirection: NSWritingDirection, remainingRect: NSRect | null): NSRect;
  lineFragmentRectForProposedRect_sweepDirection_movementDirection_remainingRect(proposedRect: NSRect, sweepDirection: NSLineSweepDirection, movementDirection: NSLineMovementDirection, remainingRect: NSRectPointer | null): NSRect;
  containsPoint(point: NSPoint): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  layoutManager(): NSLayoutManager;
  setLayoutManager(layoutManager: NSLayoutManager): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  exclusionPaths(): NSArray<any>;
  setExclusionPaths(exclusionPaths: NSArray<any> | any[]): void;
  lineBreakMode(): NSLineBreakMode;
  setLineBreakMode(lineBreakMode: NSLineBreakMode): void;
  lineFragmentPadding(): CGFloat;
  setLineFragmentPadding(lineFragmentPadding: CGFloat): void;
  maximumNumberOfLines(): NSUInteger;
  setMaximumNumberOfLines(maximumNumberOfLines: NSUInteger): void;
  simpleRectangularTextContainer(): boolean;
  widthTracksTextView(): boolean;
  setWidthTracksTextView(widthTracksTextView: boolean): void;
  heightTracksTextView(): boolean;
  setHeightTracksTextView(heightTracksTextView: boolean): void;
  textView(): NSTextView;
  setTextView(textView: NSTextView): void;
  containerSize(): NSSize;
  setContainerSize(containerSize: NSSize): void;
}

declare enum NSLineSweepDirection {
  NSLineSweepLeft = 0,
  NSLineSweepRight = 1,
  NSLineSweepDown = 2,
  NSLineSweepUp = 3,
}

declare enum NSLineMovementDirection {
  NSLineDoesntMove = 0,
  NSLineMovesLeft = 1,
  NSLineMovesRight = 2,
  NSLineMovesDown = 3,
  NSLineMovesUp = 4,
}

class NSTextFieldAllocator<T extends NSTextField> extends NSControlAllocator<T> {}
declare class NSTextField extends NSControl implements INSUserInterfaceValidations, INSAccessibilityNavigableStaticText {
  alloc<T extends NSTextField>(): NSTextFieldAllocator<T>;
  selectText(sender: any | null): void;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  static labelWithString(stringValue: NSString | string): NSTextField;
  static wrappingLabelWithString(stringValue: NSString | string): NSTextField;
  static labelWithAttributedString(attributedStringValue: NSAttributedString): NSTextField;
  static textFieldWithString(stringValue: NSString | string): NSTextField;
  setTitleWithMnemonic(stringWithAmpersand: NSString | string): void;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityRangeForLine(lineNumber: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  validateUserInterfaceItem(item: any): boolean;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityRangeForLine(lineNumber: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;

  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  bordered(): boolean;
  setBordered(bordered: boolean): void;
  bezeled(): boolean;
  setBezeled(bezeled: boolean): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  acceptsFirstResponder(): boolean;
  bezelStyle(): NSTextFieldBezelStyle;
  setBezelStyle(bezelStyle: NSTextFieldBezelStyle): void;
  preferredMaxLayoutWidth(): CGFloat;
  setPreferredMaxLayoutWidth(preferredMaxLayoutWidth: CGFloat): void;
  maximumNumberOfLines(): NSInteger;
  setMaximumNumberOfLines(maximumNumberOfLines: NSInteger): void;
  allowsDefaultTighteningForTruncation(): boolean;
  setAllowsDefaultTighteningForTruncation(allowsDefaultTighteningForTruncation: boolean): void;
  automaticTextCompletionEnabled(): boolean;
  setAutomaticTextCompletionEnabled(automaticTextCompletionEnabled: boolean): void;
  allowsCharacterPickerTouchBarItem(): boolean;
  setAllowsCharacterPickerTouchBarItem(allowsCharacterPickerTouchBarItem: boolean): void;
  allowsEditingTextAttributes(): boolean;
  setAllowsEditingTextAttributes(allowsEditingTextAttributes: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
}

declare interface INSTextFieldDelegate {
  textField_textView_candidatesForSelectedRange(textField: NSTextField, textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textField_textView_candidates_forSelectedRange(textField: NSTextField, textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textField_textView_shouldSelectCandidateAtIndex(textField: NSTextField, textView: NSTextView, index: NSUInteger): boolean;
}

class NSTextFieldCellAllocator<T extends NSTextFieldCell> extends NSActionCellAllocator<T> {}
declare class NSTextFieldCell extends NSActionCell {
  alloc<T extends NSTextFieldCell>(): NSTextFieldCellAllocator<T>;
  setUpFieldEditorAttributes(textObj: NSText): NSText;
  setWantsNotificationForMarkedText(flag: boolean): void;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  textColor(): NSColor;
  setTextColor(textColor: NSColor): void;
  bezelStyle(): NSTextFieldBezelStyle;
  setBezelStyle(bezelStyle: NSTextFieldBezelStyle): void;
  placeholderString(): NSString;
  setPlaceholderString(placeholderString: NSString | string): void;
  placeholderAttributedString(): NSAttributedString;
  setPlaceholderAttributedString(placeholderAttributedString: NSAttributedString): void;
  allowedInputSourceLocales(): NSArray<any>;
  setAllowedInputSourceLocales(allowedInputSourceLocales: NSArray<any> | any[]): void;
}

declare enum NSTextFieldBezelStyle {
  NSTextFieldSquareBezel = 0,
  NSTextFieldRoundedBezel = 1,
}

class NSTextFinderAllocator<T extends NSTextFinder> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(decoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTextFinder extends NSObject implements INSCoding {
  alloc<T extends NSTextFinder>(): NSTextFinderAllocator<T>;
  performAction(op: NSTextFinderAction): void;
  validateAction(op: NSTextFinderAction): boolean;
  cancelFindIndicator(): void;
  static drawIncrementalMatchHighlightInRect(rect: NSRect): void;
  noteClientStringWillChange(): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  client(): any;
  setClient(client: any): void;
  findBarContainer(): any;
  setFindBarContainer(findBarContainer: any): void;
  findIndicatorNeedsUpdate(): boolean;
  setFindIndicatorNeedsUpdate(findIndicatorNeedsUpdate: boolean): void;
  incrementalSearchingEnabled(): boolean;
  setIncrementalSearchingEnabled(incrementalSearchingEnabled: boolean): void;
  incrementalSearchingShouldDimContentView(): boolean;
  setIncrementalSearchingShouldDimContentView(incrementalSearchingShouldDimContentView: boolean): void;
  incrementalMatchRanges(): NSArray<any>;
}

declare interface INSTextFinderClient {
  stringAtIndex_effectiveRange_endsWithSearchBoundary(characterIndex: NSUInteger, outRange: NSRangePointer, outFlag: boolean): NSString;
  stringLength(): NSUInteger;
  scrollRangeToVisible(range: NSRange): void;
  shouldReplaceCharactersInRanges_withStrings(ranges: NSArray<any> | any[], strings: NSArray<any> | any[]): boolean;
  replaceCharactersInRange_withString(range: NSRange, string: NSString | string): void;
  didReplaceCharacters(): void;
  contentViewAtIndex_effectiveCharacterRange(index: NSUInteger, outRange: NSRangePointer): NSView;
  rectsForCharacterRange(range: NSRange): NSArray<any>;
  drawCharactersInRange_forContentView(range: NSRange, view: NSView): void;

  selectable(): boolean;
  allowsMultipleSelection(): boolean;
  editable(): boolean;
  string(): NSString;
  firstSelectedRange(): NSRange;
  selectedRanges(): NSArray<any>;
  setSelectedRanges(selectedRanges: NSArray<any> | any[]): void;
  visibleCharacterRanges(): NSArray<any>;
}

declare interface INSTextFinderBarContainer {
  findBarViewDidChangeHeight(): void;
  contentView(): NSView;

  findBarView(): NSView;
  setFindBarView(findBarView: NSView): void;
  findBarVisible(): boolean;
  setFindBarVisible(findBarVisible: boolean): void;
}

declare type NSPasteboardTypeTextFinderOptionKey = NSString

declare enum NSTextFinderAction {
  NSTextFinderActionShowFindInterface = 1,
  NSTextFinderActionNextMatch = 2,
  NSTextFinderActionPreviousMatch = 3,
  NSTextFinderActionReplaceAll = 4,
  NSTextFinderActionReplace = 5,
  NSTextFinderActionReplaceAndFind = 6,
  NSTextFinderActionSetSearchString = 7,
  NSTextFinderActionReplaceAllInSelection = 8,
  NSTextFinderActionSelectAll = 9,
  NSTextFinderActionSelectAllInSelection = 10,
  NSTextFinderActionHideFindInterface = 11,
  NSTextFinderActionShowReplaceInterface = 12,
  NSTextFinderActionHideReplaceInterface = 13,
}

declare enum NSTextFinderMatchingType {
  NSTextFinderMatchingTypeContains = 0,
  NSTextFinderMatchingTypeStartsWith = 1,
  NSTextFinderMatchingTypeFullWord = 2,
  NSTextFinderMatchingTypeEndsWith = 3,
}

declare interface INSTextInputClient {
  insertText_replacementRange(string: any, replacementRange: NSRange): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange_replacementRange(string: any, selectedRange: NSRange, replacementRange: NSRange): void;
  unmarkText(): void;
  selectedRange(): NSRange;
  markedRange(): NSRange;
  hasMarkedText(): boolean;
  attributedSubstringForProposedRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSAttributedString;
  validAttributesForMarkedText(): NSArray<any>;
  firstRectForCharacterRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  attributedString(): NSAttributedString;
  fractionOfDistanceThroughGlyphForPoint(point: NSPoint): CGFloat;
  baselineDeltaForCharacterAtIndex(anIndex: NSUInteger): CGFloat;
  windowLevel(): NSInteger;
  drawsVerticallyForCharacterAtIndex(charIndex: NSUInteger): boolean;
}

class NSTextInputContextAllocator<T extends NSTextInputContext> extends NSObjectAllocator<T> {
  initWithClient(client: any): T;
}
declare class NSTextInputContext extends NSObject {
  alloc<T extends NSTextInputContext>(): NSTextInputContextAllocator<T>;
  activate(): void;
  deactivate(): void;
  handleEvent(event: NSEvent): boolean;
  discardMarkedText(): void;
  invalidateCharacterCoordinates(): void;
  static localizedNameForInputSource(inputSourceIdentifier: NSTextInputSourceIdentifier): NSString;

  static currentInputContext(): NSTextInputContext;
  client(): any;
  acceptsGlyphInfo(): boolean;
  setAcceptsGlyphInfo(acceptsGlyphInfo: boolean): void;
  allowedInputSourceLocales(): NSArray<any>;
  setAllowedInputSourceLocales(allowedInputSourceLocales: NSArray<any> | any[]): void;
  keyboardInputSources(): NSArray<any>;
  selectedKeyboardInputSource(): NSTextInputSourceIdentifier;
  setSelectedKeyboardInputSource(selectedKeyboardInputSource: NSTextInputSourceIdentifier): void;
}

declare type NSTextInputSourceIdentifier = NSString

class NSTextListAllocator<T extends NSTextList> extends NSObjectAllocator<T> {
  initWithMarkerFormat_options(format: NSTextListMarkerFormat, mask: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTextList extends NSObject implements INSCoding, INSCopying {
  alloc<T extends NSTextList>(): NSTextListAllocator<T>;
  markerForItemNumber(itemNum: NSInteger): NSString;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;

  markerFormat(): NSTextListMarkerFormat;
  listOptions(): NSTextListOptions;
  startingItemNumber(): NSInteger;
  setStartingItemNumber(startingItemNumber: NSInteger): void;
}

declare type NSTextListMarkerFormat = NSString

declare enum NSTextListOptions {
  NSTextListPrependEnclosingMarker,
}

class NSTextStorageAllocator<T extends NSTextStorage> extends NSMutableAttributedStringAllocator<T> {}
declare class NSTextStorage extends NSMutableAttributedString {
  alloc<T extends NSTextStorage>(): NSTextStorageAllocator<T>;
  addLayoutManager(aLayoutManager: NSLayoutManager): void;
  removeLayoutManager(aLayoutManager: NSLayoutManager): void;
  edited_range_changeInLength(editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  processEditing(): void;
  invalidateAttributesInRange(range: NSRange): void;
  ensureAttributesAreFixedInRange(range: NSRange): void;
  copyTextStorage(): any;
  boundsForTextBehaviour_original(behaviour: BCTextBehaviourType, rect: NSRect): NSRect;
  glyphBounds(): NSRect;
  attributeValuesByRangeForKey(key: NSString | string): NSDictionary<any, any>;
  attributeValuesByRangeForKey_range(key: NSString | string, rangeToExamine: NSRange): NSDictionary<any, any>;
  setAttributeValuesByRange_forKey(valuesByRange: NSDictionary<any, any> | {[key: string]: any}, key: NSString | string): void;

  layoutManagers(): NSArray<any>;
  editedMask(): NSTextStorageEditActions;
  editedRange(): NSRange;
  changeInLength(): NSInteger;
  delegate(): any;
  setDelegate(delegate: any): void;
  fixesAttributesLazily(): boolean;
  attributeRuns(): NSArray<any>;
  setAttributeRuns(attributeRuns: NSArray<any> | any[]): void;
  paragraphs(): NSArray<any>;
  setParagraphs(paragraphs: NSArray<any> | any[]): void;
  words(): NSArray<any>;
  setWords(words: NSArray<any> | any[]): void;
  characters(): NSArray<any>;
  setCharacters(characters: NSArray<any> | any[]): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  foregroundColor(): NSColor;
  setForegroundColor(foregroundColor: NSColor): void;
}

declare interface INSTextStorageDelegate {
  textStorage_willProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  textStorage_didProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
}

declare type NSTextStorageEditedOptions = NSUInteger

declare enum NSTextStorageEditActions {
  NSTextStorageEditedAttributes,
  NSTextStorageEditedCharacters,
}

class NSTextBlockAllocator<T extends NSTextBlock> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTextBlock extends NSObject implements INSCoding, INSCopying {
  alloc<T extends NSTextBlock>(): NSTextBlockAllocator<T>;
  setValue_type_forDimension(val: CGFloat, type: NSTextBlockValueType, dimension: NSTextBlockDimension): void;
  valueForDimension(dimension: NSTextBlockDimension): CGFloat;
  valueTypeForDimension(dimension: NSTextBlockDimension): NSTextBlockValueType;
  setContentWidth_type(val: CGFloat, type: NSTextBlockValueType): void;
  setWidth_type_forLayer_edge(val: CGFloat, type: NSTextBlockValueType, layer: NSTextBlockLayer, edge: NSRectEdge): void;
  setWidth_type_forLayer(val: CGFloat, type: NSTextBlockValueType, layer: NSTextBlockLayer): void;
  widthForLayer_edge(layer: NSTextBlockLayer, edge: NSRectEdge): CGFloat;
  widthValueTypeForLayer_edge(layer: NSTextBlockLayer, edge: NSRectEdge): NSTextBlockValueType;
  setBorderColor_forEdge(color: NSColor | null, edge: NSRectEdge): void;
  setBorderColor(color: NSColor | null): void;
  borderColorForEdge(edge: NSRectEdge): NSColor;
  rectForLayoutAtPoint_inRect_textContainer_characterRange(startingPoint: NSPoint, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  boundsRectForContentRect_inRect_textContainer_characterRange(contentRect: NSRect, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  drawBackgroundWithFrame_inView_characterRange_layoutManager(frameRect: NSRect, controlView: NSView, charRange: NSRange, layoutManager: NSLayoutManager): void;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;

  contentWidth(): CGFloat;
  contentWidthValueType(): NSTextBlockValueType;
  verticalAlignment(): NSTextBlockVerticalAlignment;
  setVerticalAlignment(verticalAlignment: NSTextBlockVerticalAlignment): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}

class NSTextTableBlockAllocator<T extends NSTextTableBlock> extends NSTextBlockAllocator<T> {
  initWithTable_startingRow_rowSpan_startingColumn_columnSpan(table: NSTextTable, row: NSInteger, rowSpan: NSInteger, col: NSInteger, colSpan: NSInteger): T;
}
declare class NSTextTableBlock extends NSTextBlock {
  alloc<T extends NSTextTableBlock>(): NSTextTableBlockAllocator<T>;

  table(): NSTextTable;
  startingRow(): NSInteger;
  rowSpan(): NSInteger;
  startingColumn(): NSInteger;
  columnSpan(): NSInteger;
}

class NSTextTableAllocator<T extends NSTextTable> extends NSTextBlockAllocator<T> {}
declare class NSTextTable extends NSTextBlock {
  alloc<T extends NSTextTable>(): NSTextTableAllocator<T>;
  rectForBlock_layoutAtPoint_inRect_textContainer_characterRange(block: NSTextTableBlock, startingPoint: NSPoint, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  boundsRectForBlock_contentRect_inRect_textContainer_characterRange(block: NSTextTableBlock, contentRect: NSRect, rect: NSRect, textContainer: NSTextContainer, charRange: NSRange): NSRect;
  drawBackgroundForBlock_withFrame_inView_characterRange_layoutManager(block: NSTextTableBlock, frameRect: NSRect, controlView: NSView, charRange: NSRange, layoutManager: NSLayoutManager): void;

  numberOfColumns(): NSUInteger;
  setNumberOfColumns(numberOfColumns: NSUInteger): void;
  layoutAlgorithm(): NSTextTableLayoutAlgorithm;
  setLayoutAlgorithm(layoutAlgorithm: NSTextTableLayoutAlgorithm): void;
  collapsesBorders(): boolean;
  setCollapsesBorders(collapsesBorders: boolean): void;
  hidesEmptyCells(): boolean;
  setHidesEmptyCells(hidesEmptyCells: boolean): void;
}

declare enum NSTextBlockValueType {
  NSTextBlockAbsoluteValueType = 0,
  NSTextBlockPercentageValueType = 1,
}

declare enum NSTextBlockDimension {
  NSTextBlockWidth = 0,
  NSTextBlockMinimumWidth = 1,
  NSTextBlockMaximumWidth = 2,
  NSTextBlockHeight = 4,
  NSTextBlockMinimumHeight = 5,
  NSTextBlockMaximumHeight = 6,
}

declare enum NSTextBlockLayer {
  NSTextBlockPadding = -1,
  NSTextBlockBorder = 0,
  NSTextBlockMargin = 1,
}

declare enum NSTextBlockVerticalAlignment {
  NSTextBlockTopAlignment = 0,
  NSTextBlockMiddleAlignment = 1,
  NSTextBlockBottomAlignment = 2,
  NSTextBlockBaselineAlignment = 3,
}

declare enum NSTextTableLayoutAlgorithm {
  NSTextTableAutomaticLayoutAlgorithm = 0,
  NSTextTableFixedLayoutAlgorithm = 1,
}

class NSTextViewAllocator<T extends NSTextView> extends NSTextAllocator<T> {
  initWithFrame_textContainer(frameRect: NSRect, container: NSTextContainer | null): T;
}
declare class NSTextView extends NSText implements INSUserInterfaceValidations, INSTextInputClient, INSTextLayoutOrientationProvider, INSDraggingSource, INSTextInput, INSAccessibilityNavigableStaticText {
  alloc<T extends NSTextView>(): NSTextViewAllocator<T>;
  replaceTextContainer(newContainer: NSTextContainer): void;
  invalidateTextContainerOrigin(): void;
  insertText(insertString: any): void;
  setConstrainedFrameSize(desiredSize: NSSize): void;
  setAlignment_range(alignment: NSTextAlignment, range: NSRange): void;
  setBaseWritingDirection_range(writingDirection: NSWritingDirection, range: NSRange): void;
  turnOffKerning(sender: any | null): void;
  tightenKerning(sender: any | null): void;
  loosenKerning(sender: any | null): void;
  useStandardKerning(sender: any | null): void;
  turnOffLigatures(sender: any | null): void;
  useStandardLigatures(sender: any | null): void;
  useAllLigatures(sender: any | null): void;
  raiseBaseline(sender: any | null): void;
  lowerBaseline(sender: any | null): void;
  toggleTraditionalCharacterShape(sender: any | null): void;
  outline(sender: any | null): void;
  performFindPanelAction(sender: any | null): void;
  alignJustified(sender: any | null): void;
  changeColor(sender: any | null): void;
  changeAttributes(sender: any | null): void;
  changeDocumentBackgroundColor(sender: any | null): void;
  orderFrontSpacingPanel(sender: any | null): void;
  orderFrontLinkPanel(sender: any | null): void;
  orderFrontListPanel(sender: any | null): void;
  orderFrontTablePanel(sender: any | null): void;
  rulerView_didMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_didRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_didAddMarker(ruler: NSRulerView, marker: NSRulerMarker): void;
  rulerView_shouldMoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_shouldAddMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willMoveMarker_toLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_shouldRemoveMarker(ruler: NSRulerView, marker: NSRulerMarker): boolean;
  rulerView_willAddMarker_atLocation(ruler: NSRulerView, marker: NSRulerMarker, location: CGFloat): CGFloat;
  rulerView_handleMouseDown(ruler: NSRulerView, event: NSEvent): void;
  setNeedsDisplayInRect_avoidAdditionalLayout(rect: NSRect, flag: boolean): void;
  drawInsertionPointInRect_color_turnedOn(rect: NSRect, color: NSColor, flag: boolean): void;
  drawViewBackgroundInRect(rect: NSRect): void;
  updateRuler(): void;
  updateFontPanel(): void;
  updateDragTypeRegistration(): void;
  selectionRangeForProposedRange_granularity(proposedCharRange: NSRange, granularity: NSSelectionGranularity): NSRange;
  clickedOnLink_atIndex(link: any, charIndex: NSUInteger): void;
  startSpeaking(sender: any | null): void;
  stopSpeaking(sender: any | null): void;
  setLayoutOrientation(orientation: NSTextLayoutOrientation): void;
  changeLayoutOrientation(sender: any | null): void;
  characterIndexForInsertionAtPoint(point: NSPoint): NSUInteger;
  complete(sender: any | null): void;
  completionsForPartialWordRange_indexOfSelectedItem(charRange: NSRange, index: NSInteger): NSArray<any>;
  insertCompletion_forPartialWordRange_movement_isFinal(word: NSString | string, charRange: NSRange, movement: NSInteger, flag: boolean): void;
  writeSelectionToPasteboard_type(pboard: NSPasteboard, type: NSPasteboardType): boolean;
  writeSelectionToPasteboard_types(pboard: NSPasteboard, types: NSArray<any> | any[]): boolean;
  preferredPasteboardTypeFromArray_restrictedToTypesFromArray(availableTypes: NSArray<any> | any[], allowedTypes: NSArray<any> | any[] | null): NSPasteboardType;
  readSelectionFromPasteboard_type(pboard: NSPasteboard, type: NSPasteboardType): boolean;
  readSelectionFromPasteboard(pboard: NSPasteboard): boolean;
  static registerForServices(): void;
  validRequestorForSendType_returnType(sendType: NSPasteboardType | null, returnType: NSPasteboardType | null): any;
  pasteAsPlainText(sender: any | null): void;
  pasteAsRichText(sender: any | null): void;
  dragSelectionWithEvent_offset_slideBack(event: NSEvent, mouseOffset: NSSize, slideBack: boolean): boolean;
  dragImageForSelectionWithEvent_origin(event: NSEvent, origin: NSPointPointer | null): NSImage;
  dragOperationForDraggingInfo_type(dragInfo: any, type: NSPasteboardType): NSDragOperation;
  cleanUpAfterDragOperation(): void;
  setSelectedRanges_affinity_stillSelecting(ranges: NSArray<any> | any[], affinity: NSSelectionAffinity, stillSelectingFlag: boolean): void;
  setSelectedRange_affinity_stillSelecting(charRange: NSRange, affinity: NSSelectionAffinity, stillSelectingFlag: boolean): void;
  updateInsertionPointStateAndRestartTimer(restartFlag: boolean): void;
  toggleContinuousSpellChecking(sender: any | null): void;
  toggleGrammarChecking(sender: any | null): void;
  setSpellingState_range(value: NSInteger, charRange: NSRange): void;
  shouldChangeTextInRanges_replacementStrings(affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  shouldChangeTextInRange_replacementString(affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  didChangeText(): void;
  breakUndoCoalescing(): void;
  showFindIndicatorForRange(charRange: NSRange): void;
  setSelectedRange(charRange: NSRange): void;
  smartDeleteRangeForProposedRange(proposedCharRange: NSRange): NSRange;
  toggleSmartInsertDelete(sender: any | null): void;
  smartInsertForString_replacingRange_beforeString_afterString(pasteString: NSString | string, charRangeToReplace: NSRange, beforeString: NSString | string, afterString: NSString | string): void;
  smartInsertBeforeStringForString_replacingRange(pasteString: NSString | string, charRangeToReplace: NSRange): NSString;
  smartInsertAfterStringForString_replacingRange(pasteString: NSString | string, charRangeToReplace: NSRange): NSString;
  toggleAutomaticQuoteSubstitution(sender: any | null): void;
  toggleAutomaticLinkDetection(sender: any | null): void;
  toggleAutomaticDataDetection(sender: any | null): void;
  toggleAutomaticDashSubstitution(sender: any | null): void;
  toggleAutomaticTextReplacement(sender: any | null): void;
  toggleAutomaticSpellingCorrection(sender: any | null): void;
  checkTextInRange_types_options(range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}): void;
  handleTextCheckingResults_forRange_types_options_orthography_wordCount(results: NSArray<any> | any[], range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, orthography: NSOrthography, wordCount: NSInteger): void;
  orderFrontSubstitutionsPanel(sender: any | null): void;
  checkTextInSelection(sender: any | null): void;
  checkTextInDocument(sender: any | null): void;
  toggleQuickLookPreviewPanel(sender: any | null): IBAction;
  quickLookPreviewableItemsInRanges(ranges: NSArray<any> | any[]): NSArray<any>;
  updateQuickLookPreviewPanel(): void;
  orderFrontSharingServicePicker(sender: any | null): IBAction;
  toggleAutomaticTextCompletion(sender: any | null): IBAction;
  updateTouchBarItemIdentifiers(): void;
  updateTextTouchBarItems(): void;
  updateCandidates(): void;
  toggleBaseWritingDirection(sender: any | null): void;
  validateUserInterfaceItem(item: any): boolean;
  insertText_replacementRange(string: any, replacementRange: NSRange): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange_replacementRange(string: any, selectedRange: NSRange, replacementRange: NSRange): void;
  unmarkText(): void;
  selectedRange(): NSRange;
  markedRange(): NSRange;
  hasMarkedText(): boolean;
  attributedSubstringForProposedRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSAttributedString;
  validAttributesForMarkedText(): NSArray<any>;
  firstRectForCharacterRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  attributedString(): NSAttributedString;
  fractionOfDistanceThroughGlyphForPoint(point: NSPoint): CGFloat;
  baselineDeltaForCharacterAtIndex(anIndex: NSUInteger): CGFloat;
  windowLevel(): NSInteger;
  drawsVerticallyForCharacterAtIndex(charIndex: NSUInteger): boolean;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  insertText(string: any): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange(string: any, selRange: NSRange): void;
  unmarkText(): void;
  hasMarkedText(): boolean;
  conversationIdentifier(): NSInteger;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  firstRectForCharacterRange(range: NSRange): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  validAttributesForMarkedText(): NSArray<any>;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityRangeForLine(lineNumber: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;
  validateUserInterfaceItem(item: any): boolean;
  insertText_replacementRange(string: any, replacementRange: NSRange): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange_replacementRange(string: any, selectedRange: NSRange, replacementRange: NSRange): void;
  unmarkText(): void;
  selectedRange(): NSRange;
  markedRange(): NSRange;
  hasMarkedText(): boolean;
  attributedSubstringForProposedRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSAttributedString;
  validAttributesForMarkedText(): NSArray<any>;
  firstRectForCharacterRange_actualRange(range: NSRange, actualRange: NSRangePointer | null): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  attributedString(): NSAttributedString;
  fractionOfDistanceThroughGlyphForPoint(point: NSPoint): CGFloat;
  baselineDeltaForCharacterAtIndex(anIndex: NSUInteger): CGFloat;
  windowLevel(): NSInteger;
  drawsVerticallyForCharacterAtIndex(charIndex: NSUInteger): boolean;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  insertText(string: any): void;
  doCommandBySelector(selector: string): void;
  setMarkedText_selectedRange(string: any, selRange: NSRange): void;
  unmarkText(): void;
  hasMarkedText(): boolean;
  conversationIdentifier(): NSInteger;
  attributedSubstringFromRange(range: NSRange): NSAttributedString;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  firstRectForCharacterRange(range: NSRange): NSRect;
  characterIndexForPoint(point: NSPoint): NSUInteger;
  validAttributesForMarkedText(): NSArray<any>;
  accessibilityStringForRange(range: NSRange): NSString;
  accessibilityLineForIndex(index: NSInteger): NSInteger;
  accessibilityRangeForLine(lineNumber: NSInteger): NSRange;
  accessibilityFrameForRange(range: NSRange): NSRect;

  textContainer(): NSTextContainer;
  setTextContainer(textContainer: NSTextContainer): void;
  textContainerInset(): NSSize;
  setTextContainerInset(textContainerInset: NSSize): void;
  textContainerOrigin(): NSPoint;
  layoutManager(): NSLayoutManager;
  textStorage(): NSTextStorage;
  shouldDrawInsertionPoint(): boolean;
  static stronglyReferencesTextStorage(): boolean;
  rangeForUserCompletion(): NSRange;
  writablePasteboardTypes(): NSArray<any>;
  readablePasteboardTypes(): NSArray<any>;
  acceptableDragTypes(): NSArray<any>;
  selectedRanges(): NSArray<any>;
  setSelectedRanges(selectedRanges: NSArray<any> | any[]): void;
  selectionAffinity(): NSSelectionAffinity;
  selectionGranularity(): NSSelectionGranularity;
  setSelectionGranularity(selectionGranularity: NSSelectionGranularity): void;
  selectedTextAttributes(): NSDictionary<any, any>;
  setSelectedTextAttributes(selectedTextAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  insertionPointColor(): NSColor;
  setInsertionPointColor(insertionPointColor: NSColor): void;
  markedTextAttributes(): NSDictionary<any, any>;
  setMarkedTextAttributes(markedTextAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  linkTextAttributes(): NSDictionary<any, any>;
  setLinkTextAttributes(linkTextAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  displaysLinkToolTips(): boolean;
  setDisplaysLinkToolTips(displaysLinkToolTips: boolean): void;
  acceptsGlyphInfo(): boolean;
  setAcceptsGlyphInfo(acceptsGlyphInfo: boolean): void;
  usesRuler(): boolean;
  setUsesRuler(usesRuler: boolean): void;
  usesInspectorBar(): boolean;
  setUsesInspectorBar(usesInspectorBar: boolean): void;
  continuousSpellCheckingEnabled(): boolean;
  setContinuousSpellCheckingEnabled(continuousSpellCheckingEnabled: boolean): void;
  spellCheckerDocumentTag(): NSInteger;
  grammarCheckingEnabled(): boolean;
  setGrammarCheckingEnabled(grammarCheckingEnabled: boolean): void;
  typingAttributes(): NSDictionary<any, any>;
  setTypingAttributes(typingAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  rangesForUserTextChange(): NSArray<any>;
  rangesForUserCharacterAttributeChange(): NSArray<any>;
  rangesForUserParagraphAttributeChange(): NSArray<any>;
  rangeForUserTextChange(): NSRange;
  rangeForUserCharacterAttributeChange(): NSRange;
  rangeForUserParagraphAttributeChange(): NSRange;
  allowsDocumentBackgroundColorChange(): boolean;
  setAllowsDocumentBackgroundColorChange(allowsDocumentBackgroundColorChange: boolean): void;
  defaultParagraphStyle(): NSParagraphStyle;
  setDefaultParagraphStyle(defaultParagraphStyle: NSParagraphStyle): void;
  allowsUndo(): boolean;
  setAllowsUndo(allowsUndo: boolean): void;
  coalescingUndo(): boolean;
  allowsImageEditing(): boolean;
  setAllowsImageEditing(allowsImageEditing: boolean): void;
  usesRolloverButtonForSelection(): boolean;
  setUsesRolloverButtonForSelection(usesRolloverButtonForSelection: boolean): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  editable(): boolean;
  setEditable(editable: boolean): void;
  selectable(): boolean;
  setSelectable(selectable: boolean): void;
  richText(): boolean;
  setRichText(richText: boolean): void;
  importsGraphics(): boolean;
  setImportsGraphics(importsGraphics: boolean): void;
  drawsBackground(): boolean;
  setDrawsBackground(drawsBackground: boolean): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  fieldEditor(): boolean;
  setFieldEditor(fieldEditor: boolean): void;
  usesFontPanel(): boolean;
  setUsesFontPanel(usesFontPanel: boolean): void;
  rulerVisible(): boolean;
  setRulerVisible(rulerVisible: boolean): void;
  allowedInputSourceLocales(): NSArray<any>;
  setAllowedInputSourceLocales(allowedInputSourceLocales: NSArray<any> | any[]): void;
  smartInsertDeleteEnabled(): boolean;
  setSmartInsertDeleteEnabled(smartInsertDeleteEnabled: boolean): void;
  automaticQuoteSubstitutionEnabled(): boolean;
  setAutomaticQuoteSubstitutionEnabled(automaticQuoteSubstitutionEnabled: boolean): void;
  automaticLinkDetectionEnabled(): boolean;
  setAutomaticLinkDetectionEnabled(automaticLinkDetectionEnabled: boolean): void;
  automaticDataDetectionEnabled(): boolean;
  setAutomaticDataDetectionEnabled(automaticDataDetectionEnabled: boolean): void;
  automaticDashSubstitutionEnabled(): boolean;
  setAutomaticDashSubstitutionEnabled(automaticDashSubstitutionEnabled: boolean): void;
  automaticTextReplacementEnabled(): boolean;
  setAutomaticTextReplacementEnabled(automaticTextReplacementEnabled: boolean): void;
  automaticSpellingCorrectionEnabled(): boolean;
  setAutomaticSpellingCorrectionEnabled(automaticSpellingCorrectionEnabled: boolean): void;
  enabledTextCheckingTypes(): NSTextCheckingTypes;
  setEnabledTextCheckingTypes(enabledTextCheckingTypes: NSTextCheckingTypes): void;
  usesFindPanel(): boolean;
  setUsesFindPanel(usesFindPanel: boolean): void;
  usesFindBar(): boolean;
  setUsesFindBar(usesFindBar: boolean): void;
  incrementalSearchingEnabled(): boolean;
  setIncrementalSearchingEnabled(incrementalSearchingEnabled: boolean): void;
  automaticTextCompletionEnabled(): boolean;
  setAutomaticTextCompletionEnabled(automaticTextCompletionEnabled: boolean): void;
  allowsCharacterPickerTouchBarItem(): boolean;
  setAllowsCharacterPickerTouchBarItem(allowsCharacterPickerTouchBarItem: boolean): void;
  candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
}

declare interface INSTextViewDelegate {
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
}

declare type NSPasteboardTypeFindPanelSearchOptionKey = NSString

declare enum NSSelectionGranularity {
  NSSelectByCharacter = 0,
  NSSelectByWord = 1,
  NSSelectByParagraph = 2,
}

declare enum NSSelectionAffinity {
  NSSelectionAffinityUpstream = 0,
  NSSelectionAffinityDownstream = 1,
}

declare enum NSFindPanelAction {
  NSFindPanelActionShowFindPanel = 1,
  NSFindPanelActionNext = 2,
  NSFindPanelActionPrevious = 3,
  NSFindPanelActionReplaceAll = 4,
  NSFindPanelActionReplace = 5,
  NSFindPanelActionReplaceAndFind = 6,
  NSFindPanelActionSetFindString = 7,
  NSFindPanelActionReplaceAllInSelection = 8,
  NSFindPanelActionSelectAll = 9,
  NSFindPanelActionSelectAllInSelection = 10,
}

declare enum NSFindPanelSubstringMatchType {
  NSFindPanelSubstringMatchTypeContains = 0,
  NSFindPanelSubstringMatchTypeStartsWith = 1,
  NSFindPanelSubstringMatchTypeFullWord = 2,
  NSFindPanelSubstringMatchTypeEndsWith = 3,
}

class NSTitlebarAccessoryViewControllerAllocator<T extends NSTitlebarAccessoryViewController> extends NSViewControllerAllocator<T> {}
declare class NSTitlebarAccessoryViewController extends NSViewController implements INSAnimationDelegate, INSAnimatablePropertyContainer {
  alloc<T extends NSTitlebarAccessoryViewController>(): NSTitlebarAccessoryViewControllerAllocator<T>;
  animationShouldStart(animation: NSAnimation): boolean;
  animationDidStop(animation: NSAnimation): void;
  animationDidEnd(animation: NSAnimation): void;
  animation_valueForProgress(animation: NSAnimation, progress: NSAnimationProgress): number;
  animation_didReachProgressMark(animation: NSAnimation, progress: NSAnimationProgress): void;
  animator(): NSTitlebarAccessoryViewController;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;
  animationShouldStart(animation: NSAnimation): boolean;
  animationDidStop(animation: NSAnimation): void;
  animationDidEnd(animation: NSAnimation): void;
  animation_valueForProgress(animation: NSAnimation, progress: NSAnimationProgress): number;
  animation_didReachProgressMark(animation: NSAnimation, progress: NSAnimationProgress): void;
  animator(): NSTitlebarAccessoryViewController;
  animationForKey(key: NSAnimatablePropertyKey): any;
  static defaultAnimationForKey(key: NSAnimatablePropertyKey): any;

  layoutAttribute(): NSLayoutAttribute;
  setLayoutAttribute(layoutAttribute: NSLayoutAttribute): void;
  fullScreenMinHeight(): CGFloat;
  setFullScreenMinHeight(fullScreenMinHeight: CGFloat): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  animations(): NSDictionary<any, any>;
  setAnimations(animations: NSDictionary<any, any> | {[key: string]: any}): void;
}

class NSTokenFieldAllocator<T extends NSTokenField> extends NSTextFieldAllocator<T> {}
declare class NSTokenField extends NSTextField {
  alloc<T extends NSTokenField>(): NSTokenFieldAllocator<T>;

  delegate(): any;
  setDelegate(delegate: any): void;
  tokenStyle(): NSTokenStyle;
  setTokenStyle(tokenStyle: NSTokenStyle): void;
  completionDelay(): NSTimeInterval;
  setCompletionDelay(completionDelay: NSTimeInterval): void;
  static defaultCompletionDelay(): NSTimeInterval;
  tokenizingCharacterSet(): NSCharacterSet;
  setTokenizingCharacterSet(tokenizingCharacterSet: NSCharacterSet): void;
  static defaultTokenizingCharacterSet(): NSCharacterSet;
}

declare interface INSTokenFieldDelegate {
  tokenField_completionsForSubstring_indexOfToken_indexOfSelectedItem(tokenField: NSTokenField, substring: NSString | string, tokenIndex: NSInteger, selectedIndex: NSInteger | null): NSArray<any>;
  tokenField_shouldAddObjects_atIndex(tokenField: NSTokenField, tokens: NSArray<any> | any[], index: NSUInteger): NSArray<any>;
  tokenField_displayStringForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSString;
  tokenField_editingStringForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSString;
  tokenField_representedObjectForEditingString(tokenField: NSTokenField, editingString: NSString | string): any;
  tokenField_writeRepresentedObjects_toPasteboard(tokenField: NSTokenField, objects: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  tokenField_readFromPasteboard(tokenField: NSTokenField, pboard: NSPasteboard): NSArray<any>;
  tokenField_menuForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSMenu;
  tokenField_hasMenuForRepresentedObject(tokenField: NSTokenField, representedObject: any): boolean;
  tokenField_styleForRepresentedObject(tokenField: NSTokenField, representedObject: any): NSTokenStyle;
}

class NSTokenFieldCellAllocator<T extends NSTokenFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class NSTokenFieldCell extends NSTextFieldCell {
  alloc<T extends NSTokenFieldCell>(): NSTokenFieldCellAllocator<T>;

  tokenStyle(): NSTokenStyle;
  setTokenStyle(tokenStyle: NSTokenStyle): void;
  completionDelay(): NSTimeInterval;
  setCompletionDelay(completionDelay: NSTimeInterval): void;
  static defaultCompletionDelay(): NSTimeInterval;
  tokenizingCharacterSet(): NSCharacterSet;
  setTokenizingCharacterSet(tokenizingCharacterSet: NSCharacterSet): void;
  static defaultTokenizingCharacterSet(): NSCharacterSet;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface INSTokenFieldCellDelegate {
  tokenFieldCell_completionsForSubstring_indexOfToken_indexOfSelectedItem(tokenFieldCell: NSTokenFieldCell, substring: NSString | string, tokenIndex: NSInteger, selectedIndex: NSInteger): NSArray<any>;
  tokenFieldCell_shouldAddObjects_atIndex(tokenFieldCell: NSTokenFieldCell, tokens: NSArray<any> | any[], index: NSUInteger): NSArray<any>;
  tokenFieldCell_displayStringForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSString;
  tokenFieldCell_editingStringForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSString;
  tokenFieldCell_representedObjectForEditingString(tokenFieldCell: NSTokenFieldCell, editingString: NSString | string): any;
  tokenFieldCell_writeRepresentedObjects_toPasteboard(tokenFieldCell: NSTokenFieldCell, objects: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  tokenFieldCell_readFromPasteboard(tokenFieldCell: NSTokenFieldCell, pboard: NSPasteboard): NSArray<any>;
  tokenFieldCell_menuForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSMenu;
  tokenFieldCell_hasMenuForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): boolean;
  tokenFieldCell_styleForRepresentedObject(tokenFieldCell: NSTokenFieldCell, representedObject: any): NSTokenStyle;
}

declare enum NSTokenStyle {
  NSTokenStyleDefault,
  NSTokenStyleNone,
  NSTokenStyleRounded,
  NSTokenStyleSquared,
  NSTokenStylePlainSquared,
}

class NSToolbarAllocator<T extends NSToolbar> extends NSObjectAllocator<T> {
  initWithIdentifier(identifier: NSToolbarIdentifier): T;
  init(): T;
}
declare class NSToolbar extends NSObject {
  alloc<T extends NSToolbar>(): NSToolbarAllocator<T>;
  insertItemWithItemIdentifier_atIndex(itemIdentifier: NSToolbarItemIdentifier, index: NSInteger): void;
  removeItemAtIndex(index: NSInteger): void;
  runCustomizationPalette(sender: any | null): void;
  setConfigurationFromDictionary(configDict: NSDictionary<any, any> | {[key: string]: any}): void;
  validateVisibleItems(): void;
  itemWithIdentifier(identifier: NSString | string): NSToolbarItem;
  _toolbarView(): any;
  ms_toolbarHeight(): CGFloat;
  _fullLayout(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  visible(): boolean;
  setVisible(visible: boolean): void;
  customizationPaletteIsRunning(): boolean;
  displayMode(): NSToolbarDisplayMode;
  setDisplayMode(displayMode: NSToolbarDisplayMode): void;
  selectedItemIdentifier(): NSToolbarItemIdentifier;
  setSelectedItemIdentifier(selectedItemIdentifier: NSToolbarItemIdentifier): void;
  sizeMode(): NSToolbarSizeMode;
  setSizeMode(sizeMode: NSToolbarSizeMode): void;
  showsBaselineSeparator(): boolean;
  setShowsBaselineSeparator(showsBaselineSeparator: boolean): void;
  allowsUserCustomization(): boolean;
  setAllowsUserCustomization(allowsUserCustomization: boolean): void;
  identifier(): NSToolbarIdentifier;
  items(): NSArray<any>;
  visibleItems(): NSArray<any>;
  autosavesConfiguration(): boolean;
  setAutosavesConfiguration(autosavesConfiguration: boolean): void;
  configurationDictionary(): NSDictionary<any, any>;
  allowsExtensionItems(): boolean;
  setAllowsExtensionItems(allowsExtensionItems: boolean): void;
  fullScreenAccessoryView(): NSView;
  setFullScreenAccessoryView(fullScreenAccessoryView: NSView): void;
  fullScreenAccessoryViewMinHeight(): CGFloat;
  setFullScreenAccessoryViewMinHeight(fullScreenAccessoryViewMinHeight: CGFloat): void;
  fullScreenAccessoryViewMaxHeight(): CGFloat;
  setFullScreenAccessoryViewMaxHeight(fullScreenAccessoryViewMaxHeight: CGFloat): void;
}

declare interface INSToolbarDelegate {
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;
}

declare type NSToolbarIdentifier = NSString

declare type NSToolbarItemIdentifier = NSString

declare enum NSToolbarDisplayMode {
  NSToolbarDisplayModeDefault,
  NSToolbarDisplayModeIconAndLabel,
  NSToolbarDisplayModeIconOnly,
  NSToolbarDisplayModeLabelOnly,
}

declare enum NSToolbarSizeMode {
  NSToolbarSizeModeDefault,
  NSToolbarSizeModeRegular,
  NSToolbarSizeModeSmall,
}

class NSToolbarItemAllocator<T extends NSToolbarItem> extends NSObjectAllocator<T> {
  initWithItemIdentifier(itemIdentifier: NSToolbarItemIdentifier): T;
}
declare class NSToolbarItem extends NSObject implements INSCopying, INSValidatedUserInterfaceItem {
  alloc<T extends NSToolbarItem>(): NSToolbarItemAllocator<T>;
  validate(): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  itemIdentifier(): NSToolbarItemIdentifier;
  toolbar(): NSToolbar;
  label(): NSString;
  setLabel(label: NSString | string): void;
  paletteLabel(): NSString;
  setPaletteLabel(paletteLabel: NSString | string): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  menuFormRepresentation(): NSMenuItem;
  setMenuFormRepresentation(menuFormRepresentation: NSMenuItem): void;
  tag(): NSInteger;
  setTag(tag: NSInteger): void;
  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  image(): NSImage;
  setImage(image: NSImage): void;
  view(): NSView;
  setView(view: NSView): void;
  minSize(): NSSize;
  setMinSize(minSize: NSSize): void;
  maxSize(): NSSize;
  setMaxSize(maxSize: NSSize): void;
  visibilityPriority(): NSToolbarItemVisibilityPriority;
  setVisibilityPriority(visibilityPriority: NSToolbarItemVisibilityPriority): void;
  autovalidates(): boolean;
  setAutovalidates(autovalidates: boolean): void;
  allowsDuplicatesInToolbar(): boolean;
}

declare interface INSCloudSharingValidation {
  cloudShareForUserInterfaceItem(item: any): CKShare;
}

declare type NSToolbarItemVisibilityPriority = NSInteger

class NSToolbarItemGroupAllocator<T extends NSToolbarItemGroup> extends NSToolbarItemAllocator<T> {}
declare class NSToolbarItemGroup extends NSToolbarItem {
  alloc<T extends NSToolbarItemGroup>(): NSToolbarItemGroupAllocator<T>;

  subitems(): NSArray<any>;
  setSubitems(subitems: NSArray<any> | any[]): void;
}

class NSTouchAllocator<T extends NSTouch> extends NSObjectAllocator<T> {}
declare class NSTouch extends NSObject implements INSCopying {
  alloc<T extends NSTouch>(): NSTouchAllocator<T>;
  locationInView(view: NSView | null): NSPoint;
  previousLocationInView(view: NSView | null): NSPoint;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  identity(): any;
  phase(): NSTouchPhase;
  normalizedPosition(): NSPoint;
  resting(): boolean;
  device(): any;
  deviceSize(): NSSize;
  type(): NSTouchType;
}

declare enum NSTouchPhase {
  NSTouchPhaseBegan = 1 << 0,
  NSTouchPhaseMoved = 1 << 1,
  NSTouchPhaseStationary = 1 << 2,
  NSTouchPhaseEnded = 1 << 3,
  NSTouchPhaseCancelled = 1 << 4,
  NSTouchPhaseTouching,
  NSTouchPhaseAny,
}

declare enum NSTouchType {
  NSTouchTypeDirect,
  NSTouchTypeIndirect,
}

declare enum NSTouchTypeMask {
  NSTouchTypeMaskDirect,
  NSTouchTypeMaskIndirect,
}

class NSTouchBarAllocator<T extends NSTouchBar> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTouchBar extends NSObject implements INSCoding, INSCoding {
  alloc<T extends NSTouchBar>(): NSTouchBarAllocator<T>;
  itemForIdentifier(identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  customizationIdentifier(): NSTouchBarCustomizationIdentifier;
  setCustomizationIdentifier(customizationIdentifier: NSTouchBarCustomizationIdentifier): void;
  customizationAllowedItemIdentifiers(): NSArray<any>;
  setCustomizationAllowedItemIdentifiers(customizationAllowedItemIdentifiers: NSArray<any> | any[]): void;
  customizationRequiredItemIdentifiers(): NSArray<any>;
  setCustomizationRequiredItemIdentifiers(customizationRequiredItemIdentifiers: NSArray<any> | any[]): void;
  defaultItemIdentifiers(): NSArray<any>;
  setDefaultItemIdentifiers(defaultItemIdentifiers: NSArray<any> | any[]): void;
  itemIdentifiers(): NSArray<any>;
  principalItemIdentifier(): NSTouchBarItemIdentifier;
  setPrincipalItemIdentifier(principalItemIdentifier: NSTouchBarItemIdentifier): void;
  escapeKeyReplacementItemIdentifier(): NSTouchBarItemIdentifier;
  setEscapeKeyReplacementItemIdentifier(escapeKeyReplacementItemIdentifier: NSTouchBarItemIdentifier): void;
  templateItems(): NSSet<any>;
  setTemplateItems(templateItems: NSSet<any>): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  visible(): boolean;
}

declare interface INSTouchBarDelegate extends NSObject {
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
}

declare interface INSTouchBarProvider {

  touchBar(): NSTouchBar;
}

declare type NSTouchBarCustomizationIdentifier = NSString

class NSTouchBarItemAllocator<T extends NSTouchBarItem> extends NSObjectAllocator<T> {
  initWithIdentifier(identifier: NSTouchBarItemIdentifier): T;
  initWithCoder(coder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTouchBarItem extends NSObject implements INSCoding, INSCoding {
  alloc<T extends NSTouchBarItem>(): NSTouchBarItemAllocator<T>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  identifier(): NSTouchBarItemIdentifier;
  visibilityPriority(): NSTouchBarItemPriority;
  setVisibilityPriority(visibilityPriority: NSTouchBarItemPriority): void;
  view(): NSView;
  viewController(): NSViewController;
  customizationLabel(): NSString;
  visible(): boolean;
}

declare type NSTouchBarItemIdentifier = NSString

declare type NSTouchBarItemPriority = number

class NSTrackingAreaAllocator<T extends NSTrackingArea> extends NSObjectAllocator<T> {
  initWithRect_options_owner_userInfo(rect: NSRect, options: NSTrackingAreaOptions, owner: any | null, userInfo: NSDictionary<any, any> | {[key: string]: any} | null): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSTrackingArea extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSTrackingArea>(): NSTrackingAreaAllocator<T>;
  static mouseEnterExitTrackingArea(owner: any): NSTrackingArea;
  static trackingAreaWithOptions_owner(options: NSTrackingAreaOptions, owner: any): NSTrackingArea;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  rect(): NSRect;
  options(): NSTrackingAreaOptions;
  owner(): any;
  userInfo(): NSDictionary<any, any>;
}

declare enum NSTrackingAreaOptions {
  NSTrackingMouseEnteredAndExited = 0x01,
  NSTrackingMouseMoved = 0x02,
  NSTrackingCursorUpdate = 0x04,
  NSTrackingActiveWhenFirstResponder = 0x10,
  NSTrackingActiveInKeyWindow = 0x20,
  NSTrackingActiveInActiveApp = 0x40,
  NSTrackingActiveAlways = 0x80,
  NSTrackingAssumeInside = 0x100,
  NSTrackingInVisibleRect = 0x200,
  NSTrackingEnabledDuringMouseDrag = 0x400,
}

class NSTreeControllerAllocator<T extends NSTreeController> extends NSObjectControllerAllocator<T> {}
declare class NSTreeController extends NSObjectController {
  alloc<T extends NSTreeController>(): NSTreeControllerAllocator<T>;
  rearrangeObjects(): void;
  add(sender: any | null): IBAction;
  remove(sender: any | null): IBAction;
  addChild(sender: any | null): IBAction;
  insert(sender: any | null): IBAction;
  insertChild(sender: any | null): IBAction;
  insertObject_atArrangedObjectIndexPath(object: any | null, indexPath: NSIndexPath): void;
  insertObjects_atArrangedObjectIndexPaths(objects: NSArray<any> | any[], indexPaths: NSArray<any> | any[]): void;
  removeObjectAtArrangedObjectIndexPath(indexPath: NSIndexPath): void;
  removeObjectsAtArrangedObjectIndexPaths(indexPaths: NSArray<any> | any[]): void;
  setSelectionIndexPaths(indexPaths: NSArray<any> | any[]): boolean;
  setSelectionIndexPath(indexPath: NSIndexPath | null): boolean;
  addSelectionIndexPaths(indexPaths: NSArray<any> | any[]): boolean;
  removeSelectionIndexPaths(indexPaths: NSArray<any> | any[]): boolean;
  moveNode_toIndexPath(node: NSTreeNode, indexPath: NSIndexPath): void;
  moveNodes_toIndexPath(nodes: NSArray<any> | any[], startingIndexPath: NSIndexPath): void;
  childrenKeyPathForNode(node: NSTreeNode): NSString;
  countKeyPathForNode(node: NSTreeNode): NSString;
  leafKeyPathForNode(node: NSTreeNode): NSString;

  arrangedObjects(): NSTreeNode;
  childrenKeyPath(): NSString;
  setChildrenKeyPath(childrenKeyPath: NSString | string): void;
  countKeyPath(): NSString;
  setCountKeyPath(countKeyPath: NSString | string): void;
  leafKeyPath(): NSString;
  setLeafKeyPath(leafKeyPath: NSString | string): void;
  sortDescriptors(): NSArray<any>;
  setSortDescriptors(sortDescriptors: NSArray<any> | any[]): void;
  content(): any;
  setContent(content: any): void;
  canInsert(): boolean;
  canInsertChild(): boolean;
  canAddChild(): boolean;
  avoidsEmptySelection(): boolean;
  setAvoidsEmptySelection(avoidsEmptySelection: boolean): void;
  preservesSelection(): boolean;
  setPreservesSelection(preservesSelection: boolean): void;
  selectsInsertedObjects(): boolean;
  setSelectsInsertedObjects(selectsInsertedObjects: boolean): void;
  alwaysUsesMultipleValuesMarker(): boolean;
  setAlwaysUsesMultipleValuesMarker(alwaysUsesMultipleValuesMarker: boolean): void;
  selectedObjects(): NSArray<any>;
  selectionIndexPaths(): NSArray<any>;
  selectionIndexPath(): NSIndexPath;
  selectedNodes(): NSArray<any>;
}

class NSTreeNodeAllocator<T extends NSTreeNode> extends NSObjectAllocator<T> {
  initWithRepresentedObject(modelObject: any | null): T;
}
declare class NSTreeNode extends NSObject {
  alloc<T extends NSTreeNode>(): NSTreeNodeAllocator<T>;
  static treeNodeWithRepresentedObject(modelObject: any | null): NSTreeNode;
  descendantNodeAtIndexPath(indexPath: NSIndexPath): NSTreeNode;
  sortWithSortDescriptors_recursively(sortDescriptors: NSArray<any> | any[], recursively: boolean): void;

  representedObject(): any;
  indexPath(): NSIndexPath;
  leaf(): boolean;
  childNodes(): NSArray<any>;
  mutableChildNodes(): NSMutableArray<any>;
  parentNode(): NSTreeNode;
}

class NSTypesetterAllocator<T extends NSTypesetter> extends NSObjectAllocator<T> {}
declare class NSTypesetter extends NSObject {
  alloc<T extends NSTypesetter>(): NSTypesetterAllocator<T>;
  substituteFontForFont(originalFont: NSFont): NSFont;
  textTabForGlyphLocation_writingDirection_maxLocation(glyphLocation: CGFloat, direction: NSWritingDirection, maxLocation: CGFloat): NSTextTab;
  setParagraphGlyphRange_separatorGlyphRange(paragraphRange: NSRange, paragraphSeparatorRange: NSRange): void;
  layoutParagraphAtPoint(lineFragmentOrigin: NSPointPointer): NSUInteger;
  beginParagraph(): void;
  endParagraph(): void;
  beginLineWithGlyphAtIndex(glyphIndex: NSUInteger): void;
  endLineWithGlyphRange(lineGlyphRange: NSRange): void;
  lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(glyphIndex: NSUInteger, rect: NSRect): CGFloat;
  getLineFragmentRect_usedRect_forParagraphSeparatorGlyphRange_atProposedOrigin(lineFragmentRect: NSRectPointer, lineFragmentUsedRect: NSRectPointer, paragraphSeparatorGlyphRange: NSRange, lineOrigin: NSPoint): void;
  setHardInvalidation_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  layoutGlyphsInLayoutManager_startingAtGlyphIndex_maxNumberOfLineFragments_nextGlyphIndex(layoutManager: NSLayoutManager, startGlyphIndex: NSUInteger, maxNumLines: NSUInteger, nextGlyph: NSUInteger): void;
  layoutCharactersInRange_forLayoutManager_maximumNumberOfLineFragments(characterRange: NSRange, layoutManager: NSLayoutManager, maxNumLines: NSUInteger): NSRange;
  static printingAdjustmentInLayoutManager_forNominallySpacedGlyphRange_packedGlyphs_count(layoutMgr: NSLayoutManager, nominallySpacedGlyphsRange: NSRange, packedGlyphs: string, packedGlyphsCount: NSUInteger): NSSize;
  baselineOffsetInLayoutManager_glyphIndex(layoutMgr: NSLayoutManager, glyphIndex: NSUInteger): CGFloat;
  static sharedSystemTypesetterForBehavior(behavior: NSTypesetterBehavior): any;
  willSetLineFragmentRect_forGlyphRange_usedRect_baselineOffset(lineRect: NSRectPointer, glyphRange: NSRange, usedRect: NSRectPointer, baselineOffset: CGFloat): void;
  shouldBreakLineByWordBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  shouldBreakLineByHyphenatingBeforeCharacterAtIndex(charIndex: NSUInteger): boolean;
  hyphenationFactorForGlyphAtIndex(glyphIndex: NSUInteger): number;
  hyphenCharacterForGlyphAtIndex(glyphIndex: NSUInteger): string;
  boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(glyphIndex: NSUInteger, textContainer: NSTextContainer, proposedRect: NSRect, glyphPosition: NSPoint, charIndex: NSUInteger): NSRect;
  characterRangeForGlyphRange_actualGlyphRange(glyphRange: NSRange, actualGlyphRange: NSRangePointer | null): NSRange;
  glyphRangeForCharacterRange_actualCharacterRange(charRange: NSRange, actualCharRange: NSRangePointer | null): NSRange;
  getLineFragmentRect_usedRect_remainingRect_forStartingGlyphAtIndex_proposedRect_lineSpacing_paragraphSpacingBefore_paragraphSpacingAfter(lineFragmentRect: NSRectPointer, lineFragmentUsedRect: NSRectPointer, remainingRect: NSRectPointer, startingGlyphIndex: NSUInteger, proposedRect: NSRect, lineSpacing: CGFloat, paragraphSpacingBefore: CGFloat, paragraphSpacingAfter: CGFloat): void;
  setLineFragmentRect_forGlyphRange_usedRect_baselineOffset(fragmentRect: NSRect, glyphRange: NSRange, usedRect: NSRect, baselineOffset: CGFloat): void;
  setNotShownAttribute_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  setDrawsOutsideLineFragment_forGlyphRange(flag: boolean, glyphRange: NSRange): void;
  setLocation_withAdvancements_forStartOfGlyphRange(location: NSPoint, advancements: CGFloat, glyphRange: NSRange): void;
  setAttachmentSize_forGlyphRange(attachmentSize: NSSize, glyphRange: NSRange): void;
  setBidiLevels_forGlyphRange(levels: number, glyphRange: NSRange): void;
  actionForControlCharacterAtIndex(charIndex: NSUInteger): NSTypesetterControlCharacterAction;
  getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits_bidiLevels(glyphsRange: NSRange, glyphBuffer: NSGlyph, charIndexBuffer: NSUInteger, inscribeBuffer: NSGlyphInscription, elasticBuffer: boolean, bidiLevelBuffer: string): NSUInteger;
  substituteGlyphsInRange_withGlyphs(glyphRange: NSRange, glyphs: NSGlyph): void;
  insertGlyph_atGlyphIndex_characterIndex(glyph: NSGlyph, glyphIndex: NSUInteger, characterIndex: NSUInteger): void;
  deleteGlyphsInRange(glyphRange: NSRange): void;

  usesFontLeading(): boolean;
  setUsesFontLeading(usesFontLeading: boolean): void;
  typesetterBehavior(): NSTypesetterBehavior;
  setTypesetterBehavior(typesetterBehavior: NSTypesetterBehavior): void;
  hyphenationFactor(): number;
  setHyphenationFactor(hyphenationFactor: number): void;
  lineFragmentPadding(): CGFloat;
  setLineFragmentPadding(lineFragmentPadding: CGFloat): void;
  bidiProcessingEnabled(): boolean;
  setBidiProcessingEnabled(bidiProcessingEnabled: boolean): void;
  attributedString(): NSAttributedString;
  setAttributedString(attributedString: NSAttributedString): void;
  paragraphGlyphRange(): NSRange;
  paragraphSeparatorGlyphRange(): NSRange;
  paragraphCharacterRange(): NSRange;
  paragraphSeparatorCharacterRange(): NSRange;
  attributesForExtraLineFragment(): NSDictionary<any, any>;
  layoutManager(): NSLayoutManager;
  textContainers(): NSArray<any>;
  currentTextContainer(): NSTextContainer;
  currentParagraphStyle(): NSParagraphStyle;
  static sharedSystemTypesetter(): NSTypesetter;
  static defaultTypesetterBehavior(): NSTypesetterBehavior;
}

declare enum NSTypesetterControlCharacterAction {
  NSTypesetterZeroAdvancementAction,
  NSTypesetterWhitespaceAction,
  NSTypesetterHorizontalTabAction,
  NSTypesetterLineBreakAction,
  NSTypesetterParagraphBreakAction,
  NSTypesetterContainerBreakAction,
}

class NSUserDefaultsControllerAllocator<T extends NSUserDefaultsController> extends NSControllerAllocator<T> {
  initWithDefaults_initialValues(defaults: NSUserDefaults | null, initialValues: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class NSUserDefaultsController extends NSController {
  alloc<T extends NSUserDefaultsController>(): NSUserDefaultsControllerAllocator<T>;
  revert(sender: any | null): IBAction;
  save(sender: any | null): IBAction;
  revertToInitialValues(sender: any | null): IBAction;

  static sharedUserDefaultsController(): NSUserDefaultsController;
  defaults(): NSUserDefaults;
  initialValues(): NSDictionary<any, any>;
  setInitialValues(initialValues: NSDictionary<any, any> | {[key: string]: any}): void;
  appliesImmediately(): boolean;
  setAppliesImmediately(appliesImmediately: boolean): void;
  hasUnappliedChanges(): boolean;
  values(): any;
}

class NSUserInterfaceCompressionOptionsAllocator<T extends NSUserInterfaceCompressionOptions> extends NSObjectAllocator<T> {
  init(): T;
  initWithCoder(coder: NSCoder): T;
  initWithIdentifier(identifier: NSString | string): T;
  initWithCompressionOptions(options: NSSet<any>): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class NSUserInterfaceCompressionOptions extends NSObject implements INSCopying, INSCoding {
  alloc<T extends NSUserInterfaceCompressionOptions>(): NSUserInterfaceCompressionOptionsAllocator<T>;
  containsOptions(options: NSUserInterfaceCompressionOptions): boolean;
  intersectsOptions(options: NSUserInterfaceCompressionOptions): boolean;
  optionsByAddingOptions(options: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
  optionsByRemovingOptions(options: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithCoder(aCoder: NSCoder): void;

  empty(): boolean;
  static hideImagesOption(): NSUserInterfaceCompressionOptions;
  static hideTextOption(): NSUserInterfaceCompressionOptions;
  static reduceMetricsOption(): NSUserInterfaceCompressionOptions;
  static breakEqualWidthsOption(): NSUserInterfaceCompressionOptions;
  static standardOptions(): NSUserInterfaceCompressionOptions;
}

declare interface INSUserInterfaceCompression {
  compressWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): void;
  minimumSizeWithPrioritizedCompressionOptions(prioritizedOptions: NSArray<any> | any[]): NSSize;

  activeCompressionOptions(): NSUserInterfaceCompressionOptions;
}

declare interface INSUserInterfaceItemIdentification {

  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
}

declare type NSUserInterfaceItemIdentifier = NSString

declare interface INSUserInterfaceItemSearching {
  searchForItemsWithSearchString_resultLimit_matchedItemHandler(searchString: NSString | string, resultLimit: NSInteger, handleMatchedItems: Block): void;
  localizedTitlesForItem(item: any): NSArray<any>;
  performActionForItem(item: any): void;
  showAllHelpTopicsForSearchString(searchString: NSString | string): void;
}

declare enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight = 0,
  NSUserInterfaceLayoutDirectionRightToLeft = 1,
}

declare enum NSUserInterfaceLayoutOrientation {
  NSUserInterfaceLayoutOrientationHorizontal = 0,
  NSUserInterfaceLayoutOrientationVertical = 1,
}

declare interface INSValidatedUserInterfaceItem {

  action(): string;
  tag(): NSInteger;
}

declare interface INSUserInterfaceValidations {
  validateUserInterfaceItem(item: any): boolean;
}

declare type NSTrackingRectTag = NSInteger

declare type NSToolTipTag = NSInteger

declare type NSViewFullScreenModeOptionKey = NSString

declare type NSDefinitionOptionKey = NSString

declare type NSDefinitionPresentationType = NSString

declare enum NSAutoresizingMaskOptions {
  NSViewNotSizable = 0,
  NSViewMinXMargin = 1,
  NSViewWidthSizable = 2,
  NSViewMaxXMargin = 4,
  NSViewMinYMargin = 8,
  NSViewHeightSizable = 16,
  NSViewMaxYMargin = 32,
}

declare enum NSBorderType {
  NSNoBorder = 0,
  NSLineBorder = 1,
  NSBezelBorder = 2,
  NSGrooveBorder = 3,
}

declare enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever = 0,
  NSViewLayerContentsRedrawOnSetNeedsDisplay = 1,
  NSViewLayerContentsRedrawDuringViewResize = 2,
  NSViewLayerContentsRedrawBeforeViewResize = 3,
  NSViewLayerContentsRedrawCrossfade = 4,
}

declare enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently = 0,
  NSViewLayerContentsPlacementScaleProportionallyToFit = 1,
  NSViewLayerContentsPlacementScaleProportionallyToFill = 2,
  NSViewLayerContentsPlacementCenter = 3,
  NSViewLayerContentsPlacementTop = 4,
  NSViewLayerContentsPlacementTopRight = 5,
  NSViewLayerContentsPlacementRight = 6,
  NSViewLayerContentsPlacementBottomRight = 7,
  NSViewLayerContentsPlacementBottom = 8,
  NSViewLayerContentsPlacementBottomLeft = 9,
  NSViewLayerContentsPlacementLeft = 10,
  NSViewLayerContentsPlacementTopLeft = 11,
}

class NSViewControllerAllocator<T extends NSViewController> extends NSResponderAllocator<T> {
  initWithNibName_bundle(nibNameOrNil: NSNibName | null, nibBundleOrNil: NSBundle | null): T;
}
declare class NSViewController extends NSResponder implements INSCoding, INSSeguePerforming, INSUserInterfaceItemIdentification {
  alloc<T extends NSViewController>(): NSViewControllerAllocator<T>;
  loadView(): void;
  commitEditingWithDelegate_didCommitSelector_contextInfo(delegate: any | null, didCommitSelector: string | null, contextInfo: void | null): void;
  commitEditing(): boolean;
  discardEditing(): void;
  viewDidLoad(): void;
  viewWillAppear(): void;
  viewDidAppear(): void;
  viewWillDisappear(): void;
  viewDidDisappear(): void;
  updateViewConstraints(): void;
  viewWillLayout(): void;
  viewDidLayout(): void;
  presentViewController_animator(viewController: NSViewController, animator: any): void;
  dismissViewController(viewController: NSViewController): void;
  dismissController(sender: any | null): IBAction;
  presentViewControllerAsSheet(viewController: NSViewController): void;
  presentViewControllerAsModalWindow(viewController: NSViewController): void;
  presentViewController_asPopoverRelativeToRect_ofView_preferredEdge_behavior(viewController: NSViewController, positioningRect: NSRect, positioningView: NSView, preferredEdge: NSRectEdge, behavior: NSPopoverBehavior): void;
  transitionFromViewController_toViewController_options_completionHandler(fromViewController: NSViewController, toViewController: NSViewController, options: NSViewControllerTransitionOptions, completion: Block): void;
  addChildViewController(childViewController: NSViewController): void;
  removeFromParentViewController(): void;
  insertChildViewController_atIndex(childViewController: NSViewController, index: NSInteger): void;
  removeChildViewControllerAtIndex(index: NSInteger): void;
  preferredContentSizeDidChangeForViewController(viewController: NSViewController): void;
  viewWillTransitionToSize(newSize: NSSize): void;
  presentViewController_asBCPopoverRelativeToView_preferredEdge_screenEdgeBehaviour(viewController: NSViewController, positioningView: NSView, preferredEdge: NSRectEdge, behaviour: BCPopoverScreenEdgeBehaviour): BCPopover;
  targetViewControllerForAction_sender(action: string, sender: any | null): NSViewController;
  ensureLoaded(): void;
  inspectorController(): MSInspectorController;
  reloadInspectorStack(sender: any): IBAction;
  encodeWithCoder(aCoder: NSCoder): void;
  prepareForSegue_sender(segue: NSStoryboardSegue, sender: any | null): void;
  performSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): void;
  shouldPerformSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  prepareForSegue_sender(segue: NSStoryboardSegue, sender: any | null): void;
  performSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): void;
  shouldPerformSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): boolean;

  nibName(): NSNibName;
  nibBundle(): NSBundle;
  representedObject(): any;
  setRepresentedObject(representedObject: any): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  view(): NSView;
  setView(view: NSView): void;
  viewLoaded(): boolean;
  preferredContentSize(): NSSize;
  setPreferredContentSize(preferredContentSize: NSSize): void;
  presentedViewControllers(): NSArray<any>;
  presentingViewController(): NSViewController;
  parentViewController(): NSViewController;
  childViewControllers(): NSArray<any>;
  setChildViewControllers(childViewControllers: NSArray<any> | any[]): void;
  storyboard(): NSStoryboard;
  extensionContext(): NSExtensionContext;
  sourceItemView(): NSView;
  setSourceItemView(sourceItemView: NSView): void;
  preferredScreenOrigin(): NSPoint;
  setPreferredScreenOrigin(preferredScreenOrigin: NSPoint): void;
  preferredMinimumSize(): NSSize;
  preferredMaximumSize(): NSSize;
  rootViewController(): NSViewController;
  identifier(): NSUserInterfaceItemIdentifier;
  setIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
}

declare interface INSViewControllerPresentationAnimator {
  animatePresentationOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
  animateDismissalOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
}

declare enum NSViewControllerTransitionOptions {
  NSViewControllerTransitionNone = 0x0,
  NSViewControllerTransitionCrossfade = 0x1,
  NSViewControllerTransitionSlideUp = 0x10,
  NSViewControllerTransitionSlideDown = 0x20,
  NSViewControllerTransitionSlideLeft = 0x40,
  NSViewControllerTransitionSlideRight = 0x80,
  NSViewControllerTransitionSlideForward = 0x140,
  NSViewControllerTransitionSlideBackward = 0x180,
  NSViewControllerTransitionAllowUserInteraction = 0x1000,
}

class NSVisualEffectViewAllocator<T extends NSVisualEffectView> extends NSViewAllocator<T> {}
declare class NSVisualEffectView extends NSView {
  alloc<T extends NSVisualEffectView>(): NSVisualEffectViewAllocator<T>;

  material(): NSVisualEffectMaterial;
  setMaterial(material: NSVisualEffectMaterial): void;
  interiorBackgroundStyle(): NSBackgroundStyle;
  blendingMode(): NSVisualEffectBlendingMode;
  setBlendingMode(blendingMode: NSVisualEffectBlendingMode): void;
  state(): NSVisualEffectState;
  setState(state: NSVisualEffectState): void;
  maskImage(): NSImage;
  setMaskImage(maskImage: NSImage): void;
  emphasized(): boolean;
  setEmphasized(emphasized: boolean): void;
}

declare enum NSVisualEffectMaterial {
  NSVisualEffectMaterialAppearanceBased = 0,
  NSVisualEffectMaterialTitlebar = 3,
  NSVisualEffectMaterialSelection = 4,
  NSVisualEffectMaterialMenu = 5,
  NSVisualEffectMaterialPopover = 6,
  NSVisualEffectMaterialSidebar = 7,
  NSVisualEffectMaterialLight = 1,
  NSVisualEffectMaterialDark = 2,
  NSVisualEffectMaterialMediumLight = 8,
  NSVisualEffectMaterialUltraDark = 9,
}

declare enum NSVisualEffectBlendingMode {
  NSVisualEffectBlendingModeBehindWindow,
  NSVisualEffectBlendingModeWithinWindow,
}

declare enum NSVisualEffectState {
  NSVisualEffectStateFollowsWindowActiveState,
  NSVisualEffectStateActive,
  NSVisualEffectStateInactive,
}

declare interface INSWindowDelegate {
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
}

declare type NSWindowLevel = NSInteger

declare type NSWindowFrameAutosaveName = NSString

declare type NSWindowTabbingIdentifier = NSString

declare enum NSWindowStyleMask {
  NSWindowStyleMaskBorderless = 0,
  NSWindowStyleMaskTitled = 1 << 0,
  NSWindowStyleMaskClosable = 1 << 1,
  NSWindowStyleMaskMiniaturizable = 1 << 2,
  NSWindowStyleMaskResizable = 1 << 3,
  NSWindowStyleMaskTexturedBackground = 1 << 8,
  NSWindowStyleMaskUnifiedTitleAndToolbar = 1 << 12,
  NSWindowStyleMaskFullScreen = 1 << 14,
  NSWindowStyleMaskFullSizeContentView = 1 << 15,
  NSWindowStyleMaskUtilityWindow = 1 << 4,
  NSWindowStyleMaskDocModalWindow = 1 << 6,
  NSWindowStyleMaskNonactivatingPanel = 1 << 7,
  NSWindowStyleMaskHUDWindow = 1 << 13,
}

declare enum NSWindowSharingType {
  NSWindowSharingNone = 0,
  NSWindowSharingReadOnly = 1,
  NSWindowSharingReadWrite = 2,
}

declare enum NSWindowBackingLocation {
  NSWindowBackingLocationDefault = 0,
  NSWindowBackingLocationVideoMemory = 1,
  NSWindowBackingLocationMainMemory = 2,
}

declare enum NSWindowCollectionBehavior {
  NSWindowCollectionBehaviorDefault = 0,
  NSWindowCollectionBehaviorCanJoinAllSpaces = 1 << 0,
  NSWindowCollectionBehaviorMoveToActiveSpace = 1 << 1,
  NSWindowCollectionBehaviorManaged = 1 << 2,
  NSWindowCollectionBehaviorTransient = 1 << 3,
  NSWindowCollectionBehaviorStationary = 1 << 4,
  NSWindowCollectionBehaviorParticipatesInCycle = 1 << 5,
  NSWindowCollectionBehaviorIgnoresCycle = 1 << 6,
  NSWindowCollectionBehaviorFullScreenPrimary = 1 << 7,
  NSWindowCollectionBehaviorFullScreenAuxiliary = 1 << 8,
  NSWindowCollectionBehaviorFullScreenNone = 1 << 9,
  NSWindowCollectionBehaviorFullScreenAllowsTiling = 1 << 11,
  NSWindowCollectionBehaviorFullScreenDisallowsTiling = 1 << 12,
}

declare enum NSWindowAnimationBehavior {
  NSWindowAnimationBehaviorDefault = 0,
  NSWindowAnimationBehaviorNone = 2,
  NSWindowAnimationBehaviorDocumentWindow = 3,
  NSWindowAnimationBehaviorUtilityWindow = 4,
  NSWindowAnimationBehaviorAlertPanel = 5,
}

declare enum NSWindowNumberListOptions {
  NSWindowNumberListAllApplications = 1 << 0,
  NSWindowNumberListAllSpaces = 1 << 4,
}

declare enum NSWindowOcclusionState {
  NSWindowOcclusionStateVisible = 1 << 1,
}

declare enum NSSelectionDirection {
  NSDirectSelection = 0,
  NSSelectingNext,
  NSSelectingPrevious,
}

declare enum NSWindowButton {
  NSWindowCloseButton,
  NSWindowMiniaturizeButton,
  NSWindowZoomButton,
  NSWindowToolbarButton,
  NSWindowDocumentIconButton,
  NSWindowDocumentVersionsButton = 6,
  NSWindowFullScreenButton,
}

declare enum NSWindowTitleVisibility {
  NSWindowTitleVisible = 0,
  NSWindowTitleHidden = 1,
}

declare enum NSWindowUserTabbingPreference {
  NSWindowUserTabbingPreferenceManual,
  NSWindowUserTabbingPreferenceAlways,
  NSWindowUserTabbingPreferenceInFullScreen,
}

declare enum NSWindowTabbingMode {
  NSWindowTabbingModeAutomatic,
  NSWindowTabbingModePreferred,
  NSWindowTabbingModeDisallowed,
}

class NSWindowControllerAllocator<T extends NSWindowController> extends NSResponderAllocator<T> {
  initWithWindow(window: NSWindow | null): T;
  initWithWindowNibName(windowNibName: NSNibName): T;
  initWithWindowNibName_owner(windowNibName: NSNibName, owner: any): T;
  initWithWindowNibPath_owner(windowNibPath: NSString | string, owner: any): T;
}
declare class NSWindowController extends NSResponder implements INSSeguePerforming {
  alloc<T extends NSWindowController>(): NSWindowControllerAllocator<T>;
  setDocumentEdited(dirtyFlag: boolean): void;
  synchronizeWindowTitleWithDocumentName(): void;
  windowTitleForDocumentDisplayName(displayName: NSString | string): NSString;
  windowWillLoad(): void;
  windowDidLoad(): void;
  loadWindow(): void;
  close(): void;
  showWindow(sender: any | null): IBAction;
  dismissController(sender: any | null): IBAction;
  prepareForSegue_sender(segue: NSStoryboardSegue, sender: any | null): void;
  performSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): void;
  shouldPerformSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): boolean;
  prepareForSegue_sender(segue: NSStoryboardSegue, sender: any | null): void;
  performSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): void;
  shouldPerformSegueWithIdentifier_sender(identifier: NSStoryboardSegueIdentifier, sender: any | null): boolean;

  windowNibName(): NSNibName;
  windowNibPath(): NSString;
  owner(): any;
  windowFrameAutosaveName(): NSWindowFrameAutosaveName;
  setWindowFrameAutosaveName(windowFrameAutosaveName: NSWindowFrameAutosaveName): void;
  shouldCascadeWindows(): boolean;
  setShouldCascadeWindows(shouldCascadeWindows: boolean): void;
  document(): any;
  setDocument(document: any): void;
  shouldCloseDocument(): boolean;
  setShouldCloseDocument(shouldCloseDocument: boolean): void;
  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  window(): NSWindow;
  setWindow(window: NSWindow): void;
  windowLoaded(): boolean;
  storyboard(): NSStoryboard;
}

declare interface INSWindowRestoration {
}

class NSWindowTabAllocator<T extends NSWindowTab> extends NSObjectAllocator<T> {}
declare class NSWindowTab extends NSObject {
  alloc<T extends NSWindowTab>(): NSWindowTabAllocator<T>;

  title(): NSString;
  setTitle(title: NSString | string): void;
  attributedTitle(): NSAttributedString;
  setAttributedTitle(attributedTitle: NSAttributedString): void;
  toolTip(): NSString;
  setToolTip(toolTip: NSString | string): void;
  accessoryView(): NSView;
  setAccessoryView(accessoryView: NSView): void;
}

class NSWindowTabGroupAllocator<T extends NSWindowTabGroup> extends NSObjectAllocator<T> {}
declare class NSWindowTabGroup extends NSObject {
  alloc<T extends NSWindowTabGroup>(): NSWindowTabGroupAllocator<T>;
  addWindow(window: NSWindow): void;
  insertWindow_atIndex(window: NSWindow, index: NSInteger): void;
  removeWindow(window: NSWindow): void;

  identifier(): NSWindowTabbingIdentifier;
  windows(): NSArray<any>;
  overviewVisible(): boolean;
  setOverviewVisible(overviewVisible: boolean): void;
  tabBarVisible(): boolean;
  selectedWindow(): NSWindow;
  setSelectedWindow(selectedWindow: NSWindow): void;
}

declare type NSWorkspaceLaunchConfigurationKey = NSString

declare type NSWorkspaceDesktopImageOptionKey = NSString

declare type NSWorkspaceFileOperationName = NSString

declare enum NSWorkspaceLaunchOptions {
  NSWorkspaceLaunchAndPrint = 0x00000002,
  NSWorkspaceLaunchWithErrorPresentation = 0x00000040,
  NSWorkspaceLaunchInhibitingBackgroundOnly = 0x00000080,
  NSWorkspaceLaunchWithoutAddingToRecents = 0x00000100,
  NSWorkspaceLaunchWithoutActivation = 0x00000200,
  NSWorkspaceLaunchAsync = 0x00010000,
  NSWorkspaceLaunchNewInstance = 0x00080000,
  NSWorkspaceLaunchAndHide = 0x00100000,
  NSWorkspaceLaunchAndHideOthers = 0x00200000,
  NSWorkspaceLaunchDefault,
  NSWorkspaceLaunchAllowingClassicStartup = 0x00020000,
  NSWorkspaceLaunchPreferringClassic = 0x00040000,
}

declare enum NSWorkspaceIconCreationOptions {
  NSExcludeQuickDrawElementsIconCreationOption = 1 << 1,
  NSExclude10_4ElementsIconCreationOption = 1 << 2,
}

class AFHTTPRequestOperationAllocator<T extends AFHTTPRequestOperation> extends AFURLConnectionOperationAllocator<T> {}
declare class AFHTTPRequestOperation extends AFURLConnectionOperation {
  alloc<T extends AFHTTPRequestOperation>(): AFHTTPRequestOperationAllocator<T>;
  setCompletionBlockWithSuccess_failure(success: Block | null, failure: Block | null): void;

  // @ts-ignore
  response(): NSHTTPURLResponse;
  responseSerializer(): AFHTTPResponseSerializer;
  setResponseSerializer(responseSerializer: AFHTTPResponseSerializer): void;
  responseObject(): any;
}

class AFHTTPRequestOperationManagerAllocator<T extends AFHTTPRequestOperationManager> extends NSObjectAllocator<T> {
  initWithBaseURL(url: NSURL | null): T;
}
declare class AFHTTPRequestOperationManager extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends AFHTTPRequestOperationManager>(): AFHTTPRequestOperationManagerAllocator<T>;
  static manager(): AFHTTPRequestOperationManager;
  HTTPRequestOperationWithRequest_success_failure(request: NSURLRequest, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  GET_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  HEAD_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  POST_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  POST_parameters_constructingBodyWithBlock_success_failure(URLString: NSString | string, parameters: any | null, block: Block | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  PUT_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  PATCH_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  DELETE_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): AFHTTPRequestOperation;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  baseURL(): NSURL;
  requestSerializer(): AFHTTPRequestSerializer;
  setRequestSerializer(requestSerializer: AFHTTPRequestSerializer): void;
  responseSerializer(): AFHTTPResponseSerializer;
  setResponseSerializer(responseSerializer: AFHTTPResponseSerializer): void;
  operationQueue(): NSOperationQueue;
  setOperationQueue(operationQueue: NSOperationQueue): void;
  shouldUseCredentialStorage(): boolean;
  setShouldUseCredentialStorage(shouldUseCredentialStorage: boolean): void;
  credential(): NSURLCredential;
  setCredential(credential: NSURLCredential): void;
  securityPolicy(): AFSecurityPolicy;
  setSecurityPolicy(securityPolicy: AFSecurityPolicy): void;
  reachabilityManager(): AFNetworkReachabilityManager;
  setReachabilityManager(reachabilityManager: AFNetworkReachabilityManager): void;
  completionQueue(): dispatch_queue_t;
  setCompletionQueue(completionQueue: dispatch_queue_t): void;
  completionGroup(): dispatch_group_t;
  setCompletionGroup(completionGroup: dispatch_group_t): void;
  static supportsSecureCoding(): boolean;
}

class AFHTTPSessionManagerAllocator<T extends AFHTTPSessionManager> extends AFURLSessionManagerAllocator<T> {
  initWithBaseURL(url: NSURL | null): T;
  initWithBaseURL_sessionConfiguration(url: NSURL | null, configuration: NSURLSessionConfiguration | null): T;
}
declare class AFHTTPSessionManager extends AFURLSessionManager implements INSSecureCoding, INSCopying {
  alloc<T extends AFHTTPSessionManager>(): AFHTTPSessionManagerAllocator<T>;
  static manager(): AFHTTPSessionManager;
  GET_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  HEAD_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  POST_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  POST_parameters_constructingBodyWithBlock_success_failure(URLString: NSString | string, parameters: any | null, block: Block | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  PUT_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  PATCH_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  DELETE_parameters_success_failure(URLString: NSString | string, parameters: any | null, success: Block | null, failure: Block | null): NSURLSessionDataTask;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  baseURL(): NSURL;
  requestSerializer(): AFHTTPRequestSerializer;
  setRequestSerializer(requestSerializer: AFHTTPRequestSerializer): void;
  responseSerializer(): AFHTTPResponseSerializer;
  setResponseSerializer(responseSerializer: AFHTTPResponseSerializer): void;
  static supportsSecureCoding(): boolean;
}

class AFNetworkReachabilityManagerAllocator<T extends AFNetworkReachabilityManager> extends NSObjectAllocator<T> {
  initWithReachability(reachability: SCNetworkReachabilityRef): T;
}
declare class AFNetworkReachabilityManager extends NSObject {
  alloc<T extends AFNetworkReachabilityManager>(): AFNetworkReachabilityManagerAllocator<T>;
  static sharedManager(): AFNetworkReachabilityManager;
  static managerForDomain(domain: NSString | string): AFNetworkReachabilityManager;
  static managerForAddress(address: void): AFNetworkReachabilityManager;
  startMonitoring(): void;
  stopMonitoring(): void;
  localizedNetworkReachabilityStatusString(): NSString;
  setReachabilityStatusChangeBlock(block: Block | null): void;

  networkReachabilityStatus(): AFNetworkReachabilityStatus;
  reachable(): boolean;
  reachableViaWWAN(): boolean;
  reachableViaWiFi(): boolean;
}

declare enum AFNetworkReachabilityStatus {
  AFNetworkReachabilityStatusUnknown = -1,
  AFNetworkReachabilityStatusNotReachable = 0,
  AFNetworkReachabilityStatusReachableViaWWAN = 1,
  AFNetworkReachabilityStatusReachableViaWiFi = 2,
}

class AFSecurityPolicyAllocator<T extends AFSecurityPolicy> extends NSObjectAllocator<T> {}
declare class AFSecurityPolicy extends NSObject implements INSSecureCoding, INSCopying {
  alloc<T extends AFSecurityPolicy>(): AFSecurityPolicyAllocator<T>;
  static defaultPolicy(): AFSecurityPolicy;
  static policyWithPinningMode(pinningMode: AFSSLPinningMode): AFSecurityPolicy;
  evaluateServerTrust_DEPRECATED_ATTRIBUTE(serverTrust: SecTrustRef): boolean;
  evaluateServerTrust_forDomain(serverTrust: SecTrustRef, domain: NSString | string | null): boolean;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  SSLPinningMode(): AFSSLPinningMode;
  pinnedCertificates(): NSArray<any>;
  setPinnedCertificates(pinnedCertificates: NSArray<any> | any[]): void;
  allowInvalidCertificates(): boolean;
  setAllowInvalidCertificates(allowInvalidCertificates: boolean): void;
  validatesDomainName(): boolean;
  setValidatesDomainName(validatesDomainName: boolean): void;
  static supportsSecureCoding(): boolean;
}

declare enum AFSSLPinningMode {
  AFSSLPinningModeNone,
  AFSSLPinningModePublicKey,
  AFSSLPinningModeCertificate,
}

class AFURLConnectionOperationAllocator<T extends AFURLConnectionOperation> extends NSOperationAllocator<T> {
  initWithRequest(urlRequest: NSURLRequest): T;
}
declare class AFURLConnectionOperation extends NSOperation implements INSURLConnectionDelegate, INSURLConnectionDataDelegate, INSSecureCoding, INSCopying {
  alloc<T extends AFURLConnectionOperation>(): AFURLConnectionOperationAllocator<T>;
  pause(): void;
  isPaused(): boolean;
  resume(): void;
  setShouldExecuteAsBackgroundTaskWithExpirationHandler(handler: Block | null): void;
  setUploadProgressBlock(block: Block | null): void;
  setDownloadProgressBlock(block: Block | null): void;
  setWillSendRequestForAuthenticationChallengeBlock(block: Block | null): void;
  setRedirectResponseBlock(block: Block | null): void;
  setCacheResponseBlock(block: Block | null): void;
  static batchOfRequestOperations_progressBlock_completionBlock(operations: NSArray<any> | any[] | null, progressBlock: Block | null, completionBlock: Block | null): NSArray<any>;
  connection_didFailWithError(connection: NSURLConnection, error: NSError): void;
  connectionShouldUseCredentialStorage(connection: NSURLConnection): boolean;
  connection_willSendRequestForAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_canAuthenticateAgainstProtectionSpace(connection: NSURLConnection, protectionSpace: NSURLProtectionSpace): boolean;
  connection_didReceiveAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_didCancelAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_willSendRequest_redirectResponse(connection: NSURLConnection, request: NSURLRequest, response: NSURLResponse | null): NSURLRequest;
  connection_didReceiveResponse(connection: NSURLConnection, response: NSURLResponse): void;
  connection_didReceiveData(connection: NSURLConnection, data: NSData): void;
  connection_needNewBodyStream(connection: NSURLConnection, request: NSURLRequest): NSInputStream;
  connection_didSendBodyData_totalBytesWritten_totalBytesExpectedToWrite(connection: NSURLConnection, bytesWritten: NSInteger, totalBytesWritten: NSInteger, totalBytesExpectedToWrite: NSInteger): void;
  connection_willCacheResponse(connection: NSURLConnection, cachedResponse: NSCachedURLResponse): NSCachedURLResponse;
  connectionDidFinishLoading(connection: NSURLConnection): void;
  copyWithZone(zone: NSZone | null): any;
  connection_didFailWithError(connection: NSURLConnection, error: NSError): void;
  connectionShouldUseCredentialStorage(connection: NSURLConnection): boolean;
  connection_willSendRequestForAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_canAuthenticateAgainstProtectionSpace(connection: NSURLConnection, protectionSpace: NSURLProtectionSpace): boolean;
  connection_didReceiveAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_didCancelAuthenticationChallenge(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
  connection_willSendRequest_redirectResponse(connection: NSURLConnection, request: NSURLRequest, response: NSURLResponse | null): NSURLRequest;
  connection_didReceiveResponse(connection: NSURLConnection, response: NSURLResponse): void;
  connection_didReceiveData(connection: NSURLConnection, data: NSData): void;
  connection_needNewBodyStream(connection: NSURLConnection, request: NSURLRequest): NSInputStream;
  connection_didSendBodyData_totalBytesWritten_totalBytesExpectedToWrite(connection: NSURLConnection, bytesWritten: NSInteger, totalBytesWritten: NSInteger, totalBytesExpectedToWrite: NSInteger): void;
  connection_willCacheResponse(connection: NSURLConnection, cachedResponse: NSCachedURLResponse): NSCachedURLResponse;
  connectionDidFinishLoading(connection: NSURLConnection): void;
  copyWithZone(zone: NSZone | null): any;

  runLoopModes(): NSSet<any>;
  setRunLoopModes(runLoopModes: NSSet<any>): void;
  request(): NSURLRequest;
  response(): NSURLResponse;
  error(): NSError;
  responseData(): NSData;
  responseString(): NSString;
  responseStringEncoding(): NSStringEncoding;
  shouldUseCredentialStorage(): boolean;
  setShouldUseCredentialStorage(shouldUseCredentialStorage: boolean): void;
  credential(): NSURLCredential;
  setCredential(credential: NSURLCredential): void;
  securityPolicy(): AFSecurityPolicy;
  setSecurityPolicy(securityPolicy: AFSecurityPolicy): void;
  inputStream(): NSInputStream;
  setInputStream(inputStream: NSInputStream): void;
  outputStream(): NSOutputStream;
  setOutputStream(outputStream: NSOutputStream): void;
  completionQueue(): dispatch_queue_t;
  setCompletionQueue(completionQueue: dispatch_queue_t): void;
  completionGroup(): dispatch_group_t;
  setCompletionGroup(completionGroup: dispatch_group_t): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  static supportsSecureCoding(): boolean;
}

class AFHTTPRequestSerializerAllocator<T extends AFHTTPRequestSerializer> extends NSObjectAllocator<T> {}
declare class AFHTTPRequestSerializer extends NSObject implements IAFURLRequestSerialization {
  alloc<T extends AFHTTPRequestSerializer>(): AFHTTPRequestSerializerAllocator<T>;
  static serializer(): AFHTTPRequestSerializer;
  setValue_forHTTPHeaderField(value: NSString | string | null, field: NSString | string): void;
  valueForHTTPHeaderField(field: NSString | string): NSString;
  setAuthorizationHeaderFieldWithUsername_password(username: NSString | string, password: NSString | string): void;
  setAuthorizationHeaderFieldWithToken_DEPRECATED_ATTRIBUTE(token: NSString | string): void;
  clearAuthorizationHeader(): void;
  setQueryStringSerializationWithStyle(style: AFHTTPRequestQueryStringSerializationStyle): void;
  setQueryStringSerializationWithBlock(block: Block | null): void;
  requestWithMethod_URLString_parameters_DEPRECATED_ATTRIBUTE(method: NSString | string, URLString: NSString | string, parameters: any): NSMutableURLRequest;
  requestWithMethod_URLString_parameters_error(method: NSString | string, URLString: NSString | string, parameters: any | null, error: NSError): NSMutableURLRequest;
  multipartFormRequestWithMethod_URLString_parameters_constructingBodyWithBlock_DEPRECATED_ATTRIBUTE(method: NSString | string, URLString: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, block: Block): NSMutableURLRequest;
  multipartFormRequestWithMethod_URLString_parameters_constructingBodyWithBlock_error(method: NSString | string, URLString: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any} | null, block: Block | null, error: NSError): NSMutableURLRequest;
  requestWithMultipartFormRequest_writingStreamContentsToFile_completionHandler(request: NSURLRequest, fileURL: NSURL, handler: Block | null): NSMutableURLRequest;
  requestBySerializingRequest_withParameters_error(request: NSURLRequest, parameters: any | null, error: NSError): NSURLRequest;
  requestBySerializingRequest_withParameters_error(request: NSURLRequest, parameters: any | null, error: NSError): NSURLRequest;

  stringEncoding(): NSStringEncoding;
  setStringEncoding(stringEncoding: NSStringEncoding): void;
  allowsCellularAccess(): boolean;
  setAllowsCellularAccess(allowsCellularAccess: boolean): void;
  cachePolicy(): NSURLRequestCachePolicy;
  setCachePolicy(cachePolicy: NSURLRequestCachePolicy): void;
  HTTPShouldHandleCookies(): boolean;
  setHTTPShouldHandleCookies(HTTPShouldHandleCookies: boolean): void;
  HTTPShouldUsePipelining(): boolean;
  setHTTPShouldUsePipelining(HTTPShouldUsePipelining: boolean): void;
  networkServiceType(): NSURLRequestNetworkServiceType;
  setNetworkServiceType(networkServiceType: NSURLRequestNetworkServiceType): void;
  timeoutInterval(): NSTimeInterval;
  setTimeoutInterval(timeoutInterval: NSTimeInterval): void;
  HTTPRequestHeaders(): NSDictionary<any, any>;
  HTTPMethodsEncodingParametersInURI(): NSSet<any>;
  setHTTPMethodsEncodingParametersInURI(HTTPMethodsEncodingParametersInURI: NSSet<any>): void;
}

class AFJSONRequestSerializerAllocator<T extends AFJSONRequestSerializer> extends AFHTTPRequestSerializerAllocator<T> {}
declare class AFJSONRequestSerializer extends AFHTTPRequestSerializer {
  alloc<T extends AFJSONRequestSerializer>(): AFJSONRequestSerializerAllocator<T>;
  static serializerWithWritingOptions(writingOptions: NSJSONWritingOptions): AFJSONRequestSerializer;

  writingOptions(): NSJSONWritingOptions;
  setWritingOptions(writingOptions: NSJSONWritingOptions): void;
}

class AFPropertyListRequestSerializerAllocator<T extends AFPropertyListRequestSerializer> extends AFHTTPRequestSerializerAllocator<T> {}
declare class AFPropertyListRequestSerializer extends AFHTTPRequestSerializer {
  alloc<T extends AFPropertyListRequestSerializer>(): AFPropertyListRequestSerializerAllocator<T>;
  static serializerWithFormat_writeOptions(format: NSPropertyListFormat, writeOptions: NSPropertyListWriteOptions): AFPropertyListRequestSerializer;

  format(): NSPropertyListFormat;
  setFormat(format: NSPropertyListFormat): void;
  writeOptions(): NSPropertyListWriteOptions;
  setWriteOptions(writeOptions: NSPropertyListWriteOptions): void;
}

declare interface IAFURLRequestSerialization {
  requestBySerializingRequest_withParameters_error(request: NSURLRequest, parameters: any | null, error: NSError): NSURLRequest;
}

declare interface IAFMultipartFormData {
  appendPartWithFileURL_name_error(fileURL: NSURL, name: NSString | string, error: NSError): boolean;
  appendPartWithFileURL_name_fileName_mimeType_error(fileURL: NSURL, name: NSString | string, fileName: NSString | string, mimeType: NSString | string, error: NSError): boolean;
  appendPartWithInputStream_name_fileName_length_mimeType(inputStream: NSInputStream | null, name: NSString | string, fileName: NSString | string, length: number, mimeType: NSString | string): void;
  appendPartWithFileData_name_fileName_mimeType(data: NSData, name: NSString | string, fileName: NSString | string, mimeType: NSString | string): void;
  appendPartWithFormData_name(data: NSData, name: NSString | string): void;
  appendPartWithHeaders_body(headers: NSDictionary<any, any> | {[key: string]: any} | null, body: NSData): void;
  throttleBandwidthWithPacketSize_delay(numberOfBytes: NSUInteger, delay: NSTimeInterval): void;
}

declare enum AFHTTPRequestQueryStringSerializationStyle {
  AFHTTPRequestQueryStringDefaultStyle = 0,
}

class AFHTTPResponseSerializerAllocator<T extends AFHTTPResponseSerializer> extends NSObjectAllocator<T> {
  init(): T;
}
declare class AFHTTPResponseSerializer extends NSObject implements IAFURLResponseSerialization {
  alloc<T extends AFHTTPResponseSerializer>(): AFHTTPResponseSerializerAllocator<T>;
  static serializer(): AFHTTPResponseSerializer;
  validateResponse_data_error(response: NSHTTPURLResponse | null, data: NSData | null, error: NSError): boolean;
  responseObjectForResponse_data_error(response: NSURLResponse | null, data: NSData | null, error: NSError): any;
  responseObjectForResponse_data_error(response: NSURLResponse | null, data: NSData | null, error: NSError): any;

  stringEncoding(): NSStringEncoding;
  setStringEncoding(stringEncoding: NSStringEncoding): void;
  acceptableStatusCodes(): NSIndexSet;
  setAcceptableStatusCodes(acceptableStatusCodes: NSIndexSet): void;
  acceptableContentTypes(): NSSet<any>;
  setAcceptableContentTypes(acceptableContentTypes: NSSet<any>): void;
}

class AFJSONResponseSerializerAllocator<T extends AFJSONResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFJSONResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFJSONResponseSerializer>(): AFJSONResponseSerializerAllocator<T>;
  static serializerWithReadingOptions(readingOptions: NSJSONReadingOptions): AFJSONResponseSerializer;

  readingOptions(): NSJSONReadingOptions;
  setReadingOptions(readingOptions: NSJSONReadingOptions): void;
  removesKeysWithNullValues(): boolean;
  setRemovesKeysWithNullValues(removesKeysWithNullValues: boolean): void;
}

class AFXMLParserResponseSerializerAllocator<T extends AFXMLParserResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFXMLParserResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFXMLParserResponseSerializer>(): AFXMLParserResponseSerializerAllocator<T>;
}

class AFXMLDocumentResponseSerializerAllocator<T extends AFXMLDocumentResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFXMLDocumentResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFXMLDocumentResponseSerializer>(): AFXMLDocumentResponseSerializerAllocator<T>;
  static serializerWithXMLDocumentOptions(mask: NSUInteger): AFXMLDocumentResponseSerializer;

  options(): NSUInteger;
  setOptions(options: NSUInteger): void;
}

class AFPropertyListResponseSerializerAllocator<T extends AFPropertyListResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFPropertyListResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFPropertyListResponseSerializer>(): AFPropertyListResponseSerializerAllocator<T>;
  static serializerWithFormat_readOptions(format: NSPropertyListFormat, readOptions: NSPropertyListReadOptions): AFPropertyListResponseSerializer;

  format(): NSPropertyListFormat;
  setFormat(format: NSPropertyListFormat): void;
  readOptions(): NSPropertyListReadOptions;
  setReadOptions(readOptions: NSPropertyListReadOptions): void;
}

class AFImageResponseSerializerAllocator<T extends AFImageResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFImageResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFImageResponseSerializer>(): AFImageResponseSerializerAllocator<T>;

  imageScale(): CGFloat;
  setImageScale(imageScale: CGFloat): void;
  automaticallyInflatesResponseImage(): boolean;
  setAutomaticallyInflatesResponseImage(automaticallyInflatesResponseImage: boolean): void;
}

class AFCompoundResponseSerializerAllocator<T extends AFCompoundResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFCompoundResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFCompoundResponseSerializer>(): AFCompoundResponseSerializerAllocator<T>;
  static compoundSerializerWithResponseSerializers(responseSerializers: NSArray<any> | any[]): AFCompoundResponseSerializer;

  responseSerializers(): NSArray<any>;
}

declare interface IAFURLResponseSerialization {
  responseObjectForResponse_data_error(response: NSURLResponse | null, data: NSData | null, error: NSError): any;
}

class AFURLSessionManagerAllocator<T extends AFURLSessionManager> extends NSObjectAllocator<T> {
  initWithSessionConfiguration(configuration: NSURLSessionConfiguration | null): T;
}
declare class AFURLSessionManager extends NSObject implements INSURLSessionDelegate, INSURLSessionTaskDelegate, INSURLSessionDataDelegate, INSURLSessionDownloadDelegate, INSSecureCoding, INSCopying {
  alloc<T extends AFURLSessionManager>(): AFURLSessionManagerAllocator<T>;
  invalidateSessionCancelingTasks(cancelPendingTasks: boolean): void;
  dataTaskWithRequest_completionHandler(request: NSURLRequest, completionHandler: Block | null): NSURLSessionDataTask;
  uploadTaskWithRequest_fromFile_progress_completionHandler(request: NSURLRequest, fileURL: NSURL, progress: NSProgress, completionHandler: Block | null): NSURLSessionUploadTask;
  uploadTaskWithRequest_fromData_progress_completionHandler(request: NSURLRequest, bodyData: NSData | null, progress: NSProgress, completionHandler: Block | null): NSURLSessionUploadTask;
  uploadTaskWithStreamedRequest_progress_completionHandler(request: NSURLRequest, progress: NSProgress, completionHandler: Block | null): NSURLSessionUploadTask;
  downloadTaskWithRequest_progress_destination_completionHandler(request: NSURLRequest, progress: NSProgress, destination: Block | null, completionHandler: Block | null): NSURLSessionDownloadTask;
  downloadTaskWithResumeData_progress_destination_completionHandler(resumeData: NSData, progress: NSProgress, destination: Block | null, completionHandler: Block | null): NSURLSessionDownloadTask;
  uploadProgressForTask(uploadTask: NSURLSessionUploadTask): NSProgress;
  downloadProgressForTask(downloadTask: NSURLSessionDownloadTask): NSProgress;
  setSessionDidBecomeInvalidBlock(block: Block | null): void;
  setSessionDidReceiveAuthenticationChallengeBlock(block: Block | null): void;
  setTaskNeedNewBodyStreamBlock(block: Block | null): void;
  setTaskWillPerformHTTPRedirectionBlock(block: Block | null): void;
  setTaskDidReceiveAuthenticationChallengeBlock(block: Block | null): void;
  setTaskDidSendBodyDataBlock(block: Block | null): void;
  setTaskDidCompleteBlock(block: Block | null): void;
  setDataTaskDidReceiveResponseBlock(block: Block | null): void;
  setDataTaskDidBecomeDownloadTaskBlock(block: Block | null): void;
  setDataTaskDidReceiveDataBlock(block: Block | null): void;
  setDataTaskWillCacheResponseBlock(block: Block | null): void;
  setDidFinishEventsForBackgroundURLSessionBlock(block: Block | null): void;
  setDownloadTaskDidFinishDownloadingBlock(block: Block | null): void;
  setDownloadTaskDidWriteDataBlock(block: Block | null): void;
  setDownloadTaskDidResumeBlock(block: Block | null): void;
  URLSession_didBecomeInvalidWithError(session: NSURLSession, error: NSError | null): void;
  URLSession_didReceiveChallenge_completionHandler(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession): void;
  URLSession_task_willBeginDelayedRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: Block): void;
  URLSession_taskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;
  URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: Block): void;
  URLSession_task_didReceiveChallenge_completionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSession_task_needNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: Block): void;
  URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  URLSession_task_didFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;
  URLSession_task_didCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;
  URLSession_dataTask_didReceiveResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: Block): void;
  URLSession_dataTask_didBecomeDownloadTask(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;
  URLSession_dataTask_didBecomeStreamTask(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): void;
  URLSession_dataTask_didReceiveData(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;
  URLSession_dataTask_willCacheResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: Block): void;
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
  copyWithZone(zone: NSZone | null): any;
  URLSession_didBecomeInvalidWithError(session: NSURLSession, error: NSError | null): void;
  URLSession_didReceiveChallenge_completionHandler(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession): void;
  URLSession_task_willBeginDelayedRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: Block): void;
  URLSession_taskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;
  URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: Block): void;
  URLSession_task_didReceiveChallenge_completionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSession_task_needNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: Block): void;
  URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  URLSession_task_didFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;
  URLSession_task_didCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;
  URLSession_dataTask_didReceiveResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: Block): void;
  URLSession_dataTask_didBecomeDownloadTask(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;
  URLSession_dataTask_didBecomeStreamTask(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): void;
  URLSession_dataTask_didReceiveData(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;
  URLSession_dataTask_willCacheResponse_completionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: Block): void;
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
  copyWithZone(zone: NSZone | null): any;

  session(): NSURLSession;
  operationQueue(): NSOperationQueue;
  responseSerializer(): any;
  setResponseSerializer(responseSerializer: any): void;
  securityPolicy(): AFSecurityPolicy;
  setSecurityPolicy(securityPolicy: AFSecurityPolicy): void;
  reachabilityManager(): AFNetworkReachabilityManager;
  setReachabilityManager(reachabilityManager: AFNetworkReachabilityManager): void;
  tasks(): NSArray<any>;
  dataTasks(): NSArray<any>;
  uploadTasks(): NSArray<any>;
  downloadTasks(): NSArray<any>;
  completionQueue(): dispatch_queue_t;
  setCompletionQueue(completionQueue: dispatch_queue_t): void;
  completionGroup(): dispatch_group_t;
  setCompletionGroup(completionGroup: dispatch_group_t): void;
  attemptsToRecreateUploadTasksForBackgroundSessions(): boolean;
  setAttemptsToRecreateUploadTasksForBackgroundSessions(attemptsToRecreateUploadTasksForBackgroundSessions: boolean): void;
  static supportsSecureCoding(): boolean;
}

class ExtensionDelegateAllocator<T extends ExtensionDelegate> extends NSObjectAllocator<T> {}
declare class ExtensionDelegate extends NSObject implements IWKExtensionDelegate {
  alloc<T extends ExtensionDelegate>(): ExtensionDelegateAllocator<T>;
}

class AFAppDotNetAPIClientAllocator<T extends AFAppDotNetAPIClient> extends AFHTTPSessionManagerAllocator<T> {}
declare class AFAppDotNetAPIClient extends AFHTTPSessionManager {
  alloc<T extends AFAppDotNetAPIClient>(): AFAppDotNetAPIClientAllocator<T>;
  static sharedClient(): AFAppDotNetAPIClient;
}

class PostAllocator<T extends Post> extends NSObjectAllocator<T> {
  initWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class Post extends NSObject {
  alloc<T extends Post>(): PostAllocator<T>;
  static globalTimelinePostsWithBlock(block: Block): NSURLSessionDataTask;

  postID(): NSUInteger;
  setPostID(postID: NSUInteger): void;
  text(): NSString;
  setText(text: NSString | string): void;
  user(): User;
  setUser(user: User): void;
}

class UserAllocator<T extends User> extends NSObjectAllocator<T> {
  initWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class User extends NSObject {
  alloc<T extends User>(): UserAllocator<T>;

  userID(): NSUInteger;
  username(): NSString;
  avatarImageURL(): NSURL;
  profileImage(): NSImage;
  setProfileImage(profileImage: NSImage): void;
}

class AFNetworkActivityIndicatorManagerAllocator<T extends AFNetworkActivityIndicatorManager> extends NSObjectAllocator<T> {}
declare class AFNetworkActivityIndicatorManager extends NSObject {
  alloc<T extends AFNetworkActivityIndicatorManager>(): AFNetworkActivityIndicatorManagerAllocator<T>;
  static sharedManager(): AFNetworkActivityIndicatorManager;
  incrementActivityCount(): void;
  decrementActivityCount(): void;

  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  isNetworkActivityIndicatorVisible(): boolean;
}

class BCAssertionAllocator<T extends BCAssertion> extends NSObjectAllocator<T> {}
declare class BCAssertion extends NSObject {
  alloc<T extends BCAssertion>(): BCAssertionAllocator<T>;
  static assertObject_isOfClass(object: any, c: any): any;
}

declare enum BCAttributeMatchResult {
  BCAttributeMatchResultMixed = -1,
  BCAttributeMatchResultNone = 0,
  BCAttributeMatchResultMatched = 1,
}

class MSRangeAllocator<T extends MSRange> extends NSObjectAllocator<T> {}
declare class MSRange extends NSObject {
  alloc<T extends MSRange>(): MSRangeAllocator<T>;
  static from_to_do(fromIndex: NSUInteger, toIndex: NSUInteger, block: Block): void;
}

class BCCacheAllocator<T extends BCCache> extends NSObjectAllocator<T> {}
declare class BCCache extends NSObject {
  alloc<T extends BCCache>(): BCCacheAllocator<T>;
  cachedObjectForOwner_andKey(owner: any, key: any): any;
  setCachedObject_forOwner_andKey(obj: any, owner: any, key: any): void;
  cachedObjectForOwner_andKey_orCreateWithBlock(owner: any, key: any, block: BCCacheCreateObjectBlock): any;
  removeCachedObjectForOwner_andKey(owner: any, key: any): void;
  removeCachedObjectsForOwner(owner: any): void;
  removeCachedObjectsExceptForOwners(ownersToKeep: NSSet<any>): void;
  removeAllCachedObjects(): void;

  count(): NSUInteger;
  allOwners(): NSSet<any>;
}

declare enum BCConstraint {
  BCConstraintNone = 0,
  BCConstraintMaxXSizeable = 1 << 0,
  BCConstraintWidthSizeable = 1 << 1,
  BCConstraintMinXSizeable = 1 << 2,
  BCConstraintMaxYSizeable = 1 << 3,
  BCConstraintHeightSizeable = 1 << 4,
  BCConstraintMinYSizeable = 1 << 5,
  BCConstraintAllFixed = 1 << 6,
  BCConstraintAllSizeable,
}

declare enum BCCorner {
  BCCornerNone = -1,
  BCCornerTopLeft = 0,
  BCCornerTopRight = 1,
  BCCornerBottomLeft = 2,
  BCCornerBottomRight = 3,
  BCCornerMidTop = 4,
  BCCornerMidLeft = 5,
  BCCornerMidRight = 6,
  BCCornerMidBottom = 7,
  BCCornerMid = 8,
  BCCornerMinimum,
  BCCornerMaximum,
}

class BCDownloadManagerAllocator<T extends BCDownloadManager> {
  initWithSessionConfiguration_delegate_completionHandler(sessionConfiguration: NSURLSessionConfiguration, delegate: any | null, completionHandler: Block | null): T;
}
declare class BCDownloadManager {
  alloc<T extends BCDownloadManager>(): BCDownloadManagerAllocator<T>;
  addDownloadTaskWithDownloadRequestURL(downloadRequestURL: NSURL): NSString;
  addDownloadTaskWithDownloadRequest(downloadRequest: NSURLRequest): NSString;
  addDownloadTaskWithDownloadRequest_completionHandler(request: NSURLRequest, completionHandler: Block): NSString;
  removeDownloadTaskWithIdentifier(identifier: NSString | string): boolean;
  resumeDownloadTaskWithIdentifier(identifier: NSString | string): void;
  suspendDownloadTaskWithIdentifier(identifier: NSString | string): void;
  cancelAllTasksAndInvalidate(): void;
  finishTasksAndInvalidate(): void;
  downloadTaskCurrentStateWithIdentifier(identifier: NSString | string): NSDictionary<any, any>;
  cancelTaskWithIdentifier(identifier: NSString | string): void;

  identifier(): NSString;
  hasBeenInvalidated(): boolean;
  canAcceptNewDownloadTasks(): boolean;
  numberOfUnfinishedDownloadTasks(): NSInteger;
  allTasksIdentifiers(): NSArray<any>;
}

declare interface IBCDownloadManagerDelegate {
  downloadManager_downloadTaskHasUpdatedForIdentifier_downloadedSoFar_withDownloadSize(downloadManager: BCDownloadManager, identifier: NSString | string, downloadedSoFar: NSUInteger, downloadSize: NSUInteger): void;
  downloadManager_downloadTaskFinishedForIdentifier_downloadedURL_httpStatusCode(downloadManager: BCDownloadManager, identifier: NSString | string, downloadedURL: NSURL, statusCode: NSInteger): void;
  downloadManager_downloadTaskWithIdentifier_failedWithError(downloadManager: BCDownloadManager, identifier: NSString | string, error: NSError): void;
  downloadManager_sessionBecameInvalidWithError(downloadManager: BCDownloadManager, error: NSError | null): void;
}

declare type BCFloatRange = {
  location: CGFloat
  length: CGFloat
}

declare type BCEdgePaddings = {
  maxYEdge: CGFloat
  minXEdge: CGFloat
  minYEdge: CGFloat
  maxXEdge: CGFloat
}

declare enum BCAxis {
  BCAxisNone = 0,
  BCAxisX = 1 << 0,
  BCAxisY = 1 << 1,
  BCAxisBoth,
}

declare enum BCEdge {
  BCEdgeLeft = 1<<0,
  BCEdgeRight = 1<<1,
  BCEdgeTop = 1<<2,
  BCEdgeBottom = 1<<3,
  BCEdgeMidX = 1<<4,
  BCEdgeMidY = 1<<5,
  BCEdgeAll,
  BCEdgeVertical,
  BCEdgeHorizontal,
}

declare type BCIntPoint = {
  x: number
  y: number
}

declare type BCIntPointArray = {
  count: number
  points: [BCIntPoint]
}

declare type BCIntRect = {
  x: number
  y: number
  width: number
  height: number
}

declare type BCIntRectArray = {
  count: number
  capacity: number
  rects: BCIntRect
}

class BCJSONEncoderAllocator<T extends BCJSONEncoder> extends NSObjectAllocator<T> {}
declare class BCJSONEncoder extends NSObject {
  alloc<T extends BCJSONEncoder>(): BCJSONEncoderAllocator<T>;
  static encoderForWritingToMutableData(data: NSMutableData): BCJSONEncoder;
  static encodeObjectAsData_error(root: NSObject, error: NSError): NSData;
  static setAliasName_forClass(codedName: NSString | string | null, className: any): void;
  encodeRootObject_error(root: NSObject | null, error: NSError): boolean;
  encodeObject_forKey(object: NSObject | null, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeRect_forKey(rect: CGRect, key: NSString | string): void;
  encodePoint_forKey(point: CGPoint, key: NSString | string): void;
  encodeInteger_forKey(value: NSInteger, key: NSString | string): void;
  encodeSize_forKey(size: CGSize, key: NSString | string): void;
  static encoderForWritingToFile(file: NSFileHandle): BCJSONEncoder;
  static encodeObject_toFile_error(root: NSObject, file: NSFileHandle, error: NSError): boolean;
  static encoderForWritingToURL(url: NSURL): BCJSONEncoder;
  static encodeObject_toURL_error(root: NSObject, url: NSURL, error: NSError): boolean;
  static encodeObjectAsString_error(root: NSObject, error: NSError): NSString;

  userInfo(): any;
  setUserInfo(userInfo: any): void;
  error(): NSError;
  setError(error: NSError): void;
  archiver(): MSJSONArchiver;
  setArchiver(archiver: MSJSONArchiver): void;
}

class BCJSONDecoderAllocator<T extends BCJSONDecoder> extends NSObjectAllocator<T> {}
declare class BCJSONDecoder extends NSObject {
  alloc<T extends BCJSONDecoder>(): BCJSONDecoderAllocator<T>;
  static setClass_forClassName(className: any | null, codedName: NSString | string): void;
  static decodeFileAtURL_error(url: NSURL, error: NSError): any;
  decodeData_error(data: NSData, error: NSError): any;
  decodeDictionary_error(dict: NSDictionary<any, any> | {[key: string]: any}, error: NSError): any;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeDoubleForKey_withDefault(key: NSString | string, defaultValue: number): number;
  decodeBoolForKey_withDefault(key: NSString | string, defaultValue: boolean): boolean;
  decodeRectForKey_withDefault(key: NSString | string, defaultValue: CGRect): CGRect;
  decodePointForKey_withDefault(key: NSString | string, defaultValue: CGPoint): CGPoint;
  decodeIntegerForKey_withDefault(key: NSString | string, defaultValue: NSInteger): NSInteger;
  decodeSizeForKey_withDefault(key: NSString | string, defaultValue: CGSize): CGSize;

  userInfo(): any;
  setUserInfo(userInfo: any): void;
  error(): NSError;
  setError(error: NSError): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  unarchiver(): MSJSONUnarchiver;
  setUnarchiver(unarchiver: MSJSONUnarchiver): void;
}

declare interface IBCJSONDecoderDelegate {
  decoder_shouldInstantiateObjectOfClass(decoder: BCJSONDecoder, aClass: any): boolean;
}

declare interface IBCJSONEncoding {
  encodeAsJSON(coder: BCJSONEncoder): void;
  replacementObjectForJSONEncoder(coder: BCJSONEncoder): NSObject;
}

declare type BCOrthogonalLine = {
  position: CGFloat
  axis: BCAxis
}

class BCNetworkManagerAllocator<T extends BCNetworkManager> extends NSObjectAllocator<T> {}
declare class BCNetworkManager extends NSObject {
  alloc<T extends BCNetworkManager>(): BCNetworkManagerAllocator<T>;
  static sendSynchronousRequest_returningResponse_error(request: NSURLRequest, response: NSURLResponse, error: NSError): NSData;
}

class BCObjectPoolAllocator<T extends BCObjectPool> extends NSObjectAllocator<T> {
  initWithObjectCreatorBlock(block: any): T;
}
declare class BCObjectPool extends NSObject {
  alloc<T extends BCObjectPool>(): BCObjectPoolAllocator<T>;
  vendObject(): any;
  recycleObject(object: any): void;

  maximumPoolCount(): NSUInteger;
  setMaximumPoolCount(maximumPoolCount: NSUInteger): void;
}

class BCObjectSortingAllocator<T extends BCObjectSorting> extends NSObjectAllocator<T> {}
declare class BCObjectSorting extends NSObject {
  alloc<T extends BCObjectSorting>(): BCObjectSortingAllocator<T>;
  static sortObjectsAlphabetically(sortableObjects: NSArray<any> | any[]): NSArray<any>;
  static sortObjectsWithNesting(sortableObjects: NSArray<any> | any[]): NSArray<any>;
  static sortObjectsWithCompressedNesting(sortableObjects: NSArray<any> | any[]): NSArray<any>;
}

declare interface IBCSortable {

  name(): NSString;
}

class BCPerformanceTimerAllocator<T extends BCPerformanceTimer> extends NSObjectAllocator<T> {}
declare class BCPerformanceTimer extends NSObject {
  alloc<T extends BCPerformanceTimer>(): BCPerformanceTimerAllocator<T>;
}

declare type BCTime = number

declare type BCDuration = number

class BCRangeMapAllocator<T extends BCRangeMap> extends NSObjectAllocator<T> {}
declare class BCRangeMap extends NSObject {
  alloc<T extends BCRangeMap>(): BCRangeMapAllocator<T>;
  allRanges(): NSSet<any>;
  allObjects(): NSSet<any>;
  objectForLocation(index: NSUInteger): any;
  rangeForLocation(index: NSUInteger): NSRange;
  setObject_forRange(object: any, range: NSRange): void;
  removeObjectsAtOrBeyondLocation(index: NSUInteger): void;
}

class BCReadWriteLockAllocator<T extends BCReadWriteLock> extends NSObjectAllocator<T> {}
declare class BCReadWriteLock extends NSObject {
  alloc<T extends BCReadWriteLock>(): BCReadWriteLockAllocator<T>;
  protectedRead(block: BCVoidBlock): void;
  protectedWrite(block: BCVoidBlock): void;
}

class BCRectAllocator<T extends BCRect> extends NSObjectAllocator<T> {
  initWithRect(aRect: CGRect): T;
}
declare class BCRect extends NSObject implements INSCopying, IBCRect {
  alloc<T extends BCRect>(): BCRectAllocator<T>;
  static rectWithRect(aRect: CGRect): BCRect;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  rect(): CGRect;
  setRect(rect: CGRect): void;
  size(): CGSize;
  setSize(size: CGSize): void;
  origin(): CGPoint;
  setOrigin(origin: CGPoint): void;
}

declare interface IBCRect {

  rect(): CGRect;
  setRect(rect: CGRect): void;
  origin(): CGPoint;
  setOrigin(origin: CGPoint): void;
  size(): CGSize;
  setSize(size: CGSize): void;
}

declare enum BCRectComparison {
  BCRectComparisonLeftToRightTopToBottom = 0,
  BCRectComparisonRightToLeftTopToBottom,
  BCRectComparisonTopToBottomLeftToRight,
  BCRectComparisonTopToBottomRightToLeft,
  BCRectComparisonLeftToRightBottomToTop,
  BCRectComparisonRightToLeftBottomToTop,
  BCRectComparisonBottomToTopLeftToRight,
  BCRectComparisonBottomToTopRightToLeft,
  BCRectComparisonDefault,
}

class BCSingletonAllocator<T extends BCSingleton> extends NSObjectAllocator<T> {}
declare class BCSingleton extends NSObject {
  alloc<T extends BCSingleton>(): BCSingletonAllocator<T>;
  static sharedInstance(): BCSingleton;
}

class BCToolRunningResultAllocator<T extends BCToolRunningResult> extends NSObjectAllocator<T> {}
declare class BCToolRunningResult extends NSObject {
  alloc<T extends BCToolRunningResult>(): BCToolRunningResultAllocator<T>;

  errorOutput(): NSData;
  exitStatus(): number;
  output(): NSData;
  terminationReason(): NSTaskTerminationReason;
}

class BCToolRunnerAllocator<T extends BCToolRunner> extends NSObjectAllocator<T> {}
declare class BCToolRunner extends NSObject {
  alloc<T extends BCToolRunner>(): BCToolRunnerAllocator<T>;
  runToolAtExecutableURL_workingDirectoryURL_arguments_completionHandler(toolURL: NSURL, workingDirectoryURL: NSURL, arguments: NSArray<any> | any[], completionHandler: MSToolCompletionHandler): void;
}

declare type BCVector = CGVector

class BCFilterInfoAllocator<T extends BCFilterInfo> extends NSObjectAllocator<T> {}
declare class BCFilterInfo extends NSObject {
  alloc<T extends BCFilterInfo>(): BCFilterInfoAllocator<T>;
  filterTypeMatches(filterType: BCOutlineViewFilterTypeMask): boolean;
  shouldIncludeNode(node: any): boolean;

  filterTypeMask(): BCOutlineViewFilterTypeMask;
  setFilterTypeMask(filterTypeMask: BCOutlineViewFilterTypeMask): void;
  filterString(): NSString;
  setFilterString(filterString: NSString | string): void;
  isActive(): boolean;
}

class BCIndifferentButtonCellAllocator<T extends BCIndifferentButtonCell> extends NSButtonCellAllocator<T> {}
declare class BCIndifferentButtonCell extends NSButtonCell {
  alloc<T extends BCIndifferentButtonCell>(): BCIndifferentButtonCellAllocator<T>;
}

class BCLayerListFilterViewControllerAllocator<T extends BCLayerListFilterViewController> extends NSViewControllerAllocator<T> {}
declare class BCLayerListFilterViewController extends NSViewController {
  alloc<T extends BCLayerListFilterViewController>(): BCLayerListFilterViewControllerAllocator<T>;
  applyAppearance(): void;
  showFilterMenu(sender: any): IBAction;
  toggleFilter(sender: any): IBAction;
  findLayer(sender: any): IBAction;

  filter(): BCFilterInfo;
}

class BCLayerListViewControllerAllocator<T extends BCLayerListViewController> extends BCOutlineViewControllerAllocator<T> {}
declare class BCLayerListViewController extends BCOutlineViewController {
  alloc<T extends BCLayerListViewController>(): BCLayerListViewControllerAllocator<T>;
}

class BCOutlineViewAllocator<T extends BCOutlineView> extends NSOutlineViewAllocator<T> {}
declare class BCOutlineView extends NSOutlineView {
  alloc<T extends BCOutlineView>(): BCOutlineViewAllocator<T>;
  deliberateScrollRowToVisible(row: NSInteger): void;
  scrollRowToVisible(row: NSInteger): void;

  useHighlightedBackgroundColor(): boolean;
  setUseHighlightedBackgroundColor(useHighlightedBackgroundColor: boolean): void;
  dataController(): BCOutlineViewDataController;
  setDataController(dataController: BCOutlineViewDataController): void;
  discloserTriangleClickedItem(): any;
}

class BCOutlineViewControllerAllocator<T extends BCOutlineViewController> extends NSViewControllerAllocator<T> {
  initWithDataController(dataController: BCOutlineViewDataController): T;
}
declare class BCOutlineViewController extends NSViewController implements INSOutlineViewDataSource, INSOutlineViewDelegate {
  alloc<T extends BCOutlineViewController>(): BCOutlineViewControllerAllocator<T>;
  refreshWithMask(mask: BCOutlineViewControllerRefreshType): void;
  flagsChangedNotification(): void;
  renameNode(): void;
  executeAfterRefreshCompleted(block: BCOutlineViewControllerPostRefreshBlock): void;
  static itemRowCanFloat(item: any): boolean;
  outlineView_numberOfChildrenOfItem(outlineView: NSOutlineView, item: any | null): NSInteger;
  outlineView_child_ofItem(outlineView: NSOutlineView, index: NSInteger, item: any | null): any;
  outlineView_isItemExpandable(outlineView: NSOutlineView, item: any): boolean;
  outlineView_objectValueForTableColumn_byItem(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any | null): any;
  outlineView_setObjectValue_forTableColumn_byItem(outlineView: NSOutlineView, object: any | null, tableColumn: NSTableColumn | null, item: any | null): void;
  outlineView_itemForPersistentObject(outlineView: NSOutlineView, object: any): any;
  outlineView_persistentObjectForItem(outlineView: NSOutlineView, item: any | null): any;
  outlineView_sortDescriptorsDidChange(outlineView: NSOutlineView, oldDescriptors: NSArray<any> | any[]): void;
  outlineView_pasteboardWriterForItem(outlineView: NSOutlineView, item: any): any;
  outlineView_draggingSession_willBeginAtPoint_forItems(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, draggedItems: NSArray<any> | any[]): void;
  outlineView_draggingSession_endedAtPoint_operation(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  outlineView_writeItems_toPasteboard(outlineView: NSOutlineView, items: NSArray<any> | any[], pasteboard: NSPasteboard): boolean;
  outlineView_updateDraggingItemsForDrag(outlineView: NSOutlineView, draggingInfo: any): void;
  outlineView_validateDrop_proposedItem_proposedChildIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): NSDragOperation;
  outlineView_acceptDrop_item_childIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): boolean;
  outlineView_namesOfPromisedFilesDroppedAtDestination_forDraggedItems(outlineView: NSOutlineView, dropDestination: NSURL, items: NSArray<any> | any[]): NSArray<any>;
  outlineView_viewForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSView;
  outlineView_rowViewForItem(outlineView: NSOutlineView, item: any): NSTableRowView;
  outlineView_didAddRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_didRemoveRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_willDisplayCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_shouldEditTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  selectionShouldChangeInOutlineView(outlineView: NSOutlineView): boolean;
  outlineView_shouldSelectItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_selectionIndexesForProposedSelection(outlineView: NSOutlineView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  outlineView_shouldSelectTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn | null): boolean;
  outlineView_mouseDownInHeaderOfTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didClickTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didDragTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_toolTipForCell_rect_tableColumn_item_mouseLocation(outlineView: NSOutlineView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, item: any, mouseLocation: NSPoint): NSString;
  outlineView_heightOfRowByItem(outlineView: NSOutlineView, item: any): CGFloat;
  outlineView_typeSelectStringForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSString;
  outlineView_nextTypeSelectMatchFromItem_toItem_forString(outlineView: NSOutlineView, startItem: any, endItem: any, searchString: NSString | string): any;
  outlineView_shouldTypeSelectForEvent_withCurrentSearchString(outlineView: NSOutlineView, event: NSEvent, searchString: NSString | string | null): boolean;
  outlineView_shouldShowCellExpansionForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_shouldTrackCell_forTableColumn_item(outlineView: NSOutlineView, cell: NSCell, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_dataCellForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSCell;
  outlineView_isGroupItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldExpandItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldCollapseItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_willDisplayOutlineCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_sizeToFitWidthOfColumn(outlineView: NSOutlineView, column: NSInteger): CGFloat;
  outlineView_shouldReorderColumn_toColumn(outlineView: NSOutlineView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  outlineView_shouldShowOutlineCellForItem(outlineView: NSOutlineView, item: any): boolean;
  outlineViewSelectionDidChange(notification: NSNotification): void;
  outlineViewColumnDidMove(notification: NSNotification): void;
  outlineViewColumnDidResize(notification: NSNotification): void;
  outlineViewSelectionIsChanging(notification: NSNotification): void;
  outlineViewItemWillExpand(notification: NSNotification): void;
  outlineViewItemDidExpand(notification: NSNotification): void;
  outlineViewItemWillCollapse(notification: NSNotification): void;
  outlineViewItemDidCollapse(notification: NSNotification): void;
  outlineView_numberOfChildrenOfItem(outlineView: NSOutlineView, item: any | null): NSInteger;
  outlineView_child_ofItem(outlineView: NSOutlineView, index: NSInteger, item: any | null): any;
  outlineView_isItemExpandable(outlineView: NSOutlineView, item: any): boolean;
  outlineView_objectValueForTableColumn_byItem(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any | null): any;
  outlineView_setObjectValue_forTableColumn_byItem(outlineView: NSOutlineView, object: any | null, tableColumn: NSTableColumn | null, item: any | null): void;
  outlineView_itemForPersistentObject(outlineView: NSOutlineView, object: any): any;
  outlineView_persistentObjectForItem(outlineView: NSOutlineView, item: any | null): any;
  outlineView_sortDescriptorsDidChange(outlineView: NSOutlineView, oldDescriptors: NSArray<any> | any[]): void;
  outlineView_pasteboardWriterForItem(outlineView: NSOutlineView, item: any): any;
  outlineView_draggingSession_willBeginAtPoint_forItems(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, draggedItems: NSArray<any> | any[]): void;
  outlineView_draggingSession_endedAtPoint_operation(outlineView: NSOutlineView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  outlineView_writeItems_toPasteboard(outlineView: NSOutlineView, items: NSArray<any> | any[], pasteboard: NSPasteboard): boolean;
  outlineView_updateDraggingItemsForDrag(outlineView: NSOutlineView, draggingInfo: any): void;
  outlineView_validateDrop_proposedItem_proposedChildIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): NSDragOperation;
  outlineView_acceptDrop_item_childIndex(outlineView: NSOutlineView, info: any, item: any | null, index: NSInteger): boolean;
  outlineView_namesOfPromisedFilesDroppedAtDestination_forDraggedItems(outlineView: NSOutlineView, dropDestination: NSURL, items: NSArray<any> | any[]): NSArray<any>;
  outlineView_viewForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSView;
  outlineView_rowViewForItem(outlineView: NSOutlineView, item: any): NSTableRowView;
  outlineView_didAddRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_didRemoveRowView_forRow(outlineView: NSOutlineView, rowView: NSTableRowView, row: NSInteger): void;
  outlineView_willDisplayCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_shouldEditTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  selectionShouldChangeInOutlineView(outlineView: NSOutlineView): boolean;
  outlineView_shouldSelectItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_selectionIndexesForProposedSelection(outlineView: NSOutlineView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  outlineView_shouldSelectTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn | null): boolean;
  outlineView_mouseDownInHeaderOfTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didClickTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_didDragTableColumn(outlineView: NSOutlineView, tableColumn: NSTableColumn): void;
  outlineView_toolTipForCell_rect_tableColumn_item_mouseLocation(outlineView: NSOutlineView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, item: any, mouseLocation: NSPoint): NSString;
  outlineView_heightOfRowByItem(outlineView: NSOutlineView, item: any): CGFloat;
  outlineView_typeSelectStringForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSString;
  outlineView_nextTypeSelectMatchFromItem_toItem_forString(outlineView: NSOutlineView, startItem: any, endItem: any, searchString: NSString | string): any;
  outlineView_shouldTypeSelectForEvent_withCurrentSearchString(outlineView: NSOutlineView, event: NSEvent, searchString: NSString | string | null): boolean;
  outlineView_shouldShowCellExpansionForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_shouldTrackCell_forTableColumn_item(outlineView: NSOutlineView, cell: NSCell, tableColumn: NSTableColumn | null, item: any): boolean;
  outlineView_dataCellForTableColumn_item(outlineView: NSOutlineView, tableColumn: NSTableColumn | null, item: any): NSCell;
  outlineView_isGroupItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldExpandItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_shouldCollapseItem(outlineView: NSOutlineView, item: any): boolean;
  outlineView_willDisplayOutlineCell_forTableColumn_item(outlineView: NSOutlineView, cell: any, tableColumn: NSTableColumn | null, item: any): void;
  outlineView_sizeToFitWidthOfColumn(outlineView: NSOutlineView, column: NSInteger): CGFloat;
  outlineView_shouldReorderColumn_toColumn(outlineView: NSOutlineView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  outlineView_shouldShowOutlineCellForItem(outlineView: NSOutlineView, item: any): boolean;
  outlineViewSelectionDidChange(notification: NSNotification): void;
  outlineViewColumnDidMove(notification: NSNotification): void;
  outlineViewColumnDidResize(notification: NSNotification): void;
  outlineViewSelectionIsChanging(notification: NSNotification): void;
  outlineViewItemWillExpand(notification: NSNotification): void;
  outlineViewItemDidExpand(notification: NSNotification): void;
  outlineViewItemWillCollapse(notification: NSNotification): void;
  outlineViewItemDidCollapse(notification: NSNotification): void;

  outlineView(): BCOutlineView;
  setOutlineView(outlineView: BCOutlineView): void;
  preferredHeight(): CGFloat;
  filter(): BCFilterInfo;
  setFilter(filter: BCFilterInfo): void;
}

declare enum BCOutlineViewControllerRefreshType {
  BCOutlineViewControllerRefreshTypeSelection = 0x01,
  BCOutlineViewControllerRefreshTypeExpansion = 0x02,
  BCOutlineViewControllerRefreshTypeLayout = 0x04,
  BCOutlineViewControllerRefreshTypePreviewImages = 0x08,
  BCOutlineViewControllerRefreshTypeAll = 0x0F,
}

class BCOutlineViewDataControllerAllocator<T extends BCOutlineViewDataController> extends NSObjectAllocator<T> {
  initWithDataSource_delegate(dataSource: NSObject, delegate: NSObject): T;
}
declare class BCOutlineViewDataController extends NSObject {
  alloc<T extends BCOutlineViewDataController>(): BCOutlineViewDataControllerAllocator<T>;
  childrenOfNode(node: any): NSArray<any>;
  numberOfChildrenOfNode(node: any): NSUInteger;
  childOfNode_atIndex(node: any, index: NSInteger): any;
  shouldExpandNode(node: any): boolean;
  writeNodes_toPasteboard(nodes: NSArray<any> | any[], pasteboard: NSPasteboard): boolean;
  handleDragWithPasteboard_forProposedItem_proposedChildIndex_copying_validationOnly(pasteboard: NSPasteboard, item: any, index: NSInteger, copying: boolean, validating: boolean): boolean;
  changeSelectionTo(selection: NSArray<any> | any[]): void;
  isNodeSelected(node: any): boolean;
  multipleNodesSelected(): boolean;
  isNodeExpanded(node: any): boolean;
  isNodeExpandable(node: any): boolean;
  updateNode_expandedState(node: any, expanded: BCOutlineViewNodeExpansionState): void;
  menuItemsForSelectedObjects(selection: NSArray<any> | any[]): NSArray<any>;
  hoverNodeDidChangeTo(node: any): void;
  isNodeHighlighted(node: any): boolean;
  handleBadgePressedOnNode_withAltState(node: any, alt: boolean): void;
  refreshPreviewsOnNodes(nodes: NSArray<any> | any[]): void;
  namesOfPromisedFilesDroppedAtDestination_forDraggedItems(dropDestination: NSURL, items: NSArray<any> | any[]): NSArray<any>;

  filter(): BCFilterInfo;
  setFilter(filter: BCFilterInfo): void;
  rootObject(): any;
  dragTypes(): NSArray<any>;
  canProvideContextMenuItems(): boolean;
}

declare interface IBCOutlineViewDataSource {
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
}

declare interface IBCOutlineViewDelegate {
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
}

declare enum BCOutlineViewNodeExpansionState {
  BCOutlineViewNodeExpansionStateModelExpanded,
  BCOutlineViewNodeExpansionStateUserExpanded,
  BCOutlineViewNodeExpansionStateDragAutoExpanded,
  BCOutlineViewNodeExpansionStateModelCollapsed,
  BCOutlineViewNodeExpansionStateUserCollapsed,
  BCOutlineViewNodeExpansionStateDragAutoCollapsed,
}

declare interface IBCOutlineViewNode {
  badgeMap(): NSDictionary<any, any>;
  previewImages(): NSDictionary<any, any>;
  badgeMenu(): NSMenu;

  displayType(): BCOutlineViewDisplayType;
  filterTypeMask(): BCOutlineViewFilterTypeMask;
  nodeName(): NSString;
  setNodeName(nodeName: NSString | string): void;
  isActive(): boolean;
  isEditableInLayerList(): boolean;
  hasBadgedIcon(): boolean;
  selectedBadgeMenuItemIndex(): NSUInteger;
  isExpanded(): boolean;
}

declare enum BCOutlineViewDisplayType {
  BCOutlineViewDisplayTypeStandard,
  BCOutlineViewDisplayTypeArtboard,
  BCOutlineViewDisplayTypePage,
  BCOutlineViewDisplayTypeOverride,
}

declare enum BCOutlineViewFilterTypeMask {
  BCOutlineViewFilterTypeMaskShape = 1 << 0,
  BCOutlineViewFilterTypeMaskText = 1 << 1,
  BCOutlineViewFilterTypeMaskImage = 1 << 2,
  BCOutlineViewFilterTypeMaskGroup = 1 << 3,
  BCOutlineViewFilterTypeMaskExportable = 1 << 4,
  BCOutlineViewFilterTypeMaskPrototypingFlow = 1 << 5,
  BCOutlineViewFilterTypeMaskSymbol = 1 << 6,
}

class BCPageListViewControllerAllocator<T extends BCPageListViewController> extends BCOutlineViewControllerAllocator<T> {}
declare class BCPageListViewController extends BCOutlineViewController {
  alloc<T extends BCPageListViewController>(): BCPageListViewControllerAllocator<T>;
}

class BCSideBarViewControllerAllocator<T extends BCSideBarViewController> extends NSViewControllerAllocator<T> {
  initWithPageListDataSource_delegate_layerListDataSource_delegate(pageListDataSource: NSObject, pageListDelegate: NSObject, layerListDataSource: NSObject, layerListDelegate: NSObject): T;
}
declare class BCSideBarViewController extends NSViewController {
  alloc<T extends BCSideBarViewController>(): BCSideBarViewControllerAllocator<T>;
  refreshWithMask(mask: BCSideBarRefreshType): void;
  refreshAfterAppearanceChange(): void;
  renamePage(): IBAction;
  renameLayer(): IBAction;
  renameLayerAfterNextLayerListRefresh(): IBAction;
  flagsChangedNotification(): void;
  showPageView(): void;

  delegate(): NSObject;
  setDelegate(delegate: NSObject): void;
  filterViewController(): BCLayerListFilterViewController;
  setFilterViewController(filterViewController: BCLayerListFilterViewController): void;
}

declare interface IBCSideBarViewControllerDelegate {

  pageListHeight(): CGFloat;
  setPageListHeight(pageListHeight: CGFloat): void;
}

declare enum BCSideBarRefreshType {
  BCSideBarRefreshTypeSelection,
  BCSideBarRefreshTypeLayout,
  BCSideBarRefreshTypePreviewImages,
  BCSideBarRefreshTypeAll,
  BCSideBarRefreshTypeLayerList = 0x10,
  BCSideBarRefreshTypePageList = 0x20,
}

class BCSidebarPreviewImageViewAllocator<T extends BCSidebarPreviewImageView> extends NSViewAllocator<T> {}
declare class BCSidebarPreviewImageView extends NSView {
  alloc<T extends BCSidebarPreviewImageView>(): BCSidebarPreviewImageViewAllocator<T>;

  image(): NSImage;
  setImage(image: NSImage): void;
}

class BCSplitViewAllocator<T extends BCSplitView> extends NSSplitViewAllocator<T> {}
declare class BCSplitView extends NSSplitView {
  alloc<T extends BCSplitView>(): BCSplitViewAllocator<T>;
}

class BCStringWithoutNewlineTransformerAllocator<T extends BCStringWithoutNewlineTransformer> extends NSValueTransformerAllocator<T> {}
declare class BCStringWithoutNewlineTransformer extends NSValueTransformer {
  alloc<T extends BCStringWithoutNewlineTransformer>(): BCStringWithoutNewlineTransformerAllocator<T>;
}

class BCTableCellTitleTextFieldAllocator<T extends BCTableCellTitleTextField> extends NSTextFieldAllocator<T> {}
declare class BCTableCellTitleTextField extends NSTextField {
  alloc<T extends BCTableCellTitleTextField>(): BCTableCellTitleTextFieldAllocator<T>;
}

class BCTableCellViewAllocator<T extends BCTableCellView> extends NSTableCellViewAllocator<T> {}
declare class BCTableCellView extends NSTableCellView implements INSMenuDelegate {
  alloc<T extends BCTableCellView>(): BCTableCellViewAllocator<T>;
  renameNode(): void;
  updateBadge(): void;
  drawDragImageInRect(dragRect: NSRect): void;
  refreshPreviewImagesAlwaysDropPrimary(force: boolean): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;

  delegate(): any;
  setDelegate(delegate: any): void;
  displayState(): BCTableCellViewDisplayState;
  setDisplayState(displayState: BCTableCellViewDisplayState): void;
  widthForDragImage(): CGFloat;
}

declare interface IBCTableCellViewDelegate {
  isTableCellViewNodeSelected(tableCellView: BCTableCellView): boolean;
  tableCellViewHandleBadgePressed(tableCellView: BCTableCellView): void;
  tableCellViewMouseEntered(tableCellView: BCTableCellView): void;
  tableCellViewMouseExited(tableCellView: BCTableCellView): void;
  tableCellViewDidBeginEditing(tableCellView: BCTableCellView): void;
  tableCellViewDestinationWindow(view: BCTableCellView): NSWindow;
}

declare enum BCTableCellViewDisplayState {
  BCTableCellViewDisplayStateNormal,
  BCTableCellViewDisplayStateHovered,
  BCTableCellViewDisplayStateAlternate,
}

class BCTableRowViewAllocator<T extends BCTableRowView> extends NSTableRowViewAllocator<T> {}
declare class BCTableRowView extends NSTableRowView {
  alloc<T extends BCTableRowView>(): BCTableRowViewAllocator<T>;

  node(): NSObject;
  setNode(node: NSObject): void;
  delegate(): NSObject;
  setDelegate(delegate: NSObject): void;
  displayType(): BCOutlineViewDisplayType;
  expansionState(): BCOutlineViewNodeExpansionState;
  setExpansionState(expansionState: BCOutlineViewNodeExpansionState): void;
  outlineView(): BCOutlineView;
  drawsTopBorder(): boolean;
  drawsBottomBorder(): boolean;
  hasBottomPaddingApplied(): boolean;
  hasTopPaddingApplied(): boolean;
}

declare interface IBCTableRowViewDelegate {
  isNodeSelectedInTableRowView(view: BCTableRowView): boolean;
  isNodeSelectedOnRow(row: NSInteger): boolean;
  multipleNodesSelected(): boolean;
  isNodeExpandedInTableRowView(view: BCTableRowView): boolean;
  indexOfTableRowView(view: BCTableRowView): NSInteger;
  tableRowView_displayTypeOfRowAtIndex(view: BCTableRowView, index: NSInteger): BCOutlineViewDisplayType;
}

declare enum MSLayerPreviewBadgeType {
  MSLayerPreviewBadgeTypeNone,
  MSLayerPreviewBadgeTypeSlice,
  MSLayerPreviewBadgeTypeFlow,
}

class LLTestBaseControllerAllocator<T extends LLTestBaseController> extends NSObjectAllocator<T> {}
declare class LLTestBaseController extends NSObject implements IBCOutlineViewDataSource, IBCOutlineViewDelegate {
  alloc<T extends LLTestBaseController>(): LLTestBaseControllerAllocator<T>;
  dataController_removeNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;

  root(): any;
  setRoot(root: any): void;
}

class LLTestLayerListControllerAllocator<T extends LLTestLayerListController> extends LLTestBaseControllerAllocator<T> {}
declare class LLTestLayerListController extends LLTestBaseController {
  alloc<T extends LLTestLayerListController>(): LLTestLayerListControllerAllocator<T>;
}

class LLTestPageListControllerAllocator<T extends LLTestPageListController> extends LLTestBaseControllerAllocator<T> {}
declare class LLTestPageListController extends LLTestBaseController {
  alloc<T extends LLTestPageListController>(): LLTestPageListControllerAllocator<T>;
  addPage(): void;
}

class BCAppDelegateAllocator<T extends BCAppDelegate> extends NSObjectAllocator<T> {}
declare class BCAppDelegate extends NSObject implements INSApplicationDelegate, IBCPopoverDelegate, INSApplicationDelegate {
  alloc<T extends BCAppDelegate>(): BCAppDelegateAllocator<T>;
  attach(sender: any): IBAction;
  resize(sender: any): IBAction;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;

  window(): NSWindow;
  setWindow(window: NSWindow): void;
  button(): NSButton;
  setButton(button: NSButton): void;
}

class BCDummyViewControllerAllocator<T extends BCDummyViewController> extends NSViewControllerAllocator<T> {}
declare class BCDummyViewController extends NSViewController {
  alloc<T extends BCDummyViewController>(): BCDummyViewControllerAllocator<T>;
}

class BCRedLinedViewAllocator<T extends BCRedLinedView> extends NSViewAllocator<T> {}
declare class BCRedLinedView extends NSView {
  alloc<T extends BCRedLinedView>(): BCRedLinedViewAllocator<T>;
}

class BCColorButtonCellAllocator<T extends BCColorButtonCell> extends NSButtonCellAllocator<T> {}
declare class BCColorButtonCell extends NSButtonCell {
  alloc<T extends BCColorButtonCell>(): BCColorButtonCellAllocator<T>;

  backgroundColorStringRepresentation(): NSString;
  setBackgroundColorStringRepresentation(backgroundColorStringRepresentation: NSString | string): void;
  backgroundHighlightedColor(): NSString;
  setBackgroundHighlightedColor(backgroundHighlightedColor: NSString | string): void;
  textColor(): NSString;
  setTextColor(textColor: NSString | string): void;
  backgroundSelectedColor(): NSString;
  setBackgroundSelectedColor(backgroundSelectedColor: NSString | string): void;
  backgroundSelectedHighlightedColor(): NSString;
  setBackgroundSelectedHighlightedColor(backgroundSelectedHighlightedColor: NSString | string): void;
  textSelectedColor(): NSString;
  setTextSelectedColor(textSelectedColor: NSString | string): void;
}

class BCDebugMenuControllerAllocator<T extends BCDebugMenuController> extends BCSingletonAllocator<T> {}
declare class BCDebugMenuController extends BCSingleton {
  alloc<T extends BCDebugMenuController>(): BCDebugMenuControllerAllocator<T>;
  addDebugMenu(): void;
}

class BCHighlightColorButtonCellAllocator<T extends BCHighlightColorButtonCell> extends NSButtonCellAllocator<T> {}
declare class BCHighlightColorButtonCell extends NSButtonCell {
  alloc<T extends BCHighlightColorButtonCell>(): BCHighlightColorButtonCellAllocator<T>;
}

class BCHighlightColorTextFieldCellAllocator<T extends BCHighlightColorTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class BCHighlightColorTextFieldCell extends NSTextFieldCell {
  alloc<T extends BCHighlightColorTextFieldCell>(): BCHighlightColorTextFieldCellAllocator<T>;

  highlightColor(): NSColor;
  setHighlightColor(highlightColor: NSColor): void;
}

class BCHighlightImageCellAllocator<T extends BCHighlightImageCell> extends NSImageCellAllocator<T> {}
declare class BCHighlightImageCell extends NSImageCell {
  alloc<T extends BCHighlightImageCell>(): BCHighlightImageCellAllocator<T>;
}

class BCIOSStyleSwitchButtonAllocator<T extends BCIOSStyleSwitchButton> extends NSButtonAllocator<T> {}
declare class BCIOSStyleSwitchButton extends NSButton {
  alloc<T extends BCIOSStyleSwitchButton>(): BCIOSStyleSwitchButtonAllocator<T>;
}

class BCJSONZippedDecoderAllocator<T extends BCJSONZippedDecoder> extends BCJSONDecoderAllocator<T> {
  initWithURL(url: NSURL): T;
}
declare class BCJSONZippedDecoder extends BCJSONDecoder {
  alloc<T extends BCJSONZippedDecoder>(): BCJSONZippedDecoderAllocator<T>;
  rawDataAtSubpath_error(path: NSString | string, error: NSError): NSData;
  decodeFileAtSubpath_error(path: NSString | string, error: NSError): any;
  containsFileAtSubpath(path: NSString | string): boolean;
}

class BCJSONZippedEncoderAllocator<T extends BCJSONZippedEncoder> extends BCJSONEncoderAllocator<T> {}
declare class BCJSONZippedEncoder extends BCJSONEncoder {
  alloc<T extends BCJSONZippedEncoder>(): BCJSONZippedEncoderAllocator<T>;
  static zipEncoderForWritingAtURL(url: NSURL): BCJSONZippedEncoder;
  encodeObject_toSubpath_error(root: NSObject, path: NSString | string, error: NSError): boolean;
  encodeRawData_toSubpath_error(data: NSData, path: NSString | string, error: NSError): boolean;
  finishEncodingError(error: NSError): boolean;
}

class BCJSONZippedUnarchiverAllocator<T extends BCJSONZippedUnarchiver> extends BCJSONUnarchiverAllocator<T> {
  initWithURL(url: NSURL): T;
}
declare class BCJSONZippedUnarchiver extends BCJSONUnarchiver {
  alloc<T extends BCJSONZippedUnarchiver>(): BCJSONZippedUnarchiverAllocator<T>;
  unarchiveObjectAtSubpath_error(path: NSString | string, error: NSError): any;
}

class BCKeyEventActionTableViewAllocator<T extends BCKeyEventActionTableView> extends NSTableViewAllocator<T> {}
declare class BCKeyEventActionTableView extends NSTableView {
  alloc<T extends BCKeyEventActionTableView>(): BCKeyEventActionTableViewAllocator<T>;
  setTarget_action_forKeyDownEventWithCharacters(target: any, action: string, characters: NSString | string): void;
}

class BCPasteboardMockAllocator<T extends BCPasteboardMock> extends NSObjectAllocator<T> {}
declare class BCPasteboardMock extends NSObject {
  alloc<T extends BCPasteboardMock>(): BCPasteboardMockAllocator<T>;
  static generalPasteboard(): NSPasteboard;
  static pasteboardWithName(name: NSString | string): NSPasteboard;
  declareTypes_owner(types: NSArray<any> | any[], owner: any): void;
  addTypes_owner(types: NSArray<any> | any[], owner: any): void;
  setData_forType(data: NSData, dataType: NSString | string): void;
  dataForType(type: NSString | string): NSData;
  setString_forType(string: NSString | string, dataType: NSString | string): boolean;
  stringForType(dataType: NSString | string): NSString;
  setPropertyList_forType(plist: any, dataType: NSString | string): boolean;
  propertyListForType(dataType: NSString | string): any;
  availableTypeFromArray(types: NSArray<any> | any[]): NSString;
  types(): NSArray<any>;
  writeObjects(objects: NSArray<any> | any[]): boolean;
  clearContents(): void;

  name(): NSString;
  changeCount(): NSInteger;
}

class BCPopoverAllocator<T extends BCPopover> extends NSObjectAllocator<T> {}
declare class BCPopover extends NSObject implements INSWindowDelegate, INSViewControllerPresentationAnimator {
  alloc<T extends BCPopover>(): BCPopoverAllocator<T>;
  showRelativeToView_preferredEdge(view: NSView, edge: NSRectEdge): void;
  close(): void;
  move(): void;
  popoverWindowFrame(): NSRect;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  animatePresentationOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
  animateDismissalOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  animatePresentationOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;
  animateDismissalOfViewController_fromViewController(viewController: NSViewController, fromViewController: NSViewController): void;

  contentViewController(): NSViewController;
  setContentViewController(contentViewController: NSViewController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  minimumHeight(): CGFloat;
  window(): BCPopoverWindow;
  setWindow(window: BCPopoverWindow): void;
  screenEdgeBehaviour(): BCPopoverScreenEdgeBehaviour;
  setScreenEdgeBehaviour(screenEdgeBehaviour: BCPopoverScreenEdgeBehaviour): void;
  layerDependency(): BCPopupLayerDependency;
  setLayerDependency(layerDependency: BCPopupLayerDependency): void;
  closesOnWindowDidResignKey(): boolean;
  setClosesOnWindowDidResignKey(closesOnWindowDidResignKey: boolean): void;
  attachedToView(): NSView;
  setAttachedToView(attachedToView: NSView): void;
  attachedToViewMargin(): CGFloat;
  setAttachedToViewMargin(attachedToViewMargin: CGFloat): void;
  preferredEdge(): NSRectEdge;
  setPreferredEdge(preferredEdge: NSRectEdge): void;
}

declare enum BCPopupLayerDependency {
  BCPopoverLayerDependant,
  BCPopoverLayerIndependent,
}

declare enum BCPopoverScreenEdgeBehaviour {
  BCPopoverScreenEdgeBehaviourNone,
  BCPopoverScreenEdgeBehaviourResize,
  BCPopoverScreenEdgeBehaviourMove,
}

class BCPopoverContentViewAllocator<T extends BCPopoverContentView> extends NSViewAllocator<T> {}
declare class BCPopoverContentView extends NSView {
  alloc<T extends BCPopoverContentView>(): BCPopoverContentViewAllocator<T>;
  availableContentRect(): NSRect;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  arrowEdge(): NSRectEdge;
  setArrowEdge(arrowEdge: NSRectEdge): void;
  arrowPosition(): CGFloat;
  setArrowPosition(arrowPosition: CGFloat): void;
}

declare interface IBCPopoverDelegate {
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
}

class BCPopoverWindowAllocator<T extends BCPopoverWindow> extends NSWindowAllocator<T> {}
declare class BCPopoverWindow extends NSWindow {
  alloc<T extends BCPopoverWindow>(): BCPopoverWindowAllocator<T>;
  static attachedWindowWithView(aView: NSView): any;

  arrowEdge(): NSRectEdge;
  setArrowEdge(arrowEdge: NSRectEdge): void;
  arrowPosition(): CGFloat;
  setArrowPosition(arrowPosition: CGFloat): void;
}

class BCWindowBadgeAllocator<T extends BCWindowBadge> extends MSHoverButtonAllocator<T> {}
declare class BCWindowBadge extends MSHoverButton {
  alloc<T extends BCWindowBadge>(): BCWindowBadgeAllocator<T>;

  tintColor(): NSColor;
  setTintColor(tintColor: NSColor): void;
}

class BCZeroHeightWhenEmptyTextFieldAllocator<T extends BCZeroHeightWhenEmptyTextField> extends NSTextFieldAllocator<T> {}
declare class BCZeroHeightWhenEmptyTextField extends NSTextField {
  alloc<T extends BCZeroHeightWhenEmptyTextField>(): BCZeroHeightWhenEmptyTextFieldAllocator<T>;

  paddingIfNotEmpty(): CGFloat;
  setPaddingIfNotEmpty(paddingIfNotEmpty: CGFloat): void;
}

class CHFlippedViewAllocator<T extends CHFlippedView> extends NSViewAllocator<T> {}
declare class CHFlippedView extends NSView {
  alloc<T extends CHFlippedView>(): CHFlippedViewAllocator<T>;
}

class CHImagelessPopupButtonCellAllocator<T extends CHImagelessPopupButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class CHImagelessPopupButtonCell extends NSPopUpButtonCell {
  alloc<T extends CHImagelessPopupButtonCell>(): CHImagelessPopupButtonCellAllocator<T>;
}

class CHOutlineViewAllocator<T extends CHOutlineView> extends NSOutlineViewAllocator<T> {}
declare class CHOutlineView extends NSOutlineView {
  alloc<T extends CHOutlineView>(): CHOutlineViewAllocator<T>;
}

class CHTableViewAllocator<T extends CHTableView> extends NSTableViewAllocator<T> {}
declare class CHTableView extends NSTableView {
  alloc<T extends CHTableView>(): CHTableViewAllocator<T>;
}

class CHProgressSheetAllocator<T extends CHProgressSheet> extends CHSheetControllerAllocator<T> {}
declare class CHProgressSheet extends CHSheetController {
  alloc<T extends CHProgressSheet>(): CHProgressSheetAllocator<T>;
  setProgressMaximum(max: NSInteger): void;
  incrementProgress(): void;
  incrementProgressBy(amount: NSInteger): void;
  isMaximum(): boolean;
  setMessage(message: NSString | string): void;
  setTitle(aTitle: NSString | string): void;
  setSubtitle(subtitle: NSString | string): void;
  setShowsCancelButton(flag: boolean): void;
  setIndeterminate(flag: boolean): void;
}

class CHSheetControllerAllocator<T extends CHSheetController> extends CHWindowControllerAllocator<T> {}
declare class CHSheetController extends CHWindowController implements INSTouchBarDelegate {
  alloc<T extends CHSheetController>(): CHSheetControllerAllocator<T>;
  static runForWindow(window: NSWindow): any;
  static runForWindow_withObject(window: NSWindow, obj: any): any;
  run(): any;
  confirm(sender: any): IBAction;
  cancel(sender: any): IBAction;
  _init(): any;
  touchBarItemIdentifiers(): NSArray<any>;
  selectorForTouchbarItemIdentifier(itemIdentifier: NSTouchBarItemIdentifier): string;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  object(): any;
  setObject(object: any): void;
}

class CHStringAttributesAllocator<T extends CHStringAttributes> extends NSDictionaryAllocator<any, any, T> {}
declare class CHStringAttributes extends NSDictionary<any, any> implements INSCopying {
  alloc<T extends CHStringAttributes>(): CHStringAttributesAllocator<T>;
  static stringAttributesWithFont(aFont: NSFont): any;
  static stringAttributesWithFont_color(aFont: NSFont, aColor: NSColor): any;
  static stringAttributesWithFont_color_alignment(aFont: NSFont, aColor: NSColor, align: NSTextAlignment): any;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  font(): NSFont;
  setFont(font: NSFont): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  shadow(): NSShadow;
  setShadow(shadow: NSShadow): void;
  alignment(): NSTextAlignment;
  setAlignment(alignment: NSTextAlignment): void;
  fontSize(): CGFloat;
  setFontSize(fontSize: CGFloat): void;
}

class CHTransparentViewAllocator<T extends CHTransparentView> extends NSViewAllocator<T> {}
declare class CHTransparentView extends NSView {
  alloc<T extends CHTransparentView>(): CHTransparentViewAllocator<T>;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}

class CHTransparentWindowAllocator<T extends CHTransparentWindow> extends NSWindowAllocator<T> {
  initWithContentRect(contentRect: NSRect): T;
}
declare class CHTransparentWindow extends NSWindow {
  alloc<T extends CHTransparentWindow>(): CHTransparentWindowAllocator<T>;
}

class CHVerticallyCentredPopupButtonCellAllocator<T extends CHVerticallyCentredPopupButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class CHVerticallyCentredPopupButtonCell extends NSPopUpButtonCell {
  alloc<T extends CHVerticallyCentredPopupButtonCell>(): CHVerticallyCentredPopupButtonCellAllocator<T>;
}

class CHWindowControllerAllocator<T extends CHWindowController> extends NSWindowControllerAllocator<T> {}
declare class CHWindowController extends NSWindowController {
  alloc<T extends CHWindowController>(): CHWindowControllerAllocator<T>;
}

class MSAltButtonAllocator<T extends MSAltButton> extends MSHoverButtonAllocator<T> {}
declare class MSAltButton extends MSHoverButton {
  alloc<T extends MSAltButton>(): MSAltButtonAllocator<T>;

  bc_weakTarget(): any;
  setBc_weakTarget(bc_weakTarget: any): void;
}

class MSAltButtonCellAllocator<T extends MSAltButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSAltButtonCell extends MSHoverButtonCell {
  alloc<T extends MSAltButtonCell>(): MSAltButtonCellAllocator<T>;
}

declare interface IMSAltButtonTarget {
  altButtonCanShowAltImage(altButton: MSAltButton): boolean;
}

declare interface IMSDropableViewDelegate {
  draggedTypesForView(view: NSView): NSArray<any>;
  view_performDragOperation(view: NSView, sender: any): boolean;
  view_draggingEntered(view: NSView, sender: any): NSDragOperation;
  view_draggingUpdated(view: NSView, sender: any): NSDragOperation;
  view_draggingExited(view: NSView, sender: any): void;
  view_draggingEnded(view: NSView, sender: any): void;
  view_prepareForDragOperation(view: NSView, sender: any): boolean;
  view_concludeDragOperation(view: NSView, sender: any): void;
  viewWantsPeriodicDraggingUpdates(view: NSView): boolean;
  view_updateDraggingItemsForDrag(view: NSView, sender: any): void;
}

class MSFileMonitorAllocator<T extends MSFileMonitor> extends MSFolderMonitorAllocator<T> {}
declare class MSFileMonitor extends MSFolderMonitor {
  alloc<T extends MSFileMonitor>(): MSFileMonitorAllocator<T>;
}

class MSFolderMonitorAllocator<T extends MSFolderMonitor> extends NSObjectAllocator<T> {
  initWithURL_contentsChangedBlock(folderURL: NSURL, block: Block): T;
  initWithURL_latency_contentsChangedBlock(folderURL: NSURL, latency: NSTimeInterval, block: Block): T;
}
declare class MSFolderMonitor extends NSObject {
  alloc<T extends MSFolderMonitor>(): MSFolderMonitorAllocator<T>;
  flush(): void;

  folderURL(): NSURL;
}

class MSHoverButtonAllocator<T extends MSHoverButton> extends NSButtonAllocator<T> {}
declare class MSHoverButton extends NSButton {
  alloc<T extends MSHoverButton>(): MSHoverButtonAllocator<T>;

  mouseIsHovering(): boolean;
  setMouseIsHovering(mouseIsHovering: boolean): void;
}

class MSHoverButtonCellAllocator<T extends MSHoverButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSHoverButtonCell extends NSButtonCell {
  alloc<T extends MSHoverButtonCell>(): MSHoverButtonCellAllocator<T>;
}

class MSTintedHoverButtonCellAllocator<T extends MSTintedHoverButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSTintedHoverButtonCell extends MSHoverButtonCell {
  alloc<T extends MSTintedHoverButtonCell>(): MSTintedHoverButtonCellAllocator<T>;

  normalTint(): NSColor;
  hoverTint(): NSColor;
}

class MSNamedInterfaceImageOwnerAllocator<T extends MSNamedInterfaceImageOwner> extends NSObjectAllocator<T> {
  initWithImage_cacheOwner(image: NSImage, cacheOwner: any): T;
}
declare class MSNamedInterfaceImageOwner extends NSObject implements IMSInterfaceImageOwner {
  alloc<T extends MSNamedInterfaceImageOwner>(): MSNamedInterfaceImageOwnerAllocator<T>;

  interfaceImageIdentifier(): NSString;
  cacheOwner(): any;
}

declare interface IMSInterfaceImageOwner {

  interfaceImageIdentifier(): NSString;
  cacheOwner(): any;
}

class MSPlainButtonAllocator<T extends MSPlainButton> extends MSHoverButtonAllocator<T> {}
declare class MSPlainButton extends MSHoverButton {
  alloc<T extends MSPlainButton>(): MSPlainButtonAllocator<T>;
}

class MSPlainButtonCellAllocator<T extends MSPlainButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSPlainButtonCell extends MSHoverButtonCell {
  alloc<T extends MSPlainButtonCell>(): MSPlainButtonCellAllocator<T>;
}

class MSPreviewPopupButtonCellAllocator<T extends MSPreviewPopupButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSPreviewPopupButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSPreviewPopupButtonCell>(): MSPreviewPopupButtonCellAllocator<T>;

  previewImage(): NSImage;
  setPreviewImage(previewImage: NSImage): void;
  previewImageFrame(): CGRect;
  setPreviewImageFrame(previewImageFrame: CGRect): void;
  titleOffset(): CGFloat;
  setTitleOffset(titleOffset: CGFloat): void;
}

class MSThemeAllocator<T extends MSTheme> extends NSObjectAllocator<T> {}
declare class MSTheme extends NSObject {
  alloc<T extends MSTheme>(): MSThemeAllocator<T>;
  layerListSelectionColorForWindow(window: NSWindow): NSColor;
  layerListSymbolOverrideSelectionColorForWindow(window: NSWindow): NSColor;
  layerListTextColorForBackgroundStyle(style: NSBackgroundStyle): NSColor;
  layerListTextEditingBackgroundColorForBackgroundStyle(style: NSBackgroundStyle): NSColor;
  colorNamed(colorName: NSColorName): NSColor;
  colorNamed_options(colorName: NSColorName, options: MSThemeResolvingOptions): NSColor;
  imageNamed(imageName: NSString | string): NSImage;
  imageNamed_options(imageName: NSString | string, options: MSThemeResolvingOptions): NSImage;
  cacheImage_forKey_owner(image: NSImage, key: NSString | string, owner: any): void;
  cachedImageForKey_owner(key: NSString | string, owner: any): NSImage;
  cachedImageForKey_owner_createBlock(key: NSString | string, owner: any, block: BCCacheCreateObjectBlock): NSImage;
  invalidateCachedResources(): void;
  attributedStringWithString_color_controlSize(string: NSString | string, color: NSColor, controlSize: NSControlSize): NSAttributedString;

  canvasArtboardTitleColor(): NSColor;
  canvasBackgroundColor(): NSColor;
  canvasFlowArrowColor(): NSColor;
  canvasLayerHighlightColor(): NSColor;
  canvasLayerSelectionColor(): NSColor;
  canvasMeasurementLabelBackgroundColor(): NSColor;
  canvasPageBackgroundColor(): NSColor;
  canvasPixelLineColor(): NSColor;
  canvasRulerBackgroundColor(): NSColor;
  canvasRulerLineColor(): NSColor;
  canvasRulerLineOccupiedColor(): NSColor;
  canvasRulerLockColor(): NSColor;
  canvasRulerOccupiedColor(): NSColor;
  canvasRulerTextColor(): NSColor;
  canvasRulerTextBackgroundColor(): NSColor;
  canvasSliceOutlineColor(): NSColor;
  canvasSymbolErrorBackgroundColor(): NSColor;
  canvasSymbolErrorBorderColor(): NSColor;
  canvasSymbolErrorTextColor(): NSColor;
  canvasSymbolTitleColor(): NSColor;
  colorPickerAssetBorderColor(): NSColor;
  colorPickerDarkShadowColor(): NSColor;
  colorPickerLightShadowColor(): NSColor;
  colorPickerMarkerFillColor(): NSColor;
  colorPickerMarkerShadowColor(): NSColor;
  colorPickerSeparatorColor(): NSColor;
  inspectorSectionBackgroundColor(): NSColor;
  inspectorSectionSeparatorColor(): NSColor;
  inspectorSeparatorColor(): NSColor;
  layerListArtboardBorderColor(): NSColor;
  layerListBackgroundColor(): NSColor;
  layerListLightBackgroundColor(): NSColor;
  layerListFilterTokenBackgroundColor(): NSColor;
  layerListFilterTokenSelectedBackgroundColor(): NSColor;
  layerListFilterTokenTitleColor(): NSColor;
  layerListFilterTokenSelectedTitleColor(): NSColor;
  layerListIconPressedTintColor(): NSColor;
  layerListIconPrimaryTintColor(): NSColor;
  layerListIconSecondaryTintColor(): NSColor;
  layerListIconSelectedTintColor(): NSColor;
  layerListIconSharedTintColor(): NSColor;
  layerListSplitViewDividerColor(): NSColor;
  layerListSymbolOverrideIconTintColor(): NSColor;
  layerListTabButtonColor(): NSColor;
  licenseWindowErrorTextColor(): NSColor;
  preferencesWindowErrorTextColor(): NSColor;
  windowBadgeFontsMissingColor(): NSColor;
  windowBadgeLibraryChangesAvailableColor(): NSColor;
  windowBadgePluginUpdatesAvailableColor(): NSColor;
  hoverButtonHoverColor(): NSColor;
  hoverButtonNormalColor(): NSColor;
  splitViewDividerColor(): NSColor;
  static sharedTheme(): MSTheme;
  isDark(): boolean;
}

declare enum MSThemeResolvingOptions {
  MSThemeResolvingOptionsDefault = 0,
  MSThemeResolvingOptionInactiveWindow = 1,
  MSThemeResolvingOptionDarkMode = 2,
}

declare type CHTransformStruct = {
  rotation: CGFloat
  isFlippedHorizontal: boolean
  isFlippedVertical: boolean
  flipOrder: boolean
}

declare enum DKCGContextCreateFlags {
  DKCGContextCreateDefault = 0,
  DKCGContextCreateIsFlipped = 0x01,
}

class COSAlertWindowAllocator<T extends COSAlertWindow> extends NSObjectAllocator<T> {}
declare class COSAlertWindow extends NSObject {
  alloc<T extends COSAlertWindow>(): COSAlertWindowAllocator<T>;
  addTextFieldWithValue(value: NSString | string): void;
  addAccessoryView(view: NSView): void;

  alert(): NSAlert;
  setAlert(alert: NSAlert): void;
}

class COSFiberAllocator<T extends COSFiber> extends NSObjectAllocator<T> {}
declare class COSFiber extends NSObject {
  alloc<T extends COSFiber>(): COSFiberAllocator<T>;
  static createWithCocoaScript(cos: COScript): any;
  onCleanup(jsFunction: MOJavaScriptObject | Function): void;
  cleanup(): void;

  coscript(): COScript;
  setCoscript(coscript: COScript): void;
  cleanUpJSfunc(): MOJavaScriptObject;
  setCleanUpJSfunc(cleanUpJSfunc: MOJavaScriptObject | Function): void;
}

class COSGifAnimatorAllocator<T extends COSGifAnimator> extends NSObjectAllocator<T> {}
declare class COSGifAnimator extends NSObject {
  alloc<T extends COSGifAnimator>(): COSGifAnimatorAllocator<T>;

  fps(): CGFloat;
  setFps(fps: CGFloat): void;
  seconds(): CGFloat;
  setSeconds(seconds: CGFloat): void;
  size(): NSSize;
  setSize(size: NSSize): void;
}

class COSIntervalAllocator<T extends COSInterval> extends COSFiberAllocator<T> {}
declare class COSInterval extends COSFiber {
  alloc<T extends COSInterval>(): COSIntervalAllocator<T>;
  static scheduleWithInterval_cocoaScript_jsFunction_repeat(i: NSTimeInterval, cos: COScript, jsFunction: MOJavaScriptObject | Function, repeat: boolean): any;
  cancel(): void;

  jsfunc(): MOJavaScriptObject;
  setJsfunc(jsfunc: MOJavaScriptObject | Function): void;
}

class COSListenerAllocator<T extends COSListener> extends NSObjectAllocator<T> {}
declare class COSListener extends NSObject {
  alloc<T extends COSListener>(): COSListenerAllocator<T>;
  static sharedListener(): COSListener;
  static listen(): void;
  static listenWithRootObject(rootObject: any): void;

  rootObject(): any;
  setRootObject(rootObject: any): void;
}

class COSMarkdownAllocator<T extends COSMarkdown> extends NSObjectAllocator<T> {}
declare class COSMarkdown extends NSObject {
  alloc<T extends COSMarkdown>(): COSMarkdownAllocator<T>;
}

class COSPreprocessorAllocator<T extends COSPreprocessor> extends NSObjectAllocator<T> {}
declare class COSPreprocessor extends NSObject {
  alloc<T extends COSPreprocessor>(): COSPreprocessorAllocator<T>;
  static preprocessCode(sourceString: NSString | string): NSString;
  static preprocessCode_withBaseURL(sourceString: NSString | string, base: NSURL): NSString;
}

class JSTPSymbolGroupAllocator<T extends JSTPSymbolGroup> extends NSObjectAllocator<T> {}
declare class JSTPSymbolGroup extends NSObject {
  alloc<T extends JSTPSymbolGroup>(): JSTPSymbolGroupAllocator<T>;
  addSymbol(aSymbol: any): void;

  args(): NSMutableArray<any>;
  setArgs(args: NSMutableArray<any> | any[]): void;
  parent(): JSTPSymbolGroup;
  setParent(parent: JSTPSymbolGroup): void;
}

class COSRAllocator<T extends COSR> extends NSObjectAllocator<T> {}
declare class COSR extends NSObject {
  alloc<T extends COSR>(): COSRAllocator<T>;
}

class COScriptAllocator<T extends COScript> extends NSObjectAllocator<T> {
  initWithCoreModules_andName(coreModules: NSDictionary<any, any> | {[key: string]: any}, name: NSString | string): T;
}
declare class COScript extends NSObject {
  alloc<T extends COScript>(): COScriptAllocator<T>;
  static insertInMainMenu(): boolean;
  addFiber(fiber: COSFiber): void;
  cleanupFibers(): void;
  removeFiber(fiber: COSFiber): void;
  createFiber(): COSFiber;
  cleanup(): void;
  garbageCollect(): void;
  executeString(str: NSString | string): any;
  executeString_baseURL(str: NSString | string, base: NSURL): any;
  pushObject_withName(obj: any, name: NSString | string): void;
  deleteObjectWithName(name: NSString | string): void;
  print(s: any): void;
  require(module: NSString | string): any;
  shouldKeepRunning(): boolean;
  context(): JSGlobalContextRef;
  callFunctionNamed_withArguments(name: NSString | string, args: NSArray<any> | any[]): any;
  hasFunctionNamed(name: NSString | string): boolean;
  callJSFunction_withArgumentsInArray(jsFunction: JSObjectRef, arguments: NSArray<any> | any[]): any;
  static loadBridgeSupportFileAtURL(url: NSURL): void;
  static listen(): void;
  static resetPlugins(): void;
  static loadPlugins(): void;
  static setShouldLoadJSTPlugins(b: boolean): void;
  static application(app: NSString | string): any;
  static app(app: NSString | string): any;
  static currentCOScript(): COScript;
  static setDebugController(debugController: any): any;

  printController(): any;
  setPrintController(printController: any): void;
  env(): NSMutableDictionary<any, any>;
  setEnv(env: NSMutableDictionary<any, any> | {[key: string]: any}): void;
  shouldPreprocess(): boolean;
  setShouldPreprocess(shouldPreprocess: boolean): void;
  shouldKeepAround(): boolean;
  setShouldKeepAround(shouldKeepAround: boolean): void;
  processedSource(): NSString;
  setProcessedSource(processedSource: NSString | string): void;
  coreModuleMap(): NSDictionary<any, any>;
  setCoreModuleMap(coreModuleMap: NSDictionary<any, any> | {[key: string]: any}): void;
  moduleCache(): NSMutableDictionary<any, any>;
  setModuleCache(moduleCache: NSMutableDictionary<any, any> | {[key: string]: any}): void;
}

class COSTargetAllocator<T extends COSTarget> extends NSObjectAllocator<T> {
  initWithJSFunction(jsFunction: MOJavaScriptObject | Function): T;
}
declare class COSTarget extends NSObject {
  alloc<T extends COSTarget>(): COSTargetAllocator<T>;
  static targetWithJSFunction(jsFunction: MOJavaScriptObject | Function): COSTarget;
  callAction(sender: any): void;
  action(): string;

  jsFunction(): MOJavaScriptObject;
  setJsFunction(jsFunction: MOJavaScriptObject | Function): void;
  callCount(): NSUInteger;
  setCallCount(callCount: NSUInteger): void;
}

class JSTalkAllocator<T extends JSTalk> extends COScriptAllocator<T> {}
declare class JSTalk extends COScript {
  alloc<T extends JSTalk>(): JSTalkAllocator<T>;
}

declare interface ICOPrintController {
  print(s: any): void;
}

declare interface ICODebugController {
  output_args(format: NSString | string, ...args: any[]): void;
}

class MarkerLineNumberViewAllocator<T extends MarkerLineNumberView> extends NoodleLineNumberViewAllocator<T> {}
declare class MarkerLineNumberView extends NoodleLineNumberView {
  alloc<T extends MarkerLineNumberView>(): MarkerLineNumberViewAllocator<T>;
}

class NoodleLineNumberMarkerAllocator<T extends NoodleLineNumberMarker> extends NSRulerMarkerAllocator<T> {
  initWithRulerView_lineNumber_image_imageOrigin(aRulerView: NSRulerView, line: CGFloat, anImage: NSImage, imageOrigin: NSPoint): T;
}
declare class NoodleLineNumberMarker extends NSRulerMarker {
  alloc<T extends NoodleLineNumberMarker>(): NoodleLineNumberMarkerAllocator<T>;
  setLineNumber(line: NSUInteger): void;
  lineNumber(): NSUInteger;
}

class NoodleLineNumberViewAllocator<T extends NoodleLineNumberView> extends NSRulerViewAllocator<T> {
  initWithScrollView(aScrollView: NSScrollView): T;
}
declare class NoodleLineNumberView extends NSRulerView {
  alloc<T extends NoodleLineNumberView>(): NoodleLineNumberViewAllocator<T>;
  setFont(aFont: NSFont): void;
  font(): NSFont;
  setTextColor(color: NSColor): void;
  textColor(): NSColor;
  setAlternateTextColor(color: NSColor): void;
  alternateTextColor(): NSColor;
  setBackgroundColor(color: NSColor): void;
  backgroundColor(): NSColor;
  lineNumberForLocation(location: CGFloat): NSInteger;
  markerAtLine(line: NSUInteger): NoodleLineNumberMarker;
}

class MOBridgeSupportControllerAllocator<T extends MOBridgeSupportController> extends NSObjectAllocator<T> {}
declare class MOBridgeSupportController extends NSObject {
  alloc<T extends MOBridgeSupportController>(): MOBridgeSupportControllerAllocator<T>;
  static sharedController(): MOBridgeSupportController;
  isBridgeSupportLoadedForURL(aURL: NSURL): boolean;
  loadBridgeSupportAtURL_error(aURL: NSURL, outError: NSError): boolean;
  performQueryForSymbolsOfType(classes: NSArray<any> | any[]): NSDictionary<any, any>;
  performQueryForSymbolName(name: NSString | string): any;
  performQueryForSymbolName_ofType(name: NSString | string, klass: any): any;

  symbols(): NSDictionary<any, any>;
}

class MOBridgeSupportLibraryAllocator<T extends MOBridgeSupportLibrary> extends NSObjectAllocator<T> {}
declare class MOBridgeSupportLibrary extends NSObject {
  alloc<T extends MOBridgeSupportLibrary>(): MOBridgeSupportLibraryAllocator<T>;
  addDependency(dependency: NSString | string): void;
  removeDependency(dependency: NSString | string): void;
  symbolWithName(name: NSString | string): MOBridgeSupportSymbol;
  setSymbol_forName(symbol: MOBridgeSupportSymbol, name: NSString | string): void;
  removeSymbolForName(name: NSString | string): void;

  name(): NSString;
  setName(name: NSString | string): void;
  URL(): NSURL;
  setURL(URL: NSURL): void;
  dependencies(): NSArray<any>;
  setDependencies(dependencies: NSArray<any> | any[]): void;
  symbols(): NSDictionary<any, any>;
  setSymbols(symbols: NSDictionary<any, any> | {[key: string]: any}): void;
}

class MOBridgeSupportParserAllocator<T extends MOBridgeSupportParser> extends NSObjectAllocator<T> {}
declare class MOBridgeSupportParser extends NSObject {
  alloc<T extends MOBridgeSupportParser>(): MOBridgeSupportParserAllocator<T>;
  libraryWithBridgeSupportURL_error(aURL: NSURL, outError: NSError): MOBridgeSupportLibrary;
}

class MOBridgeSupportSymbolAllocator<T extends MOBridgeSupportSymbol> extends NSObjectAllocator<T> {}
declare class MOBridgeSupportSymbol extends NSObject {
  alloc<T extends MOBridgeSupportSymbol>(): MOBridgeSupportSymbolAllocator<T>;

  name(): NSString;
  setName(name: NSString | string): void;
}

class MOBridgeSupportStructAllocator<T extends MOBridgeSupportStruct> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportStruct extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportStruct>(): MOBridgeSupportStructAllocator<T>;

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  opaque(): boolean;
  setOpaque(opaque: boolean): void;
}

class MOBridgeSupportCFTypeAllocator<T extends MOBridgeSupportCFType> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportCFType extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportCFType>(): MOBridgeSupportCFTypeAllocator<T>;

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  tollFreeBridgedClassName(): NSString;
  setTollFreeBridgedClassName(tollFreeBridgedClassName: NSString | string): void;
  getTypeIDFunctionName(): NSString;
  setGetTypeIDFunctionName(getTypeIDFunctionName: NSString | string): void;
}

class MOBridgeSupportOpaqueAllocator<T extends MOBridgeSupportOpaque> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportOpaque extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportOpaque>(): MOBridgeSupportOpaqueAllocator<T>;

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  hasMagicCookie(): boolean;
  setHasMagicCookie(hasMagicCookie: boolean): void;
}

class MOBridgeSupportConstantAllocator<T extends MOBridgeSupportConstant> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportConstant extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportConstant>(): MOBridgeSupportConstantAllocator<T>;

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  hasMagicCookie(): boolean;
  setHasMagicCookie(hasMagicCookie: boolean): void;
}

class MOBridgeSupportStringConstantAllocator<T extends MOBridgeSupportStringConstant> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportStringConstant extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportStringConstant>(): MOBridgeSupportStringConstantAllocator<T>;

  value(): NSString;
  setValue(value: NSString | string): void;
  hasNSString(): boolean;
  setHasNSString(hasNSString: boolean): void;
}

class MOBridgeSupportEnumAllocator<T extends MOBridgeSupportEnum> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportEnum extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportEnum>(): MOBridgeSupportEnumAllocator<T>;

  value(): NSNumber;
  setValue(value: NSNumber | number): void;
  value64(): NSNumber;
  setValue64(value64: NSNumber | number): void;
  ignored(): boolean;
  setIgnored(ignored: boolean): void;
  suggestion(): NSString;
  setSuggestion(suggestion: NSString | string): void;
}

class MOBridgeSupportFunctionAllocator<T extends MOBridgeSupportFunction> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportFunction extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportFunction>(): MOBridgeSupportFunctionAllocator<T>;
  addArgument(argument: MOBridgeSupportArgument): void;
  removeArgument(argument: MOBridgeSupportArgument): void;

  variadic(): boolean;
  setVariadic(variadic: boolean): void;
  sentinel(): NSNumber;
  setSentinel(sentinel: NSNumber | number): void;
  inlineFunction(): boolean;
  setInlineFunction(inlineFunction: boolean): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  returnValue(): MOBridgeSupportArgument;
  setReturnValue(returnValue: MOBridgeSupportArgument): void;
}

class MOBridgeSupportFunctionAliasAllocator<T extends MOBridgeSupportFunctionAlias> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportFunctionAlias extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportFunctionAlias>(): MOBridgeSupportFunctionAliasAllocator<T>;

  original(): NSString;
  setOriginal(original: NSString | string): void;
}

class MOBridgeSupportClassAllocator<T extends MOBridgeSupportClass> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportClass extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportClass>(): MOBridgeSupportClassAllocator<T>;
  addMethod(method: MOBridgeSupportMethod): void;
  removeMethod(method: MOBridgeSupportMethod): void;
  methodWithSelector(selector: string): MOBridgeSupportMethod;

  methods(): NSArray<any>;
  setMethods(methods: NSArray<any> | any[]): void;
}

class MOBridgeSupportInformalProtocolAllocator<T extends MOBridgeSupportInformalProtocol> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportInformalProtocol extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportInformalProtocol>(): MOBridgeSupportInformalProtocolAllocator<T>;
  addMethod(method: MOBridgeSupportMethod): void;
  removeMethod(method: MOBridgeSupportMethod): void;
  methodWithSelector(selector: string): MOBridgeSupportMethod;

  methods(): NSArray<any>;
  setMethods(methods: NSArray<any> | any[]): void;
}

class MOBridgeSupportMethodAllocator<T extends MOBridgeSupportMethod> extends MOBridgeSupportSymbolAllocator<T> {}
declare class MOBridgeSupportMethod extends MOBridgeSupportSymbol {
  alloc<T extends MOBridgeSupportMethod>(): MOBridgeSupportMethodAllocator<T>;
  addArgument(argument: MOBridgeSupportArgument): void;
  removeArgument(argument: MOBridgeSupportArgument): void;

  selector(): string;
  setSelector(selector: string): void;
  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  returnValue(): MOBridgeSupportArgument;
  setReturnValue(returnValue: MOBridgeSupportArgument): void;
  classMethod(): boolean;
  setClassMethod(classMethod: boolean): void;
  variadic(): boolean;
  setVariadic(variadic: boolean): void;
  sentinel(): NSNumber;
  setSentinel(sentinel: NSNumber | number): void;
  ignored(): boolean;
  setIgnored(ignored: boolean): void;
  suggestion(): NSString;
  setSuggestion(suggestion: NSString | string): void;
}

class MOBridgeSupportArgumentAllocator<T extends MOBridgeSupportArgument> extends NSObjectAllocator<T> {}
declare class MOBridgeSupportArgument extends NSObject {
  alloc<T extends MOBridgeSupportArgument>(): MOBridgeSupportArgumentAllocator<T>;
  addArgument(argument: MOBridgeSupportArgument): void;
  removeArgument(argument: MOBridgeSupportArgument): void;

  type(): NSString;
  setType(type: NSString | string): void;
  type64(): NSString;
  setType64(type64: NSString | string): void;
  typeModifier(): NSString;
  setTypeModifier(typeModifier: NSString | string): void;
  signature(): NSString;
  setSignature(signature: NSString | string): void;
  signature64(): NSString;
  setSignature64(signature64: NSString | string): void;
  cArrayLengthInArg(): NSString;
  setCArrayLengthInArg(cArrayLengthInArg: NSString | string): void;
  cArrayOfFixedLength(): boolean;
  setCArrayOfFixedLength(cArrayOfFixedLength: boolean): void;
  cArrayDelimitedByNull(): boolean;
  setCArrayDelimitedByNull(cArrayDelimitedByNull: boolean): void;
  cArrayOfVariableLength(): boolean;
  setCArrayOfVariableLength(cArrayOfVariableLength: boolean): void;
  cArrayLengthInReturnValue(): boolean;
  setCArrayLengthInReturnValue(cArrayLengthInReturnValue: boolean): void;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
  acceptsNull(): boolean;
  setAcceptsNull(acceptsNull: boolean): void;
  acceptsPrintfFormat(): boolean;
  setAcceptsPrintfFormat(acceptsPrintfFormat: boolean): void;
  alreadyRetained(): boolean;
  setAlreadyRetained(alreadyRetained: boolean): void;
  functionPointer(): boolean;
  setFunctionPointer(functionPointer: boolean): void;
  arguments(): NSArray<any>;
  setArguments(arguments: NSArray<any> | any[]): void;
  returnValue(): MOBridgeSupportArgument;
  setReturnValue(returnValue: MOBridgeSupportArgument): void;
}

class MochaAllocator<T extends Mocha> extends NSObjectAllocator<T> {
  initWithName(name: NSString | string): T;
}
declare class Mocha extends NSObject {
  alloc<T extends Mocha>(): MochaAllocator<T>;
  static sharedRuntime(): Mocha;
  evalString(string: NSString | string): any;
  evalString_atURL(string: NSString | string, url: NSURL): any;
  callFunctionWithName(functionName: NSString | string): any;
  callFunctionWithName_withArguments(functionName: NSString | string, firstArg: any, ...args: any[]): any;
  callFunctionWithName_withArgumentsInArray(functionName: NSString | string, arguments: NSArray<any> | any[]): any;
  isSyntaxValidForString(string: NSString | string): boolean;
  loadFrameworkWithName(frameworkName: NSString | string): boolean;
  loadFrameworkWithName_inDirectory(frameworkName: NSString | string, directory: NSString | string): boolean;
  loadBridgeSupportFilesAtPath(path: NSString | string): boolean;
  addFrameworkSearchPath(path: NSString | string): void;
  insertFrameworkSearchPath_atIndex(path: NSString | string, idx: NSUInteger): void;
  removeFrameworkSearchPathAtIndex(idx: NSUInteger): void;
  garbageCollect(): void;
  context(): JSGlobalContextRef;
  static runtimeWithContext(ctx: JSContextRef): Mocha;
  static JSValueForObject_inContext(object: any, ctx: JSContextRef): JSValueRef;
  static objectForJSValue_inContext(value: JSValueRef, ctx: JSContextRef): any;
  static objectForJSValue_inContext_unboxObjects(value: JSValueRef, ctx: JSContextRef, unboxObjects: boolean): any;
  static arrayForJSArray_inContext(arrayValue: JSObjectRef, ctx: JSContextRef): NSArray<any>;
  static dictionaryForJSHash_inContext(hashValue: JSObjectRef, ctx: JSContextRef): NSDictionary<any, any>;
  JSValueForObject(object: any): JSValueRef;
  objectForJSValue(value: JSValueRef): any;
  objectForJSValue_unboxObjects(value: JSValueRef, unboxObjects: boolean): any;
  boxedJSObjectForObject(object: any): JSObjectRef;
  unboxedObjectForJSObject(jsObject: JSObjectRef): any;
  objectWithName(name: NSString | string): any;
  setObject_withName(object: any, name: NSString | string): JSValueRef;
  setObject_withName_attributes(object: any, name: NSString | string, attributes: JSPropertyAttributes): JSValueRef;
  removeObjectWithName(name: NSString | string): boolean;
  evalJSString(string: NSString | string): JSValueRef;
  evalJSString_scriptPath(string: NSString | string, scriptPath: NSString | string): JSValueRef;
  JSFunctionWithName(functionName: NSString | string): JSObjectRef;
  callJSFunctionWithName_withArgumentsInArray(functionName: NSString | string, arguments: NSArray<any> | any[]): JSValueRef;
  callJSFunction_withArgumentsInArray(jsFunction: JSObjectRef, arguments: NSArray<any> | any[]): JSValueRef;
  static exceptionWithJSException_context(exception: JSValueRef, ctx: JSContextRef): NSException;
  exceptionWithJSException(exception: JSValueRef): NSException;
  throwJSException(exception: JSValueRef): void;
  installBuiltins(): void;
  cleanUp(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  frameworkSearchPaths(): NSArray<any>;
  setFrameworkSearchPaths(frameworkSearchPaths: NSArray<any> | any[]): void;
  globalSymbolNames(): NSArray<any>;
  context(): JSGlobalContextRef;
}

declare interface IMochaDelegate {
}

class MOAllocatorAllocator<T extends MOAllocator> extends NSObjectAllocator<T> {}
declare class MOAllocator extends NSObject {
  alloc<T extends MOAllocator>(): MOAllocatorAllocator<T>;
  static allocator(): MOAllocator;

  objectClass(): any;
  setObjectClass(objectClass: any): void;
}

class MOBoxAllocator<T extends MOBox> extends NSObjectAllocator<T> {
  initWithManager_object_jsObject(manager: MOBoxManager, object: any, jsObject: JSObjectRef): T;
}
declare class MOBox extends NSObject {
  alloc<T extends MOBox>(): MOBoxAllocator<T>;
  disassociateObject(): void;

  representedObject(): any;
  JSObject(): JSObjectRef;
  manager(): MOBoxManager;
  representedObjectCanaryDesc(): NSString;
  count(): NSUInteger;
}

class MOBoxManagerAllocator<T extends MOBoxManager> extends NSObjectAllocator<T> {
  initWithContext(context: JSGlobalContextRef): T;
}
declare class MOBoxManager extends NSObject {
  alloc<T extends MOBoxManager>(): MOBoxManagerAllocator<T>;
  cleanup(): void;
  boxForObject(object: any): MOBox;
  makeBoxForObject_jsClass(object: any, jsClass: JSClassRef): JSObjectRef;
  removeBoxForObject(object: any): void;
}

class MOBoxManagerBoxContextAllocator<T extends MOBoxManagerBoxContext> extends NSObjectAllocator<T> {
  initWithManager_object(manager: MOBoxManager, object: any): T;
}
declare class MOBoxManagerBoxContext extends NSObject {
  alloc<T extends MOBoxManagerBoxContext>(): MOBoxManagerBoxContextAllocator<T>;
  finishMakingBoxForObject(jsObject: JSObjectRef): void;
}

class MOClassDescriptionAllocator<T extends MOClassDescription> extends NSObjectAllocator<T> {}
declare class MOClassDescription extends NSObject {
  alloc<T extends MOClassDescription>(): MOClassDescriptionAllocator<T>;
  static descriptionForClassWithName(name: NSString | string): MOClassDescription;
  static descriptionForClass(aClass: any): MOClassDescription;
  static allocateDescriptionForClassWithName_superclass(name: NSString | string, superclass: any): MOClassDescription;
  registerClass(): any;
  addInstanceVariableWithName_typeEncoding(name: NSString | string, typeEncoding: NSString | string): boolean;
  addClassMethodWithSelector_typeEncoding_block(selector: string, typeEncoding: NSString | string, block: any): boolean;
  addClassMethodWithSelector_function(selector: string, functionName: MOJavaScriptObject | Function): boolean;
  addInstanceMethodWithSelector_typeEncoding_block(selector: string, typeEncoding: NSString | string, block: any): boolean;
  addInstanceMethodWithSelector_function(selector: string, functionName: MOJavaScriptObject | Function): boolean;
  addProperty(property: MOPropertyDescription): boolean;
  addProtocol(protocol: MOProtocolDescription): void;

  name(): NSString;
  descriptedClass(): any;
  superclass(): MOClassDescription;
  ancestors(): NSArray<any>;
  instanceVariables(): NSArray<any>;
  instanceVariablesWithAncestors(): NSArray<any>;
  classMethods(): NSArray<any>;
  classMethodsWithAncestors(): NSArray<any>;
  instanceMethods(): NSArray<any>;
  instanceMethodsWithAncestors(): NSArray<any>;
  properties(): NSArray<any>;
  propertiesWithAncestors(): NSArray<any>;
  protocols(): NSArray<any>;
  protocolsWithAncestors(): NSArray<any>;
}

class MOClosureAllocator<T extends MOClosure> extends NSObjectAllocator<T> {
  initWithBlock(block: any): T;
}
declare class MOClosure extends NSObject {
  alloc<T extends MOClosure>(): MOClosureAllocator<T>;
  static closureWithBlock(block: any): MOClosure;

  block(): any;
  callAddress(): void;
  typeEncoding(): string;
}

class MOInstanceVariableDescriptionAllocator<T extends MOInstanceVariableDescription> extends NSObjectAllocator<T> {
  initWithName_typeEncoding(name: NSString | string, typeEncoding: NSString | string): T;
}
declare class MOInstanceVariableDescription extends NSObject {
  alloc<T extends MOInstanceVariableDescription>(): MOInstanceVariableDescriptionAllocator<T>;
  static instanceVariableWithName_typeEncoding(name: NSString | string, typeEncoding: NSString | string): MOInstanceVariableDescription;

  name(): NSString;
  setName(name: NSString | string): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
}

class MOJavaScriptObjectAllocator<T extends MOJavaScriptObject> extends NSObjectAllocator<T> {}
declare class MOJavaScriptObject extends NSObject {
  alloc<T extends MOJavaScriptObject>(): MOJavaScriptObjectAllocator<T>;
  static objectWithJSObject_context(jsObject: JSObjectRef, ctx: JSContextRef): MOJavaScriptObject;

  JSObject(): JSObjectRef;
  JSContext(): JSContextRef;
}

class MOMethodAllocator<T extends MOMethod> extends NSObjectAllocator<T> {}
declare class MOMethod extends NSObject {
  alloc<T extends MOMethod>(): MOMethodAllocator<T>;
  static methodWithTarget_selector(target: any, selector: string): MOMethod;

  target(): any;
  setTarget(target: any): void;
  selector(): string;
  setSelector(selector: string): void;
  block(): any;
  setBlock(block: any): void;
}

class MOMethodDescriptionAllocator<T extends MOMethodDescription> extends NSObjectAllocator<T> {
  initWithSelector_typeEncoding(selector: string, typeEncoding: NSString | string): T;
}
declare class MOMethodDescription extends NSObject {
  alloc<T extends MOMethodDescription>(): MOMethodDescriptionAllocator<T>;
  static methodWithSelector_typeEncoding(selector: string, typeEncoding: NSString | string): MOMethodDescription;

  selector(): string;
  setSelector(selector: string): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
}

class MOObjCRuntimeAllocator<T extends MOObjCRuntime> extends NSObjectAllocator<T> {}
declare class MOObjCRuntime extends NSObject {
  alloc<T extends MOObjCRuntime>(): MOObjCRuntimeAllocator<T>;
  static sharedRuntime(): MOObjCRuntime;

  classes(): NSArray<any>;
  protocols(): NSArray<any>;
}

class MOPointerAllocator<T extends MOPointer> extends NSObjectAllocator<T> {
  initWithValue(value: any): T;
  initWithTypeEncoding(typeEncoding: NSString | string): T;
}
declare class MOPointer extends NSObject {
  alloc<T extends MOPointer>(): MOPointerAllocator<T>;

  value(): any;
  setValue(value: any): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
}

class MOPointerValueAllocator<T extends MOPointerValue> extends NSObjectAllocator<T> {
  initWithPointerValue_typeEncoding(pointerValue: void, typeEncoding: NSString | string): T;
}
declare class MOPointerValue extends NSObject {
  alloc<T extends MOPointerValue>(): MOPointerValueAllocator<T>;

  pointerValue(): void;
  typeEncoding(): NSString;
}

class MOPropertyDescriptionAllocator<T extends MOPropertyDescription> extends NSObjectAllocator<T> {}
declare class MOPropertyDescription extends NSObject {
  alloc<T extends MOPropertyDescription>(): MOPropertyDescriptionAllocator<T>;

  name(): NSString;
  setName(name: NSString | string): void;
  typeEncoding(): NSString;
  setTypeEncoding(typeEncoding: NSString | string): void;
  ivarName(): NSString;
  setIvarName(ivarName: NSString | string): void;
  getterSelector(): string;
  setGetterSelector(getterSelector: string): void;
  setterSelector(): string;
  setSetterSelector(setterSelector: string): void;
  ownershipRule(): MOObjCOwnershipRule;
  setOwnershipRule(ownershipRule: MOObjCOwnershipRule): void;
  dynamic(): boolean;
  setDynamic(dynamic: boolean): void;
  nonAtomic(): boolean;
  setNonAtomic(nonAtomic: boolean): void;
  readOnly(): boolean;
  setReadOnly(readOnly: boolean): void;
  weak(): boolean;
  setWeak(weak: boolean): void;
}

class MOProtocolDescriptionAllocator<T extends MOProtocolDescription> extends NSObjectAllocator<T> {}
declare class MOProtocolDescription extends NSObject {
  alloc<T extends MOProtocolDescription>(): MOProtocolDescriptionAllocator<T>;
  static descriptionForProtocol(protocol: Protocol): MOProtocolDescription;
  static descriptionForProtocolWithName(name: NSString | string): MOProtocolDescription;
  static allocateDescriptionForProtocolWithName(name: NSString | string): MOProtocolDescription;
  addClassMethod_required(method: MOMethodDescription, isRequired: boolean): void;
  addInstanceMethod_required(method: MOMethodDescription, isRequired: boolean): void;
  addProperty_required(property: MOPropertyDescription, isRequired: boolean): void;
  addProtocol(protocol: MOProtocolDescription): void;

  name(): NSString;
  requiredClassMethods(): NSArray<any>;
  optionalClassMethods(): NSArray<any>;
  requiredInstanceMethods(): NSArray<any>;
  optionalInstanceMethods(): NSArray<any>;
  properties(): NSArray<any>;
  protocols(): NSArray<any>;
  protocol(): Protocol;
}

class MOStructAllocator<T extends MOStruct> extends NSObjectAllocator<T> {
  initWithName_memberNames_runtime(name: NSString | string, memberNames: NSArray<any> | any[], runtime: Mocha): T;
}
declare class MOStruct extends NSObject {
  alloc<T extends MOStruct>(): MOStructAllocator<T>;
  static structureWithName_memberNames_runtime(name: NSString | string, memberNames: NSArray<any> | any[], runtime: Mocha): MOStruct;
  objectForMemberName(name: NSString | string): any;
  setObject_forMemberName(obj: any, name: NSString | string): void;

  name(): NSString;
  memberNames(): NSArray<any>;
}

class MOUndefinedAllocator<T extends MOUndefined> extends NSObjectAllocator<T> {}
declare class MOUndefined extends NSObject {
  alloc<T extends MOUndefined>(): MOUndefinedAllocator<T>;
  static undefined(): MOUndefined;
}

class MOFunctionArgumentAllocator<T extends MOFunctionArgument> extends NSObjectAllocator<T> {}
declare class MOFunctionArgument extends NSObject {
  alloc<T extends MOFunctionArgument>(): MOFunctionArgumentAllocator<T>;
  setTypeEncoding_withCustomStorage(typeEncoding: string, storagePtr: void): void;
  setPointerTypeEncoding_withCustomStorage(pointerTypeEncoding: NSString | string, storagePtr: void): void;
  setStructureTypeEncoding_withCustomStorage(structureTypeEncoding: NSString | string, storagePtr: void): void;
  getValueAsJSValueInContext(ctx: JSContextRef): JSValueRef;
  setValueAsJSValue_context(value: JSValueRef, ctx: JSContextRef): void;
  getValueAsJSValueInContext_dereference(ctx: JSContextRef, dereference: boolean): JSValueRef;
  setValueAsJSValue_context_dereference(value: JSValueRef, ctx: JSContextRef, dereference: boolean): void;
  static getAlignment_ofTypeEncoding(alignment: size_t, encoding: string): boolean;
  static getSize_ofTypeEncoding(size: size_t, encoding: string): boolean;
  static ffiTypeForTypeEncoding(encoding: string): ffi_type;
  static descriptionOfTypeEncoding(encoding: string): NSString;
  static descriptionOfTypeEncoding_fullTypeEncoding(typeEncoding: string, fullTypeEncoding: NSString | string): NSString;
  static sizeOfStructureTypeEncoding(encoding: NSString | string): size_t;
  static structureNameFromStructureTypeEncoding(encoding: NSString | string): NSString;
  static structureTypeEncodingDescription(structureTypeEncoding: NSString | string): NSString;
  static structureFullTypeEncodingFromStructureTypeEncoding(encoding: NSString | string): NSString;
  static structureFullTypeEncodingFromStructureName(structureName: NSString | string): NSString;
  static typeEncodingsFromStructureTypeEncoding(structureTypeEncoding: NSString | string): NSArray<any>;
  static typeEncodingsFromStructureTypeEncoding_parsedCount(structureTypeEncoding: NSString | string, count: NSInteger): NSArray<any>;
  static fromJSValue_inContext_typeEncoding_fullTypeEncoding_storage(value: JSValueRef, ctx: JSContextRef, typeEncoding: string, fullTypeEncoding: NSString | string, ptr: void): boolean;
  static toJSValue_inContext_typeEncoding_fullTypeEncoding_storage(value: JSValueRef, ctx: JSContextRef, typeEncoding: string, fullTypeEncoding: NSString | string, ptr: void): boolean;
  static structureFromJSObject_inContext_inParentJSValueRef_cString_storage(object: JSObjectRef, ctx: JSContextRef, parentValue: JSValueRef, c: string, ptr: void): NSInteger;
  static structureToJSValue_inContext_cString_storage(value: JSValueRef, ctx: JSContextRef, c: string, ptr: void): NSInteger;
  static structureToJSValue_inContext_cString_storage_initialValues_initialValueCount_convertedValueCount(value: JSValueRef, ctx: JSContextRef, c: string, ptr: void, initialValues: JSValueRef, initialValueCount: NSInteger, convertedValueCount: NSInteger): NSInteger;

  typeEncoding(): string;
  setTypeEncoding(typeEncoding: string): void;
  pointerTypeEncoding(): NSString;
  setPointerTypeEncoding(pointerTypeEncoding: NSString | string): void;
  structureTypeEncoding(): NSString;
  setStructureTypeEncoding(structureTypeEncoding: NSString | string): void;
  pointer(): MOPointer;
  setPointer(pointer: MOPointer): void;
  returnValue(): boolean;
  setReturnValue(returnValue: boolean): void;
  ffiType(): ffi_type;
  storage(): void;
  typeDescription(): NSString;
}

class MOJSBlockAllocator<T extends MOJSBlock> extends NSObjectAllocator<T> {
  initWithSignature_function(signature: string, functionName: MOJavaScriptObject | Function): T;
}
declare class MOJSBlock extends NSObject implements INSCopying {
  alloc<T extends MOJSBlock>(): MOJSBlockAllocator<T>;
  static blockWithSignature_function(signature: NSString | string, functionName: MOJavaScriptObject | Function): MOJSBlock;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  function(): MOJavaScriptObject;
  signature(): NSMethodSignature;
}

class MOMapTableAllocator<T extends MOMapTable> extends NSObjectAllocator<T> {}
declare class MOMapTable extends NSObject implements INSFastEnumeration {
  alloc<T extends MOMapTable>(): MOMapTableAllocator<T>;
  static mapTableWithStrongToStrongObjects(): MOMapTable;
  static mapTableWithStrongToUnretainedObjects(): MOMapTable;
  static mapTableWithUnretainedToStrongObjects(): MOMapTable;
  static mapTableWithUnretainedToUnretainedObjects(): MOMapTable;
  keyEnumerator(): NSEnumerator<any>;
  objectEnumerator(): NSEnumerator<any>;
  count(): NSUInteger;
  allKeys(): NSArray<any>;
  allObjects(): NSArray<any>;
  objectForKey(key: any): any;
  setObject_forKey(value: any, key: any): void;
  removeObjectForKey(key: any): void;
  removeAllObjects(): void;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
}

class TDAlternationAllocator<T extends TDAlternation> extends TDCollectionParserAllocator<T> {}
declare class TDAlternation extends TDCollectionParser {
  alloc<T extends TDAlternation>(): TDAlternationAllocator<T>;
  static alternation(): any;
}

class TDAnyAllocator<T extends TDAny> extends TDTerminalAllocator<T> {}
declare class TDAny extends TDTerminal {
  alloc<T extends TDAny>(): TDAnyAllocator<T>;
  static any(): any;
}

class TDAssemblyAllocator<T extends TDAssembly> extends NSObjectAllocator<T> {
  initWithString(s: NSString | string): T;
}
declare class TDAssembly extends NSObject implements INSCopying {
  alloc<T extends TDAssembly>(): TDAssemblyAllocator<T>;
  static assemblyWithString(s: NSString | string): any;
  peek(): any;
  next(): any;
  hasMore(): boolean;
  consumedObjectsJoinedByString(delimiter: NSString | string): NSString;
  remainingObjectsJoinedByString(delimiter: NSString | string): NSString;
  pop(): any;
  push(object: any): void;
  isStackEmpty(): boolean;
  objectsAbove(fence: any): NSArray<any>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  length(): NSUInteger;
  objectsConsumed(): NSUInteger;
  objectsRemaining(): NSUInteger;
  defaultDelimiter(): NSString;
  stack(): NSMutableArray<any>;
  target(): any;
  setTarget(target: any): void;
}

class TDCaseInsensitiveLiteralAllocator<T extends TDCaseInsensitiveLiteral> extends TDLiteralAllocator<T> {}
declare class TDCaseInsensitiveLiteral extends TDLiteral {
  alloc<T extends TDCaseInsensitiveLiteral>(): TDCaseInsensitiveLiteralAllocator<T>;
}

class TDCharAllocator<T extends TDChar> extends TDTerminalAllocator<T> {}
declare class TDChar extends TDTerminal {
  alloc<T extends TDChar>(): TDCharAllocator<T>;
  static char(): any;
}

class TDCharacterAssemblyAllocator<T extends TDCharacterAssembly> extends TDAssemblyAllocator<T> {}
declare class TDCharacterAssembly extends TDAssembly {
  alloc<T extends TDCharacterAssembly>(): TDCharacterAssemblyAllocator<T>;
}

class TDCollectionParserAllocator<T extends TDCollectionParser> extends TDParserAllocator<T> {}
declare class TDCollectionParser extends TDParser {
  alloc<T extends TDCollectionParser>(): TDCollectionParserAllocator<T>;
  add(p: TDParser): void;

  subparsers(): NSMutableArray<any>;
}

class TDCommentAllocator<T extends TDComment> extends TDTerminalAllocator<T> {}
declare class TDComment extends TDTerminal {
  alloc<T extends TDComment>(): TDCommentAllocator<T>;
  static comment(): any;
}

class TDCommentStateAllocator<T extends TDCommentState> extends TDTokenizerStateAllocator<T> {}
declare class TDCommentState extends TDTokenizerState {
  alloc<T extends TDCommentState>(): TDCommentStateAllocator<T>;
  addSingleLineStartSymbol(start: NSString | string): void;
  removeSingleLineStartSymbol(start: NSString | string): void;
  addMultiLineStartSymbol_endSymbol(start: NSString | string, end: NSString | string): void;
  removeMultiLineStartSymbol(start: NSString | string): void;

  reportsCommentTokens(): boolean;
  setReportsCommentTokens(reportsCommentTokens: boolean): void;
  balancesEOFTerminatedComments(): boolean;
  setBalancesEOFTerminatedComments(balancesEOFTerminatedComments: boolean): void;
}

class TDDigitAllocator<T extends TDDigit> extends TDTerminalAllocator<T> {}
declare class TDDigit extends TDTerminal {
  alloc<T extends TDDigit>(): TDDigitAllocator<T>;
  static digit(): any;
}

class TDEmptyAllocator<T extends TDEmpty> extends TDParserAllocator<T> {}
declare class TDEmpty extends TDParser {
  alloc<T extends TDEmpty>(): TDEmptyAllocator<T>;
  static empty(): any;
}

class TDLetterAllocator<T extends TDLetter> extends TDTerminalAllocator<T> {}
declare class TDLetter extends TDTerminal {
  alloc<T extends TDLetter>(): TDLetterAllocator<T>;
  static letter(): any;
}

class TDLiteralAllocator<T extends TDLiteral> extends TDTerminalAllocator<T> {}
declare class TDLiteral extends TDTerminal {
  alloc<T extends TDLiteral>(): TDLiteralAllocator<T>;
  static literalWithString(s: NSString | string): any;
}

class TDLowercaseWordAllocator<T extends TDLowercaseWord> extends TDWordAllocator<T> {}
declare class TDLowercaseWord extends TDWord {
  alloc<T extends TDLowercaseWord>(): TDLowercaseWordAllocator<T>;
}

class TDMultiLineCommentStateAllocator<T extends TDMultiLineCommentState> extends TDTokenizerStateAllocator<T> {}
declare class TDMultiLineCommentState extends TDTokenizerState {
  alloc<T extends TDMultiLineCommentState>(): TDMultiLineCommentStateAllocator<T>;
}

class TDNonReservedWordAllocator<T extends TDNonReservedWord> extends TDWordAllocator<T> {}
declare class TDNonReservedWord extends TDWord {
  alloc<T extends TDNonReservedWord>(): TDNonReservedWordAllocator<T>;
}

class TDNumAllocator<T extends TDNum> extends TDTerminalAllocator<T> {}
declare class TDNum extends TDTerminal {
  alloc<T extends TDNum>(): TDNumAllocator<T>;
  static num(): any;
}

class TDNumberStateAllocator<T extends TDNumberState> extends TDTokenizerStateAllocator<T> {}
declare class TDNumberState extends TDTokenizerState {
  alloc<T extends TDNumberState>(): TDNumberStateAllocator<T>;

  allowsTrailingDot(): boolean;
  setAllowsTrailingDot(allowsTrailingDot: boolean): void;
}

class TDParserAllocator<T extends TDParser> extends NSObjectAllocator<T> {}
declare class TDParser extends NSObject {
  alloc<T extends TDParser>(): TDParserAllocator<T>;
  static parser(): any;
  setAssembler_selector(a: any, sel: string): void;
  bestMatchFor(inAssembly: TDAssembly): TDAssembly;
  completeMatchFor(inAssembly: TDAssembly): TDAssembly;
  allMatchesFor(inAssemblies: NSSet<any>): NSSet<any>;

  assembler(): any;
  setAssembler(assembler: any): void;
  selector(): string;
  setSelector(selector: string): void;
  name(): NSString;
  setName(name: NSString | string): void;
}

class TDQuoteStateAllocator<T extends TDQuoteState> extends TDTokenizerStateAllocator<T> {}
declare class TDQuoteState extends TDTokenizerState {
  alloc<T extends TDQuoteState>(): TDQuoteStateAllocator<T>;

  balancesEOFTerminatedQuotes(): boolean;
  setBalancesEOFTerminatedQuotes(balancesEOFTerminatedQuotes: boolean): void;
}

class TDQuotedStringAllocator<T extends TDQuotedString> extends TDTerminalAllocator<T> {}
declare class TDQuotedString extends TDTerminal {
  alloc<T extends TDQuotedString>(): TDQuotedStringAllocator<T>;
  static quotedString(): any;
}

class TDReaderAllocator<T extends TDReader> extends NSObjectAllocator<T> {
  initWithString(s: NSString | string): T;
}
declare class TDReader extends NSObject {
  alloc<T extends TDReader>(): TDReaderAllocator<T>;
  read(): NSInteger;
  unread(): void;

  string(): NSString;
  setString(string: NSString | string): void;
}

class TDRepetitionAllocator<T extends TDRepetition> extends TDParserAllocator<T> {
  initWithSubparser(p: TDParser): T;
}
declare class TDRepetition extends TDParser {
  alloc<T extends TDRepetition>(): TDRepetitionAllocator<T>;
  static repetitionWithSubparser(p: TDParser): any;
  setPreassembler_selector(a: any, sel: string): void;

  subparser(): TDParser;
  preassembler(): any;
  setPreassembler(preassembler: any): void;
  preassemblerSelector(): string;
  setPreassemblerSelector(preassemblerSelector: string): void;
}

class TDReservedWordAllocator<T extends TDReservedWord> extends TDWordAllocator<T> {}
declare class TDReservedWord extends TDWord {
  alloc<T extends TDReservedWord>(): TDReservedWordAllocator<T>;
  static setReservedWords(inWords: NSArray<any> | any[]): void;
}

class TDScientificNumberStateAllocator<T extends TDScientificNumberState> extends TDNumberStateAllocator<T> {}
declare class TDScientificNumberState extends TDNumberState {
  alloc<T extends TDScientificNumberState>(): TDScientificNumberStateAllocator<T>;
}

class TDSequenceAllocator<T extends TDSequence> extends TDCollectionParserAllocator<T> {}
declare class TDSequence extends TDCollectionParser {
  alloc<T extends TDSequence>(): TDSequenceAllocator<T>;
  static sequence(): any;
}

class TDTokenAllocator<T extends TDToken> extends NSObjectAllocator<T> {
  initWithTokenType_stringValue_floatValue(t: TDTokenType, s: NSString | string, n: CGFloat): T;
}
declare class TDToken extends NSObject {
  alloc<T extends TDToken>(): TDTokenAllocator<T>;
  static EOFToken(): TDToken;
  static tokenWithTokenType_stringValue_floatValue(t: TDTokenType, s: NSString | string, n: CGFloat): any;
  isEqualIgnoringCase(obj: any): boolean;
  debugDescription(): NSString;

  whitespace(): boolean;
  number(): boolean;
  quotedString(): boolean;
  symbol(): boolean;
  word(): boolean;
  comment(): boolean;
  tokenType(): TDTokenType;
  floatValue(): CGFloat;
  stringValue(): NSString;
  value(): any;
}

class TDSignificantWhitespaceStateAllocator<T extends TDSignificantWhitespaceState> extends TDWhitespaceStateAllocator<T> {}
declare class TDSignificantWhitespaceState extends TDWhitespaceState {
  alloc<T extends TDSignificantWhitespaceState>(): TDSignificantWhitespaceStateAllocator<T>;
}

class TDSingleLineCommentStateAllocator<T extends TDSingleLineCommentState> extends TDTokenizerStateAllocator<T> {}
declare class TDSingleLineCommentState extends TDTokenizerState {
  alloc<T extends TDSingleLineCommentState>(): TDSingleLineCommentStateAllocator<T>;
}

class TDSpecificCharAllocator<T extends TDSpecificChar> extends TDTerminalAllocator<T> {
  initWithSpecificChar(c: NSInteger): T;
}
declare class TDSpecificChar extends TDTerminal {
  alloc<T extends TDSpecificChar>(): TDSpecificCharAllocator<T>;
  static specificCharWithChar(c: NSInteger): any;
}

class TDSymbolAllocator<T extends TDSymbol> extends TDTerminalAllocator<T> {}
declare class TDSymbol extends TDTerminal {
  alloc<T extends TDSymbol>(): TDSymbolAllocator<T>;
  static symbol(): any;
  static symbolWithString(s: NSString | string): any;
}

class TDSymbolNodeAllocator<T extends TDSymbolNode> extends NSObjectAllocator<T> {
  initWithParent_character(p: TDSymbolNode, c: NSInteger): T;
}
declare class TDSymbolNode extends NSObject {
  alloc<T extends TDSymbolNode>(): TDSymbolNodeAllocator<T>;

  ancestry(): NSString;
}

class TDSymbolRootNodeAllocator<T extends TDSymbolRootNode> extends TDSymbolNodeAllocator<T> {}
declare class TDSymbolRootNode extends TDSymbolNode {
  alloc<T extends TDSymbolRootNode>(): TDSymbolRootNodeAllocator<T>;
  add(s: NSString | string): void;
  remove(s: NSString | string): void;
  nextSymbol_startingWith(r: TDReader, cin: NSInteger): NSString;
}

class TDSymbolStateAllocator<T extends TDSymbolState> extends TDTokenizerStateAllocator<T> {}
declare class TDSymbolState extends TDTokenizerState {
  alloc<T extends TDSymbolState>(): TDSymbolStateAllocator<T>;
  add(s: NSString | string): void;
  remove(s: NSString | string): void;
}

class TDTerminalAllocator<T extends TDTerminal> extends TDParserAllocator<T> {
  initWithString(s: NSString | string | null): T;
}
declare class TDTerminal extends TDParser {
  alloc<T extends TDTerminal>(): TDTerminalAllocator<T>;
  discard(): TDTerminal;

  string(): NSString;
}

declare enum TDTokenType {
  TDTokenTypeEOF,
  TDTokenTypeNumber,
  TDTokenTypeQuotedString,
  TDTokenTypeSymbol,
  TDTokenTypeWord,
  TDTokenTypeWhitespace,
  TDTokenTypeComment,
}

class TDTokenArraySourceAllocator<T extends TDTokenArraySource> extends NSObjectAllocator<T> {
  initWithTokenizer_delimiter(t: TDTokenizer, s: NSString | string): T;
}
declare class TDTokenArraySource extends NSObject {
  alloc<T extends TDTokenArraySource>(): TDTokenArraySourceAllocator<T>;
  hasMore(): boolean;
  nextTokenArray(): NSArray<any>;
}

class TDTokenAssemblyAllocator<T extends TDTokenAssembly> extends TDAssemblyAllocator<T> {
  initWithTokenzier(t: TDTokenizer): T;
  initWithTokenArray(a: NSArray<any> | any[]): T;
}
declare class TDTokenAssembly extends TDAssembly implements INSCopying {
  alloc<T extends TDTokenAssembly>(): TDTokenAssemblyAllocator<T>;
  static assemblyWithTokenizer(t: TDTokenizer): any;
  static assemblyWithTokenArray(a: NSArray<any> | any[]): any;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  preservesWhitespaceTokens(): boolean;
  setPreservesWhitespaceTokens(preservesWhitespaceTokens: boolean): void;
}

class TDTokenizerAllocator<T extends TDTokenizer> extends NSObjectAllocator<T> {
  initWithString(s: NSString | string): T;
}
declare class TDTokenizer extends NSObject {
  alloc<T extends TDTokenizer>(): TDTokenizerAllocator<T>;
  static tokenizer(): any;
  static tokenizerWithString(s: NSString | string): any;
  nextToken(): TDToken;
  setTokenizerState_from_to(state: TDTokenizerState, start: NSInteger, end: NSInteger): void;

  string(): NSString;
  setString(string: NSString | string): void;
  numberState(): TDNumberState;
  setNumberState(numberState: TDNumberState): void;
  quoteState(): TDQuoteState;
  setQuoteState(quoteState: TDQuoteState): void;
  commentState(): TDCommentState;
  setCommentState(commentState: TDCommentState): void;
  symbolState(): TDSymbolState;
  setSymbolState(symbolState: TDSymbolState): void;
  whitespaceState(): TDWhitespaceState;
  setWhitespaceState(whitespaceState: TDWhitespaceState): void;
  wordState(): TDWordState;
  setWordState(wordState: TDWordState): void;
}

class TDTokenizerStateAllocator<T extends TDTokenizerState> extends NSObjectAllocator<T> {}
declare class TDTokenizerState extends NSObject {
  alloc<T extends TDTokenizerState>(): TDTokenizerStateAllocator<T>;
  nextTokenFromReader_startingWith_tokenizer(r: TDReader, cin: NSInteger, t: TDTokenizer): TDToken;
}

class TDTrackAllocator<T extends TDTrack> extends TDSequenceAllocator<T> {}
declare class TDTrack extends TDSequence {
  alloc<T extends TDTrack>(): TDTrackAllocator<T>;
  static track(): any;
}

class TDTrackExceptionAllocator<T extends TDTrackException> extends NSExceptionAllocator<T> {}
declare class TDTrackException extends NSException {
  alloc<T extends TDTrackException>(): TDTrackExceptionAllocator<T>;
}

class TDUppercaseWordAllocator<T extends TDUppercaseWord> extends TDWordAllocator<T> {}
declare class TDUppercaseWord extends TDWord {
  alloc<T extends TDUppercaseWord>(): TDUppercaseWordAllocator<T>;
}

class TDWhitespaceStateAllocator<T extends TDWhitespaceState> extends TDTokenizerStateAllocator<T> {}
declare class TDWhitespaceState extends TDTokenizerState {
  alloc<T extends TDWhitespaceState>(): TDWhitespaceStateAllocator<T>;
  isWhitespaceChar(cin: NSInteger): boolean;
  setWhitespaceChars_from_to(yn: boolean, start: NSInteger, end: NSInteger): void;

  reportsWhitespaceTokens(): boolean;
  setReportsWhitespaceTokens(reportsWhitespaceTokens: boolean): void;
}

class TDWordAllocator<T extends TDWord> extends TDTerminalAllocator<T> {}
declare class TDWord extends TDTerminal {
  alloc<T extends TDWord>(): TDWordAllocator<T>;
  static word(): any;
}

class TDWordOrReservedStateAllocator<T extends TDWordOrReservedState> extends TDWordStateAllocator<T> {}
declare class TDWordOrReservedState extends TDWordState {
  alloc<T extends TDWordOrReservedState>(): TDWordOrReservedStateAllocator<T>;
  addReservedWord(s: NSString | string): void;
}

class TDWordStateAllocator<T extends TDWordState> extends TDTokenizerStateAllocator<T> {}
declare class TDWordState extends TDTokenizerState {
  alloc<T extends TDWordState>(): TDWordStateAllocator<T>;
  setWordChars_from_to(yn: boolean, start: NSInteger, end: NSInteger): void;
  isWordChar(c: NSInteger): boolean;
}

class ECCommandLineExampleCommandAllocator<T extends ECCommandLineExampleCommand> extends ECCommandLineCommandAllocator<T> {}
declare class ECCommandLineExampleCommand extends ECCommandLineCommand {
  alloc<T extends ECCommandLineExampleCommand>(): ECCommandLineExampleCommandAllocator<T>;
}

class ECCommandLineCommandAllocator<T extends ECCommandLineCommand> extends NSObjectAllocator<T> {}
declare class ECCommandLineCommand extends NSObject {
  alloc<T extends ECCommandLineCommand>(): ECCommandLineCommandAllocator<T>;
  static commandWithName_info_parentCommand(name: NSString | string, info: NSDictionary<any, any> | {[key: string]: any}, parentCommand: ECCommandLineCommand): ECCommandLineCommand;
  enumerateArguments(block: ArgumentBlock): void;
  engine_processCommands(engine: ECCommandLineEngine, commands: NSMutableArray<any> | any[]): ECCommandLineResult;
  engine_willProcessWithArguments(engine: ECCommandLineEngine, arguments: NSMutableArray<any> | any[]): ECCommandLineResult;
  engine_didProcessWithArguments(engine: ECCommandLineEngine, arguments: NSMutableArray<any> | any[]): ECCommandLineResult;
  help(): NSString;
  summaryAs_parentName(name: NSString | string, parentName: NSString | string): NSString;
  usageAs_parentName_engine(name: NSString | string, parentName: NSString | string, engine: ECCommandLineEngine): NSString;
  subcommandSummaryAs(name: NSString | string): NSString;
  resolveCommandPath(commands: NSMutableArray<any> | any[]): ECCommandLineCommand;

  name(): NSString;
  arguments(): NSArray<any>;
  parentCommand(): ECCommandLineCommand;
}

declare enum ECCommandLineArgumentMode {
  ECCommandLineArgumentModeNone,
  ECCommandLineArgumentModeRequired,
  ECCommandLineArgumentModeOptinal,
}

class ECCommandLineEngineAllocator<T extends ECCommandLineEngine> extends NSObjectAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class ECCommandLineEngine extends NSObject implements IECIODelegate {
  alloc<T extends ECCommandLineEngine>(): ECCommandLineEngineAllocator<T>;
  processArguments_argv(argc: number, argv: string): ECCommandLineResult;
  showUsage(): void;
  outputDescription(description: NSString | string): void;
  info(): NSDictionary<any, any>;
  commandWithName(name: NSString | string): ECCommandLineCommand;
  optionWithName(name: NSString | string): ECCommandLineOption;
  paddingLength(): NSUInteger;
  exitWithResult(result: ECCommandLineResult): void;
  static addCommandNamed_withInfo_toDictionary_parentCommand(mainName: NSString | string, info: NSDictionary<any, any> | {[key: string]: any}, dictionary: NSMutableDictionary<any, any> | {[key: string]: any}, parentCommand: ECCommandLineCommand): void;
  static commandsInDisplayOrder(commands: NSDictionary<any, any> | {[key: string]: any}): NSArray<any>;

  name(): NSString;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IECCommandLineEngineDelegate {
  engineDidFinishLaunching(engine: ECCommandLineEngine): void;
  engine_willProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
  engine_didProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
}

class ECCommandLineHelpCommandAllocator<T extends ECCommandLineHelpCommand> extends ECCommandLineCommandAllocator<T> {}
declare class ECCommandLineHelpCommand extends ECCommandLineCommand {
  alloc<T extends ECCommandLineHelpCommand>(): ECCommandLineHelpCommandAllocator<T>;
}

class ECCommandLineMissingClassCommandAllocator<T extends ECCommandLineMissingClassCommand> extends ECCommandLineCommandAllocator<T> {}
declare class ECCommandLineMissingClassCommand extends ECCommandLineCommand {
  alloc<T extends ECCommandLineMissingClassCommand>(): ECCommandLineMissingClassCommandAllocator<T>;
}

class ECCommandLineOptionAllocator<T extends ECCommandLineOption> extends NSObjectAllocator<T> {}
declare class ECCommandLineOption extends NSObject {
  alloc<T extends ECCommandLineOption>(): ECCommandLineOptionAllocator<T>;
  static optionWithName_info(name: NSString | string, info: NSDictionary<any, any> | {[key: string]: any}): ECCommandLineOption;
  mode(): ECCommandLineOptionMode;
  shortOption(): string;
  help(): NSString;
  longUsage(): NSString;
  shortUsage(): NSString;
  defaultValue(): any;

  name(): NSString;
  value(): any;
  setValue(value: any): void;
}

declare enum ECCommandLineOptionMode {
  ECCommandLineOptionModeNone,
  ECCommandLineOptionModeRequired,
  ECCommandLineOptionModeOptinal,
}

declare enum ECCommandLineResult {
  ECCommandLineResultOKButTerminate = -2,
  ECCommandLineResultStayRunning = -1,
  ECCommandLineResultOK = 0,
  ECCommandLineResultUnknownCommand,
  ECCommandLineResultMissingCommandClass,
  ECCommandLineResultNotImplemented,
  ECCommandLineResultMissingArguments,
  ECCommandLineResultImplementationReturnedError,
  ECCommandLineResultMissingBundle,
  ECCommandLineResultJSONConversionFailed,
  ECCommandLineResultJSONOutputFailed,
}

class BITCrashDetailsAllocator<T extends BITCrashDetails> extends NSObjectAllocator<T> {}
declare class BITCrashDetails extends NSObject {
  alloc<T extends BITCrashDetails>(): BITCrashDetailsAllocator<T>;

  incidentIdentifier(): NSString;
  reporterKey(): NSString;
  signal(): NSString;
  exceptionName(): NSString;
  exceptionReason(): NSString;
  appStartTime(): NSDate;
  crashTime(): NSDate;
  osVersion(): NSString;
  osBuild(): NSString;
  appVersion(): NSString;
  appBuild(): NSString;
  appProcessIdentifier(): NSUInteger;
}

class BITCrashExceptionApplicationAllocator<T extends BITCrashExceptionApplication> extends NSApplicationAllocator<T> {}
declare class BITCrashExceptionApplication extends NSApplication {
  alloc<T extends BITCrashExceptionApplication>(): BITCrashExceptionApplicationAllocator<T>;
}

class BITCrashManagerAllocator<T extends BITCrashManager> extends BITHockeyBaseManagerAllocator<T> {}
declare class BITCrashManager extends BITHockeyBaseManager {
  alloc<T extends BITCrashManager>(): BITCrashManagerAllocator<T>;
  setCrashCallbacks(callbacks: BITCrashManagerCallbacks): void;
  handleUserInput_withUserProvidedMetaData(userInput: BITCrashManagerUserInput, userProvidedMetaData: BITCrashMetaData): boolean;
  setCrashReportUIHandler(crashReportUIHandler: BITCustomCrashReportUIHandler): void;
  generateTestCrash(): void;

  askUserDetails(): boolean;
  setAskUserDetails(askUserDetails: boolean): void;
  disableMachExceptionHandler(): boolean;
  setDisableMachExceptionHandler(disableMachExceptionHandler: boolean): void;
  autoSubmitCrashReport(): boolean;
  setAutoSubmitCrashReport(autoSubmitCrashReport: boolean): void;
  didCrashInLastSession(): boolean;
  lastSessionCrashDetails(): BITCrashDetails;
  timeintervalCrashInLastSessionOccured(): NSTimeInterval;
}

declare type BITCrashManagerCallbacks = {
  context: void
  handleSignal: BITCrashManagerPostCrashSignalCallback
}

declare enum BITCrashManagerUserInput {
  BITCrashManagerUserInputDontSend = 0,
  BITCrashManagerUserInputSend = 1,
  BITCrashManagerUserInputAlwaysSend = 2,
}

declare interface IBITCrashManagerDelegate {
  crashManagerWillSendCrashReport(crashManager: BITCrashManager): void;
  crashManager_didFailWithError(crashManager: BITCrashManager, error: NSError): void;
  crashManagerDidFinishSendingCrashReport(crashManager: BITCrashManager): void;
}

class BITCrashMetaDataAllocator<T extends BITCrashMetaData> extends NSObjectAllocator<T> {}
declare class BITCrashMetaData extends NSObject {
  alloc<T extends BITCrashMetaData>(): BITCrashMetaDataAllocator<T>;

  userDescription(): NSString;
  setUserDescription(userDescription: NSString | string): void;
  userName(): NSString;
  setUserName(userName: NSString | string): void;
  userEmail(): NSString;
  setUserEmail(userEmail: NSString | string): void;
  userID(): NSString;
  setUserID(userID: NSString | string): void;
}

class BITFeedbackManagerAllocator<T extends BITFeedbackManager> extends BITHockeyBaseManagerAllocator<T> {}
declare class BITFeedbackManager extends BITHockeyBaseManager {
  alloc<T extends BITFeedbackManager>(): BITFeedbackManagerAllocator<T>;
  showFeedbackWindow(): void;

  requireUserName(): BITFeedbackUserDataElement;
  setRequireUserName(requireUserName: BITFeedbackUserDataElement): void;
  requireUserEmail(): BITFeedbackUserDataElement;
  setRequireUserEmail(requireUserEmail: BITFeedbackUserDataElement): void;
  showAlertOnIncomingMessages(): boolean;
  setShowAlertOnIncomingMessages(showAlertOnIncomingMessages: boolean): void;
}

declare enum BITFeedbackUserDataElement {
  BITFeedbackUserDataElementDontShow = 0,
  BITFeedbackUserDataElementOptional = 1,
  BITFeedbackUserDataElementRequired = 2,
}

class BITFeedbackWindowControllerAllocator<T extends BITFeedbackWindowController> extends NSWindowControllerAllocator<T> {
  initWithManager(feedbackManager: BITFeedbackManager): T;
}
declare class BITFeedbackWindowController extends NSWindowController {
  alloc<T extends BITFeedbackWindowController>(): BITFeedbackWindowControllerAllocator<T>;
}

class BITHockeyAttachmentAllocator<T extends BITHockeyAttachment> extends NSObjectAllocator<T> {
  initWithFilename_hockeyAttachmentData_contentType(filename: NSString | string, hockeyAttachmentData: NSData, contentType: NSString | string): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class BITHockeyAttachment extends NSObject implements INSCoding, INSCoding, INSCoding {
  alloc<T extends BITHockeyAttachment>(): BITHockeyAttachmentAllocator<T>;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  filename(): NSString;
  hockeyAttachmentData(): NSData;
  contentType(): NSString;
}

class BITHockeyBaseManagerAllocator<T extends BITHockeyBaseManager> extends NSObjectAllocator<T> {}
declare class BITHockeyBaseManager extends NSObject {
  alloc<T extends BITHockeyBaseManager>(): BITHockeyBaseManagerAllocator<T>;

  serverURL(): NSString;
  setServerURL(serverURL: NSString | string): void;
}

class BITHockeyManagerAllocator<T extends BITHockeyManager> extends NSObjectAllocator<T> {}
declare class BITHockeyManager extends NSObject {
  alloc<T extends BITHockeyManager>(): BITHockeyManagerAllocator<T>;
  static sharedHockeyManager(): BITHockeyManager;
  configureWithIdentifier(appIdentifier: NSString | string): void;
  configureWithIdentifier_delegate(appIdentifier: NSString | string, delegate: any): void;
  startManager(): void;
  setUserID(userID: NSString | string): void;
  setUserName(userName: NSString | string): void;
  setUserEmail(userEmail: NSString | string): void;
  setLogHandler(logHandler: BITLogHandler): void;
  testIdentifier(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  serverURL(): NSString;
  setServerURL(serverURL: NSString | string): void;
  crashManager(): BITCrashManager;
  disableCrashManager(): boolean;
  setDisableCrashManager(disableCrashManager: boolean): void;
  feedbackManager(): BITFeedbackManager;
  disableFeedbackManager(): boolean;
  setDisableFeedbackManager(disableFeedbackManager: boolean): void;
  metricsManager(): BITMetricsManager;
  disableMetricsManager(): boolean;
  setDisableMetricsManager(disableMetricsManager: boolean): void;
  logLevel(): BITLogLevel;
  setLogLevel(logLevel: BITLogLevel): void;
}

declare interface IBITHockeyManagerDelegate {
  userIDForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userNameForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userEmailForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
}

class BITMetricsManagerAllocator<T extends BITMetricsManager> extends BITHockeyBaseManagerAllocator<T> {}
declare class BITMetricsManager extends BITHockeyBaseManager {
  alloc<T extends BITMetricsManager>(): BITMetricsManagerAllocator<T>;
  trackEventWithName(eventName: NSString | string): void;
  trackEventWithName_properties_measurements(eventName: NSString | string, properties: NSDictionary<any, any> | {[key: string]: any} | null, measurements: NSDictionary<any, any> | {[key: string]: any} | null): void;

  disabled(): boolean;
  setDisabled(disabled: boolean): void;
}

class BITSystemProfileAllocator<T extends BITSystemProfile> extends NSObjectAllocator<T> {}
declare class BITSystemProfile extends NSObject {
  alloc<T extends BITSystemProfile>(): BITSystemProfileAllocator<T>;
  static sharedSystemProfile(): BITSystemProfile;
  static deviceIdentifier(): NSString;
  static deviceModel(): NSString;
  static systemVersionString(): NSString;
  systemDataForBundle(bundle: NSBundle): NSMutableArray<any>;
  systemData(): NSMutableArray<any>;
  systemUsageDataForBundle(bundle: NSBundle): NSMutableArray<any>;
  systemUsageData(): NSMutableArray<any>;
  startUsageForBundle(bundle: NSBundle): void;
  startUsage(): void;
  stopUsage(): void;
}

declare enum BITCrashErrorReason {
  BITCrashErrorUnknown,
  BITCrashAPIAppVersionRejected,
  BITCrashAPIReceivedEmptyResponse,
  BITCrashAPIErrorWithStatusCode,
}

declare enum BITFeedbackErrorReason {
  BITFeedbackErrorUnknown,
  BITFeedbackAPIServerReturnedInvalidStatus,
  BITFeedbackAPIServerReturnedInvalidData,
  BITFeedbackAPIServerReturnedEmptyResponse,
  BITFeedbackAPIClientAuthorizationMissingSecret,
  BITFeedbackAPIClientCannotCreateConnection,
}

declare enum BITHockeyErrorReason {
  BITHockeyErrorUnknown,
}

declare enum BITLogLevel {
  BITLogLevelNone = 0,
  BITLogLevelError = 1,
  BITLogLevelWarning = 2,
  BITLogLevelDebug = 3,
  BITLogLevelVerbose = 4,
}

class BCCodeSigningVerifierAllocator<T extends BCCodeSigningVerifier> extends NSObjectAllocator<T> {}
declare class BCCodeSigningVerifier extends NSObject {
  alloc<T extends BCCodeSigningVerifier>(): BCCodeSigningVerifierAllocator<T>;
}

class BCDeviceAllocator<T extends BCDevice> extends NSObjectAllocator<T> {}
declare class BCDevice extends NSObject {
  alloc<T extends BCDevice>(): BCDeviceAllocator<T>;
}

class BCLicenseAllocator<T extends BCLicense> extends NSObjectAllocator<T> {}
declare class BCLicense extends NSObject {
  alloc<T extends BCLicense>(): BCLicenseAllocator<T>;

  applicationID(): NSString;
  setApplicationID(applicationID: NSString | string): void;
}

declare enum BCLicenseType {
  BCLicenseUnknown = -1,
  BCLicenseTrial = 0,
  BCLicenseTrialExpired = 1,
  BCLicensePurchased = 2,
}

class BCLicenseManagerAllocator<T extends BCLicenseManager> extends NSObjectAllocator<T> {}
declare class BCLicenseManager extends NSObject {
  alloc<T extends BCLicenseManager>(): BCLicenseManagerAllocator<T>;
  canRenewLicense(): boolean;

  canUseCloud(): boolean;
}

declare enum BCReceiptRegistrationResult {
  BCReceiptRegistrationOK,
  BCReceiptRegistrationLicenseInvalid,
  BCReceiptRegistrationLicenseNoFreeSlot,
  BCReceiptRegistrationVersionNotSupported,
  BCReceiptRegistrationNetworkError,
  BCReceiptRegistrationFailedToSave,
}

declare enum BCLicenseManagerLicenseResult {
  BCLicenseManagerLicenseOk,
  BCLicenseManagerLicenseExpiringSoon,
  BCLicenseManagerLicenseVersionNotSupported,
  BCLicenseManagerTrialExpired,
  BCLicenseManagerLicenseExpired,
  BCLicenseManagerLicenseVariantNotAllowed,
  BCLicenseManagerLicenseError,
}

class BCNetworkTimeAllocator<T extends BCNetworkTime> extends NSObjectAllocator<T> {}
declare class BCNetworkTime extends NSObject {
  alloc<T extends BCNetworkTime>(): BCNetworkTimeAllocator<T>;
  static requestTimeFromHost_timeout_completionBlock(host: NSString | string, timeout: NSUInteger, completion: MSNetworkTimeCompletionBlock): void;
}

class BCRSASHA1VerifyAllocator<T extends BCRSASHA1Verify> extends NSObjectAllocator<T> {}
declare class BCRSASHA1Verify extends NSObject {
  alloc<T extends BCRSASHA1Verify>(): BCRSASHA1VerifyAllocator<T>;

  error(): NSError;
  setError(error: NSError): void;
  verified(): boolean;
  setVerified(verified: boolean): void;
}

declare type ASN1_Data = {
  length: size_t
  data: string
}

declare enum BCReceiptStatus {
  BCReceiptStatusNotChecked,
  BCReceiptStatusVerified,
  BCReceiptStatusInvalidBundleID,
  BCReceiptStatusInvalidBundleVersion,
  BCReceiptStatusFailedToCreateStaticCode,
  BCReceiptStatusFailedToCreateRequirement,
  BCReceiptStatusInvalidSignature,
  BCReceiptStatusMissingReceipt,
  BCReceiptStatusFailedToCreateDecoder,
  BCReceiptStatusFailedToUpdateMessage,
  BCReceiptStatusFailedToFinalizeMessage,
  BCReceiptStatusFailedToDecrypt,
  BCReceiptStatusFailedToGetSignerCount,
  BCReceiptStatusNoSignerFound,
  BCReceiptStatusFailedToGetSignerStatus,
  BCReceiptStatusNoValidSigner,
  BCReceiptStatusFailedToCreateASN1Decoder,
  BCReceiptStatusFailedToDecodePayload,
  BCReceiptStatusInvalidReceiptID,
  BCReceiptStatusInvalidReceiptVersion,
  BCReceiptStatusFailedToGetMACAddress,
  BCReceiptStatusBadReceiptHash,
  BCReceiptStatusFailedToDecodeInteger,
  BCReceiptStatusFailedToDecodeString,
  BCReceiptStatusFailedToDecodeDate,
  BCReceiptStatusFailedQuickValidation,
  BCReceiptStatusUnexpectedError,
}

class BCReceiptValidationContextAllocator<T extends BCReceiptValidationContext> extends NSObjectAllocator<T> {}
declare class BCReceiptValidationContext extends NSObject {
  alloc<T extends BCReceiptValidationContext>(): BCReceiptValidationContextAllocator<T>;
}

class BCReceiptValidationContextWithInfoAllocator<T extends BCReceiptValidationContextWithInfo> extends BCReceiptValidationContextAllocator<T> {
  initWithBundleID_minimumVersion(bundleID: NSString | string, minimumVersion: NSString | string): T;
}
declare class BCReceiptValidationContextWithInfo extends BCReceiptValidationContext {
  alloc<T extends BCReceiptValidationContextWithInfo>(): BCReceiptValidationContextWithInfoAllocator<T>;

  expectedBundleID(): NSString;
  setExpectedBundleID(expectedBundleID: NSString | string): void;
  minimumVersion(): NSString;
  setMinimumVersion(minimumVersion: NSString | string): void;
}

class BCReceiptValidationExceptionAllocator<T extends BCReceiptValidationException> extends NSExceptionAllocator<T> {}
declare class BCReceiptValidationException extends NSException {
  alloc<T extends BCReceiptValidationException>(): BCReceiptValidationExceptionAllocator<T>;
  static exceptionWithStatus(status: BCReceiptStatus): BCReceiptValidationException;
  static raiseWithStatus(status: BCReceiptStatus): void;
  static raiseWithStatus_error(status: BCReceiptStatus, error: OSStatus): void;

  status(): BCReceiptStatus;
}

class MSLicenseExpiredActionAllocator<T extends MSLicenseExpiredAction> extends MSDocumentActionAllocator<T> {}
declare class MSLicenseExpiredAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSLicenseExpiredAction>(): MSLicenseExpiredActionAllocator<T>;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSLicenseSheetActionAllocator<T extends MSLicenseSheetAction> extends MSDocumentActionAllocator<T> {}
declare class MSLicenseSheetAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSLicenseSheetAction>(): MSLicenseSheetActionAllocator<T>;
  runLicenseDialog(sender: any): IBAction;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

declare interface ISCKAPIAuthentication {
  consumeAccessToken(): NSString;

  authToken(): NSString;
  accessToken(): NSString;
}

class SCKAPIEnvironmentAllocator<T extends SCKAPIEnvironment> extends NSObjectAllocator<T> {
  initWithHost(host: NSString | string | null): T;
  initWithName(name: NSString | string | null): T;
  initWithDefinition(definition: SCKAPIEnvironmentDefinition): T;
}
declare class SCKAPIEnvironment extends NSObject implements INSCopying {
  alloc<T extends SCKAPIEnvironment>(): SCKAPIEnvironmentAllocator<T>;
  accountSettingsURLForUserID(userID: SCKObjectID | null): NSURL;
  settingsURLForShare(share: SCKShare | null): NSURL;
  sharesOverviewURLForUserID(userID: SCKObjectID | null): NSURL;
  signInURLUsingCallback_variant(usingCallback: boolean, variant: NSString | string | null): NSURL;
  signUpURLUsingCallback_variant(usingCallback: boolean, variant: NSString | string | null): NSURL;
  static current(): SCKAPIEnvironment;
  setCurrent(): void;
  setKeychainUser_error(keychainUser: SCKAuthenticatedUser | null, error: NSError): boolean;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  definition(): SCKAPIEnvironmentDefinition;
  host(): NSString;
  name(): NSString;
  displayName(): NSString;
  keychainUser(): SCKAuthenticatedUser;
  signature(): NSString;
  suffixRepresentation(): NSString;
}

declare enum SCKAPIEnvironmentDefinition {
  SCKAPIEnvironmentDefinitionCustom,
  SCKAPIEnvironmentDefinitionProduction,
  SCKAPIEnvironmentDefinitionStaging,
  SCKAPIEnvironmentDefinitionTest,
  SCKAPIEnvironmentDefinitionDevelopment,
}

class SCKAPIOperationAllocator<T extends SCKAPIOperation> extends SCKURLOperationAllocator<T> {
  initWithRequest(request: SCKAPIRequest): T;
}
declare class SCKAPIOperation extends SCKURLOperation {
  alloc<T extends SCKAPIOperation>(): SCKAPIOperationAllocator<T>;
  processData_response_error(data: NSData | null, response: NSHTTPURLResponse | null, error: NSError | null): void;
  static executeRequest_completionHandler(request: SCKAPIRequest, handler: Block): void;

  request(): SCKAPIRequest;
  error(): NSError;
  result(): NSArray<any>;
}

class SCKAPIProtocolAllocator<T extends SCKAPIProtocol> extends NSURLProtocolAllocator<T> {}
declare class SCKAPIProtocol extends NSURLProtocol {
  alloc<T extends SCKAPIProtocol>(): SCKAPIProtocolAllocator<T>;
}

class SCKAPIRequestAllocator<T extends SCKAPIRequest> extends NSMutableURLRequestAllocator<T> {}
declare class SCKAPIRequest extends NSMutableURLRequest {
  alloc<T extends SCKAPIRequest>(): SCKAPIRequestAllocator<T>;
  static baseURLForEnvironment(environment: SCKAPIEnvironment): NSURL;
  static requestWithPath_queryItems_environment(path: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any} | null, environment: SCKAPIEnvironment): SCKAPIRequest;
  static requestWithPath_environment(path: NSString | string, environment: SCKAPIEnvironment): SCKAPIRequest;
  static requestWithPath(path: NSString | string): SCKAPIRequest;

  environment(): SCKAPIEnvironment;
  setEnvironment(environment: SCKAPIEnvironment): void;
  authentication(): any;
  setAuthentication(authentication: any): void;
  body(): any;
  setBody(body: any): void;
  expectedObjectType(): any;
  setExpectedObjectType(expectedObjectType: any): void;
  applicationVersion(): NSString;
  setApplicationVersion(applicationVersion: NSString | string): void;
  applicationBuild(): NSString;
  setApplicationBuild(applicationBuild: NSString | string): void;
  type(): SCKAPIRequestType;
  setType(type: SCKAPIRequestType): void;
}

declare enum SCKAPIRequestType {
  SCKAPIRequestTypeGet,
  SCKAPIRequestTypeCreate,
  SCKAPIRequestTypeUpdate,
  SCKAPIRequestTypeDelete,
}

declare interface ISCKAPISignable {

  signableString(): NSString;
}

class SCKAuthAPIRequestAllocator<T extends SCKAuthAPIRequest> extends SCKAPIRequestAllocator<T> {}
declare class SCKAuthAPIRequest extends SCKAPIRequest {
  alloc<T extends SCKAuthAPIRequest>(): SCKAuthAPIRequestAllocator<T>;
  static loginRequestWithAccessToken(accessToken: NSString | string): SCKAuthAPIRequest;
  static loginRequestWithEmail_password(email: NSString | string, password: NSString | string): SCKAuthAPIRequest;
  static profileRequest(): SCKAuthAPIRequest;
  static forgotPasswordRequestWithEmail(email: NSString | string): SCKAuthAPIRequest;
}

class SCKDownloadOperationAllocator<T extends SCKDownloadOperation> extends SCKURLOperationAllocator<T> {
  initWithRequest(request: NSURLRequest): T;
}
declare class SCKDownloadOperation extends SCKURLOperation implements INSURLSessionDownloadDelegate {
  alloc<T extends SCKDownloadOperation>(): SCKDownloadOperationAllocator<T>;
  static operationByRequesting_completionHandler(request: NSURLRequest, block: SCKDownloadOperationHandler): SCKDownloadOperation;
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;

  request(): NSURLRequest;
  downloadCompletionBlock(): SCKDownloadOperationHandler;
  setDownloadCompletionBlock(downloadCompletionBlock: SCKDownloadOperationHandler): void;
  progress(): NSProgress;
  error(): NSError;
}

class SCKDownloadOperationSessionDelegateAllocator<T extends SCKDownloadOperationSessionDelegate> extends NSObjectAllocator<T> {}
declare class SCKDownloadOperationSessionDelegate extends NSObject implements INSURLSessionDownloadDelegate {
  alloc<T extends SCKDownloadOperationSessionDelegate>(): SCKDownloadOperationSessionDelegateAllocator<T>;
  setDownloadTaskDelegate_forTask(delegate: any, task: NSURLSessionTask): void;
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
  URLSession_downloadTask_didFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
  URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
}

class SCKOperationAllocator<T extends SCKOperation> extends NSOperationAllocator<T> {}
declare class SCKOperation extends NSOperation {
  alloc<T extends SCKOperation>(): SCKOperationAllocator<T>;

  finished(): boolean;
  setFinished(finished: boolean): void;
  executing(): boolean;
  setExecuting(executing: boolean): void;
  cancelled(): boolean;
  setCancelled(cancelled: boolean): void;
}

class SCKShareAPIRequestAllocator<T extends SCKShareAPIRequest> extends SCKAPIRequestAllocator<T> {}
declare class SCKShareAPIRequest extends SCKAPIRequest {
  alloc<T extends SCKShareAPIRequest>(): SCKShareAPIRequestAllocator<T>;
  static shareRequestWithID(shareID: SCKObjectID): SCKShareAPIRequest;
  static shareRequestWithShortID(shortID: NSString | string): SCKShareAPIRequest;
  static shareLibraryAppcastRequestWithShortID(shortID: NSString | string): SCKShareAPIRequest;
  static userSharesListRequest(): SCKShareAPIRequest;
  static shareCreationRequestWithManifest(manifest: NSDictionary<any, any> | {[key: string]: any}): SCKShareAPIRequest;
  static shareUpdateRequestWithManifest_existingShare(manifest: NSDictionary<any, any> | {[key: string]: any}, share: SCKShare): SCKShareAPIRequest;
  static shareDeletionRequestWithID(shareID: SCKObjectID): SCKShareAPIRequest;
  static shareCancelUpdateRequestWithID(shareID: SCKObjectID): SCKShareAPIRequest;
}

class SCKShareItemUploadOperationAllocator<T extends SCKShareItemUploadOperation> extends SCKOperationAllocator<T> {}
declare class SCKShareItemUploadOperation extends SCKOperation implements INSURLSessionTaskDelegate, INSProgressReporting {
  alloc<T extends SCKShareItemUploadOperation>(): SCKShareItemUploadOperationAllocator<T>;
  static itemUploadOperationWithItem_fromURL(item: SCKFileUploadSpecs, url: NSURL): SCKShareItemUploadOperation;
  static itemUploadOperationWithDocumentUploadURL_fromURL(url: NSURL, localURL: NSURL): SCKShareItemUploadOperation;
  static fileSizeOfItemAtURL(url: NSURL): NSUInteger;
  static fileSizeOfItemAtURL_multipartIndex_maxChunkSize(url: NSURL, part: NSUInteger, maxSize: NSUInteger): NSUInteger;
  URLSession_task_willBeginDelayedRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: Block): void;
  URLSession_taskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;
  URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: Block): void;
  URLSession_task_didReceiveChallenge_completionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSession_task_needNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: Block): void;
  URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  URLSession_task_didFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;
  URLSession_task_didCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;
  URLSession_task_willBeginDelayedRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: Block): void;
  URLSession_taskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;
  URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: Block): void;
  URLSession_task_didReceiveChallenge_completionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: Block): void;
  URLSession_task_needNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: Block): void;
  URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  URLSession_task_didFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;
  URLSession_task_didCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;

  urlSession(): NSURLSession;
  setUrlSession(urlSession: NSURLSession): void;
  taskIdentifier(): NSUInteger;
  sourceURL(): NSURL;
  multipartIndex(): NSUInteger;
  setMultipartIndex(multipartIndex: NSUInteger): void;
  documentMultipartSpecs(): SCKDocumentUploadMultipartSpecs;
  setDocumentMultipartSpecs(documentMultipartSpecs: SCKDocumentUploadMultipartSpecs): void;
  item(): SCKFileUploadSpecs;
  progress(): NSProgress;
  additionalRetryAttempts(): NSUInteger;
  setAdditionalRetryAttempts(additionalRetryAttempts: NSUInteger): void;
  error(): NSError;
}

class SCKShareUploadOperationAllocator<T extends SCKShareUploadOperation> extends SCKOperationAllocator<T> {
  initWithRequest(request: SCKShareAPIRequest): T;
}
declare class SCKShareUploadOperation extends SCKOperation implements INSProgressReporting {
  alloc<T extends SCKShareUploadOperation>(): SCKShareUploadOperationAllocator<T>;

  dataSource(): any;
  setDataSource(dataSource: any): void;
  progress(): NSProgress;
  share(): SCKShare;
  errors(): NSArray<any>;
}

declare interface ISCKShareUploadDataSource {
  shareUploadOperation_fileURLForItemWithHash(operation: SCKShareUploadOperation, hash: NSString | string): NSURL;
  shareUploadOperation_willStartUploadingShare(operation: SCKShareUploadOperation, share: SCKShare): void;
  shareUploadOperation_exportDocumentWithHandler(operation: SCKShareUploadOperation, handler: Block): void;
}

class SCKURLOperationAllocator<T extends SCKURLOperation> extends SCKOperationAllocator<T> {}
declare class SCKURLOperation extends SCKOperation {
  alloc<T extends SCKURLOperation>(): SCKURLOperationAllocator<T>;
  static sharedURLSession(): NSURLSession;

  session(): NSURLSession;
  setSession(session: NSURLSession): void;
}

class SCKArtboardDiffAllocator<T extends SCKArtboardDiff> extends NSObjectAllocator<T> {
  initWithObject_comparedTo(object: SCKArtboard, otherObject: SCKArtboard): T;
}
declare class SCKArtboardDiff extends NSObject implements ISCKDiff {
  alloc<T extends SCKArtboardDiff>(): SCKArtboardDiffAllocator<T>;

  object(): SCKArtboard;
  comparedObject(): SCKArtboard;
  attributes(): SCKArtboardAttributes;
}

class SCKArtboardAllocator<T extends SCKArtboard> extends SCKObjectAllocator<T> {}
declare class SCKArtboard extends SCKObject {
  alloc<T extends SCKArtboard>(): SCKArtboardAllocator<T>;
  diffComparedTo(object: SCKArtboard): SCKArtboardDiff;

  page(): SCKPage;
  name(): NSString;
  slug(): NSString;
  order(): NSUInteger;
  unread(): NSUInteger;
  size(): CGSize;
  viewport(): SCKArtboardViewport;
  files(): NSArray<any>;
  possibleFileTypes(): SCKFileImageType;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  isFlowHome(): boolean;
  setIsFlowHome(isFlowHome: boolean): void;
}

class SCKCloudDocumentDiffAllocator<T extends SCKCloudDocumentDiff> extends SCKDocumentDiffAllocator<T> {}
declare class SCKCloudDocumentDiff extends SCKDocumentDiff {
  alloc<T extends SCKCloudDocumentDiff>(): SCKCloudDocumentDiffAllocator<T>;
}

class SCKCloudDocumentAllocator<T extends SCKCloudDocument> extends SCKDocumentAllocator<T> {}
declare class SCKCloudDocument extends SCKDocument {
  alloc<T extends SCKCloudDocument>(): SCKCloudDocumentAllocator<T>;
  // @ts-ignore
  diffComparedTo(object: SCKCloudDocument): SCKCloudDocumentDiff;

  slug(): NSString;
  downloadURL(): NSURL;
  isProcessing(): boolean;
  metaImageURL(): NSURL;
}

class SCKCollectionDiffAllocator<T extends SCKCollectionDiff> extends NSObjectAllocator<T> {
  initWithObject_comparedTo(object: NSArray<any> | any[], otherObject: NSArray<any> | any[]): T;
  initWithCollectionDiffSet(diffSet: NSSet<any>): T;
}
declare class SCKCollectionDiff extends NSObject implements ISCKDiff {
  alloc<T extends SCKCollectionDiff>(): SCKCollectionDiffAllocator<T>;

  object(): NSArray<any>;
  comparedObject(): NSArray<any>;
  insertions(): NSSet<any>;
  updateDiffs(): NSSet<any>;
  deletions(): NSSet<any>;
}

declare interface ISCKDiffable {
  diffComparedTo(object: SCKObject): any;
}

class SCKDocumentDiffAllocator<T extends SCKDocumentDiff> extends NSObjectAllocator<T> {
  initWithObject_comparedTo(object: SCKDocument, otherObject: SCKDocument): T;
}
declare class SCKDocumentDiff extends NSObject implements ISCKDiff {
  alloc<T extends SCKDocumentDiff>(): SCKDocumentDiffAllocator<T>;

  object(): SCKDocument;
  comparedObject(): SCKDocument;
  attributes(): SCKDocumentAttributes;
  pageDiff(): SCKCollectionDiff;
  artboardsDiff(): SCKCollectionDiff;
}

class SCKDocumentAllocator<T extends SCKDocument> extends SCKObjectAllocator<T> {}
declare class SCKDocument extends SCKObject {
  alloc<T extends SCKDocument>(): SCKDocumentAllocator<T>;
  diffComparedTo(object: SCKDocument): SCKDocumentDiff;

  name(): NSString;
  pages(): NSArray<any>;
  colorSpace(): SCKColorSpace;
}

class SCKFlowConnectionDiffAllocator<T extends SCKFlowConnectionDiff> extends NSObjectAllocator<T> {
  initWithObject_comparedTo(object: SCKFlowConnection, otherObject: SCKFlowConnection): T;
}
declare class SCKFlowConnectionDiff extends NSObject implements ISCKDiff {
  alloc<T extends SCKFlowConnectionDiff>(): SCKFlowConnectionDiffAllocator<T>;

  object(): SCKFlowConnection;
  comparedObject(): SCKFlowConnection;
  attributes(): SCKFlowConnectionAttributes;
}

class SCKFlowConnectionAllocator<T extends SCKFlowConnection> extends SCKObjectAllocator<T> {}
declare class SCKFlowConnection extends SCKObject {
  alloc<T extends SCKFlowConnection>(): SCKFlowConnectionAllocator<T>;
  diffComparedTo(object: SCKFlowConnection): SCKFlowConnectionDiff;

  isBackAction(): boolean;
  destinationArtboardID(): SCKObjectID;
  animationType(): NSString;
  layer(): SCKLayer;
}

class SCKLayerDiffAllocator<T extends SCKLayerDiff> extends NSObjectAllocator<T> {
  initWithObject_comparedTo(object: SCKLayer, otherObject: SCKLayer): T;
}
declare class SCKLayerDiff extends NSObject implements ISCKDiff {
  alloc<T extends SCKLayerDiff>(): SCKLayerDiffAllocator<T>;

  object(): SCKLayer;
  comparedObject(): SCKLayer;
  attributes(): SCKLayerAttributes;
}

class SCKLayerAllocator<T extends SCKLayer> extends SCKObjectAllocator<T> {}
declare class SCKLayer extends SCKObject {
  alloc<T extends SCKLayer>(): SCKLayerAllocator<T>;
  diffComparedTo(object: SCKLayer): SCKLayerDiff;

  name(): NSString;
  boundingRect(): CGRect;
  flowConnection(): SCKFlowConnection;
  artboard(): SCKArtboard;
  isFixedToViewport(): boolean;
}

class SCKPageDiffAllocator<T extends SCKPageDiff> extends NSObjectAllocator<T> {
  initWithObject_comparedTo(object: SCKPage, otherObject: SCKPage): T;
}
declare class SCKPageDiff extends NSObject implements ISCKDiff {
  alloc<T extends SCKPageDiff>(): SCKPageDiffAllocator<T>;

  object(): SCKPage;
  comparedObject(): SCKPage;
  attributes(): SCKPageAttributes;
  artboardsDiff(): SCKCollectionDiff;
}

class SCKPageAllocator<T extends SCKPage> extends SCKObjectAllocator<T> {}
declare class SCKPage extends SCKObject {
  alloc<T extends SCKPage>(): SCKPageAllocator<T>;
  diffComparedTo(object: SCKPage): SCKPageDiff;

  document(): SCKDocument;
  name(): NSString;
  slug(): NSString;
  order(): NSUInteger;
  artboards(): NSArray<any>;
}

declare type SCKArtboardViewport = {
  scale: CGFloat
  size: CGSize
}

declare enum SCKArtboardAttributes {
  SCKArtboardNoAttribute = 0,
  SCKArtboardNameAttribute = 1 << 0,
  SCKArtboardSlugAttribute = 1 << 1,
  SCKArtboardOrderAttribute = 1 << 2,
  SCKArtboardUnreadAttribute = 1 << 3,
  SCKArtboardSizeAttribute = 1 << 4,
  SCKArtboardFilesAttribute = 1 << 5,
  SCKArtboardLayersAttribute = 1 << 6,
  SCKArtboardIsFlowHomeAttribute = 1 << 7,
  SCKArtboardViewportAttribute = 1 << 8,
  SCKArtboardPossibleFileTypesAttribute = 1 << 9,
}

class SCKAuthenticatedUserAllocator<T extends SCKAuthenticatedUser> extends SCKUserAllocator<T> {
  initWithObjectID_authToken(objectID: SCKObjectID, authToken: NSString | string | null): T;
}
declare class SCKAuthenticatedUser extends SCKUser implements ISCKAPIAuthentication {
  alloc<T extends SCKAuthenticatedUser>(): SCKAuthenticatedUserAllocator<T>;
  static current(): SCKAuthenticatedUser;
  static logoutWithError(error: NSError): boolean;
  static logout(): boolean;
  loginWithError(error: NSError): boolean;
  login(): boolean;
  loginToEnvironment_error(environment: SCKAPIEnvironment, error: NSError): boolean;
  loginToEnvironment(environment: SCKAPIEnvironment): boolean;
  consumeAccessToken(): NSString;
  consumeAccessToken(): NSString;

  authToken(): NSString;
  accessToken(): NSString;
}

class SCKAvatarAllocator<T extends SCKAvatar> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SCKAvatar extends NSObject {
  alloc<T extends SCKAvatar>(): SCKAvatarAllocator<T>;

  dictionaryRepresentation(): NSDictionary<any, any>;
  type(): SCKAvatarType;
  url(): NSURL;
  largeURL(): NSURL;
}

declare enum SCKAvatarType {
  SCKAvatarTypeRandom = 0,
  SCKAvatarTypeUserDefined,
}

declare enum SCKColorSpace {
  SCKColorSpaceUnmanaged = 0,
  SCKColorSpaceSRGB = 1,
  SCKColorSpaceDisplayP3 = 2,
}

declare enum SCKDocumentAttributes {
  SCKDocumentNoAttribute = 0,
  SCKDocumentNameAttribute = 1 << 0,
  SCKDocumentSlugAttribute = 1 << 1,
  SCKDocumentDownloadURLAttribute = 1 << 2,
  SCKDocumentProcessingAttribute = 1 << 3,
  SCKDocumentMetaImageURLAttribute = 1 << 4,
  SCKDocumentPagesAttribute = 1 << 5,
  SCKDocumentColorSpaceAttribute = 1 << 6,
}

class SCKDocumentUploadMultipartSpecsAllocator<T extends SCKDocumentUploadMultipartSpecs> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SCKDocumentUploadMultipartSpecs extends NSObject {
  alloc<T extends SCKDocumentUploadMultipartSpecs>(): SCKDocumentUploadMultipartSpecsAllocator<T>;
  uploadRequestCompletionBodyWithSize(size: NSUInteger): NSDictionary<any, any>;

  uploadID(): NSString;
  uploadKey(): NSString;
  partSize(): NSUInteger;
  uploadURLs(): NSArray<any>;
}

class SCKFileAllocator<T extends SCKFile> extends SCKObjectAllocator<T> {}
declare class SCKFile extends SCKObject {
  alloc<T extends SCKFile>(): SCKFileAllocator<T>;

  dimensions(): CGSize;
  fileSize(): NSUInteger;
  scale(): CGFloat;
  thumbnails(): NSArray<any>;
  url(): NSURL;
  type(): SCKFileImageType;
}

declare enum SCKFileImageType {
  SCKFileImageTypeFull = 0,
  SCKFileImageTypeScrollable = 1 << 0,
  SCKFileImageTypeFixed = 1 << 1,
}

class SCKFileUploadSpecsAllocator<T extends SCKFileUploadSpecs> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any} | null): T;
}
declare class SCKFileUploadSpecs extends NSObject {
  alloc<T extends SCKFileUploadSpecs>(): SCKFileUploadSpecsAllocator<T>;

  fileHash(): NSString;
  uploadURL(): NSURL;
}

declare enum SCKFlowConnectionAttributes {
  SCKFlowConnectionNoAttribute = 0,
  SCKFlowConnectionBackActionAttribute = 1 << 0,
  SCKFlowConnectionDestinationArtboardIDAttribute = 1 << 1,
  SCKFlowConnectionAnimationTypeAttribute = 1 << 2,
}

declare enum SCKLayerAttributes {
  SCKLayerNoAttribute = 0,
  SCKLayerNameAttribute = 1 << 0,
  SCKLayerBoundingRectAttribute = 1 << 1,
  SCKLayerFlowConnectionAttribute = 1 << 2,
  SCKLayerFixedToViewportAttribute = 1 << 3,
}

class SCKObjectAllocator<T extends SCKObject> extends NSObjectAllocator<T> {
  initWithData_error(data: NSData | null, error: NSError): T;
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithDictionary_parentObject(dictionary: NSDictionary<any, any> | {[key: string]: any}, parent: SCKObject | null): T;
  initWithObjectID(objectID: SCKObjectID): T;
}
declare class SCKObject extends NSObject implements INSSecureCoding {
  alloc<T extends SCKObject>(): SCKObjectAllocator<T>;

  parent(): SCKObject;
  objectID(): SCKObjectID;
  creationDate(): NSDate;
  updateDate(): NSDate;
  deletionDate(): NSDate;
  dictionaryRepresentation(): NSDictionary<any, any>;
  localizedUpdatedTimeComponentsString(): NSString;
  static supportsSecureCoding(): boolean;
}

declare type SCKObjectID = NSString

declare enum SCKPageAttributes {
  SCKPageNoAttribute = 0,
  SCKPageNameAttribute = 1 << 0,
  SCKPageSlugAttribute = 1 << 1,
  SCKPageOrderAttribute = 1 << 2,
  SCKPageArtboardsAttribute = 1 << 3,
}

class SCKShareAllocator<T extends SCKShare> extends SCKObjectAllocator<T> {}
declare class SCKShare extends SCKObject {
  alloc<T extends SCKShare>(): SCKShareAllocator<T>;

  shortID(): NSString;
  publicURL(): NSURL;
  isPrivate(): boolean;
  userID(): SCKObjectID;
  commentsEnabled(): boolean;
  currentVersion(): SCKShareVersion;
}

class SCKShareUploadSpecsAllocator<T extends SCKShareUploadSpecs> extends SCKShareAllocator<T> {}
declare class SCKShareUploadSpecs extends SCKShare {
  alloc<T extends SCKShareUploadSpecs>(): SCKShareUploadSpecsAllocator<T>;

  cloudDocumentID(): NSString;
  fileUploadSpecs(): NSArray<any>;
}

class SCKShareVersionAllocator<T extends SCKShareVersion> extends SCKObjectAllocator<T> {}
declare class SCKShareVersion extends SCKObject {
  alloc<T extends SCKShareVersion>(): SCKShareVersionAllocator<T>;

  number(): NSUInteger;
  message(): NSString;
  document(): SCKCloudDocument;
}

class SCKThumbnailAllocator<T extends SCKThumbnail> extends SCKObjectAllocator<T> {}
declare class SCKThumbnail extends SCKObject {
  alloc<T extends SCKThumbnail>(): SCKThumbnailAllocator<T>;

  URL(): NSURL;
  dimensions(): CGSize;
  fileSize(): NSUInteger;
}

class SCKUserAllocator<T extends SCKUser> extends SCKObjectAllocator<T> {}
declare class SCKUser extends SCKObject {
  alloc<T extends SCKUser>(): SCKUserAllocator<T>;

  name(): NSString;
  email(): NSString;
  changedEmail(): NSString;
  isAdmin(): boolean;
  avatar(): SCKAvatar;
}

class SCKTestAuthenticationAllocator<T extends SCKTestAuthentication> extends NSObjectAllocator<T> {}
declare class SCKTestAuthentication extends NSObject implements ISCKAPIAuthentication {
  alloc<T extends SCKTestAuthentication>(): SCKTestAuthenticationAllocator<T>;
  consumeAccessToken(): NSString;
  consumeAccessToken(): NSString;

  accessToken(): NSString;
  authToken(): NSString;
  environment(): SCKAPIEnvironment;
}

class AFAmazonS3ManagerAllocator<T extends AFAmazonS3Manager> extends AFHTTPRequestOperationManagerAllocator<T> {
  initWithAccessKeyID_secret(accessKey: NSString | string, secret: NSString | string): T;
}
declare class AFAmazonS3Manager extends AFHTTPRequestOperationManager implements INSSecureCoding, INSCopying {
  alloc<T extends AFAmazonS3Manager>(): AFAmazonS3ManagerAllocator<T>;
  enqueueS3RequestOperationWithMethod_path_parameters_success_failure(method: NSString | string, path: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, success: Block, failure: Block): AFHTTPRequestOperation;
  getServiceWithSuccess_failure(success: Block, failure: Block): AFHTTPRequestOperation;
  getBucket_success_failure(bucket: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  putBucket_parameters_success_failure(bucket: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, success: Block, failure: Block): AFHTTPRequestOperation;
  deleteBucket_success_failure(bucket: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  headObjectWithPath_success_failure(path: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  getObjectWithPath_progress_success_failure(path: NSString | string, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  getObjectWithPath_outputStream_progress_success_failure(path: NSString | string, outputStream: NSOutputStream, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  postObjectWithFile_destinationPath_parameters_progress_success_failure(path: NSString | string, destinationPath: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  putObjectWithFile_destinationPath_parameters_progress_success_failure(path: NSString | string, destinationPath: NSString | string, parameters: NSDictionary<any, any> | {[key: string]: any}, progress: Block, success: Block, failure: Block): AFHTTPRequestOperation;
  deleteObjectWithPath_success_failure(path: NSString | string, success: Block, failure: Block): AFHTTPRequestOperation;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  baseURL(): NSURL;
  // @ts-ignore
  requestSerializer(): AFAmazonS3RequestSerializer;
  // @ts-ignore
  setRequestSerializer(requestSerializer: AFAmazonS3RequestSerializer): void;
  static supportsSecureCoding(): boolean;
}

class AFAmazonS3RequestSerializerAllocator<T extends AFAmazonS3RequestSerializer> extends AFHTTPRequestSerializerAllocator<T> {}
declare class AFAmazonS3RequestSerializer extends AFHTTPRequestSerializer {
  alloc<T extends AFAmazonS3RequestSerializer>(): AFAmazonS3RequestSerializerAllocator<T>;
  setAccessKeyID_secret(accessKey: NSString | string, secret: NSString | string): void;
  requestBySettingAuthorizationHeadersForRequest_error(request: NSURLRequest, error: NSError): NSURLRequest;
  preSignedRequestWithRequest_expiration_error(request: NSURLRequest, expiration: NSDate, error: NSError): NSURLRequest;

  bucket(): NSString;
  setBucket(bucket: NSString | string): void;
  region(): NSString;
  setRegion(region: NSString | string): void;
  sessionToken(): NSString;
  setSessionToken(sessionToken: NSString | string): void;
  useSSL(): boolean;
  setUseSSL(useSSL: boolean): void;
  endpointURL(): NSURL;
}

class AFAmazonS3ResponseSerializerAllocator<T extends AFAmazonS3ResponseSerializer> extends AFHTTPResponseSerializerAllocator<T> {}
declare class AFAmazonS3ResponseSerializer extends AFHTTPResponseSerializer {
  alloc<T extends AFAmazonS3ResponseSerializer>(): AFAmazonS3ResponseSerializerAllocator<T>;
}

class AFAmazonS3ResponseObjectAllocator<T extends AFAmazonS3ResponseObject> extends NSObjectAllocator<T> {}
declare class AFAmazonS3ResponseObject extends NSObject {
  alloc<T extends AFAmazonS3ResponseObject>(): AFAmazonS3ResponseObjectAllocator<T>;
  static responseObject(response: NSHTTPURLResponse): AFAmazonS3ResponseObject;

  URL(): NSURL;
  ETag(): NSString;
  originalResponse(): NSHTTPURLResponse;
}

class MSActionAllocator<T extends MSAction> extends NSResponderAllocator<T> {}
declare class MSAction extends NSResponder {
  alloc<T extends MSAction>(): MSActionAllocator<T>;
  static imageName(): NSString;
  menuItems(): NSArray<any>;
  menuItemsForMenu(menu: NSMenu): NSArray<any>;
  makeToolbarItemForToolbar(forToolbar: boolean): NSToolbarItem;
  // @ts-ignore
  validateToolbarItem(): void;
  doPerformAction(sender: any): IBAction;
  submenuActionIDs(): NSArray<any>;
  containsActionWithID(actionIdentifier: NSString | string): boolean;
  contextForActionObservers(): any;
  handlesKeyEvent(event: NSEvent): boolean;

  badgeTitle(): NSAttributedString;
  preferredMenuAction(): string;
  labelForMenu(): NSString;
  mayShowInToolbar(): boolean;
  tooltip(): NSString;
  labelForToolbar(): NSString;
  imageForToolbar(): NSImage;
  labelForToolbarCustomisationSheet(): NSString;
  controller(): MSActionController;
  setController(controller: MSActionController): void;
  toolbarItem(): NSToolbarItem;
  setToolbarItem(toolbarItem: NSToolbarItem): void;
  hasSubMenu(): boolean;
  hasDynamicTitle(): boolean;
  image(): NSImage;
  imageName(): NSString;
  label(): NSString;
  shortcutCharacter(): unichar;
  isActive(): boolean;
  isSelectable(): boolean;
  validate(): boolean;
  validationStatus(): MSActionValidation;
}

declare enum MSActionValidation {
  MSActionValidationInvalid = 0,
  MSActionValidationValid = 1,
  MSActionValidationUnavailable = 2,
}

class MSActionControllerAllocator<T extends MSActionController> extends NSResponderAllocator<T> {}
declare class MSActionController extends NSResponder {
  alloc<T extends MSActionController>(): MSActionControllerAllocator<T>;
  registerAction(action: MSAction): void;
  actionForID(actionIdentifier: NSString | string): MSAction;
  actionForSelector(action: string): MSAction;
  performActionWithID_sender(actionIdentifier: NSString | string, sender: any | null): void;
  allActions(): NSArray<any>;
  insertAfterResponder(responder: NSResponder): void;
  forwardKeyEvent(event: NSEvent): boolean;
  willBeginActionWithID_context(actionID: NSString | string, context: any): void;
  didFinishActionWithID_context(actionID: NSString | string, context: any): void;
  didInstantActionWithID_context(actionID: NSString | string, context: any): void;
  registerActionObserver(observer: any): void;
  unregisterActionObserver(observer: any): void;
  performFakeActionWithID_context_block(actionID: NSString | string, context: any | null, block: MSActionFakeActionBlock | null): void;

  singleKeyShortcuts(): NSDictionary<any, any>;
  setSingleKeyShortcuts(singleKeyShortcuts: NSDictionary<any, any> | {[key: string]: any}): void;
}

declare interface IMSActionObserver {
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
}

class MSAlignLayersUnionAllocator<T extends MSAlignLayersUnion> extends BCRectAllocator<T> {}
declare class MSAlignLayersUnion extends BCRect {
  alloc<T extends MSAlignLayersUnion>(): MSAlignLayersUnionAllocator<T>;
  static unionWithLayers(layers: NSArray<any> | any[]): MSAlignLayersUnion;

  layers(): any;
  setLayers(layers: any): void;
}

class MSAlignmentEngineAllocator<T extends MSAlignmentEngine> extends NSObjectAllocator<T> {
  initWithCycle(cycle: MSAlignmentEngineCycle): T;
}
declare class MSAlignmentEngine extends NSObject {
  alloc<T extends MSAlignmentEngine>(): MSAlignmentEngineAllocator<T>;
  canSnapOnAxis(axis: BCAxis): boolean;
  beginCycleWithPoint_constraint(point: NSPoint, constraint: MSAlignmentEngineConstraint | null): MSAlignmentEngineCycle;
  addTarget(target: MSSnappingTarget): void;
  addTargets(targets: NSArray<any> | any[]): void;
  addTargetWithLineSegment(segment: MSLineSegment): void;
  addOrthogonalTargetsThroughPoint(point: NSPoint): void;
  addTargetsForRect_includeCenter(rect: NSRect, includeCenter: boolean): void;
  static snapTargetsForCentersOfLayers(layers: NSArray<any> | any[]): NSArray<any>;
  includeRulerGuideTargetsForPage_zoomScale(page: MSPage, zoomScale: CGFloat): void;
  static enumeratorForPossibleSnapTargetLayersInGroup(group: MSLayerGroup): MSLayerEnumerator<any>;

  snapDistance(): CGFloat;
  setSnapDistance(snapDistance: CGFloat): void;
  constraint(): MSAlignmentEngineConstraint;
  currentCycle(): MSAlignmentEngineCycle;
  alignmentResult(): MSAlignmentEngineResult;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSAlignmentEngineDelegate {
  alignmentEngine_alignPoint(engine: MSAlignmentEngine, point: NSPoint): NSPoint;
  alignmentEngine_roundPoint(engine: MSAlignmentEngine, point: NSPoint): NSPoint;
}

class MSAlignmentEngineConstraintAllocator<T extends MSAlignmentEngineConstraint> extends NSObjectAllocator<T> {}
declare class MSAlignmentEngineConstraint extends NSObject implements INSCopying {
  alloc<T extends MSAlignmentEngineConstraint>(): MSAlignmentEngineConstraintAllocator<T>;
  static constraintWithSourcePoint_toPoint(sourcePoint: NSPoint, point2: NSPoint): MSAlignmentEngineConstraint;
  static orthogonalOrDiagonalConstraintFromPoint_toPoint(sourcePoint: NSPoint, unsnappedDestination: NSPoint): MSAlignmentEngineConstraint;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  sourcePoint(): NSPoint;
  line(): MSLine;
}

class MSAlignmentEngineResultGuideAllocator<T extends MSAlignmentEngineResultGuide> extends NSObjectAllocator<T> {
  initWithLineSegment(segment: MSLineSegment): T;
}
declare class MSAlignmentEngineResultGuide extends NSObject implements INSCopying {
  alloc<T extends MSAlignmentEngineResultGuide>(): MSAlignmentEngineResultGuideAllocator<T>;
  bezierPath(): NSBezierPath;
  drawWithLineWidth(width: CGFloat): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  lineSegment(): MSLineSegment;
}

class MSAlignmentEngineResultAllocator<T extends MSAlignmentEngineResult> extends NSObjectAllocator<T> {
  initWithPoint_guides(point: NSPoint, guides: NSArray<any> | any[]): T;
}
declare class MSAlignmentEngineResult extends NSObject implements INSCopying {
  alloc<T extends MSAlignmentEngineResult>(): MSAlignmentEngineResultAllocator<T>;
  static snappingResultWithPoint(point: NSPoint): MSAlignmentEngineResult;
  drawAtZoomValue(zoomValue: CGFloat): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  point(): NSPoint;
  guides(): NSArray<any>;
}

class MSArtboardGroupAllocator<T extends MSArtboardGroup> extends _MSArtboardGroupAllocator<T> {}
declare class MSArtboardGroup extends _MSArtboardGroup implements IMSArtboardGroup, IMSRootLayer, IMSLayerWithMutableBackgroundColor, IMSColorConvertible {
  alloc<T extends MSArtboardGroup>(): MSArtboardGroupAllocator<T>;
  optimalBoundingBox(): NSRect;
  resizeToFitChildren(): void;
  static artboardRectFromLayersInArray(layers: MSLayerArray): NSRect;
  hitTestInNameLabel_zoomValue(mouse: NSPoint, zoom: CGFloat): boolean;
  moveChildrenToIdenticalPositionAfterResizeFromRect(oldRect: NSRect): void;
  makeChildRectsIntegral(): void;
  convertColorsUsing(converter: any): void;
  convertColorsUsing(converter: any): void;

  preset(): MSArtboardPreset;
  setPreset(preset: MSArtboardPreset): void;
  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  rulerBase(): NSPoint;
  setRulerBase(rulerBase: NSPoint): void;
  contentBounds(): NSRect;
  rect(): CGRect;
  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
}

class MSArtboardOrderSortingAllocator<T extends MSArtboardOrderSorting> extends NSObjectAllocator<T> {}
declare class MSArtboardOrderSorting extends NSObject {
  alloc<T extends MSArtboardOrderSorting>(): MSArtboardOrderSortingAllocator<T>;
  static sortArtboards_inOrder(artboards: NSArray<any> | any[], order: MSLayerOrderSortingOptions): NSArray<any>;
  static sortArtboardsInDefaultOrder(artboards: NSArray<any> | any[]): NSArray<any>;
}

declare enum MSLayerOrderSortingOptions {
  MSArtboardSortingCurrentOrder = 8,
  MSArtboardSortingReverseOrder = 9,
  MSArtboardSortingLeftToRight,
  MSArtboardSortingRightToLeft,
  MSArtboardSortingTopToBottom,
}

class MSAssetLibraryAllocator<T extends MSAssetLibrary> extends NSObjectAllocator<T> {
  initWithDocumentAtURL(url: NSURL): T;
  initWithName(name: NSString | string): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class MSAssetLibrary extends NSObject implements IBCSortable, INSCoding, IMSLibraryObject {
  alloc<T extends MSAssetLibrary>(): MSAssetLibraryAllocator<T>;
  resolveLocationOnDisk(): void;
  loadSynchronously(): boolean;
  loadAsyncWithDispatchGroup_completionHandler(dispatchGroup: dispatch_group_t | null, block: dispatch_block_t): void;
  unload(): void;
  handleAssetLibraryUpdateWithCompletionHandler(block: Block): void;
  static URLForTemplateLibraryNamed(name: NSString | string): NSURL;
  static assetLibraryStatusForDocumentErrorCode(errorCode: MSDocumentErrorCode): MSAssetLibraryStatus;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  valid(): boolean;
  status(): MSAssetLibraryStatus;
  setStatus(status: MSAssetLibraryStatus): void;
  locationOnDisk(): NSURL;
  setLocationOnDisk(locationOnDisk: NSURL): void;
  canLibraryBeRemoved(): boolean;
  document(): MSDocumentData;
  name(): NSString;
  delegate(): any;
  setDelegate(delegate: any): void;
  dateLastModified(): NSDate;
  libraryType(): MSAssetLibraryType;
  propertyListDictionaryRepresentation(): NSDictionary<any, any>;
  previewURL(): NSURL;
  libraryID(): NSString;
}

declare enum MSAssetLibraryStatus {
  MSAssetLibraryStatusLoaded = 0,
  MSAssetLibraryStatusNotLoaded,
  MSAssetLibraryStatusNotFound,
  MSAssetLibraryStatusIncompatibleVersion,
  MSAssetLibraryStatusLoadError,
}

declare enum MSAssetLibraryType {
  MSAssetLibraryTypeInternal = 0,
  MSAssetLibraryTypeUser = 1,
  MSAssetLibraryTypeRemote = 2,
}

declare enum MSAssetLibraryVersion {
  MSAssetLibraryInitialVersion = 1,
  MSAssetLibraryDownloadableLibraryVersion = 2,
  MSAssetLibraryBookMarkLocationTrackingRemoved = 3,
  MSAssetLibraryNextVersion,
  MSAssetLibraryCurrentVersion,
}

class MSAssetLibraryControllerAllocator<T extends MSAssetLibraryController> extends NSObjectAllocator<T> {}
declare class MSAssetLibraryController extends NSObject implements IMSAssetLibraryDelegate {
  alloc<T extends MSAssetLibraryController>(): MSAssetLibraryControllerAllocator<T>;
  addAssetLibraryAtURL(url: NSURL): MSAssetLibraryControllerAddStatus;
  removeAssetLibrary(library: MSAssetLibrary): void;
  importShareableObjectReference_intoDocument(reference: MSShareableObjectReference, document: MSDocumentData): MSForeignObject;
  syncForeignObject_withMaster_fromLibrary(foreignObject: MSForeignObject, libraryMaster: MSShareableObject, sourceLibrary: MSAssetLibrary): void;
  enumerateForeignObjects_inDocument_includeDisabled_block(objects: NSArray<any> | any[], document: MSDocumentData, includeDisabled: boolean, block: Block): void;
  libraryForShareableObject(object: MSModelObject): MSAssetLibrary;
  loadLibrariesWithDispatchGroup(dispatchGroup: dispatch_group_t | null): void;
  loadInternalLibraryRepresentationWithCompletionHandler(completionHandler: Block): void;
  generatePreviewImageForLibrary_completionHandler(library: MSAssetLibrary, completionHandler: Block): void;
  addRemoteLibraryFromAppcastURL_withCompletionHandler(appcastURL: NSURL, completionHandler: Block): void;
  downloadAssetLibraryAppcastsWithHandler_completionHandler(handler: Block | null, completionBlock: Block): void;
  startDownloadingAssetLibrary_progressHandler_downloadCompletionHandler_completionHandler(assetLibrary: MSRemoteAssetLibrary, progressHandler: Block, downloadCompletionHandler: Block, completionHandler: Block): void;
  librariesWithUpdates(): NSArray<any>;
  addRemoteLibraryFromAppcastURL_context_callback(appcastURL: NSURL, coscript: COScript, callback: MOJavaScriptObject | Function): void;
  assetLibraryChangedOnDisk(library: MSAssetLibrary): void;
  assetLibraryEnableStateChanged(library: MSAssetLibrary): void;
  assetLibraryChangedOnDisk(library: MSAssetLibrary): void;
  assetLibraryEnableStateChanged(library: MSAssetLibrary): void;

  availableLibraries(): NSArray<any>;
  libraries(): NSArray<any>;
}

declare enum MSAssetLibraryControllerAddStatus {
  MSAssetLibraryControllerAddStatusOK,
  MSAssetLibraryControllerAddStatusDuplicate,
  MSAssetLibraryControllerAddStatusLegacyDocument,
  MSAssetLibraryControllerAddStatusInvalidFile,
}

declare interface IMSAssetLibraryDelegate {
  assetLibraryChangedOnDisk(library: MSAssetLibrary): void;
  assetLibraryEnableStateChanged(library: MSAssetLibrary): void;
}

class MSAssetLibraryUpdaterAllocator<T extends MSAssetLibraryUpdater> {}
declare class MSAssetLibraryUpdater {
  alloc<T extends MSAssetLibraryUpdater>(): MSAssetLibraryUpdaterAllocator<T>;
  startDownloadingAssetLibrary_progressHandler_completionHandler(assetLibrary: MSRemoteAssetLibrary, progressHandler: Block, completionHandler: Block): NSString;
  updateAssetLibrary_withLibraryDownloadedTo(assetLibrary: MSRemoteAssetLibrary, downloadedFileURL: NSURL): boolean;
  downloadAppcastAtURL_withCompletionHandler(appcastURL: NSURL, completionHandler: Block): void;
  startFileDownload_completionHandler(remoteURL: NSURL, completionHandler: Block): void;
  cancelDownloadTaskWithIdentifier(downloadTaskIdentifier: NSString | string | null): void;
}

class MSAttributeConverterAllocator<T extends MSAttributeConverter> extends NSObjectAllocator<T> {
  initWithAttributeName_block(attributeName: NSString | string, conversionBlock: MSAttributeConverterBlock): T;
}
declare class MSAttributeConverter extends NSObject {
  alloc<T extends MSAttributeConverter>(): MSAttributeConverterAllocator<T>;
  static converterWithAttributeName_block(attributeName: NSString | string, conversionBlock: MSAttributeConverterBlock): MSAttributeConverter;
  convertAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;

  attributeName(): NSString;
  conversionBlock(): MSAttributeConverterBlock;
}

class MSAutoCappingNumberFormatterAllocator<T extends MSAutoCappingNumberFormatter> extends MSMathNumberFormatterAllocator<T> {}
declare class MSAutoCappingNumberFormatter extends MSMathNumberFormatter {
  alloc<T extends MSAutoCappingNumberFormatter>(): MSAutoCappingNumberFormatterAllocator<T>;
}

class MSAutoSelectingArrayControllerAllocator<T extends MSAutoSelectingArrayController> extends NSArrayControllerAllocator<T> {}
declare class MSAutoSelectingArrayController extends NSArrayController {
  alloc<T extends MSAutoSelectingArrayController>(): MSAutoSelectingArrayControllerAllocator<T>;
}

class MSAveragingRenderMonitorAllocator<T extends MSAveragingRenderMonitor> extends MSRenderMonitorAllocator<T> {
  initWithUpdateBlock(block: MSAveragingRenderMonitorUpdateBlock): T;
}
declare class MSAveragingRenderMonitor extends MSRenderMonitor {
  alloc<T extends MSAveragingRenderMonitor>(): MSAveragingRenderMonitorAllocator<T>;

  start(): BCTime;
  setStart(start: BCTime): void;
  updateTimer(): NSTimer;
  setUpdateTimer(updateTimer: NSTimer): void;
}

class MSBaseGridAllocator<T extends MSBaseGrid> extends _MSBaseGridAllocator<T> {}
declare class MSBaseGrid extends _MSBaseGrid {
  alloc<T extends MSBaseGrid>(): MSBaseGridAllocator<T>;
  verticalGuidesForRulerData_inRect(ruler: MSRulerData, aRect: NSRect): NSArray<any>;
  horizontalGuidesForRulerData_inRect(ruler: MSRulerData, aRect: NSRect): NSArray<any>;
  static defaultGrid(): any;
  static setDefaultGrid(grid: MSBaseGrid): void;
  shouldDraw(): boolean;
  drawInRect_horizontalRuler_verticalRuler(dirtyRect: NSRect, horizontalRuler: MSRulerView, verticalRuler: MSRulerView): void;
  verticalGuidesForRuler_inRect(ruler: MSRulerView, aRect: NSRect): NSArray<any>;
  horizontalGuidesForRuler_inRect(ruler: MSRulerView, aRect: NSRect): NSArray<any>;

  forceDraw(): boolean;
  setForceDraw(forceDraw: boolean): void;
}

class MSBeepSuppressorAllocator<T extends MSBeepSuppressor> extends NSObjectAllocator<T> {}
declare class MSBeepSuppressor extends NSObject {
  alloc<T extends MSBeepSuppressor>(): MSBeepSuppressorAllocator<T>;
  static failSilentlyInBlock(block: Block): void;

  static shouldSuppressBeep(): boolean;
}

class MSButtonToolbarItemAllocator<T extends MSButtonToolbarItem> extends MSToolbarItemAllocator<T> {}
declare class MSButtonToolbarItem extends MSToolbarItem {
  alloc<T extends MSButtonToolbarItem>(): MSButtonToolbarItemAllocator<T>;
}

class MSClickGestureRecognizerAllocator<T extends MSClickGestureRecognizer> extends MSGestureRecognizerAllocator<T> {}
declare class MSClickGestureRecognizer extends MSGestureRecognizer {
  alloc<T extends MSClickGestureRecognizer>(): MSClickGestureRecognizerAllocator<T>;

  buttonMask(): NSUInteger;
  setButtonMask(buttonMask: NSUInteger): void;
  numberOfClicksRequired(): NSInteger;
  setNumberOfClicksRequired(numberOfClicksRequired: NSInteger): void;
}

class MSClosePathChangeAllocator<T extends MSClosePathChange> extends MSShapeChangeAllocator<T> {}
declare class MSClosePathChange extends MSShapeChange {
  alloc<T extends MSClosePathChange>(): MSClosePathChangeAllocator<T>;
  static toggleClosePath(): MSClosePathChange;
  validateWithContext(context: MSShapeChangeContext): boolean;
  titleForContext(context: MSShapeChangeContext): NSString;
}

declare interface IMSCloudExportableDocument {

  documentData(): MSDocumentData;
  UIMetadata(): NSDictionary<any, any>;
  cacheManager(): MSCacheManager;
  cloudShare(): SCKShare;
  setCloudShare(cloudShare: SCKShare): void;
  cloudName(): NSString;
}

class MSCloudManifestMakerAllocator<T extends MSCloudManifestMaker> extends MSManifestMakerAllocator<T> {}
declare class MSCloudManifestMaker extends MSManifestMaker {
  alloc<T extends MSCloudManifestMaker>(): MSCloudManifestMakerAllocator<T>;

  imageFileProviderBlock(): MSManifestImageProviderBlock;
  setImageFileProviderBlock(imageFileProviderBlock: MSManifestImageProviderBlock): void;
}

class MSCloudShareUploadControllerAllocator<T extends MSCloudShareUploadController> extends NSObjectAllocator<T> {
  initWithDocument(document: any): T;
}
declare class MSCloudShareUploadController extends NSObject {
  alloc<T extends MSCloudShareUploadController>(): MSCloudShareUploadControllerAllocator<T>;
  startUpload(): void;
  cancel(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  existingShare(): SCKShare;
  setExistingShare(existingShare: SCKShare): void;
  cancelled(): boolean;
  progress(): NSProgress;
}

declare interface IMSCloudShareUploadControllerDelegate {
  cloudShareController_didUploadShare(controller: MSCloudShareUploadController, share: SCKShare): void;
  cloudShareController_exportDocumentWithHandler(controller: MSCloudShareUploadController, handler: Block): void;
  cloudShareController_uploadDidFailWithError(controller: MSCloudShareUploadController, error: NSError | null): void;
  cloudShareController_didChangeProgress(controller: MSCloudShareUploadController, progress: NSProgress | null): void;
}

class MSCloudUserAllocator<T extends MSCloudUser> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class MSCloudUser extends NSObject implements INSSecureCoding {
  alloc<T extends MSCloudUser>(): MSCloudUserAllocator<T>;
  verifiedUser(): MSCloudUser;
  static userWithIdentifier_verified(identifier: NSString | string, verified: boolean): MSCloudUser;

  identifier(): NSString;
  email(): NSString;
  pendingEmail(): NSString;
  isAdmin(): boolean;
  isVerified(): boolean;
  name(): NSString;
  webAccessToken(): NSString;
  static supportsSecureCoding(): boolean;
}

class MSColorSpaceConverterAllocator<T extends MSColorSpaceConverter> extends NSObjectAllocator<T> {
  initForConversionFromColorSpace_to(oldColorSpace: MSColorSpace, targetColorSpace: MSColorSpace): T;
}
declare class MSColorSpaceConverter extends NSObject implements IMSColorConverter {
  alloc<T extends MSColorSpaceConverter>(): MSColorSpaceConverterAllocator<T>;
  convertColor(color: MSColor): MSColor;
  convertImmutableColor(color: MSImmutableColor): MSImmutableColor;
  shouldConvertColor(color: MSColor): boolean;
  shouldConvertImmutableColor(color: MSImmutableColor): boolean;
  convertColor(color: MSColor): MSColor;
  convertImmutableColor(color: MSImmutableColor): MSImmutableColor;
  shouldConvertColor(color: MSColor): boolean;
  shouldConvertImmutableColor(color: MSImmutableColor): boolean;

  oldColorSpace(): MSColorSpace;
  targetColorSpace(): MSColorSpace;
  oldNSColorSpace(): NSColorSpace;
  targetNSColorSpace(): NSColorSpace;
}

class MSCompoundSnapItemAllocator<T extends MSCompoundSnapItem> extends MSSnapItemAllocator<T> {}
declare class MSCompoundSnapItem extends MSSnapItem {
  alloc<T extends MSCompoundSnapItem>(): MSCompoundSnapItemAllocator<T>;
}

class MSCoordinateInspectorValueAdaptorAllocator<T extends MSCoordinateInspectorValueAdaptor> extends MSMathInspectorValueAdaptorAllocator<T> {
  initWithLayerController_layerKeyPath_axis(layerController: NSArrayController, keyPath: NSString | string, axis: BCAxis): T;
  initWithLayerController_valueGetter_valueSetter_layerKeyPathsToWatch_axis(layerController: NSArrayController, valueGetter: Block, valueSetter: Block, layerKeyPathsToWatch: NSArray<any> | any[], axis: BCAxis): T;
}
declare class MSCoordinateInspectorValueAdaptor extends MSMathInspectorValueAdaptor {
  alloc<T extends MSCoordinateInspectorValueAdaptor>(): MSCoordinateInspectorValueAdaptorAllocator<T>;

  axis(): BCAxis;
}

class MSCornerRadiusInspectorValueAdaptorAllocator<T extends MSCornerRadiusInspectorValueAdaptor> extends MSMathInspectorValueAdaptorAllocator<T> {
  initWithModelsController(arrayController: NSArrayController): T;
}
declare class MSCornerRadiusInspectorValueAdaptor extends MSMathInspectorValueAdaptor {
  alloc<T extends MSCornerRadiusInspectorValueAdaptor>(): MSCornerRadiusInspectorValueAdaptorAllocator<T>;
}

class MSCornerRadiusInspectorValueAdaptorContextAllocator<T extends MSCornerRadiusInspectorValueAdaptorContext> extends NSObjectAllocator<T> {}
declare class MSCornerRadiusInspectorValueAdaptorContext extends NSObject {
  alloc<T extends MSCornerRadiusInspectorValueAdaptorContext>(): MSCornerRadiusInspectorValueAdaptorContextAllocator<T>;
  componentStringWithMathValueForModel(model: MSRectangleShape): NSString;

  mode(): MSCornerRadiusMode;
  setMode(mode: MSCornerRadiusMode): void;
  componentString(): NSString;
  setComponentString(componentString: NSString | string): void;
  mathOperator(): NSString;
  setMathOperator(mathOperator: NSString | string): void;
  value(): NSNumber;
  setValue(value: NSNumber | number): void;
}

declare enum MSCornerRadiusMode {
  MSCornerRadiusModeComponentString,
  MSCornerRadiusModeMath,
  MSCornerRadiusModeValue,
}

class MSDataMenuProviderAllocator<T extends MSDataMenuProvider> extends NSObjectAllocator<T> {
  initWithDataManager(dataManager: MSDataSupplierManager): T;
}
declare class MSDataMenuProvider extends NSObject implements INSMenuDelegate {
  alloc<T extends MSDataMenuProvider>(): MSDataMenuProviderAllocator<T>;
  menu(): NSMenu;
  overridesMenu(): NSMenu;
  menuItemsForDataType_indentationLevel_smallFont(dataType: MSDataType, menuItemIndentation: NSInteger, smallFont: boolean): NSArray<any>;
  clearDataMenuItemWithSmallFont(smallFont: boolean): NSMenuItem;
  refreshDataMenuItemsWithSmallFont_overridesMenu(smallFont: boolean, overridesMenu: boolean): NSArray<any>;
  addImageToMenuItems(menuItems: NSArray<any> | any[]): NSImage;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;

  dataManager(): MSDataSupplierManager;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSDataMenuProviderDelegate {
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
}

class MSDataOverrideAllocator<T extends MSDataOverride> extends NSObjectAllocator<T> {
  initWithOverride_symbolInstance(availableOverride: MSAvailableOverride, symbolInstance: MSSymbolInstance): T;
}
declare class MSDataOverride extends NSObject {
  alloc<T extends MSDataOverride>(): MSDataOverrideAllocator<T>;

  availableOverride(): MSAvailableOverride;
  symbolInstance(): MSSymbolInstance;
  affectedLayer(): MSImmutableStyledLayer;
  overrideIdentifier(): NSString;
}

class MSDataSupplierAllocator<T extends MSDataSupplier> extends NSObjectAllocator<T> {
  initWithDataIdentifier_dataName_dataType(dataIdentifier: NSString | string, dataName: NSString | string, dataType: MSDataType): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class MSDataSupplier extends NSObject implements INSCoding {
  alloc<T extends MSDataSupplier>(): MSDataSupplierAllocator<T>;
  resetMenuItemImage(): void;
  imageFileURLForDataItem(dataItem: NSString | string): NSURL;
  applyDataWithCount_data_dataApplier(count: NSUInteger, dataArray: NSArray<any> | any[], block: MSDataApplierBlock): void;
  generateDataForLayers_dataSupplierManager_dataApplier(layers: NSArray<any> | any[], manager: MSDataSupplierManager, applierBlock: MSDataApplierBlock): void;
  generateDataForOverrides_dataSupplierManager_dataApplier(overrides: NSArray<any> | any[], manager: MSDataSupplierManager, applierBlock: MSDataApplierBlock): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  dataName(): NSString;
  setDataName(dataName: NSString | string): void;
  dataType(): MSDataType;
  dataIdentifier(): NSString;
  valid(): boolean;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  menuItemImage(): NSImage;
}

declare interface IMSDataSupplierDelegate {
  dataSupplierMenuItemImage(dataSupplier: MSDataSupplier): NSImage;
  dataSupplierDataChanged(localDataSupplier: MSLocalDataSupplier): void;
}

class MSDataSupplierManagerAllocator<T extends MSDataSupplierManager> extends NSObjectAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class MSDataSupplierManager extends NSObject {
  alloc<T extends MSDataSupplierManager>(): MSDataSupplierManagerAllocator<T>;
  static validLocalDataFileSystemURL(possibleDataURL: NSURL): boolean;
  static URLForBuiltinDataNamed(name: NSString | string): NSURL;
  registerPluginDataSupplier_withName_dataType_pluginIdentifier_commandIdentifier(dynamicDataKey: NSString | string, dataName: NSString | string, dataType: NSString | string, pluginIdentifier: NSString | string, commandIdentifier: NSString | string): void;
  deregisterDataSuppliersForPluginWithIdentifier(pluginIdentifier: NSString | string): void;
  removePluginDataSuppliersNotIdentifiedWithIdentifiers(dataSupplierIdentifiers: NSDictionary<any, any> | {[key: string]: any}): void;
  requestDataFromPluginDataSupplier_dataContext_applierBlock(dataSupplier: MSPluginDataSupplier, dataSupplierContext: MSPluginDataSupplierContext, applierBlock: MSDataApplierBlock): void;
  supplyData_forKey(data: NSArray<any> | any[], dataKey: NSString | string): void;
  addLocalData(localDataSupplier: MSLocalDataSupplier): void;
  removeLocalDataSupplier(dataSupplier: MSLocalDataSupplier): void;
  loadDataSuppliersWithResetBuiltin(resetBuiltin: boolean): void;
  hasLocalDataSupplierWithURL(dataURL: NSURL): boolean;
  dataSupplierWithIdentifier(identifier: NSString | string | null): MSDataSupplier;
  useableDataSupplierWithIdentifier(identifier: NSString | string): MSDataSupplier;

  dataSuppliers(): NSArray<any>;
  delegate(): any;
}

declare interface IMSDataSupplierManagerDelegate {
  requestDataFromPluginDataSupplier_pluginContext(pluginDataSupplier: MSPluginDataSupplier, pluginContext: NSDictionary<any, any> | {[key: string]: any}): void;
  isThereAPluginForDataSupplier(pluginDataSupplier: MSPluginDataSupplier): boolean;
  pluginIconForIdentifier(pluginIdentifier: NSString | string): NSImage;
  pluginNameForIdentifier(pluginIdentifier: NSString | string): NSString;
}

declare enum MSDataType {
  MSDataTypeNone = 0,
  MSDataTypeText = 1<<0,
  MSDataTypeImage = 1<<1,
  MSDataTypeAny,
}

class MSDigitStringFormatterAllocator<T extends MSDigitStringFormatter> extends NSFormatterAllocator<T> {}
declare class MSDigitStringFormatter extends NSFormatter {
  alloc<T extends MSDigitStringFormatter>(): MSDigitStringFormatterAllocator<T>;
  static isDigitString(string: NSString | string): boolean;
}

class MSDocumentDataAllocator<T extends MSDocumentData> extends _MSDocumentDataAllocator<T> {}
declare class MSDocumentData extends _MSDocumentData implements IMSDocumentData {
  alloc<T extends MSDocumentData>(): MSDocumentDataAllocator<T>;
  enumerateColorConvertiblesIgnoringForeignSymbols(block: MSColorConvertibleHandler): void;
  replaceInstancesOfColor_withColor_ignoreAlphaWhenMatching_replaceAlphaOfOriginalColor(color: MSColor, replacementColor: MSColor, ignoreAlphaWhenMatching: boolean, replaceAlphaOfOriginalColor: boolean): void;
  assignColorSpace(colorSpace: MSColorSpace): void;
  convertToColorSpace(colorSpace: MSColorSpace): void;
  defaultPagesArray(): NSArray<any>;
  removePages_detachInstances(page: NSArray<any> | any[], shouldDetachInstances: boolean): void;
  addBlankPage(): MSPage;
  symbolsPage(): MSPage;
  symbolsPageOrCreateIfNecessary(): MSPage;
  sharedObjectContainerOfType(type: MSSharedStyleType): MSSharedObjectContainer;
  documentIsEmpty(): boolean;
  selectedLayers(): MSLayerArray;
  layerTreeLayoutDidChange(): void;
  layerWithID(objectID: NSString | string): MSLayer;
  artboardWithID(objectID: any): MSArtboardGroup;
  layersByObjectID(): NSDictionary<any, any>;
  allArtboards(): NSArray<any>;
  allSymbols(): NSArray<any>;
  localSymbols(): NSArray<any>;
  symbolWithID(symbolID: any): MSSymbolMaster;
  textStyleWithID(sharedStyleID: NSString | string | null): MSSharedStyle;
  layerStyleWithID(sharedStyleID: NSString | string | null): MSSharedStyle;
  allForeignObjects(): NSArray<any>;
  addCopyOfMasterToDocumentIfNecessary(master: MSSymbolMaster): MSSymbolMaster;
  addCopyOfInstanceMasterToDocumentIfNecessary(instance: MSSymbolInstance): MSSymbolMaster;
  addSymbolMaster(master: MSSymbolMaster): void;
  enumerateForeignObjects_withLibraries_block(objects: NSArray<any> | any[], libraries: NSArray<any> | any[], block: Block): void;
  libraryForForeignObject_inLibraries(object: MSForeignObject, libraries: NSArray<any> | any[]): any;
  temporarilyHideSelectionForLayers(layer: NSArray<any> | any[]): void;
  immediatelyShowSelectionForAllLayers(): void;
  replaceExistingCreationMetadata(): void;
  refreshOverlayInRect(rect: NSRect): void;
  refreshOverlay(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  purgeForeignObjects(): void;
  invalidateAffectedSymbolInstances(): void;
  removeShareableObjectsFromInstanceOverrides(removed: NSSet<any>): void;
  replaceFonts(fontReplacements: NSDictionary<any, any> | {[key: string]: any}): void;
  invalidateFonts(): void;
  storeMetadata_forKey_object(toStore: any, key: NSString | string, object: MSModelObject): void;
  metadataForKey_object(key: NSString | string, object: MSModelObject): any;

  cache(): BCCache;
  setCache(cache: BCCache): void;
  currentPage(): MSPage;
  setCurrentPage(currentPage: MSPage): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  autoExpandGroupsInLayerList(): boolean;
  setAutoExpandGroupsInLayerList(autoExpandGroupsInLayerList: boolean): void;
  metadata(): NSDictionary<any, any>;
  fontList(): MSFontList;
  selectedOverrides(): NSArray<any>;
  setSelectedOverrides(selectedOverrides: NSArray<any> | any[]): void;
  pages(): NSArray<any>;
}

class MSDocumentationSearchEntryAllocator<T extends MSDocumentationSearchEntry> extends NSObjectAllocator<T> {}
declare class MSDocumentationSearchEntry extends NSObject {
  alloc<T extends MSDocumentationSearchEntry>(): MSDocumentationSearchEntryAllocator<T>;
  static searchEntryWithDictionary(dict: NSDictionary<any, any> | {[key: string]: any}): MSDocumentationSearchEntry;
  static markSearchEntriesAsDuplicates(entries: NSArray<any> | any[]): void;
  titles(): NSArray<any>;
  matchesSearchQuery(query: NSString | string): boolean;
  show(): void;
}

class MSDocumentationSearcherAllocator<T extends MSDocumentationSearcher> extends NSObjectAllocator<T> {}
declare class MSDocumentationSearcher extends NSObject implements INSUserInterfaceItemSearching {
  alloc<T extends MSDocumentationSearcher>(): MSDocumentationSearcherAllocator<T>;
  documentationMightHaveChanged(): void;
  searchForItemsWithSearchString_resultLimit_matchedItemHandler(searchString: NSString | string, resultLimit: NSInteger, handleMatchedItems: Block): void;
  localizedTitlesForItem(item: any): NSArray<any>;
  performActionForItem(item: any): void;
  showAllHelpTopicsForSearchString(searchString: NSString | string): void;
  searchForItemsWithSearchString_resultLimit_matchedItemHandler(searchString: NSString | string, resultLimit: NSInteger, handleMatchedItems: Block): void;
  localizedTitlesForItem(item: any): NSArray<any>;
  performActionForItem(item: any): void;
  showAllHelpTopicsForSearchString(searchString: NSString | string): void;
}

class MSDragGestureRecognizerAllocator<T extends MSDragGestureRecognizer> extends MSGestureRecognizerAllocator<T> {}
declare class MSDragGestureRecognizer extends MSGestureRecognizer {
  alloc<T extends MSDragGestureRecognizer>(): MSDragGestureRecognizerAllocator<T>;
  locationInLayer(layer: MSLayer | null): NSPoint;
  translationInLayer(layer: MSLayer | null): CGVector;
  setTranslation_inLayer(translation: CGVector, layer: MSLayer | null): void;
  translationAsPointInLayer(layer: MSLayer | null): NSPoint;
  originInLayer(layer: MSLayer | null): NSPoint;

  beginsUponMouseDown(): boolean;
  setBeginsUponMouseDown(beginsUponMouseDown: boolean): void;
  translationLocked(): boolean;
  setTranslationLocked(translationLocked: boolean): void;
  modifierFlags(): NSEventModifierFlags;
}

class MSExportRequestAllocator<T extends MSExportRequest> extends NSObjectAllocator<T> {}
declare class MSExportRequest extends NSObject implements INSCopying {
  alloc<T extends MSExportRequest>(): MSExportRequestAllocator<T>;
  readSettingsFromDefaults(): void;
  static exportRequestsFromExportableLayer(layer: MSLayer): NSArray<any>;
  static exportRequestsFromExportableLayer_useIDForName(layer: MSLayer, useIDForName: boolean): NSArray<any>;
  static exportRequestsFromExportableLayer_exportFormats_useIDForName(layer: MSLayer, exportFormats: NSArray<any> | any[], useIDForName: boolean): NSArray<any>;
  static exportRequestsFromExportableLayer_inRect_useIDForName(layer: MSLayer, rect: NSRect, useIDForName: boolean): NSArray<any>;
  static exportRequestsFromExportableLayer_exportFormats_inRect_useIDForName(layer: MSLayer, exportFormats: NSArray<any> | any[], rect: NSRect, useIDForName: boolean): NSArray<any>;
  static exportRequestFromExportFormat_layer_inRect_useIDForName(exportFormat: MSExportFormat, layer: MSLayer, rect: NSRect, useIDForName: boolean): MSExportRequest;
  configureForLayer_layerOptions_includedIDs(layer: MSLayer, layerOptions: MSExportLayerOptions, includedIDs: NSArray<any> | any[]): void;
  static exportRequestsFromLayerAncestry(layerAncestry: MSImmutableLayerAncestry): NSArray<any>;
  static exportRequestsFromLayerAncestry_inRect(layerAncestry: MSImmutableLayerAncestry, rect: NSRect): NSArray<any>;
  static exportRequestsFromLayerAncestry_exportFormats(layerAncestry: MSImmutableLayerAncestry, exportFormats: NSArray<any> | any[]): NSArray<any>;
  static exportRequestsFromLayerAncestry_exportFormats_inRect(layerAncestry: MSImmutableLayerAncestry, exportFormats: NSArray<any> | any[], rect: NSRect): NSArray<any>;
  static exportRequestFromLayerAncestry_exportFormat_inRect(ancestry: MSImmutableLayerAncestry, exportFormat: MSImmutableExportFormat, rect: NSRect): MSExportRequest;
  setNameFromID_exportFormat(objectID: NSString | string, format: MSImmutableExportFormat): void;
  configureForLayerAncestry_layerOptions_includedIDs(ancestry: MSImmutableLayerAncestry, layerOptions: MSExportLayerOptions, includedIDs: NSArray<any> | any[]): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  rect(): NSRect;
  setRect(rect: NSRect): void;
  name(): NSString;
  setName(name: NSString | string): void;
  options(): MSExportLayerOptions;
  setOptions(options: MSExportLayerOptions): void;
  includedLayerIDs(): NSSet<any>;
  setIncludedLayerIDs(includedLayerIDs: NSSet<any>): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  shouldTrim(): boolean;
  setShouldTrim(shouldTrim: boolean): void;
  backgroundColor(): MSImmutableColor;
  setBackgroundColor(backgroundColor: MSImmutableColor): void;
  rootLayer(): MSImmutableLayer;
  setRootLayer(rootLayer: MSImmutableLayer): void;
  immutableDocument(): MSImmutableDocumentData;
  setImmutableDocument(immutableDocument: MSImmutableDocumentData): void;
  format(): NSString;
  setFormat(format: NSString | string): void;
  saveForWeb(): boolean;
  setSaveForWeb(saveForWeb: boolean): void;
  compression(): CGFloat;
  setCompression(compression: CGFloat): void;
  progressive(): boolean;
  setProgressive(progressive: boolean): void;
  interlaced(): boolean;
  setInterlaced(interlaced: boolean): void;
  includeArtboardBackground(): boolean;
  setIncludeArtboardBackground(includeArtboardBackground: boolean): void;
}

class MSFlashControllerAllocator<T extends MSFlashController> extends NSObjectAllocator<T> {}
declare class MSFlashController extends NSObject {
  alloc<T extends MSFlashController>(): MSFlashControllerAllocator<T>;
  displayFlashMessage(message: NSString | string): any;
  displayWarningMessage_withHelpHandler(message: NSString | string, helpBlock: MSFlashControllerHelpBlock | null): any;
  displayFixedMessage_withHelpHandler(message: NSString | string, helpBlock: MSFlashControllerHelpBlock | null): any;
  removeMessage(message: any): void;
  clearFlash(): void;

  stackView(): NSStackView;
  setStackView(stackView: NSStackView): void;
}

class MSFlashViewControllerAllocator<T extends MSFlashViewController> extends NSViewControllerAllocator<T> {}
declare class MSFlashViewController extends NSViewController {
  alloc<T extends MSFlashViewController>(): MSFlashViewControllerAllocator<T>;
  static flashViewControllerWithMessage_closeBlock_helpBlock(message: NSString | string, closeBlock: MSFlashViewControllerBlock | null, helpBlock: MSFlashViewControllerBlock | null): MSFlashViewController;
}

class MSFlattenActionValidatorAllocator<T extends MSFlattenActionValidator> extends NSObjectAllocator<T> {}
declare class MSFlattenActionValidator extends NSObject {
  alloc<T extends MSFlattenActionValidator>(): MSFlattenActionValidatorAllocator<T>;
  static isValidForSelectedLayers(selectedLayers: MSLayerArray): boolean;
  static hasFlattenablePathInSelection(selectedLayers: MSLayerArray): boolean;
}

class MSForeignObjectCollectorAllocator<T extends MSForeignObjectCollector> extends NSObjectAllocator<T> {
  initWithProvider(provider: any): T;
}
declare class MSForeignObjectCollector extends NSObject {
  alloc<T extends MSForeignObjectCollector>(): MSForeignObjectCollectorAllocator<T>;
  buildCollectionWithFilter(filter: MSForeignObjectCollectionFilter | null): NSArray<any>;

  provider(): any;
}

declare interface IMSForeignObjectProvider {
  localObjectsForDocument(document: MSDocumentData): NSArray<any>;
  currentDocumentIsLibrary(library: MSAssetLibrary): boolean;
  masterObjectForInstance(instance: MSModelObject): MSShareableObject;
  masterIsOutOfSyncWithInstance(instance: MSModelObject): boolean;

  foreignObjects(): NSArray<any>;
  currentDocument(): MSDocumentData;
  libraryController(): MSAssetLibraryController;
  objectType(): MSShareableObjectType;
}

class MSForeignObjectMenuBuilderAllocator<T extends MSForeignObjectMenuBuilder> extends MSSortableObjectMenuBuilderAllocator<T> {
  initWithCollector_delegate(collector: MSForeignObjectCollector, delegate: any): T;
  initWithProvider_delegate(provider: any, delegate: any): T;
}
declare class MSForeignObjectMenuBuilder extends MSSortableObjectMenuBuilder {
  alloc<T extends MSForeignObjectMenuBuilder>(): MSForeignObjectMenuBuilderAllocator<T>;
  buildMenuItemsForMenu_withTarget_selector(menu: NSMenu, target: any, selector: string): NSArray<any>;
  buildMenuItemsForMenu_withAction(menu: NSMenu, action: MSAction): NSArray<any>;
  gatherSymbolsForMenus(): NSArray<any>;
  menuItemForLibrary_mainMenu_target_selector(library: MSAssetLibrary | null, mainMenu: boolean, target: any | null, selector: string | null): NSMenuItem;
  static filterForReplacingSymbolInstances(layers: NSArray<any> | any[]): MSForeignObjectCollectionFilter;

  filter(): MSForeignObjectCollectionFilter;
  setFilter(filter: MSForeignObjectCollectionFilter): void;
  requiresLocalSubmenu(): boolean;
  setRequiresLocalSubmenu(requiresLocalSubmenu: boolean): void;
  collector(): MSForeignObjectCollector;
}

class MSGestureRecognizerAllocator<T extends MSGestureRecognizer> extends NSObjectAllocator<T> {
  initWithTarget_action(target: any | null, action: string | null): T;
}
declare class MSGestureRecognizer extends NSObject {
  alloc<T extends MSGestureRecognizer>(): MSGestureRecognizerAllocator<T>;
  locationInLayer(layer: MSLayer | null): NSPoint;
  reset(): void;
  mouseDown_clickCount_modifierFlags(location: NSPoint, clickCount: NSUInteger, flags: NSEventModifierFlags): void;
  mouseUp_location(event: NSEvent, location: NSPoint): void;
  mouseDragged_modifierFlags(location: NSPoint, flags: NSEventModifierFlags): void;
  keyDown(event: NSEvent): void;
  keyUp_flags(c: unichar, flags: NSUInteger): void;
  flagsChanged(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  state(): NSGestureRecognizerState;
  setState(state: NSGestureRecognizerState): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSGestureRecognizerDelegate {
  gestureRecognizer_shouldAttemptToRecognizeAtPoint_modifierFlags(gestureRecognizer: MSGestureRecognizer, point: NSPoint, flags: NSEventModifierFlags): boolean;
}

class MSGridConstructorAllocator<T extends MSGridConstructor> extends NSObjectAllocator<T> {}
declare class MSGridConstructor extends NSObject {
  alloc<T extends MSGridConstructor>(): MSGridConstructorAllocator<T>;
  makeGridWithLayers_options(layers: MSLayerArray, options: MSMakeGridOptions): void;
}

declare type MSMakeGridOptions = {
  numberOfRows: NSUInteger
  numberOfColumns: NSUInteger
  horizontalPadding: NSInteger
  verticalPadding: NSInteger
  hasHorizontalPadding: boolean
  hasVerticalPadding: boolean
  skipFillingHoles: boolean
}

declare interface IMSHUDClient {
  hudSetMonitor(monitor: MSRenderMonitor): void;

  hudClientName(): NSString;
  hudDocumentData(): MSDocumentData;
}

declare interface IMSHUDOwner {

  hud(): MSHUDWindowController;
}

class MSHUDViewControllerAllocator<T extends MSHUDViewController> extends NSViewControllerAllocator<T> {}
declare class MSHUDViewController extends NSViewController {
  alloc<T extends MSHUDViewController>(): MSHUDViewControllerAllocator<T>;
}

class MSHUDWindowControllerAllocator<T extends MSHUDWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSHUDWindowController extends NSWindowController implements INSWindowDelegate {
  alloc<T extends MSHUDWindowController>(): MSHUDWindowControllerAllocator<T>;
  static makeHUD(): MSHUDWindowController;
  toggle(): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;

  isVisible(): boolean;
}

class MSHandleDrawingAllocator<T extends MSHandleDrawing> extends NSObjectAllocator<T> {}
declare class MSHandleDrawing extends NSObject {
  alloc<T extends MSHandleDrawing>(): MSHandleDrawingAllocator<T>;
  static drawRectAtPoint_ofType(aPoint: NSPoint, type: MSDotRectType): void;
  static drawBezier(bezier: NSBezierPath): void;
  static drawAtPoint_ofType_state(aPoint: NSPoint, type: MSHandleSize, state: MSHandleState): void;
  static drawGradientHandleAtPoint_color_selected(aPoint: NSPoint, aColor: NSColor | null, isSelected: boolean): void;
  static drawShadowForHover_inBlock(isHovering: boolean, block: BCVoidBlock): void;
  static drawWithTransformStruct_aroundPoint_usingBlock(tStruct: CHTransformStruct, point: NSPoint, block: Block): void;
  static zoomValue(): CGFloat;
  static setZoomValue(zoomValue: CGFloat): void;
  static resetZoomValue(): void;
}

declare enum MSHandleSize {
  MSHandleSizeSmall = 0,
  MSHandleSizeRegular = 1,
  MSHandleSizeHuge = 2,
}

declare enum MSHandleState {
  MSHandleStateNormal = 0,
  MSHandleStateHighlighted = 1 << 0,
  MSHandleStateHovering = 1 << 1,
  MSHandleStateSelected = 1 << 2,
  MSHandleStateRelatedToSelection = 1 << 4,
}

declare enum MSDotRectType {
  MSDotRectGradient,
  MSDotRectLocked,
}

declare enum MSVectorComponent {
  MSVectorComponentPoint,
  MSVectorComponentHandle1,
  MSVectorComponentHandle2,
  MSVectorComponentSegment = 5,
}

class MSHistoryAllocator<T extends MSHistory> extends NSObjectAllocator<T> {
  initWithInitialMoment(initMoment: MSMoment): T;
}
declare class MSHistory extends NSObject {
  alloc<T extends MSHistory>(): MSHistoryAllocator<T>;
  addMoment(newMoment: MSMoment): MSHistoryUpdate;
  addMomentWithTitle_documentData(title: NSString | string, documentData: MSImmutableDocumentData): MSHistoryUpdate;
  addMomentWithTitle_documentData_adaptability(newTitle: NSString | string, documentData: MSImmutableDocumentData, adaptability: MSMomentAdaptability): MSHistoryUpdate;
  revertToPreviousMoment(): boolean;
  progressToNextMoment(): boolean;
  commitCurrentMoment(): void;

  currentMoment(): MSMoment;
  previousMoment(): MSMoment;
  nextMoment(): MSMoment;
  canRevertToPreviousMoment(): boolean;
  canProgressToNextMoment(): boolean;
  allowsCoalescingOfMomentsCloseInTime(): boolean;
  setAllowsCoalescingOfMomentsCloseInTime(allowsCoalescingOfMomentsCloseInTime: boolean): void;
  numberOfMoments(): NSUInteger;
}

declare enum MSHistoryUpdate {
  MSHistoryUpdateNoChange = 0,
  MSHistoryUpdateAddedMoment,
  MSHistoryUpdateCoalescedMoment,
  MSHistoryUpdateAmendedMoment,
}

declare interface IMSHoverableItem {
  drawHoverWithZoom_color_cache(zoom: CGFloat, color: NSColor, cache: BCCache): void;
  canBeHoveredOnPage(page: MSPage): boolean;
  refreshOverlay(): void;

  hoveredLayer(): MSLayer;
}

class MSImageLayerImporterAllocator<T extends MSImageLayerImporter> extends NSObjectAllocator<T> {}
declare class MSImageLayerImporter extends NSObject {
  alloc<T extends MSImageLayerImporter>(): MSImageLayerImporterAllocator<T>;
  static layerWithContentsOfPath_mode(fileURL: NSURL, importPreference: MSPasteboardImagePreferMode): MSLayer;
}

declare enum MSPasteboardImagePreferMode {
  MSPasteboardImagePreferVectors,
  MSPasteboardImagePreferImages,
}

class MSImageSizeReducerAllocator<T extends MSImageSizeReducer> extends NSObjectAllocator<T> {}
declare class MSImageSizeReducer extends NSObject {
  alloc<T extends MSImageSizeReducer>(): MSImageSizeReducerAllocator<T>;
  static reduceImageSizeOfLayers_windowForSheet_completionBlock(layers: NSArray<any> | any[], windowForSheet: NSWindow | null, completionBlock: BCVoidBlock | null): void;
  static largestSizeForImagesMapTableFromOwners(layers: NSArray<any> | any[]): NSMapTable<any, any>;
}

class MSImmutableColorAllocator<T extends MSImmutableColor> extends _MSImmutableColorAllocator<T> {}
declare class MSImmutableColor extends _MSImmutableColor implements IMSColor {
  alloc<T extends MSImmutableColor>(): MSImmutableColorAllocator<T>;
  static colorWithNSColor(color: NSColor): MSImmutableColor;
  static colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): MSImmutableColor;
  static colorWithWhite_alpha(white: CGFloat, alpha: CGFloat): MSImmutableColor;
  static colorWithIntegerRed_green_blue(red: NSInteger, green: NSInteger, blue: NSInteger): MSImmutableColor;
  static colorWithIntegerRed_green_blue_alpha(red: NSInteger, green: NSInteger, blue: NSInteger, alpha: NSInteger): MSImmutableColor;
  static whiteColor(): MSImmutableColor;
  static blackColor(): MSImmutableColor;
  static availableRGBColorSpaces(): NSArray<any>;
  NSColorWithColorSpace(colorSpace: NSColorSpace): NSColor;
  newCGColorWithColorSpace(colorSpace: CGColorSpaceRef): CGColorRef;
  static getRed_green_blue_fromHexValue(red: CGFloat, green: CGFloat, blue: CGFloat, hexValue: NSString | string): void;
  static hexValueForRed_green_blue(red: CGFloat, green: CGFloat, blue: CGFloat): NSString;
  hexValue(): NSString;
  isWhite(): boolean;
  isBlack(): boolean;
  isGrayscale(): boolean;
  fuzzyIsEqual(other: MSImmutableColor): boolean;
  fuzzyIsEqual_precision(other: MSImmutableColor, precision: CGFloat): boolean;
  fuzzyIsEqualExcludingAlpha(other: MSImmutableColor): boolean;
  fuzzyIsEqualExcludingAlpha_precision(other: MSImmutableColor, precision: CGFloat): boolean;
  colorWithAlphaComponent(alpha: CGFloat): MSImmutableColor;
  stringValueWithAlpha(includeAlpha: boolean): NSString;
  stringValueWithAlpha_alphaMultiplication(includeAlpha: boolean, alphaMultiplication: CGFloat): NSString;
  static namedColor(name: NSString | string): MSImmutableColor;
  static colorWithSVGString(string: NSString | string): MSImmutableColor;
  svgRepresentation(): NSString;
  NSColorForContext(context: MSRenderingContext): NSColor;

  manifestComponents(): NSArray<any>;
  opaque(): boolean;
}

class MSImmutableLayerGroupAllocator<T extends MSImmutableLayerGroup> extends _MSImmutableLayerGroupAllocator<T> {}
declare class MSImmutableLayerGroup extends _MSImmutableLayerGroup implements IMSLayerGroup {
  alloc<T extends MSImmutableLayerGroup>(): MSImmutableLayerGroupAllocator<T>;
  influenceRectClipsToBounds(): boolean;
  includeChildrenInCalculatingStyleSize(): boolean;
  pathCombiningChildrenByApplyingBlock(block: Block): MSPath;
  constraintForLayer(layer: MSImmutableLayer): BCConstraint;
  addChildrenToElement_exporter(parentElement: NSXMLElement, exporter: SketchSVGExporter): void;

  mirrorExportScale(): CGFloat;
  mirrorViewPortSize(): CGSize;
  layers(): NSArray<any>;
}

declare interface IMSImporter extends NSObject {
  prepareToImportFromData(data: NSData): NSUInteger;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importIntoPage_name_progress(page: MSPage, name: NSString | string, progress: BCVoidBlock): void;
  finishImporting(): void;
  firstPhaseSubtitle(): NSString;
  secondPhaseSubtitleForValue_maximum(value: NSInteger, maximum: NSInteger): NSString;
  shouldExpandPages(): boolean;
  shouldCollapseSinglePage(): boolean;
  importAsLayer(): MSLayer;
}

class MSInspectorNumberFormatterAllocator<T extends MSInspectorNumberFormatter> extends NSNumberFormatterAllocator<T> {}
declare class MSInspectorNumberFormatter extends NSNumberFormatter {
  alloc<T extends MSInspectorNumberFormatter>(): MSInspectorNumberFormatterAllocator<T>;
  static standardFloatFormatter(): MSInspectorNumberFormatter;
  static standardIntegerFormatter(): MSInspectorNumberFormatter;
  static standardPercentFormatter(): MSInspectorNumberFormatter;
  static standardPercentFormatterWithoutPercentSign(): MSInspectorNumberFormatter;
}

declare interface IMSInspectorSection {
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
}

class MSInspectorValueAdaptorAllocator<T extends MSInspectorValueAdaptor> extends NSObjectAllocator<T> {
  initWithModelsController_valueGetter_valueSetter_modelKeyPathsToWatch(modelsController: NSArrayController, valueGetter: Block, valueSetter: Block, modelKeyPathsToWatch: NSArray<any> | any[]): T;
  initWithModelsController_valueGetter_valueSetter(modelsController: NSArrayController, valueGetter: Block, valueSetter: Block): T;
  initWithModelsController_modelKeyPath(modelsController: NSArrayController, keyPath: NSString | string): T;
}
declare class MSInspectorValueAdaptor extends NSObject {
  alloc<T extends MSInspectorValueAdaptor>(): MSInspectorValueAdaptorAllocator<T>;
  transformedValuesFromAdaptorValue_contexts_error(adaptorValue: AdaptorValueType, contextsOut: NSPointerArray, error: NSError): NSArray<any>;
  transformAdaptorValue_forModel_context_error(adaptorValue: AdaptorValueType, model: ModelType, context: any, error: NSError): ModelValueType;
  valuesDidChange(): void;
  addChangeObserver(observer: any): void;
  removeChangeObserver(observer: any): void;

  modelsController(): NSArrayController;
  value(): AdaptorValueType;
  setValue(value: AdaptorValueType): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  showsDefaultAlerts(): boolean;
  setShowsDefaultAlerts(showsDefaultAlerts: boolean): void;
  view(): NSView;
  setView(view: NSView): void;
}

declare type ModelType = any

declare type ModelValueType = any

declare type AdaptorValueType = any

declare enum MSInspectorValueAdaptorErrorCode {
  MSInspectorValueAdaptorErrorInvalidInput = 1,
}

declare interface IMSInspectorValueAdaptorChangeObserver {
  inspectorValueAdaptorDidChangeValue(adaptor: MSInspectorValueAdaptor): void;
}

declare interface IMSInspectorValueAdaptorDelegate {
  inspectorValueAdaptor_validateValue_forModel_context(adaptor: MSInspectorValueAdaptor, value: ModelValueType, model: any, context: any): boolean;
  inspectorValueAdaptorDidChangeValue(adaptor: MSInspectorValueAdaptor): void;
  inspectorValueAdaptor_didEncounterError(adaptor: MSInspectorValueAdaptor, error: NSError): void;
}

class MSLayerAllocator<T extends MSLayer> extends _MSLayerAllocator<T> {
  initWithFrame(frame: NSRect): T;
}
declare class MSLayer extends _MSLayer implements IMSLayer, INSCopying, IMSRectDelegate {
  alloc<T extends MSLayer>(): MSLayerAllocator<T>;
  static alignLayers_withMode_toKey_pixelFit(layerArray: MSLayerArray, mode: MSLayerAlignmentMode, key: NSString | string, shouldPixelFit: boolean): void;
  hudDescription(): NSString;
  layerDidResizeFromInspector(axis: BCAxis): void;
  boundsOfParentLayer(): NSRect;
  minimumAdjustedRectForValue_axis_anchor(value: CGFloat, axis: BCAxis, anchor: BCCorner): CGRect;
  layersByConvertingToOutlines(): NSArray<any>;
  canConvertToOutlines(): boolean;
  replaceWithInstanceOfSymbol(symbol: MSSymbolMaster): MSSymbolInstance;
  snapItemClass(): any;
  canSnap_toLayer(snapType: MSSnapType, otherLayer: MSLayer): boolean;
  styleForBooleanOperation(): MSStyle;
  supportsInnerOuterBorders(): boolean;
  supportsMultipleShadows(): boolean;
  changeColor(sender: any): void;
  displayName(): NSString;
  parentForInsertingLayers(): MSLayerGroup;
  canCutSegments(): boolean;
  possiblyFixRectangleBorderBeforeCut(): void;
  cutBezierSegmentAtIndex(index: NSUInteger): void;
  CSSAttributeString(): NSString;
  CSSAttributes(): NSArray<any>;
  resetConstraints(): void;
  replaceFonts(fontReplacements: NSDictionary<any, any> | {[key: string]: any}): void;
  selectionHitTest_options_zoomValue(point: NSPoint, options: MSLayerSelectionOptions, zoomValue: CGFloat): MSHitTestResult;
  containsPoint_options_zoomValue(point: NSPoint, options: MSLayerSelectionOptions, zoomValue: CGFloat): boolean;
  hitTestRect_options(selectionRect: NSRect, options: MSLayerSelectionOptions): boolean;
  layoutDirection(): NSUserInterfaceLayoutDirection;
  applyOverrides_document(overrides: NSArray<any> | any[], document: MSImmutableDocumentData): void;
  applyOverride_document(overrideValue: MSImmutableOverrideValue, document: MSImmutableDocumentData): void;
  static userVisibleRotationForRotation(r: CGFloat): CGFloat;
  applyRotation_explicitRotationCenter(rotation: CGFloat, rotationCenter: NSValue | null): void;
  applyUserVisibleRotation_explicitRotationCenter(userVisibleRotation: CGFloat, rotationCenter: NSValue | null): void;
  resetSharedStyle(): void;
  updateSharedStyleToMatchSelf(): void;
  static layerWithPath(path: MSPath): MSStyledLayer;
  static makeLayerNamesUnique_withOptions(layers: NSArray<any> | any[], options: MSLayerRenameOptions): void;
  makeNameUniqueWithOptions(options: MSLayerRenameOptions): void;
  makeNameUniqueInRoot_withOptions(root: any, options: MSLayerRenameOptions): void;
  rootForNameUniquing(): any;
  frameForTransforms(): NSRect;
  absoluteRect(): MSAbsoluteRect;
  setWidthRespectingProportions(newWidth: CGFloat): void;
  setHeightRespectingProportions(newHeight: CGFloat): void;
  calculateProportions(): void;
  makeOriginIntegral(): void;
  makeRectIntegral(): void;
  isRectIntegral(): boolean;
  moveBySuggestedOffset(offset: CGVector): void;
  selectionCornerMaskWithZoomValue(zoomValue: CGFloat): NSUInteger;
  refreshOverlay(): void;
  refreshOverlayWithAbsoluteMargins(size: NSSize): void;
  refreshOverlayInRect(rect: NSRect): void;
  absoluteInfluenceRect(): NSRect;
  alignmentRectInCoordinateSpace_options(coordinateSpace: any, options: MSAlignmentRectOptions): NSRect;
  boundsRectForAlignment(): NSRect;
  select_byExtendingSelection(flag: boolean, expand: boolean): void;
  select_byExtendingSelection_showSelection(shouldSelect: boolean, expand: boolean, showSelection: boolean): void;
  containsSelectedItemIncludingSelf(includeSelf: boolean): boolean;
  isSelectableOnCanvasWithOptions(options: MSLayerSelectionOptions): boolean;
  isOpenForSelectionWithOptions(options: MSLayerSelectionOptions): boolean;
  limitsSelectionToBounds(): boolean;
  selectableLayersWithOptions(options: MSLayerSelectionOptions): NSArray<any>;
  parentPage(): MSPage;
  parentShape(): MSShapeGroup;
  parentSymbol(): MSSymbolMaster;
  parentRoot(): MSLayerGroup;
  removeFromParent(): void;
  ancestorsAndSelf(): NSArray<any>;
  ancestors(): NSArray<any>;
  canContainLayer(layer: MSLayer): boolean;
  adjustmentHandleAtPoint_zoomScale_resizing(point: NSPoint, zoom: CGFloat, resizing: boolean): BCCorner;
  transform(): NSAffineTransform;
  ancestorsAndSelfTransforms(): NSArray<any>;
  concatAncestorsAndSelfTransforms(): void;
  canBeTransformed(): boolean;
  canRotate(): boolean;
  canScale(): boolean;
  hasEnabledBackgroundBlur(): boolean;
  moveInLayerTreeInBlock(block: BCVoidBlock): void;
  multiplyBy(amount: CGFloat): void;
  layerDidEndResize(): void;
  layerDidResizeFromRect_corner(rect: NSRect, corner: BCCorner): void;
  calculateMinimumSize(): NSSize;
  allSymbolInstancesInChildren(): NSSet<any>;
  isLine(): boolean;
  resetFlow(): void;
  isPartOfClippingMask(): boolean;
  hasClippingMask(): boolean;
  candidatesForMasking(): NSArray<any>;
  closestClippingLayer(): MSShapeGroup;
  followMaskChainForLayerAtIndex_usingBlock(index: NSUInteger, block: Block): void;
  addChangeObserver(observer: any): void;
  removeChangeObserver(observer: any): void;
  enumeratorWithOptions(options: MSLayerEnumeratorFlags): MSLayerEnumerator<any>;
  configureBackgroundOfRequest(request: MSExportRequest): void;
  adjustAfterInsert(): void;
  handleDoubleClick(): boolean;
  handlerClass(): any;
  shouldRefreshOverlayForFlows(): boolean;
  inspectorSections(): NSArray<any>;
  writeBitmapImageToFile(path: NSString | string): void;
  shouldDrawSelection(): boolean;
  shouldDrawSelectionStroke(): boolean;
  cornerRectType(): MSDotRectType;
  shouldFlattenAfterRotate(): boolean;
  copyWithZone(zone: NSZone | null): any;
  rect_didChangeFromRect(rect: MSRect, oldRect: NSRect): void;
  copyWithZone(zone: NSZone | null): any;
  rect_didChangeFromRect(rect: MSRect, oldRect: NSRect): void;

  canChangeBooleanOperation(): boolean;
  shareableObjectType(): MSShareableObjectType;
  sharedMaster(): MSShareableObject;
  hasFixedEdges(): boolean;
  setHasFixedEdges(hasFixedEdges: boolean): void;
  dataSupplierIdentifier(): NSString;
  setDataSupplierIdentifier(dataSupplierIdentifier: NSString | string): void;
  userVisibleRotation(): CGFloat;
  isSharedStyleOutOfSync(): boolean;
  sharedStyle(): MSSharedStyle;
  setSharedStyle(sharedStyle: MSSharedStyle): void;
  constrainProportions(): boolean;
  setConstrainProportions(constrainProportions: boolean): void;
  proportions(): CGFloat;
  setProportions(proportions: CGFloat): void;
  rect(): CGRect;
  setRect(rect: CGRect): void;
  bounds(): CGRect;
  origin(): CGPoint;
  setOrigin(origin: CGPoint): void;
  center(): CGPoint;
  setCenter(center: CGPoint): void;
  isExpanded(): boolean;
  absolutePosition(): NSPoint;
  setAbsolutePosition(absolutePosition: NSPoint): void;
  isSelected(): boolean;
  parentArtboard(): MSArtboardGroup;
  ancestry(): MSImmutableLayerAncestry;
  unitCoordinateSpace(): any;
  rulerCoordinateSpace(): any;
  usedStyle(): MSStyle;
  transformStruct(): CHTransformStruct;
  setTransformStruct(transformStruct: CHTransformStruct): void;
}

declare enum MSLayerAlignmentMode {
  MSLayerAlignToLayers,
  MSLayerAlignToParentArtboard,
}

declare type MSLayerListItem = NSObject

class MSStyledLayerAllocator<T extends MSStyledLayer> extends _MSStyledLayerAllocator<T> {}
declare class MSStyledLayer extends _MSStyledLayer implements IMSStyledLayer {
  alloc<T extends MSStyledLayer>(): MSStyledLayerAllocator<T>;
  prepareAsMask(): void;
  static layerWithImageFromPasteboard(pasteboard: NSPasteboard): MSStyledLayer;
  static layerWithImageFromFileURL(fileURL: NSURL): MSStyledLayer;
  copyStyleToPasteboard(): NSPasteboard;
  copyStyleToPasteboard(pasteboard: NSPasteboard): void;
  writeStyleToPasteboard(pasteboard: NSPasteboard): void;
  static pasteStyleFromPasteboardOnLayers_document(styledLayers: NSArray<any> | any[], document: MSDocumentData): void;
  static pasteStyleFromPasteboard_onLayers_document(pasteboard: NSPasteboard, styledLayers: NSArray<any> | any[], document: MSDocumentData): void;
  static pasteStyleDict_onLayers_document(style: NSDictionary<any, any> | {[key: string]: any}, styledLayers: NSArray<any> | any[], document: MSDocumentData): void;
  static supportedPasteboardTypesForStyleCopying(): NSArray<any>;
  layerStyleDidChange(): void;
  sharedObject(): MSSharedObject;
  setStyleByPreservingSharedObjectReference(style: MSStyle): void;
  hasMarkers(): boolean;
  applyPropertiesToBezier(bezier: NSBezierPath): void;
}

class MSLayerGroupAllocator<T extends MSLayerGroup> extends _MSLayerGroupAllocator<T> {}
declare class MSLayerGroup extends _MSLayerGroup implements IMSLayerGroup {
  alloc<T extends MSLayerGroup>(): MSLayerGroupAllocator<T>;
  prepareAsMaskContainer(): void;
  enumerateLayersAvoidingFaultingWithOptions_passingTest_usingBlock(options: MSLayerEnumeratorFlags, predicate: MSLayerIteratorTestBlock, enumeratorBlock: MSLayerIteratorBlock): void;
  ungroup(): NSArray<any>;
  ungroupSingleChildDescendentGroups(): void;
  applyTransformsToLayers(layers: NSArray<any> | any[]): void;
  static groupWithLayer(layer: MSLayer): MSLayerGroup;
  static groupWithLayers(layers: MSLayerArray): MSLayerGroup;
  disableAutomaticScalingInBlock(block: BCVoidBlock): void;
  static groupBoundsForContainer(containter: any): NSRect;
  static groupBoundsShouldBeIntegral(): boolean;
  deselectLayerAndParent(): void;
  resizeToFitChildrenWithOption(resizeOption: MSLayerGroupResizeOption): boolean;
  insertLayer_afterLayerOrAtEnd(layer: MSLayer, after: MSLayer | null): void;
  resizeChildrenWithOldSize(oldSize: NSSize): void;
  shouldStripShadowsAndInnerShadow(): boolean;

  isAutomaticScalingEnabled(): boolean;
  layers(): NSArray<any>;
}

class MSShapePathLayerAllocator<T extends MSShapePathLayer> extends _MSShapePathLayerAllocator<T> {}
declare class MSShapePathLayer extends _MSShapePathLayer implements IMSPathLayer {
  alloc<T extends MSShapePathLayer>(): MSShapePathLayerAllocator<T>;
  static layerWithPath(path: MSPath): MSShapePathLayer;
  static shapeWithRect(rect: NSRect): MSRectangleShape;
  resetPoints(): void;
  resetPointsBasedOnUserInteraction(): void;
  editable(): boolean;
  simplify(): void;
  reversePath(): void;
  adjustFrameAfterEditIntegral(makeIntegral: boolean): void;
  didEdit(): void;
  static performBatchEdits(edits: Block): void;
  isNearlyEmpty(): boolean;
  pointCenteredAfterPointIndex(pointIndex: NSUInteger): NSPoint;
  indexOfSegmentAtPoint_tolerance(point: NSPoint, tolerance: NSSize): NSUInteger;
  flatten(): void;
  flattenedLayer(): MSShapePathLayer;
  pointsAroundIndex(index: NSUInteger): NSArray<any>;
  isRectangle(): boolean;
  isPolygon(): boolean;
  adjustGeometryToBoundsRect(targetBounds: NSRect): void;
  insertionCursor(): NSCursor;
  simplify(): void;
  reversePath(): void;
  simplify(): void;
  reversePath(): void;

  isEditing(): boolean;
  setIsEditing(isEditing: boolean): void;
  hasRoundedCorners(): boolean;
  numberOfCurvePoints(): NSUInteger;
  canFlatten(): boolean;
  pathInFrame(): MSPath;
  setPathInFrame(pathInFrame: MSPath): void;
  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  edited(): boolean;
  setEdited(edited: boolean): void;
}

class MSSliceLayerAllocator<T extends MSSliceLayer> extends _MSSliceLayerAllocator<T> {}
declare class MSSliceLayer extends _MSSliceLayer implements IMSLayerWithMutableBackgroundColor, IMSColorConvertible {
  alloc<T extends MSSliceLayer>(): MSSliceLayerAllocator<T>;
  static sliceLayerFromLayer(layer: MSLayer): MSSliceLayer;
  convertColorsUsing(converter: any): void;
  convertColorsUsing(converter: any): void;

  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
}

class MSHotspotLayerAllocator<T extends MSHotspotLayer> extends _MSHotspotLayerAllocator<T> {}
declare class MSHotspotLayer extends _MSHotspotLayer {
  alloc<T extends MSHotspotLayer>(): MSHotspotLayerAllocator<T>;
  static hotspotLayerFromLayer(layer: MSLayer): MSHotspotLayer;
}

class MSShapeGroupAllocator<T extends MSShapeGroup> extends _MSShapeGroupAllocator<T> {}
declare class MSShapeGroup extends _MSShapeGroup implements IMSShapeGroup, IMSPathLayer {
  alloc<T extends MSShapeGroup>(): MSShapeGroupAllocator<T>;
  canProbablyFlatten(): boolean;
  canFlatten(): boolean;
  static shapeWithBooleanOperation_onLayers(operation: MSBooleanOperation, layers: MSLayerArray): MSShapeGroup;
  changeInnerOuterBordersIfHasOpenPaths(): void;
  static layerWithPath(path: MSPath): MSShapeGroup;
  isHorizontalLine(): boolean;
  isVerticalLine(): boolean;
  simplify(): void;
  flatten(): MSStyledLayer;
  moveTransformsToChildren(): void;
  setEdited(flag: boolean): void;
  makeLinePixelAligned(): void;
  simplify(): void;
  reversePath(): void;
  simplify(): void;
  reversePath(): void;

  pathInFrame(): MSPath;
  setPathInFrame(pathInFrame: MSPath): void;
  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  hasMarkers(): boolean;
  isPartOfClippingMask(): boolean;
  edited(): boolean;
  setEdited(edited: boolean): void;
}

class MSSymbolMasterAllocator<T extends MSSymbolMaster> extends _MSSymbolMasterAllocator<T> {}
declare class MSSymbolMaster extends _MSSymbolMaster implements IBCSortable {
  alloc<T extends MSSymbolMaster>(): MSSymbolMasterAllocator<T>;
  static convertArtboardToSymbol(artboard: MSArtboardGroup): MSSymbolMaster;
  static convertSymbolToArtboard(symbol: MSSymbolMaster): MSArtboardGroup;
  newSymbolInstance(): MSSymbolInstance;
  copyWithIDMapping(idMap: NSMutableDictionary<any, any> | {[key: string]: any}): MSSymbolMaster;
  canInsertInstanceIntoGroupWithoutInfiniteRecursion(group: MSLayerGroup): boolean;
  hasInstances(): boolean;
  ensureSymbolIDUniqueInDocument(doc: MSDocumentData): boolean;
  detachAllInstances(): void;
  removeFromParentAndDetachAllInstances(): void;
  isSafeToDelete(): boolean;
  ancestorIDsForLayerNamed(layerName: NSString | string): NSArray<any>;

  availableOverrides(): NSArray<any>;
  changeIdentifier(): NSInteger;
  setChangeIdentifier(changeIdentifier: NSInteger): void;
  isDirty(): boolean;
  setIsDirty(isDirty: boolean): void;
  allInstances(): NSArray<any>;
  allInfluencedInstances(): NSArray<any>;
  nestedSymbols(): NSSet<any>;
  name(): NSString;
}

class MSImmutableLayerAllocator<T extends MSImmutableLayer> extends _MSImmutableLayerAllocator<T> {}
declare class MSImmutableLayer extends _MSImmutableLayer implements IMSLayer, IMSLayerTraits {
  alloc<T extends MSImmutableLayer>(): MSImmutableLayerAllocator<T>;
  absoluteRectForAncestorGroups(ancestors: NSArray<any> | any[]): NSRect;
  absoluteInfluenceRectForAncestorGroups_document(ancestors: NSArray<any> | any[], doc: MSImmutableDocumentData): NSRect;
  influenceRectForFrameInDocument(doc: MSImmutableDocumentData | null): NSRect;
  influenceRectForBoundsInDocument(doc: MSImmutableDocumentData | null): NSRect;
  influenceRectForFrameInDocument_visitedSymbols(doc: MSImmutableDocumentData | null, visitedSymbols: NSSet<any> | null): NSRect;
  influenceRectForBoundsInDocument_visitedSymbols(doc: MSImmutableDocumentData | null, visitedSymbols: NSSet<any> | null): NSRect;
  calculateInfluenceRectForBoundsInDocument_visitedSymbols(doc: MSImmutableDocumentData | null, visitedSymbols: NSSet<any> | null): NSRect;
  influenceRectForBoundsOrCalculateInBlock(creatorBlock: Block): NSRect;
  absoluteOverlayInfluenceRectForAncestorGroups(ancestors: NSArray<any> | any[]): NSRect;
  bezierBoundsInAbsoluteCoordinatesWithAncestors(ancestors: NSArray<any> | any[]): MSPath;
  transformRectToParentCoordinates(rect: NSRect): NSRect;
  canSkipAdvancedClipForStrokes(): boolean;
  isLine(): boolean;
  descendantsToLayerWithID(objectID: NSString | string): NSArray<any>;
  defaultValueForOverridePoint_relatedOverrides_document(point: MSOverridePoint, relatedOverrides: NSArray<any> | any[], document: MSImmutableDocumentData): any;
  canOverridePoint(point: MSOverridePoint): boolean;
  overridePointsWithParent_overrides_document(parent: MSOverridePoint | null, overrides: NSArray<any> | any[], document: MSImmutableDocumentData): NSArray<any>;
  enumeratorWithOptions(options: MSLayerEnumeratorFlags): MSLayerEnumerator<any>;
  renderBitmapEffects(image: CIImage): CIImage;
  pathForRenderingInBoundsInDocument_cache(doc: MSImmutableDocumentData, cache: BCCache): MSPath;
  shouldRenderInTransparencyLayer(): boolean;
  transparencyLayerUseRectCondition(): MSTransparencyRectangleOption;
  shouldSkipDrawingInContext(context: MSRenderingContext): boolean;
  configureBackgroundOfRequest(request: MSExportRequest): void;
  requiresPathDefinition(exporter: SketchSVGExporter): boolean;
  writeSVGToElement_withExporter(element: NSXMLElement, exporter: SketchSVGExporter): void;
  addTransformAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;
  relativeRectWithExporter(exporter: SketchSVGExporter): NSRect;
  addPathDefinitionToDocument(exporter: SketchSVGExporter): void;
  simplifyPathElement_exporter_inset(element: NSXMLElement, exporter: SketchSVGExporter, inset: CGFloat): void;
  addGroupContentToElement_attributes_exporter(parentElement: NSXMLElement, attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): NSXMLElement;
  addDefaultFillAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;
  shouldIncludeInSVGExport(exporter: SketchSVGExporter): boolean;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;
  traits(): MSTraits;
  traits(): MSTraits;

  center(): NSPoint;
  transform(): NSAffineTransform;
  frameForTransforms(): NSRect;
  hasEnabledBackgroundBlur(): boolean;
  traits(): MSTraits;
  isLayerExportable(): boolean;
  shouldBeIncludedInParentPath(): boolean;
  influenceRectForFrame(): NSRect;
  influenceRectEdgePaddingsThatCascadeToContainedLayers(): BCEdgePaddings;
  influenceRectEdgePaddingsThatDoNotCascade(): BCEdgePaddings;
  hasClippingMask(): boolean;
  canBreakMaskChain(): boolean;
  fontNames(): NSSet<any>;
  unavailableFontNames(): NSSet<any>;
  dataSupplierIdentifier(): NSString;
}

class MSImmutableStyledLayerAllocator<T extends MSImmutableStyledLayer> extends _MSImmutableStyledLayerAllocator<T> {}
declare class MSImmutableStyledLayer extends _MSImmutableStyledLayer implements IMSStyledLayer {
  alloc<T extends MSImmutableStyledLayer>(): MSImmutableStyledLayerAllocator<T>;
  bezierPathForStartDecorationOnPath(bezier: MSPath): MSPath;
  bezierPathForEndDecorationOnPath(bezier: MSPath): MSPath;
  static cacheDecorations(): void;
  hasMarkers(): boolean;
  applyPropertiesToBezier(bezier: NSBezierPath): void;
  prepareDrawingInContext_inBlock(context: MSRenderingContext, block: BCVoidBlock): void;
  fillPathWithDecorations(pathInOut: MSPath): MSPath;
  fillStyleForDecoratedPath(): MSImmutableStyle;
  strokeStyleForDecoratedPath(): MSImmutableStyle;
  pathWithExporter_border(exporter: SketchSVGExporter, border: MSImmutableStyleBorder | null): MSPath;

  decoratedPathInBounds(): MSPath;
  allowsBlur(): boolean;
  shouldRasterize(): boolean;
}

class MSImmutableShapeGroupAllocator<T extends MSImmutableShapeGroup> extends _MSImmutableShapeGroupAllocator<T> {}
declare class MSImmutableShapeGroup extends _MSImmutableShapeGroup implements IMSShapeGroup, IMSImmutablePathLayer {
  alloc<T extends MSImmutableShapeGroup>(): MSImmutableShapeGroupAllocator<T>;

  hasMarkers(): boolean;
  isPartOfClippingMask(): boolean;
  decoratedPathInBounds(): MSPath;
  style(): MSImmutableStyle;
}

class MSImmutableShapePathLayerAllocator<T extends MSImmutableShapePathLayer> extends _MSImmutableShapePathLayerAllocator<T> {}
declare class MSImmutableShapePathLayer extends _MSImmutableShapePathLayer implements IMSImmutablePathLayer {
  alloc<T extends MSImmutableShapePathLayer>(): MSImmutableShapePathLayerAllocator<T>;
  migratePropertiesFromShapeGroup(shape: MSImmutableShapeGroup): void;
  migrateByTakingStyleFrom(shape: MSImmutableShapeGroup): void;

  isEditing(): boolean;
  usedStyle(): MSImmutableStyle;
  isPolygon(): boolean;
  isPolyline(): boolean;
  isRectangle(): boolean;
  numberOfCurvePoints(): NSUInteger;
  decoratedPathInBounds(): MSPath;
  hasMarkers(): boolean;
  style(): MSImmutableStyle;
}

class MSImmutableSliceLayerAllocator<T extends MSImmutableSliceLayer> extends _MSImmutableSliceLayerAllocator<T> {}
declare class MSImmutableSliceLayer extends _MSImmutableSliceLayer implements IMSLayerWithBackgroundColor {
  alloc<T extends MSImmutableSliceLayer>(): MSImmutableSliceLayerAllocator<T>;
  immutableBackgroundColor(): MSImmutableColor;
  immutableBackgroundColor(): MSImmutableColor;

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
}

class MSImmutableHotspotLayerAllocator<T extends MSImmutableHotspotLayer> extends _MSImmutableHotspotLayerAllocator<T> {}
declare class MSImmutableHotspotLayer extends _MSImmutableHotspotLayer {
  alloc<T extends MSImmutableHotspotLayer>(): MSImmutableHotspotLayerAllocator<T>;
}

declare interface IMSLayerPreviewability {
  selectedPreviewTemplateImage(): NSImage;
  unselectedPreviewTemplateImage(): NSImage;
  contextualMenuPreviewTemplateImage(): NSImage;

  badgeType(): MSLayerPreviewBadgeType;
}

declare interface IMSImmutableLayerPreviewability {
  previewImagesRequireRefreshWithDocumentData_forOwner(documentData: MSImmutableDocumentData, owner: any): boolean;
  refreshPreviewImagesWithDocumentData_forOwner(documentData: MSImmutableDocumentData, owner: any): void;
}

class MSLayerArrayAllocator<T extends MSLayerArray> extends NSObjectAllocator<T> {
  initWithLayers(layers: NSArray<any> | any[]): T;
}
declare class MSLayerArray extends NSObject implements IMSLayerContainment, INSFastEnumeration {
  alloc<T extends MSLayerArray>(): MSLayerArrayAllocator<T>;
  addStylePartsOfType(type: MSStylePartType): NSArray<any>;
  removeUnusedStylePartsOfType(type: MSStylePartType): void;
  copyByGivingNewObjectIDs(): MSLayerArray;
  static arrayWithLayer(layer: MSLayer | null): MSLayerArray;
  static arrayWithLayers(layers: NSArray<any> | any[]): MSLayerArray;
  static emptyArray(): MSLayerArray;
  parentOfFirstLayer(): MSLayerGroup;
  uniqueParents(): MSLayerArray;
  effectivePage(): MSPage;
  effectiveArtboard(): MSArtboardGroup;
  layerToInsertAfter(): MSLayer;
  commonArtboard(): MSArtboardGroup;
  map(block: Block): MSLayerArray;
  filter(block: MSLayerFilterBlock): MSLayerArray;
  sortedArrayByUsingComparator(comparator: Block): MSLayerArray;
  containedLayers(): NSArray<any>;
  containedLayersCount(): NSUInteger;
  firstLayer(): any;
  lastLayer(): any;
  containsNoOrOneLayers(): boolean;
  containsLayers(): boolean;
  containsOneLayer(): boolean;
  containsMultipleLayers(): boolean;
  layerAtIndex(i: NSUInteger): any;
  indexOfLayer(aLayer: any): NSUInteger;
  enumerateLayers(block: MSLayerSimpleEnumeratorBlock): void;
  enumerateLayersWithOptions_block(options: MSLayerEnumeratorOptions, block: MSLayerEnumeratorBlock): boolean;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  containedLayers(): NSArray<any>;
  containedLayersCount(): NSUInteger;
  firstLayer(): any;
  lastLayer(): any;
  containsNoOrOneLayers(): boolean;
  containsLayers(): boolean;
  containsOneLayer(): boolean;
  containsMultipleLayers(): boolean;
  layerAtIndex(i: NSUInteger): any;
  indexOfLayer(aLayer: any): NSUInteger;
  enumerateLayers(block: MSLayerSimpleEnumeratorBlock): void;
  enumerateLayersWithOptions_block(options: MSLayerEnumeratorOptions, block: MSLayerEnumeratorBlock): boolean;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
}

class MSLayerFlattenerAllocator<T extends MSLayerFlattener> extends NSObjectAllocator<T> {}
declare class MSLayerFlattener extends NSObject {
  alloc<T extends MSLayerFlattener>(): MSLayerFlattenerAllocator<T>;
  flattenLayers(layers: MSLayerArray): void;
  imageFromLayers_immutablePage_immutableDoc(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData): NSImage;
  imageFromLayers_immutablePage_immutableDoc_includeArtboardBackground(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData, includeArtboardBackground: boolean): NSImage;
  trimmedRectFromLayers_immutablePage_immutableDoc(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData): NSRect;
  trimmedRectFromLayers_immutablePage_immutableDoc_includeArtboardBackground(layers: MSLayerArray, immutablePage: MSImmutablePage, immutableDoc: MSImmutableDocumentData, includeArtboardBackground: boolean): NSRect;
  bitmapFromRect_fromLayers_withImage(bitmapRect: NSRect, layers: MSLayerArray, image: NSImage): MSBitmapLayer;
}

class MSLayerListControllerAllocator<T extends MSLayerListController> extends MSSidebarListControllerAllocator<T> {}
declare class MSLayerListController extends MSSidebarListController implements IBCOutlineViewDataSource, IBCOutlineViewDelegate {
  alloc<T extends MSLayerListController>(): MSLayerListControllerAllocator<T>;
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
}

class MSLayerSelectorAllocator<T extends MSLayerSelector> extends NSObjectAllocator<T> {}
declare class MSLayerSelector extends NSObject {
  alloc<T extends MSLayerSelector>(): MSLayerSelectorAllocator<T>;
  updateSelectionWithRect_page_extendSelection_options(selectionRect: NSRect, page: MSPage, extend: boolean, options: MSLayerSelectionOptions): void;

  initialSelection(): MSLayerArray;
  setInitialSelection(initialSelection: MSLayerArray): void;
}

class MSStyleAllocator<T extends MSStyle> extends _MSStyleAllocator<T> {}
declare class MSStyle extends _MSStyle implements IMSSharedObjectInstance, INSCopying {
  alloc<T extends MSStyle>(): MSStyleAllocator<T>;
  multiplyBy(size: CGFloat): void;
  enabledFills(): NSArray<any>;
  enabledBorders(): NSArray<any>;
  enabledShadows(): NSArray<any>;
  enabledInnerShadows(): NSArray<any>;
  firstEnabledBorder(): MSStyleBorder;
  firstEnabledFill(): MSStyleFill;
  firstEnabledShadow(): MSStyleShadow;
  disableAllBorders(): void;
  disableAllFills(): void;
  disableAllShadows(): void;
  disableAllInnerShadows(): void;
  hasTextStyle(): boolean;
  parentLayer(): MSStyledLayer;
  supportsAdvancedBorderSettings(): boolean;
  stylePartsOfType(type: MSStylePartType): NSArray<any>;
  addStylePartOfType(type: MSStylePartType): MSStylePart;
  type(): MSSharedStyleType;
  syncWithTemplateInstance(instance: any): void;
  copyWithZone(zone: NSZone | null): any;
  type(): MSSharedStyleType;
  syncWithTemplateInstance(instance: any): void;
  copyWithZone(zone: NSZone | null): any;

  primitiveTextStyle(): MSTextStyle;
  setPrimitiveTextStyle(primitiveTextStyle: MSTextStyle): void;
  primitiveSharedObjectID(): NSString;
  setPrimitiveSharedObjectID(primitiveSharedObjectID: NSString | string): void;
  hasBlending(): boolean;
  hasMarkers(): boolean;
  hasEnabledBackgroundBlur(): boolean;
  hasEnabledBorder(): boolean;
  hasEnabledFill(): boolean;
  hasEnabledShadow(): boolean;
  hasMoreThanOneEnabledFill(): boolean;
  thickestInnerStroke(): CGFloat;
  thickestStroke(): CGFloat;
  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
}

class MSTextStyleAllocator<T extends MSTextStyle> extends _MSTextStyleAllocator<T> {}
declare class MSTextStyle extends _MSTextStyle {
  alloc<T extends MSTextStyle>(): MSTextStyleAllocator<T>;
  generatePreviewWithText_imageSize_previewSize_colorSpace_backingScale_completionBlock(text: NSString | string, imageSize: CGSize, previewSize: CGSize, colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): void;
  static styleWithAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): MSTextStyle;
  syncOwningTextLayerWithThisStyle(): void;
  updateAttributesWithoutSyncingOwningTextLayer(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  resetDecodedAttributes(): void;

  attributes(): NSDictionary<any, any>;
  setAttributes(attributes: NSDictionary<any, any> | {[key: string]: any}): void;
  isRequiredFontAvailable(): boolean;
  fontPostscriptName(): NSString;
}

class MSLayoutAnchorAllocator<T extends MSLayoutAnchor> extends NSObjectAllocator<T> {
  initWithItem_attribute(item: any, attribute: MSLayoutAttribute): T;
}
declare class MSLayoutAnchor extends NSObject {
  alloc<T extends MSLayoutAnchor>(): MSLayoutAnchorAllocator<T>;

  item(): any;
  attribute(): MSLayoutAttribute;
  axis(): BCAxis;
}

class MSLayoutPositionAllocator<T extends MSLayoutPosition> extends MSLayoutAnchorAllocator<T> {}
declare class MSLayoutPosition extends MSLayoutAnchor {
  alloc<T extends MSLayoutPosition>(): MSLayoutPositionAllocator<T>;
  static positionAnchorWithLine_inLayer_attribute(line: BCOrthogonalLine, layer: MSLayer, attribute: MSLayoutAttribute): MSLayoutPosition;
  positionInLayer(layer: MSLayer | null): CGFloat;
  snappingTargetInLayer(layer: MSLayer | null): MSSnappingTarget;
  rectBySnappingToPosition_oldFrame_mayResize(position: CGFloat, oldFrame: NSRect, resize: boolean): NSRect;
  static snapPoint_toLines_onAxis_margin(point: CGPoint, lines: NSArray<any> | any[], axis: BCAxis, margin: CGFloat): CGPoint;

  snapTag(): MSSnapTag;
  setSnapTag(snapTag: MSSnapTag): void;
}

class MSLayoutDimensionAllocator<T extends MSLayoutDimension> extends MSLayoutAnchorAllocator<T> {}
declare class MSLayoutDimension extends MSLayoutAnchor {
  alloc<T extends MSLayoutDimension>(): MSLayoutDimensionAllocator<T>;
}

declare enum MSSnapTag {
  MSSnapAll = 0,
  MSSnapEdge = 1,
  MSSnapBaseline = 3,
}

class MSLayoutGridAllocator<T extends MSLayoutGrid> extends _MSLayoutGridAllocator<T> {}
declare class MSLayoutGrid extends _MSLayoutGrid {
  alloc<T extends MSLayoutGrid>(): MSLayoutGridAllocator<T>;
  totalNumberOfGutters(): NSInteger;
  determineAppropriateColumnWidth(): void;
}

class MSLayoutRelationshipAllocator<T extends MSLayoutRelationship> extends NSObjectAllocator<T> {
  initWithAnchor_anchor(anchor1: MSLayoutAnchor, anchor2: MSLayoutAnchor | null): T;
  initWithItem_attribute_item_attribute(item1: any, attr1: MSLayoutAttribute, item2: any | null, attr2: MSLayoutAttribute): T;
  initWithFirstItem_attribute_secondAnchor(item1: any, attr1: MSLayoutAttribute, anchor2: MSLayoutAnchor | null): T;
}
declare class MSLayoutRelationship extends NSObject {
  alloc<T extends MSLayoutRelationship>(): MSLayoutRelationshipAllocator<T>;
  static dimensionMeasurementWithItem_axis(item: any, axis: BCAxis): MSLayoutRelationship;
  static spacingMeasurementWithItem_toItem_onAxis(firstItem: any, secondItem: any, axis: BCAxis): MSLayoutRelationship;

  firstAnchor(): MSLayoutAnchor;
  firstItem(): any;
  firstAttribute(): MSLayoutAttribute;
  secondAnchor(): MSLayoutAnchor;
  secondItem(): any;
  secondAttribute(): MSLayoutAttribute;
  rect(): NSRect;
}

class MSLoadedImageDataAllocator<T extends MSLoadedImageData> extends NSObjectAllocator<T> {}
declare class MSLoadedImageData extends NSObject {
  alloc<T extends MSLoadedImageData>(): MSLoadedImageDataAllocator<T>;
  static imageFromPasteboard(pasteboard: NSPasteboard): MSLoadedImageData;
  static imageFromFileURL(fileURL: NSURL): MSLoadedImageData;
  static scalingFactorForFilename(filename: NSString | string): NSUInteger;

  image(): MSImageData;
  setImage(image: MSImageData): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  intendedDPI(): NSInteger;
  setIntendedDPI(intendedDPI: NSInteger): void;
}

class MSLocalDataSupplierAllocator<T extends MSLocalDataSupplier> extends MSDataSupplierAllocator<T> {
  initWithFileSystemURL_isBuiltin(fsURL: NSURL, isBuiltin: boolean): T;
}
declare class MSLocalDataSupplier extends MSDataSupplier {
  alloc<T extends MSLocalDataSupplier>(): MSLocalDataSupplierAllocator<T>;
  static textDataFromFileURL(fileURL: NSURL): NSArray<any>;
  static imageFileNamesFromFolderURL(folderURL: NSURL): NSArray<any>;

  dataSource(): NSURL;
  isBuiltin(): boolean;
}

class MSManifestMakerAllocator<T extends MSManifestMaker> extends NSObjectAllocator<T> {
  initWithDocument(documentData: MSImmutableDocumentData): T;
}
declare class MSManifestMaker extends NSObject {
  alloc<T extends MSManifestMaker>(): MSManifestMakerAllocator<T>;
  createManifest(): NSDictionary<any, any>;
  static keyForFlowAnimationType(type: MSFlowAnimationType): NSString;
  metadataForRootLayer_onPage_earlierSlugs(root: MSImmutableLayerGroup, page: MSImmutablePage, slugs: NSMutableDictionary<any, any> | {[key: string]: any} | null): NSDictionary<any, any>;
  filesMetadataForRootLayer_onPage_id(root: MSImmutableLayerGroup, page: MSImmutablePage, fileID: NSString | string): NSArray<any>;

  documentData(): MSImmutableDocumentData;
  cacheManager(): MSCacheManager;
  setCacheManager(cacheManager: MSCacheManager): void;
  name(): NSString;
  setName(name: NSString | string): void;
  selectiveExport(): boolean;
  setSelectiveExport(selectiveExport: boolean): void;
  usePageIfMissingArtboard(): boolean;
  setUsePageIfMissingArtboard(usePageIfMissingArtboard: boolean): void;
}

class MSMaskWithShapeAllocator<T extends MSMaskWithShape> extends NSObjectAllocator<T> {}
declare class MSMaskWithShape extends NSObject {
  alloc<T extends MSMaskWithShape>(): MSMaskWithShapeAllocator<T>;
  static createMaskWithShapeForLayers(layers: MSLayerArray): MSLayer;
}

// @ts-ignore
class MSMathInspectorValueAdaptorAllocator<T extends MSMathInspectorValueAdaptor> extends MSInspectorValueAdaptorAllocator<T> {
  initWithModelsController_floatValueGetter_floatValueSetter_modelKeyPathsToWatch(modelsController: NSArrayController, floatValueGetter: Block, floatValueSetter: Block, modelKeyPathsToWatch: NSArray<any>): T;
}
// @ts-ignore
declare class MSMathInspectorValueAdaptor extends MSInspectorValueAdaptor {
  // @ts-ignore
  alloc<T extends MSMathInspectorValueAdaptor>(): MSMathInspectorValueAdaptorAllocator<T>;
  checkAndAdjustValues_contexts_withNumberFormatter_error(values: NSArray<any>, contexts: NSPointerArray, numberFormatter: NSNumberFormatter, error: NSError): NSArray<any>;
  effectiveNumberFormatter(): NSNumberFormatter;
  currentAdjustOptions(): MSValueAdaptorAdjustOptions;
  valueFromPrefixStrippedString_forModel_originalString_error(string: NSString, model: any, originalString: NSString, error: NSError): NSNumber;
  errorWithUnparsableString(unparsable: NSString): NSError;
  trimValueString_getMathPrefix(string: NSString, prefix: NSString): NSString;
  forceRelativeMathForBlock(block: Block): void;
  clampsValues(): boolean;
  setClampsValues(clampsValues: boolean): void;
  adjustIndividually(): boolean;
  setAdjustIndividually(adjustIndividually: boolean): void;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  isIncrementing(): boolean;
  setIsIncrementing(isIncrementing: boolean): void;
}

declare interface IMSIncrementDecrementDelegate {
  incrementBy(amount: CGFloat): void;
}

declare interface IMSInspectorMathValueAdaptorDelegate {
  inspectorValueAdaptorAllowFloat(adaptor: MSInspectorValueAdaptor): boolean;
}

declare enum MSValueAdaptorAdjustOptions {
  MSValueAdaptorAdjustValues = 1 << 0,
  MSValueAdaptorAdjustIgnoreMinimum = 1 << 1,
  MSValueAdaptorAdjustIgnoreMaximum = 1 << 2,
  MSValueAdaptorAdjustIndividually = 1 << 3,
}

class MSMathNumberFormatterAllocator<T extends MSMathNumberFormatter> extends NSNumberFormatterAllocator<T> {}
declare class MSMathNumberFormatter extends NSNumberFormatter {
  alloc<T extends MSMathNumberFormatter>(): MSMathNumberFormatterAllocator<T>;
}

class MSMomentAllocator<T extends MSMoment> extends NSObjectAllocator<T> {
  initWithTitle_documentData(newTitle: NSString | string, document: MSImmutableDocumentData): T;
}
declare class MSMoment extends NSObject {
  alloc<T extends MSMoment>(): MSMomentAllocator<T>;

  timestamp(): NSTimeInterval;
  title(): NSString;
  setTitle(title: NSString | string): void;
  document(): MSImmutableDocumentData;
  setDocument(document: MSImmutableDocumentData): void;
  adaptability(): MSMomentAdaptability;
  setAdaptability(adaptability: MSMomentAdaptability): void;
  selectedLayerIDs(): NSSet<any>;
  setSelectedLayerIDs(selectedLayerIDs: NSSet<any>): void;
  pageID(): NSString;
  setPageID(pageID: NSString | string): void;
}

declare enum MSMomentAdaptability {
  MSMomentAdaptabilityTransient,
  MSMomentAdaptabilityCoalesces,
  MSMomentAdaptabilityAmends,
}

class MSNetworkHelperAllocator<T extends MSNetworkHelper> extends NSObjectAllocator<T> {}
declare class MSNetworkHelper extends NSObject {
  alloc<T extends MSNetworkHelper>(): MSNetworkHelperAllocator<T>;
}

class MSOpacityKeyboardShortcutRecognizerAllocator<T extends MSOpacityKeyboardShortcutRecognizer> extends NSObjectAllocator<T> {
  initWithTarget_action(target: any | null, action: string | null): T;
}
declare class MSOpacityKeyboardShortcutRecognizer extends NSObject {
  alloc<T extends MSOpacityKeyboardShortcutRecognizer>(): MSOpacityKeyboardShortcutRecognizerAllocator<T>;
  keyDown(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  concatenationDuration(): NSTimeInterval;
  setConcatenationDuration(concatenationDuration: NSTimeInterval): void;
  opacity(): CGFloat;
}

class MSOverrideRepresentationAllocator<T extends MSOverrideRepresentation> extends MSOverrideRepresentationBaseAllocator<T> {}
declare class MSOverrideRepresentation extends MSOverrideRepresentationBase {
  alloc<T extends MSOverrideRepresentation>(): MSOverrideRepresentationAllocator<T>;
  updateExpandedStateAfterSelection(): void;
  createOverrideViewController(): MSOverrideInspectorItem;

  selectionID(): NSString;
  availableOverride(): MSAvailableOverride;
  previousSibling(): MSOverrideRepresentation;
  pathInInstance(): CGPathRef;
  layerListExpandedType(): MSLayerListStatus;
  setLayerListExpandedType(layerListExpandedType: MSLayerListStatus): void;
  isEditable(): boolean;
}

class MSOverrideRepresentationContainerAllocator<T extends MSOverrideRepresentationContainer> extends MSOverrideRepresentationBaseAllocator<T> {}
declare class MSOverrideRepresentationContainer extends MSOverrideRepresentationBase {
  alloc<T extends MSOverrideRepresentationContainer>(): MSOverrideRepresentationContainerAllocator<T>;
  static rootRepresentationForSymbolInstance(instance: MSSymbolInstance): MSOverrideRepresentationContainer;

  selectedOverrides(): NSArray<any>;
}

class MSOverrideRepresentationBaseAllocator<T extends MSOverrideRepresentationBase> extends NSObjectAllocator<T> {}
declare class MSOverrideRepresentationBase extends NSObject {
  alloc<T extends MSOverrideRepresentationBase>(): MSOverrideRepresentationBaseAllocator<T>;
  childrenForLayerList(): NSArray<any>;

  isExpanded(): boolean;
  children(): NSArray<any>;
  instance(): MSSymbolInstance;
}

class MSPDFImporterAllocator<T extends MSPDFImporter> extends NSObjectAllocator<T> {}
declare class MSPDFImporter extends NSObject implements IMSImporter {
  alloc<T extends MSPDFImporter>(): MSPDFImporterAllocator<T>;
  static pdfImporter(): MSPDFImporter;
  static epsImporter(): MSPDFImporter;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importAsLayer(): MSLayer;
  prepareToImportFromData(data: NSData): NSUInteger;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importIntoPage_name_progress(page: MSPage, name: NSString | string, progress: BCVoidBlock): void;
  finishImporting(): void;
  firstPhaseSubtitle(): NSString;
  secondPhaseSubtitleForValue_maximum(value: NSInteger, maximum: NSInteger): NSString;
  shouldExpandPages(): boolean;
  shouldCollapseSinglePage(): boolean;
  importAsLayer(): MSLayer;
  prepareToImportFromData(data: NSData): NSUInteger;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importIntoPage_name_progress(page: MSPage, name: NSString | string, progress: BCVoidBlock): void;
  finishImporting(): void;
  firstPhaseSubtitle(): NSString;
  secondPhaseSubtitleForValue_maximum(value: NSInteger, maximum: NSInteger): NSString;
  shouldExpandPages(): boolean;
  shouldCollapseSinglePage(): boolean;
  importAsLayer(): MSLayer;
}

class MSPageAllocator<T extends MSPage> extends _MSPageAllocator<T> {}
declare class MSPage extends _MSPage implements IMSRootLayer {
  alloc<T extends MSPage>(): MSPageAllocator<T>;
  static page(): MSPage;
  selectedLayers(): MSLayerArray;
  artboardWithID(objectID: any): MSArtboardGroup;
  isLayerSelected(layer: MSLayer): boolean;
  changeSelectionUsingBlock(block: MSSelectionModifierBlock): void;
  changeSelectionBySelectingLayers(layers: NSArray<any> | any[] | null): void;
  clearSelectionCache(): void;
  addOrRemoveLayerFromArtboardIfNecessary(layer: MSLayer): boolean;
  tryToMoveLayer_toArtboards(layer: MSLayer, artboards: NSArray<any> | any[]): boolean;
  destinationArtboardForLayers_artboards(layers: NSArray<any> | any[], artboards: NSArray<any> | any[]): MSArtboardGroup;
  moveLayersToArtboards(): void;
  originForNewArtboardWithSize(size: NSSize): NSPoint;
  layersByObjectID(): NSDictionary<any, any>;
  contentIntersectsWithRect(rect: NSRect): boolean;
  resetSelectedLayerIDs(layerIDs: NSSet<any>): void;
  adjustRulerDataToTopLeftInViewBounds(): void;
  scrollOriginToCenterContentInViewBounds(viewBounds: NSRect): NSPoint;

  currentArtboard(): MSArtboardGroup;
  setCurrentArtboard(currentArtboard: MSArtboardGroup): void;
  artboards(): NSArray<any>;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  symbols(): NSArray<any>;
  exportableLayers(): NSArray<any>;
  currentRoot(): MSLayerGroup;
  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  rulerBase(): NSPoint;
  setRulerBase(rulerBase: NSPoint): void;
  contentBounds(): NSRect;
  rect(): CGRect;
}

class MSPageListControllerAllocator<T extends MSPageListController> extends MSSidebarListControllerAllocator<T> {}
declare class MSPageListController extends MSSidebarListController implements IBCOutlineViewDataSource, IBCOutlineViewDelegate {
  alloc<T extends MSPageListController>(): MSPageListControllerAllocator<T>;
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
  dataController_childrenOfNode(dataController: BCOutlineViewDataController | null, node: any | null): NSArray<any>;
  rootObject(): any;
  dataController_isNodeSelected(dataController: BCOutlineViewDataController, node: any): boolean;
  multipleNodesSelectedForDataController(dataController: BCOutlineViewDataController): boolean;
  dataController_nodeHasSharedStyle(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_changeSelectionTo(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_isNodeExpanded(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeExpandable(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_isNodeHighlighted(dataController: BCOutlineViewDataController, node: any): boolean;
  dataController_updateNode_expandedState(dataController: BCOutlineViewDataController, node: any, expanded: BCOutlineViewNodeExpansionState): void;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, items: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_handleBadgePressedOnNode_withAltState(dataController: BCOutlineViewDataController, node: any, alt: boolean): void;
  dataController_refreshPreviewsOnNodes(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[]): void;
  dataController_menuItemsForSelectedObjects(dataController: BCOutlineViewDataController, selection: NSArray<any> | any[]): NSArray<any>;
  dataController_hoverNodeDidChangeTo(dataController: BCOutlineViewDataController, node: any): void;
}

class MSPasteboardFileDataProviderAllocator<T extends MSPasteboardFileDataProvider> extends NSObjectAllocator<T> {}
declare class MSPasteboardFileDataProvider extends NSObject {
  alloc<T extends MSPasteboardFileDataProvider>(): MSPasteboardFileDataProviderAllocator<T>;
  static addLayers_toPasteboard(layers: NSArray<any> | any[], pboard: NSPasteboard): void;
  static exportLayers_toFolder(layers: NSArray<any> | any[], folder: NSURL): NSArray<any>;
}

class MSPasteboardImageProviderAllocator<T extends MSPasteboardImageProvider> extends NSObjectAllocator<T> {}
declare class MSPasteboardImageProvider extends NSObject {
  alloc<T extends MSPasteboardImageProvider>(): MSPasteboardImageProviderAllocator<T>;
  static preparePasteboard_withExportRequest(pboard: NSPasteboard, request: MSExportRequest): void;
}

class MSPasteboardImageWriterAllocator<T extends MSPasteboardImageWriter> extends NSObjectAllocator<T> {}
declare class MSPasteboardImageWriter extends NSObject implements IMSPasteboardWriter {
  alloc<T extends MSPasteboardImageWriter>(): MSPasteboardImageWriterAllocator<T>;
  canWriteDataToPasteboard(pasteboard: NSPasteboard): boolean;
  supportedPasteboardTypes(): NSArray<any>;
  writeData_toPasteboard(data: MSPasteboardLayers, pasteboard: NSPasteboard): void;
  canWriteDataToPasteboard(pasteboard: NSPasteboard): boolean;
  supportedPasteboardTypes(): NSArray<any>;
  writeData_toPasteboard(data: MSPasteboardLayers, pasteboard: NSPasteboard): void;
}

class MSPasteboardImagesReaderAllocator<T extends MSPasteboardImagesReader> extends NSObjectAllocator<T> {}
declare class MSPasteboardImagesReader extends NSObject implements IMSPasteboardReader {
  alloc<T extends MSPasteboardImagesReader>(): MSPasteboardImagesReaderAllocator<T>;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
}

class MSPasteboardInternalImageReaderAllocator<T extends MSPasteboardInternalImageReader> extends MSPasteboardImagesReaderAllocator<T> {}
declare class MSPasteboardInternalImageReader extends MSPasteboardImagesReader {
  alloc<T extends MSPasteboardInternalImageReader>(): MSPasteboardInternalImageReaderAllocator<T>;
}

class MSPasteboardLayerListImageProviderAllocator<T extends MSPasteboardLayerListImageProvider> extends NSObjectAllocator<T> {}
declare class MSPasteboardLayerListImageProvider extends NSObject {
  alloc<T extends MSPasteboardLayerListImageProvider>(): MSPasteboardLayerListImageProviderAllocator<T>;
  static addLayer_toPasteboard(layer: MSLayer, pboard: NSPasteboard): void;
}

class MSPasteboardPDFReaderAllocator<T extends MSPasteboardPDFReader> extends NSObjectAllocator<T> {}
declare class MSPasteboardPDFReader extends NSObject {
  alloc<T extends MSPasteboardPDFReader>(): MSPasteboardPDFReaderAllocator<T>;
}

class MSPasteboardPathsReaderAllocator<T extends MSPasteboardPathsReader> extends NSObjectAllocator<T> {}
declare class MSPasteboardPathsReader extends NSObject implements IMSPasteboardReader {
  alloc<T extends MSPasteboardPathsReader>(): MSPasteboardPathsReaderAllocator<T>;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
}

class MSPasteboardTextReaderAllocator<T extends MSPasteboardTextReader> extends NSObjectAllocator<T> {}
declare class MSPasteboardTextReader extends NSObject implements IMSPasteboardReader {
  alloc<T extends MSPasteboardTextReader>(): MSPasteboardTextReaderAllocator<T>;
  attributedStringFromPasteboard_options(pasteboard: NSPasteboard, options: MSPasteboardReaderOptions): NSAttributedString;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
}

class MSPasteboardTextWritingAllocator<T extends MSPasteboardTextWriting> extends NSObjectAllocator<T> {}
declare class MSPasteboardTextWriting extends NSObject {
  alloc<T extends MSPasteboardTextWriting>(): MSPasteboardTextWritingAllocator<T>;
  static supportedTypes(): NSArray<any>;
  static writeAttributedString_toPasteboard_type_documentColorSpace(attributedString: NSAttributedString, pasteboard: NSPasteboard, type: NSString | string, colorSpace: NSColorSpace): boolean;
}

class MSPluginDataSupplierAllocator<T extends MSPluginDataSupplier> extends MSDataSupplierAllocator<T> {
  initWithPluginIdentifier_commandIdentifier_dataName_dataTypeStringRepresentation_dynamicDataKey(identifier: NSString | string, commandIdentifier: NSString | string, dataName: NSString | string, dataType: NSString | string, dynamicDataKey: NSString | string): T;
}
declare class MSPluginDataSupplier extends MSDataSupplier {
  alloc<T extends MSPluginDataSupplier>(): MSPluginDataSupplierAllocator<T>;
  static identifierWithPluginIdentifier_commandIdentifier_dynamicDataKey(pluginIdentifier: NSString | string, commandIdentifier: NSString | string, dynamicDataKey: NSString | string): NSString;

  pluginIdentifier(): NSString;
  commandIdentifier(): NSString;
  dynamicDataKey(): NSString;
  registered(): boolean;
  setRegistered(registered: boolean): void;
}

class MSPluginDataSupplierContextAllocator<T extends MSPluginDataSupplierContext> extends NSObjectAllocator<T> {
  initWithLayers(layers: NSArray<any> | any[]): T;
  initWithOverrides(overrides: NSArray<any> | any[]): T;
}
declare class MSPluginDataSupplierContext extends NSObject {
  alloc<T extends MSPluginDataSupplierContext>(): MSPluginDataSupplierContextAllocator<T>;

  isSymbolInstanceOverride(): boolean;
  layers(): NSArray<any>;
  overrides(): NSArray<any>;
  dictionaryRepresentation(): NSDictionary<any, any>;
  requestedCount(): NSUInteger;
  key(): NSString;
}

class MSPointInsertionAllocator<T extends MSPointInsertion> extends NSObjectAllocator<T> {}
declare class MSPointInsertion extends NSObject {
  alloc<T extends MSPointInsertion>(): MSPointInsertionAllocator<T>;
  static insertPointAtLocation_index_layer_options(location: NSPoint, index: NSUInteger, layer: MSShapePathLayer, options: MSPointInsertionOptions): MSCurvePoint;
  static canInsertAtProposedLocation_index_layer_options(proposedPoint: NSPoint, index: NSUInteger, layer: MSShapePathLayer, options: MSPointInsertionOptions): boolean;
}

declare enum MSPointInsertionOptions {
  MSPointInsertionStraight = 1 << 0,
  MSPointInsertionCenter = 1 << 1,
}

class MSPopUpToolbarItemAllocator<T extends MSPopUpToolbarItem> extends MSToolbarItemAllocator<T> {}
declare class MSPopUpToolbarItem extends MSToolbarItem {
  alloc<T extends MSPopUpToolbarItem>(): MSPopUpToolbarItemAllocator<T>;
}

declare interface IMSPreviewGeneration {
  generatePreviewWithImageSize_previewSize_colorSpace_backingScale_completionBlock(imageSize: CGSize, previewSize: CGSize, colorSpace: NSColorSpace | null, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): void;
}

class MSRectSnapItemAllocator<T extends MSRectSnapItem> extends MSSnapItemAllocator<T> {}
declare class MSRectSnapItem extends MSSnapItem {
  alloc<T extends MSRectSnapItem>(): MSRectSnapItemAllocator<T>;
  static rectSnapItemWithLayer_rect_constrainProportions(layer: MSLayer, rect: NSRect, constrainProportions: boolean): MSRectSnapItem;
}

class MSRectangleShapeAllocator<T extends MSRectangleShape> extends _MSRectangleShapeAllocator<T> {}
declare class MSRectangleShape extends _MSRectangleShape {
  alloc<T extends MSRectangleShape>(): MSRectangleShapeAllocator<T>;
  static looksLikeComponentString(string: NSString | string): boolean;
  static componentStringWithValues(values: NSArray<any> | any[]): NSString;
  static validateComponentString(string: NSString | string): boolean;
  validateProposedCornerRadiusSizeWithString(radiusString: NSString | string): boolean;
  validateProposedCornerRadiusWithFloat(radius: CGFloat): boolean;
  resetPathsToRect(): void;
  resetPathsToRoundedRect(): void;

  static lastUsedCornerRadius(): CGFloat;
  static useSmoothCorners(): boolean;
  cornerRadiusString(): NSString;
  setCornerRadiusString(cornerRadiusString: NSString | string): void;
  cornerRadiusFloat(): CGFloat;
  setCornerRadiusFloat(cornerRadiusFloat: CGFloat): void;
  normalizedExponentialCornerRadius(): CGFloat;
  setNormalizedExponentialCornerRadius(normalizedExponentialCornerRadius: CGFloat): void;
  hasSmoothCorners(): boolean;
  setHasSmoothCorners(hasSmoothCorners: boolean): void;
  smoothCornersAllowed(): boolean;
  maximumAllowedRadius(): CGFloat;
}

class MSAssetLibraryUpdatingInfoAllocator<T extends MSAssetLibraryUpdatingInfo> extends NSObjectAllocator<T> {
  initWithDownloadURL_libraryName_imageURL_newVersionNumber_shareLink_downloadSize(downloadURL: NSURL, libraryName: NSString | string | null, imageURL: NSURL | null, newVersionNumber: NSString | string, shareLink: NSURL | null, downloadSize: NSUInteger): T;
  initWithCoder(aDecoder: NSCoder): T;
}
declare class MSAssetLibraryUpdatingInfo extends NSObject implements INSCoding {
  alloc<T extends MSAssetLibraryUpdatingInfo>(): MSAssetLibraryUpdatingInfoAllocator<T>;
  isEqual(object: any | null): boolean;
  isHigherVersionThan(otherVersion: NSString | string | null): boolean;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;

  downloadURL(): NSURL;
  versionNumberForUpdate(): NSString;
  downloadSize(): NSUInteger;
  libraryName(): NSString;
  imageURL(): NSURL;
  folderMonitor(): MSFolderMonitor;
  setFolderMonitor(folderMonitor: MSFolderMonitor): void;
  downloadTaskIdentifier(): NSString;
  setDownloadTaskIdentifier(downloadTaskIdentifier: NSString | string): void;
  shareLink(): NSURL;
}

class MSRemoteAssetLibraryAllocator<T extends MSRemoteAssetLibrary> extends MSAssetLibraryAllocator<T> {
  initWithName_appcastURL_version_infoText(libraryName: NSString | string, appcastURL: NSURL, libraryVersion: NSString | string | null, infoText: NSString | string | null): T;
}
declare class MSRemoteAssetLibrary extends MSAssetLibrary {
  alloc<T extends MSRemoteAssetLibrary>(): MSRemoteAssetLibraryAllocator<T>;
  static URLForApplicationSupportLibraryNamed(name: NSString | string): NSURL;
  assetLibraryUpdated(): void;

  appcastURL(): NSURL;
  setAppcastURL(appcastURL: NSURL): void;
  libraryVersion(): NSString;
  setLibraryVersion(libraryVersion: NSString | string): void;
  originalName(): NSString;
  infoText(): NSString;
  setInfoText(infoText: NSString | string): void;
  newUpdatingInfo(): boolean;
  setNewUpdatingInfo(newUpdatingInfo: boolean): void;
  updatingInfo(): MSAssetLibraryUpdatingInfo;
  setUpdatingInfo(updatingInfo: MSAssetLibraryUpdatingInfo): void;
  downloadAvailable(): boolean;
  updateAvailable(): boolean;
  fileName(): NSString;
  static assetLibraryFolder(): NSURL;
}

class MSRenderMonitorAllocator<T extends MSRenderMonitor> extends NSObjectAllocator<T> {}
declare class MSRenderMonitor extends NSObject {
  alloc<T extends MSRenderMonitor>(): MSRenderMonitorAllocator<T>;
  recordEvent(event: MSRenderMonitorEvent): void;
  recordEvent_timestamp(event: MSRenderMonitorEvent, timestamp: BCTime): void;
  timestampForEvent(event: MSRenderMonitorEvent): BCTime;
  timeIntervalBetweenStartEvent_endEvent(startEvent: MSRenderMonitorEvent, endEvent: MSRenderMonitorEvent): NSTimeInterval;
  registerHook_forEvent(hook: MSRenderMonitorHook, event: MSRenderMonitorEvent): void;

  shouldRemoveWhenDone(): boolean;
  setShouldRemoveWhenDone(shouldRemoveWhenDone: boolean): void;
  shouldClearAllCaches(): boolean;
  setShouldClearAllCaches(shouldClearAllCaches: boolean): void;
  shouldForceFullRedraw(): boolean;
  setShouldForceFullRedraw(shouldForceFullRedraw: boolean): void;
}

declare enum MSRenderMonitorEvent {
  MSRenderMonitorEventQueued,
  MSRenderMonitorEventDiffStarted,
  MSRenderMonitorEventOverlayRenderStarted,
  MSRenderMonitorEventOverlayRenderFinished,
  MSRenderMonitorEventTileRenderStarted,
  MSRenderMonitorEventTileRenderFinished,
  MSRenderMonitorEventCount,
}

class MSResizeArtboardToFitValidatorAllocator<T extends MSResizeArtboardToFitValidator> extends NSObjectAllocator<T> {}
declare class MSResizeArtboardToFitValidator extends NSObject {
  alloc<T extends MSResizeArtboardToFitValidator>(): MSResizeArtboardToFitValidatorAllocator<T>;
  static isValidForSelectedLayers(selectedLayers: MSLayerArray): boolean;
}

class MSRotatedSnapItemAllocator<T extends MSRotatedSnapItem> extends MSSnapItemAllocator<T> {}
declare class MSRotatedSnapItem extends MSSnapItem {
  alloc<T extends MSRotatedSnapItem>(): MSRotatedSnapItemAllocator<T>;
}

class MSRulerGuidesAllocator<T extends MSRulerGuides> extends NSObjectAllocator<T> {}
declare class MSRulerGuides extends NSObject {
  alloc<T extends MSRulerGuides>(): MSRulerGuidesAllocator<T>;
  static findHoverGuidesOnPage_mouse_mask_zoomScale(page: MSPage, mouse: NSPoint, mask: MSAlignmentGuideMask, zoomScale: CGFloat): NSArray<any>;
  static horizontalGuidesForVerticalRulerOnPage_mask_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, zoomScale: CGFloat): NSArray<any>;
  static horizontalGuidesForVerticalRulerOnPage_mask_inRect_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, rect: NSRect, zoomScale: CGFloat): NSArray<any>;
  static verticalGuidesForHorizontalRulerOnPage_mask_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, zoomScale: CGFloat): NSArray<any>;
  static verticalGuidesForHorizontalRulerOnPage_mask_inRect_zoomScale(page: MSPage, mask: MSAlignmentGuideMask, rect: NSRect, zoomScale: CGFloat): NSArray<any>;
}

declare enum MSAlignmentGuideMask {
  MSAlignmentGuideMaskCustom = 1 << 0,
  MSAlignmentGuideMaskGrid = 1 << 1,
}

class MSSVGImporterAllocator<T extends MSSVGImporter> extends NSObjectAllocator<T> {}
declare class MSSVGImporter extends NSObject implements IMSImporter {
  alloc<T extends MSSVGImporter>(): MSSVGImporterAllocator<T>;
  static svgImporter(): MSSVGImporter;
  importAsLayer(): MSLayer;
  prepareToImportFromData(data: NSData): NSUInteger;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importIntoPage_name_progress(page: MSPage, name: NSString | string, progress: BCVoidBlock): void;
  finishImporting(): void;
  firstPhaseSubtitle(): NSString;
  secondPhaseSubtitleForValue_maximum(value: NSInteger, maximum: NSInteger): NSString;
  shouldExpandPages(): boolean;
  shouldCollapseSinglePage(): boolean;
  importAsLayer(): MSLayer;
  prepareToImportFromData(data: NSData): NSUInteger;
  prepareToImportFromURL(url: NSURL): NSUInteger;
  importIntoPage_name_progress(page: MSPage, name: NSString | string, progress: BCVoidBlock): void;
  finishImporting(): void;
  firstPhaseSubtitle(): NSString;
  secondPhaseSubtitleForValue_maximum(value: NSInteger, maximum: NSInteger): NSString;
  shouldExpandPages(): boolean;
  shouldCollapseSinglePage(): boolean;
  importAsLayer(): MSLayer;
}

class MSShapeChangeContextAllocator<T extends MSShapeChangeContext> extends NSObjectAllocator<T> {
  initWithLayers_handleIndexPaths(layers: NSArray<any> | any[], indexPaths: NSArray<any> | any[] | null): T;
}
declare class MSShapeChangeContext extends NSObject implements INSCopying {
  alloc<T extends MSShapeChangeContext>(): MSShapeChangeContextAllocator<T>;
  enumerateCurvePointsUsingBlock(block: Block): void;
  curvePointAtIndexPath(indexPath: NSIndexPath): MSCurvePoint;
  locationOfHandleAtIndexPath_inCoordinateSpace(indexPath: NSIndexPath, coordinateSpace: any | null): NSPoint;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  layers(): NSArray<any>;
  handleIndexPaths(): NSArray<any>;
  orderedHandleIndexPaths(): NSArray<any>;
}

class MSShapeChangeAllocator<T extends MSShapeChange> extends NSObjectAllocator<T> {}
declare class MSShapeChange extends NSObject {
  alloc<T extends MSShapeChange>(): MSShapeChangeAllocator<T>;
  static moveToPoint_options(location: NSPoint, options: MSCurveMoveOptions): MSShapeChange;
  static moveByOffset_options(offset: NSSize, options: MSCurveMoveOptions): MSShapeChange;
  static moveToLocation_onAxis(location: CGFloat, axis: BCAxis): MSShapeChange;
  static moveHandle_toLocation_onAxis(indexPath: NSIndexPath, location: CGFloat, axis: BCAxis): MSShapeChange;
  static nudgeWithKey_distance_flags(key: unichar, distance: CGFloat, flags: NSEventModifierFlags): MSShapeChange;
  static changeToCurveMode(curveMode: MSCurveMode): MSShapeChange;
  static alignToKey(key: NSString | string): MSShapeChange;
  static distributeAlongAxis(axis: BCAxis): MSShapeChange;
  static deleteHandle(): MSShapeChange;
  static customActionWithBlock(block: Block): MSShapeChange;
  executeWithContext(context: MSShapeChangeContext): void;
}

class MSShapeEditingBehaviorAllocator<T extends MSShapeEditingBehavior> extends NSObjectAllocator<T> {
  initForDrawingNewShape(drawingNewShape: boolean): T;
}
declare class MSShapeEditingBehavior extends NSObject {
  alloc<T extends MSShapeEditingBehavior>(): MSShapeEditingBehaviorAllocator<T>;
  isAddingPoints(context: MSShapeChangeContext): boolean;
  canInsertPoints(): boolean;
  shouldClosePathWhenMouseDownOnHandleAtIndexPath_modifierFlags_context(indexPath: NSIndexPath, flags: NSEventModifierFlags, context: MSShapeChangeContext): boolean;

  isNewShape(): boolean;
  allowSelectionOnly(): boolean;
  setAllowSelectionOnly(allowSelectionOnly: boolean): void;
  allowClosingPathUsingMouse(): boolean;
  setAllowClosingPathUsingMouse(allowClosingPathUsingMouse: boolean): void;
}

class MSShareableObjectPopUpButtonAllocator<T extends MSShareableObjectPopUpButton> extends NSPopUpButtonAllocator<T> {}
declare class MSShareableObjectPopUpButton extends NSPopUpButton {
  alloc<T extends MSShareableObjectPopUpButton>(): MSShareableObjectPopUpButtonAllocator<T>;
  updateWithMenuBuilder_forLayers(menuBuilder: MSForeignObjectMenuBuilder, layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
}

class MSShareableObjectReferenceAllocator<T extends MSShareableObjectReference> extends NSObjectAllocator<T> {}
declare class MSShareableObjectReference extends NSObject implements IBCSortable, IMSSharedObjectStyling {
  alloc<T extends MSShareableObjectReference>(): MSShareableObjectReferenceAllocator<T>;
  static referenceForShareableObject(object: MSModelObject): MSShareableObjectReference;
  static referenceForShareableObject_inLibrary(object: MSModelObject, library: MSAssetLibrary): MSShareableObjectReference;
  foreignObjectCollectionInDocument(document: MSDocumentData): NSArray<any>;
  generatePreviewForMenuItem_withColorSpace_backingScale_completionBlock(menuItem: NSMenuItem, colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForPopup_backingScale_completionBlock(cell: NSPopUpButtonCell, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForManageSheetWithBackingScale_completionBlock(backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForSyncSheetWithSize_backingScale_shadow_colorSpace_completionBlock(size: CGSize, backingScale: CGFloat, shadow: boolean, colorSpace: NSColorSpace, block: MSPreviewGeneratorBlock): void;
  applyStyleToMenuItem_withColorSpace(item: NSMenuItem | null, colorSpace: NSColorSpace | null): void;
  generatePreviewForMenuItem_withColorSpace_backingScale_completionBlock(menuItem: NSMenuItem, colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForPopup_backingScale_completionBlock(cell: NSPopUpButtonCell, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForManageSheetWithBackingScale_completionBlock(backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForSyncSheetWithSize_backingScale_shadow_colorSpace_completionBlock(size: CGSize, backingScale: CGFloat, shadow: boolean, colorSpace: NSColorSpace, block: MSPreviewGeneratorBlock): void;
  applyStyleToMenuItem_withColorSpace(item: NSMenuItem | null, colorSpace: NSColorSpace | null): void;

  sourceLibrary(): MSAssetLibrary;
  shareableObject(): MSShareableObject;
  shareableObjectType(): MSShareableObjectType;
  sharedObjectID(): NSString;
  locationPath(): NSString;
  name(): NSString;
}

declare type MSShareableObject = MSModelObject

declare enum MSShareableObjectType {
  MSShareableObjectTypeSymbol = 0,
  MSShareableObjectTypeLayerStyle,
  MSShareableObjectTypeTextStyle,
  MSShareableObjectTypeUnknown,
}

class MSShareableObjectUpdaterAllocator<T extends MSShareableObjectUpdater> extends NSObjectAllocator<T> {}
declare class MSShareableObjectUpdater extends NSObject {
  alloc<T extends MSShareableObjectUpdater>(): MSShareableObjectUpdaterAllocator<T>;
  performCreateNewStyleAction(): void;
  performSyncAndOrUnlinkAction(): void;
  performResetAction(): void;
  performDetachAction(): void;

  selectedLayers(): MSLayerArray;
  setSelectedLayers(selectedLayers: MSLayerArray): void;
  shareableObjectType(): MSShareableObjectType;
  hasOutOfSyncStyles(): boolean;
  allSharedObjects(): NSSet<any>;
  shareableObject(): MSShareableObject;
  selectedStyle(): MSStyle;
  foreignSharedObjects(): NSSet<any>;
  menuItemTitleForCreateNewStyleAction(): NSString;
  menuItemTitleForSyncAction(): NSString;
  menuItemTitleForUnlinkAction(): NSString;
  menuItemTitleForUnlinkAndSyncAction(): NSString;
  menuItemTitleForResetStyleAction(): NSString;
  menuItemTitleForDetachAction(): NSString;
}

class MSSharedStyleAllocator<T extends MSSharedStyle> extends _MSSharedStyleAllocator<T> {}
declare class MSSharedStyle extends _MSSharedStyle {
  alloc<T extends MSSharedStyle>(): MSSharedStyleAllocator<T>;
  resetReferencingInstances(): void;
  // @ts-ignore
  newInstance(): MSStyle;

  style(): MSStyle;
}

declare interface IMSSharedObjectStyling {
  generatePreviewForMenuItem_withColorSpace_backingScale_completionBlock(menuItem: NSMenuItem, colorSpace: NSColorSpace, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForPopup_backingScale_completionBlock(cell: NSPopUpButtonCell, backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForManageSheetWithBackingScale_completionBlock(backingScale: CGFloat, block: MSPreviewGeneratorBlock | null): NSImage;
  generatePreviewForSyncSheetWithSize_backingScale_shadow_colorSpace_completionBlock(size: CGSize, backingScale: CGFloat, shadow: boolean, colorSpace: NSColorSpace, block: MSPreviewGeneratorBlock): void;
  applyStyleToMenuItem_withColorSpace(item: NSMenuItem | null, colorSpace: NSColorSpace | null): void;
}

class MSSharedStyleReferenceAllocator<T extends MSSharedStyleReference> extends MSShareableObjectReferenceAllocator<T> {}
declare class MSSharedStyleReference extends MSShareableObjectReference {
  alloc<T extends MSSharedStyleReference>(): MSSharedStyleReferenceAllocator<T>;
}

class MSSharedLayerReferenceAllocator<T extends MSSharedLayerReference> extends MSSharedStyleReferenceAllocator<T> {}
declare class MSSharedLayerReference extends MSSharedStyleReference {
  alloc<T extends MSSharedLayerReference>(): MSSharedLayerReferenceAllocator<T>;
}

class MSSharedTextReferenceAllocator<T extends MSSharedTextReference> extends MSSharedStyleReferenceAllocator<T> {}
declare class MSSharedTextReference extends MSSharedStyleReference {
  alloc<T extends MSSharedTextReference>(): MSSharedTextReferenceAllocator<T>;
}

class MSSharedStylesPopUpButtonCellAllocator<T extends MSSharedStylesPopUpButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSSharedStylesPopUpButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSSharedStylesPopUpButtonCell>(): MSSharedStylesPopUpButtonCellAllocator<T>;

  localIsOutOfSync(): boolean;
  setLocalIsOutOfSync(localIsOutOfSync: boolean): void;
}

class MSSidebarListControllerAllocator<T extends MSSidebarListController> extends NSObjectAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class MSSidebarListController extends NSObject {
  alloc<T extends MSSidebarListController>(): MSSidebarListControllerAllocator<T>;
  readDragNodesFromPasteboard(pboard: NSPasteboard): NSArray<any>;
  layerForNode(node: any): MSLayer;
  layersFromNodeArray(nodes: NSArray<any> | any[]): NSArray<any>;
  canMoveNode_toParent_after(node: any, parent: any, previousNode: any): boolean;
  canCopyNode_toParent_after(node: any, parent: any, previousNode: any): boolean;
  moveNode_toParent_after(node: any, parent: any, previousNode: any): boolean;
  dragTypesForDataController(dataController: BCOutlineViewDataController): NSArray<any>;
  dataController_writeNodes_toPasteboard(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], pboard: NSPasteboard): boolean;
  dataController_canMoveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_canCopyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_moveFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_copyFromPasteboard_toParent_after(dataController: BCOutlineViewDataController, pboard: NSPasteboard, parent: any, previousNode: any): boolean;
  dataController_exportNodes_toFolder(dataController: BCOutlineViewDataController, nodes: NSArray<any> | any[], folder: NSURL): NSArray<any>;

  delegate(): any;
  documentData(): MSDocumentData;
  rootObject(): any;
}

class MSSimpleGridAllocator<T extends MSSimpleGrid> extends _MSSimpleGridAllocator<T> {}
declare class MSSimpleGrid extends _MSSimpleGrid {
  alloc<T extends MSSimpleGrid>(): MSSimpleGridAllocator<T>;
  horizontalGuidesForRulerData_inRect(rulerData: MSRulerData, rect: NSRect): NSArray<any>;
  verticalGuidesForRulerData_inRect(rulerData: MSRulerData, rect: NSRect): NSArray<any>;
}

class MSSizeInspectorValueAdaptorAllocator<T extends MSSizeInspectorValueAdaptor> extends MSCoordinateInspectorValueAdaptorAllocator<T> {}
declare class MSSizeInspectorValueAdaptor extends MSCoordinateInspectorValueAdaptor {
  alloc<T extends MSSizeInspectorValueAdaptor>(): MSSizeInspectorValueAdaptorAllocator<T>;
}

class MSSmartGuideDrawingAllocator<T extends MSSmartGuideDrawing> extends NSObjectAllocator<T> {}
declare class MSSmartGuideDrawing extends NSObject {
  alloc<T extends MSSmartGuideDrawing>(): MSSmartGuideDrawingAllocator<T>;
  static smartGuideColor(): NSColor;
  static resetSmartGuideColor(): void;
}

class MSMeasurementDrawingAllocator<T extends MSMeasurementDrawing> extends MSSmartGuideDrawingAllocator<T> {}
declare class MSMeasurementDrawing extends MSSmartGuideDrawing {
  alloc<T extends MSMeasurementDrawing>(): MSMeasurementDrawingAllocator<T>;
  drawWithFrame_zoomScale(frame: NSRect, zoomScale: CGFloat): void;
  frameForMeasuringSizeOfRect_zoomScale(targetRect: NSRect, zoomScale: CGFloat): NSRect;

  orientation(): BCAxis;
  setOrientation(orientation: BCAxis): void;
  labelText(): NSString;
  setLabelText(labelText: NSString | string): void;
  labelTransform(): CGAffineTransform;
  setLabelTransform(labelTransform: CGAffineTransform): void;
  color(): NSColor;
  setColor(color: NSColor): void;
}

class MSSnapItemAllocator<T extends MSSnapItem> extends NSObjectAllocator<T> {
  initWithLayers(layers: NSArray<any> | any[]): T;
}
declare class MSSnapItem extends NSObject implements IMSSnappable {
  alloc<T extends MSSnapItem>(): MSSnapItemAllocator<T>;
  static snapItemWithLayers(layers: NSArray<any> | any[]): MSSnapItem;
  rotation(): CGFloat;
  snapInBlock(block: BCVoidBlock): void;
  candidateLayersForSnapping(snapType: MSSnapType): NSArray<any>;
  artboardForSnapping(): MSArtboardGroup;
  shouldDrawDistanceOnSnapTo(snapItem: any): boolean;
  boundsRect(): NSRect;
  alignmentRectInCoordinateSpace_options(coordinateSpace: any, options: MSAlignmentRectOptions): NSRect;
  enumerateAnchorsForSnappingOnAxes_usingBlock(axes: BCAxis, block: Block): void;
  anchorsForSnappingOnAxes(axes: BCAxis): NSArray<any>;
  distanceRectangleToItem_axis(other: any, axis: BCAxis): NSRect;
  refreshOverlayWithAbsoluteMargins(margins: NSSize): void;
  concatAncestorsAndSelfTransforms(): void;
  textCorrectionTransform(): CGAffineTransform;
  boundsRect(): NSRect;
  alignmentRectInCoordinateSpace_options(coordinateSpace: any, options: MSAlignmentRectOptions): NSRect;
  enumerateAnchorsForSnappingOnAxes_usingBlock(axes: BCAxis, block: Block): void;
  anchorsForSnappingOnAxes(axes: BCAxis): NSArray<any>;
  distanceRectangleToItem_axis(other: any, axis: BCAxis): NSRect;
  refreshOverlayWithAbsoluteMargins(margins: NSSize): void;
  concatAncestorsAndSelfTransforms(): void;
  textCorrectionTransform(): CGAffineTransform;

  rectForSnapping(): NSRect;
  setRectForSnapping(rectForSnapping: NSRect): void;
  shouldConstrainProportions(): boolean;
  supportsResizingForSnapping(): boolean;
  layers(): NSArray<any>;
  layer(): MSLayer;
  coordinateSpace(): MSLayer;
  leftAnchor(): MSLayoutPosition;
  rightAnchor(): MSLayoutPosition;
  topAnchor(): MSLayoutPosition;
  bottomAnchor(): MSLayoutPosition;
  centerXAnchor(): MSLayoutPosition;
  centerYAnchor(): MSLayoutPosition;
  widthAnchor(): MSLayoutDimension;
  heightAnchor(): MSLayoutDimension;
  baselineAnchor(): MSLayoutPosition;
  midXHeightAnchor(): MSLayoutPosition;
  snapItemForDrawing(): any;
  name(): NSString;
}

declare interface IMSSnappable {
  boundsRect(): NSRect;
  alignmentRectInCoordinateSpace_options(coordinateSpace: any, options: MSAlignmentRectOptions): NSRect;
  enumerateAnchorsForSnappingOnAxes_usingBlock(axes: BCAxis, block: Block): void;
  anchorsForSnappingOnAxes(axes: BCAxis): NSArray<any>;
  distanceRectangleToItem_axis(other: any, axis: BCAxis): NSRect;
  refreshOverlayWithAbsoluteMargins(margins: NSSize): void;
  concatAncestorsAndSelfTransforms(): void;
  textCorrectionTransform(): CGAffineTransform;

  rectForSnapping(): NSRect;
  coordinateSpace(): MSLayer;
  leftAnchor(): MSLayoutPosition;
  rightAnchor(): MSLayoutPosition;
  topAnchor(): MSLayoutPosition;
  bottomAnchor(): MSLayoutPosition;
  centerXAnchor(): MSLayoutPosition;
  centerYAnchor(): MSLayoutPosition;
  widthAnchor(): MSLayoutDimension;
  heightAnchor(): MSLayoutDimension;
  baselineAnchor(): MSLayoutPosition;
  midXHeightAnchor(): MSLayoutPosition;
  snapItemForDrawing(): any;
  name(): NSString;
}

declare enum MSLayoutAttribute {
  MSLayoutAttributeLeft,
  MSLayoutAttributeRight,
  MSLayoutAttributeTop,
  MSLayoutAttributeBottom,
  MSLayoutAttributeWidth,
  MSLayoutAttributeHeight,
  MSLayoutAttributeCenterX,
  MSLayoutAttributeCenterY,
  MSLayoutAttributeBaseline,
  MSLayoutAttributeMidXHeight,
  MSLayoutAttributeCapHeight,
  MSLayoutAttributeGuideX,
  MSLayoutAttributeGuideY,
  MSLayoutAttributeNotAnAttribute,
}

declare enum MSSnapType {
  MSSnapGuides,
  MSSnapSpacing,
  MSSnapDimension,
}

class MSSnapperAllocator<T extends MSSnapper> extends NSObjectAllocator<T> {}
declare class MSSnapper extends NSObject {
  alloc<T extends MSSnapper>(): MSSnapperAllocator<T>;
  snapSize_edges(snap: BCAxis, mask: NSInteger): BCAxis;
  snapSpacingOnEdges_mayResize(mask: BCEdge, resize: boolean): BCAxis;
  snapDuringSession(session: MSSnappingSession): MSSnapperData;
  snapToLines_adjustableAxes_mayResize(lines: NSArray<any> | any[], adjustableAxes: BCAxis, resize: boolean): void;

  snapperData(): MSSnapperData;
  setSnapperData(snapperData: MSSnapperData): void;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}

class MSSnapperDataAllocator<T extends MSSnapperData> extends NSObjectAllocator<T> {
  initWithSnappingSession(session: MSSnappingSession): T;
}
declare class MSSnapperData extends NSObject {
  alloc<T extends MSSnapperData>(): MSSnapperDataAllocator<T>;
  accumulatorForAxis(axis: BCAxis): MSSnappingAccumulator;
  firstDimensionSnapForAxis(axis: BCAxis): MSLayoutRelationship;
  addDimensionSnap(snap: MSLayoutRelationship): void;
  firstSpacingSnapForAxis(axis: BCAxis): MSLayoutRelationship;
  addSpacingSnap(snap: MSLayoutRelationship): void;
  addEdgeSnap(relationship: MSLayoutRelationship): void;
  resetEdgeSnapsForAxis(axis: BCAxis): void;
  addSpacingMeasurementsForEdgeSnaps(): void;
  drawForGroup_zoomScale(group: MSLayerGroup, zoom: CGFloat): void;

  snappingSession(): MSSnappingSession;
  item(): MSSnapItem;
  xAxisAccumulator(): MSSnappingAccumulator;
  yAxisAccumulator(): MSSnappingAccumulator;
  dimensionAxes(): BCAxis;
  spacingAxes(): BCAxis;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
}

class MSSnappingAccumulatorAllocator<T extends MSSnappingAccumulator> extends NSObjectAllocator<T> {
  initWithAxis(axis: BCAxis): T;
}
declare class MSSnappingAccumulator extends NSObject {
  alloc<T extends MSSnappingAccumulator>(): MSSnappingAccumulatorAllocator<T>;
  removeAllEdgeSnaps(): void;
  removeAllDimensionSnaps(): void;
  removeAllSpacingSnaps(): void;

  axis(): BCAxis;
  edgeSnaps(): NSArray<any>;
  dimensionSnaps(): NSArray<any>;
  spacingSnaps(): NSArray<any>;
}

class MSSnappingSessionAllocator<T extends MSSnappingSession> extends NSObjectAllocator<T> {}
declare class MSSnappingSession extends NSObject {
  alloc<T extends MSSnappingSession>(): MSSnappingSessionAllocator<T>;
  static moveSnappingSessionWithItem(item: MSSnapItem): MSSnappingSession;
  static resizeSnappingSessionWithItem_corner(item: MSSnapItem, corner: BCCorner): MSSnappingSession;
  static keySnappingSessionWithItem(item: MSSnapItem): MSSnappingSession;

  sessionType(): MSSnappingSessionType;
  snapDistance(): CGFloat;
  setSnapDistance(snapDistance: CGFloat): void;
  zoomScale(): CGFloat;
  setZoomScale(zoomScale: CGFloat): void;
  effectiveSnapDistance(): CGFloat;
  allowedAxes(): BCAxis;
  setAllowedAxes(allowedAxes: BCAxis): void;
  item(): MSSnapItem;
  layers(): NSArray<any>;
  layer(): MSLayer;
  corner(): BCCorner;
  setCorner(corner: BCCorner): void;
  snappableEdges(): BCEdge;
  snappableAttributes(): NSIndexSet;
  shouldSnapToLayers(): boolean;
  setShouldSnapToLayers(shouldSnapToLayers: boolean): void;
  snappableGuidesMask(): MSAlignmentGuideMask;
  setSnappableGuidesMask(snappableGuidesMask: MSAlignmentGuideMask): void;
}

declare enum MSSnappingSessionType {
  MSSnappingSessionTypeMove,
  MSSnappingSessionTypeResize,
  MSSnappingSessionTypeKey,
}

class MSSnappingTargetAllocator<T extends MSSnappingTarget> extends NSObjectAllocator<T> {
  initWithGuideLine(lineSegment: MSLineSegment): T;
  initWithPosition_onAxis(value: CGFloat, axis: BCAxis): T;
  initWithPoint_axis_wantsGuide_length(point: NSPoint, axis: BCAxis, showGuide: boolean, length: CGFloat): T;
  initWithPoint_directionVector_guideType(point: NSPoint, vector: CGVector, guideType: MSSnappingTargetGuideType): T;
}
declare class MSSnappingTarget extends NSObject implements INSCopying {
  alloc<T extends MSSnappingTarget>(): MSSnappingTargetAllocator<T>;
  static targetsForEdgesOfRect_includeCenter(rect: NSRect, includeCenter: boolean): NSArray<any>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  point(): NSPoint;
  directionVector(): CGVector;
  line(): MSLine;
  lineSegment(): MSLineSegment;
  guideType(): MSSnappingTargetGuideType;
}

declare enum MSSnappingTargetGuideType {
  MSSnappingTargetGuideNone,
  MSSnappingTargetGuidePoint,
  MSSnappingTargetGuideSegment,
}

class MSSortableObjectMenuBuilderAllocator<T extends MSSortableObjectMenuBuilder> extends NSObjectAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class MSSortableObjectMenuBuilder extends NSObject implements INSMenuDelegate {
  alloc<T extends MSSortableObjectMenuBuilder>(): MSSortableObjectMenuBuilderAllocator<T>;
  menuItemsForSortableObjects_selectedObjects_target_selector(objects: NSArray<any> | any[], selectedObjects: NSArray<any> | any[], target: any, action: string): NSArray<any>;
  addSortableObjects_selectedObjects_toPopUpButton_target_selector(objects: NSArray<any> | any[], selectedObjects: NSArray<any> | any[], button: NSPopUpButton, target: any, action: string): void;
  menuWillOpen(menu: NSMenu): void;
  prepareForDisplay(menuItem: NSMenuItem): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

declare interface IMSMenuBuilderDelegate {
  previewColorSpaceForItem(item: NSMenuItem): NSColorSpace;
}

class MSStyleOverridePopupButtonAllocator<T extends MSStyleOverridePopupButton> extends NSPopUpButtonAllocator<T> {}
declare class MSStyleOverridePopupButton extends NSPopUpButton {
  alloc<T extends MSStyleOverridePopupButton>(): MSStyleOverridePopupButtonAllocator<T>;
  buildMenuForOverride_withMenuBuilder_document(primaryOverride: MSAvailableOverride, menuBuilder: MSForeignObjectMenuBuilder, document: MSDocumentData): void;
}

class MSStyleOverridePopupButtonCellAllocator<T extends MSStyleOverridePopupButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSStyleOverridePopupButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSStyleOverridePopupButtonCell>(): MSStyleOverridePopupButtonCellAllocator<T>;
}

class MSStylePartAllocator<T extends MSStylePart> extends _MSStylePartAllocator<T> {}
declare class MSStylePart extends _MSStylePart implements INSCopying, IMSStylePart {
  alloc<T extends MSStylePart>(): MSStylePartAllocator<T>;
  previewImageForSize_colorSpace(size: NSSize, colorSpace: NSColorSpace): NSImage;
  hasEqualAppearance(other: MSStylePart): boolean;
  static stylesHaveEqualAppearance(styles: NSArray<any> | any[]): boolean;
  multiplyBy(amount: CGFloat): void;
  parentStyle(): MSStyle;
  parentLayer(): MSStyledLayer;
  static defaultStylePartForStyle(style: MSStyle): MSStylePart;
  blendingViewForColorInspector(blendingViews: NSDictionary<any, any> | {[key: string]: any}): NSView;
  topViewForColorInspector(topViews: NSDictionary<any, any> | {[key: string]: any}): NSView;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  isEnabled(): boolean;
}

class MSStylePartInspectorValueAdaptorAllocator<T extends MSStylePartInspectorValueAdaptor> extends MSInspectorValueAdaptorAllocator<T> {}
declare class MSStylePartInspectorValueAdaptor extends MSInspectorValueAdaptor {
  alloc<T extends MSStylePartInspectorValueAdaptor>(): MSStylePartInspectorValueAdaptorAllocator<T>;
}

class MSSymbolCreatorAllocator<T extends MSSymbolCreator> extends NSObjectAllocator<T> {}
declare class MSSymbolCreator extends NSObject {
  alloc<T extends MSSymbolCreator>(): MSSymbolCreatorAllocator<T>;
  static canCreateSymbolFromLayers(layers: MSLayerArray): boolean;
  static createSymbolFromLayers_withName_onSymbolsPage(layers: MSLayerArray, name: NSString | string, useSymbolsPage: boolean): MSSymbolInstance;
}

class MSSymbolMasterReferenceAllocator<T extends MSSymbolMasterReference> extends MSShareableObjectReferenceAllocator<T> {}
declare class MSSymbolMasterReference extends MSShareableObjectReference {
  alloc<T extends MSSymbolMasterReference>(): MSSymbolMasterReferenceAllocator<T>;

  symbolMaster(): MSSymbolMaster;
  descriptor(): MSSymbolMasterReferenceDescriptor;
}

class MSSymbolMasterReferenceDescriptorAllocator<T extends MSSymbolMasterReferenceDescriptor> extends NSObjectAllocator<T> {
  initWithPasteboardPropertyList_ofType(propertyList: any, type: NSPasteboardType): T;
}
declare class MSSymbolMasterReferenceDescriptor extends NSObject implements INSPasteboardWriting, INSPasteboardReading {
  alloc<T extends MSSymbolMasterReferenceDescriptor>(): MSSymbolMasterReferenceDescriptorAllocator<T>;
  static pasteboardType(): NSString;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  static readableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  static readingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardReadingOptions;

  libraryLocation(): NSURL;
  setLibraryLocation(libraryLocation: NSURL): void;
  symbolID(): NSString;
  setSymbolID(symbolID: NSString | string): void;
}

class MSSymbolPreviewGeneratorAllocator<T extends MSSymbolPreviewGenerator> extends NSObjectAllocator<T> {}
declare class MSSymbolPreviewGenerator extends NSObject {
  alloc<T extends MSSymbolPreviewGenerator>(): MSSymbolPreviewGeneratorAllocator<T>;
  static imageForSymbolAncestry_withSize_colorSpace_trimmed(ancestry: MSImmutableLayerAncestry, size: NSSize, colorSpace: NSColorSpace, trimmed: boolean): NSImage;
}

class MSTextLayerAllocator<T extends MSTextLayer> extends _MSTextLayerAllocator<T> {
  initWithAttributedString_documentColorSpace_maxWidth(attributedString: NSAttributedString | null, colorSpace: NSColorSpace, maxWidth: CGFloat): T;
  initWithFrame_attributes_documentColorSpace_type(aRect: NSRect, attributes: NSDictionary<any, any> | {[key: string]: any} | null, colorSpace: NSColorSpace, behaviourType: BCTextBehaviourType): T;
}
declare class MSTextLayer extends _MSTextLayer implements IMSFirstLineTypesetterDelegate, IMSColorConvertible {
  alloc<T extends MSTextLayer>(): MSTextLayerAllocator<T>;
  layersByConvertingToOutlines(): NSArray<any>;
  static canSetTextAlignmentForLayers(layers: MSLayerArray): boolean;
  static setTextAlignment_forLayers(alignment: NSTextAlignment, layers: MSLayerArray): void;
  static menuItemStateForAlignment_forLayers(alignment: NSTextAlignment, layers: MSLayerArray): NSInteger;
  static canSetTextVerticalAlignmentForLayers(layers: MSLayerArray): boolean;
  static setTextVerticalAlignment_forLayers(alignment: MSTextStyleVerticalAlignment, layers: MSLayerArray): void;
  static menuItemStateForTextVerticalAlignment_forLayers(alignment: MSTextStyleVerticalAlignment, layers: MSLayerArray): NSInteger;
  static maintainTextLayerBaselinesForLayers_inBlock(textLayers: NSArray<any> | any[], block: BCVoidBlock): void;
  changeFont(sender: any | null): void;
  font(): NSFont;
  shapeToUseForTextOnPath(): MSStyledLayer;
  bezierPathFromGlyphsInBounds(): NSBezierPath;
  isEmpty(): boolean;
  finishEditing(): void;
  updateNameFromStorage(): void;
  replaceMissingFontsIfNecessary(): void;
  adjustFrameToFit(): void;
  ignoreDelegateNotificationsInBlock(block: BCVoidBlock): void;
  addAttribute_value_forRange(attributeName: NSString | string, value: any | null, range: NSRange): void;
  setAttributes_forRange(attributes: NSDictionary<any, any> | {[key: string]: any} | null, range: NSRange): void;
  makeUppercase(sender: any | null): IBAction;
  makeLowercase(sender: any | null): IBAction;
  setTextTransform_range(textTransform: MSAttributedStringTextTransform, range: NSRange): void;
  changeListType(textList: NSTextList | null): void;
  syncTextStyleAttributes(): void;
  checkTextBehaviourAndClippingAfterResizeFromCorner_mayClip(corner: BCCorner, mayClip: boolean): void;
  shouldStorePDFPreviews(): boolean;
  PDFPreview(): MSImageData;
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;
  convertColorsUsing(converter: any): void;
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;
  convertColorsUsing(converter: any): void;

  supportsVerticalAlignment(): boolean;
  previousRectCache(): NSRect;
  setPreviousRectCache(previousRectCache: NSRect): void;
  isEditingText(): boolean;
  setIsEditingText(isEditingText: boolean): void;
  textAlignment(): NSTextAlignment;
  setTextAlignment(textAlignment: NSTextAlignment): void;
  verticalAlignment(): MSTextStyleVerticalAlignment;
  setVerticalAlignment(verticalAlignment: MSTextStyleVerticalAlignment): void;
  characterSpacing(): NSNumber;
  setCharacterSpacing(characterSpacing: NSNumber | number): void;
  fontPostscriptName(): NSString;
  setFontPostscriptName(fontPostscriptName: NSString | string): void;
  styleAttributes(): NSDictionary<any, any>;
  setStyleAttributes(styleAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  stringValue(): NSString;
  setStringValue(stringValue: NSString | string): void;
  attributedStringValue(): NSAttributedString;
  setAttributedStringValue(attributedStringValue: NSAttributedString): void;
  transientGlyphBoundsValue(): NSValue;
  setTransientGlyphBoundsValue(transientGlyphBoundsValue: NSValue): void;
  textColor(): MSColor;
  setTextColor(textColor: MSColor): void;
  editingDelegate(): any;
  setEditingDelegate(editingDelegate: any): void;
}

class MSTextSnapItemAllocator<T extends MSTextSnapItem> extends MSSnapItemAllocator<T> {}
declare class MSTextSnapItem extends MSSnapItem {
  alloc<T extends MSTextSnapItem>(): MSTextSnapItemAllocator<T>;
}

class MSTextStyleMenuPreviewAllocator<T extends MSTextStyleMenuPreview> extends NSObjectAllocator<T> {}
declare class MSTextStyleMenuPreview extends NSObject {
  alloc<T extends MSTextStyleMenuPreview>(): MSTextStyleMenuPreviewAllocator<T>;
  static applyTextStylesToMenuItem_colorSpace(item: NSMenuItem, colorSpace: NSColorSpace): void;
  static attributedTitleForTextStyle_colorSpace(sharedStyle: MSSharedStyle, colorSpace: NSColorSpace): NSAttributedString;
}

class MSToggleHUDActionAllocator<T extends MSToggleHUDAction> extends MSActionAllocator<T> {}
declare class MSToggleHUDAction extends MSAction {
  alloc<T extends MSToggleHUDAction>(): MSToggleHUDActionAllocator<T>;
  toggleHUD(sender: any): IBAction;
}

class MSToolbarItemAllocator<T extends MSToolbarItem> extends NSToolbarItemAllocator<T> {
  initWithAction(action: MSAction): T;
}
declare class MSToolbarItem extends NSToolbarItem {
  alloc<T extends MSToolbarItem>(): MSToolbarItemAllocator<T>;
  makeViewForAction(action: MSAction): NSView;
}

class MSUserAssetLibraryAllocator<T extends MSUserAssetLibrary> extends MSAssetLibraryAllocator<T> {}
declare class MSUserAssetLibrary extends MSAssetLibrary {
  alloc<T extends MSUserAssetLibrary>(): MSUserAssetLibraryAllocator<T>;
}

class MSVectorHandleStateDeciderAllocator<T extends MSVectorHandleStateDecider> extends NSObjectAllocator<T> {}
declare class MSVectorHandleStateDecider extends NSObject {
  alloc<T extends MSVectorHandleStateDecider>(): MSVectorHandleStateDeciderAllocator<T>;
  reset(): void;
  isHandleAtIndexPathSelected(indexPath: NSIndexPath): boolean;
  isHandleAtIndexPathVisible(indexPath: NSIndexPath): boolean;
  stateOfCurvePointAtIndexPath_curveToState_curveFromState(indexPath: NSIndexPath, curveToState: MSHandleState, curveFromState: MSHandleState): MSHandleState;
  indexPathOfHandleAtPoint_tolerance(point: NSPoint, tolerance: CGFloat): NSIndexPath;

  visibilityAroundSelectedHandles(): MSCurveAdjustmentHandleVisibility;
  setVisibilityAroundSelectedHandles(visibilityAroundSelectedHandles: MSCurveAdjustmentHandleVisibility): void;
  visibilityAroundHighlight(): MSCurveAdjustmentHandleVisibility;
  setVisibilityAroundHighlight(visibilityAroundHighlight: MSCurveAdjustmentHandleVisibility): void;
  selectionContext(): MSShapeChangeContext;
  setSelectionContext(selectionContext: MSShapeChangeContext): void;
  indexPathForHighlightedComponent(): NSIndexPath;
  setIndexPathForHighlightedComponent(indexPathForHighlightedComponent: NSIndexPath): void;
}

declare enum MSCurveAdjustmentHandleVisibility {
  MSCurveAdjustmentHandleVisibilityDirect,
  MSCurveAdjustmentHandleVisibilityAdjacent,
  MSCurveAdjustmentHandleVisibilityExtended,
  MSCurveAdjustmentHandleVisibilityAll,
}

class MSVectorRoundingAllocator<T extends MSVectorRounding> extends NSObjectAllocator<T> {}
declare class MSVectorRounding extends NSObject {
  alloc<T extends MSVectorRounding>(): MSVectorRoundingAllocator<T>;
  static precision(): MSVectorPrecision;
  static roundPoint_layer(p: NSPoint, layer: MSLayer): NSPoint;
  static roundPoint(p: NSPoint): NSPoint;
}

declare enum MSVectorPrecision {
  MSVectorPrecisionFreeForm,
  MSVectorPrecisionHalfPixel,
  MSVectorPrecisionPixel,
}

class MSViewPortAllocator<T extends MSViewPort> extends NSObjectAllocator<T> {}
declare class MSViewPort extends NSObject {
  alloc<T extends MSViewPort>(): MSViewPortAllocator<T>;
  static viewPortWithScrollOrigin_zoom(origin: NSPoint, zoom: CGFloat): MSViewPort;
  static cappedZoom(zoom: CGFloat): CGFloat;
  static minimumZoomValue(): CGFloat;
  static maximumZoomValue(): CGFloat;

  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}

declare enum MSWebExportLayerBehavior {
  MSWebExportLayerBehaviorDefault = 0,
  MSWebExportLayerBehaviorScrollable = 1 << 0,
  MSWebExportLayerBehaviorFixedToTop = 1 << 1,
  MSWebExportLayerBehaviorFixedToBottom = 1 << 2,
  MSWebExportLayerBehaviorFixed,
}

class MSWebExportRequestAllocator<T extends MSWebExportRequest> extends MSExportRequestAllocator<T> {}
declare class MSWebExportRequest extends MSExportRequest {
  alloc<T extends MSWebExportRequest>(): MSWebExportRequestAllocator<T>;
  static webExportRequestForRootLayer_inDocument_atScale(rootLayer: MSImmutableLayer, documentData: MSImmutableDocumentData, scale: CGFloat): MSWebExportRequest;

  rootLayer(): MSImmutableLayer;
  setRootLayer(rootLayer: MSImmutableLayer): void;
  layerBehavior(): MSWebExportLayerBehavior;
  setLayerBehavior(layerBehavior: MSWebExportLayerBehavior): void;
}

class MSImmutableArtboardGroupAllocator<T extends MSImmutableArtboardGroup> extends _MSImmutableArtboardGroupAllocator<T> {}
declare class MSImmutableArtboardGroup extends _MSImmutableArtboardGroup implements IMSLayerWithBackgroundColor, IMSArtboardGroup, IMSImmutableRootLayer {
  alloc<T extends MSImmutableArtboardGroup>(): MSImmutableArtboardGroupAllocator<T>;
  shouldDrawBackgroundInContext(context: MSRenderingContext): boolean;
  immutableBackgroundColor(): MSImmutableColor;
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;
  immutableBackgroundColor(): MSImmutableColor;
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;

  unscaledNameSize(): NSSize;
  preset(): MSArtboardPreset;
  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
  grid(): MSImmutableSimpleGrid;
  layout(): MSImmutableLayoutGrid;
}

class MSImmutablePageAllocator<T extends MSImmutablePage> extends _MSImmutablePageAllocator<T> {}
declare class MSImmutablePage extends _MSImmutablePage implements IMSImmutableRootLayer {
  alloc<T extends MSImmutablePage>(): MSImmutablePageAllocator<T>;
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;

  selectedLayerIDs(): NSSet<any>;
  artboards(): NSArray<any>;
  hasArtboards(): boolean;
  symbols(): NSArray<any>;
  grid(): MSImmutableSimpleGrid;
  layout(): MSImmutableLayoutGrid;
}

class MSSubtreeRootAllocator<T extends MSSubtreeRoot> extends NSObjectAllocator<T> {}
declare class MSSubtreeRoot extends NSObject {
  alloc<T extends MSSubtreeRoot>(): MSSubtreeRootAllocator<T>;
  contentDirtyDiffRect(): NSRect;
  overlayInfluenceRect(): NSRect;

  webExportableRootLayer(): MSImmutableLayerGroup;
  object(): MSImmutableModelObject;
  setObject(object: MSImmutableModelObject): void;
  ancestorsOfObject(): NSArray<any>;
  setAncestorsOfObject(ancestorsOfObject: NSArray<any> | any[]): void;
  document(): MSImmutableDocumentData;
  setDocument(document: MSImmutableDocumentData): void;
}

declare interface IMSWebExportableRootLayer {
  webExportLayerBehaviorWithRect_fromLayer(rect: CGRect, layer: MSImmutableLayer): MSWebExportLayerBehavior;
  rectInFixedViewportWithRect_fromFixingLayer(rect: CGRect, layer: MSImmutableLayer): CGRect;

  webExporterBackgoundColor(): MSImmutableColor;
  webExporterShouldIncludeBackgroundColor(): boolean;
  isFlowHome(): boolean;
  preset(): MSArtboardPreset;
  containsFixedLayers(): boolean;
}

class MSWebExporterAllocator<T extends MSWebExporter> extends NSObjectAllocator<T> {
  initWithDocument_name_localURL(doc: MSDocumentData, name: NSString | string, localURL: NSURL): T;
}
declare class MSWebExporter extends NSObject {
  alloc<T extends MSWebExporter>(): MSWebExporterAllocator<T>;
  static exportArtboardsOfDocument_withName_toLocalURL_completionBlock(doc: MSDocumentData, name: NSString | string, localURL: NSURL, completionBlock: MSWebExporterCompletionBlock): void;
  static exportSelectedArtboardsOfDocument_withName_toLocalURL_completionBlock(doc: MSDocumentData, name: NSString | string, localURL: NSURL, completionBlock: MSWebExporterCompletionBlock): void;
  static exportBitmapImageForRequest(request: MSWebExportRequest): NSBitmapImageRep;
  exportArtboardsWithCompletionBlock(completionBlock: MSWebExporterCompletionBlock): void;
  exportDocumentWithUIMetadata_completionBlock(UIMetadata: NSDictionary<any, any> | {[key: string]: any}, completionBlock: MSWebExporterCompletionBlock): void;
  cancel(): void;
  static imageURLWithHash_inDirectory(dataHash: NSString | string, directory: NSURL): NSURL;
  static documentURLInDirectory(directory: NSURL): NSURL;

  documentData(): MSDocumentData;
  destinationURL(): NSURL;
  name(): NSString;
  cacheManager(): MSCacheManager;
  setCacheManager(cacheManager: MSCacheManager): void;
  selectiveExport(): boolean;
  setSelectiveExport(selectiveExport: boolean): void;
}

declare interface IMSWindowBadgeAction {

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class BCSketchFileMigratorClientAllocator<T extends BCSketchFileMigratorClient> extends NSObjectAllocator<T> {}
declare class BCSketchFileMigratorClient extends NSObject {
  alloc<T extends BCSketchFileMigratorClient>(): BCSketchFileMigratorClientAllocator<T>;
  validateDocumentAtURL_options_withReply(atURL: NSURL, options: BCSketchFileMigratorOptions, reply: Block): void;
  migrateDocumentAtURL_intoFolderAtURL_options_withReply(atURL: NSURL, intoURL: NSURL, options: BCSketchFileMigratorOptions, reply: Block): void;
  migrateResourcesWithNames_atURL_options_withReply(names: NSArray<any> | any[], url: NSURL, options: BCSketchFileMigratorOptions, reply: Block): void;
}

declare enum BCSketchFileMigratorOptions {
  BCSketchFileMigrateAsynchronous = 0x00,
  BCSketchFileMigrateSynchronous = 0x01,
  BCSketchFileMigratePartOfChain = 0x02,
  BCSketchFileMigrateBadParameters = 0x04,
}

class BCSketchFileMigratorErrorAllocator<T extends BCSketchFileMigratorError> extends NSErrorAllocator<T> {}
declare class BCSketchFileMigratorError extends NSError {
  alloc<T extends BCSketchFileMigratorError>(): BCSketchFileMigratorErrorAllocator<T>;
  static errorWithCode(code: BCSketchFileMigratorErrorCode): BCSketchFileMigratorError;
  static errorWithCode_underlyingCode_missingFonts(code: BCSketchFileMigratorErrorCode, underlyingCode: MSDocumentErrorCode, missingFonts: NSArray<any> | any[]): BCSketchFileMigratorError;
}

declare enum BCSketchFileMigratorErrorCode {
  BCSketchFileMigratorNoError,
  BCSketchFileMigratorGenericError,
  BCSketchFileMigratorBadFromURL,
  BCSketchFileMigratorBadToURL,
  BCSketchFileMigratorFileAlreadyMigrated,
  BCSketchFileMigratorFileTooNew,
  BCSketchFileMigratorFailedToValidateInputFile,
  BCSketchFileMigratorFailedToReadInputFile,
  BCSketchFileMigratorFailedToWriteOutputFile,
  BCSketchFileMigratorXPCInterrupted,
}

declare interface IBCSketchFileMigrator {
  validateDocumentAtBookmark_withReply(bookmark: NSData, reply: Block): void;
  migrateDocumentAtBookmark_intoFolderAtBookmark_withReply(fromBookmark: NSData, toBookmark: NSData, reply: Block): void;
  migrateResourcesNamed_inFolderAtBookmark_withReply(names: NSArray<any> | any[], bookmark: NSData, reply: Block): void;
}

class SMKArtboardRequestAllocator<T extends SMKArtboardRequest> extends NSObjectAllocator<T> {
  initWithArtboardID_rect_additive_constrainedToSize_scale_type(artboardID: SCKObjectID, rect: CGRect, additive: boolean, constrainingSize: CGSize, scale: CGFloat, type: SCKFileImageType): T;
}
declare class SMKArtboardRequest extends NSObject {
  alloc<T extends SMKArtboardRequest>(): SMKArtboardRequestAllocator<T>;
  static requestForArtboardID_atScale_type(artboardID: SCKObjectID, scale: CGFloat, type: SCKFileImageType): SMKArtboardRequest;
  static requestForArtboardID_atScale_constrainedToSize_type(artboardID: SCKObjectID, scale: CGFloat, size: CGSize, type: SCKFileImageType): SMKArtboardRequest;
  static requestForArtboardID_atScale_constrainedToSize_inRect_type(artboardID: SCKObjectID, scale: CGFloat, size: CGSize, rect: CGRect, type: SCKFileImageType): SMKArtboardRequest;
  static requestForArtboardID_atScale_additiveInRect_type(artboardID: SCKObjectID, scale: CGFloat, rect: CGRect, type: SCKFileImageType): SMKArtboardRequest;
  squashableWithRequest(request: SMKArtboardRequest): boolean;
  squashedWithRequest(request: SMKArtboardRequest): SMKArtboardRequest;
  urlWithHost_port_token(host: NSString | string, port: NSUInteger, token: NSString | string): NSURL;

  artboardID(): SCKObjectID;
  rect(): CGRect;
  scale(): CGFloat;
  constrainingSize(): CGSize;
  isConstrained(): boolean;
  isAdditive(): boolean;
  type(): SCKFileImageType;
}

class SMKMirrorControllerAllocator<T extends SMKMirrorController> extends NSObjectAllocator<T> {}
declare class SMKMirrorController extends NSObject {
  alloc<T extends SMKMirrorController>(): SMKMirrorControllerAllocator<T>;
  disconnect(): void;
  performArtboardRequest_handler(request: SMKArtboardRequest, handler: Block): void;
  performURLRequest_completionHandler(request: NSURLRequest, completionHandler: Block): void;
  connect(client: SMKMirrorClient): void;
  disconnect(client: SMKMirrorClient): void;
  continueUserActivity(userActivity: NSUserActivity): void;
  whitelistClientAdvertisementID(advertisementID: NSUUID): void;
  isClientWhitelisted(client: SMKMirrorClient): boolean;
  invalidateContent(): void;
  invalidateCurrentArtboard(): void;
  invalidateImageForArtboardIdentifier_inRect(identifier: NSString | string, rect: CGRect): void;

  connectionStatus(): SMKConnectionStatus;
  connectionType(): SMKConnectionType;
  serverName(): NSString;
  canDisconnect(): boolean;
  document(): SCKDocument;
  setDocument(document: SCKDocument): void;
  currentArtboardID(): SCKObjectID;
  setCurrentArtboardID(currentArtboardID: SCKObjectID): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  usbEnabled(): boolean;
  webEnabled(): boolean;
  netserviceEnabled(): boolean;
  clients(): NSArray<any>;
  hasConnectedClients(): boolean;
  webURL(): NSURL;
  dataSource(): any;
  setDataSource(dataSource: any): void;
}

class SMKUSBConnectionAllocator<T extends SMKUSBConnection> extends SMKConnectionAllocator<T> {}
declare class SMKUSBConnection extends SMKConnection {
  alloc<T extends SMKUSBConnection>(): SMKUSBConnectionAllocator<T>;
}

class SMKWebConnectionAllocator<T extends SMKWebConnection> extends SMKConnectionAllocator<T> {
  initWithAdvertisement(advertisement: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKWebConnection extends SMKConnection {
  alloc<T extends SMKWebConnection>(): SMKWebConnectionAllocator<T>;
  destroy(): void;

  advertisement(): NSDictionary<any, any>;
  setAdvertisement(advertisement: NSDictionary<any, any> | {[key: string]: any}): void;
  advertising(): boolean;
  setAdvertising(advertising: boolean): void;
}

declare interface ISMKCommunicationInterface {
  startUsingOptions_webPort(options: SMKCommunicationOptions, port: NSUInteger): void;
  connectionInfoWithReply(reply: Block): void;
  connect(connectionID: NSUUID): void;
  disconnect(connectionID: NSUUID): void;
  broadcastData(data: NSData): void;
  sendData_to(data: NSData, connectionID: NSUUID): void;
}

declare enum SMKCommunicationOptions {
  SMKCommunicationOptionsNone = 0,
  SMKCommunicationOptionsDisableUSB = 1 << 0,
  SMKCommunicationOptionsDisableWeb = 1 << 1,
  SMKCommunicationOptionsDisableNetService = 1 << 2,
}

class SMKServerControllerAllocator<T extends SMKServerController> extends NSObjectAllocator<T> {}
declare class SMKServerController extends NSObject {
  alloc<T extends SMKServerController>(): SMKServerControllerAllocator<T>;

  connections(): NSArray<any>;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface ISMKServerControllerDelegate {
  serverController_connectionsDidChange(controller: SMKServerController, connections: NSArray<any> | any[]): void;
}

class SMKUSBServerConnectionAllocator<T extends SMKUSBServerConnection> extends SMKConnectionAllocator<T> {
  initWithDeviceID(deviceID: NSNumber | number): T;
}
declare class SMKUSBServerConnection extends SMKConnection {
  alloc<T extends SMKUSBServerConnection>(): SMKUSBServerConnectionAllocator<T>;

  deviceID(): NSNumber;
}

class SMKUSBServerControllerAllocator<T extends SMKUSBServerController> extends SMKServerControllerAllocator<T> {}
declare class SMKUSBServerController extends SMKServerController {
  alloc<T extends SMKUSBServerController>(): SMKUSBServerControllerAllocator<T>;
}

class SMKWebServerControllerAllocator<T extends SMKWebServerController> extends SMKServerControllerAllocator<T> {
  initWithServerPort(port: NSUInteger): T;
}
declare class SMKWebServerController extends SMKServerController {
  alloc<T extends SMKWebServerController>(): SMKWebServerControllerAllocator<T>;
}

declare interface ISMKCommunicationResponseInterface {
  connectionInfoDidChange(info: NSArray<any> | any[]): void;
  connectionStatusDidChange(info: SMKConnectionInfo): void;
  connectionAdvertisementDidChange(info: SMKConnectionInfo): void;
  connectionInfo_didReceiveData(info: SMKConnectionInfo, data: NSData): void;
}

class SMKMirrorClientAllocator<T extends SMKMirrorClient> extends NSObjectAllocator<T> {}
declare class SMKMirrorClient extends NSObject {
  alloc<T extends SMKMirrorClient>(): SMKMirrorClientAllocator<T>;
  static clientWithConnectionInfo(connectionInfo: SMKConnectionInfo): SMKMirrorClient;

  connectionID(): NSUUID;
  setConnectionID(connectionID: NSUUID): void;
  advertisement(): SMKAdvertisement;
  setAdvertisement(advertisement: SMKAdvertisement): void;
  status(): SMKConnectionStatus;
  setStatus(status: SMKConnectionStatus): void;
  type(): SMKConnectionType;
  setType(type: SMKConnectionType): void;
}

declare interface ISMKMirrorControllerDelegate {
  mirrorController_didChangeClients(controller: SMKMirrorController, clients: NSArray<any> | any[] | null): void;
  mirrorController_didChangeWebURL(controller: SMKMirrorController, url: NSURL | null): void;
}

declare interface ISMKMirrorDataSource {

  currentArtboardID(): NSString;
  manifestContent(): NSDictionary<any, any>;
}

class SMKWebServerAllocator<T extends SMKWebServer> extends NSObjectAllocator<T> {}
declare class SMKWebServer extends NSObject {
  alloc<T extends SMKWebServer>(): SMKWebServerAllocator<T>;
  start(): void;
  stop(): void;
  authorizeAdvertisementID(connectionID: NSUUID): NSString;
  tokenForAdvertisementID(connectionID: NSUUID): NSString;
  deauthorizeAdvertisementID(connectionID: NSUUID): void;
  invalidateArtboardID(artboardID: NSString | string): void;
  invalidateAllArtboards(): void;
  dataForExportRequest(requestURL: NSURL): NSData;

  URL(): NSURL;
  dataSource(): any;
  setDataSource(dataSource: any): void;
  port(): NSUInteger;
}

declare interface ISMKWebServerDataSource {
  renderExportForRequest_handler(requestURL: NSURL, handler: Block): void;
}

class SMKAdvertisementAllocator<T extends SMKAdvertisement> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKAdvertisement extends NSObject implements INSCopying, INSSecureCoding {
  alloc<T extends SMKAdvertisement>(): SMKAdvertisementAllocator<T>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  dictionaryRepresentation(): NSDictionary<any, any>;
  identifier(): NSUUID;
  setIdentifier(identifier: NSUUID): void;
  name(): NSString;
  setName(name: NSString | string): void;
  modelName(): NSString;
  setModelName(modelName: NSString | string): void;
  static supportsSecureCoding(): boolean;
}

class SMKConnectionAllocator<T extends SMKConnection> extends NSObjectAllocator<T> {}
declare class SMKConnection extends NSObject {
  alloc<T extends SMKConnection>(): SMKConnectionAllocator<T>;
  connect(): void;
  close(): void;
  sendData(data: NSData): void;
  didReceiveData(data: NSData): void;

  UUID(): NSUUID;
  error(): NSError;
  queue(): dispatch_queue_t;
  advertisement(): NSDictionary<any, any>;
  status(): NSUInteger;
  setStatus(status: NSUInteger): void;
  connectionInfo(): SMKConnectionInfo;
  connectionType(): NSUInteger;
  resourceHost(): NSString;
}

class SMKConnectionInfoAllocator<T extends SMKConnectionInfo> extends NSObjectAllocator<T> {}
declare class SMKConnectionInfo extends NSObject implements INSSecureCoding {
  alloc<T extends SMKConnectionInfo>(): SMKConnectionInfoAllocator<T>;
  compareConnectionInfo(info: SMKConnectionInfo): NSComparisonResult;

  UUID(): NSUUID;
  setUUID(UUID: NSUUID): void;
  status(): SMKConnectionStatus;
  setStatus(status: SMKConnectionStatus): void;
  type(): SMKConnectionType;
  setType(type: SMKConnectionType): void;
  advertisement(): NSDictionary<any, any>;
  setAdvertisement(advertisement: NSDictionary<any, any> | {[key: string]: any}): void;
  hidden(): boolean;
  static supportsSecureCoding(): boolean;
}

declare enum SMKConnectionStatus {
  SMKConnectionStatusDestroyed,
  SMKConnectionStatusClosed,
  SMKConnectionStatusOpening,
  SMKConnectionStatusOpen,
}

declare enum SMKConnectionType {
  SMKConnectionTypeUSB,
  SMKConnectionTypeBonjour,
  SMKConnectionTypeWeb,
}

declare enum SMKErrorCode {
  SMKConnectionNotEstablishedErrorCode = 2000,
  SMKConnectionDidBecomeCorruptErrorCode = 2001,
  SMKConnectionDidReceiveInvalidDataErrorCode = 2002,
  SMKConnectionCouldNotArchiveObjectErrorCode = 2003,
  SMKConnectionDidTimeoutErrorCode = 2004,
  SMKImageUpdateDataNotAvailableErrorCode = 2005,
}

class SMKMessageAllocator<T extends SMKMessage> extends NSObjectAllocator<T> {
  initWithType(type: NSString | string): T;
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKMessage extends NSObject implements ISMKMessageCoding {
  alloc<T extends SMKMessage>(): SMKMessageAllocator<T>;
  static messageFromData(data: NSData): SMKMessage;

  type(): NSString;
  setType(type: NSString | string): void;
  contentClass(): any;
  content(): any;
  setContent(content: any): void;
  messageData(): NSData;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class SMKManifestMessageContentAllocator<T extends SMKManifestMessageContent> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKManifestMessageContent extends NSObject implements ISMKMessageCoding {
  alloc<T extends SMKManifestMessageContent>(): SMKManifestMessageContentAllocator<T>;

  manifest(): NSDictionary<any, any>;
  setManifest(manifest: NSDictionary<any, any> | {[key: string]: any}): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class SMKArtboardMessageContentAllocator<T extends SMKArtboardMessageContent> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKArtboardMessageContent extends NSObject implements ISMKMessageCoding {
  alloc<T extends SMKArtboardMessageContent>(): SMKArtboardMessageContentAllocator<T>;

  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  rect(): CGRect;
  setRect(rect: CGRect): void;
  constrainingSize(): CGSize;
  setConstrainingSize(constrainingSize: CGSize): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class SMKConnectionMessageContentAllocator<T extends SMKConnectionMessageContent> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKConnectionMessageContent extends NSObject implements ISMKMessageCoding {
  alloc<T extends SMKConnectionMessageContent>(): SMKConnectionMessageContentAllocator<T>;

  token(): NSString;
  setToken(token: NSString | string): void;
  device(): NSString;
  setDevice(device: NSString | string): void;
  serverPort(): NSUInteger;
  setServerPort(serverPort: NSUInteger): void;
  serverName(): NSString;
  setServerName(serverName: NSString | string): void;
  supportsURLRequests(): boolean;
  setSupportsURLRequests(supportsURLRequests: boolean): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class SMKAdvertisementMessageContentAllocator<T extends SMKAdvertisementMessageContent> extends NSObjectAllocator<T> {
  initWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class SMKAdvertisementMessageContent extends NSObject implements ISMKMessageCoding {
  alloc<T extends SMKAdvertisementMessageContent>(): SMKAdvertisementMessageContentAllocator<T>;

  advertisement(): SMKAdvertisement;
  setAdvertisement(advertisement: SMKAdvertisement): void;
  challenge(): NSString;
  setChallenge(challenge: NSString | string): void;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

declare interface ISMKMessageCoding {

  dictionaryRepresentation(): NSDictionary<any, any>;
}

class SMKURLResponseAllocator<T extends SMKURLResponse> extends NSObjectAllocator<T> {}
declare class SMKURLResponse extends NSObject implements INSSecureCoding {
  alloc<T extends SMKURLResponse>(): SMKURLResponseAllocator<T>;

  request(): NSURLRequest;
  setRequest(request: NSURLRequest): void;
  response(): NSURLResponse;
  setResponse(response: NSURLResponse): void;
  data(): NSData;
  setData(data: NSData): void;
  error(): NSError;
  setError(error: NSError): void;
  static supportsSecureCoding(): boolean;
}

class SMKUSBHTTPResponseAllocator<T extends SMKUSBHTTPResponse> extends SMKURLResponseAllocator<T> {}
declare class SMKUSBHTTPResponse extends SMKURLResponse {
  alloc<T extends SMKUSBHTTPResponse>(): SMKUSBHTTPResponseAllocator<T>;
}

class BCStructuredFileAllocator<T extends BCStructuredFile> extends NSObjectAllocator<T> {
  initWithURL_error(url: NSURL, error: NSError): T;
}
declare class BCStructuredFile extends NSObject {
  alloc<T extends BCStructuredFile>(): BCStructuredFileAllocator<T>;
  metadata(): NSDictionary<any, any>;
  metaDataWithKey(key: NSString | string): any;
  dataWithKey_error(key: NSString | string, error: NSError): NSData;
  close(error: NSError): boolean;
}

declare enum BCStructuredFileErrorCode {
  BCStructuredFileUnknownError,
  BCStructuredFileInvalidURL,
  BCStructuredFileErrorClosed,
}

declare enum BCTextBehaviourType {
  BCTextBehaviourFlexibleWidth,
  BCTextBehaviourFixedWidth,
  BCTextBehaviourFixedWidthAndHeight,
}

declare enum BCTextLineSpacingBehaviourType {
  BCTextLineSpacingBehaviourUnknown = -1,
  BCTextLineSpacingBehaviourV1 = 0,
  BCTextLineSpacingBehaviourV2 = 1,
  BCTextLineSpacingBehaviourV3 = 2,
  BCTextLineSpacingBehaviourCurrent,
  BCTextLineSpacingBehaviourDefault,
}

declare enum MSTextStyleVerticalAlignment {
  MSTextStyleVerticalAlignmentTop = 0,
  MSTextStyleVerticalAlignmentMiddle = 1,
  MSTextStyleVerticalAlignmentBottom = 2,
  MSTextStyleVerticalAlignmentDefault,
}

class _MSArtboardGroupAllocator<T extends _MSArtboardGroup> extends MSLayerGroupAllocator<T> {}
declare class _MSArtboardGroup extends MSLayerGroup {
  alloc<T extends _MSArtboardGroup>(): _MSArtboardGroupAllocator<T>;

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
  includeBackgroundColorInExport(): boolean;
  setIncludeBackgroundColorInExport(includeBackgroundColorInExport: boolean): void;
  includeInCloudUpload(): boolean;
  setIncludeInCloudUpload(includeInCloudUpload: boolean): void;
  isFlowHome(): boolean;
  setIsFlowHome(isFlowHome: boolean): void;
  presetDictionary(): NSDictionary<any, any>;
  setPresetDictionary(presetDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  resizesContent(): boolean;
  setResizesContent(resizesContent: boolean): void;
  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  horizontalRulerData(): MSRulerData;
  setHorizontalRulerData(horizontalRulerData: MSRulerData): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  verticalRulerData(): MSRulerData;
  setVerticalRulerData(verticalRulerData: MSRulerData): void;
}

class _MSAssetCollectionAllocator<T extends _MSAssetCollection> extends MSModelObjectAllocator<T> {}
declare class _MSAssetCollection extends MSModelObject {
  alloc<T extends _MSAssetCollection>(): _MSAssetCollectionAllocator<T>;
  addColor(value: MSColor): void;
  addColors(colors: NSArray<any> | any[]): void;
  insertColor_atIndex(value: MSColor, index: NSUInteger): void;
  insertColor_beforeColor(value: MSColor, after: MSColor | null): void;
  insertColors_beforeColor(values: NSArray<any> | any[], before: MSColor | null): void;
  insertColor_afterColor(value: MSColor, after: MSColor | null): void;
  insertColors_afterColor(values: NSArray<any> | any[], after: MSColor | null): void;
  removeColor(value: MSColor): void;
  removeColorAtIndex(index: NSUInteger): void;
  removeColorsAtIndexes(indexes: NSIndexSet): void;
  removeAllColors(): void;
  moveColorIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addExportPreset(value: MSExportPreset): void;
  addExportPresets(exportPresets: NSArray<any> | any[]): void;
  insertExportPreset_atIndex(value: MSExportPreset, index: NSUInteger): void;
  insertExportPreset_beforeExportPreset(value: MSExportPreset, after: MSExportPreset | null): void;
  insertExportPresets_beforeExportPreset(values: NSArray<any> | any[], before: MSExportPreset | null): void;
  insertExportPreset_afterExportPreset(value: MSExportPreset, after: MSExportPreset | null): void;
  insertExportPresets_afterExportPreset(values: NSArray<any> | any[], after: MSExportPreset | null): void;
  removeExportPreset(value: MSExportPreset): void;
  removeExportPresetAtIndex(index: NSUInteger): void;
  removeExportPresetsAtIndexes(indexes: NSIndexSet): void;
  removeAllExportPresets(): void;
  moveExportPresetIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addGradient(value: MSGradient): void;
  addGradients(gradients: NSArray<any> | any[]): void;
  insertGradient_atIndex(value: MSGradient, index: NSUInteger): void;
  insertGradient_beforeGradient(value: MSGradient, after: MSGradient | null): void;
  insertGradients_beforeGradient(values: NSArray<any> | any[], before: MSGradient | null): void;
  insertGradient_afterGradient(value: MSGradient, after: MSGradient | null): void;
  insertGradients_afterGradient(values: NSArray<any> | any[], after: MSGradient | null): void;
  removeGradient(value: MSGradient): void;
  removeGradientAtIndex(index: NSUInteger): void;
  removeGradientsAtIndexes(indexes: NSIndexSet): void;
  removeAllGradients(): void;
  moveGradientIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  images(): NSArray<any>;
  setImages(images: NSArray<any> | any[]): void;
  colors(): NSArray<any>;
  setColors(colors: NSArray<any> | any[]): void;
  exportPresets(): NSArray<any>;
  setExportPresets(exportPresets: NSArray<any> | any[]): void;
  gradients(): NSArray<any>;
  setGradients(gradients: NSArray<any> | any[]): void;
  imageCollection(): MSImageCollection;
  setImageCollection(imageCollection: MSImageCollection): void;
}

class _MSBaseGridAllocator<T extends _MSBaseGrid> extends MSModelObjectAllocator<T> {}
declare class _MSBaseGrid extends MSModelObject {
  alloc<T extends _MSBaseGrid>(): _MSBaseGridAllocator<T>;

  isEnabled(): boolean;
  setIsEnabled(isEnabled: boolean): void;
}

class _MSBitmapLayerAllocator<T extends _MSBitmapLayer> extends MSStyledLayerAllocator<T> {}
declare class _MSBitmapLayer extends MSStyledLayer {
  alloc<T extends _MSBitmapLayer>(): _MSBitmapLayerAllocator<T>;

  clippingMask(): NSRect;
  setClippingMask(clippingMask: NSRect): void;
  fillReplacesImage(): boolean;
  setFillReplacesImage(fillReplacesImage: boolean): void;
  image(): MSImageData;
  setImage(image: MSImageData): void;
  intendedDPI(): NSInteger;
  setIntendedDPI(intendedDPI: NSInteger): void;
}

class _MSColorAllocator<T extends _MSColor> extends MSModelObjectAllocator<T> {}
declare class _MSColor extends MSModelObject {
  alloc<T extends _MSColor>(): _MSColorAllocator<T>;

  alpha(): CGFloat;
  blue(): CGFloat;
  green(): CGFloat;
  red(): CGFloat;
}

class _MSCurvePointAllocator<T extends _MSCurvePoint> extends MSModelObjectAllocator<T> {}
declare class _MSCurvePoint extends MSModelObject {
  alloc<T extends _MSCurvePoint>(): _MSCurvePointAllocator<T>;

  cornerRadius(): CGFloat;
  setCornerRadius(cornerRadius: CGFloat): void;
  curveFrom(): NSPoint;
  setCurveFrom(curveFrom: NSPoint): void;
  curveMode(): MSCurveMode;
  setCurveMode(curveMode: MSCurveMode): void;
  curveTo(): NSPoint;
  setCurveTo(curveTo: NSPoint): void;
  hasCurveFrom(): boolean;
  setHasCurveFrom(hasCurveFrom: boolean): void;
  hasCurveTo(): boolean;
  setHasCurveTo(hasCurveTo: boolean): void;
  point(): NSPoint;
  setPoint(point: NSPoint): void;
}

class _MSDocumentDataAllocator<T extends _MSDocumentData> extends MSModelObjectAllocator<T> {}
declare class _MSDocumentData extends MSModelObject {
  alloc<T extends _MSDocumentData>(): _MSDocumentDataAllocator<T>;
  addForeignLayerStyle(value: MSForeignLayerStyle): void;
  addForeignLayerStyles(foreignLayerStyles: NSArray<any> | any[]): void;
  insertForeignLayerStyle_atIndex(value: MSForeignLayerStyle, index: NSUInteger): void;
  insertForeignLayerStyle_beforeForeignLayerStyle(value: MSForeignLayerStyle, after: MSForeignLayerStyle | null): void;
  insertForeignLayerStyles_beforeForeignLayerStyle(values: NSArray<any> | any[], before: MSForeignLayerStyle | null): void;
  insertForeignLayerStyle_afterForeignLayerStyle(value: MSForeignLayerStyle, after: MSForeignLayerStyle | null): void;
  insertForeignLayerStyles_afterForeignLayerStyle(values: NSArray<any> | any[], after: MSForeignLayerStyle | null): void;
  removeForeignLayerStyle(value: MSForeignLayerStyle): void;
  removeForeignLayerStyleAtIndex(index: NSUInteger): void;
  removeForeignLayerStylesAtIndexes(indexes: NSIndexSet): void;
  removeAllForeignLayerStyles(): void;
  moveForeignLayerStyleIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addForeignSymbol(value: MSForeignSymbol): void;
  addForeignSymbols(foreignSymbols: NSArray<any> | any[]): void;
  insertForeignSymbol_atIndex(value: MSForeignSymbol, index: NSUInteger): void;
  insertForeignSymbol_beforeForeignSymbol(value: MSForeignSymbol, after: MSForeignSymbol | null): void;
  insertForeignSymbols_beforeForeignSymbol(values: NSArray<any> | any[], before: MSForeignSymbol | null): void;
  insertForeignSymbol_afterForeignSymbol(value: MSForeignSymbol, after: MSForeignSymbol | null): void;
  insertForeignSymbols_afterForeignSymbol(values: NSArray<any> | any[], after: MSForeignSymbol | null): void;
  removeForeignSymbol(value: MSForeignSymbol): void;
  removeForeignSymbolAtIndex(index: NSUInteger): void;
  removeForeignSymbolsAtIndexes(indexes: NSIndexSet): void;
  removeAllForeignSymbols(): void;
  moveForeignSymbolIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addForeignTextStyle(value: MSForeignTextStyle): void;
  addForeignTextStyles(foreignTextStyles: NSArray<any> | any[]): void;
  insertForeignTextStyle_atIndex(value: MSForeignTextStyle, index: NSUInteger): void;
  insertForeignTextStyle_beforeForeignTextStyle(value: MSForeignTextStyle, after: MSForeignTextStyle | null): void;
  insertForeignTextStyles_beforeForeignTextStyle(values: NSArray<any> | any[], before: MSForeignTextStyle | null): void;
  insertForeignTextStyle_afterForeignTextStyle(value: MSForeignTextStyle, after: MSForeignTextStyle | null): void;
  insertForeignTextStyles_afterForeignTextStyle(values: NSArray<any> | any[], after: MSForeignTextStyle | null): void;
  removeForeignTextStyle(value: MSForeignTextStyle): void;
  removeForeignTextStyleAtIndex(index: NSUInteger): void;
  removeForeignTextStylesAtIndexes(indexes: NSIndexSet): void;
  removeAllForeignTextStyles(): void;
  moveForeignTextStyleIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addPage(value: MSPage): void;
  addPages(pages: NSArray<any> | any[]): void;
  insertPage_atIndex(value: MSPage, index: NSUInteger): void;
  insertPage_beforePage(value: MSPage, after: MSPage | null): void;
  insertPages_beforePage(values: NSArray<any> | any[], before: MSPage | null): void;
  insertPage_afterPage(value: MSPage, after: MSPage | null): void;
  insertPages_afterPage(values: NSArray<any> | any[], after: MSPage | null): void;
  removePage(value: MSPage): void;
  removePageAtIndex(index: NSUInteger): void;
  removePagesAtIndexes(indexes: NSIndexSet): void;
  removeAllPages(): void;
  movePageIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  colorSpace(): MSColorSpace;
  setColorSpace(colorSpace: MSColorSpace): void;
  currentPageIndex(): NSUInteger;
  setCurrentPageIndex(currentPageIndex: NSUInteger): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  assets(): MSAssetCollection;
  setAssets(assets: MSAssetCollection): void;
  foreignLayerStyles(): NSArray<any>;
  setForeignLayerStyles(foreignLayerStyles: NSArray<any> | any[]): void;
  foreignSymbols(): NSArray<any>;
  setForeignSymbols(foreignSymbols: NSArray<any> | any[]): void;
  foreignTextStyles(): NSArray<any>;
  setForeignTextStyles(foreignTextStyles: NSArray<any> | any[]): void;
  layerStyles(): MSSharedStyleContainer;
  setLayerStyles(layerStyles: MSSharedStyleContainer): void;
  layerSymbols(): MSSymbolContainer;
  setLayerSymbols(layerSymbols: MSSymbolContainer): void;
  layerTextStyles(): MSSharedTextStyleContainer;
  setLayerTextStyles(layerTextStyles: MSSharedTextStyleContainer): void;
  pages(): NSArray<any>;
  setPages(pages: NSArray<any> | any[]): void;
}

class _MSExportFormatAllocator<T extends _MSExportFormat> extends MSModelObjectAllocator<T> {}
declare class _MSExportFormat extends MSModelObject {
  alloc<T extends _MSExportFormat>(): _MSExportFormatAllocator<T>;

  absoluteSize(): CGFloat;
  setAbsoluteSize(absoluteSize: CGFloat): void;
  fileFormat(): NSString;
  setFileFormat(fileFormat: NSString | string): void;
  name(): NSString;
  setName(name: NSString | string): void;
  namingScheme(): MSExportFormatNamingScheme;
  setNamingScheme(namingScheme: MSExportFormatNamingScheme): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  visibleScaleType(): MSUserVisibleScaleType;
  setVisibleScaleType(visibleScaleType: MSUserVisibleScaleType): void;
}

class _MSExportOptionsAllocator<T extends _MSExportOptions> extends MSModelObjectAllocator<T> {}
declare class _MSExportOptions extends MSModelObject {
  alloc<T extends _MSExportOptions>(): _MSExportOptionsAllocator<T>;
  addExportFormat(value: MSExportFormat): void;
  addExportFormats(exportFormats: NSArray<any> | any[]): void;
  insertExportFormat_atIndex(value: MSExportFormat, index: NSUInteger): void;
  insertExportFormat_beforeExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_beforeExportFormat(values: NSArray<any> | any[], before: MSExportFormat | null): void;
  insertExportFormat_afterExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_afterExportFormat(values: NSArray<any> | any[], after: MSExportFormat | null): void;
  removeExportFormat(value: MSExportFormat): void;
  removeExportFormatAtIndex(index: NSUInteger): void;
  removeExportFormatsAtIndexes(indexes: NSIndexSet): void;
  removeAllExportFormats(): void;
  moveExportFormatIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  includedLayerIds(): NSArray<any>;
  setIncludedLayerIds(includedLayerIds: NSArray<any> | any[]): void;
  layerOptions(): MSExportLayerOptions;
  setLayerOptions(layerOptions: MSExportLayerOptions): void;
  shouldTrim(): boolean;
  setShouldTrim(shouldTrim: boolean): void;
  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
}

class _MSExportPresetAllocator<T extends _MSExportPreset> extends MSModelObjectAllocator<T> {}
declare class _MSExportPreset extends MSModelObject {
  alloc<T extends _MSExportPreset>(): _MSExportPresetAllocator<T>;
  addExportFormat(value: MSExportFormat): void;
  addExportFormats(exportFormats: NSArray<any> | any[]): void;
  insertExportFormat_atIndex(value: MSExportFormat, index: NSUInteger): void;
  insertExportFormat_beforeExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_beforeExportFormat(values: NSArray<any> | any[], before: MSExportFormat | null): void;
  insertExportFormat_afterExportFormat(value: MSExportFormat, after: MSExportFormat | null): void;
  insertExportFormats_afterExportFormat(values: NSArray<any> | any[], after: MSExportFormat | null): void;
  removeExportFormat(value: MSExportFormat): void;
  removeExportFormatAtIndex(index: NSUInteger): void;
  removeExportFormatsAtIndexes(indexes: NSIndexSet): void;
  removeAllExportFormats(): void;
  moveExportFormatIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  name(): NSString;
  setName(name: NSString | string): void;
  shouldApplyAutomatically(): boolean;
  setShouldApplyAutomatically(shouldApplyAutomatically: boolean): void;
  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
}

class _MSFlowConnectionAllocator<T extends _MSFlowConnection> extends MSModelObjectAllocator<T> {}
declare class _MSFlowConnection extends MSModelObject {
  alloc<T extends _MSFlowConnection>(): _MSFlowConnectionAllocator<T>;

  animationType(): NSInteger;
  setAnimationType(animationType: NSInteger): void;
  destinationArtboardID(): NSString;
  setDestinationArtboardID(destinationArtboardID: NSString | string): void;
}

class _MSForeignLayerStyleAllocator<T extends _MSForeignLayerStyle> extends MSForeignStyleAllocator<T> {}
declare class _MSForeignLayerStyle extends MSForeignStyle {
  alloc<T extends _MSForeignLayerStyle>(): _MSForeignLayerStyleAllocator<T>;
}

class _MSForeignObjectAllocator<T extends _MSForeignObject> extends MSModelObjectAllocator<T> {}
declare class _MSForeignObject extends MSModelObject {
  alloc<T extends _MSForeignObject>(): _MSForeignObjectAllocator<T>;

  libraryID(): NSString;
  setLibraryID(libraryID: NSString | string): void;
  sourceLibraryName(): NSString;
  setSourceLibraryName(sourceLibraryName: NSString | string): void;
}

class _MSForeignStyleAllocator<T extends _MSForeignStyle> extends MSForeignObjectAllocator<T> {}
declare class _MSForeignStyle extends MSForeignObject {
  alloc<T extends _MSForeignStyle>(): _MSForeignStyleAllocator<T>;

  remoteStyleID(): NSString;
  setRemoteStyleID(remoteStyleID: NSString | string): void;
  localSharedStyle(): MSSharedStyle;
  setLocalSharedStyle(localSharedStyle: MSSharedStyle): void;
}

class _MSForeignSymbolAllocator<T extends _MSForeignSymbol> extends MSForeignObjectAllocator<T> {}
declare class _MSForeignSymbol extends MSForeignObject {
  alloc<T extends _MSForeignSymbol>(): _MSForeignSymbolAllocator<T>;

  originalMaster(): MSSymbolMaster;
  setOriginalMaster(originalMaster: MSSymbolMaster): void;
  symbolMaster(): MSSymbolMaster;
  setSymbolMaster(symbolMaster: MSSymbolMaster): void;
}

class _MSForeignTextStyleAllocator<T extends _MSForeignTextStyle> extends MSForeignStyleAllocator<T> {}
declare class _MSForeignTextStyle extends MSForeignStyle {
  alloc<T extends _MSForeignTextStyle>(): _MSForeignTextStyleAllocator<T>;
}

class _MSGradientAllocator<T extends _MSGradient> extends MSModelObjectAllocator<T> {}
declare class _MSGradient extends MSModelObject {
  alloc<T extends _MSGradient>(): _MSGradientAllocator<T>;
  addGradientStop(value: MSGradientStop): void;
  addGradientStops(stops: NSArray<any> | any[]): void;
  insertGradientStop_atIndex(value: MSGradientStop, index: NSUInteger): void;
  insertGradientStop_beforeGradientStop(value: MSGradientStop, after: MSGradientStop | null): void;
  insertGradientStops_beforeGradientStop(values: NSArray<any> | any[], before: MSGradientStop | null): void;
  insertGradientStop_afterGradientStop(value: MSGradientStop, after: MSGradientStop | null): void;
  insertGradientStops_afterGradientStop(values: NSArray<any> | any[], after: MSGradientStop | null): void;
  removeGradientStop(value: MSGradientStop): void;
  removeGradientStopAtIndex(index: NSUInteger): void;
  removeGradientStopsAtIndexes(indexes: NSIndexSet): void;
  removeAllGradientStops(): void;
  moveGradientStopIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  elipseLength(): CGFloat;
  setElipseLength(elipseLength: CGFloat): void;
  from(): NSPoint;
  setFrom(from: NSPoint): void;
  gradientType(): MSGradientType;
  setGradientType(gradientType: MSGradientType): void;
  to(): NSPoint;
  setTo(to: NSPoint): void;
  stops(): NSArray<any>;
  setStops(stops: NSArray<any> | any[]): void;
}

class _MSGradientStopAllocator<T extends _MSGradientStop> extends MSModelObjectAllocator<T> {}
declare class _MSGradientStop extends MSModelObject {
  alloc<T extends _MSGradientStop>(): _MSGradientStopAllocator<T>;

  position(): CGFloat;
  setPosition(position: CGFloat): void;
  color(): MSColor;
  setColor(color: MSColor): void;
}

class _MSGraphicsContextSettingsAllocator<T extends _MSGraphicsContextSettings> extends MSModelObjectAllocator<T> {}
declare class _MSGraphicsContextSettings extends MSModelObject {
  alloc<T extends _MSGraphicsContextSettings>(): _MSGraphicsContextSettingsAllocator<T>;

  blendMode(): MSBlendMode;
  setBlendMode(blendMode: MSBlendMode): void;
  opacity(): CGFloat;
  setOpacity(opacity: CGFloat): void;
}

class _MSHotspotLayerAllocator<T extends _MSHotspotLayer> extends MSLayerAllocator<T> {}
declare class _MSHotspotLayer extends MSLayer {
  alloc<T extends _MSHotspotLayer>(): _MSHotspotLayerAllocator<T>;
}

class _MSImageCollectionAllocator<T extends _MSImageCollection> extends MSModelObjectAllocator<T> {}
declare class _MSImageCollection extends MSModelObject {
  alloc<T extends _MSImageCollection>(): _MSImageCollectionAllocator<T>;

  images(): NSDictionary<any, any>;
  setImages(images: NSDictionary<any, any> | {[key: string]: any}): void;
}

class _MSImmutableArtboardGroupAllocator<T extends _MSImmutableArtboardGroup> extends MSImmutableLayerGroupAllocator<T> {}
declare class _MSImmutableArtboardGroup extends MSImmutableLayerGroup {
  alloc<T extends _MSImmutableArtboardGroup>(): _MSImmutableArtboardGroupAllocator<T>;

  hasBackgroundColor(): boolean;
  includeBackgroundColorInExport(): boolean;
  includeInCloudUpload(): boolean;
  isFlowHome(): boolean;
  presetDictionary(): NSDictionary<any, any>;
  resizesContent(): boolean;
  backgroundColor(): MSImmutableColor;
  grid(): MSImmutableSimpleGrid;
  horizontalRulerData(): MSImmutableRulerData;
  layout(): MSImmutableLayoutGrid;
  verticalRulerData(): MSImmutableRulerData;
}

class _MSImmutableAssetCollectionAllocator<T extends _MSImmutableAssetCollection> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableAssetCollection extends MSImmutableModelObject {
  alloc<T extends _MSImmutableAssetCollection>(): _MSImmutableAssetCollectionAllocator<T>;

  images(): NSArray<any>;
  colors(): NSArray<any>;
  exportPresets(): NSArray<any>;
  gradients(): NSArray<any>;
  imageCollection(): MSImmutableImageCollection;
}

class _MSImmutableBaseGridAllocator<T extends _MSImmutableBaseGrid> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableBaseGrid extends MSImmutableModelObject {
  alloc<T extends _MSImmutableBaseGrid>(): _MSImmutableBaseGridAllocator<T>;

  isEnabled(): boolean;
}

class _MSImmutableBitmapLayerAllocator<T extends _MSImmutableBitmapLayer> extends MSImmutableStyledLayerAllocator<T> {}
declare class _MSImmutableBitmapLayer extends MSImmutableStyledLayer {
  alloc<T extends _MSImmutableBitmapLayer>(): _MSImmutableBitmapLayerAllocator<T>;

  clippingMask(): NSRect;
  fillReplacesImage(): boolean;
  image(): MSImageData;
  intendedDPI(): NSInteger;
}

class _MSImmutableColorAllocator<T extends _MSImmutableColor> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableColor extends MSImmutableModelObject {
  alloc<T extends _MSImmutableColor>(): _MSImmutableColorAllocator<T>;

  alpha(): CGFloat;
  blue(): CGFloat;
  green(): CGFloat;
  red(): CGFloat;
}

class _MSImmutableCurvePointAllocator<T extends _MSImmutableCurvePoint> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableCurvePoint extends MSImmutableModelObject {
  alloc<T extends _MSImmutableCurvePoint>(): _MSImmutableCurvePointAllocator<T>;

  cornerRadius(): CGFloat;
  curveFrom(): NSPoint;
  curveMode(): MSCurveMode;
  curveTo(): NSPoint;
  hasCurveFrom(): boolean;
  hasCurveTo(): boolean;
  point(): NSPoint;
}

class _MSImmutableDocumentDataAllocator<T extends _MSImmutableDocumentData> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableDocumentData extends MSImmutableModelObject {
  alloc<T extends _MSImmutableDocumentData>(): _MSImmutableDocumentDataAllocator<T>;

  colorSpace(): MSColorSpace;
  currentPageIndex(): NSUInteger;
  userInfo(): NSDictionary<any, any>;
  assets(): MSImmutableAssetCollection;
  foreignLayerStyles(): NSArray<any>;
  foreignSymbols(): NSArray<any>;
  foreignTextStyles(): NSArray<any>;
  layerStyles(): MSImmutableSharedStyleContainer;
  layerSymbols(): MSImmutableSymbolContainer;
  layerTextStyles(): MSImmutableSharedTextStyleContainer;
  pages(): NSArray<any>;
}

class _MSImmutableExportFormatAllocator<T extends _MSImmutableExportFormat> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableExportFormat extends MSImmutableModelObject {
  alloc<T extends _MSImmutableExportFormat>(): _MSImmutableExportFormatAllocator<T>;

  absoluteSize(): CGFloat;
  fileFormat(): NSString;
  name(): NSString;
  namingScheme(): MSExportFormatNamingScheme;
  scale(): CGFloat;
  visibleScaleType(): MSUserVisibleScaleType;
}

class _MSImmutableExportOptionsAllocator<T extends _MSImmutableExportOptions> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableExportOptions extends MSImmutableModelObject {
  alloc<T extends _MSImmutableExportOptions>(): _MSImmutableExportOptionsAllocator<T>;

  includedLayerIds(): NSArray<any>;
  layerOptions(): MSExportLayerOptions;
  shouldTrim(): boolean;
  exportFormats(): NSArray<any>;
}

class _MSImmutableExportPresetAllocator<T extends _MSImmutableExportPreset> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableExportPreset extends MSImmutableModelObject {
  alloc<T extends _MSImmutableExportPreset>(): _MSImmutableExportPresetAllocator<T>;

  name(): NSString;
  shouldApplyAutomatically(): boolean;
  exportFormats(): NSArray<any>;
}

class _MSImmutableFlowConnectionAllocator<T extends _MSImmutableFlowConnection> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableFlowConnection extends MSImmutableModelObject {
  alloc<T extends _MSImmutableFlowConnection>(): _MSImmutableFlowConnectionAllocator<T>;

  animationType(): NSInteger;
  destinationArtboardID(): NSString;
}

class _MSImmutableForeignLayerStyleAllocator<T extends _MSImmutableForeignLayerStyle> extends MSImmutableForeignStyleAllocator<T> {}
declare class _MSImmutableForeignLayerStyle extends MSImmutableForeignStyle {
  alloc<T extends _MSImmutableForeignLayerStyle>(): _MSImmutableForeignLayerStyleAllocator<T>;
}

class _MSImmutableForeignObjectAllocator<T extends _MSImmutableForeignObject> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableForeignObject extends MSImmutableModelObject {
  alloc<T extends _MSImmutableForeignObject>(): _MSImmutableForeignObjectAllocator<T>;

  libraryID(): NSString;
  sourceLibraryName(): NSString;
}

class _MSImmutableForeignStyleAllocator<T extends _MSImmutableForeignStyle> extends MSImmutableForeignObjectAllocator<T> {}
declare class _MSImmutableForeignStyle extends MSImmutableForeignObject {
  alloc<T extends _MSImmutableForeignStyle>(): _MSImmutableForeignStyleAllocator<T>;

  remoteStyleID(): NSString;
  localSharedStyle(): MSImmutableSharedStyle;
}

class _MSImmutableForeignSymbolAllocator<T extends _MSImmutableForeignSymbol> extends MSImmutableForeignObjectAllocator<T> {}
declare class _MSImmutableForeignSymbol extends MSImmutableForeignObject {
  alloc<T extends _MSImmutableForeignSymbol>(): _MSImmutableForeignSymbolAllocator<T>;

  originalMaster(): MSImmutableSymbolMaster;
  symbolMaster(): MSImmutableSymbolMaster;
}

class _MSImmutableForeignTextStyleAllocator<T extends _MSImmutableForeignTextStyle> extends MSImmutableForeignStyleAllocator<T> {}
declare class _MSImmutableForeignTextStyle extends MSImmutableForeignStyle {
  alloc<T extends _MSImmutableForeignTextStyle>(): _MSImmutableForeignTextStyleAllocator<T>;
}

class _MSImmutableGradientAllocator<T extends _MSImmutableGradient> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableGradient extends MSImmutableModelObject {
  alloc<T extends _MSImmutableGradient>(): _MSImmutableGradientAllocator<T>;

  elipseLength(): CGFloat;
  from(): NSPoint;
  gradientType(): MSGradientType;
  to(): NSPoint;
  stops(): NSArray<any>;
}

class _MSImmutableGradientStopAllocator<T extends _MSImmutableGradientStop> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableGradientStop extends MSImmutableModelObject {
  alloc<T extends _MSImmutableGradientStop>(): _MSImmutableGradientStopAllocator<T>;

  position(): CGFloat;
  color(): MSImmutableColor;
}

class _MSImmutableGraphicsContextSettingsAllocator<T extends _MSImmutableGraphicsContextSettings> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableGraphicsContextSettings extends MSImmutableModelObject {
  alloc<T extends _MSImmutableGraphicsContextSettings>(): _MSImmutableGraphicsContextSettingsAllocator<T>;

  blendMode(): MSBlendMode;
  opacity(): CGFloat;
}

class _MSImmutableHotspotLayerAllocator<T extends _MSImmutableHotspotLayer> extends MSImmutableLayerAllocator<T> {}
declare class _MSImmutableHotspotLayer extends MSImmutableLayer {
  alloc<T extends _MSImmutableHotspotLayer>(): _MSImmutableHotspotLayerAllocator<T>;
}

class _MSImmutableImageCollectionAllocator<T extends _MSImmutableImageCollection> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableImageCollection extends MSImmutableModelObject {
  alloc<T extends _MSImmutableImageCollection>(): _MSImmutableImageCollectionAllocator<T>;

  images(): NSDictionary<any, any>;
}

class _MSImmutableLayerAllocator<T extends _MSImmutableLayer> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableLayer extends MSImmutableModelObject {
  alloc<T extends _MSImmutableLayer>(): _MSImmutableLayerAllocator<T>;

  booleanOperation(): MSBooleanOperation;
  isFixedToViewport(): boolean;
  isFlippedHorizontal(): boolean;
  isFlippedVertical(): boolean;
  isLocked(): boolean;
  isVisible(): boolean;
  layerListExpandedType(): MSLayerListStatus;
  name(): NSString;
  nameIsFixed(): boolean;
  originalObjectID(): NSString;
  pathInBounds(): MSPath;
  resizingConstraint(): BCConstraint;
  resizingType(): MSLayerResizingType;
  rotation(): CGFloat;
  shouldBreakMaskChain(): boolean;
  userInfo(): NSDictionary<any, any>;
  exportOptions(): MSImmutableExportOptions;
  flow(): MSImmutableFlowConnection;
  frame(): MSImmutableRect;
}

class _MSImmutableLayerGroupAllocator<T extends _MSImmutableLayerGroup> extends MSImmutableStyledLayerAllocator<T> {}
declare class _MSImmutableLayerGroup extends MSImmutableStyledLayer {
  alloc<T extends _MSImmutableLayerGroup>(): _MSImmutableLayerGroupAllocator<T>;

  hasClickThrough(): boolean;
  sharedObjectID(): NSString;
  layers(): NSArray<any>;
}

class _MSImmutableLayoutGridAllocator<T extends _MSImmutableLayoutGrid> extends MSImmutableBaseGridAllocator<T> {}
declare class _MSImmutableLayoutGrid extends MSImmutableBaseGrid {
  alloc<T extends _MSImmutableLayoutGrid>(): _MSImmutableLayoutGridAllocator<T>;

  columnWidth(): CGFloat;
  drawHorizontal(): boolean;
  drawHorizontalLines(): boolean;
  drawVertical(): boolean;
  gutterHeight(): CGFloat;
  gutterWidth(): CGFloat;
  guttersOutside(): boolean;
  horizontalOffset(): CGFloat;
  numberOfColumns(): CGFloat;
  rowHeightMultiplication(): CGFloat;
  totalWidth(): CGFloat;
}

class _MSImmutableOvalShapeAllocator<T extends _MSImmutableOvalShape> extends MSImmutableShapePathLayerAllocator<T> {}
declare class _MSImmutableOvalShape extends MSImmutableShapePathLayer {
  alloc<T extends _MSImmutableOvalShape>(): _MSImmutableOvalShapeAllocator<T>;
}

class _MSImmutableOverrideValueAllocator<T extends _MSImmutableOverrideValue> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableOverrideValue extends MSImmutableModelObject {
  alloc<T extends _MSImmutableOverrideValue>(): _MSImmutableOverrideValueAllocator<T>;

  overrideName(): NSString;
  value(): NSObject;
}

class _MSImmutablePageAllocator<T extends _MSImmutablePage> extends MSImmutableLayerGroupAllocator<T> {}
declare class _MSImmutablePage extends MSImmutableLayerGroup {
  alloc<T extends _MSImmutablePage>(): _MSImmutablePageAllocator<T>;

  includeInCloudUpload(): boolean;
  grid(): MSImmutableSimpleGrid;
  horizontalRulerData(): MSImmutableRulerData;
  layout(): MSImmutableLayoutGrid;
  verticalRulerData(): MSImmutableRulerData;
}

class _MSImmutablePolygonShapeAllocator<T extends _MSImmutablePolygonShape> extends MSImmutableShapePathLayerAllocator<T> {}
declare class _MSImmutablePolygonShape extends MSImmutableShapePathLayer {
  alloc<T extends _MSImmutablePolygonShape>(): _MSImmutablePolygonShapeAllocator<T>;

  numberOfPoints(): NSInteger;
}

class _MSImmutableRectAllocator<T extends _MSImmutableRect> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableRect extends MSImmutableModelObject {
  alloc<T extends _MSImmutableRect>(): _MSImmutableRectAllocator<T>;

  constrainProportions(): boolean;
  height(): CGFloat;
  width(): CGFloat;
  x(): CGFloat;
  y(): CGFloat;
}

class _MSImmutableRectangleShapeAllocator<T extends _MSImmutableRectangleShape> extends MSImmutableShapePathLayerAllocator<T> {}
declare class _MSImmutableRectangleShape extends MSImmutableShapePathLayer {
  alloc<T extends _MSImmutableRectangleShape>(): _MSImmutableRectangleShapeAllocator<T>;

  fixedRadius(): CGFloat;
  hasConvertedToNewRoundCorners(): boolean;
}

class _MSImmutableRulerDataAllocator<T extends _MSImmutableRulerData> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableRulerData extends MSImmutableModelObject {
  alloc<T extends _MSImmutableRulerData>(): _MSImmutableRulerDataAllocator<T>;

  base(): NSInteger;
  guides(): NSArray<any>;
}

class _MSImmutableShapeGroupAllocator<T extends _MSImmutableShapeGroup> extends MSImmutableLayerGroupAllocator<T> {}
declare class _MSImmutableShapeGroup extends MSImmutableLayerGroup {
  alloc<T extends _MSImmutableShapeGroup>(): _MSImmutableShapeGroupAllocator<T>;
}

class _MSImmutableShapePathAllocator<T extends _MSImmutableShapePath> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableShapePath extends MSImmutableModelObject {
  alloc<T extends _MSImmutableShapePath>(): _MSImmutableShapePathAllocator<T>;

  isClosed(): boolean;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  points(): NSArray<any>;
}

class _MSImmutableShapePathLayerAllocator<T extends _MSImmutableShapePathLayer> extends MSImmutableStyledLayerAllocator<T> {}
declare class _MSImmutableShapePathLayer extends MSImmutableStyledLayer {
  alloc<T extends _MSImmutableShapePathLayer>(): _MSImmutableShapePathLayerAllocator<T>;

  edited(): boolean;
  isClosed(): boolean;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  points(): NSArray<any>;
}

class _MSImmutableSharedObjectAllocator<T extends _MSImmutableSharedObject> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableSharedObject extends MSImmutableModelObject {
  alloc<T extends _MSImmutableSharedObject>(): _MSImmutableSharedObjectAllocator<T>;

  name(): NSString;
  value(): MSImmutableModelObject;
}

class _MSImmutableSharedObjectContainerAllocator<T extends _MSImmutableSharedObjectContainer> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableSharedObjectContainer extends MSImmutableModelObject {
  alloc<T extends _MSImmutableSharedObjectContainer>(): _MSImmutableSharedObjectContainerAllocator<T>;

  objects(): NSArray<any>;
}

class _MSImmutableSharedStyleAllocator<T extends _MSImmutableSharedStyle> extends MSImmutableSharedObjectAllocator<T> {}
declare class _MSImmutableSharedStyle extends MSImmutableSharedObject {
  alloc<T extends _MSImmutableSharedStyle>(): _MSImmutableSharedStyleAllocator<T>;
}

class _MSImmutableSharedStyleContainerAllocator<T extends _MSImmutableSharedStyleContainer> extends MSImmutableSharedObjectContainerAllocator<T> {}
declare class _MSImmutableSharedStyleContainer extends MSImmutableSharedObjectContainer {
  alloc<T extends _MSImmutableSharedStyleContainer>(): _MSImmutableSharedStyleContainerAllocator<T>;
}

class _MSImmutableSharedTextStyleContainerAllocator<T extends _MSImmutableSharedTextStyleContainer> extends MSImmutableSharedStyleContainerAllocator<T> {}
declare class _MSImmutableSharedTextStyleContainer extends MSImmutableSharedStyleContainer {
  alloc<T extends _MSImmutableSharedTextStyleContainer>(): _MSImmutableSharedTextStyleContainerAllocator<T>;
}

class _MSImmutableSimpleGridAllocator<T extends _MSImmutableSimpleGrid> extends MSImmutableBaseGridAllocator<T> {}
declare class _MSImmutableSimpleGrid extends MSImmutableBaseGrid {
  alloc<T extends _MSImmutableSimpleGrid>(): _MSImmutableSimpleGridAllocator<T>;

  gridSize(): NSInteger;
  thickGridTimes(): NSInteger;
}

class _MSImmutableSliceLayerAllocator<T extends _MSImmutableSliceLayer> extends MSImmutableLayerAllocator<T> {}
declare class _MSImmutableSliceLayer extends MSImmutableLayer {
  alloc<T extends _MSImmutableSliceLayer>(): _MSImmutableSliceLayerAllocator<T>;

  hasBackgroundColor(): boolean;
  backgroundColor(): MSImmutableColor;
}

class _MSImmutableStarShapeAllocator<T extends _MSImmutableStarShape> extends MSImmutableShapePathLayerAllocator<T> {}
declare class _MSImmutableStarShape extends MSImmutableShapePathLayer {
  alloc<T extends _MSImmutableStarShape>(): _MSImmutableStarShapeAllocator<T>;

  numberOfPoints(): NSInteger;
  radius(): CGFloat;
}

class _MSImmutableStyleAllocator<T extends _MSImmutableStyle> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableStyle extends MSImmutableModelObject {
  alloc<T extends _MSImmutableStyle>(): _MSImmutableStyleAllocator<T>;

  endMarkerType(): MSMarkerType;
  miterLimit(): NSInteger;
  sharedObjectID(): NSString;
  startMarkerType(): MSMarkerType;
  windingRule(): NSWindingRule;
  blur(): MSImmutableStyleBlur;
  borderOptions(): MSImmutableStyleBorderOptions;
  borders(): NSArray<any>;
  colorControls(): MSImmutableStyleColorControls;
  contextSettings(): MSImmutableGraphicsContextSettings;
  fills(): NSArray<any>;
  innerShadows(): NSArray<any>;
  shadows(): NSArray<any>;
  textStyle(): MSImmutableTextStyle;
}

class _MSImmutableStyleBasicFillAllocator<T extends _MSImmutableStyleBasicFill> extends MSImmutableStylePartAllocator<T> {}
declare class _MSImmutableStyleBasicFill extends MSImmutableStylePart {
  alloc<T extends _MSImmutableStyleBasicFill>(): _MSImmutableStyleBasicFillAllocator<T>;

  fillType(): BCFillType;
  color(): MSImmutableColor;
  contextSettings(): MSImmutableGraphicsContextSettings;
  gradient(): MSImmutableGradient;
}

class _MSImmutableStyleBlurAllocator<T extends _MSImmutableStyleBlur> extends MSImmutableStylePartAllocator<T> {}
declare class _MSImmutableStyleBlur extends MSImmutableStylePart {
  alloc<T extends _MSImmutableStyleBlur>(): _MSImmutableStyleBlurAllocator<T>;

  center(): NSPoint;
  motionAngle(): CGFloat;
  radius(): CGFloat;
  saturation(): CGFloat;
  type(): MSStyleBlurType;
}

class _MSImmutableStyleBorderAllocator<T extends _MSImmutableStyleBorder> extends MSImmutableStyleBasicFillAllocator<T> {}
declare class _MSImmutableStyleBorder extends MSImmutableStyleBasicFill {
  alloc<T extends _MSImmutableStyleBorder>(): _MSImmutableStyleBorderAllocator<T>;

  position(): MSBorderPositionType;
  thickness(): CGFloat;
}

class _MSImmutableStyleBorderOptionsAllocator<T extends _MSImmutableStyleBorderOptions> extends MSImmutableStylePartAllocator<T> {}
declare class _MSImmutableStyleBorderOptions extends MSImmutableStylePart {
  alloc<T extends _MSImmutableStyleBorderOptions>(): _MSImmutableStyleBorderOptionsAllocator<T>;

  dashPattern(): NSArray<any>;
  lineCapStyle(): NSLineCapStyle;
  lineJoinStyle(): NSLineJoinStyle;
}

class _MSImmutableStyleColorControlsAllocator<T extends _MSImmutableStyleColorControls> extends MSImmutableStylePartAllocator<T> {}
declare class _MSImmutableStyleColorControls extends MSImmutableStylePart {
  alloc<T extends _MSImmutableStyleColorControls>(): _MSImmutableStyleColorControlsAllocator<T>;

  brightness(): CGFloat;
  contrast(): CGFloat;
  hue(): CGFloat;
  saturation(): CGFloat;
}

class _MSImmutableStyleFillAllocator<T extends _MSImmutableStyleFill> extends MSImmutableStyleBasicFillAllocator<T> {}
declare class _MSImmutableStyleFill extends MSImmutableStyleBasicFill {
  alloc<T extends _MSImmutableStyleFill>(): _MSImmutableStyleFillAllocator<T>;

  image(): MSImageData;
  noiseIndex(): NSInteger;
  noiseIntensity(): CGFloat;
  patternFillType(): MSPatternFillType;
  patternTileScale(): CGFloat;
}

class _MSImmutableStyleInnerShadowAllocator<T extends _MSImmutableStyleInnerShadow> extends MSImmutableStyleShadowAllocator<T> {}
declare class _MSImmutableStyleInnerShadow extends MSImmutableStyleShadow {
  alloc<T extends _MSImmutableStyleInnerShadow>(): _MSImmutableStyleInnerShadowAllocator<T>;
}

class _MSImmutableStylePartAllocator<T extends _MSImmutableStylePart> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableStylePart extends MSImmutableModelObject {
  alloc<T extends _MSImmutableStylePart>(): _MSImmutableStylePartAllocator<T>;

  isEnabled(): boolean;
}

class _MSImmutableStyleReflectionAllocator<T extends _MSImmutableStyleReflection> extends MSImmutableStylePartAllocator<T> {}
declare class _MSImmutableStyleReflection extends MSImmutableStylePart {
  alloc<T extends _MSImmutableStyleReflection>(): _MSImmutableStyleReflectionAllocator<T>;

  distance(): CGFloat;
  strength(): CGFloat;
}

class _MSImmutableStyleShadowAllocator<T extends _MSImmutableStyleShadow> extends MSImmutableStylePartAllocator<T> {}
declare class _MSImmutableStyleShadow extends MSImmutableStylePart {
  alloc<T extends _MSImmutableStyleShadow>(): _MSImmutableStyleShadowAllocator<T>;

  blurRadius(): CGFloat;
  offsetX(): CGFloat;
  offsetY(): CGFloat;
  spread(): CGFloat;
  color(): MSImmutableColor;
  contextSettings(): MSImmutableGraphicsContextSettings;
}

class _MSImmutableStyledLayerAllocator<T extends _MSImmutableStyledLayer> extends MSImmutableLayerAllocator<T> {}
declare class _MSImmutableStyledLayer extends MSImmutableLayer {
  alloc<T extends _MSImmutableStyledLayer>(): _MSImmutableStyledLayerAllocator<T>;

  clippingMaskMode(): NSInteger;
  hasClippingMask(): boolean;
  style(): MSImmutableStyle;
}

class _MSImmutableSymbolAllocator<T extends _MSImmutableSymbol> extends MSImmutableSharedObjectAllocator<T> {}
declare class _MSImmutableSymbol extends MSImmutableSharedObject {
  alloc<T extends _MSImmutableSymbol>(): _MSImmutableSymbolAllocator<T>;
}

class _MSImmutableSymbolContainerAllocator<T extends _MSImmutableSymbolContainer> extends MSImmutableSharedObjectContainerAllocator<T> {}
declare class _MSImmutableSymbolContainer extends MSImmutableSharedObjectContainer {
  alloc<T extends _MSImmutableSymbolContainer>(): _MSImmutableSymbolContainerAllocator<T>;
}

class _MSImmutableSymbolInstanceAllocator<T extends _MSImmutableSymbolInstance> extends MSImmutableStyledLayerAllocator<T> {}
declare class _MSImmutableSymbolInstance extends MSImmutableStyledLayer {
  alloc<T extends _MSImmutableSymbolInstance>(): _MSImmutableSymbolInstanceAllocator<T>;

  horizontalSpacing(): CGFloat;
  scale(): CGFloat;
  symbolID(): NSString;
  verticalSpacing(): CGFloat;
  overrideValues(): NSArray<any>;
}

class _MSImmutableSymbolMasterAllocator<T extends _MSImmutableSymbolMaster> extends MSImmutableArtboardGroupAllocator<T> {}
declare class _MSImmutableSymbolMaster extends MSImmutableArtboardGroup {
  alloc<T extends _MSImmutableSymbolMaster>(): _MSImmutableSymbolMasterAllocator<T>;

  includeBackgroundColorInInstance(): boolean;
  symbolID(): NSString;
}

class _MSImmutableTextLayerAllocator<T extends _MSImmutableTextLayer> extends MSImmutableStyledLayerAllocator<T> {}
declare class _MSImmutableTextLayer extends MSImmutableStyledLayer {
  alloc<T extends _MSImmutableTextLayer>(): _MSImmutableTextLayerAllocator<T>;

  attributedString(): MSAttributedString;
  automaticallyDrawOnUnderlyingPath(): boolean;
  dontSynchroniseWithSymbol(): boolean;
  glyphBounds(): NSRect;
  lineSpacingBehaviour(): BCTextLineSpacingBehaviourType;
  preview(): MSImageData;
  textBehaviour(): BCTextBehaviourType;
}

class _MSImmutableTextStyleAllocator<T extends _MSImmutableTextStyle> extends MSImmutableModelObjectAllocator<T> {}
declare class _MSImmutableTextStyle extends MSImmutableModelObject {
  alloc<T extends _MSImmutableTextStyle>(): _MSImmutableTextStyleAllocator<T>;

  encodedAttributes(): NSDictionary<any, any>;
  verticalAlignment(): MSTextStyleVerticalAlignment;
}

class _MSImmutableTriangleShapeAllocator<T extends _MSImmutableTriangleShape> extends MSImmutableShapePathLayerAllocator<T> {}
declare class _MSImmutableTriangleShape extends MSImmutableShapePathLayer {
  alloc<T extends _MSImmutableTriangleShape>(): _MSImmutableTriangleShapeAllocator<T>;

  isEquilateral(): boolean;
}

class _MSLayerAllocator<T extends _MSLayer> extends MSModelObjectAllocator<T> {}
declare class _MSLayer extends MSModelObject {
  alloc<T extends _MSLayer>(): _MSLayerAllocator<T>;

  booleanOperation(): MSBooleanOperation;
  setBooleanOperation(booleanOperation: MSBooleanOperation): void;
  isFixedToViewport(): boolean;
  setIsFixedToViewport(isFixedToViewport: boolean): void;
  isFlippedHorizontal(): boolean;
  setIsFlippedHorizontal(isFlippedHorizontal: boolean): void;
  isFlippedVertical(): boolean;
  setIsFlippedVertical(isFlippedVertical: boolean): void;
  isLocked(): boolean;
  setIsLocked(isLocked: boolean): void;
  isVisible(): boolean;
  setIsVisible(isVisible: boolean): void;
  layerListExpandedType(): MSLayerListStatus;
  setLayerListExpandedType(layerListExpandedType: MSLayerListStatus): void;
  name(): NSString;
  setName(name: NSString | string): void;
  nameIsFixed(): boolean;
  setNameIsFixed(nameIsFixed: boolean): void;
  originalObjectID(): NSString;
  setOriginalObjectID(originalObjectID: NSString | string): void;
  pathInBounds(): MSPath;
  resizingConstraint(): BCConstraint;
  setResizingConstraint(resizingConstraint: BCConstraint): void;
  resizingType(): MSLayerResizingType;
  setResizingType(resizingType: MSLayerResizingType): void;
  rotation(): CGFloat;
  setRotation(rotation: CGFloat): void;
  shouldBreakMaskChain(): boolean;
  setShouldBreakMaskChain(shouldBreakMaskChain: boolean): void;
  userInfo(): NSDictionary<any, any>;
  setUserInfo(userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  exportOptions(): MSExportOptions;
  setExportOptions(exportOptions: MSExportOptions): void;
  flow(): MSFlowConnection;
  setFlow(flow: MSFlowConnection): void;
  frame(): MSRect;
  setFrame(frame: MSRect): void;
}

class _MSLayerGroupAllocator<T extends _MSLayerGroup> extends MSStyledLayerAllocator<T> {}
declare class _MSLayerGroup extends MSStyledLayer {
  alloc<T extends _MSLayerGroup>(): _MSLayerGroupAllocator<T>;
  addLayer(value: MSLayer): void;
  addLayers(layers: NSArray<any> | any[]): void;
  insertLayer_atIndex(value: MSLayer, index: NSUInteger): void;
  insertLayer_beforeLayer(value: MSLayer, after: MSLayer | null): void;
  insertLayers_beforeLayer(values: NSArray<any> | any[], before: MSLayer | null): void;
  insertLayer_afterLayer(value: MSLayer, after: MSLayer | null): void;
  insertLayers_afterLayer(values: NSArray<any> | any[], after: MSLayer | null): void;
  removeLayer(value: MSLayer): void;
  removeLayerAtIndex(index: NSUInteger): void;
  removeLayersAtIndexes(indexes: NSIndexSet): void;
  removeAllLayers(): void;
  moveLayerIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  hasClickThrough(): boolean;
  setHasClickThrough(hasClickThrough: boolean): void;
  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}

class _MSLayoutGridAllocator<T extends _MSLayoutGrid> extends MSBaseGridAllocator<T> {}
declare class _MSLayoutGrid extends MSBaseGrid {
  alloc<T extends _MSLayoutGrid>(): _MSLayoutGridAllocator<T>;

  columnWidth(): CGFloat;
  setColumnWidth(columnWidth: CGFloat): void;
  drawHorizontal(): boolean;
  setDrawHorizontal(drawHorizontal: boolean): void;
  drawHorizontalLines(): boolean;
  setDrawHorizontalLines(drawHorizontalLines: boolean): void;
  drawVertical(): boolean;
  setDrawVertical(drawVertical: boolean): void;
  gutterHeight(): CGFloat;
  setGutterHeight(gutterHeight: CGFloat): void;
  gutterWidth(): CGFloat;
  setGutterWidth(gutterWidth: CGFloat): void;
  guttersOutside(): boolean;
  setGuttersOutside(guttersOutside: boolean): void;
  horizontalOffset(): CGFloat;
  setHorizontalOffset(horizontalOffset: CGFloat): void;
  numberOfColumns(): CGFloat;
  setNumberOfColumns(numberOfColumns: CGFloat): void;
  rowHeightMultiplication(): CGFloat;
  setRowHeightMultiplication(rowHeightMultiplication: CGFloat): void;
  totalWidth(): CGFloat;
  setTotalWidth(totalWidth: CGFloat): void;
}

class _MSOvalShapeAllocator<T extends _MSOvalShape> extends MSShapePathLayerAllocator<T> {}
declare class _MSOvalShape extends MSShapePathLayer {
  alloc<T extends _MSOvalShape>(): _MSOvalShapeAllocator<T>;
}

class _MSOverrideValueAllocator<T extends _MSOverrideValue> extends MSModelObjectAllocator<T> {}
declare class _MSOverrideValue extends MSModelObject {
  alloc<T extends _MSOverrideValue>(): _MSOverrideValueAllocator<T>;

  overrideName(): NSString;
  setOverrideName(overrideName: NSString | string): void;
  value(): NSObject;
  setValue(value: NSObject): void;
}

class _MSPageAllocator<T extends _MSPage> extends MSLayerGroupAllocator<T> {}
declare class _MSPage extends MSLayerGroup {
  alloc<T extends _MSPage>(): _MSPageAllocator<T>;

  includeInCloudUpload(): boolean;
  setIncludeInCloudUpload(includeInCloudUpload: boolean): void;
  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  horizontalRulerData(): MSRulerData;
  setHorizontalRulerData(horizontalRulerData: MSRulerData): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  verticalRulerData(): MSRulerData;
  setVerticalRulerData(verticalRulerData: MSRulerData): void;
}

class _MSPolygonShapeAllocator<T extends _MSPolygonShape> extends MSShapePathLayerAllocator<T> {}
declare class _MSPolygonShape extends MSShapePathLayer {
  alloc<T extends _MSPolygonShape>(): _MSPolygonShapeAllocator<T>;

  numberOfPoints(): NSInteger;
  setNumberOfPoints(numberOfPoints: NSInteger): void;
}

class _MSRectAllocator<T extends _MSRect> extends MSModelObjectAllocator<T> {}
declare class _MSRect extends MSModelObject {
  alloc<T extends _MSRect>(): _MSRectAllocator<T>;

  constrainProportions(): boolean;
  setConstrainProportions(constrainProportions: boolean): void;
  height(): CGFloat;
  setHeight(height: CGFloat): void;
  width(): CGFloat;
  setWidth(width: CGFloat): void;
  x(): CGFloat;
  setX(x: CGFloat): void;
  y(): CGFloat;
  setY(y: CGFloat): void;
}

class _MSRectangleShapeAllocator<T extends _MSRectangleShape> extends MSShapePathLayerAllocator<T> {}
declare class _MSRectangleShape extends MSShapePathLayer {
  alloc<T extends _MSRectangleShape>(): _MSRectangleShapeAllocator<T>;

  fixedRadius(): CGFloat;
  setFixedRadius(fixedRadius: CGFloat): void;
  hasConvertedToNewRoundCorners(): boolean;
  setHasConvertedToNewRoundCorners(hasConvertedToNewRoundCorners: boolean): void;
}

class _MSRulerDataAllocator<T extends _MSRulerData> extends MSModelObjectAllocator<T> {}
declare class _MSRulerData extends MSModelObject {
  alloc<T extends _MSRulerData>(): _MSRulerDataAllocator<T>;

  base(): NSInteger;
  setBase(base: NSInteger): void;
  guides(): NSArray<any>;
  setGuides(guides: NSArray<any> | any[]): void;
}

class _MSShapeGroupAllocator<T extends _MSShapeGroup> extends MSLayerGroupAllocator<T> {}
declare class _MSShapeGroup extends MSLayerGroup {
  alloc<T extends _MSShapeGroup>(): _MSShapeGroupAllocator<T>;
}

class _MSShapePathAllocator<T extends _MSShapePath> extends MSModelObjectAllocator<T> {}
declare class _MSShapePath extends MSModelObject {
  alloc<T extends _MSShapePath>(): _MSShapePathAllocator<T>;
  addCurvePoint(value: MSCurvePoint): void;
  addCurvePoints(points: NSArray<any> | any[]): void;
  insertCurvePoint_atIndex(value: MSCurvePoint, index: NSUInteger): void;
  insertCurvePoint_beforeCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_beforeCurvePoint(values: NSArray<any> | any[], before: MSCurvePoint | null): void;
  insertCurvePoint_afterCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_afterCurvePoint(values: NSArray<any> | any[], after: MSCurvePoint | null): void;
  removeCurvePoint(value: MSCurvePoint): void;
  removeCurvePointAtIndex(index: NSUInteger): void;
  removeCurvePointsAtIndexes(indexes: NSIndexSet): void;
  removeAllCurvePoints(): void;
  moveCurvePointIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  setPointRadiusBehaviour(pointRadiusBehaviour: MSPointRadiusBehaviour): void;
  points(): NSArray<any>;
  setPoints(points: NSArray<any> | any[]): void;
}

class _MSShapePathLayerAllocator<T extends _MSShapePathLayer> extends MSStyledLayerAllocator<T> {}
declare class _MSShapePathLayer extends MSStyledLayer {
  alloc<T extends _MSShapePathLayer>(): _MSShapePathLayerAllocator<T>;
  addCurvePoint(value: MSCurvePoint): void;
  addCurvePoints(points: NSArray<any> | any[]): void;
  insertCurvePoint_atIndex(value: MSCurvePoint, index: NSUInteger): void;
  insertCurvePoint_beforeCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_beforeCurvePoint(values: NSArray<any> | any[], before: MSCurvePoint | null): void;
  insertCurvePoint_afterCurvePoint(value: MSCurvePoint, after: MSCurvePoint | null): void;
  insertCurvePoints_afterCurvePoint(values: NSArray<any> | any[], after: MSCurvePoint | null): void;
  removeCurvePoint(value: MSCurvePoint): void;
  removeCurvePointAtIndex(index: NSUInteger): void;
  removeCurvePointsAtIndexes(indexes: NSIndexSet): void;
  removeAllCurvePoints(): void;
  moveCurvePointIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  edited(): boolean;
  setEdited(edited: boolean): void;
  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  pointRadiusBehaviour(): MSPointRadiusBehaviour;
  setPointRadiusBehaviour(pointRadiusBehaviour: MSPointRadiusBehaviour): void;
  points(): NSArray<any>;
  setPoints(points: NSArray<any> | any[]): void;
}

class _MSSharedObjectAllocator<T extends _MSSharedObject> extends MSModelObjectAllocator<T> {}
declare class _MSSharedObject extends MSModelObject {
  alloc<T extends _MSSharedObject>(): _MSSharedObjectAllocator<T>;

  name(): NSString;
  setName(name: NSString | string): void;
  value(): MSModelObjectCommon;
  setValue(value: MSModelObjectCommon): void;
}

class _MSSharedObjectContainerAllocator<T extends _MSSharedObjectContainer> extends MSModelObjectAllocator<T> {}
declare class _MSSharedObjectContainer extends MSModelObject {
  alloc<T extends _MSSharedObjectContainer>(): _MSSharedObjectContainerAllocator<T>;
  addSharedObject(value: MSSharedObject): void;
  addSharedObjects(objects: NSArray<any> | any[]): void;
  insertSharedObject_atIndex(value: MSSharedObject, index: NSUInteger): void;
  insertSharedObject_beforeSharedObject(value: MSSharedObject, after: MSSharedObject | null): void;
  insertSharedObjects_beforeSharedObject(values: NSArray<any> | any[], before: MSSharedObject | null): void;
  insertSharedObject_afterSharedObject(value: MSSharedObject, after: MSSharedObject | null): void;
  insertSharedObjects_afterSharedObject(values: NSArray<any> | any[], after: MSSharedObject | null): void;
  removeSharedObject(value: MSSharedObject): void;
  removeSharedObjectAtIndex(index: NSUInteger): void;
  removeSharedObjectsAtIndexes(indexes: NSIndexSet): void;
  removeAllSharedObjects(): void;
  moveSharedObjectIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  objects(): NSArray<any>;
  setObjects(objects: NSArray<any> | any[]): void;
}

class _MSSharedStyleAllocator<T extends _MSSharedStyle> extends MSSharedObjectAllocator<T> {}
declare class _MSSharedStyle extends MSSharedObject {
  alloc<T extends _MSSharedStyle>(): _MSSharedStyleAllocator<T>;
}

class _MSSharedStyleContainerAllocator<T extends _MSSharedStyleContainer> extends MSSharedObjectContainerAllocator<T> {}
declare class _MSSharedStyleContainer extends MSSharedObjectContainer {
  alloc<T extends _MSSharedStyleContainer>(): _MSSharedStyleContainerAllocator<T>;
}

class _MSSharedTextStyleContainerAllocator<T extends _MSSharedTextStyleContainer> extends MSSharedStyleContainerAllocator<T> {}
declare class _MSSharedTextStyleContainer extends MSSharedStyleContainer {
  alloc<T extends _MSSharedTextStyleContainer>(): _MSSharedTextStyleContainerAllocator<T>;
}

class _MSSimpleGridAllocator<T extends _MSSimpleGrid> extends MSBaseGridAllocator<T> {}
declare class _MSSimpleGrid extends MSBaseGrid {
  alloc<T extends _MSSimpleGrid>(): _MSSimpleGridAllocator<T>;

  gridSize(): NSInteger;
  setGridSize(gridSize: NSInteger): void;
  thickGridTimes(): NSInteger;
  setThickGridTimes(thickGridTimes: NSInteger): void;
}

class _MSSliceLayerAllocator<T extends _MSSliceLayer> extends MSLayerAllocator<T> {}
declare class _MSSliceLayer extends MSLayer {
  alloc<T extends _MSSliceLayer>(): _MSSliceLayerAllocator<T>;

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
}

class _MSStarShapeAllocator<T extends _MSStarShape> extends MSShapePathLayerAllocator<T> {}
declare class _MSStarShape extends MSShapePathLayer {
  alloc<T extends _MSStarShape>(): _MSStarShapeAllocator<T>;

  numberOfPoints(): NSInteger;
  setNumberOfPoints(numberOfPoints: NSInteger): void;
  radius(): CGFloat;
  setRadius(radius: CGFloat): void;
}

class _MSStyleAllocator<T extends _MSStyle> extends MSModelObjectAllocator<T> {}
declare class _MSStyle extends MSModelObject {
  alloc<T extends _MSStyle>(): _MSStyleAllocator<T>;
  addStyleBorder(value: MSStyleBorder): void;
  addStyleBorders(borders: NSArray<any> | any[]): void;
  insertStyleBorder_atIndex(value: MSStyleBorder, index: NSUInteger): void;
  insertStyleBorder_beforeStyleBorder(value: MSStyleBorder, after: MSStyleBorder | null): void;
  insertStyleBorders_beforeStyleBorder(values: NSArray<any> | any[], before: MSStyleBorder | null): void;
  insertStyleBorder_afterStyleBorder(value: MSStyleBorder, after: MSStyleBorder | null): void;
  insertStyleBorders_afterStyleBorder(values: NSArray<any> | any[], after: MSStyleBorder | null): void;
  removeStyleBorder(value: MSStyleBorder): void;
  removeStyleBorderAtIndex(index: NSUInteger): void;
  removeStyleBordersAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleBorders(): void;
  moveStyleBorderIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addStyleFill(value: MSStyleFill): void;
  addStyleFills(fills: NSArray<any> | any[]): void;
  insertStyleFill_atIndex(value: MSStyleFill, index: NSUInteger): void;
  insertStyleFill_beforeStyleFill(value: MSStyleFill, after: MSStyleFill | null): void;
  insertStyleFills_beforeStyleFill(values: NSArray<any> | any[], before: MSStyleFill | null): void;
  insertStyleFill_afterStyleFill(value: MSStyleFill, after: MSStyleFill | null): void;
  insertStyleFills_afterStyleFill(values: NSArray<any> | any[], after: MSStyleFill | null): void;
  removeStyleFill(value: MSStyleFill): void;
  removeStyleFillAtIndex(index: NSUInteger): void;
  removeStyleFillsAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleFills(): void;
  moveStyleFillIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addStyleInnerShadow(value: MSStyleInnerShadow): void;
  addStyleInnerShadows(innerShadows: NSArray<any> | any[]): void;
  insertStyleInnerShadow_atIndex(value: MSStyleInnerShadow, index: NSUInteger): void;
  insertStyleInnerShadow_beforeStyleInnerShadow(value: MSStyleInnerShadow, after: MSStyleInnerShadow | null): void;
  insertStyleInnerShadows_beforeStyleInnerShadow(values: NSArray<any> | any[], before: MSStyleInnerShadow | null): void;
  insertStyleInnerShadow_afterStyleInnerShadow(value: MSStyleInnerShadow, after: MSStyleInnerShadow | null): void;
  insertStyleInnerShadows_afterStyleInnerShadow(values: NSArray<any> | any[], after: MSStyleInnerShadow | null): void;
  removeStyleInnerShadow(value: MSStyleInnerShadow): void;
  removeStyleInnerShadowAtIndex(index: NSUInteger): void;
  removeStyleInnerShadowsAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleInnerShadows(): void;
  moveStyleInnerShadowIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;
  addStyleShadow(value: MSStyleShadow): void;
  addStyleShadows(shadows: NSArray<any> | any[]): void;
  insertStyleShadow_atIndex(value: MSStyleShadow, index: NSUInteger): void;
  insertStyleShadow_beforeStyleShadow(value: MSStyleShadow, after: MSStyleShadow | null): void;
  insertStyleShadows_beforeStyleShadow(values: NSArray<any> | any[], before: MSStyleShadow | null): void;
  insertStyleShadow_afterStyleShadow(value: MSStyleShadow, after: MSStyleShadow | null): void;
  insertStyleShadows_afterStyleShadow(values: NSArray<any> | any[], after: MSStyleShadow | null): void;
  removeStyleShadow(value: MSStyleShadow): void;
  removeStyleShadowAtIndex(index: NSUInteger): void;
  removeStyleShadowsAtIndexes(indexes: NSIndexSet): void;
  removeAllStyleShadows(): void;
  moveStyleShadowIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  endMarkerType(): MSMarkerType;
  setEndMarkerType(endMarkerType: MSMarkerType): void;
  miterLimit(): NSInteger;
  setMiterLimit(miterLimit: NSInteger): void;
  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
  startMarkerType(): MSMarkerType;
  setStartMarkerType(startMarkerType: MSMarkerType): void;
  windingRule(): NSWindingRule;
  setWindingRule(windingRule: NSWindingRule): void;
  blur(): MSStyleBlur;
  setBlur(blur: MSStyleBlur): void;
  borderOptions(): MSStyleBorderOptions;
  setBorderOptions(borderOptions: MSStyleBorderOptions): void;
  borders(): NSArray<any>;
  setBorders(borders: NSArray<any> | any[]): void;
  colorControls(): MSStyleColorControls;
  setColorControls(colorControls: MSStyleColorControls): void;
  contextSettings(): MSGraphicsContextSettings;
  setContextSettings(contextSettings: MSGraphicsContextSettings): void;
  fills(): NSArray<any>;
  setFills(fills: NSArray<any> | any[]): void;
  innerShadows(): NSArray<any>;
  setInnerShadows(innerShadows: NSArray<any> | any[]): void;
  shadows(): NSArray<any>;
  setShadows(shadows: NSArray<any> | any[]): void;
  textStyle(): MSTextStyle;
  setTextStyle(textStyle: MSTextStyle): void;
}

class _MSStyleBasicFillAllocator<T extends _MSStyleBasicFill> extends MSStylePartAllocator<T> {}
declare class _MSStyleBasicFill extends MSStylePart {
  alloc<T extends _MSStyleBasicFill>(): _MSStyleBasicFillAllocator<T>;

  fillType(): BCFillType;
  setFillType(fillType: BCFillType): void;
  color(): MSColor;
  setColor(color: MSColor): void;
  contextSettings(): MSGraphicsContextSettings;
  setContextSettings(contextSettings: MSGraphicsContextSettings): void;
  gradient(): MSGradient;
  setGradient(gradient: MSGradient): void;
}

class _MSStyleBlurAllocator<T extends _MSStyleBlur> extends MSStylePartAllocator<T> {}
declare class _MSStyleBlur extends MSStylePart {
  alloc<T extends _MSStyleBlur>(): _MSStyleBlurAllocator<T>;

  center(): NSPoint;
  setCenter(center: NSPoint): void;
  motionAngle(): CGFloat;
  setMotionAngle(motionAngle: CGFloat): void;
  radius(): CGFloat;
  setRadius(radius: CGFloat): void;
  saturation(): CGFloat;
  setSaturation(saturation: CGFloat): void;
  type(): MSStyleBlurType;
  setType(type: MSStyleBlurType): void;
}

class _MSStyleBorderAllocator<T extends _MSStyleBorder> extends MSStyleBasicFillAllocator<T> {}
declare class _MSStyleBorder extends MSStyleBasicFill {
  alloc<T extends _MSStyleBorder>(): _MSStyleBorderAllocator<T>;

  position(): MSBorderPositionType;
  setPosition(position: MSBorderPositionType): void;
  thickness(): CGFloat;
  setThickness(thickness: CGFloat): void;
}

class _MSStyleBorderOptionsAllocator<T extends _MSStyleBorderOptions> extends MSStylePartAllocator<T> {}
declare class _MSStyleBorderOptions extends MSStylePart {
  alloc<T extends _MSStyleBorderOptions>(): _MSStyleBorderOptionsAllocator<T>;

  dashPattern(): NSArray<any>;
  setDashPattern(dashPattern: NSArray<any> | any[]): void;
  lineCapStyle(): NSLineCapStyle;
  setLineCapStyle(lineCapStyle: NSLineCapStyle): void;
  lineJoinStyle(): NSLineJoinStyle;
  setLineJoinStyle(lineJoinStyle: NSLineJoinStyle): void;
}

class _MSStyleColorControlsAllocator<T extends _MSStyleColorControls> extends MSStylePartAllocator<T> {}
declare class _MSStyleColorControls extends MSStylePart {
  alloc<T extends _MSStyleColorControls>(): _MSStyleColorControlsAllocator<T>;

  brightness(): CGFloat;
  setBrightness(brightness: CGFloat): void;
  contrast(): CGFloat;
  setContrast(contrast: CGFloat): void;
  hue(): CGFloat;
  setHue(hue: CGFloat): void;
  saturation(): CGFloat;
  setSaturation(saturation: CGFloat): void;
}

class _MSStyleFillAllocator<T extends _MSStyleFill> extends MSStyleBasicFillAllocator<T> {}
declare class _MSStyleFill extends MSStyleBasicFill {
  alloc<T extends _MSStyleFill>(): _MSStyleFillAllocator<T>;

  image(): MSImageData;
  setImage(image: MSImageData): void;
  noiseIndex(): NSInteger;
  setNoiseIndex(noiseIndex: NSInteger): void;
  noiseIntensity(): CGFloat;
  setNoiseIntensity(noiseIntensity: CGFloat): void;
  patternFillType(): MSPatternFillType;
  setPatternFillType(patternFillType: MSPatternFillType): void;
  patternTileScale(): CGFloat;
  setPatternTileScale(patternTileScale: CGFloat): void;
}

class _MSStyleInnerShadowAllocator<T extends _MSStyleInnerShadow> extends MSStyleShadowAllocator<T> {}
declare class _MSStyleInnerShadow extends MSStyleShadow {
  alloc<T extends _MSStyleInnerShadow>(): _MSStyleInnerShadowAllocator<T>;
}

class _MSStylePartAllocator<T extends _MSStylePart> extends MSModelObjectAllocator<T> {}
declare class _MSStylePart extends MSModelObject {
  alloc<T extends _MSStylePart>(): _MSStylePartAllocator<T>;

  isEnabled(): boolean;
  setIsEnabled(isEnabled: boolean): void;
}

class _MSStyleReflectionAllocator<T extends _MSStyleReflection> extends MSStylePartAllocator<T> {}
declare class _MSStyleReflection extends MSStylePart {
  alloc<T extends _MSStyleReflection>(): _MSStyleReflectionAllocator<T>;

  distance(): CGFloat;
  setDistance(distance: CGFloat): void;
  strength(): CGFloat;
  setStrength(strength: CGFloat): void;
}

class _MSStyleShadowAllocator<T extends _MSStyleShadow> extends MSStylePartAllocator<T> {}
declare class _MSStyleShadow extends MSStylePart {
  alloc<T extends _MSStyleShadow>(): _MSStyleShadowAllocator<T>;

  blurRadius(): CGFloat;
  setBlurRadius(blurRadius: CGFloat): void;
  offsetX(): CGFloat;
  setOffsetX(offsetX: CGFloat): void;
  offsetY(): CGFloat;
  setOffsetY(offsetY: CGFloat): void;
  spread(): CGFloat;
  setSpread(spread: CGFloat): void;
  color(): MSColor;
  setColor(color: MSColor): void;
  contextSettings(): MSGraphicsContextSettings;
  setContextSettings(contextSettings: MSGraphicsContextSettings): void;
}

class _MSStyledLayerAllocator<T extends _MSStyledLayer> extends MSLayerAllocator<T> {}
declare class _MSStyledLayer extends MSLayer {
  alloc<T extends _MSStyledLayer>(): _MSStyledLayerAllocator<T>;

  clippingMaskMode(): NSInteger;
  setClippingMaskMode(clippingMaskMode: NSInteger): void;
  hasClippingMask(): boolean;
  setHasClippingMask(hasClippingMask: boolean): void;
  style(): MSStyle;
  setStyle(style: MSStyle): void;
}

class _MSSymbolAllocator<T extends _MSSymbol> extends MSSharedObjectAllocator<T> {}
declare class _MSSymbol extends MSSharedObject {
  alloc<T extends _MSSymbol>(): _MSSymbolAllocator<T>;
}

class _MSSymbolContainerAllocator<T extends _MSSymbolContainer> extends MSSharedObjectContainerAllocator<T> {}
declare class _MSSymbolContainer extends MSSharedObjectContainer {
  alloc<T extends _MSSymbolContainer>(): _MSSymbolContainerAllocator<T>;
}

class _MSSymbolInstanceAllocator<T extends _MSSymbolInstance> extends MSStyledLayerAllocator<T> {}
declare class _MSSymbolInstance extends MSStyledLayer {
  alloc<T extends _MSSymbolInstance>(): _MSSymbolInstanceAllocator<T>;
  addOverrideValue(value: MSOverrideValue): void;
  addOverrideValues(overrideValues: NSArray<any> | any[]): void;
  insertOverrideValue_atIndex(value: MSOverrideValue, index: NSUInteger): void;
  insertOverrideValue_beforeOverrideValue(value: MSOverrideValue, after: MSOverrideValue | null): void;
  insertOverrideValues_beforeOverrideValue(values: NSArray<any> | any[], before: MSOverrideValue | null): void;
  insertOverrideValue_afterOverrideValue(value: MSOverrideValue, after: MSOverrideValue | null): void;
  insertOverrideValues_afterOverrideValue(values: NSArray<any> | any[], after: MSOverrideValue | null): void;
  removeOverrideValue(value: MSOverrideValue): void;
  removeOverrideValueAtIndex(index: NSUInteger): void;
  removeOverrideValuesAtIndexes(indexes: NSIndexSet): void;
  removeAllOverrideValues(): void;
  moveOverrideValueIndex_toIndex(fromIndex: NSUInteger, toIndex: NSUInteger): void;

  horizontalSpacing(): CGFloat;
  setHorizontalSpacing(horizontalSpacing: CGFloat): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  symbolID(): NSString;
  setSymbolID(symbolID: NSString | string): void;
  verticalSpacing(): CGFloat;
  setVerticalSpacing(verticalSpacing: CGFloat): void;
  overrideValues(): NSArray<any>;
  setOverrideValues(overrideValues: NSArray<any> | any[]): void;
}

class _MSSymbolMasterAllocator<T extends _MSSymbolMaster> extends MSArtboardGroupAllocator<T> {}
declare class _MSSymbolMaster extends MSArtboardGroup {
  alloc<T extends _MSSymbolMaster>(): _MSSymbolMasterAllocator<T>;

  includeBackgroundColorInInstance(): boolean;
  setIncludeBackgroundColorInInstance(includeBackgroundColorInInstance: boolean): void;
  symbolID(): NSString;
  setSymbolID(symbolID: NSString | string): void;
}

class _MSTextLayerAllocator<T extends _MSTextLayer> extends MSStyledLayerAllocator<T> {}
declare class _MSTextLayer extends MSStyledLayer {
  alloc<T extends _MSTextLayer>(): _MSTextLayerAllocator<T>;

  attributedString(): MSAttributedString;
  setAttributedString(attributedString: MSAttributedString): void;
  automaticallyDrawOnUnderlyingPath(): boolean;
  setAutomaticallyDrawOnUnderlyingPath(automaticallyDrawOnUnderlyingPath: boolean): void;
  dontSynchroniseWithSymbol(): boolean;
  setDontSynchroniseWithSymbol(dontSynchroniseWithSymbol: boolean): void;
  glyphBounds(): NSRect;
  setGlyphBounds(glyphBounds: NSRect): void;
  lineSpacingBehaviour(): BCTextLineSpacingBehaviourType;
  setLineSpacingBehaviour(lineSpacingBehaviour: BCTextLineSpacingBehaviourType): void;
  preview(): MSImageData;
  setPreview(preview: MSImageData): void;
  textBehaviour(): BCTextBehaviourType;
  setTextBehaviour(textBehaviour: BCTextBehaviourType): void;
}

class _MSTextStyleAllocator<T extends _MSTextStyle> extends MSModelObjectAllocator<T> {}
declare class _MSTextStyle extends MSModelObject {
  alloc<T extends _MSTextStyle>(): _MSTextStyleAllocator<T>;

  encodedAttributes(): NSDictionary<any, any>;
  setEncodedAttributes(encodedAttributes: NSDictionary<any, any> | {[key: string]: any}): void;
  verticalAlignment(): MSTextStyleVerticalAlignment;
  setVerticalAlignment(verticalAlignment: MSTextStyleVerticalAlignment): void;
}

class _MSTriangleShapeAllocator<T extends _MSTriangleShape> extends MSShapePathLayerAllocator<T> {}
declare class _MSTriangleShape extends MSShapePathLayer {
  alloc<T extends _MSTriangleShape>(): _MSTriangleShapeAllocator<T>;

  isEquilateral(): boolean;
  setIsEquilateral(isEquilateral: boolean): void;
}

class MSImmutableArrayAllocator<T extends MSImmutableArray> extends MSImmutableModelObjectAllocator<T> {}
declare class MSImmutableArray extends MSImmutableModelObject {
  alloc<T extends MSImmutableArray>(): MSImmutableArrayAllocator<T>;
}

class MSImmutableAssetCollectionAllocator<T extends MSImmutableAssetCollection> extends _MSImmutableAssetCollectionAllocator<T> {}
declare class MSImmutableAssetCollection extends _MSImmutableAssetCollection {
  alloc<T extends MSImmutableAssetCollection>(): MSImmutableAssetCollectionAllocator<T>;
}

class MSImmutableBaseGridAllocator<T extends MSImmutableBaseGrid> extends _MSImmutableBaseGridAllocator<T> {}
declare class MSImmutableBaseGrid extends _MSImmutableBaseGrid {
  alloc<T extends MSImmutableBaseGrid>(): MSImmutableBaseGridAllocator<T>;
  shouldDrawAtZoom(zoom: CGFloat): boolean;
  static displayableAtZoom(zoom: CGFloat): boolean;
}

class MSImmutableBitmapLayerAllocator<T extends MSImmutableBitmapLayer> extends _MSImmutableBitmapLayerAllocator<T> {}
declare class MSImmutableBitmapLayer extends _MSImmutableBitmapLayer {
  alloc<T extends MSImmutableBitmapLayer>(): MSImmutableBitmapLayerAllocator<T>;
  NSImage(): NSImage;

  fillReplacesImage(): boolean;
  setFillReplacesImage(fillReplacesImage: boolean): void;
  image(): MSImageData;
  setImage(image: MSImageData): void;
}

class MSImmutableCurvePointAllocator<T extends MSImmutableCurvePoint> extends _MSImmutableCurvePointAllocator<T> {}
declare class MSImmutableCurvePoint extends _MSImmutableCurvePoint implements IMSCurvePoint {
  alloc<T extends MSImmutableCurvePoint>(): MSImmutableCurvePointAllocator<T>;

  isStraight(): boolean;
  isRounded(): boolean;
  isEffectivelyStraight(): boolean;
}

class MSImmutableDocumentDataAllocator<T extends MSImmutableDocumentData> extends _MSImmutableDocumentDataAllocator<T> {}
declare class MSImmutableDocumentData extends _MSImmutableDocumentData implements IMSDocumentData {
  alloc<T extends MSImmutableDocumentData>(): MSImmutableDocumentDataAllocator<T>;
  static loadDocumentDataWithMetadata_loadBlock(metadata: NSDictionary<any, any> | {[key: string]: any}, loadBlock: Block): MSImmutableDocumentData;
  defaultPagesArray(): NSArray<any>;
  usedFontNames(): NSSet<any>;
  pageWithID(pageID: NSString | string): MSImmutablePage;
  symbolWithID(objectID: NSString | string): MSImmutableSymbolMaster;
  artboardWithID(objectID: NSString | string | null): MSImmutableArtboardGroup;
  textStyleWithID(sharedStyleID: NSString | string | null): MSImmutableSharedStyle;
  layerStyleWithID(sharedStyleID: NSString | string | null): MSImmutableSharedStyle;
  artboardWithID_page(objectID: NSString | string, pageOut: MSImmutablePage): MSImmutableArtboardGroup;
  wasSavedByOldVersion(): boolean;
  wasSavedByTestVersion(): boolean;
  allArtboards(): NSArray<any>;
  allSymbols(): NSArray<any>;
  pagesAndArtboardsMetadata(): NSDictionary<any, any>;
  findFrequentColorsForUse_maximumColorCount_ignoreAlpha_excludeForeignSymbols_completionHandler(colorUse: MSColorUse, maxCount: NSUInteger, ignoreAlpha: boolean, excludeForeignSymbols: boolean, block: MSColorFinderCompletionBlock): void;
  trackColors_excludeForeignSymbols(tracker: MSFrequentColorTracker, excludeForeignSymbols: boolean): void;
  symbolsChangedSincePreviousDocument(lastImmutable: MSImmutableDocumentData): boolean;

  metadata(): NSDictionary<any, any>;
  currentPage(): MSImmutablePage;
  selectedOverrides(): NSArray<any>;
  fontNames(): NSSet<any>;
  unavailableFontNames(): NSSet<any>;
  containsUnavailableFontNames(): boolean;
  pages(): NSArray<any>;
}

class MSImmutableExportFormatAllocator<T extends MSImmutableExportFormat> extends _MSImmutableExportFormatAllocator<T> {}
declare class MSImmutableExportFormat extends _MSImmutableExportFormat {
  alloc<T extends MSImmutableExportFormat>(): MSImmutableExportFormatAllocator<T>;
  static defaultNameForScale(scale: CGFloat): NSString;
  exportScaleInRect(rect: NSRect): CGFloat;
  isVectorExport(): boolean;
}

class MSImmutableExportOptionsAllocator<T extends MSImmutableExportOptions> extends _MSImmutableExportOptionsAllocator<T> {}
declare class MSImmutableExportOptions extends _MSImmutableExportOptions {
  alloc<T extends MSImmutableExportOptions>(): MSImmutableExportOptionsAllocator<T>;
  firstFormat(): NSString;
}

class MSImmutableExportPresetAllocator<T extends MSImmutableExportPreset> extends _MSImmutableExportPresetAllocator<T> {}
declare class MSImmutableExportPreset extends _MSImmutableExportPreset {
  alloc<T extends MSImmutableExportPreset>(): MSImmutableExportPresetAllocator<T>;
}

class MSImmutableFlowConnectionAllocator<T extends MSImmutableFlowConnection> extends _MSImmutableFlowConnectionAllocator<T> {}
declare class MSImmutableFlowConnection extends _MSImmutableFlowConnection {
  alloc<T extends MSImmutableFlowConnection>(): MSImmutableFlowConnectionAllocator<T>;
  flowTypeForTransitionFromParentLayer_toArtboard(layer: MSImmutableLayerAncestry, artboard: MSImmutableLayerAncestry): MSFlowType;
  bezierPathForRenderingFlowFromParentLayer_toArtboard_zoomLevel(layer: MSImmutableLayerAncestry, destinationArtboard: MSImmutableLayerAncestry, zoomLevel: CGFloat): NSBezierPath;
  isValidFlowConnectionInDocumentData(documentData: MSImmutableDocumentData): boolean;

  isBackAction(): boolean;
}

class MSImmutableForeignLayerStyleAllocator<T extends MSImmutableForeignLayerStyle> extends _MSImmutableForeignLayerStyleAllocator<T> {}
declare class MSImmutableForeignLayerStyle extends _MSImmutableForeignLayerStyle {
  alloc<T extends MSImmutableForeignLayerStyle>(): MSImmutableForeignLayerStyleAllocator<T>;
}

class MSImmutableForeignObjectAllocator<T extends MSImmutableForeignObject> extends _MSImmutableForeignObjectAllocator<T> {}
declare class MSImmutableForeignObject extends _MSImmutableForeignObject {
  alloc<T extends MSImmutableForeignObject>(): MSImmutableForeignObjectAllocator<T>;
}

class MSImmutableForeignStyleAllocator<T extends MSImmutableForeignStyle> extends _MSImmutableForeignStyleAllocator<T> {}
declare class MSImmutableForeignStyle extends _MSImmutableForeignStyle {
  alloc<T extends MSImmutableForeignStyle>(): MSImmutableForeignStyleAllocator<T>;
}

class MSImmutableForeignSymbolAllocator<T extends MSImmutableForeignSymbol> extends _MSImmutableForeignSymbolAllocator<T> {}
declare class MSImmutableForeignSymbol extends _MSImmutableForeignSymbol {
  alloc<T extends MSImmutableForeignSymbol>(): MSImmutableForeignSymbolAllocator<T>;
}

class MSImmutableForeignTextStyleAllocator<T extends MSImmutableForeignTextStyle> extends _MSImmutableForeignTextStyleAllocator<T> {}
declare class MSImmutableForeignTextStyle extends _MSImmutableForeignTextStyle {
  alloc<T extends MSImmutableForeignTextStyle>(): MSImmutableForeignTextStyleAllocator<T>;
}

class MSImmutableGradientAllocator<T extends MSImmutableGradient> extends _MSImmutableGradientAllocator<T> {}
declare class MSImmutableGradient extends _MSImmutableGradient {
  alloc<T extends MSImmutableGradient>(): MSImmutableGradientAllocator<T>;
  static defaultGradientStops(): NSArray<any>;
  defaultStopsArray(): NSArray<any>;
  conditionedEllipseLength(): CGFloat;
  pointAtIndex(index: NSUInteger): NSPoint;
  newCGGradientForColorSpace(colorSpace: CGColorSpaceRef): CGGradientRef;
  newCGGradientForColorSpace_colorConverter(colorSpace: CGColorSpaceRef, colorConverter: Block): CGGradientRef;
  NSGradientWithColorSpace(colorSpace: NSColorSpace): NSGradient;
  ellipseTransformInRect(aRect: NSRect): CGAffineTransform;
  angularGradientImageInRect_colorSpace(rect: CGRect, colorSpace: NSColorSpace): NSBitmapImageRep;
  drawFillInRect_forBorderThickness_context_cacheKey(rect: NSRect, thickness: CGFloat, context: MSRenderingContext, cacheKey: MSModelObjectCacheGeneration): void;

  hasOpacity(): boolean;
}

class MSImmutableGradientStopAllocator<T extends MSImmutableGradientStop> extends _MSImmutableGradientStopAllocator<T> {
  initWithPosition_color(position: CGFloat, color: MSImmutableColor): T;
}
declare class MSImmutableGradientStop extends _MSImmutableGradientStop {
  alloc<T extends MSImmutableGradientStop>(): MSImmutableGradientStopAllocator<T>;
}

class MSImmutableGraphicsContextSettingsAllocator<T extends MSImmutableGraphicsContextSettings> extends _MSImmutableGraphicsContextSettingsAllocator<T> {}
declare class MSImmutableGraphicsContextSettings extends _MSImmutableGraphicsContextSettings {
  alloc<T extends MSImmutableGraphicsContextSettings>(): MSImmutableGraphicsContextSettingsAllocator<T>;
  shouldChangeGraphicsContext(): boolean;
  CGBlendMode(): CGBlendMode;
}

class MSImmutableImageCollectionAllocator<T extends MSImmutableImageCollection> extends _MSImmutableImageCollectionAllocator<T> {}
declare class MSImmutableImageCollection extends _MSImmutableImageCollection {
  alloc<T extends MSImmutableImageCollection>(): MSImmutableImageCollectionAllocator<T>;
  imageWithSHA1(sha1: NSData): MSImageData;
}

class MSImmutableSymbolInstanceAllocator<T extends MSImmutableSymbolInstance> extends _MSImmutableSymbolInstanceAllocator<T> {
  initWithGroupForMigration(group: MSImmutableLayerGroup): T;
}
declare class MSImmutableSymbolInstance extends _MSImmutableSymbolInstance {
  alloc<T extends MSImmutableSymbolInstance>(): MSImmutableSymbolInstanceAllocator<T>;
  isScaled(): boolean;
  availableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;
  cachedModifiedSymbolForMaster_document_cache(originalSymbol: MSImmutableSymbolMaster, doc: MSImmutableDocumentData, cache: BCCache): MSImmutableSymbolMaster;
  updateOverridesWithObjectIDMapping_afterChangingSymbolMasterWithID(objectIDMapping: NSDictionary<any, any> | {[key: string]: any}, symbolID: NSString | string): void;
  overridesWithGridIndexRemoved(overrides: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  overridePointsInDocument(document: MSImmutableDocumentData): NSArray<any>;
  calculateAvailableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;
  cachedModifiedSymbolForMaster_inContext(originalSymbol: MSImmutableSymbolMaster, context: MSRenderingContext): MSImmutableSymbolMaster;

  modifiedMasterCacheKey(): any;
  masterRefreshCounter(): NSUInteger;
  overrides(): NSDictionary<any, any>;
}

declare interface IMSFlowContainmentCheck {
  firstFlowWithSymbolsFromDocument(document: MSImmutableDocumentData): MSImmutableFlowConnection;
  containsFlowWithSymbolsFromDocument(document: MSImmutableDocumentData): boolean;
}

class MSImmutableLayoutGridAllocator<T extends MSImmutableLayoutGrid> extends _MSImmutableLayoutGridAllocator<T> {}
declare class MSImmutableLayoutGrid extends _MSImmutableLayoutGrid {
  alloc<T extends MSImmutableLayoutGrid>(): MSImmutableLayoutGridAllocator<T>;
}

class MSImmutableModelObjectAllocator<T extends MSImmutableModelObject> extends MSModelObjectCommonAllocator<T> {
  initWithMutableModelObject(object: MSModelObject): T;
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): T;
}
declare class MSImmutableModelObject extends MSModelObjectCommon implements IMSModelObject, IMSCoding {
  alloc<T extends MSImmutableModelObject>(): MSImmutableModelObjectAllocator<T>;
  differsFromObject(object: MSImmutableModelObject): boolean;
  shouldDiffSubObjectsForDifferingObject(objet: MSImmutableModelObject): boolean;
  newMutableCounterpart(): any;
  static mutableClass(): any;
  isEqualForDiffToObject(otherObject: any): boolean;
  keysDifferingFromObject(object: MSImmutableModelObject): NSSet<any>;
  static traitsForPropertyName(name: NSString | string): MSPropertyTraits;
  encodePropertiesWithCoder(coder: MSBaseArchiver): void;
  decodePropertiesWithUnarchiver(coder: MSBaseUnarchiver): void;
  performInitWithMutableModelObject(object: MSModelObject): void;
  performInitWithUnarchiver(coder: MSBaseUnarchiver): void;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  encodeWithArchiver(archiver: MSBaseArchiver): void;

  subObjectsForTreeDiff(): NSArray<any>;
  archiveReferenceIdentifier_bc(): NSString;
}

declare enum MSPropertyTraits {
  MSPropertyTraitNone = 0,
  MSPropertyTraitInfluencesContentRender = 1<<1,
  MSPropertyTraitInfluencesOverlayRender = 1<<2,
  MSPropertyTraitChangesHistory = 1<<3,
  MSPropertyTraitAmendsHistory = 1<<4,
  MSPropertyTraitInfluencesLayerStructure = 1<<5,
  MSPropertyTraitInfluencesMirror = 1<<6,
  MSPropertyTraitRequiresFullContentRefresh = 1<<7,
  MSPropertyTraitInfluencesLayerListPreview = 1<<8,
  MSPropertyTraitSharedObjectUpdated = 1<<9,
  MSPropertyTraitAll,
}

class MSImmutableOvalShapeAllocator<T extends MSImmutableOvalShape> extends _MSImmutableOvalShapeAllocator<T> {}
declare class MSImmutableOvalShape extends _MSImmutableOvalShape {
  alloc<T extends MSImmutableOvalShape>(): MSImmutableOvalShapeAllocator<T>;
}

class MSImmutableOverrideValueAllocator<T extends MSImmutableOverrideValue> extends _MSImmutableOverrideValueAllocator<T> {
  initWithName_value(name: NSString | string, value: NSObject): T;
}
declare class MSImmutableOverrideValue extends _MSImmutableOverrideValue {
  alloc<T extends MSImmutableOverrideValue>(): MSImmutableOverrideValueAllocator<T>;
  static overrideValuesFromDictionary(dict: NSDictionary<any, any> | {[key: string]: any} | null): NSArray<any>;
  static dictionaryFromOverrideValues(overrideValues: NSArray<any> | any[] | null): NSDictionary<any, any>;

  attributeName(): NSString;
  path(): NSString;
}

class MSImmutablePersistentAssetCollectionAllocator<T extends MSImmutablePersistentAssetCollection> extends MSImmutableAssetCollectionAllocator<T> {}
declare class MSImmutablePersistentAssetCollection extends MSImmutableAssetCollection {
  alloc<T extends MSImmutablePersistentAssetCollection>(): MSImmutablePersistentAssetCollectionAllocator<T>;
}

class MSImmutablePolygonShapeAllocator<T extends MSImmutablePolygonShape> extends _MSImmutablePolygonShapeAllocator<T> {}
declare class MSImmutablePolygonShape extends _MSImmutablePolygonShape {
  alloc<T extends MSImmutablePolygonShape>(): MSImmutablePolygonShapeAllocator<T>;
}

class MSImmutableRectAllocator<T extends MSImmutableRect> extends _MSImmutableRectAllocator<T> {
  initWithRect(aRect: NSRect): T;
  initWithRect_constrainProportions(aRect: NSRect, constraintProportions: boolean): T;
}
declare class MSImmutableRect extends _MSImmutableRect implements IMSRect {
  alloc<T extends MSImmutableRect>(): MSImmutableRectAllocator<T>;

  rect(): NSRect;
  size(): NSSize;
  origin(): NSPoint;
}

class MSImmutableRectangleShapeAllocator<T extends MSImmutableRectangleShape> extends _MSImmutableRectangleShapeAllocator<T> {}
declare class MSImmutableRectangleShape extends _MSImmutableRectangleShape {
  alloc<T extends MSImmutableRectangleShape>(): MSImmutableRectangleShapeAllocator<T>;
}

class MSImmutableRulerDataAllocator<T extends MSImmutableRulerData> extends _MSImmutableRulerDataAllocator<T> {}
declare class MSImmutableRulerData extends _MSImmutableRulerData {
  alloc<T extends MSImmutableRulerData>(): MSImmutableRulerDataAllocator<T>;
}

class MSImmutableShapePathAllocator<T extends MSImmutableShapePath> extends _MSImmutableShapePathAllocator<T> {}
declare class MSImmutableShapePath extends _MSImmutableShapePath {
  alloc<T extends MSImmutableShapePath>(): MSImmutableShapePathAllocator<T>;
}

class MSImmutableSharedObjectAllocator<T extends MSImmutableSharedObject> extends _MSImmutableSharedObjectAllocator<T> {}
declare class MSImmutableSharedObject extends _MSImmutableSharedObject {
  alloc<T extends MSImmutableSharedObject>(): MSImmutableSharedObjectAllocator<T>;
}

class MSImmutableSharedObjectContainerAllocator<T extends MSImmutableSharedObjectContainer> extends _MSImmutableSharedObjectContainerAllocator<T> {}
declare class MSImmutableSharedObjectContainer extends _MSImmutableSharedObjectContainer {
  alloc<T extends MSImmutableSharedObjectContainer>(): MSImmutableSharedObjectContainerAllocator<T>;
}

class MSImmutableSharedStyleAllocator<T extends MSImmutableSharedStyle> extends _MSImmutableSharedStyleAllocator<T> {}
declare class MSImmutableSharedStyle extends _MSImmutableSharedStyle {
  alloc<T extends MSImmutableSharedStyle>(): MSImmutableSharedStyleAllocator<T>;
}

class MSImmutableSharedStyleContainerAllocator<T extends MSImmutableSharedStyleContainer> extends _MSImmutableSharedStyleContainerAllocator<T> {}
declare class MSImmutableSharedStyleContainer extends _MSImmutableSharedStyleContainer {
  alloc<T extends MSImmutableSharedStyleContainer>(): MSImmutableSharedStyleContainerAllocator<T>;
}

class MSImmutableSharedTextStyleContainerAllocator<T extends MSImmutableSharedTextStyleContainer> extends _MSImmutableSharedTextStyleContainerAllocator<T> {}
declare class MSImmutableSharedTextStyleContainer extends _MSImmutableSharedTextStyleContainer {
  alloc<T extends MSImmutableSharedTextStyleContainer>(): MSImmutableSharedTextStyleContainerAllocator<T>;
}

class MSImmutableSimpleGridAllocator<T extends MSImmutableSimpleGrid> extends _MSImmutableSimpleGridAllocator<T> {}
declare class MSImmutableSimpleGrid extends _MSImmutableSimpleGrid {
  alloc<T extends MSImmutableSimpleGrid>(): MSImmutableSimpleGridAllocator<T>;
}

class MSImmutableStarShapeAllocator<T extends MSImmutableStarShape> extends _MSImmutableStarShapeAllocator<T> {}
declare class MSImmutableStarShape extends _MSImmutableStarShape {
  alloc<T extends MSImmutableStarShape>(): MSImmutableStarShapeAllocator<T>;
}

class MSImmutableStyleAllocator<T extends MSImmutableStyle> extends _MSImmutableStyleAllocator<T> {}
declare class MSImmutableStyle extends _MSImmutableStyle {
  alloc<T extends MSImmutableStyle>(): MSImmutableStyleAllocator<T>;
  clearTextStyle(): void;
  boundingBoxForBiggestShadowSpreadForLayer(layer: MSImmutableLayer): NSRect;
  boundsForPath(path: MSPath): CGRect;
  renderBitmapEffects_bounds_parentCoordinateTransform(image: CIImage, bounds: CGRect, parentCoordinateTransform: CGAffineTransform): CIImage;
  requiresPathDefinition(exporter: SketchSVGExporter): boolean;
  numberOfElementsWithExporter(exporter: SketchSVGExporter): NSUInteger;
  addSVGAttributes_exporter_elementPosition(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter, position: NSUInteger): void;
  borderAtElementPosition_exporter(position: NSInteger, exporter: SketchSVGExporter): MSImmutableStyleBorder;
  fillAtElementPosition_exporter(position: NSInteger, exporter: SketchSVGExporter): MSImmutableStyleFill;

  hasMarkers(): boolean;
  hasMoreThanOneEnabledFill(): boolean;
  hasEnabledShadow(): boolean;
  hasEnabledInnerShadow(): boolean;
  hasEnabledBorder(): boolean;
  hasEnabledFill(): boolean;
  hasBlending(): boolean;
  thickestStroke(): CGFloat;
  thickestInnerStroke(): CGFloat;
  outerPaddingForBiggestStroke(): CGFloat;
  outerPaddingForBiggestShadowSpread(): CGFloat;
  hasEnabledBackgroundBlur(): boolean;
  shadowType(): MSShadowType;
  shadowStrokeType(): MSShadowBorderType;
  firstEnabledShadow(): MSImmutableStyleShadow;
  firstEnabledInnerShadow(): MSImmutableStyleInnerShadow;
  firstEnabledFill(): MSImmutableStyleFill;
  firstEnabledBorder(): MSImmutableStyleBorder;
  enabledFills(): NSArray<any>;
  enabledBorders(): NSArray<any>;
  enabledShadows(): NSArray<any>;
  enabledInnerShadows(): NSArray<any>;
  hasEnabledOpaqueFill(): boolean;
  renderableFills(): NSArray<any>;
}

class MSImmutableStyleBasicFillAllocator<T extends MSImmutableStyleBasicFill> extends _MSImmutableStyleBasicFillAllocator<T> {}
declare class MSImmutableStyleBasicFill extends _MSImmutableStyleBasicFill {
  alloc<T extends MSImmutableStyleBasicFill>(): MSImmutableStyleBasicFillAllocator<T>;

  hasOpacity(): boolean;
}

class MSImmutableStyleBlurAllocator<T extends MSImmutableStyleBlur> extends _MSImmutableStyleBlurAllocator<T> {}
declare class MSImmutableStyleBlur extends _MSImmutableStyleBlur {
  alloc<T extends MSImmutableStyleBlur>(): MSImmutableStyleBlurAllocator<T>;
  cropRadius(): CGFloat;
  renderBitmapEffects_bounds_parentCoordinateTransform(image: CIImage, bounds: CGRect, parentCoordinateTransform: CGAffineTransform): CIImage;
  shouldUseCoreImageForEffect(): boolean;
  addFilterWithExporter(exporter: SketchSVGExporter): void;
}

class MSImmutableStyleBorderAllocator<T extends MSImmutableStyleBorder> extends _MSImmutableStyleBorderAllocator<T> {}
declare class MSImmutableStyleBorder extends _MSImmutableStyleBorder {
  alloc<T extends MSImmutableStyleBorder>(): MSImmutableStyleBorderAllocator<T>;
  drawBorder_advancedOptions_context(path: MSPath, advanced: MSImmutableStyleBorderOptions, context: MSRenderingContext): void;
  drawGradientBorder_advancedOptions_originalPath_isArtistic_frame_context(path: MSPath, advanced: MSImmutableStyleBorderOptions, original: MSPath, isArtistic: boolean, rect: NSRect, context: MSRenderingContext): void;
  pathWithExporter(exporter: SketchSVGExporter): MSPath;
  requiresMask(borderOptions: MSImmutableStyleBorderOptions): boolean;
  needsOutlinePath(borderOptions: MSImmutableStyleBorderOptions): boolean;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  borderInset(): CGFloat;
}

class MSImmutableStyleBorderOptionsAllocator<T extends MSImmutableStyleBorderOptions> extends _MSImmutableStyleBorderOptionsAllocator<T> {}
declare class MSImmutableStyleBorderOptions extends _MSImmutableStyleBorderOptions {
  alloc<T extends MSImmutableStyleBorderOptions>(): MSImmutableStyleBorderOptionsAllocator<T>;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  CGLineJoin(): CGLineJoin;
  CGLineCap(): CGLineCap;
  hasDashPattern(): boolean;
}

class MSImmutableStyleColorControlsAllocator<T extends MSImmutableStyleColorControls> extends _MSImmutableStyleColorControlsAllocator<T> {}
declare class MSImmutableStyleColorControls extends _MSImmutableStyleColorControls {
  alloc<T extends MSImmutableStyleColorControls>(): MSImmutableStyleColorControlsAllocator<T>;
  renderBitmapEffects(image: CIImage): CIImage;
}

class MSImmutableStyleFillAllocator<T extends MSImmutableStyleFill> extends _MSImmutableStyleFillAllocator<T> {}
declare class MSImmutableStyleFill extends _MSImmutableStyleFill {
  alloc<T extends MSImmutableStyleFill>(): MSImmutableStyleFillAllocator<T>;
  NSImage(): NSImage;
  addSVGAttributes_exporter(attributes: NSMutableArray<any> | any[], exporter: SketchSVGExporter): void;

  hasOpacity(): boolean;
}

class MSImmutableStyleInnerShadowAllocator<T extends MSImmutableStyleInnerShadow> extends _MSImmutableStyleInnerShadowAllocator<T> {}
declare class MSImmutableStyleInnerShadow extends _MSImmutableStyleInnerShadow {
  alloc<T extends MSImmutableStyleInnerShadow>(): MSImmutableStyleInnerShadowAllocator<T>;
}

class MSImmutableStylePartAllocator<T extends MSImmutableStylePart> extends _MSImmutableStylePartAllocator<T> {}
declare class MSImmutableStylePart extends _MSImmutableStylePart implements IMSStylePart {
  alloc<T extends MSImmutableStylePart>(): MSImmutableStylePartAllocator<T>;

  isEnabled(): boolean;
}

class MSImmutableStyleShadowAllocator<T extends MSImmutableStyleShadow> extends _MSImmutableStyleShadowAllocator<T> {}
declare class MSImmutableStyleShadow extends _MSImmutableStyleShadow {
  alloc<T extends MSImmutableStyleShadow>(): MSImmutableStyleShadowAllocator<T>;
  addSpread_withInput_output_filter(spread: CGFloat, input: NSString | string, output: NSString | string, filter: MSSVGFilter): MSSVGMorphology;
  addBlurWithRadius_input_output_filter(radius: CGFloat, input: NSString | string, output: NSString | string, filter: MSSVGFilter): MSSVGGaussianBlur;
  addCompositeMask_mask_output_filter(src: NSString | string, mask: NSString | string, output: NSString | string, filter: MSSVGFilter): MSSVGComposite;
  addOffsetTo_dx_dy_output_filter(input: NSString | string, dx: CGFloat, dy: CGFloat, output: NSString | string, filter: MSSVGFilter): MSSVGOffset;
  addColorMatrix_color_output_filter(input: NSString | string, color: MSImmutableColor, output: NSString | string, filter: MSSVGFilter): MSSVGColorMatrix;
  addSVGFilterWithParent_exporter_index(parent: MSImmutableStyle, exporter: SketchSVGExporter, index: NSUInteger): void;
}

declare enum MSShadowType {
  MSShadowFill = 1 << 0,
  MSShadowStroke = 1 << 1,
}

declare enum MSShadowBorderType {
  MSShadowBorderCenter = 0,
  MSShadowBorderInside = 1,
  MSShadowBorderOutside = 2,
}

class MSImmutableSymbolAllocator<T extends MSImmutableSymbol> extends _MSImmutableSymbolAllocator<T> {}
declare class MSImmutableSymbol extends _MSImmutableSymbol {
  alloc<T extends MSImmutableSymbol>(): MSImmutableSymbolAllocator<T>;
  masterInstance(): MSImmutableLayerGroup;
}

class MSImmutableSymbolContainerAllocator<T extends MSImmutableSymbolContainer> extends _MSImmutableSymbolContainerAllocator<T> {}
declare class MSImmutableSymbolContainer extends _MSImmutableSymbolContainer {
  alloc<T extends MSImmutableSymbolContainer>(): MSImmutableSymbolContainerAllocator<T>;
}

class MSImmutableSymbolMasterAllocator<T extends MSImmutableSymbolMaster> extends _MSImmutableSymbolMasterAllocator<T> {}
declare class MSImmutableSymbolMaster extends _MSImmutableSymbolMaster {
  alloc<T extends MSImmutableSymbolMaster>(): MSImmutableSymbolMasterAllocator<T>;
  modifiedMasterByApplyingInstance_inDocument(instance: MSImmutableSymbolInstance, document: MSImmutableDocumentData): MSImmutableSymbolMaster;
  influenceRectPaddingForInstancesInDocument_visitedSymbols(doc: MSImmutableDocumentData, visitedSymbols: NSSet<any>): BCEdgePaddings;
  availableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;
  calculateAvailableOverridesWithDocument(document: MSImmutableDocumentData): NSArray<any>;

  changeIdentifier(): NSInteger;
}

class MSImmutableTextLayerAllocator<T extends MSImmutableTextLayer> extends _MSImmutableTextLayerAllocator<T> {}
declare class MSImmutableTextLayer extends _MSImmutableTextLayer implements IMSFirstLineTypesetterDelegate {
  alloc<T extends MSImmutableTextLayer>(): MSImmutableTextLayerAllocator<T>;
  defaultLineHeight(layoutManager: NSLayoutManager): CGFloat;
  startingPositionOnPath(shape: NSBezierPath): CGFloat;
  textContainerSize(): NSSize;
  shapeToUseForTextOnPathWithParentGroup(parentGroup: MSImmutableLayerGroup): MSImmutableStyledLayer;
  firstUnderlyingShapePathWithParentGroup(parentGroup: MSImmutableLayerGroup): NSBezierPath;
  bezierPathFromGlyphsInBoundsWithParentGroup_layoutManager(parentGroup: MSImmutableLayerGroup | null, layoutManager: NSLayoutManager): NSBezierPath;
  usedFontNames(): NSSet<any>;
  drawingPointForText(): NSPoint;
  createTextStorage(): NSTextStorage;
  textStoragePoolInCache(cache: BCCache): MSTextStoragePool;
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;

  fontSize(): CGFloat;
  stringValue(): NSString;
  attributedStringValue(): NSAttributedString;
  textAlignment(): NSTextAlignment;
  drawingPointForText(): NSPoint;
  textLayout(): MSTextLayout;
  transientGlyphBoundsValue(): NSValue;
  setTransientGlyphBoundsValue(transientGlyphBoundsValue: NSValue): void;
  capHeightBounds(): CGRect;
  shouldUseBezierRepresentationForRendering(): boolean;
  isEditingText(): boolean;
}

class MSImmutableTextStyleAllocator<T extends MSImmutableTextStyle> extends _MSImmutableTextStyleAllocator<T> {}
declare class MSImmutableTextStyle extends _MSImmutableTextStyle {
  alloc<T extends MSImmutableTextStyle>(): MSImmutableTextStyleAllocator<T>;

  attributes(): NSDictionary<any, any>;
}

class MSImmutableTriangleShapeAllocator<T extends MSImmutableTriangleShape> extends _MSImmutableTriangleShapeAllocator<T> {}
declare class MSImmutableTriangleShape extends _MSImmutableTriangleShape {
  alloc<T extends MSImmutableTriangleShape>(): MSImmutableTriangleShapeAllocator<T>;
}

class MSAbsoluteRectAllocator<T extends MSAbsoluteRect> extends BCRectAllocator<T> {
  initWithLayer(layer: MSLayer): T;
}
declare class MSAbsoluteRect extends BCRect {
  alloc<T extends MSAbsoluteRect>(): MSAbsoluteRectAllocator<T>;
  boundsContainsPoint(mouse: NSPoint): boolean;

  rulerOrigin(): CGPoint;
  setRulerOrigin(rulerOrigin: CGPoint): void;
}

class MSAdaptableColorAllocator<T extends MSAdaptableColor> extends NSColorAllocator<T> {}
declare class MSAdaptableColor extends NSColor {
  alloc<T extends MSAdaptableColor>(): MSAdaptableColorAllocator<T>;
}

class MSApplicationMetadataAllocator<T extends MSApplicationMetadata> extends NSObjectAllocator<T> {}
declare class MSApplicationMetadata extends NSObject {
  alloc<T extends MSApplicationMetadata>(): MSApplicationMetadataAllocator<T>;
  static metadata(): NSDictionary<any, any>;
  static applicationKeys(): NSArray<any>;
}

class MSArchiveHeaderAllocator<T extends MSArchiveHeader> extends NSObjectAllocator<T> {
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): T;
}
declare class MSArchiveHeader extends NSObject implements IMSCoding {
  alloc<T extends MSArchiveHeader>(): MSArchiveHeaderAllocator<T>;
  static metadataForNewHeader(): NSDictionary<any, any>;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  encodeWithArchiver(archiver: MSBaseArchiver): void;

  version(): NSInteger;
  setVersion(version: NSInteger): void;
  compatibilityVersion(): NSInteger;
  setCompatibilityVersion(compatibilityVersion: NSInteger): void;
  metadata(): NSDictionary<any, any>;
  setMetadata(metadata: NSDictionary<any, any> | {[key: string]: any}): void;
  root(): any;
  setRoot(root: any): void;
  archiveReferenceIdentifier_bc(): NSString;
}

declare interface IMSArtboardGroup {
}

class MSArtboardPresetAllocator<T extends MSArtboardPreset> extends NSObjectAllocator<T> {
  initWithName_size_imageName(name: NSString | string, size: NSSize, imageName: NSString | string | null): T;
  initWithDictionaryRepresentation(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class MSArtboardPreset extends NSObject implements INSCopying {
  alloc<T extends MSArtboardPreset>(): MSArtboardPresetAllocator<T>;
  static sizeToFitPresetWithName_size(name: NSString | string, size: NSSize): MSArtboardPreset;
  oppositeOrientationPreset(): MSArtboardPreset;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  name(): NSString;
  setName(name: NSString | string): void;
  layerName(): NSString;
  size(): NSSize;
  setSize(size: NSSize): void;
  sizeDescription(): NSString;
  offersLandscapeVariant(): boolean;
  allowResizedMatching(): boolean;
  imageName(): NSString;
  image(): NSImage;
  tooltip(): NSString;
  isSizeToFit(): boolean;
  isNew(): boolean;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class MSArtboardPresetStoreAllocator<T extends MSArtboardPresetStore> extends NSObjectAllocator<T> {}
declare class MSArtboardPresetStore extends NSObject {
  alloc<T extends MSArtboardPresetStore>(): MSArtboardPresetStoreAllocator<T>;
  presetWithSize_preferredCategory(size: NSSize, preferredCategory: MSArtboardPresetsCategory | null): MSArtboardPreset;
  resizablePresetMatchingSize_preferredCategory(size: NSSize, preferredCategory: MSArtboardPresetsCategory | null): MSArtboardPreset;
  savePreset_error(newPreset: MSArtboardPreset, error: NSError): boolean;
  removePreset_error(aPreset: MSArtboardPreset, error: NSError): boolean;
  suggestedNameForUserPreset(): NSString;
  systemCategories(): NSArray<any>;

  categories(): NSArray<any>;
  customPresetsCategory(): MSArtboardPresetsCategory;
  static indexOfLastSelectedCategory(): NSUInteger;
  static setIndexOfLastSelectedCategory(indexOfLastSelectedCategory: NSUInteger): void;
}

class MSArtboardPresetsCategoryAllocator<T extends MSArtboardPresetsCategory> extends NSObjectAllocator<T> {
  initWithName_sections(name: NSString | string, sections: NSArray<any> | any[]): T;
  initWithDictionaryRepresentation(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class MSArtboardPresetsCategory extends NSObject {
  alloc<T extends MSArtboardPresetsCategory>(): MSArtboardPresetsCategoryAllocator<T>;
  static categoriesWithContentsOfURL(url: NSURL): NSArray<any>;

  name(): NSString;
  sections(): NSArray<any>;
}

class MSArtboardPresetsSectionAllocator<T extends MSArtboardPresetsSection> extends NSObjectAllocator<T> {
  initWithName_presets(name: NSString | string | null, presets: NSArray<any> | any[]): T;
  initWithDictionaryRepresentation(dictionary: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class MSArtboardPresetsSection extends NSObject {
  alloc<T extends MSArtboardPresetsSection>(): MSArtboardPresetsSectionAllocator<T>;
  static sectionsWithContentsOfURL(url: NSURL): NSArray<any>;
  static writeSections_toURL_error(collections: NSArray<any> | any[], url: NSURL, error: NSError): boolean;

  name(): NSString;
  presets(): NSArray<any>;
  dictionaryRepresentation(): NSDictionary<any, any>;
}

class MSAssetCollectionAllocator<T extends MSAssetCollection> extends _MSAssetCollectionAllocator<T> {}
declare class MSAssetCollection extends _MSAssetCollection {
  alloc<T extends MSAssetCollection>(): MSAssetCollectionAllocator<T>;
  numberOfAssetsOfType(type: MSAsset): NSUInteger;
  addAsset(asset: any): void;
  assetAtIndex_ofType(index: NSUInteger, type: MSAsset): any;
  removeAssetAtIndex_ofType(index: NSUInteger, type: MSAsset): void;
  indexesOfAsset(asset: any): NSIndexSet;
  moveAssetAtIndex_beforeObjectAtIndex_ofType(fromIndex: NSUInteger, toIndex: NSUInteger, type: MSAsset): boolean;
}

class MSColorAllocator<T extends MSColor> extends _MSColorAllocator<T> {
  initWithImmutableObject(immutableColor: MSImmutableColor): T;
}
declare class MSColor extends _MSColor implements IMSColor {
  alloc<T extends MSColor>(): MSColorAllocator<T>;
  static colorWithRGBADictionary(dict: NSDictionary<any, any> | {[key: string]: any}): any;
  RGBADictionary(): NSDictionary<any, any>;
  scaledColor(scale: CGFloat): MSColor;
  static colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): MSColor;
  static colorWithHue_saturation_brightness_alpha(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat): MSColor;
  static colorWithNSColor(color: NSColor): MSColor;
  static whiteColor(): MSColor;
  static blackColor(): MSColor;
  colorWithAlphaComponent(alpha: CGFloat): MSColor;
  NSColorWithColorSpace(space: NSColorSpace): NSColor;
  fuzzyIsEqual(other: MSColor): boolean;
  fuzzyIsEqual_precision(other: MSColor, precision: CGFloat): boolean;
  fuzzyIsEqualExcludingAlpha(other: MSColor): boolean;
  fuzzyIsEqualExcludingAlpha_precision(other: MSColor, precision: CGFloat): boolean;
}

class MSGradientAllocator<T extends MSGradient> extends _MSGradientAllocator<T> {
  initBlankGradient(): T;
  initWithNSGradient(nsGradient: NSGradient): T;
}
declare class MSGradient extends _MSGradient {
  alloc<T extends MSGradient>(): MSGradientAllocator<T>;
  NSGradientWithColorSpace(colorSpace: NSColorSpace): NSGradient;
  conditionedEllipseLength(): CGFloat;
  pointAtIndex(index: NSUInteger): NSPoint;
  setPoint_atIndex(point: NSPoint, index: NSUInteger): void;
  colorAtIndex(index: NSUInteger): MSColor;
  setColor_atIndex(color: MSColor, index: NSUInteger): void;
  addStopAtPosition(relativePoint: NSPoint): NSInteger;
  addStopAtLength(position: CGFloat): NSUInteger;
  removeStopAtIndex(index: NSUInteger): void;
  convertPointToPosition(p: NSPoint): CGFloat;
  stopAtIndex(index: NSUInteger): MSGradientStop;
  invert(): void;
  rotatePointsBy(degrees: CGFloat): void;
  hasOpacity(): boolean;
  CSSAttributeStringWithMasterAlpha(masterAlpha: CGFloat): NSString;

  svgPositionIsAbsolute(): boolean;
  setSvgPositionIsAbsolute(svgPositionIsAbsolute: boolean): void;
}

class MSImageDataAllocator<T extends MSImageData> extends NSObjectAllocator<T> {
  initWithImage(image: NSImage): T;
  initWithData_sha(data: NSData, sha1: NSData | null): T;
  initWithLegacyHash(sha1: NSData): T;
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): T;
}
declare class MSImageData extends NSObject implements INSCopying, IMSCoding, IMSJSONArchiverAlternativeFileReference {
  alloc<T extends MSImageData>(): MSImageDataAllocator<T>;
  CGImageSuitableForDrawingWithSize(size: CGSize): CGImageRef;
  isLegacy(): boolean;
  correctInvalidGamma(): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  encodeReferenceInJSONZipArchive(encoder: BCJSONZippedEncoder): void;
  static decodeReferenceFromJSONZipArchive_withReference(decoder: BCJSONZippedDecoder, referenceID: NSString | string): any;
  copyWithZone(zone: NSZone | null): any;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  encodeReferenceInJSONZipArchive(encoder: BCJSONZippedEncoder): void;
  static decodeReferenceFromJSONZipArchive_withReference(decoder: BCJSONZippedDecoder, referenceID: NSString | string): any;

  data(): NSData;
  sha1(): NSData;
  image(): NSImage;
  cgImage(): CGImageRef;
  archiveReferenceIdentifier_bc(): NSString;
}

class MSExportPresetAllocator<T extends MSExportPreset> extends _MSExportPresetAllocator<T> {
  initWithName_formats(name: NSString | string, formats: NSArray<any> | any[]): T;
}
declare class MSExportPreset extends _MSExportPreset implements IMSExportFormatContainer {
  alloc<T extends MSExportPreset>(): MSExportPresetAllocator<T>;
  containingLayer(): MSLayer;
  exportFormats(): NSArray<any>;
  removeExportFormat(exportFormat: MSExportFormat): void;
  containingLayer(): MSLayer;
  exportFormats(): NSArray<any>;
  removeExportFormat(exportFormat: MSExportFormat): void;
}

declare interface IMSAsset {
  assetType(): MSAsset;
  isAssetEqual(object: any): boolean;
}

declare enum MSAsset {
  MSAssetColor,
  MSAssetGradient,
  MSAssetImage,
  MSAssetSymbol,
  MSAssetExportPreset,
}

class MSAttributedStringAllocator<T extends MSAttributedString> extends NSObjectAllocator<T> {
  initWithAttributedString_colorSpace_convert(attributedString: NSAttributedString, colorSpace: NSColorSpace, convert: boolean): T;
  initWithAttributedString_documentColorSpace(attributedString: NSAttributedString, colorSpace: NSColorSpace): T;
  initWithUnarchiver(unarchiver: MSBaseUnarchiver): T;
}
declare class MSAttributedString extends NSObject implements IMSCoding, INSCopying {
  alloc<T extends MSAttributedString>(): MSAttributedStringAllocator<T>;
  static encodeAttributesInDictionary(attrs: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  static decodeAttributesInDictionary(attrs: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  static isRequiredFontAvailableInDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): boolean;
  static fontDescriptorInDictionary(attributes: NSDictionary<any, any> | {[key: string]: any}): NSFontDescriptor;
  attributedStringByReplacingFontNames(fontNames: NSDictionary<any, any> | {[key: string]: any}): MSAttributedString;
  resetComputedProperties(): void;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  copyWithZone(zone: NSZone | null): any;
  encodeWithArchiver(archiver: MSBaseArchiver): void;
  copyWithZone(zone: NSZone | null): any;

  attributedString(): NSAttributedString;
  transformedAttributedString(): NSAttributedString;
  fontDescriptors(): NSSet<any>;
  fontNames(): NSSet<any>;
  unavailableFontNames(): NSSet<any>;
  areRequiredFontsAvailable(): boolean;
  string(): NSString;
  archiveReferenceIdentifier_bc(): NSString;
}

declare enum MSAttributedStringTextTransform {
  MSAttributedStringTextTransformNone = 0,
  MSAttributedStringTextTransformUppercase,
  MSAttributedStringTextTransformLowercase,
}

class MSAttributedStringAttributeAllocator<T extends MSAttributedStringAttribute> extends NSObjectAllocator<T> {
  initWithJSONDecoder(decoder: BCJSONDecoder): T;
}
declare class MSAttributedStringAttribute extends NSObject implements IBCJSONEncoding {
  alloc<T extends MSAttributedStringAttribute>(): MSAttributedStringAttributeAllocator<T>;
  encodeAsJSON(coder: BCJSONEncoder): void;
  replacementObjectForJSONEncoder(coder: BCJSONEncoder): NSObject;
  encodeAsJSON(coder: BCJSONEncoder): void;
  replacementObjectForJSONEncoder(coder: BCJSONEncoder): NSObject;

  range(): NSRange;
  setRange(range: NSRange): void;
  attributeDictionary(): NSDictionary<any, any>;
  setAttributeDictionary(attributeDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
}

class MSAvailableOverrideAllocator<T extends MSAvailableOverride> extends NSObjectAllocator<T> {}
declare class MSAvailableOverride extends NSObject {
  alloc<T extends MSAvailableOverride>(): MSAvailableOverrideAllocator<T>;
  static availableOverrideWithOverridePoint_master_overrideValue_otherOverrides_inParent_document(overridePoint: MSOverridePoint, master: MSImmutableSymbolMaster, overrideValue: MSOverrideValue | null, otherOverrides: NSArray<any> | any[], parent: MSAvailableOverride | null, document: MSImmutableDocumentData): MSAvailableOverride;
  static enumerateOverrides_withBlock(overrides: NSArray<any> | any[], block: Block): void;
  static flattenAvailableOverrides(overrides: NSArray<any> | any[]): NSArray<any>;

  parent(): MSAvailableOverride;
  master(): MSImmutableSymbolMaster;
  affectedLayer(): MSImmutableLayer;
  overridePoint(): MSOverridePoint;
  children(): NSArray<any>;
  overrideValue(): any;
  currentValue(): any;
  defaultValue(): any;
  hasOverride(): boolean;
  isEditable(): boolean;
}

class MSBaseArchiverAllocator<T extends MSBaseArchiver> extends NSObjectAllocator<T> {}
declare class MSBaseArchiver extends NSObject {
  alloc<T extends MSBaseArchiver>(): MSBaseArchiverAllocator<T>;
  archiveRootObject(root: NSObject): void;
  shouldEncodeAsReference(object: NSObject | null): boolean;
  referenceObjectForObject(object: NSObject): NSObject;
  archivedDataWithRootObject_error(root: NSObject, error: NSError): NSData;
  static archivedDataWithHeaderAndRootObject(root: NSObject): NSData;
  encodeObject_forKey(object: NSObject | null, key: NSString | string): void;
  encodeDouble_forKey(value: number, key: NSString | string): void;
  encodeBool_forKey(value: boolean, key: NSString | string): void;
  encodeRect_forKey(rect: CGRect, key: NSString | string): void;
  encodePoint_forKey(point: CGPoint, key: NSString | string): void;
  encodeInteger_forKey(value: NSInteger, key: NSString | string): void;
  encodeSize_forKey(size: NSSize, key: NSString | string): void;

  archiveObjectIDs(): boolean;
  setArchiveObjectIDs(archiveObjectIDs: boolean): void;
}

class MSBaseUnarchiverAllocator<T extends MSBaseUnarchiver> extends NSObjectAllocator<T> {}
declare class MSBaseUnarchiver extends NSObject {
  alloc<T extends MSBaseUnarchiver>(): MSBaseUnarchiverAllocator<T>;
  static unarchiveObjectWithData(data: NSData): any;
  static unarchiveObjectWithData_actualVersion_error(data: NSData, actualVersion: MSDocumentVersion | null, error: NSError): any;
  static unarchiveObjectWithData_asVersion_corruptionDetected_error(data: NSData, version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;
  unarchiveObjectAsVersion_corruptionDetected_error(version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;
  decodeObjectOfClass_forKey(className: any, key: NSString | string): any;
  decodeObjectOfClasses_forKey(classes: NSSet<any> | null, key: NSString | string): any;
  instanciateObject(object: NSObject): any;
  containsValueForKey(key: NSString | string): boolean;
  decodeObjectForKey(key: NSString | string): any;
  decodeDoubleForKey_withDefault(key: NSString | string, defaultValue: number): number;
  decodeBoolForKey_withDefault(key: NSString | string, defaultValue: boolean): boolean;
  decodeRectForKey_withDefault(key: NSString | string, defaultValue: CGRect): CGRect;
  decodePointForKey_withDefault(key: NSString | string, defaultValue: CGPoint): CGPoint;
  decodeIntegerForKey_withDefault(key: NSString | string, defaultValue: NSInteger): NSInteger;
  decodeSizeForKey_withDefault(key: NSString | string, defaultValue: CGSize): CGSize;

  currentVersion(): NSInteger;
  setCurrentVersion(currentVersion: NSInteger): void;
  archiveVersion(): NSInteger;
  setArchiveVersion(archiveVersion: NSInteger): void;
  corruptionDetected(): boolean;
  setCorruptionDetected(corruptionDetected: boolean): void;
  actualSymbolIDs(): NSArray<any>;
  setActualSymbolIDs(actualSymbolIDs: NSArray<any> | any[]): void;
}

class MSBezierBuilderAllocator<T extends MSBezierBuilder> extends NSObjectAllocator<T> {
  initWithPointRadiusBehavior(pointRadiusBehaviour: MSPointRadiusBehaviour): T;
}
declare class MSBezierBuilder extends NSObject {
  alloc<T extends MSBezierBuilder>(): MSBezierBuilderAllocator<T>;
  bezierPath(): NSBezierPath;
  path(): MSPath;
  _bezierPath(): NSBezierPath;
  static bezierPathWithPoints_inRect_shouldClose_pointRadiusBehaviour(points: NSArray<any> | any[], rect: NSRect, shouldClose: boolean, pointRadiusBehaviour: MSPointRadiusBehaviour): NSBezierPath;
  static pathWithPoints_inRect_shouldClose_pointRadiusBehaviour(points: NSArray<any> | any[], rect: NSRect, shouldClose: boolean, pointRadiusBehaviour: MSPointRadiusBehaviour): MSPath;
  static bezierPathForSegmentAtIndex_inPath_inRect(index: NSUInteger, shapePath: MSShapePathLayer, rect: NSRect): NSBezierPath;

  pointRadiusBehaviour(): MSPointRadiusBehaviour;
}

class MSBezierContourAllocator<T extends MSBezierContour> extends NSObjectAllocator<T> {
  initWithSegments_closed(segments: NSArray<any> | any[], isClosed: boolean): T;
}
declare class MSBezierContour extends NSObject {
  alloc<T extends MSBezierContour>(): MSBezierContourAllocator<T>;
  static contourWithRect(rect: CGRect): MSBezierContour;
  static contourWithPolygonAtPoint_radius_sides(center: CGPoint, radius: CGFloat, sides: NSUInteger): MSBezierContour;
  reversedContour(): MSBezierContour;
  closedContour(): MSBezierContour;
  contourWithInset(inset: CGFloat): MSBezierContour;
  contourWithInset_joinStrategy(inset: CGFloat, strategy: MSBezierJoinStrategy): MSBezierContour;
  segmentBefore(segment: MSBezierSegment): MSBezierSegment;
  segmentAfter(segment: MSBezierSegment): MSBezierSegment;
  intersectionsWithSegment(segment: MSBezierSegment): NSSet<any>;

  closed(): boolean;
  clockwise(): boolean;
  segments(): NSArray<any>;
  bounds(): CGRect;
  path(): MSPath;
  isRectangular(): boolean;
}

class MSBezierCurveCurveJoinAllocator<T extends MSBezierCurveCurveJoin> extends MSBezierLineCurveJoinAllocator<T> {}
declare class MSBezierCurveCurveJoin extends MSBezierLineCurveJoin {
  alloc<T extends MSBezierCurveCurveJoin>(): MSBezierCurveCurveJoinAllocator<T>;
}

class MSBezierFilletAllocator<T extends MSBezierFillet> extends NSObjectAllocator<T> {
  initWithSegment1_segment2_segment1Offset_segment2Offset_arcEndPoint1_arcEndPoint2_arcCenter_arcRadius(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat, segment2Offset: CGFloat, arcEndPoint1: CGPoint, arcEndPoint2: CGPoint, arcCenter: CGPoint, arcRadius: CGFloat): T;
}
declare class MSBezierFillet extends NSObject {
  alloc<T extends MSBezierFillet>(): MSBezierFilletAllocator<T>;
  static bezierFilletWithSegment1_segment2_segment1Offset(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat): MSBezierFillet;
  static bezierFilletWithSegment1_segment2_filletRadius(segment1: MSBezierSegment, segment2: MSBezierSegment, filletRadius: CGFloat): MSBezierFillet;
  static zeroRadiusFilletWithSegment1_segment2(segment1: MSBezierSegment, segment2: MSBezierSegment): MSBezierFillet;
  reversedFillet(): MSBezierFillet;
  arcSegments(): NSArray<any>;
  addArcToBezierPath_orCGPath(bezierPath: NSBezierPath, pathRef: CGMutablePathRef): void;

  segment1(): MSBezierSegment;
  segment2(): MSBezierSegment;
  segment1Offset(): CGFloat;
  segment2Offset(): CGFloat;
  arcRadius(): CGFloat;
  arcEndPoint1(): CGPoint;
  arcEndPoint2(): CGPoint;
  arcCenter(): CGPoint;
  startAngle(): CGFloat;
  endAngle(): CGFloat;
  clockwise(): boolean;
}

class MSBezierInterpreterAllocator<T extends MSBezierInterpreter> extends NSObjectAllocator<T> {}
declare class MSBezierInterpreter extends NSObject {
  alloc<T extends MSBezierInterpreter>(): MSBezierInterpreterAllocator<T>;
  static pointsFromBezierPath_inRect(bezierPath: NSBezierPath, rect: NSRect): NSArray<any>;
  points(): NSArray<any>;

  bezierPath(): NSBezierPath;
  setBezierPath(bezierPath: NSBezierPath): void;
  rect(): NSRect;
  setRect(rect: NSRect): void;
}

class MSBezierIntersectionAllocator<T extends MSBezierIntersection> extends NSObjectAllocator<T> {
  initWithSegment1_segment2_segment1Offset_segment2Offset(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat, segment2Offset: CGFloat): T;
}
declare class MSBezierIntersection extends NSObject {
  alloc<T extends MSBezierIntersection>(): MSBezierIntersectionAllocator<T>;
  static intersectionWithSegment1_segment2_segment1Offset_segment2Offset(segment1: MSBezierSegment, segment2: MSBezierSegment, segment1Offset: CGFloat, segment2Offset: CGFloat): MSBezierIntersection;

  segment1(): MSBezierSegment;
  segment2(): MSBezierSegment;
  segment1Offset(): CGFloat;
  segment2Offset(): CGFloat;
}

class MSBezierJoinAllocator<T extends MSBezierJoin> extends NSObjectAllocator<T> {
  initWithSegment1_segment2_joinedSegments(segment1: MSBezierSegment, segment2: MSBezierSegment, joinedSegments: NSArray<any> | any[] | null): T;
}
declare class MSBezierJoin extends NSObject {
  alloc<T extends MSBezierJoin>(): MSBezierJoinAllocator<T>;
  static joinWithSegment1_segment2(segment1: MSBezierSegment, segment2: MSBezierSegment): MSBezierJoin;
  static joinWithSegment1_segment2_strategy(segment1: MSBezierSegment, segment2: MSBezierSegment, strategy: MSBezierJoinStrategy): MSBezierJoin;
  static segmentsByJoiningSegment1_segment2(segment1: MSBezierSegment, segment2: MSBezierSegment): NSArray<any>;

  segment1(): MSBezierSegment;
  segment2(): MSBezierSegment;
  joinedSegments(): NSArray<any>;
}

declare enum MSBezierJoinStrategy {
  MSBezierJoinStrategyNone = 1<<0,
  MSBezierJoinStrategyConnectEndpoints = 1<<1,
  MSBezierJoinStrategyIntersect = 1<<2,
  MSBezierJoinStrategyExtend = 1<<3,
  MSBezierJoinStrategyMirror = 1<<4,
  MSBezierJoinStrategyExtendTangent = 1<<5,
  MSBezierJoinStrategyArc = 1<<6,
  MSBezierJoinStrategyAny,
  MSBezierJoinStrategyDefault,
}

class MSBezierLineCurveJoinAllocator<T extends MSBezierLineCurveJoin> extends MSBezierJoinAllocator<T> {}
declare class MSBezierLineCurveJoin extends MSBezierJoin {
  alloc<T extends MSBezierLineCurveJoin>(): MSBezierLineCurveJoinAllocator<T>;
}

class MSBezierLineLineJoinAllocator<T extends MSBezierLineLineJoin> extends MSBezierJoinAllocator<T> {}
declare class MSBezierLineLineJoin extends MSBezierJoin {
  alloc<T extends MSBezierLineLineJoin>(): MSBezierLineLineJoinAllocator<T>;
}

class MSBezierSegmentAllocator<T extends MSBezierSegment> extends NSObjectAllocator<T> {
  initWithEndPoint1_endPoint2(endPoint1: CGPoint, endPoint2: CGPoint): T;
  initWithEndPoint1_endPoint2_controlPoint(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint: CGPoint): T;
  initWithEndPoint1_endPoint2_controlPoint1_controlPoint2(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): T;
}
declare class MSBezierSegment extends NSObject {
  alloc<T extends MSBezierSegment>(): MSBezierSegmentAllocator<T>;
  static lineSegmentWithEndPoint1_endPoint2(endPoint1: CGPoint, endPoint2: CGPoint): MSBezierSegment;
  static quadraticSegmentWithEndPoint1_endPoint2_controlPoint(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint: CGPoint): MSBezierSegment;
  static cubicSegmentWithEndPoint1_endPoint2_controlPoint1_controlPoint2(endPoint1: CGPoint, endPoint2: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): MSBezierSegment;
  segmentWithEndPoint1(endPoint1: CGPoint): MSBezierSegment;
  segmentWithEndPoint2(endPoint2: CGPoint): MSBezierSegment;
  segmentMirroredAtOffset(offset: CGFloat): MSBezierSegment;
  tanget_andPoint_atOffset(tangent: MSLine, point: CGPoint, offset: CGFloat): void;
  tangentAtOffset(offset: CGFloat): MSLine;
  pointAtOffset(offset: CGFloat): CGPoint;
  curvatureAtOffset(offset: CGFloat): CGFloat;
  segmentToOffset(offset: CGFloat): MSBezierSegment;
  segmentFromOffset(offset: CGFloat): MSBezierSegment;
  segmentByMovingPointAtOffset_toLocation(offset: CGFloat, location: CGPoint): MSBezierSegment;
  segmentWithTransform(transform: CGAffineTransform): MSBezierSegment;
  segmentWithInset(inset: CGFloat): MSBezierSegment;
  segmentsWithFlatness(flatness: CGFloat): NSArray<any>;
  offsetForNormalToPoint(point: CGPoint): CGFloat;
  offsetsOfIntersectionsWithTangent(tangent: MSLine): NSSet<any>;
  intersectionsWithSegment(segment: MSBezierSegment): NSSet<any>;
  lineRepresentation(): MSBezierSegment;
  quadraticRepresentation(): MSBezierSegment;
  cubicRepresentation(): MSBezierSegment;
  representationUsingType(type: MSBezierSegmentType): MSBezierSegment;
  reversedSegment(): MSBezierSegment;
  isEqualToBezierSegment(object: MSBezierSegment): boolean;
  derivative(): MSBezierSegment;
  bounds(): CGRect;
  bezierPath(): NSBezierPath;

  segmentType(): MSBezierSegmentType;
  endPoint1(): CGPoint;
  endPoint2(): CGPoint;
  lineLength(): CGFloat;
  arcLength(): CGFloat;
  controlPoint1(): CGPoint;
  controlPoint2(): CGPoint;
  looksLikeALine(): boolean;
  isAPoint(): boolean;
  lineSegment(): MSLineSegment;
  xAxisRoots(): NSSet<any>;
  yAxisRoots(): NSSet<any>;
  inflectionOffsets(): NSSet<any>;
  curviness(): CGFloat;
  flatness(): CGFloat;
  transformForXAxisAlignment(): CGAffineTransform;
}

declare enum MSBezierSegmentType {
  MSBezierSegmentTypeLine = 0,
  MSBezierSegmentTypeQuadratic,
  MSBezierSegmentTypeCubic,
}

class MSBitmapLayerAllocator<T extends MSBitmapLayer> extends _MSBitmapLayerAllocator<T> {
  initWithFrame_image(frame: NSRect, image: MSImageData): T;
}
declare class MSBitmapLayer extends _MSBitmapLayer implements IMSImageOwner {
  alloc<T extends MSBitmapLayer>(): MSBitmapLayerAllocator<T>;
  replaceImageWithImage(image: NSImage): void;
  NSImage(): NSImage;
  isAtOriginalSize(): boolean;
  resizeToOriginalSize(): void;
  correctInvalidGamma(): void;
  setReducedImage(image: MSImageData): void;
  setReducedImage(image: MSImageData): void;

  image(): MSImageData;
  setImage(image: MSImageData): void;
  targetSizeForReduction(): NSSize;
  canReduceImageSize(): boolean;
}

declare enum MSBlendMode {
  MSBlendModeNormal = 0,
  MSBlendModeDarken = 1,
  MSBlendModeMultiply = 2,
  MSBlendModeColorBurn = 3,
  MSBlendModeLighten = 4,
  MSBlendModeScreen = 5,
  MSBlendModeColorDodge = 6,
  MSBlendModeOverlay = 7,
  MSBlendModeSoftLight = 8,
  MSBlendModeHardLight = 9,
  MSBlendModeDifference = 10,
  MSBlendModeExclusion = 11,
  MSBlendModeHue = 12,
  MSBlendModeSaturation = 13,
  MSBlendModeColor = 14,
  MSBlendModeLuminosity = 15,
  MSBlendModePlusDarker = 16,
  MSBlendModePlusLighter = 17,
}

class MSBooleanOperationChainAllocator<T extends MSBooleanOperationChain> extends NSObjectAllocator<T> {
  initWithSubjectPath(subject: MSPath): T;
}
declare class MSBooleanOperationChain extends NSObject {
  alloc<T extends MSBooleanOperationChain>(): MSBooleanOperationChainAllocator<T>;
  static booleanOperationChainWithSubjectPath(subject: MSPath): MSBooleanOperationChain;
  addClippingPath_forBooleanOperation(subject: MSPath, operation: MSBooleanOperation): void;
  resultPath(): MSPath;
}

declare interface IMSCoding {
  encodeWithArchiver(archiver: MSBaseArchiver): void;

  archiveReferenceIdentifier_bc(): NSString;
}

declare interface IMSColor {
}

class MSColorArchivingFactoryAllocator<T extends MSColorArchivingFactory> extends NSObjectAllocator<T> {}
declare class MSColorArchivingFactory extends NSObject {
  alloc<T extends MSColorArchivingFactory>(): MSColorArchivingFactoryAllocator<T>;
  static colorForEncodingColor(color: MSColor): MSColor;
}

declare interface IMSColorConverter {
  convertColor(color: MSColor): MSColor;
  convertImmutableColor(color: MSImmutableColor): MSImmutableColor;
  shouldConvertColor(color: MSColor): boolean;
  shouldConvertImmutableColor(color: MSImmutableColor): boolean;
}

declare interface IMSColorConvertible {
  convertColorsUsing(converter: any): void;
}

class MSColorCounterAllocator<T extends MSColorCounter> extends NSObjectAllocator<T> {}
declare class MSColorCounter extends NSObject {
  alloc<T extends MSColorCounter>(): MSColorCounterAllocator<T>;
  countSource(source: any): void;
  compare(otherCounter: MSColorCounter): NSComparisonResult;
  compare_byColorUse(otherCounter: MSColorCounter, use: MSColorUse): NSComparisonResult;

  immutableColor(): MSImmutableColor;
  setImmutableColor(immutableColor: MSImmutableColor): void;
  color(): MSColor;
  totalCount(): NSUInteger;
  title(): NSString;
}

declare enum MSColorSpace {
  MSColorSpaceUnmanaged = 0,
  MSColorSpaceSRGB = 1,
  MSColorSpaceDisplayP3 = 2,
}

declare interface IMSColorUser {
  updateColorCounter(color: MSColorCounter): void;
}

declare enum MSColorUse {
  MSColorUseAll = 0,
  MSColorUseFill = 1,
  MSColorUseBorder = 2,
  MSColorUseShadow = 3,
  MSColorUseInnerShadow = 4,
  MSColorUseText = 5,
  MSColorUseArtboard = 6,
}

class MSConstantBaselineLayoutManagerAllocator<T extends MSConstantBaselineLayoutManager> extends NSLayoutManagerAllocator<T> {}
declare class MSConstantBaselineLayoutManager extends NSLayoutManager {
  alloc<T extends MSConstantBaselineLayoutManager>(): MSConstantBaselineLayoutManagerAllocator<T>;

  constantBaselineTypesetter(): MSConstantBaselineTypesetter;
  setConstantBaselineTypesetter(constantBaselineTypesetter: MSConstantBaselineTypesetter): void;
}

class MSConstantBaselineTypesetterAllocator<T extends MSConstantBaselineTypesetter> extends NSATSTypesetterAllocator<T> {}
declare class MSConstantBaselineTypesetter extends NSATSTypesetter {
  alloc<T extends MSConstantBaselineTypesetter>(): MSConstantBaselineTypesetterAllocator<T>;
  constantBaselineGlyphRangeForGlyphLocation(location: NSUInteger): NSRange;
  invalidateLayoutFromGlyphLocation(location: NSUInteger): void;
}

declare enum MSCurveMode {
  MSCurveModeUndefined = 0,
  MSCurveModeStraight = 1,
  MSCurveModeMirrored = 2,
  MSCurveModeAsymmetric = 3,
  MSCurveModeDisconnected = 4,
}

class MSCurvePointAllocator<T extends MSCurvePoint> extends _MSCurvePointAllocator<T> {
  initWithPoint(p: NSPoint): T;
  initWithPoint_curveTo_curveFrom(p: NSPoint, p2: NSPoint, p1: NSPoint): T;
}
declare class MSCurvePoint extends _MSCurvePoint implements IMSCurvePoint, INSCopying {
  alloc<T extends MSCurvePoint>(): MSCurvePointAllocator<T>;
  static point(): MSCurvePoint;
  static pointWithPoint(p: NSPoint): MSCurvePoint;
  static pointWithPoint_curveTo_curveFrom(p: NSPoint, p2: NSPoint, p1: NSPoint): MSCurvePoint;
  changeCurveModeTo_usingPoint(m: MSCurveMode, pointType: MSPointType): void;
  isRounded(): boolean;
  inferCurveMode(): void;
  locationOfPoint(pointType: MSPointType): NSPoint;
  movePointTo(p: NSPoint): void;
  moveCurveFromTo(p: NSPoint): void;
  moveCurveToTo(p: NSPoint): void;
  multiplyBy(amount: CGFloat): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  isStraight(): boolean;
  isEffectivelyStraight(): boolean;
}

declare interface IMSCurvePoint {
}

declare enum MSPointType {
  MSPointTypeMain = 0,
  MSPointTypeControl1 = 1,
  MSPointTypeControl2 = 2,
}

declare enum MSCurveMoveOptions {
  MSCurveMoveIndependently = 1 << 0,
}

class MSCurvePointAsymmetricBehaviourAllocator<T extends MSCurvePointAsymmetricBehaviour> extends MSCurvePointBehaviourAllocator<T> {}
declare class MSCurvePointAsymmetricBehaviour extends MSCurvePointBehaviour {
  alloc<T extends MSCurvePointAsymmetricBehaviour>(): MSCurvePointAsymmetricBehaviourAllocator<T>;
}

class MSCurvePointBehaviourAllocator<T extends MSCurvePointBehaviour> extends NSObjectAllocator<T> {}
declare class MSCurvePointBehaviour extends NSObject {
  alloc<T extends MSCurvePointBehaviour>(): MSCurvePointBehaviourAllocator<T>;
  static didAssignBehaviorToHandle_ofPoint_previousMode(handle: MSPointType, point: MSCurvePoint, oldMode: MSCurveMode): void;
  static curveFromChangedInPoint(point: MSCurvePoint): void;
  static curveToChangedInPoint(point: MSCurvePoint): void;
}

class MSCurvePointDisconnectedBehaviourAllocator<T extends MSCurvePointDisconnectedBehaviour> extends MSCurvePointBehaviourAllocator<T> {}
declare class MSCurvePointDisconnectedBehaviour extends MSCurvePointBehaviour {
  alloc<T extends MSCurvePointDisconnectedBehaviour>(): MSCurvePointDisconnectedBehaviourAllocator<T>;
}

class MSCurvePointMirroredBehaviourAllocator<T extends MSCurvePointMirroredBehaviour> extends MSCurvePointBehaviourAllocator<T> {}
declare class MSCurvePointMirroredBehaviour extends MSCurvePointBehaviour {
  alloc<T extends MSCurvePointMirroredBehaviour>(): MSCurvePointMirroredBehaviourAllocator<T>;
}

class MSCurvePointStraightBehaviourAllocator<T extends MSCurvePointStraightBehaviour> extends MSCurvePointBehaviourAllocator<T> {}
declare class MSCurvePointStraightBehaviour extends MSCurvePointBehaviour {
  alloc<T extends MSCurvePointStraightBehaviour>(): MSCurvePointStraightBehaviourAllocator<T>;
}

class MSDefaultArchiveAllocator<T extends MSDefaultArchive> extends BCSingletonAllocator<T> {}
declare class MSDefaultArchive extends BCSingleton {
  alloc<T extends MSDefaultArchive>(): MSDefaultArchiveAllocator<T>;
  archivesNeedingMigration(): NSArray<any>;
  oldDefaultsName(): NSString;
  filename(): NSString;
  defaultClass(): any;
  newObject(): any;

  defaultObject(): any;
  setDefaultObject(defaultObject: any): void;
}

class MSDefaultGridAllocator<T extends MSDefaultGrid> extends MSDefaultArchiveAllocator<T> {}
declare class MSDefaultGrid extends MSDefaultArchive {
  alloc<T extends MSDefaultGrid>(): MSDefaultGridAllocator<T>;

  static defaultGrid(): MSSimpleGrid;
  static setDefaultGrid(defaultGrid: MSSimpleGrid): void;
}

class MSDefaultLayoutGridAllocator<T extends MSDefaultLayoutGrid> extends MSDefaultArchiveAllocator<T> {}
declare class MSDefaultLayoutGrid extends MSDefaultArchive {
  alloc<T extends MSDefaultLayoutGrid>(): MSDefaultLayoutGridAllocator<T>;

  static defaultLayout(): MSLayoutGrid;
  static setDefaultLayout(defaultLayout: MSLayoutGrid): void;
}

class MSDefaultStyleAllocator<T extends MSDefaultStyle> extends MSDefaultArchiveAllocator<T> {}
declare class MSDefaultStyle extends MSDefaultArchive {
  alloc<T extends MSDefaultStyle>(): MSDefaultStyleAllocator<T>;

  static defaultStyle(): MSStyle;
  static setDefaultStyle(defaultStyle: MSStyle): void;
}

class MSDefaultTextStyleAllocator<T extends MSDefaultTextStyle> extends MSDefaultArchiveAllocator<T> {}
declare class MSDefaultTextStyle extends MSDefaultArchive {
  alloc<T extends MSDefaultTextStyle>(): MSDefaultTextStyleAllocator<T>;
  static recordTextStyleForLayer(layer: MSTextLayer): void;

  static defaultTextStyle(): NSDictionary<any, any>;
  static setDefaultTextStyle(defaultTextStyle: NSDictionary<any, any> | {[key: string]: any}): void;
}

class MSDiffAllocator<T extends MSDiff> extends NSObjectAllocator<T> {
  initWithFirstObjectRoot_secondObjectRoot(first: MSSubtreeRoot, second: MSSubtreeRoot): T;
}
declare class MSDiff extends NSObject {
  alloc<T extends MSDiff>(): MSDiffAllocator<T>;
  contentDirtyDiffRect(): NSRect;
  overlayDirtyDiffRect(): NSRect;

  firstObjectRoot(): MSSubtreeRoot;
  secondObjectRoot(): MSSubtreeRoot;
}

declare interface IMSDocumentData {

  pages(): NSArray<any>;
}

declare interface IMSDocumentDataDelegate {
  documentData_didChangeToPage(data: MSDocumentData, newPage: MSPage): void;
  documentData_temporarilyHideSelectionForLayers(data: MSDocumentData, layers: NSArray<any> | any[]): void;
  documentDataImmediatelyShowSelectionForAllLayers(data: MSDocumentData): void;
  documentDidChange(document: MSDocumentData): void;
  documentData_storeMetadata_forKey_object(data: MSDocumentData, metadata: any, key: NSString | string, object: MSModelObject): void;
  documentData_metadataForKey_object(data: MSDocumentData, key: NSString | string, object: MSModelObject): any;
  layerTreeLayoutDidChange(): void;
  refreshOverlayInRect(rect: NSRect): void;
  refreshOverlay(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  visibleCanvasRectForDocumentData(data: MSDocumentData): CGRect;
}

class MSDocumentErrorAllocator<T extends MSDocumentError> extends NSErrorAllocator<T> {}
declare class MSDocumentError extends NSError {
  alloc<T extends MSDocumentError>(): MSDocumentErrorAllocator<T>;
  static errorWithCode(code: MSDocumentErrorCode): MSDocumentError;
}

declare enum MSDocumentErrorCode {
  MSDocumentNoError,
  MSDocumentWrongType,
  MSDocumentMissingMetadata,
  MSDocumentCorruptMetadata,
  MSDocumentTooNew,
  MSDocumentCorruptDocument,
  MSDocumentMissingFonts,
  MSDocumentMissingWrapper,
  MSDocumentWrongSize,
  MSDocumentCouldntLoadData,
  MSDocumentNeedsMigrationService,
  MSDocumentUnarchivingError,
  MSDocumentUnknownError,
}

declare interface IMSDocumentPreviewGeneration {
  generatePreviewsForDocument(documentData: MSImmutableDocumentData): NSDictionary<any, any>;
}

class MSDocumentReaderAllocator<T extends MSDocumentReader> extends NSObjectAllocator<T> {}
declare class MSDocumentReader extends NSObject {
  alloc<T extends MSDocumentReader>(): MSDocumentReaderAllocator<T>;
  static readerForDocumentAtURL(url: NSURL): MSDocumentReader;
  repair(): void;
  readDataWithCorruptionDetected_error(corruptionDetected: boolean, error: NSError): MSDocumentData;
  open(error: NSError): boolean;
  previewImageWithMaximumSize(size: NSSize): NSImage;
  validate(): MSDocumentErrorCode;
  readImmutableDataWithCorruptionDetected_error(corruptionDetected: boolean, errorOut: NSError): MSImmutableDocumentData;
  static readerForDocumentAtURL_engine(url: NSURL, engine: ECCommandLineEngine): MSDocumentReader;

  documentWasMigrated(): boolean;
  missingFonts(): NSArray<any>;
  UIMetadata(): NSDictionary<any, any>;
  containsPreviewImage(): boolean;
  previewImage(): NSImage;
  libraryPreviewImage(): NSImage;
  version(): MSDocumentVersion;
  compatibilityVersion(): MSDocumentVersion;
  metadata(): NSDictionary<any, any>;
}

class MSDocumentTreeAllocator<T extends MSDocumentTree> extends NSObjectAllocator<T> {
  initWithDocumentData(documentData: MSImmutableDocumentData): T;
}
declare class MSDocumentTree extends NSObject {
  alloc<T extends MSDocumentTree>(): MSDocumentTreeAllocator<T>;
  parentForObject(object: MSImmutableModelObject): any;
  ancestorsOfObject(object: MSImmutableModelObject): NSArray<any>;
  ancestorLayersOfObject(object: MSImmutableLayer): NSArray<any>;

  documentData(): MSImmutableDocumentData;
  cache(): BCCache;
}

declare enum MSDocumentVersion {
  MSDocumentUnknownVersion = -1,
  MSDocumentEarlyVersion = 0,
  MSDocument211to212Version = 2,
  MSDocument213to214Version = 3,
  MSDocument220Version = 4,
  MSDocument221Version = 8,
  MSDocument222to223Version = 9,
  MSDocument224to23Version = 10,
  MSDocumentFirstComaVersion = 14,
  MSDocumentAKArrayRenamedVersion = 16,
  MSDocumentDontStoreDefaultsAndOptimiseColors = 17,
  MSDocumentArchiveColorsAsDoubles = 18,
  MSDocumentMigrationTest = 19,
  MSDocumentSymbols = 20,
  MSDocumentDontSyncFlagOnText = 21,
  MSDocumentRemovedSliceContainers = 22,
  MSDocumentAddedExportOptions = 23,
  MSDocumentUnifiedTextStyleSymbols = 24,
  MSDocumentMigrateArtboardAssociatedSlice = 25,
  MSDocumentMergeLayerContainers = 26,
  MSDocumentColorControlsLoadingFix = 27,
  MSDocumentAddedWindingRule = 28,
  MSDocumentClearStylesOnArtboards = 29,
  MSDocumentOriginalObjectIDOnLayers = 30,
  MSDocumentDeprecateAdaptableColor = 31,
  MSDocumentNoiseAsSeparateFill = 32,
  MSDocumentImageCollection = 33,
  MSDocumentExportableLayers = 34,
  MSDocumentStripUnsupportedAttributes = 35,
  MSDocumentMergeStraightAndRoundedCornerEnums = 36,
  MSDocumentSplitGridAndLayout = 37,
  MSDocumentStructuredFile = 40,
  MSDocumentPatternsUsesImageCollection = 41,
  MSDocumentPatternsImagePropertyRemoved = 42,
  MSDocumentImageNameRemoved = 43,
  MSDocumentDontEncodeArchivedColor = 44,
  MSDocumentTextHeightIsClippedProperty = 45,
  MSDocumentNewLineSpacingBehaviour = 46,
  MSDocumentPersistentLayerListFolding = 47,
  MSDocumentDefaultStyleIncludesPatternImages = 48,
  MSDocumentArtisticStrokeRemoved = 49,
  MSDocumentDecorationsRemoved = 50,
  MSDocumentAddedLayerUserInfo = 51,
  MSDocumentArrowMoveToStyle = 52,
  MSDocumentColorControlsHue = 53,
  MSDocumentLocalAssets = 54,
  MSDocumentImagesStoredInLocalAssets = 55,
  MSDocumentSaveImmutableVariants = 56,
  MSDocumentSaveImageWrappersThemselves = 57,
  MSDocumentArtboardsOnFullPixels = 58,
  MSDocumentRemoveHasDashPatternProperty = 59,
  MSDocumentNineSliceScaleAdded = 60,
  MSDocumentFillReplacesImage = 61,
  MSDocumentNineSliceScaleBugFix = 62,
  MSDocumentSharedStylesOnInappropriateLayersBugFix = 63,
  MSDocumentRestoreImmutableVariants = 70,
  MSDocumentCloudShareIDSupport = 71,
  MSDocumentRenameSharedLayerToSymbol = 72,
  MSDocumentRenamedExportSizeToExportFormat = 73,
  MSDocumentRetinaCanvasAndDefaultZoomValueRemoved = 74,
  MSDocumentImageCollectionDeprecated = 75,
  MSDocumentImageCollectionCleared = 76,
  MSDocumentConsistentBaselineTypesetter = 77,
  MSDocumentTextLayerGlyphBounds = 78,
  MSDocumentSymbolsAsArtboards = 79,
  MSDocumentCloudExport = 80,
  MSDocumentRemoveNSTextStorage = 81,
  MSDocumentRemoveNSFontFromMSTextStyle = 82,
  MSDocumentHistoryBasedUndoIntroduced = 83,
  MSDocumentDataUserInfoAdded = 84,
  MSDocumentRepairSymbolOverrideMissingRootDictionary = 85,
  MSDocumentReplaceMSArray = 86,
  MSDocumentLayerResizing = 87,
  MSDocumentZippedJSON = 88,
  MSDocumentShapeLayerPointRadiusType = 89,
  MSDocumentRemoveGridIndex = 90,
  MSDocumentResizingMask = 91,
  MSDocumentDuplicateIDFix = 92,
  MSDocumentVerticalAlignmentAsComaProperty = 93,
  MSDocumentSmoothPointRadiusBehaviour = 94,
  MSDocumentColorManagementThatDidntShip = 95,
  MSDocumentColorManagementForReal = 96,
  MSDocumentOverrideValues = 97,
  MSDocumentRefactorBCTextBehaviour = 98,
  MSDocumentMSAttributedStringJSON = 99,
  MSDocumentRemoveShapePathClass = 100,
  MSDocumentPersistentArtboardPresets = 101,
  MSDocumentForeignStyles = 102,
  MSDocumentUseGenericDocumentMetadataKey = 103,
  MSDocumentRefactorWindingRule = 104,
  MSDocumentFancyArrowHeads = 105,
  MSDocumentPlusLigherPlusDarkerBlendModes = 106,
  MSDocumentBackgroundBlurSaturation = 107,
  MSDocumentNestedBooleanOperations = 110,
  MSDocumentZoomBlurCoordinateSystem = 111,
  MSDocumentNextVersion,
  MSDocumentCurrentVersion,
  MSDocumentCompatibilityVersion,
  MSDocumentNewestVersionRequiringMigration,
}

class MSDocumentWriterAllocator<T extends MSDocumentWriter> extends NSObjectAllocator<T> {
  initWithFileURL(url: NSURL): T;
}
declare class MSDocumentWriter extends NSObject {
  alloc<T extends MSDocumentWriter>(): MSDocumentWriterAllocator<T>;
  writeDocumentData_isAutosave_error(data: MSImmutableDocumentData, isAutosave: boolean, error: NSError): boolean;
  static metadataForNewFile(): NSDictionary<any, any>;

  UIMetadata(): NSDictionary<any, any>;
  setUIMetadata(UIMetadata: NSDictionary<any, any> | {[key: string]: any}): void;
  previewGenerationBlock(): imageGenerationBlock;
  setPreviewGenerationBlock(previewGenerationBlock: imageGenerationBlock): void;
}

class MSDocumentZippedJSONReaderAllocator<T extends MSDocumentZippedJSONReader> extends MSDocumentReaderAllocator<T> {
  initWithFileURL(url: NSURL): T;
}
declare class MSDocumentZippedJSONReader extends MSDocumentReader {
  alloc<T extends MSDocumentZippedJSONReader>(): MSDocumentZippedJSONReaderAllocator<T>;
}

class MSExportFormatAllocator<T extends MSExportFormat> extends _MSExportFormatAllocator<T> {}
declare class MSExportFormat extends _MSExportFormat {
  alloc<T extends MSExportFormat>(): MSExportFormatAllocator<T>;
  static formatWithScale_name_fileFormat(scale: CGFloat, name: NSString | string, format: NSString | string): MSExportFormat;
  static formatWithScale_name_fileFormat_absoluteSize_namingScheme(scale: CGFloat, name: NSString | string, format: NSString | string, absoluteSize: CGFloat, namingScheme: MSExportFormatNamingScheme): MSExportFormat;
  static validFormats(): NSSet<any>;
  static exportableFilenameBodyForLayerName_exportFormat(layerName: NSString | string, format: MSImmutableExportFormat): NSString;
  static exportableFilenameForLayerName_exportFormat(layerName: NSString | string, format: MSImmutableExportFormat): NSString;
  container(): any;
  parentLayer(): MSLayer;
  remove(): void;
  isScalableExport(): boolean;
}

declare interface IMSExportFormatContainer {
  containingLayer(): MSLayer;
  exportFormats(): NSArray<any>;
  removeExportFormat(exportFormat: MSExportFormat): void;
}

declare enum MSExportFormatNamingScheme {
  MSExportFormatNamingSchemeSuffix = 0,
  MSExportFormatNamingSchemePrefix = 1,
}

declare enum MSExportLayerOptions {
  MSExportLayersAll = 0,
  MSExportLayersSelected = 1,
  MSExportLayersInGroup = 2,
}

class MSExportOptionsAllocator<T extends MSExportOptions> extends _MSExportOptionsAllocator<T> {}
declare class MSExportOptions extends _MSExportOptions implements IMSExportFormatContainer {
  alloc<T extends MSExportOptions>(): MSExportOptionsAllocator<T>;
  static nextMostAppropriateExportFormatToAdd(existingExportFormats: NSArray<any> | any[]): MSExportFormat;
  addExportFormat(): MSExportFormat;
  containingLayer(): MSLayer;
  exportFormats(): NSArray<any>;
  removeExportFormat(exportFormat: MSExportFormat): void;
  containingLayer(): MSLayer;
  exportFormats(): NSArray<any>;
  removeExportFormat(exportFormat: MSExportFormat): void;
}

class MSFeatureAvailabilityAllocator<T extends MSFeatureAvailability> extends NSObjectAllocator<T> {}
declare class MSFeatureAvailability extends NSObject {
  alloc<T extends MSFeatureAvailability>(): MSFeatureAvailabilityAllocator<T>;
  static enableFeatureAvailability(): void;

  static libraryStylesEnabled(): boolean;
  static setLibraryStylesEnabled(libraryStylesEnabled: boolean): void;
  static feature14414Enabled(): boolean;
  static setFeature14414Enabled(feature14414Enabled: boolean): void;
  static dataSuppliersEnabled(): boolean;
  static setDataSuppliersEnabled(dataSuppliersEnabled: boolean): void;
  static isComponentsPanelEnabled(): boolean;
  static setIsComponentsPanelEnabled(isComponentsPanelEnabled: boolean): void;
  static builtInRemoteLibrariesEnabled(): boolean;
  static setBuiltInRemoteLibrariesEnabled(builtInRemoteLibrariesEnabled: boolean): void;
  static cloudDocumentsEnabled(): boolean;
  static setCloudDocumentsEnabled(cloudDocumentsEnabled: boolean): void;
}

class MSFirstLineHeightTypesetterAllocator<T extends MSFirstLineHeightTypesetter> extends NSATSTypesetterAllocator<T> {}
declare class MSFirstLineHeightTypesetter extends NSATSTypesetter {
  alloc<T extends MSFirstLineHeightTypesetter>(): MSFirstLineHeightTypesetterAllocator<T>;

  forcedBaselineOffset(): CGFloat;
  setForcedBaselineOffset(forcedBaselineOffset: CGFloat): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSFirstLineTypesetterDelegate {
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;
}

class MSFlowConnectionAllocator<T extends MSFlowConnection> extends _MSFlowConnectionAllocator<T> {}
declare class MSFlowConnection extends _MSFlowConnection {
  alloc<T extends MSFlowConnection>(): MSFlowConnectionAllocator<T>;
  static flowConnectionTo_ofType(to: MSArtboardGroup, type: MSFlowAnimationType): MSFlowConnection;
  static flowConnectionBack(): MSFlowConnection;
  static defaultAnimationType(): MSFlowAnimationType;
  bezierPathForRenderingFlowAtZoomLevel(zoomLevel: CGFloat): NSBezierPath;

  isBackAction(): boolean;
  setIsBackAction(isBackAction: boolean): void;
  isValidFlowConnection(): boolean;
  sendingLayer(): MSLayer;
  destinationArtboard(): MSArtboardGroup;
}

declare enum MSFlowAnimationType {
  MSFlowAnimationNone = -1,
  MSFlowAnimationSlideFromRight = 0,
  MSFlowAnimationSlideFromLeft,
  MSFlowAnimationSlideFromBottom,
  MSFlowAnimationSlideFromTop,
}

declare type MSFlowEndpoint = {
  edge: BCEdge
  rect: NSRect
}

declare type MSFlowInfo = {
  from: MSFlowEndpoint
  to: MSFlowEndpoint
  type: MSFlowType
}

declare enum MSFlowType {
  MSFlowTypeRegularTranstion,
  MSFlowTypeBackTransition,
  MSFlowTypeTransitionToParent,
  MSFlowTypeOtherPageTransition,
}

class MSFontListAllocator<T extends MSFontList> extends NSObjectAllocator<T> {
  initWithDocumentData(documentData: MSDocumentData): T;
}
declare class MSFontList extends NSObject {
  alloc<T extends MSFontList>(): MSFontListAllocator<T>;
  reloadFonts(): void;
  numberOfFontFamilies(): NSUInteger;
  nameOfFontFamilyAtIndex(index: NSUInteger): NSString;
  fontForFontFamilyAtIndex(index: NSUInteger): NSFont;
  filter(filter: NSString | string): void;
  clearFilter(): void;
  startCachingFonts(): void;
  prepareForDealloc(): void;

  documentFontFamilyNames(): NSArray<any>;
  documentData(): MSDocumentData;
}

class MSForeignLayerStyleAllocator<T extends MSForeignLayerStyle> extends _MSForeignLayerStyleAllocator<T> {}
declare class MSForeignLayerStyle extends _MSForeignLayerStyle {
  alloc<T extends MSForeignLayerStyle>(): MSForeignLayerStyleAllocator<T>;
}

class MSForeignObjectAllocator<T extends MSForeignObject> extends _MSForeignObjectAllocator<T> {
  initWithOriginalObject_inLibrary(original: MSModelObject, library: any): T;
}
declare class MSForeignObject extends _MSForeignObject {
  alloc<T extends MSForeignObject>(): MSForeignObjectAllocator<T>;
  isOutOfDateWithLibrary(library: any): boolean;
  syncWithRemote(remote: MSModelObject): void;
  unlinkFromRemote(): MSModelObject;
  masterFromLibrary(library: any): MSModelObject;
  masterFromDocument(doc: MSDocumentData): MSModelObject;
  matchingForeignObjectInDocument(doc: MSDocumentData): MSForeignObject;
  isLocalToDocument(doc: MSDocumentData): boolean;

  localObject(): MSModelObject;
  setLocalObject(localObject: MSModelObject): void;
  remoteShareID(): NSString;
}

class MSModelObjectAllocator<T extends MSModelObject> extends MSModelObjectCommonAllocator<T> {
  initWithImmutableModelObject(immutableBase: MSImmutableModelObject): T;
}
declare class MSModelObject extends MSModelObjectCommon implements IMSModelObject {
  alloc<T extends MSModelObject>(): MSModelObjectAllocator<T>;
  cachedValueForKey(key: any): any;
  cachedValueForKey_setUsingBlock(key: any, block: BCCacheCreateObjectBlock): any;
  updateCachedValue_forKey(value: any, key: any): void;
  clearCachedValueForKey(key: any): void;
  clearCache(): void;
  storeMetadata_forKey(toStore: any, key: NSString | string): void;
  metadataForKey(key: NSString | string): any;
  performInitWithImmutableModelObject(immutableObject: MSImmutableModelObject): void;
  static immutableClass(): any;
  object_didChangeProperty(object: MSModelObject, propertyName: NSString | string): void;
  invalidateModelCacheGeneration(): void;
  invalidateImmutableObject(): void;
  invalidateImmutableObjectAndAncestors(): void;
  setAsParentOnChildren(): void;
  parentGroup(): MSLayerGroup;
  static allowsFaulting(): boolean;
  fireFault(): void;
  fireFaultIfNecessary(): void;
  undoManager(): NSUndoManager;
  setUndoActionName(name: NSString | string): void;
  setUndoActionSenderAndName(name: NSString | string): void;
  isUndoing(): boolean;
  registerUndoNamed_action(name: NSString | string, action: MSUndoActionBlock): void;
  copyPropertiesToObject_options(objectCopy: any, options: MSModelCopyOptions): void;
  syncPropertiesFromObject(object: any): void;

  foreignObject(): MSModelObject;
  isForeign(): boolean;
  UIMetadataKey(): NSString;
  cachedImmutableModelObject(): any;
  setCachedImmutableModelObject(cachedImmutableModelObject: any): void;
  documentData(): MSDocumentData;
  parentObject(): MSModelObject;
  // @ts-ignore
  setParentObject(parentObject: MSModelObject): void;
  immutableModelObject(): any;
  isFault(): boolean;
}

class MSForeignStyleAllocator<T extends MSForeignStyle> extends _MSForeignStyleAllocator<T> {}
declare class MSForeignStyle extends _MSForeignStyle {
  alloc<T extends MSForeignStyle>(): MSForeignStyleAllocator<T>;
}

class MSForeignSymbolAllocator<T extends MSForeignSymbol> extends _MSForeignSymbolAllocator<T> {}
declare class MSForeignSymbol extends _MSForeignSymbol {
  alloc<T extends MSForeignSymbol>(): MSForeignSymbolAllocator<T>;
  static foreignSymbolWithMaster_inLibrary(master: MSSymbolMaster, library: any): MSForeignSymbol;

  remoteSymbolID(): NSString;
}

class MSModelObjectCommonAllocator<T extends MSModelObjectCommon> extends NSObjectAllocator<T> {
  initializeUnsetObjectPropertiesWithDefaults(): T;
  init(): T;
  initWithBlock(block: Block): T;
  initWithMinimalSetup(): T;
}
declare class MSModelObjectCommon extends NSObject implements IMSModelObjectCommon {
  alloc<T extends MSModelObjectCommon>(): MSModelObjectCommonAllocator<T>;
  isContainedByInstanceOfForeignSymbol(ancestors: NSArray<any> | any[]): boolean;
  treeStructure(): NSString;
  simpleTreeStructure(): NSString;
  treeAsDictionary(): any;
  performInitEmptyObject(): void;
  objectDidInit(): void;
  enumerateProperties(enumerator: MSDataPropertyEnumerator): void;
  performMigrationsWithUnarchiver(coder: MSBaseUnarchiver): void;
  hasObjectID(): boolean;
  primitiveObjectID(): NSString;
  static generateObjectID(): any;
  recursivelyGenerateObjectID(): any;
  static defaultName(): NSString;
  enumerateChildProperties(enumerator: MSDataPropertyEnumerator): void;
  enumerateDescendants(enumerator: MSDescendantEnumerator): void;

  objectID(): NSString;
  setObjectID(objectID: NSString | string): void;
  modelObjectCacheGeneration(): MSModelObjectCacheGeneration;
  hasModelObjectCacheGeneration(): boolean;
}

class MSForeignTextStyleAllocator<T extends MSForeignTextStyle> extends _MSForeignTextStyleAllocator<T> {}
declare class MSForeignTextStyle extends _MSForeignTextStyle {
  alloc<T extends MSForeignTextStyle>(): MSForeignTextStyleAllocator<T>;
}

class MSFrequentColorTrackerAllocator<T extends MSFrequentColorTracker> extends NSObjectAllocator<T> {
  initWithColorUse_maximumColorCount_ignoreAlpha(colorUse: MSColorUse, maxCount: NSUInteger, ignoreAlpha: boolean): T;
}
declare class MSFrequentColorTracker extends NSObject {
  alloc<T extends MSFrequentColorTracker>(): MSFrequentColorTrackerAllocator<T>;
  registerColor_fromSource(color: MSImmutableColor, source: any): void;
  registerColors_fromSource(colors: NSArray<any> | any[], source: any): void;
  frequentColors(): NSArray<any>;

  colorUse(): MSColorUse;
  maximumColorCount(): NSUInteger;
  shouldIgnoreAlpha(): boolean;
}

class MSGradientPointArrayAllocator<T extends MSGradientPointArray> extends MSPointArrayAllocator<T> {}
declare class MSGradientPointArray extends MSPointArray {
  alloc<T extends MSGradientPointArray>(): MSGradientPointArrayAllocator<T>;

  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSGradientPointArrayDelegate {
  gradientPointArray_didReplacePointAtIndex_withPoint(array: MSGradientPointArray, i: NSUInteger, aPoint: NSPoint): void;
}

class MSGradientStopAllocator<T extends MSGradientStop> extends _MSGradientStopAllocator<T> {
  initWithPosition_color(pos: CGFloat, aColor: MSColor): T;
}
declare class MSGradientStop extends _MSGradientStop implements IMSColorConvertible {
  alloc<T extends MSGradientStop>(): MSGradientStopAllocator<T>;
  static stopWithPosition_color(pos: CGFloat, aColor: MSColor): any;
  convertColorsUsing(converter: any): void;
  convertColorsUsing(converter: any): void;
}

declare enum MSGradientType {
  MSGradientTypeLinear = 0,
  MSGradientTypeRadial = 1,
  MSGradientTypeAngular = 2,
}

class MSGraphicsContextSettingsAllocator<T extends MSGraphicsContextSettings> extends _MSGraphicsContextSettingsAllocator<T> {}
declare class MSGraphicsContextSettings extends _MSGraphicsContextSettings {
  alloc<T extends MSGraphicsContextSettings>(): MSGraphicsContextSettingsAllocator<T>;
}

class MSImageCollectionAllocator<T extends MSImageCollection> extends _MSImageCollectionAllocator<T> {}
declare class MSImageCollection extends _MSImageCollection {
  alloc<T extends MSImageCollection>(): MSImageCollectionAllocator<T>;
}

declare interface IMSImageOwner {
  setReducedImage(image: MSImageData): void;

  image(): MSImageData;
  setImage(image: MSImageData): void;
  targetSizeForReduction(): NSSize;
  canReduceImageSize(): boolean;
}

class MSImmutableLayerAncestryAllocator<T extends MSImmutableLayerAncestry> extends NSObjectAllocator<T> {
  initWithLayer_document(layer: MSImmutableLayer, doc: MSImmutableDocumentData): T;
  initWithLayer_ancestors_document(layer: MSImmutableLayer, ancestors: NSArray<any> | any[], doc: MSImmutableDocumentData): T;
  initWithMSLayer(layer: MSLayer): T;
}
declare class MSImmutableLayerAncestry extends NSObject {
  alloc<T extends MSImmutableLayerAncestry>(): MSImmutableLayerAncestryAllocator<T>;
  static ancestryWithMSLayer(layer: MSLayer): MSImmutableLayerAncestry;
  absoluteRect(): NSRect;

  layer(): MSImmutableLayer;
  document(): MSImmutableDocumentData;
  page(): MSImmutablePage;
  parentGroup(): MSImmutableLayerGroup;
  artboard(): MSImmutableArtboardGroup;
  ancestors(): NSArray<any>;
  ancestorsAndSelf(): NSArray<any>;
}

class MSJSONArchiveReferenceAllocator<T extends MSJSONArchiveReference> extends NSObjectAllocator<T> {
  initWithReferenceObject(object: NSObject): T;
  initWithJSONDecoder(decoder: BCJSONDecoder): T;
}
declare class MSJSONArchiveReference extends NSObject implements IBCJSONEncoding {
  alloc<T extends MSJSONArchiveReference>(): MSJSONArchiveReferenceAllocator<T>;
  encodeAsJSON(coder: BCJSONEncoder): void;
  replacementObjectForJSONEncoder(coder: BCJSONEncoder): NSObject;
  encodeAsJSON(coder: BCJSONEncoder): void;
  replacementObjectForJSONEncoder(coder: BCJSONEncoder): NSObject;
}

class MSJSONOriginalFileReferenceAllocator<T extends MSJSONOriginalFileReference> extends MSJSONArchiveReferenceAllocator<T> {}
declare class MSJSONOriginalFileReference extends MSJSONArchiveReference {
  alloc<T extends MSJSONOriginalFileReference>(): MSJSONOriginalFileReferenceAllocator<T>;
}

class MSJSONFileReferenceAllocator<T extends MSJSONFileReference> extends MSJSONArchiveReferenceAllocator<T> {}
declare class MSJSONFileReference extends MSJSONArchiveReference {
  alloc<T extends MSJSONFileReference>(): MSJSONFileReferenceAllocator<T>;
}

class MSJSONDataReferenceAllocator<T extends MSJSONDataReference> extends MSJSONArchiveReferenceAllocator<T> {}
declare class MSJSONDataReference extends MSJSONArchiveReference {
  alloc<T extends MSJSONDataReference>(): MSJSONDataReferenceAllocator<T>;
}

class MSJSONOriginalDataReferenceAllocator<T extends MSJSONOriginalDataReference> extends MSJSONDataReferenceAllocator<T> {}
declare class MSJSONOriginalDataReference extends MSJSONDataReference {
  alloc<T extends MSJSONOriginalDataReference>(): MSJSONOriginalDataReferenceAllocator<T>;
}

class MSJSONArchiverAllocator<T extends MSJSONArchiver> extends MSBaseArchiverAllocator<T> {}
declare class MSJSONArchiver extends MSBaseArchiver {
  alloc<T extends MSJSONArchiver>(): MSJSONArchiverAllocator<T>;
  static archiverFromCoder(coder: BCJSONEncoder): MSJSONArchiver;
  static archiveObject_coder(object: NSObject, coder: BCJSONEncoder): void;
  replacementObjectForObject(object: NSObject): NSObject;
}

class MSJSONDataArchiverAllocator<T extends MSJSONDataArchiver> extends MSJSONArchiverAllocator<T> {}
declare class MSJSONDataArchiver extends MSJSONArchiver {
  alloc<T extends MSJSONDataArchiver>(): MSJSONDataArchiverAllocator<T>;
  static archiveStringWithRootObject_error(root: NSObject, error: NSError): NSString;
}

class MSJSONDataUnarchiverAllocator<T extends MSJSONDataUnarchiver> extends MSJSONUnarchiverAllocator<T> {}
declare class MSJSONDataUnarchiver extends MSJSONUnarchiver {
  alloc<T extends MSJSONDataUnarchiver>(): MSJSONDataUnarchiverAllocator<T>;
  static unarchiveObjectWithString_asVersion_corruptionDetected_error(jsonString: NSString | string, version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;
}

class MSJSONDictionaryUnarchiverAllocator<T extends MSJSONDictionaryUnarchiver> extends MSJSONUnarchiverAllocator<T> {}
declare class MSJSONDictionaryUnarchiver extends MSJSONUnarchiver {
  alloc<T extends MSJSONDictionaryUnarchiver>(): MSJSONDictionaryUnarchiverAllocator<T>;
  static unarchiveObjectFromDictionary_asVersion_corruptionDetected_error(dict: NSDictionary<any, any> | {[key: string]: any}, version: MSDocumentVersion, corruption: boolean | null, error: NSError): any;
}

class MSJSONUnarchiverAllocator<T extends MSJSONUnarchiver> extends MSBaseUnarchiverAllocator<T> {}
declare class MSJSONUnarchiver extends MSBaseUnarchiver {
  alloc<T extends MSJSONUnarchiver>(): MSJSONUnarchiverAllocator<T>;
  decodeReferenceObjectOfClass_withIdentifier(className: NSString | string | null, identifier: NSString | string | null): any;
  referenceObjectWithIdentifier(identifier: NSString | string | null): any;
  addReference_withIdentifier(reference: any, identifier: NSString | string): void;
}

class MSJSONZippedArchiverAllocator<T extends MSJSONZippedArchiver> extends MSJSONArchiverAllocator<T> {
  initWithURL(url: NSURL): T;
}
declare class MSJSONZippedArchiver extends MSJSONArchiver {
  alloc<T extends MSJSONZippedArchiver>(): MSJSONZippedArchiverAllocator<T>;
  encodeObject_toSubpath_error(root: NSObject, path: NSString | string, error: NSError): boolean;
  encodeRawData_toSubpath_error(data: NSData, path: NSString | string, error: NSError): boolean;
  finishEncodingError(error: NSError): boolean;
}

declare interface IMSJSONArchiverAlternativeFileReference {
  encodeReferenceInJSONZipArchive(encoder: BCJSONZippedEncoder): void;

  archiveReferenceIdentifier_bc(): NSString;
}

class MSJSONZippedUnarchiverAllocator<T extends MSJSONZippedUnarchiver> extends MSJSONUnarchiverAllocator<T> {
  initWithURL(url: NSURL): T;
}
declare class MSJSONZippedUnarchiver extends MSJSONUnarchiver {
  alloc<T extends MSJSONZippedUnarchiver>(): MSJSONZippedUnarchiverAllocator<T>;
  unarchiveObjectAtSubpath_error(path: NSString | string, error: NSError): any;
  unarchiveRawDataAtSubpath_error(path: NSString | string, error: NSError): NSData;
  containsFileAtSubpath(path: NSString | string): boolean;
}

class MSKeyedArchiverAllocator<T extends MSKeyedArchiver> extends MSBaseArchiverAllocator<T> {}
declare class MSKeyedArchiver extends MSBaseArchiver {
  alloc<T extends MSKeyedArchiver>(): MSKeyedArchiverAllocator<T>;
}

class MSKeyedArchiverHelperAllocator<T extends MSKeyedArchiverHelper> extends NSKeyedArchiverAllocator<T> {}
declare class MSKeyedArchiverHelper extends NSKeyedArchiver {
  alloc<T extends MSKeyedArchiverHelper>(): MSKeyedArchiverHelperAllocator<T>;

  archiver(): MSBaseArchiver;
  setArchiver(archiver: MSBaseArchiver): void;
}

class MSKeyedUnarchiverAllocator<T extends MSKeyedUnarchiver> extends MSBaseUnarchiverAllocator<T> {}
declare class MSKeyedUnarchiver extends MSBaseUnarchiver {
  alloc<T extends MSKeyedUnarchiver>(): MSKeyedUnarchiverAllocator<T>;
  static unarchiveObjectFromURL_error(url: NSURL, error: NSError): any;

  legacyImages(): NSDictionary<any, any>;
  setLegacyImages(legacyImages: NSDictionary<any, any> | {[key: string]: any}): void;
}

class MSStyleFillAllocator<T extends MSStyleFill> extends _MSStyleFillAllocator<T> {}
declare class MSStyleFill extends _MSStyleFill implements IMSImageOwner {
  alloc<T extends MSStyleFill>(): MSStyleFillAllocator<T>;
  CSSAttributeString(): NSString;
  hasOpacity(): boolean;
  setOpacity(opacity: CGFloat): void;
  NSImage(): NSImage;
  setReducedImage(image: MSImageData): void;
  setReducedImage(image: MSImageData): void;

  interfaceOpacity(): CGFloat;
  setInterfaceOpacity(interfaceOpacity: CGFloat): void;
  image(): MSImageData;
  setImage(image: MSImageData): void;
  targetSizeForReduction(): NSSize;
  canReduceImageSize(): boolean;
}

class MSStyleBorderAllocator<T extends MSStyleBorder> extends _MSStyleBorderAllocator<T> {}
declare class MSStyleBorder extends _MSStyleBorder implements IMSColorConvertible {
  alloc<T extends MSStyleBorder>(): MSStyleBorderAllocator<T>;
  CSSAttributeString(): NSString;
  supportsAdvancedBorderSettings(): boolean;
  convertColorsUsing(converter: any): void;
  convertColorsUsing(converter: any): void;
}

class MSStyleShadowAllocator<T extends MSStyleShadow> extends _MSStyleShadowAllocator<T> {}
declare class MSStyleShadow extends _MSStyleShadow implements IMSColorConvertible {
  alloc<T extends MSStyleShadow>(): MSStyleShadowAllocator<T>;
  CSSAttributeString(): NSString;
  convertColorsUsing(converter: any): void;
  convertColorsUsing(converter: any): void;
}

class MSStyleInnerShadowAllocator<T extends MSStyleInnerShadow> extends _MSStyleInnerShadowAllocator<T> {}
declare class MSStyleInnerShadow extends _MSStyleInnerShadow {
  alloc<T extends MSStyleInnerShadow>(): MSStyleInnerShadowAllocator<T>;
}

class MSHitTestResultAllocator<T extends MSHitTestResult> extends NSObjectAllocator<T> {}
declare class MSHitTestResult extends NSObject {
  alloc<T extends MSHitTestResult>(): MSHitTestResultAllocator<T>;

  layer(): MSLayer;
  overrideRepresentation(): MSOverrideRepresentation;
}

class MSSymbolInstanceAllocator<T extends MSSymbolInstance> extends _MSSymbolInstanceAllocator<T> {}
declare class MSSymbolInstance extends _MSSymbolInstance {
  alloc<T extends MSSymbolInstance>(): MSSymbolInstanceAllocator<T>;
  symbolMaster(): MSSymbolMaster;
  isInstanceForMaster(symbolMaster: MSSymbolMaster): boolean;
  changeInstanceToSymbol(symbol: MSSymbolMaster): void;
  numberOfVisibleCells(): NSUInteger;
  detachByReplacingWithGroup(): MSLayerGroup;
  resizeInstanceToFitSymbol(symbol: MSSymbolMaster): void;
  resetSizeToMaster(): void;
  setValue_forOverridePoint(value: any | null, point: MSOverridePoint): void;
  updateOverridesWithObjectIDMap(idMap: NSDictionary<any, any> | {[key: string]: any}): void;
  invalidateIfAffectedBySymbolMastersIn(modifiedSymbols: NSSet<any>): boolean;
  removeShareableObjectsFromOverrides(removed: NSSet<any>): void;

  overridePoints(): NSArray<any>;
  availableOverrides(): NSArray<any>;
  overrides(): NSDictionary<any, any>;
  setOverrides(overrides: NSDictionary<any, any> | {[key: string]: any}): void;
  masterRefreshCounter(): NSInteger;
  setMasterRefreshCounter(masterRefreshCounter: NSInteger): void;
  overrideContainer(): MSOverrideRepresentationContainer;
  influencingSymbolIDs(): NSSet<any>;
}

declare interface IMSLayerChangeObserver {
  layerDidChange(layer: MSLayer): void;
}

declare type MSLayerAbsolutePosition = NSPoint

declare enum MSAlignmentRectOptions {
  MSAlignmentRectTextBaselineAndCapHeight = 1 << 0,
  MSAlignmentRectTextXHeight = 2 << 0,
}

declare enum MSLayerRenameOptions {
  MSLayerRenameNumbersOnly = 0,
  MSLayerRenameIncludeCopy = 1,
}

declare enum MSLayerSelectionOptions {
  MSLayerSelectionClickThroughAllGroups = 1 << 1,
  MSLayerSelectionIgnoreSlices = 1 << 2,
  MSLayerSelectionIgnoreHotspots = 1 << 3,
  MSLayerSelectionSlicesAsOutlines = 1 << 4,
  MSLayerSelectionHotspotsAsOutlines = 1 <<5,
  MSLayerSelectionPreferSecondMatch = 1 << 6,
  MSLayerSelectionFullyContained = 1 << 7,
  MSLayerSelectionAllArtboards = 1 << 8,
}

class MSLayerBuilderAllocator<T extends MSLayerBuilder> extends NSObjectAllocator<T> {}
declare class MSLayerBuilder extends NSObject {
  alloc<T extends MSLayerBuilder>(): MSLayerBuilderAllocator<T>;
  static layerTreeWithDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): any;
  static layerTreeWithJSON_relativeToURL_error(json: NSString | string, url: NSURL, error: NSError): any;
  static layerTreeWithContentsOfURL_error(url: NSURL, error: NSError): any;
}

declare interface IMSLayerContainment {
  containedLayers(): NSArray<any>;
  containedLayersCount(): NSUInteger;
  firstLayer(): any;
  lastLayer(): any;
  containsNoOrOneLayers(): boolean;
  containsLayers(): boolean;
  containsOneLayer(): boolean;
  containsMultipleLayers(): boolean;
  layerAtIndex(i: NSUInteger): any;
  indexOfLayer(aLayer: any): NSUInteger;
  enumerateLayers(block: MSLayerSimpleEnumeratorBlock): void;
  enumerateLayersWithOptions_block(options: MSLayerEnumeratorOptions, block: MSLayerEnumeratorBlock): boolean;
}

declare type MSLayerEnumeratorOptions = NSUInteger

declare enum MSLayerEnumeratorFlags {
  MSLEDefault = 0,
  MSLEIncludeSelf = 1<<0,
  MSLEBackwards = 1<<1,
  MSLERecursive = 1<<2,
  MSLESkipHidden = 1<<3,
  MSLEMutates = 1<<4,
  MSLETraitsMatchOr = 1<<5,
  MSLEAllOptions,
}

declare interface IMSLayerCoordinateSpace {
  convertPoint_toCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertPoint_fromCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertRect_toCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertRect_fromCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertVector_toCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  convertVector_fromCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  transformForConvertingToCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  transformForConvertingFromCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;

  bounds(): CGRect;
  parentCoordinateSpace(): any;
  transformForConvertingToParentCoordinateSpace(): CGAffineTransform;
  transformForConvertingFromParentCoordinateSpace(): CGAffineTransform;
}

class MSLayerEnumeratorAllocator<ObjectType, T extends MSLayerEnumerator<ObjectType>> extends NSEnumeratorAllocator<ObjectType, T> {}
declare class MSLayerEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
  alloc<T extends MSLayerEnumerator<ObjectType>>(): MSLayerEnumeratorAllocator<ObjectType, T>;
  skipDescendants(): void;
}

declare interface IMSLayerGroup {

  layers(): NSArray<any>;
}

declare enum MSLayerGroupResizeOption {
  MSLayerGroupResizeOptionLayerOnly = 0,
  MSLayerGroupResizeOptionResizeParentUponRectChange = 1 << 0,
}

declare enum MSLayerListStatus {
  MSLayerListStatusUndecided = 0,
  MSLayerListStatusCollapsed = 1,
  MSLayerListStatusExpanded = 2,
}

class MSLayerMovementAllocator<T extends MSLayerMovement> extends NSObjectAllocator<T> {}
declare class MSLayerMovement extends NSObject {
  alloc<T extends MSLayerMovement>(): MSLayerMovementAllocator<T>;
  static moveForward(layers: NSArray<any> | any[]): void;
  static moveBackward(layers: NSArray<any> | any[]): void;
  static canMoveLayerUpHierarchy(layer: MSLayer): boolean;
  static moveUpHierarchy(layers: NSArray<any> | any[]): void;
  static canMoveLayerToTopOfHierarchy(layer: MSLayer): boolean;
  static moveToTopOfHierarchy(layers: NSArray<any> | any[]): void;
  static canMoveLayersForward(layers: NSArray<any> | any[]): boolean;
  static canMoveLayersBackward(layers: NSArray<any> | any[]): boolean;
  static moveToFront(layers: NSArray<any> | any[]): void;
  static moveToBack(layers: NSArray<any> | any[]): void;
}

class MSLayerPasterAllocator<T extends MSLayerPaster> extends NSObjectAllocator<T> {}
declare class MSLayerPaster extends NSObject {
  alloc<T extends MSLayerPaster>(): MSLayerPasterAllocator<T>;
  static insertPasteboardData_onPage_withHint_viewPort(pboardData: MSPasteboardLayers, page: MSPage, destinationHint: MSLayer | null, viewport: MSPastingViewport): MSPastingViewport;
  static insertPasteboardData_intoParent_atPosition_afterLayer_viewport_fitToParent(pboardData: MSPasteboardLayers, parent: MSLayerGroup, position: NSPoint, afterLayer: any, viewport: MSPastingViewport, fitToParent: boolean): MSLayerArray;
  static insertPasteboardData_intoParent_beforeLayer(pboardData: MSPasteboardLayers, parent: MSLayerGroup, beforeLayer: any): MSLayerArray;
  static insertPagePasteboardData_intoDocument_afterPage(pboardData: MSPasteboardLayers, document: MSDocumentData, afterPage: MSPage): MSLayerArray;
  static parentForData_hint_page_viewPort(pboardData: MSPasteboardLayers, hint: MSLayer | null, page: MSPage, viewport: MSPastingViewport): MSLayerGroup;
  static parentForData_hint_page(pboardData: MSPasteboardLayers, hint: MSLayer | null, page: MSPage): MSLayerGroup;
  static duplicateLayers(layers: MSPasteboardLayers): MSPasteboardLayers;
}

declare enum MSLayerResizingType {
  MSLayerResizingStretch = 0,
  MSLayerResizingPinToEdge = 1,
  MSLayerResizingResize = 2,
  MSLayerResizingFloat = 3,
}

declare interface IMSLayerTraits {
  traits(): MSTraits;
}

declare enum MSTraits {
  MSTraitStyled = 1<<8,
  MSTraitText = 1<<9,
  MSTraitImage = 1<<10,
  MSTraitSlice = 1<<11,
  MSTraitGroup = 1<<12,
  MSTraitArtboard = 1<<13,
  MSTraitShape = 1<<14,
  MSTraitPage = 1<<15,
  MSTraitContainer = 1<<16,
  MSTraitRoot = 1<<17,
  MSTraitPath = 1<<18,
  MSTraitSymbolInstance = 1<<19,
  MSTraitSymbolMaster = 1<<20,
  MSTraitHotspot = 1<<21,
  MSTraitExportable = 1<<22,
  MSTraitShapeOrPath = 1<<23,
  MSTraitAllTraits,
}

declare interface IMSLayerWithBackgroundColor {
  immutableBackgroundColor(): MSImmutableColor;

  hasBackgroundColor(): boolean;
  setHasBackgroundColor(hasBackgroundColor: boolean): void;
}

declare interface IMSLayerWithMutableBackgroundColor {

  backgroundColor(): MSColor;
  setBackgroundColor(backgroundColor: MSColor): void;
}

declare enum MSLayoutGridStyle {
  MSLayoutGridStyleFill,
  MSLayoutGridStyleBorder,
}

class MSLegacyDocumentReaderAllocator<T extends MSLegacyDocumentReader> extends MSDocumentReaderAllocator<T> {
  initWithFileURL(url: NSURL | null): T;
}
declare class MSLegacyDocumentReader extends MSDocumentReader {
  alloc<T extends MSLegacyDocumentReader>(): MSLegacyDocumentReaderAllocator<T>;
}

declare interface IMSLibraryObject {

  name(): NSString;
  libraryID(): NSString;
  document(): MSDocumentData;
}

declare type MSLine = {
  A: CGFloat
  B: CGFloat
  C: CGFloat
}

declare type MSLineSegment = {
  p0: CGPoint
  p1: CGPoint
}

declare enum MSMarkerType {
  MSMarkerTypeNone = 0,
  MSMarkerTypeOpenArrow = 1,
  MSMarkerTypeFilledArrow = 2,
  MSMarkerTypeLine = 3,
  MSMarkerTypeOpenCircle = 4,
  MSMarkerTypeFilledCircle = 5,
  MSMarkerTypeOpenSquare = 6,
  MSMarkerTypeFilledSquare = 7,
  MSMarkerTypeFilledArrowRounded,
  MSMarkerTypeFilledSquareRounded,
}

declare enum MSSharedStyleType {
  MSSharedStyleTypeLayerStyles = 1,
  MSSharedStyleTypeTextStyles,
  MSSharedStyleTypeUnknown,
}

declare interface IMSModelObject {
}

declare enum MSModelCopyOptions {
  MSModelCopyNormal = 0x0000,
  MSModelPreserveIDs = 0x0001,
}

class MSModelObjectCacheGenerationAllocator<T extends MSModelObjectCacheGeneration> extends NSObjectAllocator<T> {}
declare class MSModelObjectCacheGeneration extends NSObject {
  alloc<T extends MSModelObjectCacheGeneration>(): MSModelObjectCacheGenerationAllocator<T>;
}

declare interface IMSModelObjectCommon {

  objectID(): NSString;
}

declare enum MSRootObjectMessage {
  MSRootObjectMessageRulersChangedUsingUndo,
}

class MSModelResourcesAllocator<T extends MSModelResources> extends BCSingletonAllocator<T> {}
declare class MSModelResources extends BCSingleton {
  alloc<T extends MSModelResources>(): MSModelResourcesAllocator<T>;
  preloadResources(): void;
  URLForImageResource(resource: NSString | string): NSURL;
  URLForResource_withExtension(name: NSString | string, ext: NSString | string): NSURL;
  resourcesNeedingMigration(): NSArray<any>;

  bundle(): NSBundle;
  setBundle(bundle: NSBundle): void;
  noiseImages(): NSArray<any>;
  setNoiseImages(noiseImages: NSArray<any> | any[]): void;
  errorPattern(): NSBitmapImageRep;
}

class MSOvalShapeAllocator<T extends MSOvalShape> extends _MSOvalShapeAllocator<T> {}
declare class MSOvalShape extends _MSOvalShape {
  alloc<T extends MSOvalShape>(): MSOvalShapeAllocator<T>;
}

class MSOverrideMappingAllocator<T extends MSOverrideMapping> extends NSObjectAllocator<T> {}
declare class MSOverrideMapping extends NSObject {
  alloc<T extends MSOverrideMapping>(): MSOverrideMappingAllocator<T>;
  static overrideMappingFor_withOldOverrides(overridePoint: MSOverridePoint, oldOverridePoints: NSArray<any> | any[]): MSOverrideMapping;
  static consolidateAndFindNextMappingFrom(mappings: NSMutableArray<any> | any[]): MSOverrideMapping;
  removeOverridePoint(overridePoint: MSOverridePoint): void;

  score(): NSInteger;
  overridePoint(): MSOverridePoint;
  oldOverridePoint(): MSOverridePoint;
}

class MSOverridePointAllocator<T extends MSOverridePoint> extends NSObjectAllocator<T> {
  initWithLayer_property_parent(layer: MSImmutableLayer, property: NSString | string, parent: MSOverridePoint | null): T;
}
declare class MSOverridePoint extends NSObject {
  alloc<T extends MSOverridePoint>(): MSOverridePointAllocator<T>;
  comparisonScoreAgainst(point: MSOverridePoint): NSInteger;
  distanceToOverridePoint(point: MSOverridePoint): NSUInteger;

  layerID(): NSString;
  property(): NSString;
  name(): NSString;
  path(): NSString;
  isSymbolOverride(): boolean;
  isStyleOverride(): boolean;
}

class MSOverrideValueAllocator<T extends MSOverrideValue> extends _MSOverrideValueAllocator<T> {
  initWithName_value(name: NSString | string, value: NSObject): T;
}
declare class MSOverrideValue extends _MSOverrideValue {
  alloc<T extends MSOverrideValue>(): MSOverrideValueAllocator<T>;
  addPredecessor(predecessor: MSOverrideValue): void;

  isInherited(): boolean;
  setIsInherited(isInherited: boolean): void;
  predecessor(): MSOverrideValue;
  attributeName(): NSString;
}

class MSPasteboardLayersAllocator<T extends MSPasteboardLayers> extends NSObjectAllocator<T> {}
declare class MSPasteboardLayers extends NSObject implements IMSLayerTraits {
  alloc<T extends MSPasteboardLayers>(): MSPasteboardLayersAllocator<T>;
  static pasteboardLayersWithLayers(layers: NSArray<any> | any[]): MSPasteboardLayers;
  static pasteboardLayersWithForeignLayers(layers: NSArray<any> | any[]): MSPasteboardLayers;
  insertOnPage_viewport_hint(page: MSPage, viewport: MSPastingViewport, destinationHint: MSLayer | null): MSPastingViewport;
  insertInGroup_atPosition_afterLayer_viewport_fitToParent(group: MSLayerGroup, position: NSPoint, afterLayer: any, viewport: MSPastingViewport | null, fitToParent: boolean): MSLayerArray;
  traits(): MSTraits;
  canBeContainedInLayer(layer: MSLayer): boolean;
  unionSize(): NSSize;
  layerPositionsRelativeToUnion(): NSArray<any>;
  suggestedRect(): NSRect;
  traits(): MSTraits;
  traits(): MSTraits;

  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  sharedStyles(): NSArray<any>;
  setSharedStyles(sharedStyles: NSArray<any> | any[]): void;
  localSymbols(): NSDictionary<any, any>;
  setLocalSymbols(localSymbols: NSDictionary<any, any> | {[key: string]: any}): void;
  foreignSymbols(): NSDictionary<any, any>;
  setForeignSymbols(foreignSymbols: NSDictionary<any, any> | {[key: string]: any}): void;
  suggestedPosition(): NSPoint;
  setSuggestedPosition(suggestedPosition: NSPoint): void;
  parentTraits(): MSTraits;
  setParentTraits(parentTraits: MSTraits): void;
}

class MSPasteboardLayersBaseAllocator<T extends MSPasteboardLayersBase> extends NSObjectAllocator<T> {}
declare class MSPasteboardLayersBase extends NSObject {
  alloc<T extends MSPasteboardLayersBase>(): MSPasteboardLayersBaseAllocator<T>;
  static dictionaryFromPasteboardLayers(pasteboardLayers: MSPasteboardLayers): NSDictionary<any, any>;
  static dataFromPasteboardDictionary(dict: NSDictionary<any, any> | {[key: string]: any}): NSData;
  static pasteboardDataFromData(data: NSData | null): MSPasteboardLayers;
}

declare enum MSPasteboardVersion {
  MSPasteboardVersionUnknown = 0,
  MSPasteboardVersion34 = 1,
  MSPasteboardVersion34WithSeparateLayersArchiving = 2,
  MSPasteboardVersion36 = 3,
  MSPasteboardUsingJSON = 4,
  MSPasteboardForeignObjects = 5,
  MSPasteboardArchiveObjectIDs = 6,
  MSPasteboardForeignStyles = 7,
  MSPasteboardNextVersion,
  MSPasteboardCurrentVersion,
}

class MSPasteboardLayersReaderWriterAllocator<T extends MSPasteboardLayersReaderWriter> extends NSObjectAllocator<T> {}
declare class MSPasteboardLayersReaderWriter extends NSObject implements IMSPasteboardReader, IMSPasteboardWriter {
  alloc<T extends MSPasteboardLayersReaderWriter>(): MSPasteboardLayersReaderWriterAllocator<T>;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
  canWriteDataToPasteboard(pasteboard: NSPasteboard): boolean;
  supportedPasteboardTypes(): NSArray<any>;
  writeData_toPasteboard(data: MSPasteboardLayers, pasteboard: NSPasteboard): void;
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
  canWriteDataToPasteboard(pasteboard: NSPasteboard): boolean;
  supportedPasteboardTypes(): NSArray<any>;
  writeData_toPasteboard(data: MSPasteboardLayers, pasteboard: NSPasteboard): void;
}

class MSPasteboardLayerListReaderWriterAllocator<T extends MSPasteboardLayerListReaderWriter> extends MSPasteboardLayersReaderWriterAllocator<T> {}
declare class MSPasteboardLayerListReaderWriter extends MSPasteboardLayersReaderWriter {
  alloc<T extends MSPasteboardLayerListReaderWriter>(): MSPasteboardLayerListReaderWriterAllocator<T>;
}

class MSPasteboardPageListReaderWriterAllocator<T extends MSPasteboardPageListReaderWriter> extends MSPasteboardLayersReaderWriterAllocator<T> {}
declare class MSPasteboardPageListReaderWriter extends MSPasteboardLayersReaderWriter {
  alloc<T extends MSPasteboardPageListReaderWriter>(): MSPasteboardPageListReaderWriterAllocator<T>;
}

class MSPasteboardManagerAllocator<T extends MSPasteboardManager> extends NSObjectAllocator<T> {}
declare class MSPasteboardManager extends NSObject {
  alloc<T extends MSPasteboardManager>(): MSPasteboardManagerAllocator<T>;
  static readPasteboardLayersFromPasteboard_colorSpace_options(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions): MSPasteboardLayers;
  static readPasteboardLayersFromDrag_colorSpace(dragInfo: any, colorSpace: NSColorSpace): MSPasteboardLayers;
  static writePasteboardLayers_toPasteboard(layers: MSPasteboardLayers, pasteboard: NSPasteboard): void;
  static registerReader(reader: any): void;
  static registerWriter(writer: any): void;
  static registerViewForSupportedDraggedTypes(view: NSView): void;
  registerDefaultReadersAndWriters(): void;
}

declare interface IMSPasteboardReader {
  supportedPasteboardTypes(): NSArray<any>;
  pasteboardDataFromPasteboard_colorSpace_options_sender(pasteboard: NSPasteboard, colorSpace: NSColorSpace, options: MSPasteboardReaderOptions, sender: any | null): MSPasteboardLayers;
}

declare enum MSPasteboardReaderOptions {
  MSPasteboardReaderOptionsNone = 0,
  MSPasteboardReaderOptionsStripTextStyle = 1<<0,
  MSPasteboardReaderOptionsDefault,
}

declare interface IMSPasteboardWriter {
  canWriteDataToPasteboard(pasteboard: NSPasteboard): boolean;
  supportedPasteboardTypes(): NSArray<any>;
  writeData_toPasteboard(data: MSPasteboardLayers, pasteboard: NSPasteboard): void;
}

class MSPastingViewportAllocator<T extends MSPastingViewport> extends NSObjectAllocator<T> {}
declare class MSPastingViewport extends NSObject {
  alloc<T extends MSPastingViewport>(): MSPastingViewportAllocator<T>;
  static viewportWithVisibleRect_zoom(visibleRect: NSRect, zoom: CGFloat): MSPastingViewport;
  viewportContainingLayers(layers: MSLayerArray): MSPastingViewport;

  zoomValue(): CGFloat;
  visibleRect(): NSRect;
}

class MSPathAllocator<T extends MSPath> extends NSObjectAllocator<T> {
  initWithCGPath(pathRef: CGPathRef): T;
  initWithContours(contours: NSArray<any> | any[]): T;
  initWithRect(rect: CGRect): T;
  initWithRoundedRect_radius(rect: CGRect, radius: CGFloat): T;
  initWithSquircleInRect_radius(rect: CGRect, radius: CGFloat): T;
  initWithEllipseInRect(rect: CGRect): T;
  initWithLineFrom_to(point1: CGPoint, point2: CGPoint): T;
  initWithCurveFromPoint_to_controlPoint1_controlPoint2(point: CGPoint, to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): T;
  initWithPoints_pointCount_close(points: CGPoint, pointCount: number, close: boolean): T;
  initWithBezierPath(bezierPath: NSBezierPath): T;
}
declare class MSPath extends NSObject implements INSCopying {
  alloc<T extends MSPath>(): MSPathAllocator<T>;
  booleanOp_withPath(op: MSBooleanOperation, otherPath: MSPath): MSPath;
  booleanUnionWith(otherPath: MSPath): MSPath;
  booleanIntersectWith(otherPath: MSPath): MSPath;
  booleanSubtractWith(otherPath: MSPath): MSPath;
  booleanExclusiveOrWith(otherPath: MSPath): MSPath;
  shadowPathForStrokeType_lineWidth(strokeType: MSShadowBorderType, lineWidth: CGFloat): MSPath;
  shadowPathWithSpread(spread: CGFloat): MSPath;
  shadowPathWithSpread_borderOptions_strokeType_lineWidth(spread: CGFloat, borderOptions: MSImmutableStyleBorderOptions, strokeType: MSShadowBorderType, lineWidth: CGFloat): MSPath;
  copyWithZone(zone: NSZone): MSPath;
  static pathWithSubpaths(subpaths: NSArray<any> | any[]): MSPath;
  static pathWithContours(contours: NSArray<any> | any[]): MSPath;
  static pathWithRect(rect: CGRect): MSPath;
  static pathWithEllipseInRect(rect: CGRect): MSPath;
  static pathWithCGPath(pathRef: CGPathRef): MSPath;
  static pathWithBezierPath(bezierPath: NSBezierPath): MSPath;
  static pathWithLineFrom_to(point1: CGPoint, point2: CGPoint): MSPath;
  static pathWithCurveFromPoint_to_controlPoint1_controlPoint2(point: CGPoint, to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): MSPath;
  static pathWithPoints_pointCount_close(points: CGPoint, pointCount: number, close: boolean): MSPath;
  transformedPathUsingAffineTransform(transform: CGAffineTransform): MSPath;
  transformedPathUsingMapBlock(map: Block): MSPath;
  pathWithInset(inset: CGFloat): MSPath;
  pathWithInset_joinStrategy(inset: CGFloat, strategy: MSBezierJoinStrategy): MSPath;
  outlinePathWithWidth(width: CGFloat): MSPath;
  outlinePathWithWidth_lineCap_lineJoin(width: CGFloat, lineCap: CGLineCap, lineJoin: CGLineJoin): MSPath;
  pathByRemovingSubsequentMoveToComponents(): MSPath;
  pathByCuttingBeforeIndex(index: NSUInteger): MSPath;
  pathByScalingToBounds(bounds: CGRect): MSPath;
  reversedPath(): MSPath;
  pathByJoiningWithPath(path: MSPath): MSPath;
  pointAtIndex(index: NSUInteger): CGPoint;
  pointOnPathAtLength(length: CGFloat): CGPoint;
  length(): CGFloat;
  startPoint(): CGPoint;
  endPoint(): CGPoint;
  bezierIndexForPoint_tolerance(point: CGPoint, tolerance: CGFloat): NSUInteger;
  containsPoint(point: CGPoint): boolean;
  isClosed(): boolean;
  pointsInRect(rect: NSRect): NSArray<any>;
  elementAtIndex(index: NSUInteger): MSCGPathElement;
  isEqualToPath(path: MSPath): boolean;
  isEqualToPath_epsilon(path: MSPath, epsilon: CGFloat): boolean;
  clipContext_windingRule_inBlock(context: CGContextRef, windingRule: NSWindingRule, block: Block): void;
  addClipForWindingRule_context(windingRule: NSWindingRule, context: CGContextRef): void;
  pathWithDashPattern(dashPattern: NSArray<any> | any[]): MSPath;
  outerPathWithRect(rect: CGRect): MSPath;
  pathWithOuterPathOfSize(amount: CGFloat): MSPath;
  insetPathBy(inset: CGFloat): MSPath;
  insetPathBy_borderOptions(size: CGFloat, options: MSImmutableStyleBorderOptions): MSPath;
  pathByGrowingBy(offset: CGFloat): MSPath;
  outlinePathWithLineWidth_borderOptions(lineWidth: CGFloat, borderOptions: MSImmutableStyleBorderOptions): MSPath;
  shadowPathForStrokeType_lineWidth_cacheObject_context(strokeType: MSShadowBorderType, lineWidth: CGFloat, cacheObject: MSModelObjectCommon, context: MSRenderingContext): MSPath;
  shadowPathWithSpread_cacheObject_context(spread: CGFloat, cacheObject: MSModelObjectCommon, context: MSRenderingContext): MSPath;
  shadowPathWithSpread_borderOptions_strokeType_lineWidth_cacheObject_context(spread: CGFloat, borderOptions: MSImmutableStyleBorderOptions, strokeType: MSShadowBorderType, lineWidth: CGFloat, cacheObject: MSModelObjectCommon, context: MSRenderingContext): MSPath;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  CGPath(): CGPathRef;
  isEmpty(): boolean;
  elementCount(): NSUInteger;
  contours(): NSArray<any>;
  isRectangular(): boolean;
  bounds(): CGRect;
  controlPointBounds(): CGRect;
  safeBounds(): CGRect;
  subpaths(): NSArray<any>;
}

declare type MSCGPathElement = {
  type: CGPathElementType
  controlPoints: [CGPoint, CGPoint]
  toPoint: CGPoint
}

declare interface IMSPathLayer {
  simplify(): void;
  reversePath(): void;

  isClosed(): boolean;
  setIsClosed(isClosed: boolean): void;
  edited(): boolean;
  setEdited(edited: boolean): void;
  pathInFrame(): MSPath;
  setPathInFrame(pathInFrame: MSPath): void;
}

declare interface IMSImmutablePathLayer {

  decoratedPathInBounds(): MSPath;
  hasMarkers(): boolean;
  style(): MSImmutableStyle;
}

declare enum MSPatternFillType {
  MSPatternFillTypeTile = 0,
  MSPatternFillTypeFill = 1,
  MSPatternFillTypeStretch = 2,
  MSPatternFillTypeFit = 3,
}

class MSPersistentAssetCollectionAllocator<T extends MSPersistentAssetCollection> extends MSAssetCollectionAllocator<T> {}
declare class MSPersistentAssetCollection extends MSAssetCollection {
  alloc<T extends MSPersistentAssetCollection>(): MSPersistentAssetCollectionAllocator<T>;
  static assetCollectionWithName(name: NSString | string): MSPersistentAssetCollection;
  save(): void;
  resourceNeedingMigration(): NSArray<any>;
  cleanupAfterTesting(): void;
  static assetCollectionByMigratingPresetsFromSources(sources: MSAssetMigrationSources): MSPersistentAssetCollection;
  static defaultMigrationSources(): MSAssetMigrationSources;
  static defaultExportPresets(): NSArray<any>;
}

class MSAssetMigrationSourcesAllocator<T extends MSAssetMigrationSources> extends NSObjectAllocator<T> {}
declare class MSAssetMigrationSources extends NSObject {
  alloc<T extends MSAssetMigrationSources>(): MSAssetMigrationSourcesAllocator<T>;

  imageURL(): NSURL;
  setImageURL(imageURL: NSURL): void;
}

class MSPointArrayAllocator<T extends MSPointArray> extends NSObjectAllocator<T> {}
declare class MSPointArray extends NSObject implements INSCopying {
  alloc<T extends MSPointArray>(): MSPointArrayAllocator<T>;
  addPoint(aPoint: NSPoint): void;
  insertPoint_atIndex(aPoint: NSPoint, i: NSUInteger): void;
  pointAtIndex(i: NSUInteger): NSPoint;
  removePointAtIndex(i: NSUInteger): void;
  countOfPoints(): NSUInteger;
  replacePointAtIndex_withPoint(i: NSUInteger, aPoint: NSPoint): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;
}

declare enum MSPointRadiusBehaviour {
  MSPointRadiusBehaviourV0 = 0,
  MSPointRadiusBehaviourV1 = 1,
  MSPointRadiusBehaviourV1Smooth = 2,
  MSPointRadiusBehaviourDisabled = -1,
  MSPointRadiusBehaviourLegacy,
  MSPointRadiusBehaviourCurrent,
}

class MSPolygonShapeAllocator<T extends MSPolygonShape> extends _MSPolygonShapeAllocator<T> {}
declare class MSPolygonShape extends _MSPolygonShape {
  alloc<T extends MSPolygonShape>(): MSPolygonShapeAllocator<T>;
}

class MSRectAllocator<T extends MSRect> extends _MSRectAllocator<T> {
  initWithX_y_width_height(x: CGFloat, y: CGFloat, w: CGFloat, h: CGFloat): T;
  initWithRect(rect: NSRect): T;
}
declare class MSRect extends _MSRect implements IMSRect {
  alloc<T extends MSRect>(): MSRectAllocator<T>;
  static rectWithX_y_width_height(x: CGFloat, y: CGFloat, w: CGFloat, h: CGFloat): any;
  static rectWithRect(rect: NSRect): any;
  static rectWithUnionOfRects(rects: NSArray<any> | any[]): any;
  calculateProportions(): void;
  performUpdatesWithUnconstrainedProportions(block: Block): void;
  setRectByIgnoringProportions(newRect: NSRect): void;
  shouldConstrainProportions(): boolean;
  containsPoint(p: NSPoint): boolean;
  isIntegral(): boolean;
  makeOriginIntegral(): void;
  makeRectIntegral(): void;
  log(): void;

  rect(): NSRect;
  setRect(rect: NSRect): void;
  size(): NSSize;
  setSize(size: NSSize): void;
  origin(): NSPoint;
  setOrigin(origin: NSPoint): void;
  mid(): NSPoint;
  setMid(mid: NSPoint): void;
  primitiveConstrainProportions(): boolean;
  setPrimitiveConstrainProportions(primitiveConstrainProportions: boolean): void;
  proportions(): CGFloat;
  setProportions(proportions: CGFloat): void;
}

declare interface IMSRect {

  rect(): NSRect;
  size(): NSSize;
  origin(): NSPoint;
}

declare interface IMSRectDelegate {
  rect_didChangeFromRect(rect: MSRect, oldRect: NSRect): void;
}

declare interface IMSRootLayer {

  grid(): MSSimpleGrid;
  setGrid(grid: MSSimpleGrid): void;
  layout(): MSLayoutGrid;
  setLayout(layout: MSLayoutGrid): void;
  rulerBase(): NSPoint;
  setRulerBase(rulerBase: NSPoint): void;
  contentBounds(): NSRect;
  rect(): CGRect;
}

declare interface IMSImmutableRootLayer {
  contentBoundsForDocument(doc: MSImmutableDocumentData): NSRect;

  grid(): MSImmutableSimpleGrid;
  layout(): MSImmutableLayoutGrid;
}

class MSRulerCoordinateSpaceAllocator<T extends MSRulerCoordinateSpace> extends NSObjectAllocator<T> {
  initWithLayer(layer: MSLayer): T;
}
declare class MSRulerCoordinateSpace extends NSObject implements IMSLayerCoordinateSpace {
  alloc<T extends MSRulerCoordinateSpace>(): MSRulerCoordinateSpaceAllocator<T>;
  convertPoint_toCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertPoint_fromCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertRect_toCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertRect_fromCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertVector_toCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  convertVector_fromCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  transformForConvertingToCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  transformForConvertingFromCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  convertPoint_toCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertPoint_fromCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertRect_toCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertRect_fromCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertVector_toCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  convertVector_fromCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  transformForConvertingToCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  transformForConvertingFromCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;

  layer(): MSLayer;
  bounds(): CGRect;
  parentCoordinateSpace(): any;
  transformForConvertingToParentCoordinateSpace(): CGAffineTransform;
  transformForConvertingFromParentCoordinateSpace(): CGAffineTransform;
}

class MSRulerDataAllocator<T extends MSRulerData> extends _MSRulerDataAllocator<T> {}
declare class MSRulerData extends _MSRulerData {
  alloc<T extends MSRulerData>(): MSRulerDataAllocator<T>;
  addGuide(): void;
  addGuideWithValue(value: CGFloat): void;
  addGuide(guide: NSNumber | number): void;
  removeGuideAtIndex(index: NSUInteger): void;
  removeGuide(guide: NSNumber | number): void;
  removeAllGuides(): void;
  numberOfGuides(): NSUInteger;
  guideAtIndex(index: NSUInteger): CGFloat;
  setValue_forGuideAtIndex(value: CGFloat, index: NSUInteger): void;
}

declare interface IMSShapeGroup {

  hasMarkers(): boolean;
  isPartOfClippingMask(): boolean;
}

declare enum MSClippingMaskMode {
  MSClippingMaskOutline,
  MSClippingMaskAlpha,
}

class MSShapePathAllocator<T extends MSShapePath> extends _MSShapePathAllocator<T> {}
declare class MSShapePath extends _MSShapePath {
  alloc<T extends MSShapePath>(): MSShapePathAllocator<T>;
}

class MSSharedObjectAllocator<T extends MSSharedObject> extends _MSSharedObjectAllocator<T> {
  initWithName_firstInstance(name: NSString | string, firstInstance: MSSharedObjectInstance): T;
  initWithName_sharedObjectID_value(name: NSString | string, sharedObjectID: NSString | string, value: MSSharedObjectInstance): T;
}
declare class MSSharedObject extends _MSSharedObject implements IBCSortable {
  alloc<T extends MSSharedObject>(): MSSharedObjectAllocator<T>;
  registerInstance(instance: MSSharedObjectInstance): void;
  unregisterInstance(instance: MSSharedObjectInstance): void;
  isSharedObjectForInstance(instance: MSSharedObjectInstance): boolean;
  newInstance(): MSSharedObjectInstance;
  isOutOfSyncWithInstance(instance: MSSharedObjectInstance): boolean;

  name(): NSString;
}

declare interface IMSSharedObjectInstance {
  type(): MSSharedStyleType;
  syncWithTemplateInstance(instance: any): void;

  sharedObjectID(): NSString;
  setSharedObjectID(sharedObjectID: NSString | string): void;
}

declare type MSSharedObjectInstance = MSModelObject

class MSSharedObjectContainerAllocator<T extends MSSharedObjectContainer> extends _MSSharedObjectContainerAllocator<T> {}
declare class MSSharedObjectContainer extends _MSSharedObjectContainer {
  alloc<T extends MSSharedObjectContainer>(): MSSharedObjectContainerAllocator<T>;
  removeSharedObject(sharedObject: MSSharedObject): void;
  removeSharedObjects(sharedObjects: NSArray<any> | any[]): void;
  instancesOf_inContainer(sharedObjectIDs: NSSet<any>, container: any): NSArray<any>;
  isSharedObjectForInstance(instance: MSSharedObjectInstance): boolean;
  sharedObjectForInstance(instance: MSSharedObjectInstance): MSSharedObject;
  sharedObjectWithID(sharedObjectID: NSString | string): MSSharedObject;
  sharedObjectAtIndex(index: NSUInteger): MSSharedObject;
  indexOfSharedObject(sharedObject: MSSharedObject): NSInteger;
  numberOfSharedObjects(): NSUInteger;
  registerInstance_withSharedObject(instance: MSSharedObjectInstance, sharedObject: MSSharedObject): void;
  unregisterInstance(instance: MSSharedObjectInstance): void;
  sharedObjectsInLayers(layers: MSLayerArray): NSDictionary<any, any>;
  objectsSortedByName(): NSArray<any>;
}

declare interface IMSSharedStylePasting {
  handlePasteIntoDocument(document: MSDocumentData): NSString;

  currentObjectID_MSSharedStylePasting(): NSString;
}

class MSSharedStyleContainerAllocator<T extends MSSharedStyleContainer> extends _MSSharedStyleContainerAllocator<T> {}
declare class MSSharedStyleContainer extends _MSSharedStyleContainer {
  alloc<T extends MSSharedStyleContainer>(): MSSharedStyleContainerAllocator<T>;
  removeSharedStyle(sharedStyle: MSSharedStyle): void;
  isSharedStyleForInstance(instance: MSStyle): boolean;
  sharedStyleForInstance(instance: MSStyle): MSSharedStyle;
  sharedStyleWithID(sharedStyleID: NSString | string): MSSharedStyle;
  sharedStyleAtIndex(index: NSUInteger): MSSharedStyle;
  indexOfSharedStyle(sharedStyle: MSSharedStyle): NSInteger;
  numberOfSharedStyles(): NSUInteger;
  registerInstance_withSharedStyle(instance: MSStyle, sharedObject: MSSharedStyle): void;
  validStyleType(): MSSharedStyleType;
  sharedStyles(): NSArray<any>;
}

class MSSharedTextStyleContainerAllocator<T extends MSSharedTextStyleContainer> extends _MSSharedTextStyleContainerAllocator<T> {}
declare class MSSharedTextStyleContainer extends _MSSharedTextStyleContainer {
  alloc<T extends MSSharedTextStyleContainer>(): MSSharedTextStyleContainerAllocator<T>;
}

class MSSmoothBezierFilletAllocator<T extends MSSmoothBezierFillet> extends MSBezierFilletAllocator<T> {}
declare class MSSmoothBezierFillet extends MSBezierFillet {
  alloc<T extends MSSmoothBezierFillet>(): MSSmoothBezierFilletAllocator<T>;
  static smoothBezierFilletWithLineSegment1_lineSegment2_filletRadius(segment1: MSBezierSegment, segment2: MSBezierSegment, filletRadius: CGFloat): MSSmoothBezierFillet;
}

class MSStarShapeAllocator<T extends MSStarShape> extends _MSStarShapeAllocator<T> {}
declare class MSStarShape extends _MSStarShape {
  alloc<T extends MSStarShape>(): MSStarShapeAllocator<T>;
}

declare enum MSStylePartType {
  MSStylePartFill,
  MSStylePartBorder,
  MSStylePartShadow,
  MSStylePartInnerShadow,
}

class MSStyleBasicFillAllocator<T extends MSStyleBasicFill> extends _MSStyleBasicFillAllocator<T> {}
declare class MSStyleBasicFill extends _MSStyleBasicFill implements IMSColorConvertible {
  alloc<T extends MSStyleBasicFill>(): MSStyleBasicFillAllocator<T>;
  static defaultFillColor(): NSColor;
  static drawBasicFill_colorSpace_enabled_inRect(basicFill: MSStyleBasicFill, colorSpace: NSColorSpace, enabled: boolean, frame: NSRect): void;
  static drawCheckerboardBackgroundInRect(r: NSRect): void;
  static drawColor_enabled_inRect(color: NSColor, enabled: boolean, frame: NSRect): void;
  previewImageOfSize_colorSpace_clippingAsBorder_borderWidth(size: NSSize, colorSpace: NSColorSpace, clipBorder: boolean, borderWidth: CGFloat): NSImage;
  convertColorsUsing(converter: any): void;
  convertColorsUsing(converter: any): void;
}

class MSStyleBlurAllocator<T extends MSStyleBlur> extends _MSStyleBlurAllocator<T> {}
declare class MSStyleBlur extends _MSStyleBlur {
  alloc<T extends MSStyleBlur>(): MSStyleBlurAllocator<T>;
  cropRadius(): CGFloat;
}

declare enum MSStyleBlurType {
  MSStyleBlurGaussian = 0,
  MSStyleBlurMotion = 1,
  MSStyleBlurZoom = 2,
  MSStyleBlurBackground = 3,
}

class MSStyleBorderOptionsAllocator<T extends MSStyleBorderOptions> extends _MSStyleBorderOptionsAllocator<T> {}
declare class MSStyleBorderOptions extends _MSStyleBorderOptions {
  alloc<T extends MSStyleBorderOptions>(): MSStyleBorderOptionsAllocator<T>;

  hasDashPattern(): boolean;
}

class MSStyleColorControlsAllocator<T extends MSStyleColorControls> extends _MSStyleColorControlsAllocator<T> {}
declare class MSStyleColorControls extends _MSStyleColorControls {
  alloc<T extends MSStyleColorControls>(): MSStyleColorControlsAllocator<T>;
  hasDefaultColorControlsValues(): boolean;
  resetToDefaultValues(): void;
}

declare enum BCFillType {
  BCFillTypeColor = 0,
  BCFillTypeGradient = 1,
  BCFillTypePattern = 4,
  BCFillTypeNoise = 5,
}

declare enum MSBorderPositionType {
  MSBorderPositionCenter = 0,
  MSBorderPositionInside = 1,
  MSBorderPositionOutside = 2,
}

declare interface IMSStylePart {

  isEnabled(): boolean;
}

declare interface IMSStyledLayer {
}

class MSSymbolAllocator<T extends MSSymbol> extends _MSSymbolAllocator<T> {}
declare class MSSymbol extends _MSSymbol {
  alloc<T extends MSSymbol>(): MSSymbolAllocator<T>;
}

class MSSymbolContainerAllocator<T extends MSSymbolContainer> extends _MSSymbolContainerAllocator<T> {}
declare class MSSymbolContainer extends _MSSymbolContainer {
  alloc<T extends MSSymbolContainer>(): MSSymbolContainerAllocator<T>;
}

declare interface IMSTextLayerEditingDelegate {
  adjustTextViewFrame(): void;
  adjustForegroundColor(): void;
}

class MSTextLayoutAllocator<T extends MSTextLayout> extends NSObjectAllocator<T> {}
declare class MSTextLayout extends NSObject {
  alloc<T extends MSTextLayout>(): MSTextLayoutAllocator<T>;
  static textLayoutForLayoutManager(layoutManager: NSLayoutManager): MSTextLayout;

  baselineOffsets(): NSArray<any>;
  lineFragmentRectangles(): NSArray<any>;
  firstBaselineOffset(): CGFloat;
  lastBaselineOffset(): CGFloat;
  lineFragmentBounds(): CGRect;
  firstLineCapOffset(): CGFloat;
}

class MSTrailingLayersMoverAllocator<T extends MSTrailingLayersMover> extends NSObjectAllocator<T> {}
declare class MSTrailingLayersMover extends NSObject {
  alloc<T extends MSTrailingLayersMover>(): MSTrailingLayersMoverAllocator<T>;
  static changeFrameForLayers_inBlock(layers: NSArray<any> | any[], block: BCVoidBlock): void;
}

class MSTreeDiffAllocator<T extends MSTreeDiff> extends NSObjectAllocator<T> {
  initWithFirstDocument_secondDocument(firstDoc: MSImmutableDocumentData, secondDoc: MSImmutableDocumentData): T;
}
declare class MSTreeDiff extends NSObject {
  alloc<T extends MSTreeDiff>(): MSTreeDiffAllocator<T>;
  diffs(): NSArray<any>;
  contentDirtyDiffRect(): NSRect;
  overlayDirtyDiffRect(): NSRect;
  changedPropertiesAllExhibitTrait_allKeysWereCompared(trait: MSPropertyTraits, allKeysWereCompared: boolean): boolean;
  someChangedPropertiesExhibitTrait_allKeysWereCompared(targetTrait: MSPropertyTraits, allKeysWereCompared: boolean): boolean;
  containsLayerWithTraits(traits: MSTraits): boolean;
}

class MSTriangleShapeAllocator<T extends MSTriangleShape> extends _MSTriangleShapeAllocator<T> {}
declare class MSTriangleShape extends _MSTriangleShape {
  alloc<T extends MSTriangleShape>(): MSTriangleShapeAllocator<T>;
}

class MSUnitCoordinateSpaceAllocator<T extends MSUnitCoordinateSpace> extends NSObjectAllocator<T> {}
declare class MSUnitCoordinateSpace extends NSObject implements IMSLayerCoordinateSpace {
  alloc<T extends MSUnitCoordinateSpace>(): MSUnitCoordinateSpaceAllocator<T>;
  static convertPoint_fromBounds(point: CGPoint, bounds: CGRect): CGPoint;
  static convertPoint_toBounds(point: CGPoint, bounds: CGRect): CGPoint;
  convertPoint_toCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertPoint_fromCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertRect_toCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertRect_fromCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertVector_toCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  convertVector_fromCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  transformForConvertingToCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  transformForConvertingFromCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  convertPoint_toCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertPoint_fromCoordinateSpace(p: NSPoint, coordinateSpace: any | null): NSPoint;
  convertRect_toCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertRect_fromCoordinateSpace(r: NSRect, coordinateSpace: any | null): NSRect;
  convertVector_toCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  convertVector_fromCoordinateSpace(vector: CGVector, coordinateSpace: any | null): CGVector;
  transformForConvertingToCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;
  transformForConvertingFromCoordinateSpace(coordinateSpace: any | null): CGAffineTransform;

  parentCoordinateSpace(): any;
  setParentCoordinateSpace(parentCoordinateSpace: any): void;
  bounds(): CGRect;
  transformForConvertingToParentCoordinateSpace(): CGAffineTransform;
  transformForConvertingFromParentCoordinateSpace(): CGAffineTransform;
}

declare enum MSUserVisibleScaleType {
  MSUserVisibleScaleTypeScale = 0,
  MSUserVisibleScaleTypeWidth = 1,
  MSUserVisibleScaleTypeHeight = 2,
}

class MSVersionedArchiveAllocator<T extends MSVersionedArchive> extends NSObjectAllocator<T> {
  initWithURL_version(url: NSURL, version: MSDocumentVersion): T;
}
declare class MSVersionedArchive extends NSObject {
  alloc<T extends MSVersionedArchive>(): MSVersionedArchiveAllocator<T>;
  static globalArchiveWithName_extension_version(name: NSString | string, extension: NSString | string, version: MSDocumentVersion): MSVersionedArchive;
  unarchiveRootObjectVersion_error(version: MSDocumentVersion, error: NSError): any;
  archiveRootObject_error(rootObject: any, error: NSError): boolean;
  URLNeedingMigration(): NSURL;
  exists(): boolean;
  static versionedURLWithBase_extension_version(base: NSURL, extension: NSString | string, version: NSUInteger): NSURL;
  cleanupAfterTesting(): void;
}

declare enum MSBooleanOperation {
  MSBooleanOperationNone = -1,
  MSBooleanOperationUnion = 0,
  MSBooleanOperationSubtract = 1,
  MSBooleanOperationIntersect = 2,
  MSBooleanOperationDifference = 3,
}

class NSBezierPathEnumeratorAllocator<T extends NSBezierPathEnumerator> extends NSObjectAllocator<T> {}
declare class NSBezierPathEnumerator extends NSObject implements INSFastEnumeration {
  alloc<T extends NSBezierPathEnumerator>(): NSBezierPathEnumeratorAllocator<T>;
  objectAtIndex(index: NSUInteger): any;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;
  countByEnumeratingWithState_objects_count(state: NSFastEnumerationState, buffer: any[], len: NSUInteger): NSUInteger;

  pathItems(): NSArray<any>;
  bezierPath(): NSBezierPath;
  setBezierPath(bezierPath: NSBezierPath): void;
  reverse(): boolean;
  setReverse(reverse: boolean): void;
}

class NSBezierPathItemAllocator<T extends NSBezierPathItem> extends NSObjectAllocator<T> {}
declare class NSBezierPathItem extends NSObject {
  alloc<T extends NSBezierPathItem>(): NSBezierPathItemAllocator<T>;
  points(): NSPoint;
  setPoints(p: NSPoint): void;
  bezierPathStartingAtPoint(point: NSPoint): NSBezierPath;
  isEqual_withAccuracy(other: NSBezierPathItem, accuracy: CGFloat): boolean;

  type(): NSBezierPathElement;
  setType(type: NSBezierPathElement): void;
}

class CMapParserAllocator<T extends CMapParser> extends NSObjectAllocator<T> {
  initWithStream(stream: PDFStream): T;
  initWithData(data: NSData): T;
}
declare class CMapParser extends NSObject {
  alloc<T extends CMapParser>(): CMapParserAllocator<T>;

  map(): NSMutableDictionary<any, any>;
  setMap(map: NSMutableDictionary<any, any> | {[key: string]: any}): void;
}

class EPSConverterAllocator<T extends EPSConverter> extends NSObjectAllocator<T> {}
declare class EPSConverter extends NSObject {
  alloc<T extends EPSConverter>(): EPSConverterAllocator<T>;
  convertEPSAtURL_progressBlock(source: NSURL, progress: ProgressBlock): NSData;
  convertEPSData_progressBlock(data: NSData, progress: ProgressBlock): NSData;
  convertEPSAtURL_toURL_progressBlock(source: NSURL, destination: NSURL, progress: ProgressBlock): void;
}

class EPSParserAllocator<T extends EPSParser> extends NSObjectAllocator<T> {
  initWithScanner(scanner: PDFScanner): T;
}
declare class EPSParser extends NSObject implements IPDFParser {
  alloc<T extends EPSParser>(): EPSParserAllocator<T>;
  loadDocumentFromURL(url: NSURL): void;
  loadDocumentFromData(data: NSData): void;
  parseWithProgress(progress: BCVoidBlock): void;
  parsePastedDocument(): void;
  pageCount(): NSUInteger;
  name(): NSString;
  loadDocumentFromURL(url: NSURL): void;
  loadDocumentFromData(data: NSData): void;
  parseWithProgress(progress: BCVoidBlock): void;
  parsePastedDocument(): void;
  pageCount(): NSUInteger;
  name(): NSString;
}

class MSPDFScannerAllocator<T extends MSPDFScanner> extends PDFScannerAllocator<T> {}
declare class MSPDFScanner extends PDFScanner {
  alloc<T extends MSPDFScanner>(): MSPDFScannerAllocator<T>;

  rootLayer(): MSLayerGroup;
  setRootLayer(rootLayer: MSLayerGroup): void;
  substituteFontName(): NSString;
  setSubstituteFontName(substituteFontName: NSString | string): void;
}

class MSPDFStateAllocator<T extends MSPDFState> extends NSObjectAllocator<T> {
  initWithScanner(scanner: MSPDFScanner): T;
}
declare class MSPDFState extends NSObject implements INSCopying {
  alloc<T extends MSPDFState>(): MSPDFStateAllocator<T>;
  addLayer(layer: MSLayer): void;
  layerWithEnclosingGroup(enclosingGroup: boolean): MSLayer;
  makeArtboardGroup(): MSArtboardGroup;
  optimiseClipLayerInGroup(group: MSLayerGroup): boolean;
  lastLayer(): MSLayer;
  resetTransform(transform: NSAffineTransform): void;
  appendTransform(transform: NSAffineTransform): void;
  transformPoint(aPoint: NSPoint): NSPoint;
  transformSize(aSize: NSSize): NSSize;
  transformStruct(): NSAffineTransformStruct;
  transformBezierPath(aPath: NSBezierPath): NSBezierPath;
  stringFromTransform(transform: NSAffineTransform): NSString;
  updateClipping(): void;
  updateClippingWithTextPath(path: NSBezierPath): void;
  transformedClippingPath(): NSBezierPath;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  borderAlphaConstant(): CGFloat;
  setBorderAlphaConstant(borderAlphaConstant: CGFloat): void;
  borderColor(): NSColor;
  setBorderColor(borderColor: NSColor): void;
  borderColorSpace(): NSColorSpace;
  setBorderColorSpace(borderColorSpace: NSColorSpace): void;
  borderColorSpaceMapping(): PDFFunction;
  setBorderColorSpaceMapping(borderColorSpaceMapping: PDFFunction): void;
  borderDashes(): NSArray<any>;
  setBorderDashes(borderDashes: NSArray<any> | any[]): void;
  borderCapStyle(): NSLineCapStyle;
  setBorderCapStyle(borderCapStyle: NSLineCapStyle): void;
  borderGradient(): PDFPattern;
  setBorderGradient(borderGradient: PDFPattern): void;
  borderJoinStyle(): NSLineJoinStyle;
  setBorderJoinStyle(borderJoinStyle: NSLineJoinStyle): void;
  borderThickness(): CGFloat;
  setBorderThickness(borderThickness: CGFloat): void;
  clippingMode(): ClippingMode;
  setClippingMode(clippingMode: ClippingMode): void;
  clippingPath(): NSBezierPath;
  setClippingPath(clippingPath: NSBezierPath): void;
  clippingUpdated(): boolean;
  setClippingUpdated(clippingUpdated: boolean): void;
  containsClippedItems(): boolean;
  setContainsClippedItems(containsClippedItems: boolean): void;
  currentPoint(): NSPoint;
  setCurrentPoint(currentPoint: NSPoint): void;
  fillAlphaConstant(): CGFloat;
  setFillAlphaConstant(fillAlphaConstant: CGFloat): void;
  fillColor(): NSColor;
  setFillColor(fillColor: NSColor): void;
  fillColorSpace(): NSColorSpace;
  setFillColorSpace(fillColorSpace: NSColorSpace): void;
  fillColorSpaceMapping(): PDFFunction;
  setFillColorSpaceMapping(fillColorSpaceMapping: PDFFunction): void;
  fillGradient(): PDFPattern;
  setFillGradient(fillGradient: PDFPattern): void;
  layers(): NSMutableArray<any>;
  setLayers(layers: NSMutableArray<any> | any[]): void;
  path(): NSBezierPath;
  setPath(path: NSBezierPath): void;
  pathClosed(): boolean;
  setPathClosed(pathClosed: boolean): void;
  pathUsed(): boolean;
  setPathUsed(pathUsed: boolean): void;
  pathWasRect(): boolean;
  setPathWasRect(pathWasRect: boolean): void;
  renderingIntent(): CGColorRenderingIntent;
  setRenderingIntent(renderingIntent: CGColorRenderingIntent): void;
  text(): MSPDFTextState;
  setText(text: MSPDFTextState): void;
  transformedPath(): NSBezierPath;
  setTransformedPath(transformedPath: NSBezierPath): void;
  scanner(): MSPDFScanner;
  setScanner(scanner: MSPDFScanner): void;
}

declare enum ClippingMode {
  ClippingModeNonZeroWinding,
  ClippingModeWithEvenOddWindow,
  ClippingModeDontClip,
}

class MSPDFTextStateAllocator<T extends MSPDFTextState> extends NSObjectAllocator<T> {}
declare class MSPDFTextState extends NSObject implements INSCopying {
  alloc<T extends MSPDFTextState>(): MSPDFTextStateAllocator<T>;
  static textStateWithState(state: MSPDFState): MSPDFTextState;
  shouldFill(): boolean;
  shouldStroke(): boolean;
  shouldClip(): boolean;
  setTransform_resettingLineTransform(transform: NSAffineTransform, resettingLineTransform: boolean): void;
  resetRenderingTransform(): void;
  appendText(text: NSString | string): void;
  attributes(): NSDictionary<any, any>;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  characterSpacing(): CGFloat;
  setCharacterSpacing(characterSpacing: CGFloat): void;
  font(): NSFont;
  setFont(font: NSFont): void;
  fontName(): NSString;
  setFontName(fontName: NSString | string): void;
  fontInfo(): NSDictionary<any, any>;
  setFontInfo(fontInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  leading(): CGFloat;
  setLeading(leading: CGFloat): void;
  lineTransform(): NSAffineTransform;
  setLineTransform(lineTransform: NSAffineTransform): void;
  mode(): NSUInteger;
  setMode(mode: NSUInteger): void;
  offset(): CGFloat;
  setOffset(offset: CGFloat): void;
  renderingTransform(): NSAffineTransform;
  setRenderingTransform(renderingTransform: NSAffineTransform): void;
  rise(): CGFloat;
  setRise(rise: CGFloat): void;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  size(): CGFloat;
  setSize(size: CGFloat): void;
  state(): MSPDFState;
  setState(state: MSPDFState): void;
  text(): NSMutableAttributedString;
  setText(text: NSMutableAttributedString): void;
  transform(): NSAffineTransform;
  setTransform(transform: NSAffineTransform): void;
  wordSpacing(): CGFloat;
  setWordSpacing(wordSpacing: CGFloat): void;
}

class PDFFunctionAllocator<T extends PDFFunction> extends NSObjectAllocator<T> {
  initWithInfo(info: any): T;
}
declare class PDFFunction extends NSObject {
  alloc<T extends PDFFunction>(): PDFFunctionAllocator<T>;
  static functionWithInfo(info: any): PDFFunction;
  mapInputs_toOutputs(inputs: PDFFunctionInput, outputs: PDFFunctionOutput): void;

  samples(): NSData;
  parameters(): NSDictionary<any, any>;
  numberOfInputComponents(): NSUInteger;
  numberOfOutputComponents(): NSUInteger;
  bitsPerSample(): NSUInteger;
  bytesPerSampleComponent(): NSUInteger;
  bytesPerSample(): NSUInteger;
  numberOfSamples(): NSUInteger;
  domain(): NSArray<any>;
  setDomain(domain: NSArray<any> | any[]): void;
}

declare type PDFFunctionInput = CGFloat[]

declare type PDFFunctionOutput = CGFloat[]

class PDFOperatorInfoAllocator<T extends PDFOperatorInfo> extends NSObjectAllocator<T> {}
declare class PDFOperatorInfo extends NSObject {
  alloc<T extends PDFOperatorInfo>(): PDFOperatorInfoAllocator<T>;

  selector(): string;
  setSelector(selector: string): void;
  callback(): CGPDFOperatorCallback;
  setCallback(callback: CGPDFOperatorCallback): void;
  operatorName(): NSString;
  setOperatorName(operatorName: NSString | string): void;
  methodName(): NSString;
  setMethodName(methodName: NSString | string): void;
}

class PDFParserAllocator<T extends PDFParser> extends NSObjectAllocator<T> {
  initWithScanner(scanner: PDFScanner): T;
}
declare class PDFParser extends NSObject implements IPDFParser {
  alloc<T extends PDFParser>(): PDFParserAllocator<T>;
  loadDocumentFromURL(url: NSURL): void;
  loadDocumentFromData(data: NSData): void;
  parseWithProgress(progress: BCVoidBlock): void;
  parsePastedDocument(): void;
  pageCount(): NSUInteger;
  name(): NSString;
  loadDocumentFromURL(url: NSURL): void;
  loadDocumentFromData(data: NSData): void;
  parseWithProgress(progress: BCVoidBlock): void;
  parsePastedDocument(): void;
  pageCount(): NSUInteger;
  name(): NSString;

  name(): NSString;
  setName(name: NSString | string): void;
}

declare interface IPDFParser extends NSObject {
  loadDocumentFromURL(url: NSURL): void;
  loadDocumentFromData(data: NSData): void;
  parseWithProgress(progress: BCVoidBlock): void;
  parsePastedDocument(): void;
  pageCount(): NSUInteger;
  name(): NSString;
}

class PDFPatternAllocator<T extends PDFPattern> extends NSObjectAllocator<T> {
  initWithResource(resource: any): T;
}
declare class PDFPattern extends NSObject {
  alloc<T extends PDFPattern>(): PDFPatternAllocator<T>;
  static patternWithResource(resource: any): PDFPattern;

  shadingType(): ShadingType;
  function(): PDFFunction;
  space(): any;
  coords(): NSArray<any>;
}

declare enum ShadingType {
  ShadingTypeFunction = 1,
  ShadingTypeLinear,
  ShadingTypeRadial,
  ShadingTypeGouraudTriange,
  ShadingTypeGouraudLattice,
  ShadingTypeCoonsPatchMesh,
  ShadingTypeTensorProductPatchMesh,
}

class PDFScannerAllocator<T extends PDFScanner> extends NSObjectAllocator<T> {
  init(): T;
}
declare class PDFScanner extends NSObject {
  alloc<T extends PDFScanner>(): PDFScannerAllocator<T>;
  scanPage_parser_isPasted(page: CGPDFPageRef, parser: PDFParser, isPasted: boolean): void;
  scanStream_dictionary(stream: CGPDFContentStreamRef, dictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  popBool(): boolean;
  popDouble(): CGFloat;
  popInteger(): NSInteger;
  popRGBColor(): NSColor;
  popCMYKColor(): NSColor;
  popNumber(): NSNumber;
  popPoint(): NSPoint;
  popString(): PDFString;
  popName(): NSString;
  popTransform(): NSAffineTransform;
  popArray(): NSArray<any>;
  popObject(): any;
  static convertObject(object: CGPDFObjectRef): any;
  static convertArray(array: CGPDFArrayRef): NSArray<any>;
  static convertDictionary(dictionary: CGPDFDictionaryRef): NSDictionary<any, any>;
  colorSpaceWithInfo_mapping(info: any, mapping: PDFFunction): NSColorSpace;
  gradientForPattern(pattern: PDFPattern): NSGradient;
  currentPoint(): NSPoint;
  currentLeading(): CGFloat;
  currentFillColorSpace(): NSColorSpace;
  currentFillColorSpaceMapping(): PDFFunction;
  currentStrokeColorSpace(): NSColorSpace;
  currentStrokeColorSpaceMapping(): PDFFunction;
  currentFont(): NSDictionary<any, any>;
  moveTo(point: NSPoint): void;
  lineTo(point: NSPoint): void;
  curveTo_control1_control2(point: NSPoint, control1: NSPoint, control2: NSPoint): void;
  closePath(): void;
  endPath(): void;
  appendRectangle(rectangle: NSRect): void;
  defineMarkedPoint(): void;
  processXObject(object: PDFStream): void;
  processForm(form: PDFStream): void;
  processImage_info(image: NSImage, info: NSDictionary<any, any> | {[key: string]: any}): void;
  concatMatrix(transform: NSAffineTransform): void;
  saveGraphicState(): void;
  restoreGraphicState(): void;
  setLineWidth(width: CGFloat): void;
  setLineJoin(join: NSUInteger): void;
  setLineCap(cap: NSUInteger): void;
  setLineDash_phase(dashes: NSArray<any> | any[], phase: NSInteger): void;
  setMitreLimit(limit: CGFloat): void;
  setStrokeColourSpace_mapping(space: NSColorSpace, mapping: PDFFunction): void;
  setFillColourSpace_mapping(space: NSColorSpace, mapping: PDFFunction): void;
  setColourRenderingIntent(intent: CGColorRenderingIntent): void;
  setFillColour(colour: NSColor): void;
  setStrokeColour(colour: NSColor): void;
  setFillPattern(pattern: PDFPattern): void;
  setStrokePattern(pattern: PDFPattern): void;
  setFillAlphaConstant(alpha: CGFloat): void;
  setStrokeAlphaConstant(alpha: CGFloat): void;
  clipWithWinding(winding: NSWindingRule): void;
  fillWithWinding(winding: NSWindingRule): void;
  fillWithShadingPattern(pattern: PDFPattern): void;
  strokeWithWinding(winding: NSWindingRule): void;
  beginCompatibility(): void;
  endCompatibility(): void;
  beginMarkedContentWithProperty(): void;
  beginMarkedContent(): void;
  endMarkedContent(): void;
  beginImage(): void;
  setOverprintMode(mode: NSInteger): void;
  beginText(): void;
  setFontName_size_info(name: NSString | string, size: CGFloat, info: NSDictionary<any, any> | {[key: string]: any}): void;
  setTextCharacterSpacing(spacing: CGFloat): void;
  setTextWordSpacing(spacing: CGFloat): void;
  setTextLeading(spacing: CGFloat): void;
  setTextRise(spacing: CGFloat): void;
  setTextScale(spacing: CGFloat): void;
  setTextMode(mode: NSUInteger): void;
  setTextMatrix(matrix: NSAffineTransform): void;
  offset(offset: CGFloat): void;
  nextLineWithOffset(point: NSPoint): void;
  appendText(string: NSString | string): void;
  endText(): void;
  declareGlyph(): void;
  glyphBounds(): void;

  dictionary(): NSDictionary<any, any>;
  setDictionary(dictionary: NSDictionary<any, any> | {[key: string]: any}): void;
}

class PDFStreamAllocator<T extends PDFStream> extends NSObjectAllocator<T> {
  initWithStream(stream: CGPDFStreamRef): T;
}
declare class PDFStream extends NSObject {
  alloc<T extends PDFStream>(): PDFStreamAllocator<T>;
  dictionary(): NSDictionary<any, any>;

  stream(): CGPDFStreamRef;
  format(): CGPDFDataFormat;
  data(): NSData;
  dictionary(): NSDictionary<any, any>;
}

class PDFStringAllocator<T extends PDFString> extends NSObjectAllocator<T> {
  initWithStringRef(stringRef: CGPDFStringRef): T;
}
declare class PDFString extends NSObject {
  alloc<T extends PDFString>(): PDFStringAllocator<T>;
  string(): NSString;
  data(): NSData;
  stringWithMap(map: NSDictionary<any, any> | {[key: string]: any}): NSString;
}

class PDFLoggingScannerAllocator<T extends PDFLoggingScanner> extends PDFScannerAllocator<T> {}
declare class PDFLoggingScanner extends PDFScanner {
  alloc<T extends PDFLoggingScanner>(): PDFLoggingScannerAllocator<T>;
  log_method(string: NSString | string, method: string): void;
}

class MSPluginBundleAllocator<T extends MSPluginBundle> extends NSObjectAllocator<T> {
  initPluginBundleWithURL(url: NSURL): T;
  initWithName_identifier_commands_icon(name: NSString | string, identifier: NSString | string, commands: NSArray<any> | any[], icon: NSImage): T;
}
declare class MSPluginBundle extends NSObject {
  alloc<T extends MSPluginBundle>(): MSPluginBundleAllocator<T>;
  static pluginBundleWithURL(url: NSURL): MSPluginBundle;
  writeToURL(url: NSURL): boolean;
  urlForResourceNamed(resourceName: NSString | string): NSURL;

  url(): NSURL;
  commands(): NSDictionary<any, any>;
  version(): NSString;
  name(): NSString;
  icon(): NSImage;
  alertIcon(): NSImage;
  identifier(): NSString;
  versionedIdentifier(): NSString;
  pluginDescription(): NSString;
  suppliesData(): boolean;
  menuDescription(): NSDictionary<any, any>;
  setMenuDescription(menuDescription: NSDictionary<any, any> | {[key: string]: any}): void;
  homepageURL(): NSURL;
  author(): NSString;
  authorEmail(): NSString;
  appcastURL(): NSURL;
  compatibleVersion(): NSString;
  maximumCompatibleVersion(): NSString;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  compatible(): boolean;
  disableCocoaScriptPreprocessor(): boolean;
  setDisableCocoaScriptPreprocessor(disableCocoaScriptPreprocessor: boolean): void;
}

class MSPluginCommandAllocator<T extends MSPluginCommand> extends NSObjectAllocator<T> {
  initWithScript_identifier_name_handlers_shortcut_scope(script: MSPluginScript, identifier: NSString | string, name: NSString | string, handlers: NSDictionary<any, any> | {[key: string]: any}, shortcut: NSString | string, scope: MSPluginCommandScope): T;
  initWithScript_identifier_name_runHandler_scope(script: MSPluginScript, identifier: NSString | string, name: NSString | string, runHandler: NSString | string, scope: MSPluginCommandScope): T;
}
declare class MSPluginCommand extends NSObject implements ICOPrintController {
  alloc<T extends MSPluginCommand>(): MSPluginCommandAllocator<T>;
  static commandWithJSON_scripts_scriptsURL(commandJSON: any, scripts: NSMutableDictionary<any, any> | {[key: string]: any}, scriptsURL: NSURL): MSPluginCommand;
  runHandlerWithKey_context_manager(handlerKey: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager): NSString;
  runHandlerWithKey_context_manager_onComplete(handlerKey: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager, callback: Block): NSString;
  runHandler_context_manager(handler: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager): NSString;
  runHandler_context_manager_onComplete(handler: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager, callback: Block): NSString;
  run_manager(context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager): NSString;
  run_manager_onComplete(context: NSDictionary<any, any> | {[key: string]: any}, manager: MSPluginManager, callback: Block): NSString;
  tearDownIfFinished(): boolean;
  hasRunHandler(): boolean;
  menuItemWithAction(selector: string): NSMenuItem;
  metadata(): NSDictionary<any, any>;
  print(value: any): void;
  logString(): NSString;
  valueForKey_onLayer_forPluginIdentifier(key: NSString | string, layer: MSLayer, identifier: NSString | string): any;
  setValue_forKey_onLayer_forPluginIdentifier(value: any, key: NSString | string, layer: MSLayer, identifier: NSString | string): void;
  valueForKey_onLayer(key: NSString | string, layer: MSLayer): any;
  setValue_forKey_onLayer(value: any, key: NSString | string, layer: MSLayer): void;
  valueForKey_onDocument_forPluginIdentifier(key: NSString | string, document: MSDocumentData, identifier: NSString | string): any;
  setValue_forKey_onDocument_forPluginIdentifier(value: any, key: NSString | string, document: MSDocumentData, identifier: NSString | string): void;
  valueForKey_onDocument(key: NSString | string, document: MSDocumentData): any;
  setValueForKey_forKey_onDocument(value: any, key: NSString | string, document: MSDocumentData): void;
  print(s: any): void;
  print(s: any): void;

  identifier(): NSString;
  commandSpecifier(): MSPluginCommandSpecifier;
  script(): MSPluginScript;
  name(): NSString;
  shortcut(): NSString;
  pluginBundle(): MSPluginBundle;
  setPluginBundle(pluginBundle: MSPluginBundle): void;
  scope(): MSPluginCommandScope;
  stayRunning(): boolean;
  setStayRunning(stayRunning: boolean): void;
  disableCocoaScriptPreprocessor(): boolean;
  setDisableCocoaScriptPreprocessor(disableCocoaScriptPreprocessor: boolean): void;
}

declare enum MSPluginCommandScope {
  MSPluginCommandScopeDocument,
  MSPluginCommandScopeApplication,
}

class MSPluginCommandSpecifierAllocator<T extends MSPluginCommandSpecifier> extends NSObjectAllocator<T> {
  initWithPluginBundleIdentifier_commandIdentifier(pluginBundleIdentifier: NSString | string, commandIdentifier: NSString | string): T;
}
declare class MSPluginCommandSpecifier extends NSObject implements INSCopying {
  alloc<T extends MSPluginCommandSpecifier>(): MSPluginCommandSpecifierAllocator<T>;
  isEqualToCommandSpecifier(specifier: MSPluginCommandSpecifier): boolean;
  stringValue(): NSString;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  pluginBundleIdentifier(): NSString;
  commandIdentifier(): NSString;
}

class MSPluginDebugControllerAllocator<T extends MSPluginDebugController> extends NSObjectAllocator<T> {}
declare class MSPluginDebugController extends NSObject implements ICODebugController {
  alloc<T extends MSPluginDebugController>(): MSPluginDebugControllerAllocator<T>;
  output_args(format: NSString | string, ...args: any[]): void;
  output_args(format: NSString | string, ...args: any[]): void;
}

class MSPluginManagerAllocator<T extends MSPluginManager> extends NSObjectAllocator<T> {
  initialisePlugins(): T;
  initWithPluginsFolderURLs_updater_pluginStateManager(pluginsFolderURLs: NSArray<any> | any[] | null, updater: any | null, stateManager: MSPluginManagingState | null): T;
}
declare class MSPluginManager extends NSObject {
  alloc<T extends MSPluginManager>(): MSPluginManagerAllocator<T>;
  static mainPluginsFolderURL(): NSURL;
  static defaultPluginURL(): NSURL;
  static pluginsURLs(): NSArray<any>;
  static warehousePluginFolderForIdentifier_withVersion(identifier: NSString | string, version: NSString | string): NSURL;
  enablePlugin(pluginBundle: MSPluginBundle): void;
  disablePlugin(pluginBundle: MSPluginBundle): void;
  enabledPlugins(): NSArray<any>;
  disabledPlugins(): NSArray<any>;
  versionsForPlugin(pluginBundle: MSPluginBundle): MSPluginVersions;
  reloadPlugins(): void;
  commandWithSpecifier(specifier: MSPluginCommandSpecifier): MSPluginCommand;
  addPluginsToMenu_selector(menu: NSMenu, selector: string | null): void;
  stopTrackingLongRunningCommandWithSpecifier(specifier: MSPluginCommandSpecifier): MSPluginCommand;
  trackLongRunningCommand_onComplete(command: MSPluginCommand, callback: Block): void;
  editBundle(bundle: MSPluginBundle | null): void;
  runHandlerWithKey_fromCommand_inPlugin_withContext(handlerKey: NSString | string, commandIdentifier: NSString | string, pluginIdentifier: NSString | string, context: NSDictionary<any, any> | {[key: string]: any}): void;
  checkForPluginUpdatesWithHandler_completionHandler(handler: Block, completionHandler: Block | null): void;
  checkForPluginUpdates_handler_completionHandler(plugins: NSArray<any> | any[], handler: Block, completionHandler: Block | null): void;
  downloadCompatiblePluginUpdatesWithCompletionHandler(completionHandler: Block): void;
  downloadLatestPluginUpdatesWithCompletionHandler(completionHandler: Block): void;
  downloadPluginUpdates_withCompletionHandler(updates: NSDictionary<any, any> | {[key: string]: any}, completionHandler: Block): void;
  isPluginUpdateDownloadedWithIdentifier_version(identifier: NSString | string, version: NSString | string): boolean;
  downloadPluginUpdate_withVersion_completionHandler(pluginIdentifier: NSString | string, pluginVersion: NSString | string, downloadCompletionHandler: Block): void;
  downloadAndInstallPluginWithIdentifier_version_downloadCompletionHandler(identifier: NSString | string, version: NSString | string, downloadCompletionHandler: Block): void;
  installPluginWithIdentifier_version_error(identifier: NSString | string, version: NSString | string, error: NSError): boolean;
  isPluginWithIdentifier_incompatibleWithVersion(identifier: NSString | string, version: NSString | string): boolean;
  cancelDownloadingPluginVersions(): void;
  clearPluginsCache(): void;
  clearFolderMonitors(): void;
  registerIncompatiblePlugins(): void;
  downloadRemotePluginsBlacklist(): void;

  pluginsFolderURLs(): NSArray<any>;
  mainPluginsFolderURL(): NSURL;
  plugins(): NSDictionary<any, any>;
  numberOfPluginsWithUpdates(): NSInteger;
  numberOfPluginsWithSketchCompatibleUpdates(): NSInteger;
  numberOfIncompatiblePluginsDisabled(): NSInteger;
  setNumberOfIncompatiblePluginsDisabled(numberOfIncompatiblePluginsDisabled: NSInteger): void;
  incompatiblePluginsWithCompatibleUpdates(): NSDictionary<any, any>;
  pluginsWithSketchCompatipleUpdates(): NSArray<any>;
  setPluginsWithSketchCompatipleUpdates(pluginsWithSketchCompatipleUpdates: NSArray<any> | any[]): void;
  static pluginsWarehouseURL(): NSURL;
  updatesAddedToWarehouse(): NSInteger;
  setUpdatesAddedToWarehouse(updatesAddedToWarehouse: NSInteger): void;
  disableAllPlugins(): boolean;
  setDisableAllPlugins(disableAllPlugins: boolean): void;
  logAction(): any;
  setLogAction(logAction: any): void;
}

declare interface IMSPluginLogAction {
  log(sender: NSDictionary<any, any> | {[key: string]: any}): void;
  clearLog(): void;
  logString(): NSString;
}

class MSPluginManagingStateAllocator<T extends MSPluginManagingState> extends NSObjectAllocator<T> {
  initWithMetadataURL_incompatiblePlugins(metadataURL: NSURL, incompatiblePlugins: NSDictionary<any, any> | {[key: string]: any}): T;
}
declare class MSPluginManagingState extends NSObject {
  alloc<T extends MSPluginManagingState>(): MSPluginManagingStateAllocator<T>;
  setEnabled_forPluginIdentifier_withVersion(enable: boolean, identifier: NSString | string, version: NSString | string): void;
  shouldEnablePluginIdentifier_withVersion(identifier: NSString | string, version: NSString | string): boolean;
  updateMetadataWithPluginIndentifiers(identifiers: NSArray<any> | any[]): void;
  isPluginWithIdentifier_incompatibleWithVersion(identifier: NSString | string, version: NSString | string): boolean;
  registerPluginIncompatibilityForVersions(pluginsDictionary: NSDictionary<any, any> | {[key: string]: any}): NSInteger;
  resetIncompatiblePluginMetadata(): void;

  static incompatiblePlugins(): NSDictionary<any, any>;
  static existingDownloadededBlacklistURL(): NSURL;
}

class MSPluginScriptAllocator<T extends MSPluginScript> extends NSObjectAllocator<T> {
  initWithURL_error(URL: NSURL, error: NSError): T;
  initWithString_filename(string: NSString | string, filename: NSString | string): T;
}
declare class MSPluginScript extends NSObject {
  alloc<T extends MSPluginScript>(): MSPluginScriptAllocator<T>;
  reload(): void;

  URL(): NSURL;
  filename(): NSString;
  script(): NSString;
}

declare interface IMSPluginUpdater {

  downloadingAppcastsStatus(): MSUpdaterStatus;
  downloadingPluginVersionsStatus(): MSUpdaterStatus;
}

declare enum MSUpdaterStatus {
  MSUpdaterNotUpdating,
  MSUpdaterActive,
  MSUpdaterCancelling,
  MSUpdaterFinished,
}

class MSPluginUpdaterImplementationAllocator<T extends MSPluginUpdaterImplementation> {}
declare class MSPluginUpdaterImplementation {
  alloc<T extends MSPluginUpdaterImplementation>(): MSPluginUpdaterImplementationAllocator<T>;
}

class MSPluginVersionsAllocator<T extends MSPluginVersions> extends NSObjectAllocator<T> {
  initWithIdentifier_appcastURL(identifier: NSString | string, appcastURL: NSURL): T;
}
declare class MSPluginVersions extends NSObject {
  alloc<T extends MSPluginVersions>(): MSPluginVersionsAllocator<T>;
  addVersions(versionsDictionary: NSDictionary<any, any> | {[key: string]: any}): void;
  downloadURLForVersion(version: NSString | string): NSURL;
  isVersionDownloaded(version: NSString | string): boolean;
  isVersionListed(version: NSString | string): boolean;
  isUpdateAvailableForVersion(version: NSString | string): boolean;

  identifier(): NSString;
  appcastURL(): NSURL;
  versions(): NSArray<any>;
  versionsDictionary(): NSDictionary<any, any>;
  latestVersionAvailable(): NSString;
}

class MSArtboardRendererCGAllocator<T extends MSArtboardRendererCG> extends MSGroupRendererCGAllocator<T> {}
declare class MSArtboardRendererCG extends MSGroupRendererCG {
  alloc<T extends MSArtboardRendererCG>(): MSArtboardRendererCGAllocator<T>;
  renderSubLayersOfGroup_ignoreDrawingArea_context(group: MSImmutableLayerGroup, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}

class MSBackgroundBlurRendererCGAllocator<T extends MSBackgroundBlurRendererCG> extends NSObjectAllocator<T> {}
declare class MSBackgroundBlurRendererCG extends NSObject implements IMSBackgroundBlurRenderer {
  alloc<T extends MSBackgroundBlurRendererCG>(): MSBackgroundBlurRendererCGAllocator<T>;
  renderBackgroundBlurBehindLayer_context_clippedToPath(shape: MSImmutableStyledLayer, context: MSRenderingContext, path: MSPath): void;
  renderBackgroundBlurBehindLayer_context_clippedToPath(shape: MSImmutableStyledLayer, context: MSRenderingContext, path: MSPath): void;
}

class MSBitmapBackedRenderingAllocator<T extends MSBitmapBackedRendering> extends NSObjectAllocator<T> {}
declare class MSBitmapBackedRendering extends NSObject {
  alloc<T extends MSBitmapBackedRendering>(): MSBitmapBackedRenderingAllocator<T>;
  static imageToCacheForLayer_context(layer: MSImmutableLayer, context: MSRenderingContextCG): MSLayerCachedImage;
}

class MSBitmapRendererCGAllocator<T extends MSBitmapRendererCG> extends MSLayerRendererCGAllocator<T> {}
declare class MSBitmapRendererCG extends MSLayerRendererCG {
  alloc<T extends MSBitmapRendererCG>(): MSBitmapRendererCGAllocator<T>;
}

class MSBitmapShadowRendererCGAllocator<T extends MSBitmapShadowRendererCG> extends NSObjectAllocator<T> {}
declare class MSBitmapShadowRendererCG extends NSObject implements IMSShadowRenderer {
  alloc<T extends MSBitmapShadowRendererCG>(): MSBitmapShadowRendererCGAllocator<T>;
  renderShadow_path_cacheObject_windingRule_options_type_strokeType_fillShouldClip_lineWidth_context(shadow: MSImmutableStyleShadow, path: MSPath, cacheObject: MSModelObjectCommon, windingRule: NSWindingRule, options: MSImmutableStyleBorderOptions, shadowType: MSShadowType, strokeType: MSShadowBorderType, fillShouldClip: boolean, width: CGFloat, context: MSRenderingContext): void;
  renderShadow_rect_context_block(shadow: MSImmutableStyleShadow, rect: CGRect, context: MSRenderingContext, block: BCVoidBlock): void;
  renderInnerShadow_path_windingRule_context_cacheObject(shadow: MSImmutableStyleInnerShadow, path: MSPath, windingRule: NSWindingRule, context: MSRenderingContext, cacheObject: MSModelObjectCommon): void;
  renderShadow_path_cacheObject_windingRule_options_type_strokeType_fillShouldClip_lineWidth_context(shadow: MSImmutableStyleShadow, path: MSPath, cacheObject: MSModelObjectCommon, windingRule: NSWindingRule, options: MSImmutableStyleBorderOptions, shadowType: MSShadowType, strokeType: MSShadowBorderType, fillShouldClip: boolean, width: CGFloat, context: MSRenderingContext): void;
  renderShadow_rect_context_block(shadow: MSImmutableStyleShadow, rect: CGRect, context: MSRenderingContext, block: BCVoidBlock): void;
  renderInnerShadow_path_windingRule_context_cacheObject(shadow: MSImmutableStyleInnerShadow, path: MSPath, windingRule: NSWindingRule, context: MSRenderingContext, cacheObject: MSModelObjectCommon): void;
}

declare enum MSBlurredImageOptions {
  MSBlurredImageOptionsNone = 0,
  MSBlurredImageOptionsWhiteBackground = 1<<1,
  MSBlurredImageOptionsBlurTwice = 1<<2,
}

class MSCGContextPoolAllocator<T extends MSCGContextPool> extends BCObjectPoolAllocator<T> {
  initWithSize_colorSpace(contextSize: CGSize, colorSpace: CGColorSpaceRef): T;
}
declare class MSCGContextPool extends BCObjectPool {
  alloc<T extends MSCGContextPool>(): MSCGContextPoolAllocator<T>;
  vendsSize_colorSpace(size: CGSize, colorSpace: CGColorSpaceRef): boolean;
  recycleContext(context: CGContextRef): void;
}

class MSCacheManagerAllocator<T extends MSCacheManager> extends NSObjectAllocator<T> {
  init(): T;
  initWithZoomIndependentCache(zoomIndependentCache: BCCache): T;
}
declare class MSCacheManager extends NSObject implements IMSRenderingContextCacheProvider {
  alloc<T extends MSCacheManager>(): MSCacheManagerAllocator<T>;
  clearCachesExceptForOwners(ownersToKeep: NSSet<any>): void;
  clearAllCaches(): void;
  cacheForZoomLevel(zoomLevel: CGFloat): BCCache;
  cacheForZoomLevel(zoomLevel: CGFloat): BCCache;

  modelCache(): BCCache;
  zoomIndependentCache(): BCCache;
}

declare type MSColorTriangleVertex = {
  x: number
  y: number
  z: number
  w: number
  r: number
  g: number
  b: number
  a: number
}

declare type MSColorTriangleMesh = {
  vertices: MSColorTriangleVertex
  count: number
  capacity: number
}

class MSCoreImageQueueAllocator<T extends MSCoreImageQueue> extends NSObjectAllocator<T> {}
declare class MSCoreImageQueue extends NSObject {
  alloc<T extends MSCoreImageQueue>(): MSCoreImageQueueAllocator<T>;
  static drawImage_withEffect_inRect_fromObject_context_colorSpace_options(imageRef: CGImageRef, effect: MSCoreImageEffect, rect: CGRect, source: any, contextRef: CGContextRef, colorSpace: CGColorSpaceRef, options: MSRenderingRequestOptions): void;
  static cachedImage_withEffect_fromObject_colorSpace(imageRef: CGImageRef, effect: MSCoreImageEffect, source: any, colorSpace: CGColorSpaceRef): MSLayerCachedImage;
  static averageLuminanceOfImage(inputImage: CGImageRef): CGFloat;
}

declare enum MSCoreImageEffect {
  MSCoreImageEffectDefault,
  MSCoreImageEffectPerspective,
  MSCoreImageEffectAverageLuminance,
  MSCoreImageEffectSaturation,
}

class MSEPSExporterAllocator<T extends MSEPSExporter> extends MSExporterAllocator<T> {}
declare class MSEPSExporter extends MSExporter {
  alloc<T extends MSEPSExporter>(): MSEPSExporterAllocator<T>;
}

class MSExportRenderingContextAllocator<T extends MSExportRenderingContext> extends MSRenderingContextCGAllocator<T> {}
declare class MSExportRenderingContext extends MSRenderingContextCG {
  alloc<T extends MSExportRenderingContext>(): MSExportRenderingContextAllocator<T>;

  exportRequest(): MSExportRequest;
  setExportRequest(exportRequest: MSExportRequest): void;
}

class MSExporterAllocator<T extends MSExporter> extends NSObjectAllocator<T> {}
declare class MSExporter extends NSObject {
  alloc<T extends MSExporter>(): MSExporterAllocator<T>;
  static exporterForRequest_colorSpace(request: MSExportRequest, colorSpace: NSColorSpace | null): MSExporter;
  static exporterForRequest_colorSpace_driver(request: MSExportRequest, colorSpace: NSColorSpace, driver: MSRenderingDriver): MSExporter;
  data(): NSData;
  image(): NSImage;
  previewImage(): NSImage;
  drawRect_context(dirtyRect: NSRect, contextRef: CGContextRef): void;
  exportToFileURL(fileURL: NSURL): boolean;
  bitmapImageRep(): NSBitmapImageRep;
  basicBitmapImageRep(): NSBitmapImageRep;
  boundsForVectorRender(): NSRect;

  request(): MSExportRequest;
  setRequest(request: MSExportRequest): void;
  isPrinting(): boolean;
  setIsPrinting(isPrinting: boolean): void;
  driver(): MSRenderingDriver;
  colorSpace(): NSColorSpace;
}

class MSExporterViewAllocator<T extends MSExporterView> extends NSViewAllocator<T> {}
declare class MSExporterView extends NSView {
  alloc<T extends MSExporterView>(): MSExporterViewAllocator<T>;
  static exportViewWithRenderer(renderer: MSExporter): MSExporterView;

  renderer(): MSExporter;
  setRenderer(renderer: MSExporter): void;
}

class MSFillRendererCGAllocator<T extends MSFillRendererCG> extends NSObjectAllocator<T> {}
declare class MSFillRendererCG extends NSObject implements IMSFillRenderer {
  alloc<T extends MSFillRendererCG>(): MSFillRendererCGAllocator<T>;
  renderFill_path_layer_index_rect_hasInnerStroke_context(fill: MSImmutableStyleFill, path: MSPath, layer: MSImmutableStyledLayer, index: NSInteger, rect: CGRect, hasInnerStroke: boolean, context: MSRenderingContext): void;
  renderFill_path_layer_index_rect_hasInnerStroke_context(fill: MSImmutableStyleFill, path: MSPath, layer: MSImmutableStyledLayer, index: NSInteger, rect: CGRect, hasInnerStroke: boolean, context: MSRenderingContext): void;
}

class MSFlowRendererAllocator<T extends MSFlowRenderer> extends MSOverlayRendererAllocator<T> {}
declare class MSFlowRenderer extends MSOverlayRenderer {
  alloc<T extends MSFlowRenderer>(): MSFlowRendererAllocator<T>;
  drawRect_context_selectedLayerIDs(dirtyRect: NSRect, context: MSRenderingContext, selectedLayerIDs: NSArray<any> | any[]): void;

  flowInfluencingLayerIDs(): NSArray<any>;
  setFlowInfluencingLayerIDs(flowInfluencingLayerIDs: NSArray<any> | any[]): void;
  shouldDrawSourceLayerBounds(): boolean;
  setShouldDrawSourceLayerBounds(shouldDrawSourceLayerBounds: boolean): void;
  sourceLayerBounds(): CGRect;
  setSourceLayerBounds(sourceLayerBounds: CGRect): void;
  flowType(): MSFlowType;
  setFlowType(flowType: MSFlowType): void;
  flowPath(): NSBezierPath;
  setFlowPath(flowPath: NSBezierPath): void;
  flowClipPath(): NSBezierPath;
  setFlowClipPath(flowClipPath: NSBezierPath): void;
}

class MSFlowRendererCollectorAllocator<T extends MSFlowRendererCollector> extends NSObjectAllocator<T> {
  initWithLayers_onPage_document_zoomLevel_cache(layers: MSLayerArray, page: MSImmutablePage, doc: MSImmutableDocumentData, zoomLevel: CGFloat, cache: BCCache | null): T;
}
declare class MSFlowRendererCollector extends NSObject {
  alloc<T extends MSFlowRendererCollector>(): MSFlowRendererCollectorAllocator<T>;
  shouldInvalidateCollectedFlowsWithDiff(diff: MSTreeDiff): boolean;

  flowRenderers(): NSArray<any>;
}

class MSGPUArtboardShadowAllocator<T extends MSGPUArtboardShadow> extends NSObjectAllocator<T> {
  initWithRenderer(renderer: any): T;
}
declare class MSGPUArtboardShadow extends NSObject {
  alloc<T extends MSGPUArtboardShadow>(): MSGPUArtboardShadowAllocator<T>;
  minimumArtboardSizeForDrawingShadow(): CGFloat;
  cornerSize(): CGFloat;
  cornerSourceSize(): CGFloat;

  texture(): any;
  selectedTexture(): any;
}

declare interface IMSGPURenderer {
  scheduleDrawBlock(renderBlock: Block): void;
  beginFrameWithClearColor_drawableSize_backingScaleFactor_colorSpace(color: NSColor, drawableSize: CGSize, backingScaleFactor: CGFloat, colorSpace: CGColorSpaceRef): boolean;
  endFrame(): void;
  drawColorQuadInRect_color(rect: CGRect, color: MSRGBAColor): void;
  drawColorTriangleMesh(mesh: MSColorTriangleMesh): void;
  drawTexturedQuadInDestinationRect_sourceTexture_bilinearFilter(destinationRect: CGRect, sourceTexture: any, bilinearFilter: boolean): void;
  drawTexturedQuadInDestinationRect_sourceTexture_sourceRect_bilinearFilter(destinationRect: CGRect, sourceTexture: any, sourceRect: CGRect, bilinearFilter: boolean): void;
  drawShadowForArtboardInRect_selected_shadow(rect: CGRect, selected: boolean, shadow: MSGPUArtboardShadow): void;
  setScissorRectWithX_y_width_height(x: number, y: number, width: number, height: number): void;
  resetScissorRect(): void;
  createTextureWithWidth_height(width: NSUInteger, height: NSUInteger): any;
  layer(): CALayer;
  requiresSynchronousRendering(): boolean;
}

declare interface IMSGPUTexture {
  replaceRegion_bytesPerRow_pixels(region: BCIntRect, bytesPerRow: NSUInteger, pixels: void): void;
  width(): NSUInteger;
  height(): NSUInteger;
}

class MSGridRendererCGAllocator<T extends MSGridRendererCG> extends NSObjectAllocator<T> {
  initWithLightColor_darkColor(lightColor: CGColorRef, darkColor: CGColorRef): T;
}
declare class MSGridRendererCG extends NSObject implements IMSGridRenderer {
  alloc<T extends MSGridRendererCG>(): MSGridRendererCGAllocator<T>;
  renderGrid_in_origin_context(grid: MSImmutableBaseGrid, rect: CGRect, origin: CGPoint, context: MSRenderingContext): void;
  renderGrid_in_origin_context(grid: MSImmutableBaseGrid, rect: CGRect, origin: CGPoint, context: MSRenderingContext): void;

  lightColor(): CGColorRef;
  darkColor(): CGColorRef;
}

class MSGroupRendererCGAllocator<T extends MSGroupRendererCG> extends MSLayerRendererCGAllocator<T> {}
declare class MSGroupRendererCG extends MSLayerRendererCG {
  alloc<T extends MSGroupRendererCG>(): MSGroupRendererCGAllocator<T>;
  renderSubLayersOfGroup_ignoreDrawingArea_context(group: MSImmutableLayerGroup, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}

class MSHighLevelExporterAllocator<T extends MSHighLevelExporter> extends NSObjectAllocator<T> {
  initWithDelegate(delegate: any): T;
  initWithDelegate_driver(delegate: any, driver: MSRenderingDriver): T;
}
declare class MSHighLevelExporter extends NSObject {
  alloc<T extends MSHighLevelExporter>(): MSHighLevelExporterAllocator<T>;
  static exporterWithDelgate(delegate: any): MSHighLevelExporter;
  formatsToExport(): NSArray<any>;
  exportLayers(layers: NSArray<any> | any[]): boolean;
  exportPage(page: MSPage): boolean;

  delegate(): any;
}

declare interface IMSHighLevelExportDelegate {
}

class MSJPGExporterAllocator<T extends MSJPGExporter> extends MSExporterAllocator<T> {}
declare class MSJPGExporter extends MSExporter {
  alloc<T extends MSJPGExporter>(): MSJPGExporterAllocator<T>;
}

class MSLayerAnnotationsRendererAllocator<T extends MSLayerAnnotationsRenderer> extends MSOptionalRendererAllocator<T> {}
declare class MSLayerAnnotationsRenderer extends MSOptionalRenderer {
  alloc<T extends MSLayerAnnotationsRenderer>(): MSLayerAnnotationsRendererAllocator<T>;
}

class MSLayerCachedImageAllocator<T extends MSLayerCachedImage> extends NSObjectAllocator<T> {}
declare class MSLayerCachedImage extends NSObject {
  alloc<T extends MSLayerCachedImage>(): MSLayerCachedImageAllocator<T>;

  rect(): NSRect;
  setRect(rect: NSRect): void;
  image(): CGImageRef;
  setImage(image: CGImageRef): void;
}

class MSLayerRendererCGAllocator<T extends MSLayerRendererCG> extends NSObjectAllocator<T> {}
declare class MSLayerRendererCG extends NSObject implements IMSLayerRenderer {
  alloc<T extends MSLayerRendererCG>(): MSLayerRendererCGAllocator<T>;
  renderLayer_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
  renderLayerUncached_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
  renderLayer_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
  renderLayerUncached_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}

class MSMemoryBufferAllocator<T extends MSMemoryBuffer> extends NSObjectAllocator<T> {
  initWithSize(size: size_t): T;
}
declare class MSMemoryBuffer extends NSObject {
  alloc<T extends MSMemoryBuffer>(): MSMemoryBufferAllocator<T>;
  zerofill(bytesToFill: size_t): void;

  size(): size_t;
  bytes(): void;
}

class MSMetalRendererAllocator<T extends MSMetalRenderer> extends NSObjectAllocator<T> {}
declare class MSMetalRenderer extends NSObject implements IMSGPURenderer {
  alloc<T extends MSMetalRenderer>(): MSMetalRendererAllocator<T>;
  static createWithCompletionHandler(handler: Block): MSMetalRenderer;
  scheduleDrawBlock(renderBlock: Block): void;
  beginFrameWithClearColor_drawableSize_backingScaleFactor_colorSpace(color: NSColor, drawableSize: CGSize, backingScaleFactor: CGFloat, colorSpace: CGColorSpaceRef): boolean;
  endFrame(): void;
  drawColorQuadInRect_color(rect: CGRect, color: MSRGBAColor): void;
  drawColorTriangleMesh(mesh: MSColorTriangleMesh): void;
  drawTexturedQuadInDestinationRect_sourceTexture_bilinearFilter(destinationRect: CGRect, sourceTexture: any, bilinearFilter: boolean): void;
  drawTexturedQuadInDestinationRect_sourceTexture_sourceRect_bilinearFilter(destinationRect: CGRect, sourceTexture: any, sourceRect: CGRect, bilinearFilter: boolean): void;
  drawShadowForArtboardInRect_selected_shadow(rect: CGRect, selected: boolean, shadow: MSGPUArtboardShadow): void;
  setScissorRectWithX_y_width_height(x: number, y: number, width: number, height: number): void;
  resetScissorRect(): void;
  createTextureWithWidth_height(width: NSUInteger, height: NSUInteger): any;
  layer(): CALayer;
  requiresSynchronousRendering(): boolean;
  scheduleDrawBlock(renderBlock: Block): void;
  beginFrameWithClearColor_drawableSize_backingScaleFactor_colorSpace(color: NSColor, drawableSize: CGSize, backingScaleFactor: CGFloat, colorSpace: CGColorSpaceRef): boolean;
  endFrame(): void;
  drawColorQuadInRect_color(rect: CGRect, color: MSRGBAColor): void;
  drawColorTriangleMesh(mesh: MSColorTriangleMesh): void;
  drawTexturedQuadInDestinationRect_sourceTexture_bilinearFilter(destinationRect: CGRect, sourceTexture: any, bilinearFilter: boolean): void;
  drawTexturedQuadInDestinationRect_sourceTexture_sourceRect_bilinearFilter(destinationRect: CGRect, sourceTexture: any, sourceRect: CGRect, bilinearFilter: boolean): void;
  drawShadowForArtboardInRect_selected_shadow(rect: CGRect, selected: boolean, shadow: MSGPUArtboardShadow): void;
  setScissorRectWithX_y_width_height(x: number, y: number, width: number, height: number): void;
  resetScissorRect(): void;
  createTextureWithWidth_height(width: NSUInteger, height: NSUInteger): any;
  layer(): CALayer;
  requiresSynchronousRendering(): boolean;
}

class MSMetalTextureAllocator<T extends MSMetalTexture> extends NSObjectAllocator<T> {
  initWithMetalTexture(texture: any): T;
}
declare class MSMetalTexture extends NSObject implements IMSGPUTexture {
  alloc<T extends MSMetalTexture>(): MSMetalTextureAllocator<T>;
  replaceRegion_bytesPerRow_pixels(region: BCIntRect, bytesPerRow: NSUInteger, pixels: void): void;
  width(): NSUInteger;
  height(): NSUInteger;
  replaceRegion_bytesPerRow_pixels(region: BCIntRect, bytesPerRow: NSUInteger, pixels: void): void;
  width(): NSUInteger;
  height(): NSUInteger;

  metalTexture(): any;
}

class MSNoiseAllocator<T extends MSNoise> extends NSObjectAllocator<T> {}
declare class MSNoise extends NSObject {
  alloc<T extends MSNoise>(): MSNoiseAllocator<T>;
  static noiseIsOpaqueForType(type: NSInteger): boolean;
  static drawWithIntensity_ofType_inRect_zoomValue_context(intensity: CGFloat, type: NSInteger, rect: NSRect, zoomValue: CGFloat, context: CGContextRef): void;
  static drawWithIntensity_ofType_inPath_windingRule_zoomValue_context(intensity: CGFloat, type: NSInteger, path: MSPath, windingRule: NSWindingRule, zoomValue: CGFloat, context: CGContextRef): void;
}

class MSOpenGLLayerAllocator<T extends MSOpenGLLayer> extends NSOpenGLLayerAllocator<T> {}
declare class MSOpenGLLayer extends NSOpenGLLayer {
  alloc<T extends MSOpenGLLayer>(): MSOpenGLLayerAllocator<T>;
}

class MSOpenGLOffscreenBufferAllocator<T extends MSOpenGLOffscreenBuffer> extends NSObjectAllocator<T> {}
declare class MSOpenGLOffscreenBuffer extends NSObject {
  alloc<T extends MSOpenGLOffscreenBuffer>(): MSOpenGLOffscreenBufferAllocator<T>;
  beginRendering_height(width: number, height: number): void;
  endRendering(): void;

  context(): NSOpenGLContext;
  setContext(context: NSOpenGLContext): void;
  colorspace(): CGColorSpaceRef;
  setColorspace(colorspace: CGColorSpaceRef): void;
}

class MSOpenGLRendererAllocator<T extends MSOpenGLRenderer> extends NSObjectAllocator<T> {}
declare class MSOpenGLRenderer extends NSObject implements IMSGPURenderer {
  alloc<T extends MSOpenGLRenderer>(): MSOpenGLRendererAllocator<T>;
  static createWithCompletionHandler(handler: Block): MSOpenGLRenderer;
  scheduleDrawBlock(renderBlock: Block): void;
  beginFrameWithClearColor_drawableSize_backingScaleFactor_colorSpace(color: NSColor, drawableSize: CGSize, backingScaleFactor: CGFloat, colorSpace: CGColorSpaceRef): boolean;
  endFrame(): void;
  drawColorQuadInRect_color(rect: CGRect, color: MSRGBAColor): void;
  drawColorTriangleMesh(mesh: MSColorTriangleMesh): void;
  drawTexturedQuadInDestinationRect_sourceTexture_bilinearFilter(destinationRect: CGRect, sourceTexture: any, bilinearFilter: boolean): void;
  drawTexturedQuadInDestinationRect_sourceTexture_sourceRect_bilinearFilter(destinationRect: CGRect, sourceTexture: any, sourceRect: CGRect, bilinearFilter: boolean): void;
  drawShadowForArtboardInRect_selected_shadow(rect: CGRect, selected: boolean, shadow: MSGPUArtboardShadow): void;
  setScissorRectWithX_y_width_height(x: number, y: number, width: number, height: number): void;
  resetScissorRect(): void;
  createTextureWithWidth_height(width: NSUInteger, height: NSUInteger): any;
  layer(): CALayer;
  requiresSynchronousRendering(): boolean;
  scheduleDrawBlock(renderBlock: Block): void;
  beginFrameWithClearColor_drawableSize_backingScaleFactor_colorSpace(color: NSColor, drawableSize: CGSize, backingScaleFactor: CGFloat, colorSpace: CGColorSpaceRef): boolean;
  endFrame(): void;
  drawColorQuadInRect_color(rect: CGRect, color: MSRGBAColor): void;
  drawColorTriangleMesh(mesh: MSColorTriangleMesh): void;
  drawTexturedQuadInDestinationRect_sourceTexture_bilinearFilter(destinationRect: CGRect, sourceTexture: any, bilinearFilter: boolean): void;
  drawTexturedQuadInDestinationRect_sourceTexture_sourceRect_bilinearFilter(destinationRect: CGRect, sourceTexture: any, sourceRect: CGRect, bilinearFilter: boolean): void;
  drawShadowForArtboardInRect_selected_shadow(rect: CGRect, selected: boolean, shadow: MSGPUArtboardShadow): void;
  setScissorRectWithX_y_width_height(x: number, y: number, width: number, height: number): void;
  resetScissorRect(): void;
  createTextureWithWidth_height(width: NSUInteger, height: NSUInteger): any;
  layer(): CALayer;
  requiresSynchronousRendering(): boolean;
}

class MSOpenGLTextureAllocator<T extends MSOpenGLTexture> extends NSObjectAllocator<T> {
  initWithTextureID_width_height(textureID: GLuint, width: NSUInteger, height: NSUInteger): T;
}
declare class MSOpenGLTexture extends NSObject implements IMSGPUTexture {
  alloc<T extends MSOpenGLTexture>(): MSOpenGLTextureAllocator<T>;
  replaceRegion_bytesPerRow_pixels(region: BCIntRect, bytesPerRow: NSUInteger, pixels: void): void;
  width(): NSUInteger;
  height(): NSUInteger;
  replaceRegion_bytesPerRow_pixels(region: BCIntRect, bytesPerRow: NSUInteger, pixels: void): void;
  width(): NSUInteger;
  height(): NSUInteger;

  textureID(): GLuint;
  filter(): MSOpenGLTextureFilter;
  setFilter(filter: MSOpenGLTextureFilter): void;
}

declare enum MSOpenGLTextureFilter {
  MSOpenGLTextureFilterPoint = 0,
  MSOpenGLTextureFilterLinear,
}

class MSOptionalRendererAllocator<T extends MSOptionalRenderer> extends NSObjectAllocator<T> {
  initWithBaseRenderer_disableSetting(baseRenderer: any, setting: NSString | string): T;
}
declare class MSOptionalRenderer extends NSObject {
  alloc<T extends MSOptionalRenderer>(): MSOptionalRendererAllocator<T>;

  baseRenderer(): any;
  enabled(): boolean;
}

class MSOverlayColorSettingsAllocator<T extends MSOverlayColorSettings> extends NSObjectAllocator<T> {}
declare class MSOverlayColorSettings extends NSObject {
  alloc<T extends MSOverlayColorSettings>(): MSOverlayColorSettingsAllocator<T>;
  static colorSettings(): MSOverlayColorSettings;

  canvasBackgroundColor(): NSColor;
  setCanvasBackgroundColor(canvasBackgroundColor: NSColor): void;
  pageBackgroundColor(): NSColor;
  setPageBackgroundColor(pageBackgroundColor: NSColor): void;
  pixelGridColor(): NSColor;
  setPixelGridColor(pixelGridColor: NSColor): void;
  sliceOutlineColor(): NSColor;
  setSliceOutlineColor(sliceOutlineColor: NSColor): void;
  artboardTitleColor(): NSColor;
  setArtboardTitleColor(artboardTitleColor: NSColor): void;
  symbolTitleColor(): NSColor;
  setSymbolTitleColor(symbolTitleColor: NSColor): void;
}

class MSOverlayRendererAllocator<T extends MSOverlayRenderer> extends NSObjectAllocator<T> {}
declare class MSOverlayRenderer extends NSObject {
  alloc<T extends MSOverlayRenderer>(): MSOverlayRendererAllocator<T>;
  drawRect_context(dirtyRect: NSRect, context: MSRenderingContext): void;
  setNeedsDisplayInRect(rect: NSRect): void;

  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  hostView(): any;
  setHostView(hostView: any): void;
}

class MSPDFExporterAllocator<T extends MSPDFExporter> extends MSExporterAllocator<T> {}
declare class MSPDFExporter extends MSExporter {
  alloc<T extends MSPDFExporter>(): MSPDFExporterAllocator<T>;
}

class MSPDFPageAllocator<T extends MSPDFPage> extends NSObjectAllocator<T> {
  initWithPDFData(PDFData: NSData): T;
}
declare class MSPDFPage extends NSObject {
  alloc<T extends MSPDFPage>(): MSPDFPageAllocator<T>;

  pageRef(): CGPDFPageRef;
  size(): CGSize;
}

class MSPNGExporterAllocator<T extends MSPNGExporter> extends MSExporterAllocator<T> {}
declare class MSPNGExporter extends MSExporter {
  alloc<T extends MSPNGExporter>(): MSPNGExporterAllocator<T>;
}

class MSPathRendererCGAllocator<T extends MSPathRendererCG> extends NSObjectAllocator<T> {}
declare class MSPathRendererCG extends NSObject implements IMSPathRenderer {
  alloc<T extends MSPathRendererCG>(): MSPathRendererCGAllocator<T>;
  renderPath_style_layer_inRect_fallbackColor_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, fillColor: CGColorRef | null, context: MSRenderingContext): void;
  renderFillsForPath_style_layer_rect_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, context: MSRenderingContext): void;
  renderBordersForPath_style_rect_context(path: MSPath, style: MSImmutableStyle, rect: CGRect, context: MSRenderingContext): void;
  renderPath_style_layer_inRect_fallbackColor_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, fillColor: CGColorRef | null, context: MSRenderingContext): void;
  renderFillsForPath_style_layer_rect_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, context: MSRenderingContext): void;
  renderBordersForPath_style_rect_context(path: MSPath, style: MSImmutableStyle, rect: CGRect, context: MSRenderingContext): void;
}

class MSPerspectiveInstructionsAllocator<T extends MSPerspectiveInstructions> extends NSObjectAllocator<T> {}
declare class MSPerspectiveInstructions extends NSObject {
  alloc<T extends MSPerspectiveInstructions>(): MSPerspectiveInstructionsAllocator<T>;
  applyToImage(image: CIImage): CIImage;

  rect(): NSRect;
  setRect(rect: NSRect): void;
}

declare type MSRGBAColor = {
  red: number
  green: number
  blue: number
  alpha: number
}

declare type MSRegionRunHead = {
  _refCnt: number
  _runCount: number
  _ySpanCount: number
  _intervalCount: number
}

declare type MSRegion = {
  _bounds: BCIntRect
  _runHead: MSRegionRunHead
}

declare type MSRegionIterator = {
  _runs: number
  _rect: BCIntRect
  _done: boolean
}

declare enum MSRegionOp {
  MSDifferenceOp,
  MSIntersectOp,
  MSUnionOp,
  MSXOROp,
}

class MSRenderingContextAllocator<T extends MSRenderingContext> extends NSObjectAllocator<T> {
  initWithName_driver_renderingRequest(name: NSString | string, driver: MSRenderingDriver, renderingRequest: MSRenderingRequest): T;
}
declare class MSRenderingContext extends NSObject {
  alloc<T extends MSRenderingContext>(): MSRenderingContextAllocator<T>;
  renderLayer_ignoreCacheAndDrawingArea(layer: MSImmutableLayer, ignoreCacheAndDrawingArea: boolean): void;
  renderRect_withStyle(rect: CGRect, style: MSImmutableStyle): void;
  renderInBlock(block: BCVoidBlock): void;
  setUp(): void;
  tearDown(): void;
  setCachedValue_forModelObject_key_zoomIndependent(value: any, modelObject: MSModelObjectCommon, key: any, zoomIndependent: boolean): void;
  cachedValueForModelObject_key_zoomIndependent_orCreateWithBlock(object: MSModelObjectCommon, key: any, zoomIndependent: boolean, block: BCCacheCreateObjectBlock): any;
  concatTransform(transform: CGAffineTransform): void;
  accumulatedTransform(): CGAffineTransform;
  accumulatedRotateFlipTransform(): CGAffineTransform;
  pushGraphicsState(): void;
  popGraphicsState(): void;
  pushParentGroup(layerGroup: MSImmutableLayerGroup): void;
  popParentGroup(): MSImmutableLayerGroup;
  parentGroupForLayer(layer: any): MSImmutableLayerGroup;
  cancel(): void;
  transparencyLayerInBlock(block: BCVoidBlock): void;
  transparencyLayerInRect_inBlock(rect: CGRect, block: BCVoidBlock): void;
  beginTransparencyLayerInRect(aRect: CGRect): CGFloat;
  beginTransparencyLayerInRect_inheritClip(aRect: CGRect, inheritClip: boolean): CGFloat;
  beginTransparencyLayer(): CGFloat;
  endTransparencyLayer(oldAlpha: CGFloat): void;
  multiplyAlphaBy(alpha: CGFloat): CGFloat;
  setAlpha(oldAlpha: CGFloat): CGFloat;
  setBlendMode(blendMode: CGBlendMode): CGBlendMode;
  prepareLayerDrawing_inBlock(layer: MSImmutableStyledLayer, block: BCVoidBlock): void;
  applySettings_withOptions_inBlock(settings: MSImmutableGraphicsContextSettings, options: NSInteger, block: BCVoidBlock): void;
  applyLayerTransform_inBlock(layer: MSImmutableLayer, block: BCVoidBlock): void;
  shouldDrawLayer_withMaskingShapeGroup_ignoreDrawingArea(layer: MSImmutableLayer, mask: MSImmutableShapeGroup | null, ignoreDrawingArea: boolean): boolean;
  clipToRect(rect: CGRect): void;
  applyFillColor(color: MSImmutableColor): void;
  applyStrokeColor(color: MSImmutableColor): void;
  applyShadow(shadow: MSImmutableStyleShadow): void;
  canDrawSymbolMasterWithoutRiskingRecursion(master: MSImmutableSymbolMaster): boolean;
  isDrawingSymbol(): boolean;
  isDrawingSymbolInstance(): boolean;
  drawSymbolMaster_inBlock(master: MSImmutableSymbolMaster, block: BCVoidBlock): void;
  drawSymbolInstance_inBlock(instance: MSImmutableSymbolInstance, block: BCVoidBlock): void;
  shouldSkipDrawingShadow(shadow: MSImmutableStyleShadow): boolean;
  shouldLog(): boolean;

  renderingRequest(): MSRenderingRequest;
  rootLayer(): MSImmutableLayerGroup;
  cancelled(): boolean;
  drawingArea(): CGRect;
  setDrawingArea(drawingArea: CGRect): void;
  driver(): MSRenderingDriver;
  name(): NSString;
  setName(name: NSString | string): void;
  zoomLevelForShadows(): CGFloat;
  rotateFlipTransform(): CGAffineTransform;
}

declare enum MSGraphicsContextSettingMode {
  MSGraphicsSettingBlending = 1,
  MSGraphicsSettingOpacity = 2,
}

declare enum MSTransparencyOption {
  MSTransparencyDontUseLayer,
  MSTransparencyUseLayer,
}

declare enum MSTransparencyOptimiseOption {
  MSTransparencyDontOptimise,
  MSTransparencyCanOptimise,
}

declare enum MSTransparencyRectangleOption {
  MSTransparencyDontUseRectangle,
  MSTransparencyUseRectangle,
}

class MSRenderingContextCGAllocator<T extends MSRenderingContextCG> extends MSRenderingContextAllocator<T> {
  initWithName_driver_context_renderingRequest(name: NSString | string, driver: MSRenderingDriver, cgContext: CGContextRef, renderingRequest: MSRenderingRequest): T;
  initWithName_driver_cgContext_contextIsVectorBacked_renderingRequest(name: NSString | string, driver: MSRenderingDriver, cgContext: CGContextRef, vectorBacked: boolean, renderingRequest: MSRenderingRequest): T;
}
declare class MSRenderingContextCG extends MSRenderingContext {
  alloc<T extends MSRenderingContextCG>(): MSRenderingContextCGAllocator<T>;
  subContextWithCGContext_contextIsVectorBacked_pointScale_zoomLevel_options(cgContext: CGContextRef, vectorBacked: boolean, pointScale: CGFloat, zoomLevel: CGFloat, options: MSRenderingRequestOptions): MSRenderingContextCG;
  blurSubContextWithCGContext_backgroundBlurLayer_pointScale_rect(cgContext: CGContextRef, layer: MSImmutableLayer | null, pointScale: CGFloat, rect: CGRect): MSRenderingContextCG;
  applyShadow_withXOffset(shadow: MSImmutableStyleShadow, offset: CGFloat): void;
  applyShadow_respectFlipped(shadow: MSImmutableStyleShadow, respectFlipped: boolean): void;
  shouldDisableSubpixelQuantization(): boolean;
  doNotClipFillsInBlock(block: BCVoidBlock): void;
  shouldClipFills(): boolean;
  ifCondition_skipDrawingFillsInBlock(condition: boolean, block: BCVoidBlock): void;
  shouldDrawFills(): boolean;

  contextIsVectorBacked(): boolean;
  contextRef(): CGContextRef;
  contextPool(): MSCGContextPool;
  setContextPool(contextPool: MSCGContextPool): void;
  graphicsContext(): NSGraphicsContext;
}

declare interface IMSRenderingContextCacheProvider {
  cacheForZoomLevel(zoomLevel: CGFloat): BCCache;

  zoomIndependentCache(): BCCache;
}

class MSRenderingDriverAllocator<T extends MSRenderingDriver> extends NSObjectAllocator<T> {
  initWithSettings(settings: MSRenderingDriverSettings): T;
}
declare class MSRenderingDriver extends NSObject {
  alloc<T extends MSRenderingDriver>(): MSRenderingDriverAllocator<T>;
  setupRendererMap(): NSMapTable<any, any>;
  rendererForObject_protocol(object: any, protocol: Protocol): any;
  contextWithName_forCGContext_renderingRequest(name: NSString | string, contextRef: CGContextRef, renderingRequest: MSRenderingRequest): MSRenderingContext;

  settings(): MSRenderingDriverSettings;
}

class MSRenderingDriverCGAllocator<T extends MSRenderingDriverCG> extends MSRenderingDriverAllocator<T> {}
declare class MSRenderingDriverCG extends MSRenderingDriver {
  alloc<T extends MSRenderingDriverCG>(): MSRenderingDriverCGAllocator<T>;
}

class MSRenderingDriverCGDebugAllocator<T extends MSRenderingDriverCGDebug> extends MSRenderingDriverCGAllocator<T> {}
declare class MSRenderingDriverCGDebug extends MSRenderingDriverCG {
  alloc<T extends MSRenderingDriverCGDebug>(): MSRenderingDriverCGDebugAllocator<T>;
}

class MSRenderingDriverCGProfilingAllocator<T extends MSRenderingDriverCGProfiling> extends MSRenderingDriverCGAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class MSRenderingDriverCGProfiling extends MSRenderingDriverCG {
  alloc<T extends MSRenderingDriverCGProfiling>(): MSRenderingDriverCGProfilingAllocator<T>;
}

class MSRenderingDriverExportAllocator<T extends MSRenderingDriverExport> extends MSRenderingDriverCGAllocator<T> {}
declare class MSRenderingDriverExport extends MSRenderingDriverCG {
  alloc<T extends MSRenderingDriverExport>(): MSRenderingDriverExportAllocator<T>;
}

class MSRenderingDriverSettingsAllocator<T extends MSRenderingDriverSettings> extends NSObjectAllocator<T> {
  initWithGridLightColor_gridDarkColor_layoutGridStyle_flowColor_flowTipImage_flowBackImage_flowOtherPageImage(gridLightColor: CGColorRef, gridDarkColor: CGColorRef, layoutGridStyle: MSLayoutGridStyle, flowColor: CGColorRef, tipImage: CGImageRef | null, backImage: CGImageRef | null, otherPageImage: CGImageRef | null): T;
}
declare class MSRenderingDriverSettings extends NSObject {
  alloc<T extends MSRenderingDriverSettings>(): MSRenderingDriverSettingsAllocator<T>;
  flowTipImage(): CGImageRef;
  flowBackImage(): CGImageRef;
  flowOtherPageImage(): CGImageRef;
  flowColor(): CGColorRef;

  layoutGridStyle(): MSLayoutGridStyle;
  gridLightColor(): CGColorRef;
  gridDarkColor(): CGColorRef;
}

declare interface IMSRenderer extends NSObject {
}

declare interface IMSLayerRenderer extends IMSRenderer {
  renderLayer_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
  renderLayerUncached_ignoreDrawingArea_context(layer: MSImmutableLayer, ignoreDrawingArea: boolean, context: MSRenderingContext): void;
}

declare interface IMSPathRenderer extends IMSRenderer {
  renderPath_style_layer_inRect_fallbackColor_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, fillColor: CGColorRef | null, context: MSRenderingContext): void;
  renderFillsForPath_style_layer_rect_context(path: MSPath, style: MSImmutableStyle, layer: MSImmutableStyledLayer, rect: CGRect, context: MSRenderingContext): void;
  renderBordersForPath_style_rect_context(path: MSPath, style: MSImmutableStyle, rect: CGRect, context: MSRenderingContext): void;
}

declare interface IMSFillRenderer extends IMSRenderer {
  renderFill_path_layer_index_rect_hasInnerStroke_context(fill: MSImmutableStyleFill, path: MSPath, layer: MSImmutableStyledLayer, index: NSInteger, rect: CGRect, hasInnerStroke: boolean, context: MSRenderingContext): void;
}

declare interface IMSBackgroundBlurRenderer extends IMSRenderer {
  renderBackgroundBlurBehindLayer_context_clippedToPath(shape: MSImmutableStyledLayer, context: MSRenderingContext, path: MSPath): void;
}

declare interface IMSShadowRenderer extends IMSRenderer {
  renderShadow_path_cacheObject_windingRule_options_type_strokeType_fillShouldClip_lineWidth_context(shadow: MSImmutableStyleShadow, path: MSPath, cacheObject: MSModelObjectCommon, windingRule: NSWindingRule, options: MSImmutableStyleBorderOptions, shadowType: MSShadowType, strokeType: MSShadowBorderType, fillShouldClip: boolean, width: CGFloat, context: MSRenderingContext): void;
  renderShadow_rect_context_block(shadow: MSImmutableStyleShadow, rect: CGRect, context: MSRenderingContext, block: BCVoidBlock): void;
  renderInnerShadow_path_windingRule_context_cacheObject(shadow: MSImmutableStyleInnerShadow, path: MSPath, windingRule: NSWindingRule, context: MSRenderingContext, cacheObject: MSModelObjectCommon): void;
}

declare interface IMSGridRenderer extends IMSRenderer {
  renderGrid_in_origin_context(grid: MSImmutableBaseGrid, rect: CGRect, origin: CGPoint, context: MSRenderingContext): void;
}

declare enum MSPageOverlayRenderOptions {
  MSPageOverlayRenderTitles = 0x01,
  MSPageOverlayRenderShadows = 0x02,
  MSPageOverlayRenderGrids = 0x04,
  MSPageOverlayRenderPixels = 0x08,
  MSPageOverlayRenderSlices = 0x10,
  MSPageOverlayRenderFlows = 0x20,
}

class MSRenderingRequestAllocator<T extends MSRenderingRequest> extends NSObjectAllocator<T> {
  initWithDocument_colorSpace_pointScale_zoomLevel_cacheProvider_backgroundBlurLayer_options(document: MSImmutableDocumentData, colorSpace: CGColorSpaceRef, pointScale: CGFloat, zoomLevel: CGFloat, cacheProvider: any | null, backgroundBlurLayer: MSImmutableLayer | null, options: MSRenderingRequestOptions): T;
  initWithDocument_colorSpace_pointScale_zoomLevel_cacheProvider_options(document: MSImmutableDocumentData, colorSpace: CGColorSpaceRef, pointScale: CGFloat, zoomLevel: CGFloat, cacheProvider: any | null, options: MSRenderingRequestOptions): T;
}
declare class MSRenderingRequest extends NSObject {
  alloc<T extends MSRenderingRequest>(): MSRenderingRequestAllocator<T>;
  requestWithOptions(options: MSRenderingRequestOptions): MSRenderingRequest;

  cacheProvider(): any;
  setCacheProvider(cacheProvider: any): void;
  colorSpace(): CGColorSpaceRef;
  document(): MSImmutableDocumentData;
  pointScale(): CGFloat;
  zoomLevel(): CGFloat;
  backgroundBlurLayer(): MSImmutableLayer;
  options(): MSRenderingRequestOptions;
  exporting(): boolean;
  drawingMask(): boolean;
  drawingPixelated(): boolean;
  willDrawPixelated(): boolean;
  includeArtboardBackground(): boolean;
  printing(): boolean;
  skipLayerInclusionTests(): boolean;
  shouldFlipShadows(): boolean;
}

declare enum MSRenderingRequestOptions {
  MSRenderingRequestOptionsNone = 0,
  MSRenderingRequestOptionsExporting = 1 << 0,
  MSRenderingRequestOptionsDrawingMask = 1 << 1,
  MSRenderingRequestOptionsDrawingPixelated = 1 << 2,
  MSRenderingRequestOptionsIncludeArtboardBackground = 1 << 3,
  MSRenderingRequestOptionsPrinting = 1 << 4,
  MSRenderingRequestOptionsFlipShadows = 1 << 5,
  MSRenderingRequestOptionsSkipLayerInclusionTests = 1 << 6,
  MSRenderingRequestOptionsVectorBacked = 1 << 7,
  MSRenderingRequestOptionsDefault,
}

class MSSelfContainedHighLevelExporterAllocator<T extends MSSelfContainedHighLevelExporter> extends MSHighLevelExporterAllocator<T> {
  initWithOptions(options: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithOptions_driver(options: NSDictionary<any, any> | {[key: string]: any}, driver: MSRenderingDriver): T;
}
declare class MSSelfContainedHighLevelExporter extends MSHighLevelExporter implements IMSHighLevelExportDelegate {
  alloc<T extends MSSelfContainedHighLevelExporter>(): MSSelfContainedHighLevelExporterAllocator<T>;

  results(): NSDictionary<any, any>;
}

class MSShadowRendererCGAllocator<T extends MSShadowRendererCG> extends NSObjectAllocator<T> {}
declare class MSShadowRendererCG extends NSObject implements IMSShadowRenderer {
  alloc<T extends MSShadowRendererCG>(): MSShadowRendererCGAllocator<T>;
  renderShadow_path_cacheObject_windingRule_options_type_strokeType_fillShouldClip_lineWidth_context(shadow: MSImmutableStyleShadow, path: MSPath, cacheObject: MSModelObjectCommon, windingRule: NSWindingRule, options: MSImmutableStyleBorderOptions, shadowType: MSShadowType, strokeType: MSShadowBorderType, fillShouldClip: boolean, width: CGFloat, context: MSRenderingContext): void;
  renderShadow_rect_context_block(shadow: MSImmutableStyleShadow, rect: CGRect, context: MSRenderingContext, block: BCVoidBlock): void;
  renderInnerShadow_path_windingRule_context_cacheObject(shadow: MSImmutableStyleInnerShadow, path: MSPath, windingRule: NSWindingRule, context: MSRenderingContext, cacheObject: MSModelObjectCommon): void;
  renderShadow_path_cacheObject_windingRule_options_type_strokeType_fillShouldClip_lineWidth_context(shadow: MSImmutableStyleShadow, path: MSPath, cacheObject: MSModelObjectCommon, windingRule: NSWindingRule, options: MSImmutableStyleBorderOptions, shadowType: MSShadowType, strokeType: MSShadowBorderType, fillShouldClip: boolean, width: CGFloat, context: MSRenderingContext): void;
  renderShadow_rect_context_block(shadow: MSImmutableStyleShadow, rect: CGRect, context: MSRenderingContext, block: BCVoidBlock): void;
  renderInnerShadow_path_windingRule_context_cacheObject(shadow: MSImmutableStyleInnerShadow, path: MSPath, windingRule: NSWindingRule, context: MSRenderingContext, cacheObject: MSModelObjectCommon): void;
}

class MSShapeRendererCGAllocator<T extends MSShapeRendererCG> extends MSGroupRendererCGAllocator<T> {}
declare class MSShapeRendererCG extends MSGroupRendererCG {
  alloc<T extends MSShapeRendererCG>(): MSShapeRendererCGAllocator<T>;
}

class MSSliceTrimmingAllocator<T extends MSSliceTrimming> extends NSObjectAllocator<T> {}
declare class MSSliceTrimming extends NSObject {
  alloc<T extends MSSliceTrimming>(): MSSliceTrimmingAllocator<T>;
  static trimmedRectForLayerAncestry(ancestry: MSImmutableLayerAncestry): NSRect;
  static simpleSafeRectFromLayerAncestry(ancestry: MSImmutableLayerAncestry): NSRect;
}

class MSSymbolMasterRendererCGAllocator<T extends MSSymbolMasterRendererCG> extends MSArtboardRendererCGAllocator<T> {}
declare class MSSymbolMasterRendererCG extends MSArtboardRendererCG {
  alloc<T extends MSSymbolMasterRendererCG>(): MSSymbolMasterRendererCGAllocator<T>;
}

class MSSymbolRendererCGAllocator<T extends MSSymbolRendererCG> extends MSArtboardRendererCGAllocator<T> {}
declare class MSSymbolRendererCG extends MSArtboardRendererCG {
  alloc<T extends MSSymbolRendererCG>(): MSSymbolRendererCGAllocator<T>;
}

class MSTextRendererCGAllocator<T extends MSTextRendererCG> extends MSLayerRendererCGAllocator<T> {}
declare class MSTextRendererCG extends MSLayerRendererCG {
  alloc<T extends MSTextRendererCG>(): MSTextRendererCGAllocator<T>;
}

class MSTextStoragePoolAllocator<T extends MSTextStoragePool> extends BCObjectPoolAllocator<T> {
  initWithTextLayer(textLayer: MSImmutableTextLayer): T;
}
declare class MSTextStoragePool extends BCObjectPool {
  alloc<T extends MSTextStoragePool>(): MSTextStoragePoolAllocator<T>;
  vendTextStorage(): NSTextStorage;
  recycleTextStorage(textStorage: NSTextStorage): void;
}

declare type MSTexturedVertex = {
  x: number
  y: number
  textureX: number
  textureY: number
}

class MSTiffExporterAllocator<T extends MSTiffExporter> extends MSExporterAllocator<T> {}
declare class MSTiffExporter extends MSExporter {
  alloc<T extends MSTiffExporter>(): MSTiffExporterAllocator<T>;
}

class MSTileAllocator<T extends MSTile> extends NSObjectAllocator<T> {
  initWithRenderer_point(renderer: any, point: BCIntPoint): T;
}
declare class MSTile extends NSObject {
  alloc<T extends MSTile>(): MSTileAllocator<T>;
  replaceRegion_withBytes_bytesPerRow(region: BCIntRect, bytes: void, bytesPerRow: NSUInteger): void;

  texture(): any;
  point(): BCIntPoint;
  rectWithImageFragment(): BCIntRect;
}

class MSTileMipLevelAllocator<T extends MSTileMipLevel> extends NSObjectAllocator<T> {
  initWithScaleRangeMax(max: CGFloat): T;
}
declare class MSTileMipLevel extends NSObject {
  alloc<T extends MSTileMipLevel>(): MSTileMipLevelAllocator<T>;
  static tileMipLevelWithScaleRangeMax(rangeMax: CGFloat): MSTileMipLevel;
  enqueueRenderableTilesForVisibleRect(visibleRect: NSRect): NSArray<any>;
  countExistingTilesForVisibleRect(visibleRect: NSRect): NSUInteger;
  findWritableTileAt(point: BCIntPoint): MSTile;
  addTile(tile: MSTile): void;
  removeAllTiles(): void;
  removeAllTilesAndClearDirtyRegion(): void;
  removeAllTilesAndResetDirtyRegionToRect(rect: BCIntRect): void;
  isCurrentColorSpaceEqualTo(colorSpace: CGColorSpaceRef): boolean;
  uniteDirtyRect(rect: NSRect): void;
  subtractDirtyRect(rect: BCIntRect): void;

  scaleRangeMax(): CGFloat;
  scale(): CGFloat;
  setScale(scale: CGFloat): void;
  currentColorSpace(): CGColorSpaceRef;
  setCurrentColorSpace(currentColorSpace: CGColorSpaceRef): void;
  clearBeforeUpload(): boolean;
  setClearBeforeUpload(clearBeforeUpload: boolean): void;
  dirtyRegion(): MSRegion;
  tileCount(): NSUInteger;
}

class MSTileRasterisationOperationAllocator<T extends MSTileRasterisationOperation> extends NSOperationAllocator<T> {}
declare class MSTileRasterisationOperation extends NSOperation {
  alloc<T extends MSTileRasterisationOperation>(): MSTileRasterisationOperationAllocator<T>;
  static operationWithMemory_bytesPerRow_rect_zoomValue_backingScaleFactor_page_document_driver_contextPool_cacheProvider_colorSpace(memory: void, bytesPerRow: size_t, rect: BCIntRect, zoomValue: CGFloat, backingScaleFactor: CGFloat, page: MSImmutablePage, document: MSImmutableDocumentData, driver: MSRenderingDriver, contextPool: MSCGContextPool | null, cacheProvider: any | null, colorSpace: CGColorSpaceRef): MSTileRasterisationOperation;
}

class MSTileRenderPassAllocator<T extends MSTileRenderPass> extends NSObjectAllocator<T> {}
declare class MSTileRenderPass extends NSObject {
  alloc<T extends MSTileRenderPass>(): MSTileRenderPassAllocator<T>;
  static tileRenderPassWithPage_inDocument_dirtyRect_zoomValue(page: MSImmutablePage, documentData: MSImmutableDocumentData, dirtyRect: CGRect, zoomValue: CGFloat): MSTileRenderPass;
}

class MSTileRenderOperationAllocator<T extends MSTileRenderOperation> extends NSOperationAllocator<T> {}
declare class MSTileRenderOperation extends NSOperation {
  alloc<T extends MSTileRenderOperation>(): MSTileRenderOperationAllocator<T>;
  static bitmapImageRenderForPage_inDocument_visibleContentRect_backingScaleFactor_pixelViewSize_zoomValue_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(page: MSImmutablePage, documentData: MSImmutableDocumentData, visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, zoomValue: CGFloat, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): NSBitmapImageRep;
  static bitmapImageFromRenderPasses_visibleContentRect_backingScaleFactor_pixelViewSize_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(renderPasses: NSArray<any> | any[], visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): NSBitmapImageRep;
  static renderOperationWithPage_inDocument_visibleContentRect_backingScaleFactor_pixelViewSize_zoomValue_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(page: MSImmutablePage, documentData: MSImmutableDocumentData, visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, zoomValue: CGFloat, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): MSTileRenderOperation;
  static renderOperationWithRenderPasses_visibleContentRect_backingScaleFactor_pixelViewSize_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace(renderPasses: NSArray<any> | any[], visibleContentRect: CGRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any, canvasColorSpace: NSColorSpace): MSTileRenderOperation;

  renderedImage(): NSBitmapImageRep;
}

class MSTiledRendererAllocator<T extends MSTiledRenderer> extends NSObjectAllocator<T> {
  initWithCompletionHandler(handler: Block): T;
}
declare class MSTiledRenderer extends NSObject {
  alloc<T extends MSTiledRenderer>(): MSTiledRendererAllocator<T>;
  updateContentInRect_forPage_document_visibleImageRect_backingScaleFactor_pixelViewSize_zoomValue_pixelated_pageOverlayRenderOptions_cacheProvider_canvasColorSpace_renderContentSynchronously_overlayColors(dirtyRect: NSRect, page: MSImmutablePage, document: MSImmutableDocumentData, visibleImageRect: NSRect, backingScaleFactor: CGFloat, pixelViewSize: CGSize, zoomValue: CGFloat, pixelated: boolean, pageOverlayRenderOptions: MSPageOverlayRenderOptions, cacheProvider: any | null, canvasColorSpace: NSColorSpace, renderContentSynchronously: boolean, colors: MSOverlayColorSettings | null): void;
  beginFastZooming(): void;

  layer(): CALayer;
  renderingCacheProvider(): any;
  setRenderingCacheProvider(renderingCacheProvider: any): void;
  overlayRenderingDelegate(): any;
  setOverlayRenderingDelegate(overlayRenderingDelegate: any): void;
  hostView(): NSView;
  setHostView(hostView: NSView): void;
  hideOverlay(): boolean;
  setHideOverlay(hideOverlay: boolean): void;
}

declare interface IMSOverlayRenderingDelegate {
  renderOverlayInRect_context_pageOverlayRenderOptions(rect: NSRect, context: CGContextRef, pageOverlayRenderOptions: MSPageOverlayRenderOptions): void;
}

declare interface IMSTiledRendererHostView {
  scheduleRedraw(): void;
  driver(): MSRenderingDriver;
}

class MSWebPExporterAllocator<T extends MSWebPExporter> extends MSExporterAllocator<T> {}
declare class MSWebPExporter extends MSExporter {
  alloc<T extends MSWebPExporter>(): MSWebPExporterAllocator<T>;
}

class DrawingViewAllocator<T extends DrawingView> extends NSViewAllocator<T> {}
declare class DrawingView extends NSView {
  alloc<T extends DrawingView>(): DrawingViewAllocator<T>;
}

class DataProtocolAllocator<T extends DataProtocol> extends NSURLProtocolAllocator<T> {}
declare class DataProtocol extends NSURLProtocol {
  alloc<T extends DataProtocol>(): DataProtocolAllocator<T>;
  static dataFromLink_type_encoding(link: NSString | string, typeOut: NSString | string, encodingOut: NSString | string): NSData;
}

class _SVGBasicShapeAllocator<T extends _SVGBasicShape> extends SVGDrawableElementAllocator<T> {}
declare class _SVGBasicShape extends SVGDrawableElement {
  alloc<T extends _SVGBasicShape>(): _SVGBasicShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
}

class _SVGCircleShapeAllocator<T extends _SVGCircleShape> extends SVGBasicShapeAllocator<T> {}
declare class _SVGCircleShape extends SVGBasicShape {
  alloc<T extends _SVGCircleShape>(): _SVGCircleShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  cx(): number;
  setCx(cx: number): void;
  cy(): number;
  setCy(cy: number): void;
  r(): number;
  setR(r: number): void;
}

class _SVGClipPathAllocator<T extends _SVGClipPath> extends SVGGroupElementAllocator<T> {}
declare class _SVGClipPath extends SVGGroupElement {
  alloc<T extends _SVGClipPath>(): _SVGClipPathAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveAddClippingObject(object: any): void;
  primitiveRemoveClippingObject(object: any): void;

  clipping(): NSSet<any>;
  setClipping(clipping: NSSet<any>): void;
}

class _SVGDrawableElementAllocator<T extends _SVGDrawableElement> extends SVGElementAllocator<T> {}
declare class _SVGDrawableElement extends SVGElement {
  alloc<T extends _SVGDrawableElement>(): _SVGDrawableElementAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveSetClip(clip: any): void;
  primitiveSetFill(fill: any): void;
  primitiveSetFont(font: any): void;
  primitiveSetMask(mask: any): void;
  primitiveSetStroke(stroke: any): void;

  blendMode(): NSString;
  setBlendMode(blendMode: NSString | string): void;
  clips(): boolean;
  setClips(clips: boolean): void;
  hidden(): boolean;
  setHidden(hidden: boolean): void;
  opacity(): number;
  setOpacity(opacity: number): void;
  rect(): NSRect;
  setRect(rect: NSRect): void;
  transform(): NSAffineTransform;
  setTransform(transform: NSAffineTransform): void;
  clip(): SVGClipPath;
  setClip(clip: SVGClipPath): void;
  fill(): SVGFill;
  setFill(fill: SVGFill): void;
  font(): SVGFont;
  setFont(font: SVGFont): void;
  mask(): SVGMask;
  setMask(mask: SVGMask): void;
  stroke(): SVGStroke;
  setStroke(stroke: SVGStroke): void;
}

class _SVGElementAllocator<T extends _SVGElement> extends NSObjectAllocator<T> {}
declare class _SVGElement extends NSObject {
  alloc<T extends _SVGElement>(): _SVGElementAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveAddChildrenObject(object: any): void;
  primitiveRemoveChildrenObject(object: any): void;
  primitiveAddLinkedObject(object: any): void;
  primitiveRemoveLinkedObject(object: any): void;
  primitiveSetParent(parent: any): void;

  desc(): NSString;
  setDesc(desc: NSString | string): void;
  identifier(): NSString;
  setIdentifier(identifier: NSString | string): void;
  index(): number;
  setIndex(index: number): void;
  title(): NSString;
  setTitle(title: NSString | string): void;
  type(): NSString;
  setType(type: NSString | string): void;
  children(): NSSet<any>;
  setChildren(children: NSSet<any>): void;
  linked(): NSSet<any>;
  setLinked(linked: NSSet<any>): void;
  parent(): SVGElement;
  setParent(parent: SVGElement): void;
}

class _SVGEllipseShapeAllocator<T extends _SVGEllipseShape> extends SVGBasicShapeAllocator<T> {}
declare class _SVGEllipseShape extends SVGBasicShape {
  alloc<T extends _SVGEllipseShape>(): _SVGEllipseShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  cx(): number;
  setCx(cx: number): void;
  cy(): number;
  setCy(cy: number): void;
  rx(): number;
  setRx(rx: number): void;
  ry(): number;
  setRy(ry: number): void;
}

class _SVGFillAllocator<T extends _SVGFill> extends SVGElementAllocator<T> {}
declare class _SVGFill extends SVGElement {
  alloc<T extends _SVGFill>(): _SVGFillAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveSetGradient(gradient: any): void;
  primitiveSetPattern(pattern: any): void;
  primitiveAddUsedByObject(object: any): void;
  primitiveRemoveUsedByObject(object: any): void;

  color(): MSImmutableColor;
  setColor(color: MSImmutableColor): void;
  opacity(): number;
  setOpacity(opacity: number): void;
  windingrule(): NSString;
  setWindingrule(windingrule: NSString | string): void;
  gradient(): SVGGradient;
  setGradient(gradient: SVGGradient): void;
  pattern(): SVGPattern;
  setPattern(pattern: SVGPattern): void;
  usedBy(): NSSet<any>;
  setUsedBy(usedBy: NSSet<any>): void;
}

class _SVGFontAllocator<T extends _SVGFont> extends SVGElementAllocator<T> {}
declare class _SVGFont extends SVGElement {
  alloc<T extends _SVGFont>(): _SVGFontAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveAddUsedByObject(object: any): void;
  primitiveRemoveUsedByObject(object: any): void;

  family(): NSString;
  setFamily(family: NSString | string): void;
  size(): number;
  setSize(size: number): void;
  style(): NSString;
  setStyle(style: NSString | string): void;
  variant(): NSString;
  setVariant(variant: NSString | string): void;
  weight(): number;
  setWeight(weight: number): void;
  usedBy(): NSSet<any>;
  setUsedBy(usedBy: NSSet<any>): void;
}

class _SVGGradientAllocator<T extends _SVGGradient> extends SVGElementAllocator<T> {}
declare class _SVGGradient extends SVGElement {
  alloc<T extends _SVGGradient>(): _SVGGradientAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveAddLinkedFromObject(object: any): void;
  primitiveRemoveLinkedFromObject(object: any): void;
  primitiveSetLinkedTo(linkedTo: any): void;
  primitiveAddUsedByFillsObject(object: any): void;
  primitiveRemoveUsedByFillsObject(object: any): void;
  primitiveAddUsedByStrokesObject(object: any): void;
  primitiveRemoveUsedByStrokesObject(object: any): void;

  fromX(): number;
  setFromX(fromX: number): void;
  fromY(): number;
  setFromY(fromY: number): void;
  radial(): boolean;
  setRadial(radial: boolean): void;
  toX(): number;
  setToX(toX: number): void;
  toY(): number;
  setToY(toY: number): void;
  transform(): NSAffineTransform;
  setTransform(transform: NSAffineTransform): void;
  linkedFrom(): NSSet<any>;
  setLinkedFrom(linkedFrom: NSSet<any>): void;
  linkedTo(): SVGGradient;
  setLinkedTo(linkedTo: SVGGradient): void;
  usedByFills(): NSSet<any>;
  setUsedByFills(usedByFills: NSSet<any>): void;
  usedByStrokes(): NSSet<any>;
  setUsedByStrokes(usedByStrokes: NSSet<any>): void;
}

class _SVGGradientStopAllocator<T extends _SVGGradientStop> extends SVGElementAllocator<T> {}
declare class _SVGGradientStop extends SVGElement {
  alloc<T extends _SVGGradientStop>(): _SVGGradientStopAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  color(): MSImmutableColor;
  setColor(color: MSImmutableColor): void;
  position(): number;
  setPosition(position: number): void;
}

class _SVGGroupElementAllocator<T extends _SVGGroupElement> extends SVGDrawableElementAllocator<T> {}
declare class _SVGGroupElement extends SVGDrawableElement {
  alloc<T extends _SVGGroupElement>(): _SVGGroupElementAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
}

class _SVGImageAllocator<T extends _SVGImage> extends SVGDrawableElementAllocator<T> {}
declare class _SVGImage extends SVGDrawableElement {
  alloc<T extends _SVGImage>(): _SVGImageAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  image(): NSImage;
  setImage(image: NSImage): void;
}

class _SVGLineShapeAllocator<T extends _SVGLineShape> extends SVGBasicShapeAllocator<T> {}
declare class _SVGLineShape extends SVGBasicShape {
  alloc<T extends _SVGLineShape>(): _SVGLineShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  x1(): number;
  setX1(x1: number): void;
  x2(): number;
  setX2(x2: number): void;
  y1(): number;
  setY1(y1: number): void;
  y2(): number;
  setY2(y2: number): void;
}

class _SVGLinkAllocator<T extends _SVGLink> extends SVGDrawableElementAllocator<T> {}
declare class _SVGLink extends SVGDrawableElement {
  alloc<T extends _SVGLink>(): _SVGLinkAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveSetLink(link: any): void;

  link(): SVGElement;
  setLink(link: SVGElement): void;
}

class _SVGMaskAllocator<T extends _SVGMask> extends SVGGroupElementAllocator<T> {}
declare class _SVGMask extends SVGGroupElement {
  alloc<T extends _SVGMask>(): _SVGMaskAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveAddMaskingObject(object: any): void;
  primitiveRemoveMaskingObject(object: any): void;

  masking(): NSSet<any>;
  setMasking(masking: NSSet<any>): void;
}

class _SVGPathShapeAllocator<T extends _SVGPathShape> extends SVGDrawableElementAllocator<T> {}
declare class _SVGPathShape extends SVGDrawableElement {
  alloc<T extends _SVGPathShape>(): _SVGPathShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  closed(): boolean;
  setClosed(closed: boolean): void;
  path(): NSBezierPath;
  setPath(path: NSBezierPath): void;
}

class _SVGPatternAllocator<T extends _SVGPattern> extends SVGElementAllocator<T> {}
declare class _SVGPattern extends SVGElement {
  alloc<T extends _SVGPattern>(): _SVGPatternAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveAddUsedByFillsObject(object: any): void;
  primitiveRemoveUsedByFillsObject(object: any): void;
  primitiveAddUsedByStrokesObject(object: any): void;
  primitiveRemoveUsedByStrokesObject(object: any): void;

  height(): number;
  setHeight(height: number): void;
  patternUnits(): NSString;
  setPatternUnits(patternUnits: NSString | string): void;
  width(): number;
  setWidth(width: number): void;
  x(): number;
  setX(x: number): void;
  y(): number;
  setY(y: number): void;
  usedByFills(): NSSet<any>;
  setUsedByFills(usedByFills: NSSet<any>): void;
  usedByStrokes(): NSSet<any>;
  setUsedByStrokes(usedByStrokes: NSSet<any>): void;
}

class _SVGPolygonShapeAllocator<T extends _SVGPolygonShape> extends SVGPathShapeAllocator<T> {}
declare class _SVGPolygonShape extends SVGPathShape {
  alloc<T extends _SVGPolygonShape>(): _SVGPolygonShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
}

class _SVGRectangleShapeAllocator<T extends _SVGRectangleShape> extends SVGBasicShapeAllocator<T> {}
declare class _SVGRectangleShape extends SVGBasicShape {
  alloc<T extends _SVGRectangleShape>(): _SVGRectangleShapeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  cornerRadius(): number;
  setCornerRadius(cornerRadius: number): void;
}

class _SVGRootElementAllocator<T extends _SVGRootElement> extends SVGGroupElementAllocator<T> {}
declare class _SVGRootElement extends SVGGroupElement {
  alloc<T extends _SVGRootElement>(): _SVGRootElementAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  height(): number;
  setHeight(height: number): void;
  width(): number;
  setWidth(width: number): void;
}

class _SVGStrokeAllocator<T extends _SVGStroke> extends SVGElementAllocator<T> {}
declare class _SVGStroke extends SVGElement {
  alloc<T extends _SVGStroke>(): _SVGStrokeAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
  primitiveSetGradient(gradient: any): void;
  primitiveSetPattern(pattern: any): void;
  primitiveAddUsedByObject(object: any): void;
  primitiveRemoveUsedByObject(object: any): void;

  color(): MSImmutableColor;
  setColor(color: MSImmutableColor): void;
  dashes(): NSArray<any>;
  setDashes(dashes: NSArray<any> | any[]): void;
  linecap(): NSString;
  setLinecap(linecap: NSString | string): void;
  linejoin(): NSString;
  setLinejoin(linejoin: NSString | string): void;
  width(): number;
  setWidth(width: number): void;
  gradient(): SVGGradient;
  setGradient(gradient: SVGGradient): void;
  pattern(): SVGPattern;
  setPattern(pattern: SVGPattern): void;
  usedBy(): NSSet<any>;
  setUsedBy(usedBy: NSSet<any>): void;
}

class _SVGSymbolElementAllocator<T extends _SVGSymbolElement> extends SVGGroupElementAllocator<T> {}
declare class _SVGSymbolElement extends SVGGroupElement {
  alloc<T extends _SVGSymbolElement>(): _SVGSymbolElementAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;
}

class _SVGTextAllocator<T extends _SVGText> extends SVGDrawableElementAllocator<T> {}
declare class _SVGText extends SVGDrawableElement {
  alloc<T extends _SVGText>(): _SVGTextAllocator<T>;
  static propertyNames(): NSArray<any>;
  static relationshipNames(): NSArray<any>;
  static attributeNames(): NSArray<any>;

  adjustSpacingAndGlyphs(): boolean;
  setAdjustSpacingAndGlyphs(adjustSpacingAndGlyphs: boolean): void;
  anchor(): number;
  setAnchor(anchor: number): void;
  dx(): number;
  setDx(dx: number): void;
  dy(): number;
  setDy(dy: number): void;
  length(): number;
  setLength(length: number): void;
  rotate(): number;
  setRotate(rotate: number): void;
  text(): NSString;
  setText(text: NSString | string): void;
  x(): number;
  setX(x: number): void;
  y(): number;
  setY(y: number): void;
}

class SVGBasicShapeAllocator<T extends SVGBasicShape> extends _SVGBasicShapeAllocator<T> {}
declare class SVGBasicShape extends _SVGBasicShape {
  alloc<T extends SVGBasicShape>(): SVGBasicShapeAllocator<T>;
  shapeGroupForLayer(layer: MSLayer): MSShapeGroup;
}

class SVGCircleShapeAllocator<T extends SVGCircleShape> extends _SVGCircleShapeAllocator<T> {}
declare class SVGCircleShape extends _SVGCircleShape {
  alloc<T extends SVGCircleShape>(): SVGCircleShapeAllocator<T>;
}

class SVGClipPathAllocator<T extends SVGClipPath> extends _SVGClipPathAllocator<T> {}
declare class SVGClipPath extends _SVGClipPath {
  alloc<T extends SVGClipPath>(): SVGClipPathAllocator<T>;
}

class SVGDrawableElementAllocator<T extends SVGDrawableElement> extends _SVGDrawableElementAllocator<T> {}
declare class SVGDrawableElement extends _SVGDrawableElement {
  alloc<T extends SVGDrawableElement>(): SVGDrawableElementAllocator<T>;
  dontCollapse(): boolean;
  processStyles_parent(xml: NSXMLElement, parent: SVGDrawableElement): void;
  emptyLayerWithParentLayer(parentLayer: MSLayerGroup): MSLayer;
  applyEffectsToLayer(layer: MSLayer): void;

  deferredClipping(): NSXMLElement;
  setDeferredClipping(deferredClipping: NSXMLElement): void;
}

class SVGElementAllocator<T extends SVGElement> extends _SVGElementAllocator<T> {
  initWithImporter_xml(importer: SVGImporter, xml: NSXMLElement): T;
}
declare class SVGElement extends _SVGElement {
  alloc<T extends SVGElement>(): SVGElementAllocator<T>;
  static elementOfType_xml_importer_parent(type: NSString | string, xml: NSXMLElement, importer: SVGImporter, parent: SVGElement): SVGElement;
  elementOfType_xml_parent(type: NSString | string, xml: NSXMLElement, parent: SVGElement): SVGElement;
  process(): void;
  processSelf(xml: NSXMLElement): void;
  processIdentifier(xml: NSXMLElement): void;
  processStyles(): void;
  processChildren(xml: NSXMLElement): void;
  processChildren_startingAtIndex(xml: NSXMLElement, index: NSUInteger): void;
  processChild_index(xml: NSXMLElement, index: NSUInteger): NSUInteger;
  svgDescription(): NSString;
  svgAttributesDescription(): NSString;
  addReferenceToIdentifier_type_property(identifier: NSString | string, type: NSString | string, property: NSString | string): void;
  resolvedValue_forProperty(value: SVGElement, property: NSString | string): void;
  name(): NSString;
  containsDrawables(): boolean;
  drawableParent(): SVGDrawableElement;
  clippingParent(): SVGDrawableElement;
  relativeURLForLink(link: NSString | string): NSURL;
  styleAttributesForElement_defaults(xml: NSXMLElement, defaults: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  isDescendantOf(element: SVGElement): boolean;
  makeLayerWithParentLayer_progress(parentLayer: MSLayerGroup, progress: BCVoidBlock): MSLayer;
  nameLayer(layer: MSLayer): void;
  adjustSizeForChildrenOfLayer(layer: MSLayer): void;

  xml(): NSXMLElement;
  setXml(xml: NSXMLElement): void;
  importer(): SVGImporter;
  effectiveLayerName(): NSString;
}

class SVGEllipseShapeAllocator<T extends SVGEllipseShape> extends _SVGEllipseShapeAllocator<T> {}
declare class SVGEllipseShape extends _SVGEllipseShape {
  alloc<T extends SVGEllipseShape>(): SVGEllipseShapeAllocator<T>;
}

class SVGFillAllocator<T extends SVGFill> extends _SVGFillAllocator<T> {}
declare class SVGFill extends _SVGFill {
  alloc<T extends SVGFill>(): SVGFillAllocator<T>;
  static fillForXML_element_parent(xml: NSXMLElement, element: SVGElement, parent: SVGDrawableElement): SVGFill;
}

class SVGFontAllocator<T extends SVGFont> extends _SVGFontAllocator<T> {}
declare class SVGFont extends _SVGFont {
  alloc<T extends SVGFont>(): SVGFontAllocator<T>;
  static fontForXML_element_parent(xml: NSXMLElement, element: SVGElement, parent: SVGDrawableElement): SVGFont;
  representedFont(): NSFont;
}

class SVGGradientAllocator<T extends SVGGradient> extends _SVGGradientAllocator<T> {}
declare class SVGGradient extends _SVGGradient {
  alloc<T extends SVGGradient>(): SVGGradientAllocator<T>;
  from(): NSPoint;
  to(): NSPoint;
  stopsElements(): NSArray<any>;

  usesAbsoluteUnits(): boolean;
}

class SVGGradientStopAllocator<T extends SVGGradientStop> extends _SVGGradientStopAllocator<T> {}
declare class SVGGradientStop extends _SVGGradientStop {
  alloc<T extends SVGGradientStop>(): SVGGradientStopAllocator<T>;
}

class SVGGroupElementAllocator<T extends SVGGroupElement> extends _SVGGroupElementAllocator<T> {}
declare class SVGGroupElement extends _SVGGroupElement {
  alloc<T extends SVGGroupElement>(): SVGGroupElementAllocator<T>;
}

class SVGImageAllocator<T extends SVGImage> extends _SVGImageAllocator<T> {}
declare class SVGImage extends _SVGImage {
  alloc<T extends SVGImage>(): SVGImageAllocator<T>;
}

class SVGLineShapeAllocator<T extends SVGLineShape> extends _SVGLineShapeAllocator<T> {}
declare class SVGLineShape extends _SVGLineShape {
  alloc<T extends SVGLineShape>(): SVGLineShapeAllocator<T>;
}

class SVGLinkAllocator<T extends SVGLink> extends _SVGLinkAllocator<T> {}
declare class SVGLink extends _SVGLink {
  alloc<T extends SVGLink>(): SVGLinkAllocator<T>;
}

class SVGMaskAllocator<T extends SVGMask> extends _SVGMaskAllocator<T> {}
declare class SVGMask extends _SVGMask {
  alloc<T extends SVGMask>(): SVGMaskAllocator<T>;
}

class SVGPathShapeAllocator<T extends SVGPathShape> extends _SVGPathShapeAllocator<T> {}
declare class SVGPathShape extends _SVGPathShape {
  alloc<T extends SVGPathShape>(): SVGPathShapeAllocator<T>;
}

class SVGPolygonShapeAllocator<T extends SVGPolygonShape> extends _SVGPolygonShapeAllocator<T> {}
declare class SVGPolygonShape extends _SVGPolygonShape {
  alloc<T extends SVGPolygonShape>(): SVGPolygonShapeAllocator<T>;
}

class SVGRectangleShapeAllocator<T extends SVGRectangleShape> extends _SVGRectangleShapeAllocator<T> {}
declare class SVGRectangleShape extends _SVGRectangleShape {
  alloc<T extends SVGRectangleShape>(): SVGRectangleShapeAllocator<T>;
}

class SVGRootElementAllocator<T extends SVGRootElement> extends _SVGRootElementAllocator<T> {}
declare class SVGRootElement extends _SVGRootElement {
  alloc<T extends SVGRootElement>(): SVGRootElementAllocator<T>;
}

class SVGStrokeAllocator<T extends SVGStroke> extends _SVGStrokeAllocator<T> {}
declare class SVGStroke extends _SVGStroke {
  alloc<T extends SVGStroke>(): SVGStrokeAllocator<T>;
  static strokeForXML_element_parent(xml: NSXMLElement, element: SVGElement, parent: SVGDrawableElement): SVGStroke;
}

class SVGSymbolElementAllocator<T extends SVGSymbolElement> extends _SVGSymbolElementAllocator<T> {}
declare class SVGSymbolElement extends _SVGSymbolElement {
  alloc<T extends SVGSymbolElement>(): SVGSymbolElementAllocator<T>;
}

class SVGTextAllocator<T extends SVGText> extends _SVGTextAllocator<T> {}
declare class SVGText extends _SVGText {
  alloc<T extends SVGText>(): SVGTextAllocator<T>;
}

class SVGCSSParserAllocator<T extends SVGCSSParser> extends NSObjectAllocator<T> {}
declare class SVGCSSParser extends NSObject {
  alloc<T extends SVGCSSParser>(): SVGCSSParserAllocator<T>;
  static parseCSSAttributeList(cssAttributes: NSString | string): NSDictionary<any, any>;
  static mergeStylesheet_withExisting(styleSheet: NSString | string, existing: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
}

class SVGDescriptionAllocator<T extends SVGDescription> extends SVGElementAllocator<T> {}
declare class SVGDescription extends SVGElement {
  alloc<T extends SVGDescription>(): SVGDescriptionAllocator<T>;
}

declare enum SVGExportOptions {
  SVGExportOptionsIncludeHeader = 1,
  SVGExportOptionsCompact = 0,
  SVGExportOptionsDefault,
}

class SVGImporterAllocator<T extends SVGImporter> extends NSObjectAllocator<T> {
  initWithURL(url: NSURL): T;
  initWithData(data: NSData): T;
  initWithXMLString(string: NSString | string): T;
}
declare class SVGImporter extends NSObject {
  alloc<T extends SVGImporter>(): SVGImporterAllocator<T>;
  importObjectGraph(): SVGElement;
  addedDrawableElement(element: SVGDrawableElement): void;
  drawableElementCount(): NSUInteger;
  elementOfType_xml_parent(type: NSString | string, xml: NSXMLElement, parent: SVGElement): SVGElement;
  registerElementWithIdentifier_type_element(identifier: NSString | string, type: NSString | string, element: SVGElement): void;
  addReferenceToIdentifier_type_target_property(identifier: NSString | string, type: NSString | string, target: any, property: NSString | string): void;
  relativeURLForLink(link: NSString | string): NSURL;
  registerStylesheet(stylesheet: NSString | string): void;
  styleAttributesForElement_defaults(xml: NSXMLElement, defaults: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;

  documentWidth(): CGFloat;
  documentHeight(): CGFloat;
  scaleValue(): CGFloat;
  setScaleValue(scaleValue: CGFloat): void;
}

class SVGPathInterpreterAllocator<T extends SVGPathInterpreter> extends NSObjectAllocator<T> {}
declare class SVGPathInterpreter extends NSObject {
  alloc<T extends SVGPathInterpreter>(): SVGPathInterpreterAllocator<T>;
  bezierPathFromCommands_isPathClosed(commands: NSString | string, isClosed: boolean): NSBezierPath;
  bezierPathFromPoints(points: NSString | string): NSBezierPath;
}

class SVGPathScannerAllocator<T extends SVGPathScanner> extends NSObjectAllocator<T> {
  initWithString(string: NSString | string): T;
}
declare class SVGPathScanner extends NSObject {
  alloc<T extends SVGPathScanner>(): SVGPathScannerAllocator<T>;
  nextCommand(): string;
  nextFloat(): CGFloat;

  scanner(): NSScanner;
  setScanner(scanner: NSScanner): void;
}

class SVGStyleAllocator<T extends SVGStyle> extends SVGElementAllocator<T> {}
declare class SVGStyle extends SVGElement {
  alloc<T extends SVGStyle>(): SVGStyleAllocator<T>;
}

class SVGTitleAllocator<T extends SVGTitle> extends SVGElementAllocator<T> {}
declare class SVGTitle extends SVGElement {
  alloc<T extends SVGTitle>(): SVGTitleAllocator<T>;
}

class SVGTransformImporterAllocator<T extends SVGTransformImporter> extends NSObjectAllocator<T> {}
declare class SVGTransformImporter extends NSObject {
  alloc<T extends SVGTransformImporter>(): SVGTransformImporterAllocator<T>;
  static transformFromString(aString: NSString | string): NSAffineTransform;
  static transformFromName_components(name: NSString | string, paramString: NSString | string): NSAffineTransform;
  static translateTransformFromComponents(params: NSArray<any> | any[]): NSAffineTransform;
  static rotateTransformFromComponents(params: NSArray<any> | any[]): NSAffineTransform;
  static matrixTransformFromComponents(params: NSArray<any> | any[]): NSAffineTransform;
}

class MSExportRendererWithSVGSupportAllocator<T extends MSExportRendererWithSVGSupport> extends MSExporterAllocator<T> {}
declare class MSExportRendererWithSVGSupport extends MSExporter {
  alloc<T extends MSExportRendererWithSVGSupport>(): MSExportRendererWithSVGSupportAllocator<T>;
}

class MSSVGBlendModeAllocator<T extends MSSVGBlendMode> extends NSObjectAllocator<T> {}
declare class MSSVGBlendMode extends NSObject {
  alloc<T extends MSSVGBlendMode>(): MSSVGBlendModeAllocator<T>;
  static sketchBlendModeFromSVG(svgValue: NSString | string): MSBlendMode;
  static svgFromSketchBlendMode(blendMode: MSBlendMode): NSString;
}

class MSSVGColorMatrixAllocator<T extends MSSVGColorMatrix> extends MSSVGfeFilterPrimitiveAllocator<T> {}
declare class MSSVGColorMatrix extends MSSVGfeFilterPrimitive {
  alloc<T extends MSSVGColorMatrix>(): MSSVGColorMatrixAllocator<T>;
  static colorMatrixForColor(color: MSImmutableColor): MSSVGColorMatrix;

  in(): NSString;
  setIn(in_: NSString | string): void;
  type(): NSString;
  setType(type: NSString | string): void;
  values(): NSString;
  setValues(values: NSString | string): void;
}

class MSSVGCompositeAllocator<T extends MSSVGComposite> extends MSSVGfeFilterPrimitiveAllocator<T> {}
declare class MSSVGComposite extends MSSVGfeFilterPrimitive {
  alloc<T extends MSSVGComposite>(): MSSVGCompositeAllocator<T>;

  in(): NSString;
  setIn(in_: NSString | string): void;
  in2(): NSString;
  setIn2(in2: NSString | string): void;
  operator(): NSString;
  setOperator(operator: NSString | string): void;
  k1(): CGFloat;
  setK1(k1: CGFloat): void;
  k2(): CGFloat;
  setK2(k2: CGFloat): void;
  k3(): CGFloat;
  setK3(k3: CGFloat): void;
  k4(): CGFloat;
  setK4(k4: CGFloat): void;
}

class MSSVGFilterAllocator<T extends MSSVGFilter> extends MSXMLElementWrapperAllocator<T> {}
declare class MSSVGFilter extends MSXMLElementWrapper {
  alloc<T extends MSSVGFilter>(): MSSVGFilterAllocator<T>;
  static filter(): MSSVGFilter;
  addFilterItem(filterItem: NSXMLElement): void;
  addFilterOutput(string: NSString | string): void;
  close(): void;

  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  filterRes(): NSString;
  setFilterRes(filterRes: NSString | string): void;
  filterUnits(): NSString;
  setFilterUnits(filterUnits: NSString | string): void;
  primitiveUnits(): NSString;
  setPrimitiveUnits(primitiveUnits: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}

class MSSVGGaussianBlurAllocator<T extends MSSVGGaussianBlur> extends MSSVGfeFilterPrimitiveAllocator<T> {}
declare class MSSVGGaussianBlur extends MSSVGfeFilterPrimitive {
  alloc<T extends MSSVGGaussianBlur>(): MSSVGGaussianBlurAllocator<T>;

  in(): NSString;
  setIn(in_: NSString | string): void;
  stdDeviation(): NSString;
  setStdDeviation(stdDeviation: NSString | string): void;
}

class MSSVGImageWrapperAllocator<T extends MSSVGImageWrapper> extends MSXMLElementWrapperAllocator<T> {}
declare class MSSVGImageWrapper extends MSXMLElementWrapper {
  alloc<T extends MSSVGImageWrapper>(): MSSVGImageWrapperAllocator<T>;

  externalResourcesRequired(): NSString;
  setExternalResourcesRequired(externalResourcesRequired: NSString | string): void;
  preserveAspectRatio(): NSString;
  setPreserveAspectRatio(preserveAspectRatio: NSString | string): void;
  transform(): NSString;
  setTransform(transform: NSString | string): void;
  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}

class MSSVGMergeAllocator<T extends MSSVGMerge> extends MSSVGfeFilterPrimitiveAllocator<T> {}
declare class MSSVGMerge extends MSSVGfeFilterPrimitive {
  alloc<T extends MSSVGMerge>(): MSSVGMergeAllocator<T>;
  addMergeNodeNamed(name: NSString | string): void;
}

class MSSVGMergeNodeAllocator<T extends MSSVGMergeNode> extends MSXMLElementWrapperAllocator<T> {}
declare class MSSVGMergeNode extends MSXMLElementWrapper {
  alloc<T extends MSSVGMergeNode>(): MSSVGMergeNodeAllocator<T>;
  static mergeNodeNamed(nodeName: NSString | string): MSSVGMergeNode;

  in(): NSString;
  setIn(in_: NSString | string): void;
}

class MSSVGMorphologyAllocator<T extends MSSVGMorphology> extends MSSVGfeFilterPrimitiveAllocator<T> {}
declare class MSSVGMorphology extends MSSVGfeFilterPrimitive {
  alloc<T extends MSSVGMorphology>(): MSSVGMorphologyAllocator<T>;

  in(): NSString;
  setIn(in_: NSString | string): void;
  operator(): NSString;
  setOperator(operator: NSString | string): void;
  radius(): CGFloat;
  setRadius(radius: CGFloat): void;
}

class MSSVGOffsetAllocator<T extends MSSVGOffset> extends MSSVGfeFilterPrimitiveAllocator<T> {}
declare class MSSVGOffset extends MSSVGfeFilterPrimitive {
  alloc<T extends MSSVGOffset>(): MSSVGOffsetAllocator<T>;

  in(): NSString;
  setIn(in_: NSString | string): void;
  dx(): CGFloat;
  setDx(dx: CGFloat): void;
  dy(): CGFloat;
  setDy(dy: CGFloat): void;
}

class MSSVGPatternWrapperAllocator<T extends MSSVGPatternWrapper> extends MSXMLElementWrapperAllocator<T> {}
declare class MSSVGPatternWrapper extends MSXMLElementWrapper {
  alloc<T extends MSSVGPatternWrapper>(): MSSVGPatternWrapperAllocator<T>;

  preserveAspectRatio(): NSString;
  setPreserveAspectRatio(preserveAspectRatio: NSString | string): void;
  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  patternUnits(): NSString;
  setPatternUnits(patternUnits: NSString | string): void;
  patternContentUnits(): NSString;
  setPatternContentUnits(patternContentUnits: NSString | string): void;
  patternTransform(): NSString;
  setPatternTransform(patternTransform: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}

class MSSVGUseWrapperAllocator<T extends MSSVGUseWrapper> extends MSXMLElementWrapperAllocator<T> {}
declare class MSSVGUseWrapper extends MSXMLElementWrapper {
  alloc<T extends MSSVGUseWrapper>(): MSSVGUseWrapperAllocator<T>;

  externalResourcesRequired(): NSString;
  setExternalResourcesRequired(externalResourcesRequired: NSString | string): void;
  transform(): NSString;
  setTransform(transform: NSString | string): void;
  x(): NSString;
  setX(x: NSString | string): void;
  y(): NSString;
  setY(y: NSString | string): void;
  width(): NSString;
  setWidth(width: NSString | string): void;
  height(): NSString;
  setHeight(height: NSString | string): void;
  href(): NSString;
  setHref(href: NSString | string): void;
}

class MSSVGfeFilterPrimitiveAllocator<T extends MSSVGfeFilterPrimitive> extends MSXMLElementWrapperAllocator<T> {}
declare class MSSVGfeFilterPrimitive extends MSXMLElementWrapper {
  alloc<T extends MSSVGfeFilterPrimitive>(): MSSVGfeFilterPrimitiveAllocator<T>;
  static filter(): MSSVGfeFilterPrimitive;

  result(): NSString;
  setResult(result: NSString | string): void;
}

class MSXMLElementWrapperAllocator<T extends MSXMLElementWrapper> extends NSObjectAllocator<T> {
  initWithName(elementName: NSString | string): T;
  initWithElement(element: NSXMLElement): T;
}
declare class MSXMLElementWrapper extends NSObject {
  alloc<T extends MSXMLElementWrapper>(): MSXMLElementWrapperAllocator<T>;
  static elementName(): NSString;
  static element(): MSXMLElementWrapper;
  attributeStringForKey(key: NSString | string): NSString;
  setAttributeString_forKey(value: NSString | string, key: NSString | string): void;
  addChild(child: NSXMLNode): void;
  addChildWrapper(child: MSXMLElementWrapper): void;

  element(): NSXMLElement;
  svgId(): NSString;
  setSvgId(svgId: NSString | string): void;
  svgClass(): NSString;
  setSvgClass(svgClass: NSString | string): void;
  style(): NSString;
  setStyle(style: NSString | string): void;
}

class SVGPatternAllocator<T extends SVGPattern> extends _SVGPatternAllocator<T> {}
declare class SVGPattern extends _SVGPattern {
  alloc<T extends SVGPattern>(): SVGPatternAllocator<T>;

  imageData(): MSImageData;
  scale(): CGFloat;
  sketchPatternFillType(): MSPatternFillType;
}

class SketchSVGExporterAllocator<T extends SketchSVGExporter> extends NSObjectAllocator<T> {
  initWithImmutableDocument_exportRect_layerIDs_includeBackground(immutableDocument: MSImmutableDocumentData, exportRect: NSRect, layerIDs: NSSet<any>, includeBackground: boolean): T;
  initWithName_exportRequest(name: NSString | string, request: MSExportRequest): T;
}
declare class SketchSVGExporter extends NSObject {
  alloc<T extends SketchSVGExporter>(): SketchSVGExporterAllocator<T>;
  exportLayers(layers: NSArray<any> | any[]): NSData;
  pushParent(layer: MSImmutableLayer): void;
  popParent(): MSImmutableLayer;
  parentForLayer(layer: any): MSImmutableLayer;
  performWithParent_block(layer: MSImmutableLayer, block: BCVoidBlock): void;
  ancestorsForLayer(layer: any): NSArray<any>;
  drawSymbolInstance_inBlock(instance: MSImmutableSymbolInstance, block: BCVoidBlock): void;
  isDrawingSymbol(): boolean;
  addDefinitionWithName_children_attributes(name: NSString | string, children: NSArray<any> | any[], attributes: NSArray<any> | any[]): NSXMLElement;
  addGradient_inRect(gradient: MSImmutableGradient, rect: MSImmutableRect): void;
  gradientElement_inRect(gradient: MSImmutableGradient, rect: MSImmutableRect): NSXMLElement;
  uniqueIDForElementWithName(name: NSString | string): NSString;
  beginFilterGroup(): MSSVGFilter;
  endFilterGroup(): boolean;
  layerIsIncluded(layer: MSImmutableLayer): boolean;

  exportBounds(): NSRect;
  mask(): NSString;
  setMask(mask: NSString | string): void;
  currentShapeDef(): NSString;
  setCurrentShapeDef(currentShapeDef: NSString | string): void;
  document(): MSImmutableDocumentData;
  currentFilterGroup(): MSSVGFilter;
  currentSymbolInstance(): MSImmutableSymbolInstance;
  includeArtboardBackground(): boolean;
}

class BCSketchToolRunnerAllocator<T extends BCSketchToolRunner> extends BCToolRunnerAllocator<T> {
  initWithSketchToolURL_maximumConcurrentOperations(toolURL: NSURL, maxConcurrency: NSInteger): T;
}
declare class BCSketchToolRunner extends BCToolRunner {
  alloc<T extends BCSketchToolRunner>(): BCSketchToolRunnerAllocator<T>;
  exportPreviewImageForDocumentAtURL_additionalArguments_intoURL_completionHandler(url: NSURL, additionalArguments: NSArray<any> | any[], previewImageURL: NSURL, handler: MSDocumentPreviewImageHandler): void;

  sketchToolURL(): NSURL;
}

class BCSTCommandAllocator<T extends BCSTCommand> extends ECCommandLineCommandAllocator<T> {}
declare class BCSTCommand extends ECCommandLineCommand {
  alloc<T extends BCSTCommand>(): BCSTCommandAllocator<T>;
  processDocumentsAtPaths_engine(paths: NSArray<any> | any[], engine: ECCommandLineEngine): ECCommandLineResult;
  processDocumentURL_engine(documentURL: NSURL, engine: ECCommandLineEngine): ECCommandLineResult;
  processItemsForPage_engine(page: MSPage, engine: ECCommandLineEngine): ECCommandLineResult;
  documentDataForURL_engine(url: NSURL, engine: ECCommandLineEngine): MSDocumentData;
  documentForURL_engine(url: NSURL, engine: ECCommandLineEngine): MSDocumentReader;
  pagesForURL_engine(url: NSURL, engine: ECCommandLineEngine): NSArray<any>;
  scalesToUseForSlice_scales(slice: MSSliceLayer, scales: NSArray<any> | any[]): NSArray<any>;
  suffixForScale(scale: CGFloat): NSString;
  specifiedItemsWithEngine(engine: ECCommandLineEngine): NSArray<any>;
  filteredArtboardsForPage_engine(page: MSPage, engine: ECCommandLineEngine): NSArray<any>;
}

declare enum BCSTErrorCode {
  BCSTNoError,
  BCSTExportFailed,
  BCSTBadBoundsFormat,
  BCSTDocumentTooNew,
  BCSTUnknownFolderType,
  BCSTMissingReleaseNotes,
  BCSTFailedToLaunchSketch,
  BCSTTimedOutWaitingForSketch,
}

class BCSTDumpCommandAllocator<T extends BCSTDumpCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTDumpCommand extends BCSTCommand {
  alloc<T extends BCSTDumpCommand>(): BCSTDumpCommandAllocator<T>;
}

class BCSTEngineDelegateAllocator<T extends BCSTEngineDelegate> extends NSObjectAllocator<T> {}
declare class BCSTEngineDelegate extends NSObject implements IECCommandLineEngineDelegate {
  alloc<T extends BCSTEngineDelegate>(): BCSTEngineDelegateAllocator<T>;
  engineDidFinishLaunching(engine: ECCommandLineEngine): void;
  engine_willProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
  engine_didProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
  engineDidFinishLaunching(engine: ECCommandLineEngine): void;
  engine_willProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;
  engine_didProcessCommands(engine: ECCommandLineEngine, commands: NSArray<any> | any[]): void;

  resources(): NSBundle;
  setResources(resources: NSBundle): void;
}

class BCSTExportArtboardsCommandAllocator<T extends BCSTExportArtboardsCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTExportArtboardsCommand extends BCSTCommand {
  alloc<T extends BCSTExportArtboardsCommand>(): BCSTExportArtboardsCommandAllocator<T>;
}

class BCSTExportLayersCommandAllocator<T extends BCSTExportLayersCommand> extends BCSTExportSlicesCommandAllocator<T> {}
declare class BCSTExportLayersCommand extends BCSTExportSlicesCommand {
  alloc<T extends BCSTExportLayersCommand>(): BCSTExportLayersCommandAllocator<T>;
}

class BCSTExportPagesCommandAllocator<T extends BCSTExportPagesCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTExportPagesCommand extends BCSTCommand {
  alloc<T extends BCSTExportPagesCommand>(): BCSTExportPagesCommandAllocator<T>;
}

class BCSTExportPreviewCommandAllocator<T extends BCSTExportPreviewCommand> extends BCSTExportPagesCommandAllocator<T> {}
declare class BCSTExportPreviewCommand extends BCSTExportPagesCommand {
  alloc<T extends BCSTExportPreviewCommand>(): BCSTExportPreviewCommandAllocator<T>;
}

class BCSTExportSlicesCommandAllocator<T extends BCSTExportSlicesCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTExportSlicesCommand extends BCSTCommand {
  alloc<T extends BCSTExportSlicesCommand>(): BCSTExportSlicesCommandAllocator<T>;
}

class BCSTListArtboardsCommandAllocator<T extends BCSTListArtboardsCommand> extends BCSTListCommandAllocator<T> {}
declare class BCSTListArtboardsCommand extends BCSTListCommand {
  alloc<T extends BCSTListArtboardsCommand>(): BCSTListArtboardsCommandAllocator<T>;
}

class BCSTListCommandAllocator<T extends BCSTListCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTListCommand extends BCSTCommand {
  alloc<T extends BCSTListCommand>(): BCSTListCommandAllocator<T>;
  itemsName(): NSString;
  itemsToListFromPages_engine(pages: NSArray<any> | any[], engine: ECCommandLineEngine): NSArray<any>;
  itemsToListFromPage_engine(page: MSPage, engine: ECCommandLineEngine): NSArray<any>;
  infoForPage_engine(page: MSPage, engine: ECCommandLineEngine): any;
  infoForItem_engine(item: any, engine: ECCommandLineEngine): NSDictionary<any, any>;
  safeName(name: NSString | string): NSString;
  rectDictionary(rect: NSRect): NSDictionary<any, any>;
  supportedFormats(): NSArray<any>;
}

class BCSTListFormatsCommandAllocator<T extends BCSTListFormatsCommand> extends BCSTListCommandAllocator<T> {}
declare class BCSTListFormatsCommand extends BCSTListCommand {
  alloc<T extends BCSTListFormatsCommand>(): BCSTListFormatsCommandAllocator<T>;
}

class BCSTListLayersCommandAllocator<T extends BCSTListLayersCommand> extends BCSTListSlicesCommandAllocator<T> {}
declare class BCSTListLayersCommand extends BCSTListSlicesCommand {
  alloc<T extends BCSTListLayersCommand>(): BCSTListLayersCommandAllocator<T>;
}

class BCSTListPagesCommandAllocator<T extends BCSTListPagesCommand> extends BCSTListCommandAllocator<T> {}
declare class BCSTListPagesCommand extends BCSTListCommand {
  alloc<T extends BCSTListPagesCommand>(): BCSTListPagesCommandAllocator<T>;
}

class BCSTListSlicesCommandAllocator<T extends BCSTListSlicesCommand> extends BCSTListCommandAllocator<T> {}
declare class BCSTListSlicesCommand extends BCSTListCommand {
  alloc<T extends BCSTListSlicesCommand>(): BCSTListSlicesCommandAllocator<T>;
}

class BCSTMetadataCommandAllocator<T extends BCSTMetadataCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTMetadataCommand extends BCSTCommand {
  alloc<T extends BCSTMetadataCommand>(): BCSTMetadataCommandAllocator<T>;
}

class BCSTRunCommandAllocator<T extends BCSTRunCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTRunCommand extends BCSTCommand {
  alloc<T extends BCSTRunCommand>(): BCSTRunCommandAllocator<T>;

  waitForTermination(): boolean;
  setWaitForTermination(waitForTermination: boolean): void;
}

class BCSTShowCommandAllocator<T extends BCSTShowCommand> extends BCSTCommandAllocator<T> {}
declare class BCSTShowCommand extends BCSTCommand {
  alloc<T extends BCSTShowCommand>(): BCSTShowCommandAllocator<T>;
}

class TerminationListenerAllocator<T extends TerminationListener> extends NSObjectAllocator<T> {
  initWithProcessIdentifier(processIdentifier: NSNumber | number): T;
}
declare class TerminationListener extends NSObject {
  alloc<T extends TerminationListener>(): TerminationListenerAllocator<T>;
  startListeningWithCompletion(completionBlock: Block): void;

  terminated(): boolean;
}

class SUAppcastAllocator<T extends SUAppcast> extends NSObjectAllocator<T> {}
declare class SUAppcast extends NSObject implements INSURLDownloadDelegate {
  alloc<T extends SUAppcast>(): SUAppcastAllocator<T>;
  fetchAppcastFromURL_inBackground_completionBlock(url: NSURL, bg: boolean, err: Block): void;
  copyWithoutDeltaUpdates(): SUAppcast;
  parseAppcastItemsFromXMLFile_error(appcastFile: NSURL, errorp: NSError): NSArray<any>;
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;

  userAgentString(): NSString;
  setUserAgentString(userAgentString: NSString | string): void;
  httpHeaders(): NSDictionary<any, any>;
  setHttpHeaders(httpHeaders: NSDictionary<any, any> | {[key: string]: any}): void;
  items(): NSArray<any>;
}

class SUAppcastItemAllocator<T extends SUAppcastItem> extends NSObjectAllocator<T> {
  initWithDictionary(dict: NSDictionary<any, any> | {[key: string]: any}): T;
  initWithDictionary_failureReason(dict: NSDictionary<any, any> | {[key: string]: any}, error: NSString | string): T;
}
declare class SUAppcastItem extends NSObject {
  alloc<T extends SUAppcastItem>(): SUAppcastItemAllocator<T>;
  infoURL(): NSURL;

  title(): NSString;
  dateString(): NSString;
  itemDescription(): NSString;
  releaseNotesURL(): NSURL;
  DSASignature(): NSString;
  minimumSystemVersion(): NSString;
  maximumSystemVersion(): NSString;
  fileURL(): NSURL;
  contentLength(): number;
  versionString(): NSString;
  osString(): NSString;
  displayVersionString(): NSString;
  deltaUpdates(): NSDictionary<any, any>;
  infoURL(): NSURL;
  deltaUpdate(): boolean;
  criticalUpdate(): boolean;
  macOsUpdate(): boolean;
  informationOnlyUpdate(): boolean;
  propertiesDictionary(): NSDictionary<any, any>;
}

class SUApplicationInfoAllocator<T extends SUApplicationInfo> extends NSObjectAllocator<T> {}
declare class SUApplicationInfo extends NSObject {
  alloc<T extends SUApplicationInfo>(): SUApplicationInfoAllocator<T>;
  static isBackgroundApplication(application: NSApplication): boolean;
  static bestIconForHost(host: SUHost): NSImage;
}

class SUAutomaticUpdateAlertAllocator<T extends SUAutomaticUpdateAlert> extends NSWindowControllerAllocator<T> {
  initWithAppcastItem_host_completionBlock(item: SUAppcastItem, hostBundle: SUHost, c: Block): T;
}
declare class SUAutomaticUpdateAlert extends NSWindowController {
  alloc<T extends SUAutomaticUpdateAlert>(): SUAutomaticUpdateAlertAllocator<T>;
  installNowsender(): IBAction;
  installLatersender(): IBAction;
  doNotInstallsender(): IBAction;
}

declare enum SUAutomaticInstallationChoice {
  SUInstallNowChoice,
  SUInstallLaterChoice,
  SUDoNotInstallChoice,
}

class SUAutomaticUpdateDriverAllocator<T extends SUAutomaticUpdateDriver> extends SUBasicUpdateDriverAllocator<T> {}
declare class SUAutomaticUpdateDriver extends SUBasicUpdateDriver {
  alloc<T extends SUAutomaticUpdateDriver>(): SUAutomaticUpdateDriverAllocator<T>;
}

class SUBasicUpdateDriverAllocator<T extends SUBasicUpdateDriver> extends SUUpdateDriverAllocator<T> {}
declare class SUBasicUpdateDriver extends SUUpdateDriver implements INSURLDownloadDelegate {
  alloc<T extends SUBasicUpdateDriver>(): SUBasicUpdateDriverAllocator<T>;
  checkForUpdatesAtURL_host(URL: NSURL, host: SUHost): void;
  isItemNewer(ui: SUAppcastItem): boolean;
  static hostSupportsItem(ui: SUAppcastItem): boolean;
  itemContainsSkippedVersion(ui: SUAppcastItem): boolean;
  itemContainsValidUpdate(ui: SUAppcastItem): boolean;
  appcastDidFinishLoading(ac: SUAppcast): void;
  didFindValidUpdate(): void;
  didNotFindUpdate(): void;
  downloadUpdate(): void;
  download_decideDestinationWithSuggestedFilename(d: NSURLDownload, name: NSString | string): void;
  downloadDidFinish(d: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
  extractUpdate(): void;
  failedToApplyDeltaUpdate(): void;
  unarchiver_extractedProgress(ua: any, progress: number): void;
  unarchiverDidFinish(ua: any): void;
  installWithToolAndRelaunch(relaunch: boolean): void;
  installWithToolAndRelaunch_displayingUserInterface(relaunch: boolean, showUI: boolean): void;
  installerForHost_failedWithError(host: SUHost, error: NSError): void;
  cleanUpDownload(): void;
  abortUpdate(): void;
  abortUpdateWithError(error: NSError): void;
  terminateApp(): void;
  static bestItemFromAppcastItems_getDeltaItem_withHostVersion_comparator(appcastItems: NSArray<any> | any[], deltaItem: SUAppcastItem, hostVersion: NSString | string, comparator: any): SUAppcastItem;
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;

  updateItem(): SUAppcastItem;
  download(): NSURLDownload;
  downloadPath(): NSString;
}

declare enum SUBinaryDeltaMajorVersion {
  SUAzureMajorVersion = 1,
  SUBeigeMajorVersion = 2,
}

class SUBinaryDeltaUnarchiverAllocator<T extends SUBinaryDeltaUnarchiver> extends NSObjectAllocator<T> {
  initWithArchivePath_updateHostBundlePath(archivePath: NSString | string, updateHostBundlePath: NSString | string): T;
}
declare class SUBinaryDeltaUnarchiver extends NSObject implements ISUUnarchiverProtocol {
  alloc<T extends SUBinaryDeltaUnarchiver>(): SUBinaryDeltaUnarchiverAllocator<T>;
  static updateSpotlightImportersAtBundlePath(targetPath: NSString | string): void;
  static canUnarchivePath(path: NSString | string): boolean;
  static unsafeIfArchiveIsNotValidated(): boolean;
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
  static canUnarchivePath(path: NSString | string): boolean;
  static unsafeIfArchiveIsNotValidated(): boolean;
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
}

class SUBundleIconAllocator<T extends SUBundleIcon> extends NSObjectAllocator<T> {}
declare class SUBundleIcon extends NSObject {
  alloc<T extends SUBundleIcon>(): SUBundleIconAllocator<T>;
  static iconURLForHost(host: SUHost): NSURL;
}

class SUCodeSigningVerifierAllocator<T extends SUCodeSigningVerifier> extends NSObjectAllocator<T> {}
declare class SUCodeSigningVerifier extends NSObject {
  alloc<T extends SUCodeSigningVerifier>(): SUCodeSigningVerifierAllocator<T>;
  static codeSignatureAtBundleURL_matchesSignatureAtBundleURL_error(oldBundlePath: NSURL, newBundlePath: NSURL, error: NSError): boolean;
  static codeSignatureIsValidAtBundleURL_error(bundlePath: NSURL, error: NSError): boolean;
  static bundleAtURLIsCodeSigned(bundlePath: NSURL): boolean;
}

class SUDSAVerifierAllocator<T extends SUDSAVerifier> extends NSObjectAllocator<T> {
  initWithPublicKeyData(data: NSData): T;
}
declare class SUDSAVerifier extends NSObject {
  alloc<T extends SUDSAVerifier>(): SUDSAVerifierAllocator<T>;
  static validatePath_withEncodedDSASignature_withPublicDSAKey(path: NSString | string, encodedSignature: NSString | string, pkeyString: NSString | string): boolean;
  verifyFileAtPath_signature(path: NSString | string, signature: NSData): boolean;
  verifyStream_signature(stream: NSInputStream, signature: NSData): boolean;
}

class SUDiskImageUnarchiverAllocator<T extends SUDiskImageUnarchiver> extends NSObjectAllocator<T> {
  initWithArchivePath_decryptionPassword(archivePath: NSString | string, decryptionPassword: NSString | string | null): T;
}
declare class SUDiskImageUnarchiver extends NSObject implements ISUUnarchiverProtocol {
  alloc<T extends SUDiskImageUnarchiver>(): SUDiskImageUnarchiverAllocator<T>;
  static canUnarchivePath(path: NSString | string): boolean;
  static unsafeIfArchiveIsNotValidated(): boolean;
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
  static canUnarchivePath(path: NSString | string): boolean;
  static unsafeIfArchiveIsNotValidated(): boolean;
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
}

declare enum SUError {
  SUAppcastParseError = 1000,
  SUNoUpdateError = 1001,
  SUAppcastError = 1002,
  SURunningFromDiskImageError = 1003,
  SUTemporaryDirectoryError = 2000,
  SUDownloadError = 2001,
  SUUnarchivingError = 3000,
  SUSignatureError = 3001,
  SUFileCopyFailure = 4000,
  SUAuthenticationFailure = 4001,
  SUMissingUpdateError = 4002,
  SUMissingInstallerToolError = 4003,
  SURelaunchError = 4004,
  SUInstallationError = 4005,
  SUDowngradeError = 4006,
  SUInstallationCancelledError = 4007,
  SUSystemPowerOffError = 5000,
}

class SUFileManagerAllocator<T extends SUFileManager> extends NSObjectAllocator<T> {}
declare class SUFileManager extends NSObject {
  alloc<T extends SUFileManager>(): SUFileManagerAllocator<T>;
  static defaultManager(): SUFileManager;
  static fileManagerWithAuthorizationToolPath(authorizationToolPath: NSString | string): SUFileManager;
  fileManagerByPreservingAuthorizationRights(): SUFileManager;
  makeTemporaryDirectoryWithPreferredName_appropriateForDirectoryURL_error(preferredName: NSString | string, appropriateURL: NSURL, error: NSError): NSURL;
  makeDirectoryAtURL_error(targetURL: NSURL, error: NSError): boolean;
  moveItemAtURL_toURL_error(sourceURL: NSURL, destinationURL: NSURL, error: NSError): boolean;
  copyItemAtURL_toURL_error(sourceURL: NSURL, destinationURL: NSURL, error: NSError): boolean;
  removeItemAtURL_error(url: NSURL, error: NSError): boolean;
  changeOwnerAndGroupOfItemAtRootURL_toMatchURL_error(targetURL: NSURL, matchURL: NSURL, error: NSError): boolean;
  updateModificationAndAccessTimeOfItemAtURL_error(targetURL: NSURL, error: NSError): boolean;
  releaseItemFromQuarantineAtRootURL_error(rootURL: NSURL, error: NSError): boolean;
  executePackageAtURL_progressBlock_error(packageURL: NSURL, progressBlock: Block | null, error: NSError): boolean;
  _acquireAuthorizationWithError(error: NSError): boolean;
  _itemExistsAtURL(fileURL: NSURL): boolean;
  _itemExistsAtURL_isDirectory(fileURL: NSURL, isDirectory: boolean | null): boolean;
}

class SUGuidedPackageInstallerAllocator<T extends SUGuidedPackageInstaller> extends NSObjectAllocator<T> {
  initWithPackagePath_installationPath_fileOperationToolPath(packagePath: NSString | string, installationPath: NSString | string, fileOperationToolPath: NSString | string): T;
}
declare class SUGuidedPackageInstaller extends NSObject implements ISUInstallerProtocol {
  alloc<T extends SUGuidedPackageInstaller>(): SUGuidedPackageInstallerAllocator<T>;
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
}

class SUHostAllocator<T extends SUHost> extends NSObjectAllocator<T> {
  initWithBundle(aBundle: NSBundle): T;
}
declare class SUHost extends NSObject {
  alloc<T extends SUHost>(): SUHostAllocator<T>;
  objectForInfoDictionaryKey(key: NSString | string): any;
  boolForInfoDictionaryKey(key: NSString | string): boolean;
  objectForUserDefaultsKey(defaultName: NSString | string): any;
  setObject_forUserDefaultsKey(value: any, defaultName: NSString | string): void;
  boolForUserDefaultsKey(defaultName: NSString | string): boolean;
  setBool_forUserDefaultsKey(value: boolean, defaultName: NSString | string): void;
  objectForKey(key: NSString | string): any;
  boolForKey(key: NSString | string): boolean;

  bundle(): NSBundle;
  bundlePath(): NSString;
  name(): NSString;
  version(): NSString;
  displayVersion(): NSString;
  runningOnReadOnlyVolume(): boolean;
  publicDSAKey(): NSString;
  publicDSAKeyFileKey(): NSString;
}

class SUInstallerAllocator<T extends SUInstaller> extends NSObjectAllocator<T> {}
declare class SUInstaller extends NSObject {
  alloc<T extends SUInstaller>(): SUInstallerAllocator<T>;
  static installerForHost_fileOperationToolPath_updateDirectory_error(host: SUHost, fileOperationToolPath: NSString | string, updateDirectory: NSString | string, error: NSError): any;
  static installSourcePathInUpdateFolder_forHost_isPackage_isGuided(inUpdateFolder: NSString | string, host: SUHost, isPackagePtr: boolean, isGuidedPtr: boolean | null): NSString;
}

declare interface ISUInstallerProtocol {
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
}

declare enum SULogLevel {
  SULogLevelDefault,
  SULogLevelError,
}

class SUOperatingSystemAllocator<T extends SUOperatingSystem> extends NSObjectAllocator<T> {}
declare class SUOperatingSystem extends NSObject {
  alloc<T extends SUOperatingSystem>(): SUOperatingSystemAllocator<T>;
  static operatingSystemVersion(): NSOperatingSystemVersion;
  static isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
  static systemVersionString(): NSString;
}

class SUPackageInstallerAllocator<T extends SUPackageInstaller> extends NSObjectAllocator<T> {
  initWithPackagePath_installationPath(packagePath: NSString | string, installationPath: NSString | string): T;
}
declare class SUPackageInstaller extends NSObject implements ISUInstallerProtocol {
  alloc<T extends SUPackageInstaller>(): SUPackageInstallerAllocator<T>;
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
}

class SUPipedUnarchiverAllocator<T extends SUPipedUnarchiver> extends NSObjectAllocator<T> {
  initWithArchivePath(archivePath: NSString | string): T;
}
declare class SUPipedUnarchiver extends NSObject implements ISUUnarchiverProtocol {
  alloc<T extends SUPipedUnarchiver>(): SUPipedUnarchiverAllocator<T>;
  static canUnarchivePath(path: NSString | string): boolean;
  static unsafeIfArchiveIsNotValidated(): boolean;
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
  static canUnarchivePath(path: NSString | string): boolean;
  static unsafeIfArchiveIsNotValidated(): boolean;
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
}

class SUPlainInstallerAllocator<T extends SUPlainInstaller> extends NSObjectAllocator<T> {
  initWithHost_bundlePath_installationPath_fileOperationToolPath(host: SUHost, bundlePath: NSString | string, installationPath: NSString | string, fileOperationToolPath: NSString | string): T;
}
declare class SUPlainInstaller extends NSObject implements ISUInstallerProtocol {
  alloc<T extends SUPlainInstaller>(): SUPlainInstallerAllocator<T>;
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
  performInitialInstallation(error: NSError): boolean;
  performFinalInstallationProgressBlock_error(cb: Block | null, error: NSError): boolean;
  canInstallSilently(): boolean;
  installationPath(): NSString;
}

class SUProbingUpdateDriverAllocator<T extends SUProbingUpdateDriver> extends SUBasicUpdateDriverAllocator<T> {}
declare class SUProbingUpdateDriver extends SUBasicUpdateDriver {
  alloc<T extends SUProbingUpdateDriver>(): SUProbingUpdateDriverAllocator<T>;
}

class SUScheduledUpdateDriverAllocator<T extends SUScheduledUpdateDriver> extends SUUIBasedUpdateDriverAllocator<T> {}
declare class SUScheduledUpdateDriver extends SUUIBasedUpdateDriver {
  alloc<T extends SUScheduledUpdateDriver>(): SUScheduledUpdateDriverAllocator<T>;
}

class SUStandardVersionComparatorAllocator<T extends SUStandardVersionComparator> extends NSObjectAllocator<T> {
  init(): T;
}
declare class SUStandardVersionComparator extends NSObject implements ISUVersionComparison {
  alloc<T extends SUStandardVersionComparator>(): SUStandardVersionComparatorAllocator<T>;
  static defaultComparator(): SUStandardVersionComparator;
  compareVersion_toVersion(versionA: NSString | string, versionB: NSString | string): NSComparisonResult;
  compareVersion_toVersion(versionA: NSString | string, versionB: NSString | string): NSComparisonResult;
  compareVersion_toVersion(versionA: NSString | string, versionB: NSString | string): NSComparisonResult;
}

class SUStatusControllerAllocator<T extends SUStatusController> extends NSWindowControllerAllocator<T> {
  initWithHost(host: SUHost): T;
}
declare class SUStatusController extends NSWindowController {
  alloc<T extends SUStatusController>(): SUStatusControllerAllocator<T>;
  beginActionWithTitle_maxProgressValue_statusText(title: NSString | string, maxProgressValue: number, statusText: NSString | string): void;
  setButtonTitle_target_action_isDefault(buttonTitle: NSString | string, target: any, action: string, isDefault: boolean): void;

  actionButton(): NSButton;
  setActionButton(actionButton: NSButton): void;
  progressBar(): NSProgressIndicator;
  setProgressBar(progressBar: NSProgressIndicator): void;
  statusTextField(): NSTextField;
  setStatusTextField(statusTextField: NSTextField): void;
  statusText(): NSString;
  setStatusText(statusText: NSString | string): void;
  progressValue(): number;
  setProgressValue(progressValue: number): void;
  maxProgressValue(): number;
  setMaxProgressValue(maxProgressValue: number): void;
  buttonEnabled(): boolean;
  setButtonEnabled(buttonEnabled: boolean): void;
}

class SUSystemProfilerAllocator<T extends SUSystemProfiler> extends NSObjectAllocator<T> {}
declare class SUSystemProfiler extends NSObject {
  alloc<T extends SUSystemProfiler>(): SUSystemProfilerAllocator<T>;
  static systemProfileArrayForHost(host: SUHost): NSArray<any>;
}

class SUSystemUpdateInfoAllocator<T extends SUSystemUpdateInfo> extends NSObjectAllocator<T> {}
declare class SUSystemUpdateInfo extends NSObject {
  alloc<T extends SUSystemUpdateInfo>(): SUSystemUpdateInfoAllocator<T>;
  static systemAllowsAutomaticUpdatesForHost(host: SUHost): boolean;
}

class SUTouchBarButtonGroupAllocator<T extends SUTouchBarButtonGroup> extends NSViewControllerAllocator<T> {
  initByReferencingButtons(buttons: NSArray<any> | any[]): T;
}
declare class SUTouchBarButtonGroup extends NSViewController {
  alloc<T extends SUTouchBarButtonGroup>(): SUTouchBarButtonGroupAllocator<T>;

  buttons(): NSArray<any>;
}

class SUUIBasedUpdateDriverAllocator<T extends SUUIBasedUpdateDriver> extends SUBasicUpdateDriverAllocator<T> {}
declare class SUUIBasedUpdateDriver extends SUBasicUpdateDriver {
  alloc<T extends SUUIBasedUpdateDriver>(): SUUIBasedUpdateDriverAllocator<T>;
  showAlert(alert: NSAlert): void;
  cancelDownload(sender: any): IBAction;
  installAndRestart(sender: any): void;

  showErrors(): boolean;
  setShowErrors(showErrors: boolean): void;
}

class SUUnarchiverAllocator<T extends SUUnarchiver> extends NSObjectAllocator<T> {}
declare class SUUnarchiver extends NSObject {
  alloc<T extends SUUnarchiver>(): SUUnarchiverAllocator<T>;
  static unarchiverForPath_updatingHostBundlePath_decryptionPassword(path: NSString | string, hostPath: NSString | string | null, decryptionPassword: NSString | string | null): any;
}

class SUUnarchiverNotifierAllocator<T extends SUUnarchiverNotifier> extends NSObjectAllocator<T> {
  initWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): T;
}
declare class SUUnarchiverNotifier extends NSObject {
  alloc<T extends SUUnarchiverNotifier>(): SUUnarchiverNotifierAllocator<T>;
  notifySuccess(): void;
  notifyFailureWithError(reason: NSError): void;
  notifyProgress(progress: number): void;
}

declare interface ISUUnarchiverProtocol {
  unarchiveWithCompletionBlock_progressBlock(completionBlock: Block, progressBlock: Block): void;
  description(): NSString;
}

class SUUpdateAlertAllocator<T extends SUUpdateAlert> extends NSWindowControllerAllocator<T> {
  initWithAppcastItem_host_completionBlock(item: SUAppcastItem, host: SUHost, c: Block): T;
}
declare class SUUpdateAlert extends NSWindowController {
  alloc<T extends SUUpdateAlert>(): SUUpdateAlertAllocator<T>;
  installUpdatesender(): IBAction;
  skipThisVersionsender(): IBAction;
  remindMeLatersender(): IBAction;
  disableKeyboardShortcutForInstallButton(): void;

  versionDisplayer(): any;
  setVersionDisplayer(versionDisplayer: any): void;
}

declare enum SUUpdateAlertChoice {
  SUInstallUpdateChoice,
  SURemindMeLaterChoice,
  SUSkipThisVersionChoice,
  SUOpenInfoURLChoice,
}

class SUUpdateDriverAllocator<T extends SUUpdateDriver> extends NSObjectAllocator<T> {
  initWithUpdater(updater: any): T;
}
declare class SUUpdateDriver extends NSObject implements INSURLDownloadDelegate {
  alloc<T extends SUUpdateDriver>(): SUUpdateDriverAllocator<T>;
  checkForUpdatesAtURL_host(URL: NSURL, host: SUHost): void;
  abortUpdate(): void;
  resumeUpdateInteractively(): boolean;
  showAlert(alert: NSAlert): void;
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;
  downloadDidBegin(download: NSURLDownload): void;
  download_willSendRequest_redirectResponse(download: NSURLDownload, request: NSURLRequest, redirectResponse: NSURLResponse | null): NSURLRequest;
  download_canAuthenticateAgainstProtectionSpace(connection: NSURLDownload, protectionSpace: NSURLProtectionSpace): boolean;
  download_didReceiveAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  download_didCancelAuthenticationChallenge(download: NSURLDownload, challenge: NSURLAuthenticationChallenge): void;
  downloadShouldUseCredentialStorage(download: NSURLDownload): boolean;
  download_didReceiveResponse(download: NSURLDownload, response: NSURLResponse): void;
  download_willResumeWithResponse_fromByte(download: NSURLDownload, response: NSURLResponse, startingByte: number): void;
  download_didReceiveDataOfLength(download: NSURLDownload, length: NSUInteger): void;
  download_shouldDecodeSourceDataOfMIMEType(download: NSURLDownload, encodingType: NSString | string): boolean;
  download_decideDestinationWithSuggestedFilename(download: NSURLDownload, filename: NSString | string): void;
  download_didCreateDestination(download: NSURLDownload, path: NSString | string): void;
  downloadDidFinish(download: NSURLDownload): void;
  download_didFailWithError(download: NSURLDownload, error: NSError): void;

  updater(): SUUpdater;
  host(): SUHost;
  setHost(host: SUHost): void;
  interruptible(): boolean;
  finished(): boolean;
  downloadsAppcastInBackground(): boolean;
  downloadsUpdatesInBackground(): boolean;
  automaticallyInstallUpdates(): boolean;
  setAutomaticallyInstallUpdates(automaticallyInstallUpdates: boolean): void;
}

class SUUpdatePermissionPromptAllocator<T extends SUUpdatePermissionPrompt> extends NSWindowControllerAllocator<T> {}
declare class SUUpdatePermissionPrompt extends NSWindowController {
  alloc<T extends SUUpdatePermissionPrompt>(): SUUpdatePermissionPromptAllocator<T>;
  static promptWithHost_systemProfile_reply(host: SUHost, profile: NSArray<any> | any[], reply: Block): void;
  toggleMoreInfo(sender: any): IBAction;
  finishPrompt(sender: any): IBAction;
}

declare enum SUPermissionPromptResult {
  SUAutomaticallyCheck,
  SUDoNotAutomaticallyCheck,
}

class SUUpdatePermissionResponseAllocator<T extends SUUpdatePermissionResponse> extends NSObjectAllocator<T> {
  initWithAutomaticUpdateChecks_sendSystemProfile(automaticUpdateChecks: boolean, sendSystemProfile: boolean): T;
}
declare class SUUpdatePermissionResponse extends NSObject {
  alloc<T extends SUUpdatePermissionResponse>(): SUUpdatePermissionResponseAllocator<T>;

  automaticUpdateChecks(): boolean;
  sendSystemProfile(): boolean;
}

class SUUpdateValidatorAllocator<T extends SUUpdateValidator> extends NSObjectAllocator<T> {
  initWithDownloadPath_dsaSignature_host_performingPrevalidation(downloadPath: NSString | string, dsaSignature: NSString | string, host: SUHost, performingPrevalidation: boolean): T;
}
declare class SUUpdateValidator extends NSObject {
  alloc<T extends SUUpdateValidator>(): SUUpdateValidatorAllocator<T>;
  validateWithUpdateDirectory(updateDirectory: NSString | string): boolean;

  canValidate(): boolean;
}

class SUUpdaterAllocator<T extends SUUpdater> extends NSObjectAllocator<T> {
  initForBundle(bundle: NSBundle): T;
}
declare class SUUpdater extends NSObject {
  alloc<T extends SUUpdater>(): SUUpdaterAllocator<T>;
  static sharedUpdater(): SUUpdater;
  static updaterForBundle(bundle: NSBundle): SUUpdater;
  checkForUpdates(sender: any): IBAction;
  validateMenuItem(menuItem: NSMenuItem): boolean;
  checkForUpdatesInBackground(): void;
  checkForUpdateInformation(): void;
  installUpdatesIfAvailable(): void;
  resetUpdateCycle(): void;

  delegate(): any;
  setDelegate(delegate: any): void;
  automaticallyChecksForUpdates(): boolean;
  setAutomaticallyChecksForUpdates(automaticallyChecksForUpdates: boolean): void;
  automaticallyDownloadsUpdates(): boolean;
  setAutomaticallyDownloadsUpdates(automaticallyDownloadsUpdates: boolean): void;
  updateCheckInterval(): NSTimeInterval;
  setUpdateCheckInterval(updateCheckInterval: NSTimeInterval): void;
  feedURL(): NSURL;
  setFeedURL(feedURL: NSURL): void;
  hostBundle(): NSBundle;
  sparkleBundle(): NSBundle;
  userAgentString(): NSString;
  setUserAgentString(userAgentString: NSString | string): void;
  httpHeaders(): NSDictionary<any, any>;
  setHttpHeaders(httpHeaders: NSDictionary<any, any> | {[key: string]: any}): void;
  sendsSystemProfile(): boolean;
  setSendsSystemProfile(sendsSystemProfile: boolean): void;
  decryptionPassword(): NSString;
  setDecryptionPassword(decryptionPassword: NSString | string): void;
  lastUpdateCheckDate(): NSDate;
  updateInProgress(): boolean;
}

class SUUserInitiatedUpdateDriverAllocator<T extends SUUserInitiatedUpdateDriver> extends SUUIBasedUpdateDriverAllocator<T> {}
declare class SUUserInitiatedUpdateDriver extends SUUIBasedUpdateDriver {
  alloc<T extends SUUserInitiatedUpdateDriver>(): SUUserInitiatedUpdateDriverAllocator<T>;
}

declare interface ISUVersionComparison {
  compareVersion_toVersion(versionA: NSString | string, versionB: NSString | string): NSComparisonResult;
}

declare interface ISUVersionDisplay {
  formatVersion_andVersion(inOutVersionA: NSString | string, inOutVersionB: NSString | string): void;
}

class SUTestApplicationDelegateAllocator<T extends SUTestApplicationDelegate> extends NSObjectAllocator<T> {}
declare class SUTestApplicationDelegate extends NSObject implements INSApplicationDelegate {
  alloc<T extends SUTestApplicationDelegate>(): SUTestApplicationDelegateAllocator<T>;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
}

class SUTestWebServerAllocator<T extends SUTestWebServer> extends NSObjectAllocator<T> {
  initWithPort_workingDirectory(port: number, workingDirectory: NSString | string): T;
}
declare class SUTestWebServer extends NSObject {
  alloc<T extends SUTestWebServer>(): SUTestWebServerAllocator<T>;
  close(): void;
}

class SUUpdateSettingsWindowControllerAllocator<T extends SUUpdateSettingsWindowController> extends NSWindowControllerAllocator<T> {}
declare class SUUpdateSettingsWindowController extends NSWindowController {
  alloc<T extends SUUpdateSettingsWindowController>(): SUUpdateSettingsWindowControllerAllocator<T>;
}

class TestFlightAllocator<T extends TestFlight> extends NSObjectAllocator<T> {}
declare class TestFlight extends NSObject {
  alloc<T extends TestFlight>(): TestFlightAllocator<T>;
  static manuallyStartSession(): void;
  static manuallyEndSession(): void;
  static addCustomEnvironmentInformation_forKey(information: NSString | string, key: NSString | string): void;
  static takeOff(applicationToken: NSString | string): void;
  static setOptions(options: NSDictionary<any, any> | {[key: string]: any}): void;
  static passCheckpoint(checkpointName: NSString | string): void;
  static submitFeedback(feedback: NSString | string): void;
}

class BCBooleanViewAllocator<T extends BCBooleanView> extends NSViewAllocator<T> {}
declare class BCBooleanView extends NSView implements INSTableViewDataSource, INSTableViewDelegate, INSPathControlDelegate {
  alloc<T extends BCBooleanView>(): BCBooleanViewAllocator<T>;
  onPathControl(sender: any): IBAction;
  onZoom(sender: any): IBAction;
  onDebugIntersections(sender: any): IBAction;
  onDebugCrossings(sender: any): IBAction;
  onDebugLeftContainment(sender: any): IBAction;
  onDebugRightContainment(sender: any): IBAction;
  onDebugOperation(sender: any): IBAction;
  onDebugCrossingContainment(sender: any): IBAction;
  onDebugCrossingContainmentIntersection(sender: any): IBAction;
  onDebugWhyIntersectionIsntExternalCrossing(sender: any): IBAction;
  onDebugCrossingContainmentRayWithEdge(sender: any): IBAction;
  onShowIntersectionType(sender: any): IBAction;
  onShowOverlaps(sender: any): IBAction;
  onShowContainmentRays(sender: any): IBAction;
  onShowWindingRuleContainmentRays(sender: any): IBAction;
  onShowCrossingContainmentRays(sender: any): IBAction;
  onShowExpandedXor(sender: any): IBAction;
  onShowContourJoints(sender: any): IBAction;
  onShowSuspiciousSelfCrossings(sender: any): IBAction;
  onShowWindingRuleContainmentRaysForSelection(sender: any): IBAction;
  onConvertToXor(sender: any): IBAction;
  onToggleAnimation(sender: any): IBAction;
  onPrescale(sender: any): IBAction;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  pathControl_shouldDragItem_withPasteboard(pathControl: NSPathControl, pathItem: NSPathControlItem, pasteboard: NSPasteboard): boolean;
  pathControl_shouldDragPathComponentCell_withPasteboard(pathControl: NSPathControl, pathComponentCell: NSPathComponentCell, pasteboard: NSPasteboard): boolean;
  pathControl_validateDrop(pathControl: NSPathControl, info: any): NSDragOperation;
  pathControl_acceptDrop(pathControl: NSPathControl, info: any): boolean;
  pathControl_willDisplayOpenPanel(pathControl: NSPathControl, openPanel: NSOpenPanel): void;
  pathControl_willPopUpMenu(pathControl: NSPathControl, menu: NSMenu): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  pathControl_shouldDragItem_withPasteboard(pathControl: NSPathControl, pathItem: NSPathControlItem, pasteboard: NSPasteboard): boolean;
  pathControl_shouldDragPathComponentCell_withPasteboard(pathControl: NSPathControl, pathComponentCell: NSPathComponentCell, pasteboard: NSPasteboard): boolean;
  pathControl_validateDrop(pathControl: NSPathControl, info: any): NSDragOperation;
  pathControl_acceptDrop(pathControl: NSPathControl, info: any): boolean;
  pathControl_willDisplayOpenPanel(pathControl: NSPathControl, openPanel: NSOpenPanel): void;
  pathControl_willPopUpMenu(pathControl: NSPathControl, menu: NSMenu): void;

  examplesTableView(): NSTableView;
  setExamplesTableView(examplesTableView: NSTableView): void;
  examplesPathControl(): NSPathControl;
  setExamplesPathControl(examplesPathControl: NSPathControl): void;
}

class FBBezierContourAllocator<T extends FBBezierContour> extends NSObjectAllocator<T> {}
declare class FBBezierContour extends NSObject implements INSCopying {
  alloc<T extends FBBezierContour>(): FBBezierContourAllocator<T>;
  static bezierContourWithCurve(curve: FBBezierCurve): FBBezierContour;
  addCurve(curve: FBBezierCurve): void;
  addCurveFrom_to(startCrossing: FBEdgeCrossing, endCrossing: FBEdgeCrossing): void;
  addReverseCurve(curve: FBBezierCurve): void;
  addReverseCurveFrom_to(startCrossing: FBEdgeCrossing, endCrossing: FBEdgeCrossing): void;
  intersectionsWithRay_withBlock(testEdge: FBBezierCurve, block: Block): void;
  numberOfIntersectionsWithRay(testEdge: FBBezierCurve): NSUInteger;
  containsPoint(point: FBPoint): boolean;
  markCrossingsAsEntryOrExitWithContour_markInside(otherContour: FBBezierContour, markInside: boolean): void;
  containsPointUsingNonZeroWindingRule(point: FBPoint): boolean;
  containsCrossingUsingNonZeroWindingRule(testIntersection: FBBezierIntersection): boolean;
  bezierPath(): FBBezierPath;
  close(): void;
  bezierPathFromEdge_toEdge(curve1: FBBezierCurve, curve2: FBBezierCurve): FBBezierPath;
  reversedContour(): FBBezierContour;
  contourMadeClockwiseIfNecessary(): FBBezierContour;
  contourWithTransform(t: CGAffineTransform): FBBezierContour;
  contourByMergingLinearRuns(): FBBezierContour;
  addOverlap(overlap: FBContourOverlap): void;
  removeAllOverlaps(): void;
  isEquivalent(other: FBBezierContour): boolean;
  startEdge(): FBBezierCurve;
  testRayForContainment(bounds: FBRect): FBBezierCurve;
  closestLocationToPoint(point: FBPoint): FBCurveLocation;
  clone(): FBBezierContour;
  crossesOwnContour(contour: FBBezierContour): boolean;
  contourWithFlatness(flatness: CGFloat): FBBezierContour;
  markSelfCrossingsAsEntryOrExit(): void;
  sortCoincidentCrossings(): void;
  crossingContainmentRay(testPoint: FBPoint): FBBezierCurve;
  debugPathForIntersectionType_withTransform_andSizeTransform(itersectionType: NSInteger, transform: CGAffineTransform, sizeTransform: CGAffineTransform): FBBezierPath;
  debugPathForJointsWithTransform_andSizeTransform(transform: CGAffineTransform, sizeTransform: CGAffineTransform): FBBezierPath;
  debugPathForContainmentOfCrossing_transform(testIntersection: FBBezierIntersection, transform: CGAffineTransform): FBBezierPath;
  debugPathForWindingRuleContainmentWithTransform_andSizeTransform(transform: CGAffineTransform, sizeTransform: CGAffineTransform): FBBezierPath;
  forEachEdgeOverlapDo(block: Block): void;
  doesOverlapContainCrossing(crossing: FBEdgeCrossing): boolean;
  doesOverlapContainParameter_onEdge(parameter: FBFloat, edge: FBBezierCurve): boolean;
  debugDrawColor_scale(color: NSColor, scale: CGFloat): void;
  copyWithZone(zone: NSZone | null): any;
  copyWithZone(zone: NSZone | null): any;

  edges(): NSArray<any>;
  nonPointEdges(): NSArray<any>;
  bounds(): FBRect;
  boundingRect(): FBRect;
  firstPoint(): FBPoint;
  inside(): FBContourInside;
  setInside(inside: FBContourInside): void;
  intersectingContours(): NSArray<any>;
  isEmpty(): boolean;
  isClosed(): boolean;
  direction(): FBContourDirection;
  CGPath(): CGPathRef;
  overlaps(): NSArray<any>;
  crossings(): NSArray<any>;
}

declare enum FBContourDirection {
  FBContourClockwise,
  FBContourAntiClockwise,
}

class FBBezierCurveAllocator<T extends FBBezierCurve> extends NSObjectAllocator<T> {
  initWithEndPoint1_controlPoint1_controlPoint2_endPoint2_contour(endPoint1: FBPoint, controlPoint1: FBPoint, controlPoint2: FBPoint, endPoint2: FBPoint, contour: FBBezierContour): T;
  initWithLineStartPoint_endPoint_contour(startPoint: FBPoint, endPoint: FBPoint, contour: FBBezierContour): T;
}
declare class FBBezierCurve extends NSObject {
  alloc<T extends FBBezierCurve>(): FBBezierCurveAllocator<T>;
  static bezierCurvesFromBezierPath(path: FBBezierPath): NSArray<any>;
  static bezierCurveWithLineStartPoint_endPoint(startPoint: FBPoint, endPoint: FBPoint): FBBezierCurve;
  static bezierCurveWithEndPoint1_controlPoint1_controlPoint2_endPoint2(endPoint1: FBPoint, controlPoint1: FBPoint, controlPoint2: FBPoint, endPoint2: FBPoint): FBBezierCurve;
  checkForLine(): void;
  doesHaveIntersectionsWithBezierCurve(curve: FBBezierCurve): boolean;
  intersectionsWithBezierCurve_overlapRange_withBlock(curve: FBBezierCurve, intersectRange: FBBezierIntersectRange, block: FBCurveIntersectionBlock): void;
  pointAtParameter(parameter: FBFloat): FBPoint;
  pointAtParameter_leftBezierCurve_rightBezierCurve(parameter: FBFloat, leftBezierCurve: FBBezierCurve, rightBezierCurve: FBBezierCurve): FBPoint;
  subcurveWithRange(range: FBRange): FBBezierCurve;
  splitSubcurvesWithRange_left_middle_right(range: FBRange, leftCurve: FBBezierCurve, middleCurve: FBBezierCurve, rightCurve: FBBezierCurve): void;
  lengthAtParameter(parameter: FBFloat): FBFloat;
  length(): FBFloat;
  pointFromRightOffset(offset: FBFloat): FBPoint;
  pointFromLeftOffset(offset: FBFloat): FBPoint;
  tangentFromRightOffset(offset: FBFloat): FBPoint;
  tangentFromLeftOffset(offset: FBFloat): FBPoint;
  tangentAtParameter(parameter: FBFloat): FBPoint;
  closestLocationToPoint(point: FBPoint): FBBezierCurveLocation;
  reversedCurve(): FBBezierCurve;
  curveWithTransform(t: CGAffineTransform): FBBezierCurve;
  bezierPath(): FBBezierPath;
  clone(): FBBezierCurve;
  edgesWithFlatness(flatness: CGFloat): NSArray<any>;
  mightIntersectWith(curve: FBBezierCurve): boolean;
  firstCrossingUsingNonself(useNonself: boolean): FBEdgeCrossing;
  lastCrossingUsingNonself(useNonself: boolean): FBEdgeCrossing;
  hasCrossingsUsingNonself(useNonself: boolean): boolean;
  crossingsWithBlock(block: Block): void;
  crossingsCopyWithBlock(block: Block): void;
  removeCrossingsInNonCrossingOverlapRuns(): void;
  nextCrossing(crossing: FBEdgeCrossing): FBEdgeCrossing;
  previousCrossing(crossing: FBEdgeCrossing): FBEdgeCrossing;
  intersectingEdgesWithBlock(block: Block): void;
  selfIntersectingEdgesWithBlock(block: Block): void;
  addCrossing(crossing: FBEdgeCrossing): void;
  removeCrossing(crossing: FBEdgeCrossing): void;
  removeDuplicateCrossings(): void;
  removeAllCrossings(): void;
  reorderCoincidentCrossingA_crossingB(crossingA: FBEdgeCrossing, crossingB: FBEdgeCrossing): void;
  crossesEdge_atIntersection(edge2: FBBezierCurve, intersection: FBBezierIntersection): boolean;
  crossesEdge_atIntersectRange(edge2: FBBezierCurve, intersectRange: FBBezierIntersectRange): boolean;
  isNext(other: FBBezierCurve): boolean;
  debugDrawColor_controlPointColor_scale(color: NSColor, controlPointColor: NSColor, scale: CGFloat): void;

  endPoint1(): FBPoint;
  controlPoint1(): FBPoint;
  controlPoint2(): FBPoint;
  endPoint2(): FBPoint;
  isStraightLine(): boolean;
  bounds(): FBRect;
  boundingRect(): FBRect;
  flatness(): FBFloat;
  point(): boolean;
  isPointOrHorizontalLine(): boolean;
  isStartHorizontal(): boolean;
  isEndHorizontal(): boolean;
  isHorizontalLine(): boolean;
  looksLikeLine(): boolean;
  contour(): FBBezierContour;
  setContour(contour: FBBezierContour): void;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
  startShared(): boolean;
  setStartShared(startShared: boolean): void;
  next(): FBBezierCurve;
  previous(): FBBezierCurve;
  nextNonpoint(): FBBezierCurve;
  previousNonpoint(): FBBezierCurve;
  nextNonpointNonHorizontalLine(): FBBezierCurve;
  previousNonpointNonHorizontalLine(): FBBezierCurve;
  firstCrossing(): FBEdgeCrossing;
  lastCrossing(): FBEdgeCrossing;
  crossings(): NSArray<any>;
  hasCrossings(): boolean;
}

declare type FBBezierCurveLocation = {
  parameter: FBFloat
  distance: FBFloat
}

class FBBezierGraphAllocator<T extends FBBezierGraph> extends NSObjectAllocator<T> {
  initWithBezierPath(path: FBBezierPath): T;
}
declare class FBBezierGraph extends NSObject {
  alloc<T extends FBBezierGraph>(): FBBezierGraphAllocator<T>;
  static bezierGraph(): FBBezierGraph;
  static bezierGraphWithCGPath(path: CGPathRef): FBBezierGraph;
  static bezierGraphWithBezierPath(path: FBBezierPath): FBBezierGraph;
  static bezierGraphWithContours(contours: NSArray<any> | any[]): FBBezierGraph;
  unionWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  intersectWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  differenceWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  xorWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  noneWithBezierGraph(graph: FBBezierGraph): FBBezierGraph;
  bezierPath(): FBBezierPath;
  bezierPathWithClass(bezierClass: any): any;
  closestLocationToPoint(point: FBPoint): FBCurveLocation;
  closestCrossingToPoint(point: FBPoint): FBEdgeCrossing;
  convertToNoneZeroWindingRule(): FBBezierGraph;
  convertToEvenOddWindingRule(): FBBezierGraph;
  bezierGraphBySplittingSelfCrossingContours(singleCrossingContoursOut: NSMutableArray<any> | any[]): FBBezierGraph;
  bezierGraphByTrimmingSelfCrossingContours(): FBBezierGraph;
  bezierGraphWithTransform(t: CGAffineTransform): FBBezierGraph;
  bezierGraphByMergingLinearRunsInContours(): FBBezierGraph;
  bezierGraphWithClockwiseFillsAnticlockwiseHoles(): FBBezierGraph;
  containmentResultForContour(testContour: FBBezierContour): FBContainmentResult;
  debuggingInsertCrossingsForUnionWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertCrossingsForIntersectWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertCrossingsForDifferenceWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertIntersectionsWithBezierGraph(otherGraph: FBBezierGraph): void;
  debuggingInsertCrossingsForFillConversion(): void;
  debugPathForContainmentOfContour(contour: FBBezierContour): FBBezierPath;
  debugPathForContainmentOfContour_transform(testContour: FBBezierContour, transform: CGAffineTransform): FBBezierPath;
  debugPathForJointsOfContour(testContour: FBBezierContour): FBBezierPath;
  debugFindCurvesThatShouldIntersectWith_withBlock(otherGraph: FBBezierGraph, block: Block): void;

  nonEmptyContours(): NSArray<any>;
  contours(): NSArray<any>;
  bounds(): FBRect;
  CGPath(): CGPathRef;
}

class FBBezierIntersectRangeAllocator<T extends FBBezierIntersectRange> extends NSObjectAllocator<T> {
  initWithCurve1_parameterRange1_curve2_parameterRange2_reversed(curve1: FBBezierCurve, parameterRange1: FBRange, curve2: FBBezierCurve, parameterRange2: FBRange, reversed: boolean): T;
}
declare class FBBezierIntersectRange extends NSObject {
  alloc<T extends FBBezierIntersectRange>(): FBBezierIntersectRangeAllocator<T>;
  static intersectRangeWithCurve1_parameterRange1_curve2_parameterRange2_reversed(curve1: FBBezierCurve, parameterRange1: FBRange, curve2: FBBezierCurve, parameterRange2: FBRange, reversed: boolean): FBBezierIntersectRange;
  merge(other: FBBezierIntersectRange): void;
  flip(): FBBezierIntersectRange;

  curve1(): FBBezierCurve;
  parameterRange1(): FBRange;
  curve1LeftBezier(): FBBezierCurve;
  curve1RightBezier(): FBBezierCurve;
  curve1OverlappingBezier(): FBBezierCurve;
  curve2(): FBBezierCurve;
  parameterRange2(): FBRange;
  reversed(): boolean;
  curve2LeftBezier(): FBBezierCurve;
  curve2RightBezier(): FBBezierCurve;
  curve2OverlappingBezier(): FBBezierCurve;
  startIntersection(): FBBezierIntersection;
  middleIntersection(): FBBezierIntersection;
  stopIntersection(): FBBezierIntersection;
  atStartOfCurve1(): boolean;
  atStopOfCurve1(): boolean;
  atStartOfCurve2(): boolean;
  atStopOfCurve2(): boolean;
}

class FBBezierIntersectionAllocator<T extends FBBezierIntersection> extends NSObjectAllocator<T> {
  initWithCurve1_parameter1_curve2_parameter2(curve1: FBBezierCurve, parameter1: FBFloat, curve2: FBBezierCurve, parameter2: FBFloat): T;
}
declare class FBBezierIntersection extends NSObject {
  alloc<T extends FBBezierIntersection>(): FBBezierIntersectionAllocator<T>;
  static intersectionWithCurve1_parameter1_curve2_parameter2(curve1: FBBezierCurve, parameter1: FBFloat, curve2: FBBezierCurve, parameter2: FBFloat): FBBezierIntersection;
  enumerateAliasesWithBlock(block: Block): void;
  curve1Direction(): FBPoint;
  curve2Direction(): FBPoint;
  curve1WindingCount(): NSInteger;
  curve2WindingCount(): NSInteger;

  location(): FBPoint;
  curve1(): FBBezierCurve;
  parameter1(): FBFloat;
  curve2(): FBBezierCurve;
  parameter2(): FBFloat;
  tangent(): boolean;
  curve1LeftBezier(): FBBezierCurve;
  curve1RightBezier(): FBBezierCurve;
  curve2LeftBezier(): FBBezierCurve;
  curve2RightBezier(): FBBezierCurve;
  atStartOfCurve1(): boolean;
  atStopOfCurve1(): boolean;
  atStartOfCurve2(): boolean;
  atStopOfCurve2(): boolean;
  isAtExactStartOfCurve1(): boolean;
  isAtExactStopOfCurve1(): boolean;
  isAtExactStartOfCurve2(): boolean;
  isAtExactStopOfCurve2(): boolean;
  atEndPointOfCurve1(): boolean;
  atEndPointOfCurve2(): boolean;
  atEndPointOfCurve(): boolean;
}

class FBBezierOperationChainAllocator<T extends FBBezierOperationChain> extends NSObjectAllocator<T> {
  initWithBezierPath(sourcePath: FBBezierPath): T;
  initWithData(data: NSData): T;
}
declare class FBBezierOperationChain extends NSObject {
  alloc<T extends FBBezierOperationChain>(): FBBezierOperationChainAllocator<T>;
  appendBezierPath_withOperation(path: FBBezierPath, op: FBBezierPathOperation): void;
  archive(): NSData;
  saveWithName(name: NSString | string): void;
  enumerateWithBlock(block: Block): void;
}

declare type FBBezierPathElement = {
  type: FBPathElementType
  point: FBPoint
  controlPoints: [FBPoint, FBPoint]
}

declare enum FBBezierPathOperation {
  FBBezierPathOperationUnion = 0,
  FBBezierPathOperationDifference = 1,
  FBBezierPathOperationIntersect = 2,
  FBBezierPathOperationXor = 3,
}

class FBContainmentResultAllocator<T extends FBContainmentResult> extends NSObjectAllocator<T> {
  initWithTestContour_inGraph_evenOddInside_nonZeroInside_testEdge_intersections(testContour: FBBezierContour, graph: FBBezierGraph, evenOdd: FBContourInside, nonZero: FBContourInside, testEdge: FBBezierCurve | null, intersections: NSArray<any> | any[]): T;
}
declare class FBContainmentResult extends NSObject {
  alloc<T extends FBContainmentResult>(): FBContainmentResultAllocator<T>;

  evenOdd(): FBContourInside;
  nonZero(): FBContourInside;
  testEdge(): FBBezierCurve;
  intersections(): NSArray<any>;
  testContour(): FBBezierContour;
  graph(): FBBezierGraph;
  container(): FBBezierContour;
}

class FBEdgeOverlapAllocator<T extends FBEdgeOverlap> extends NSObjectAllocator<T> {}
declare class FBEdgeOverlap extends NSObject {
  alloc<T extends FBEdgeOverlap>(): FBEdgeOverlapAllocator<T>;

  range(): FBBezierIntersectRange;
  edge1(): FBBezierCurve;
  edge2(): FBBezierCurve;
}

class FBEdgeOverlapRunAllocator<T extends FBEdgeOverlapRun> extends NSObjectAllocator<T> {}
declare class FBEdgeOverlapRun extends NSObject {
  alloc<T extends FBEdgeOverlapRun>(): FBEdgeOverlapRunAllocator<T>;
  isCrossing(): boolean;
  isCrossingUsingNonZeroWindingRule(): boolean;
  removeCrossings(): void;
  addMiddleCrossing(): void;
  addStartCrossing(): void;
  addStopCrossing(): void;
  middleIntersection(): FBBezierIntersection;

  overlaps(): NSArray<any>;
  startIsInsideContour1(): boolean;
  stopIsInsideContour1(): boolean;
  startIsInsideContour2(): boolean;
  stopIsInsideContour2(): boolean;
  crossingType(): FBEdgeOverlapRunCrossingType;
}

class FBContourOverlapAllocator<T extends FBContourOverlap> extends NSObjectAllocator<T> {}
declare class FBContourOverlap extends NSObject {
  alloc<T extends FBContourOverlap>(): FBContourOverlapAllocator<T>;
  static contourOverlap(): FBContourOverlap;
  addOverlap_forEdge1_edge2(range: FBBezierIntersectRange, edge1: FBBezierCurve, edge2: FBBezierCurve): void;
  runsWithBlock(block: Block): void;
  reset(): void;
  isComplete(): boolean;
  isEmpty(): boolean;
  isBetweenContour_andContour(contour1: FBBezierContour, contour2: FBBezierContour): boolean;
  doesContainCrossing(crossing: FBEdgeCrossing): boolean;
  doesContainParameter_onEdge(parameter: FBFloat, edge: FBBezierCurve): boolean;

  contour1(): FBBezierContour;
  contour2(): FBBezierContour;
  overlapRuns(): NSArray<any>;
}

class FBCurveLocationAllocator<T extends FBCurveLocation> extends NSObjectAllocator<T> {
  initWithEdge_parameter_distance(edge: FBBezierCurve, parameter: FBFloat, distance: FBFloat): T;
}
declare class FBCurveLocation extends NSObject {
  alloc<T extends FBCurveLocation>(): FBCurveLocationAllocator<T>;
  static curveLocationWithEdge_parameter_distance(edge: FBBezierCurve, parameter: FBFloat, distance: FBFloat): FBCurveLocation;

  graph(): FBBezierGraph;
  setGraph(graph: FBBezierGraph): void;
  contour(): FBBezierContour;
  setContour(contour: FBBezierContour): void;
  edge(): FBBezierCurve;
  parameter(): FBFloat;
  distance(): FBFloat;
}

declare enum FBDebugIntersectionType {
  FBDebugIntersectionTypeNone,
  FBDebugIntersectionTypeEntry,
  FBDebugIntersectionTypeExit,
}

declare type FBDoublePoint = {
  x: FBDouble
  y: FBDouble
}

declare type FBDoubleSize = {
  width: FBDouble
  height: FBDouble
}

declare type FBDoubleRect = {
  origin: FBDoublePoint
  size: FBDoubleSize
}

declare type FBDouble = number

class FBEdgeCrossingAllocator<T extends FBEdgeCrossing> extends NSObjectAllocator<T> {
  initWithIntersection(intersection: FBBezierIntersection): T;
}
declare class FBEdgeCrossing extends NSObject {
  alloc<T extends FBEdgeCrossing>(): FBEdgeCrossingAllocator<T>;
  static crossingWithIntersection(intersection: FBBezierIntersection): FBEdgeCrossing;
  removeFromEdge(): void;
  isCoincidentWith(crossing: FBEdgeCrossing): boolean;
  nextUsingNonself(useNonself: boolean): FBEdgeCrossing;
  previousUsingNonself(useNonself: boolean): FBEdgeCrossing;
  isEqualToEdgeCrossing(crossing: FBEdgeCrossing): boolean;

  edge(): FBBezierCurve;
  setEdge(edge: FBBezierCurve): void;
  counterpart(): FBEdgeCrossing;
  setCounterpart(counterpart: FBEdgeCrossing): void;
  order(): FBFloat;
  entry(): boolean;
  setEntry(entry: boolean): void;
  processed(): boolean;
  setProcessed(processed: boolean): void;
  selfCrossing(): boolean;
  setSelfCrossing(selfCrossing: boolean): void;
  overlapRun(): FBEdgeOverlapRun;
  setOverlapRun(overlapRun: FBEdgeOverlapRun): void;
  fromCrossingOverlap(): boolean;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
  suspicious(): boolean;
  setSuspicious(suspicious: boolean): void;
  next(): FBEdgeCrossing;
  previous(): FBEdgeCrossing;
  parameter(): FBFloat;
  curve(): FBBezierCurve;
  leftCurve(): FBBezierCurve;
  rightCurve(): FBBezierCurve;
  atStart(): boolean;
  atEnd(): boolean;
  location(): FBPoint;
  intersection(): FBBezierIntersection;
}

declare type FBAngleRange = {
  minimum: FBFloat
  maximum: FBFloat
}

declare type FBRange = {
  minimum: FBFloat
  maximum: FBFloat
}

class FBTangentIteratorAllocator<T extends FBTangentIterator> extends NSObjectAllocator<T> {
  initWithIntersection_onCurve(intersection: FBBezierIntersection, curve: FBBezierCurve): T;
}
declare class FBTangentIterator extends NSObject {
  alloc<T extends FBTangentIterator>(): FBTangentIteratorAllocator<T>;
  static tangentIteratorWithIntersection_onCurve(intersection: FBBezierIntersection, curve: FBBezierCurve): FBTangentIterator;
  sync(other: FBTangentIterator): void;
  next(tangents: [FBPoint, FBPoint]): boolean;

  leftCurve(): FBBezierCurve;
  setLeftCurve(leftCurve: FBBezierCurve): void;
  rightCurve(): FBBezierCurve;
  setRightCurve(rightCurve: FBBezierCurve): void;
  offset(): FBFloat;
  setOffset(offset: FBFloat): void;
  offsetStep(): FBFloat;
  setOffsetStep(offsetStep: FBFloat): void;
  offsetMaximum(): FBFloat;
  setOffsetMaximum(offsetMaximum: FBFloat): void;
}

declare type FBPathElementType = any

declare enum FBContourInside {
  FBContourInsideFilled,
  FBContourInsideHole,
}

declare enum FBEdgeOverlapRunCrossingType {
  FBEdgeOverlapRunCrossingTypeUnknown = 0,
  FBEdgeOverlapRunCrossingTypeCrossing = 1<<1,
  FBEdgeOverlapRunCrossingTypeContainedByContour1 = 1<<2,
  FBEdgeOverlapRunCrossingTypeContainedByContour2 = 1<<3,
  FBEdgeOverlapRunCrossingTypeDisjoint = 1<<4,
  FBEdgeOverlapRunCrossingTypeContainedMask,
}

declare enum FBEdgeOverlapRunCrossingPosition {
  FBEdgeOverlapRunCrossingPositionMiddle,
  FBEdgeOverlapRunCrossingPositionInside,
  FBEdgeOverlapRunCrossingPositionOutside,
}

class BrushAllocator<T extends Brush> extends NSObjectAllocator<T> {}
declare class Brush extends NSObject {
  alloc<T extends Brush>(): BrushAllocator<T>;
  mouseDown_inView_onCanvas(theEvent: NSEvent, view: NSView, canvas: Canvas): void;
  mouseDragged_inView_onCanvas(theEvent: NSEvent, view: NSView, canvas: Canvas): void;
  mouseUp_inView_onCanvas(theEvent: NSEvent, view: NSView, canvas: Canvas): void;
}

class CanvasAllocator<T extends Canvas> extends NSObjectAllocator<T> {}
declare class Canvas extends NSObject {
  alloc<T extends Canvas>(): CanvasAllocator<T>;
  beginPathAtLocation_withWidth_color(location: NSPoint, width: CGFloat, color: NSColor): void;
  extendPathToLocation(location: NSPoint): void;
  endPath(): void;
  drawRect(dirtyRect: NSRect): void;

  showPoints(): boolean;
  setShowPoints(showPoints: boolean): void;
  simplify(): boolean;
  setSimplify(simplify: boolean): void;
  fitCurve(): boolean;
  setFitCurve(fitCurve: boolean): void;
}

class CanvasViewAllocator<T extends CanvasView> extends NSViewAllocator<T> {}
declare class CanvasView extends NSView {
  alloc<T extends CanvasView>(): CanvasViewAllocator<T>;

  showPoints(): boolean;
  setShowPoints(showPoints: boolean): void;
  simplify(): boolean;
  setSimplify(simplify: boolean): void;
  fitCurve(): boolean;
  setFitCurve(fitCurve: boolean): void;
}

class MyDocumentAllocator<T extends MyDocument> extends NSDocumentAllocator<T> {}
declare class MyDocument extends NSDocument {
  alloc<T extends MyDocument>(): MyDocumentAllocator<T>;
  toggleShowPoints(sender: any): IBAction;
  toggleSimplifyPath(sender: any): IBAction;
  toggleFitCurve(sender: any): IBAction;
}

declare type NSBezierElement = {
  kind: NSBezierPathElement
  point: NSPoint
  controlPoints: [NSPoint, NSPoint]
}

class AppControllerAllocator<T extends AppController> extends NSObjectAllocator<T> {}
declare class AppController extends NSObject implements INSApplicationDelegate, INSWindowDelegate, INSMenuDelegate, INSUserNotificationCenterDelegate, IMSDataMenuProviderDelegate, IMSDataSupplierManagerDelegate {
  alloc<T extends AppController>(): AppControllerAllocator<T>;
  actionClasses(): NSArray<any>;
  runPluginCommandWithIdentifier_fromBundleAtURL_context(identifier: NSString | string, url: NSURL, context: NSDictionary<any, any> | {[key: string]: any}): NSString;
  runPluginCommandWithIdentifier_fromBundleAtURL_context_portToAsnwerTo(identifier: NSString | string, url: NSURL, context: NSDictionary<any, any> | {[key: string]: any}, port: NSString | string): NSString;
  revealPlugin(sender: any): IBAction;
  buildPluginsMenu(menu: NSMenu): void;
  runPluginCommand_fromMenu_context(command: MSPluginCommand, fromMenu: boolean, context: NSDictionary<any, any> | {[key: string]: any}): NSString;
  runPluginScript_name(script: NSString | string, name: NSString | string): NSString;
  runPluginScript_handler_name_withPreprocess(script: NSString | string, handler: NSString | string, name: NSString | string, shoulPreprocess: boolean): NSString;
  validatePluginMenuItem_documentShowing(menuItem: NSMenuItem, documentShowing: boolean): boolean;
  registerURLScheme(): void;
  static sharedInstance(): AppController;
  checkDefaults(): void;
  openPreferencesWindowWithPreferencePaneIdentifier(identifier: NSString | string): void;
  openAboutWindow(sender: any): IBAction;
  revealTemplatesFolderInFinder(sender: any): IBAction;
  buy(sender: any): IBAction;
  refreshCurrentDocument(): void;
  currentDocumentDidChange(): void;
  refreshDocumentWindowBadges(): void;
  openTemplateAtPath(templateURL: NSURL): void;
  templateLibraryPath(): NSURL;
  toggleDarkMode(sender: any): IBAction;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  userNotificationCenter_didDeliverNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_didActivateNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_shouldPresentNotification(center: NSUserNotificationCenter, notification: NSUserNotification): boolean;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
  requestDataFromPluginDataSupplier_pluginContext(pluginDataSupplier: MSPluginDataSupplier, pluginContext: NSDictionary<any, any> | {[key: string]: any}): void;
  isThereAPluginForDataSupplier(pluginDataSupplier: MSPluginDataSupplier): boolean;
  pluginIconForIdentifier(pluginIdentifier: NSString | string): NSImage;
  pluginNameForIdentifier(pluginIdentifier: NSString | string): NSString;
  applicationShouldTerminate(sender: NSApplication): NSApplicationTerminateReply;
  application_openURLs(application: NSApplication, urls: NSArray<any> | any[]): void;
  application_openFile(sender: NSApplication, filename: NSString | string): boolean;
  application_openFiles(sender: NSApplication, filenames: NSArray<any> | any[]): void;
  application_openTempFile(sender: NSApplication, filename: NSString | string): boolean;
  applicationShouldOpenUntitledFile(sender: NSApplication): boolean;
  applicationOpenUntitledFile(sender: NSApplication): boolean;
  application_openFileWithoutUI(sender: any, filename: NSString | string): boolean;
  application_printFile(sender: NSApplication, filename: NSString | string): boolean;
  application_printFiles_withSettings_showPrintPanels(application: NSApplication, fileNames: NSArray<any> | any[], printSettings: NSDictionary<any, any> | {[key: string]: any}, showPrintPanels: boolean): NSApplicationPrintReply;
  applicationShouldTerminateAfterLastWindowClosed(sender: NSApplication): boolean;
  applicationShouldHandleReopen_hasVisibleWindows(sender: NSApplication, flag: boolean): boolean;
  applicationDockMenu(sender: NSApplication): NSMenu;
  application_willPresentError(application: NSApplication, error: NSError): NSError;
  application_didRegisterForRemoteNotificationsWithDeviceToken(application: NSApplication, deviceToken: NSData): void;
  application_didFailToRegisterForRemoteNotificationsWithError(application: NSApplication, error: NSError): void;
  application_didReceiveRemoteNotification(application: NSApplication, userInfo: NSDictionary<any, any> | {[key: string]: any}): void;
  application_willEncodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_didDecodeRestorableState(app: NSApplication, coder: NSCoder): void;
  application_willContinueUserActivityWithType(application: NSApplication, userActivityType: NSString | string): boolean;
  application_continueUserActivity_restorationHandler(application: NSApplication, userActivity: NSUserActivity, restorationHandler: Block): boolean;
  application_didFailToContinueUserActivityWithType_error(application: NSApplication, userActivityType: NSString | string, error: NSError): void;
  application_didUpdateUserActivity(application: NSApplication, userActivity: NSUserActivity): void;
  application_userDidAcceptCloudKitShareWithMetadata(application: NSApplication, metadata: CKShareMetadata): void;
  applicationWillFinishLaunching(notification: NSNotification): void;
  applicationDidFinishLaunching(notification: NSNotification): void;
  applicationWillHide(notification: NSNotification): void;
  applicationDidHide(notification: NSNotification): void;
  applicationWillUnhide(notification: NSNotification): void;
  applicationDidUnhide(notification: NSNotification): void;
  applicationWillBecomeActive(notification: NSNotification): void;
  applicationDidBecomeActive(notification: NSNotification): void;
  applicationWillResignActive(notification: NSNotification): void;
  applicationDidResignActive(notification: NSNotification): void;
  applicationWillUpdate(notification: NSNotification): void;
  applicationDidUpdate(notification: NSNotification): void;
  applicationWillTerminate(notification: NSNotification): void;
  applicationDidChangeScreenParameters(notification: NSNotification): void;
  applicationDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  userNotificationCenter_didDeliverNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_didActivateNotification(center: NSUserNotificationCenter, notification: NSUserNotification): void;
  userNotificationCenter_shouldPresentNotification(center: NSUserNotificationCenter, notification: NSUserNotification): boolean;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
  requestDataFromPluginDataSupplier_pluginContext(pluginDataSupplier: MSPluginDataSupplier, pluginContext: NSDictionary<any, any> | {[key: string]: any}): void;
  isThereAPluginForDataSupplier(pluginDataSupplier: MSPluginDataSupplier): boolean;
  pluginIconForIdentifier(pluginIdentifier: NSString | string): NSImage;
  pluginNameForIdentifier(pluginIdentifier: NSString | string): NSString;

  lastRun(): MSPluginCommand;
  shapesMenu(): any;
  setShapesMenu(shapesMenu: any): void;
  pluginsMenuItem(): NSMenuItem;
  setPluginsMenuItem(pluginsMenuItem: NSMenuItem): void;
  templatesMenu(): NSMenu;
  setTemplatesMenu(templatesMenu: NSMenu): void;
  printMenu(): NSMenu;
  setPrintMenu(printMenu: NSMenu): void;
  prototypingMenuItem(): NSMenuItem;
  setPrototypingMenuItem(prototypingMenuItem: NSMenuItem): void;
  debugMenuItem(): NSMenuItem;
  setDebugMenuItem(debugMenuItem: NSMenuItem): void;
  dataFeedMenuItem(): NSMenuItem;
  setDataFeedMenuItem(dataFeedMenuItem: NSMenuItem): void;
  cloudEnvironmentMenuItem(): NSMenuItem;
  setCloudEnvironmentMenuItem(cloudEnvironmentMenuItem: NSMenuItem): void;
  updateTimer(): NSTimer;
  setUpdateTimer(updateTimer: NSTimer): void;
  pasteboardManager(): MSPasteboardManager;
  setPasteboardManager(pasteboardManager: MSPasteboardManager): void;
  mirrorController(): SMKMirrorController;
  setMirrorController(mirrorController: SMKMirrorController): void;
  mirrorDataProvider(): MSMirrorDataProvider;
  setMirrorDataProvider(mirrorDataProvider: MSMirrorDataProvider): void;
  dataFeedProvider(): MSDataMenuProvider;
  dataSupplierManager(): MSDataSupplierManager;
  crashLogManager(): MSCrashLogManager;
  pluginManager(): MSPluginManagerWithActions;
  licenseManager(): BCLicenseManager;
  updateController(): MSUpdateController;
  actionController(): MSActionController;
  librariesController(): MSAssetLibraryController;
  hud(): MSHUDWindowController;
  creationTime(): NSTimeInterval;
  launchStartTime(): NSTimeInterval;
  launchEndTime(): NSTimeInterval;
  globalAssets(): MSPersistentAssetCollection;
  sketchSafeModeOn(): boolean;
  needToInformUserPluginsAreDisabled(): boolean;
  setNeedToInformUserPluginsAreDisabled(needToInformUserPluginsAreDisabled: boolean): void;
  canShowWelcomeWindowForUserAction(): boolean;
  canCreateDocuments(): boolean;
  setCanCreateDocuments(canCreateDocuments: boolean): void;
}

class BCBaseMagnifierButtonAllocator<T extends BCBaseMagnifierButton> extends NSButtonAllocator<T> {}
declare class BCBaseMagnifierButton extends NSButton {
  alloc<T extends BCBaseMagnifierButton>(): BCBaseMagnifierButtonAllocator<T>;
  color(): BCFlexibleColor;
  documentColorSpace(): NSColorSpace;
}

class BCFlexibleColorAllocator<T extends BCFlexibleColor> extends NSObjectAllocator<T> {}
declare class BCFlexibleColor extends NSObject {
  alloc<T extends BCFlexibleColor>(): BCFlexibleColorAllocator<T>;
  static colorWithRed_green_blue_alpha(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat): any;
  static colorWithHue_sat_light_alpha(hue: CGFloat, sat: CGFloat, light: CGFloat, alpha: CGFloat): any;
  colorForColorSpace(space: NSColorSpace): NSColor;
}

class BCFontSearchFieldAllocator<T extends BCFontSearchField> extends NSSearchFieldAllocator<T> {}
declare class BCFontSearchField extends NSSearchField implements INSTextViewDelegate {
  alloc<T extends BCFontSearchField>(): BCFontSearchFieldAllocator<T>;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;

  searchResults(): NSTableView;
  setSearchResults(searchResults: NSTableView): void;
}

class BCHexTextFieldAllocator<T extends BCHexTextField> extends NSTextFieldAllocator<T> {}
declare class BCHexTextField extends NSTextField {
  alloc<T extends BCHexTextField>(): BCHexTextFieldAllocator<T>;
}

class BCMagicWandAllocator<T extends BCMagicWand> extends NSOperationAllocator<T> {}
declare class BCMagicWand extends NSOperation {
  alloc<T extends BCMagicWand>(): BCMagicWandAllocator<T>;

  startPoint(): NSPoint;
  setStartPoint(startPoint: NSPoint): void;
  tolerance(): number;
  setTolerance(tolerance: number): void;
  bitmap(): NSBitmapImageRep;
  setBitmap(bitmap: NSBitmapImageRep): void;
}

class BCMagnifierAllocator<T extends BCMagnifier> extends NSObjectAllocator<T> {}
declare class BCMagnifier extends NSObject {
  alloc<T extends BCMagnifier>(): BCMagnifierAllocator<T>;
  static pickColorInColorSpace_completionHandler(colorSpace: NSColorSpace, completionHandler: BCMagnifierCompletionBlock): void;
}

class BCMagnifierWindowAllocator<T extends BCMagnifierWindow> extends NSWindowAllocator<T> {
  initWithScreenGrab_frameOffset(screenGrab: BCScreenGrab, offset: NSPoint): T;
}
declare class BCMagnifierWindow extends NSWindow {
  alloc<T extends BCMagnifierWindow>(): BCMagnifierWindowAllocator<T>;
  updateScreenGrabIfNeeded(screenGrab: BCScreenGrab): void;
  mouseMovedTo(mousePoint: NSPoint): void;
  setCurrentColor(color: BCFlexibleColor): void;
  flagsChanged(): void;

  frameOffset(): NSPoint;
  screenFrame(): CGRect;
  setScreenFrame(screenFrame: CGRect): void;
}

class BCMagnifierWindowContentViewAllocator<T extends BCMagnifierWindowContentView> extends NSViewAllocator<T> {}
declare class BCMagnifierWindowContentView extends NSView {
  alloc<T extends BCMagnifierWindowContentView>(): BCMagnifierWindowContentViewAllocator<T>;

  screenGrab(): BCScreenGrab;
  setScreenGrab(screenGrab: BCScreenGrab): void;
  currentColor(): BCFlexibleColor;
  setCurrentColor(currentColor: BCFlexibleColor): void;
}

class BCScreenGrabAllocator<T extends BCScreenGrab> extends NSObjectAllocator<T> {}
declare class BCScreenGrab extends NSObject {
  alloc<T extends BCScreenGrab>(): BCScreenGrabAllocator<T>;
  static screenGrabForDisplay_belowWindowWithID(displayID: CGDirectDisplayID, windowID: CGWindowID): BCScreenGrab;
  static screenGrabWithBitmapImageRep_originOnScreen_colorSpace_displayID(bitmapRep: NSBitmapImageRep, screenOrigin: NSPoint, colorSpace: NSColorSpace, displayID: CGDirectDisplayID): BCScreenGrab;
  bitmapImageRepCroppingToRect(r: NSRect): NSBitmapImageRep;

  displayID(): CGDirectDisplayID;
  image(): NSImage;
  bitmapRep(): NSBitmapImageRep;
  imageOrigin(): NSPoint;
  isRetinaScreen(): boolean;
  colorSpace(): NSColorSpace;
  screenFrame(): NSRect;
}

class BCSparkleLicensedUpdateCheckerAllocator<T extends BCSparkleLicensedUpdateChecker> extends NSObjectAllocator<T> {}
declare class BCSparkleLicensedUpdateChecker extends NSObject {
  alloc<T extends BCSparkleLicensedUpdateChecker>(): BCSparkleLicensedUpdateCheckerAllocator<T>;
  static sparkleCheckerWithLicenseExpirationDate_buildNumber_appcastResults(date: NSDate, buildNumber: NSString | string, results: NSArray<any> | any[]): BCSparkleLicensedUpdateChecker;

  numberOfUnavailableReleases(): NSUInteger;
  hasAvailableUpdates(): boolean;
  numberOfUpdatesRequiringRenewal(): NSUInteger;
  setNumberOfUpdatesRequiringRenewal(numberOfUpdatesRequiringRenewal: NSUInteger): void;
  numberOfUpdatesRequiringHostUpdate(): NSUInteger;
  setNumberOfUpdatesRequiringHostUpdate(numberOfUpdatesRequiringHostUpdate: NSUInteger): void;
  numberOfUpdatesRequiringHostUpdateAndRenewal(): NSUInteger;
  setNumberOfUpdatesRequiringHostUpdateAndRenewal(numberOfUpdatesRequiringHostUpdateAndRenewal: NSUInteger): void;
  latestUnavailableVersion(): NSString;
  latestUnavailableBuildNumber(): NSString;
  latestUnavailableVersionBeforeRenewing(): NSString;
  latestUnavailableBuildNumberBeforeRenewing(): NSString;
  latestUnavailableVersionBeforeUpdatingMac(): NSString;
  latestUnavailableBuildNumberBeforeUpdatingMac(): NSString;
  latestUnavailableVersionBeforeUpdatingMacAndRenewing(): NSString;
  latestUnavailableBuildNumberBeforeUpdatingMacAndRenewing(): NSString;
  indexOfBestUpdate(): NSUInteger;
}

class CHPlainWhiteViewAllocator<T extends CHPlainWhiteView> extends NSViewAllocator<T> {}
declare class CHPlainWhiteView extends NSView {
  alloc<T extends CHPlainWhiteView>(): CHPlainWhiteViewAllocator<T>;

  displayString(): NSString;
  setDisplayString(displayString: NSString | string): void;
}

class CHWhiteViewAllocator<T extends CHWhiteView> extends NSViewAllocator<T> {}
declare class CHWhiteView extends NSView {
  alloc<T extends CHWhiteView>(): CHWhiteViewAllocator<T>;
}

class CHLinedWhiteViewAllocator<T extends CHLinedWhiteView> extends CHPlainWhiteViewAllocator<T> {}
declare class CHLinedWhiteView extends CHPlainWhiteView {
  alloc<T extends CHLinedWhiteView>(): CHLinedWhiteViewAllocator<T>;
}

class BCAlphaColorPickerAllocator<T extends BCAlphaColorPicker> extends BCColorPickerSliderViewAllocator<T> {}
declare class BCAlphaColorPicker extends BCColorPickerSliderView {
  alloc<T extends BCAlphaColorPicker>(): BCAlphaColorPickerAllocator<T>;

  colorAlphaValue(): CGFloat;
  setColorAlphaValue(colorAlphaValue: CGFloat): void;
  color(): BCFlexibleColor;
  setColor(color: BCFlexibleColor): void;
}

class BCColorPickerBaseViewAllocator<T extends BCColorPickerBaseView> extends NSControlAllocator<T> {
  initInBounds(colorPickerBounds: NSRect): T;
}
declare class BCColorPickerBaseView extends NSControl {
  alloc<T extends BCColorPickerBaseView>(): BCColorPickerBaseViewAllocator<T>;
  drawContentInRect_dirtyRect(contentRect: NSRect, dirtyRect: NSRect): void;
  drawCheckerboardPatternInRect(rect: NSRect): void;
  drawMarkerInRect(rect: NSRect): void;
  contentBounds(): NSRect;
  markerShadow(): NSShadow;
  static darkShadow(): NSShadow;
  static drawFrameInRect_block(contentRect: NSRect, block: BCVoidBlock): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  hideSelection(): boolean;
  setHideSelection(hideSelection: boolean): void;
}

class BCColorPickerSliderViewAllocator<T extends BCColorPickerSliderView> extends BCColorPickerBaseViewAllocator<T> {}
declare class BCColorPickerSliderView extends BCColorPickerBaseView {
  alloc<T extends BCColorPickerSliderView>(): BCColorPickerSliderViewAllocator<T>;
  drawSelectionMarkerAtPosition(xPosition: NSInteger): void;
}

class BCColorPreviewAllocator<T extends BCColorPreview> extends NSPopUpButtonAllocator<T> {
  initInBounds(colorPickerBounds: NSRect): T;
}
declare class BCColorPreview extends NSPopUpButton implements INSMenuDelegate {
  alloc<T extends BCColorPreview>(): BCColorPreviewAllocator<T>;
  static menuItemForColorCounter_target_action_documentColorSpace_useHSB(colorCounter: MSColorCounter, target: any, action: string, colorSpace: NSColorSpace, useHSB: boolean): NSMenuItem;
  static shouldUseHSBInColorDescriptions(): boolean;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;

  color(): BCFlexibleColor;
  setColor(color: BCFlexibleColor): void;
  frequentColors(): NSArray<any>;
  setFrequentColors(frequentColors: NSArray<any> | any[]): void;
}

declare interface IBCColorPreviewDelegate {
  colorPreviewColorSpace(colorPreviewView: BCColorPreview): NSColorSpace;
}

class BCHSBColorPickerAllocator<T extends BCHSBColorPicker> extends NSControlAllocator<T> {}
declare class BCHSBColorPicker extends NSControl implements IBCColorPreviewDelegate, IBCMagnifierButtonDelegate {
  alloc<T extends BCHSBColorPicker>(): BCHSBColorPickerAllocator<T>;
  setColor_multipleValues(color: MSColor, multiple: boolean): void;
  hueChanged(sender: BCHueColorPicker): IBAction;
  alphaChanged(sender: BCAlphaColorPicker): IBAction;
  saturationBrightnessChanged(sender: BCSaturationBrightnessColorPicker): IBAction;
  rgbComponentFieldsChanged(sender: NSTextField): IBAction;
  hslComponentFieldsChanged(sender: NSTextField): IBAction;
  hexValueFieldChanged(sender: any): IBAction;
  frequentColorPicked(sender: any): IBAction;
  setFrequentColors(frequentColors: NSArray<any> | any[]): void;
  colorPreviewColorSpace(colorPreviewView: BCColorPreview): NSColorSpace;
  magnifierButtonDocumentColorSpace(button: BCMagnifierButton): NSColorSpace;
  colorPreviewColorSpace(colorPreviewView: BCColorPreview): NSColorSpace;
  magnifierButtonDocumentColorSpace(button: BCMagnifierButton): NSColorSpace;

  delegate(): any;
  setDelegate(delegate: any): void;
  color(): MSColor;
  setColor(color: MSColor): void;
  hexValueTextField(): NSTextField;
  setHexValueTextField(hexValueTextField: NSTextField): void;
  alphaComponentTextField(): NSTextField;
  setAlphaComponentTextField(alphaComponentTextField: NSTextField): void;
  separatorView(): MSColorInspectorSeparatorView;
  setSeparatorView(separatorView: MSColorInspectorSeparatorView): void;
}

declare interface IBCHSBColorPickerDelegate {
  hsbColorPickerDocumentColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
  hsbColorPickerPreviewColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
}

class BCHueColorPickerAllocator<T extends BCHueColorPicker> extends BCColorPickerSliderViewAllocator<T> {}
declare class BCHueColorPicker extends BCColorPickerSliderView {
  alloc<T extends BCHueColorPicker>(): BCHueColorPickerAllocator<T>;

  hueValue(): CGFloat;
  setHueValue(hueValue: CGFloat): void;
}

class BCMagnifierButtonAllocator<T extends BCMagnifierButton> extends BCBaseMagnifierButtonAllocator<T> {}
declare class BCMagnifierButton extends BCBaseMagnifierButton {
  alloc<T extends BCMagnifierButton>(): BCMagnifierButtonAllocator<T>;

  delegate(): any;
  setDelegate(delegate: any): void;
}

class BCMagnifierButtonCellAllocator<T extends BCMagnifierButtonCell> extends NSButtonCellAllocator<T> {}
declare class BCMagnifierButtonCell extends NSButtonCell {
  alloc<T extends BCMagnifierButtonCell>(): BCMagnifierButtonCellAllocator<T>;
}

declare interface IBCMagnifierButtonDelegate {
  magnifierButtonDocumentColorSpace(button: BCMagnifierButton): NSColorSpace;
}

class BCSaturationBrightnessColorPickerAllocator<T extends BCSaturationBrightnessColorPicker> extends BCColorPickerBaseViewAllocator<T> {}
declare class BCSaturationBrightnessColorPicker extends BCColorPickerBaseView {
  alloc<T extends BCSaturationBrightnessColorPicker>(): BCSaturationBrightnessColorPickerAllocator<T>;
}

class MSCustomShapeItemAllocator<T extends MSCustomShapeItem> extends MSInspectorItemAllocator<T> {}
declare class MSCustomShapeItem extends MSInspectorItem {
  alloc<T extends MSCustomShapeItem>(): MSCustomShapeItemAllocator<T>;
  refreshAndResetAction(sender: any): IBAction;
}

class MSAboutLinkButtonAllocator<T extends MSAboutLinkButton> extends MSHoverButtonAllocator<T> {}
declare class MSAboutLinkButton extends MSHoverButton {
  alloc<T extends MSAboutLinkButton>(): MSAboutLinkButtonAllocator<T>;
}

class MSAboutLinkButtonCellAllocator<T extends MSAboutLinkButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSAboutLinkButtonCell extends MSHoverButtonCell {
  alloc<T extends MSAboutLinkButtonCell>(): MSAboutLinkButtonCellAllocator<T>;
}

class MSAboutWindowControllerAllocator<T extends MSAboutWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSAboutWindowController extends NSWindowController {
  alloc<T extends MSAboutWindowController>(): MSAboutWindowControllerAllocator<T>;
  static showAboutWindow(): void;
  showAboutUsPage(sender: any): IBAction;
  showAcknowledgementsPage(sender: any): IBAction;
  showPurchaseLicensePage(sender: any): IBAction;
  showRenewLicensePage(sender: any): IBAction;
  unlinkDevice(sender: any): IBAction;

  backgroundImageView(): NSImageView;
  setBackgroundImageView(backgroundImageView: NSImageView): void;
  buildNumberTextField(): NSTextField;
  setBuildNumberTextField(buildNumberTextField: NSTextField): void;
  copyrightTextField(): NSTextField;
  setCopyrightTextField(copyrightTextField: NSTextField): void;
  expirationTitleTextField(): NSTextField;
  setExpirationTitleTextField(expirationTitleTextField: NSTextField): void;
  expirationDateTextField(): NSTextField;
  setExpirationDateTextField(expirationDateTextField: NSTextField): void;
  purchaseLicenseButton(): NSButton;
  setPurchaseLicenseButton(purchaseLicenseButton: NSButton): void;
  registeredToTextField(): NSTextField;
  setRegisteredToTextField(registeredToTextField: NSTextField): void;
  renewLicenseButton(): NSButton;
  setRenewLicenseButton(renewLicenseButton: NSButton): void;
  trialNoteTextField(): NSTextField;
  setTrialNoteTextField(trialNoteTextField: NSTextField): void;
  unlinkDeviceButton(): NSButton;
  setUnlinkDeviceButton(unlinkDeviceButton: NSButton): void;
  variantNameTextField(): NSTextField;
  setVariantNameTextField(variantNameTextField: NSTextField): void;
  versionTextField(): NSTextField;
  setVersionTextField(versionTextField: NSTextField): void;
}

class MSActionGroupAllocator<T extends MSActionGroup> extends MSDocumentActionAllocator<T> {}
declare class MSActionGroup extends MSDocumentAction {
  alloc<T extends MSActionGroup>(): MSActionGroupAllocator<T>;
  actionNames(): NSArray<any>;
  childActions(): NSArray<any>;
  supportsState(): boolean;
}

class MSAddAsLibraryActionAllocator<T extends MSAddAsLibraryAction> extends MSDocumentActionAllocator<T> {}
declare class MSAddAsLibraryAction extends MSDocumentAction {
  alloc<T extends MSAddAsLibraryAction>(): MSAddAsLibraryActionAllocator<T>;
  addAsLibraryAction(sender: any): IBAction;
}

class MSAddExportFormatActionAllocator<T extends MSAddExportFormatAction> extends MSDocumentActionAllocator<T> {}
declare class MSAddExportFormatAction extends MSDocumentAction {
  alloc<T extends MSAddExportFormatAction>(): MSAddExportFormatActionAllocator<T>;
  addExportFormat(sender: any): IBAction;
  addExportFormatToLayer(layer: MSLayer): void;
}

class MSAddFlowActionAllocator<T extends MSAddFlowAction> extends MSFlowBaseActionAllocator<T> {}
declare class MSAddFlowAction extends MSFlowBaseAction {
  alloc<T extends MSAddFlowAction>(): MSAddFlowActionAllocator<T>;
  addFlow(sender: any): IBAction;
}

class MSAddFlowBackActionAllocator<T extends MSAddFlowBackAction> extends MSFlowBaseActionAllocator<T> {}
declare class MSAddFlowBackAction extends MSFlowBaseAction {
  alloc<T extends MSAddFlowBackAction>(): MSAddFlowBackActionAllocator<T>;
  addFlowBack(sender: any): IBAction;
}

class MSAddFlowHomeActionAllocator<T extends MSAddFlowHomeAction> extends MSFlowBaseActionAllocator<T> {}
declare class MSAddFlowHomeAction extends MSFlowBaseAction {
  alloc<T extends MSAddFlowHomeAction>(): MSAddFlowHomeActionAllocator<T>;
  addFlowHome(sender: any): IBAction;
}

class MSInsertMenuActionAllocator<T extends MSInsertMenuAction> extends MSDocumentActionAllocator<T> {}
declare class MSInsertMenuAction extends MSDocumentAction {
  alloc<T extends MSInsertMenuAction>(): MSInsertMenuActionAllocator<T>;
}

class MSInsertImageActionAllocator<T extends MSInsertImageAction> extends MSBaseInsertActionAllocator<T> {}
declare class MSInsertImageAction extends MSBaseInsertAction {
  alloc<T extends MSInsertImageAction>(): MSInsertImageActionAllocator<T>;
  insertImage(sender: any): IBAction;
}

class MSPencilActionAllocator<T extends MSPencilAction> extends MSDocumentActionAllocator<T> {}
declare class MSPencilAction extends MSDocumentAction {
  alloc<T extends MSPencilAction>(): MSPencilActionAllocator<T>;
  pencil(sender: any): IBAction;
}

class MSAddRemoteLibraryActionAllocator<T extends MSAddRemoteLibraryAction> extends MSActionAllocator<T> {}
declare class MSAddRemoteLibraryAction extends MSAction {
  alloc<T extends MSAddRemoteLibraryAction>(): MSAddRemoteLibraryActionAllocator<T>;
  addAppcastURL(url: NSURL): void;
}

class MSBaseAlignLayersActionAllocator<T extends MSBaseAlignLayersAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseAlignLayersAction extends MSDocumentAction implements IMSAltButtonTarget {
  alloc<T extends MSBaseAlignLayersAction>(): MSBaseAlignLayersActionAllocator<T>;
  alignToKey(key: NSString | string): void;
  altButtonCanShowAltImage(altButton: MSAltButton): boolean;
  altButtonCanShowAltImage(altButton: MSAltButton): boolean;
}

class MSAlignLayersLeftActionAllocator<T extends MSAlignLayersLeftAction> extends MSBaseAlignLayersActionAllocator<T> {}
declare class MSAlignLayersLeftAction extends MSBaseAlignLayersAction {
  alloc<T extends MSAlignLayersLeftAction>(): MSAlignLayersLeftActionAllocator<T>;
  alignLayersLeft(sender: any): IBAction;
}

class MSAlignLayersCenterActionAllocator<T extends MSAlignLayersCenterAction> extends MSBaseAlignLayersActionAllocator<T> {}
declare class MSAlignLayersCenterAction extends MSBaseAlignLayersAction {
  alloc<T extends MSAlignLayersCenterAction>(): MSAlignLayersCenterActionAllocator<T>;
  alignLayersCenter(sender: any): IBAction;
}

class MSAlignLayersRightActionAllocator<T extends MSAlignLayersRightAction> extends MSBaseAlignLayersActionAllocator<T> {}
declare class MSAlignLayersRightAction extends MSBaseAlignLayersAction {
  alloc<T extends MSAlignLayersRightAction>(): MSAlignLayersRightActionAllocator<T>;
  alignLayersRight(sender: any): IBAction;
}

class MSAlignLayersTopActionAllocator<T extends MSAlignLayersTopAction> extends MSBaseAlignLayersActionAllocator<T> {}
declare class MSAlignLayersTopAction extends MSBaseAlignLayersAction {
  alloc<T extends MSAlignLayersTopAction>(): MSAlignLayersTopActionAllocator<T>;
  alignLayersTop(sender: any): IBAction;
}

class MSAlignLayersMiddleActionAllocator<T extends MSAlignLayersMiddleAction> extends MSBaseAlignLayersActionAllocator<T> {}
declare class MSAlignLayersMiddleAction extends MSBaseAlignLayersAction {
  alloc<T extends MSAlignLayersMiddleAction>(): MSAlignLayersMiddleActionAllocator<T>;
  alignLayersMiddle(sender: any): IBAction;
}

class MSAlignLayersBottomActionAllocator<T extends MSAlignLayersBottomAction> extends MSBaseAlignLayersActionAllocator<T> {}
declare class MSAlignLayersBottomAction extends MSBaseAlignLayersAction {
  alloc<T extends MSAlignLayersBottomAction>(): MSAlignLayersBottomActionAllocator<T>;
  alignLayersBottom(sender: any): IBAction;
}

class MSAlignmentActionsAllocator<T extends MSAlignmentActions> extends MSActionGroupAllocator<T> {}
declare class MSAlignmentActions extends MSActionGroup {
  alloc<T extends MSAlignmentActions>(): MSAlignmentActionsAllocator<T>;
}

class MSAlignmentBackgroundViewAllocator<T extends MSAlignmentBackgroundView> extends NSStackViewAllocator<T> {}
declare class MSAlignmentBackgroundView extends NSStackView {
  alloc<T extends MSAlignmentBackgroundView>(): MSAlignmentBackgroundViewAllocator<T>;
}

class MSAlternatingViewAllocator<T extends MSAlternatingView> extends NSViewAllocator<T> {}
declare class MSAlternatingView extends NSView {
  alloc<T extends MSAlternatingView>(): MSAlternatingViewAllocator<T>;

  otherView(): NSView;
  setOtherView(otherView: NSView): void;
}

class MSAnalyticsAllocator<T extends MSAnalytics> extends BCSingletonAllocator<T> {}
declare class MSAnalytics extends BCSingleton implements IMSActionObserver {
  alloc<T extends MSAnalytics>(): MSAnalyticsAllocator<T>;
  trackScreenWithName(name: NSString | string): void;
  trackEvent_withValue(event: NSString | string, value: any | null): void;
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;

  isEnabled(): boolean;
  setIsEnabled(isEnabled: boolean): void;
}

class MSAngularGradientEventHandlerAllocator<T extends MSAngularGradientEventHandler> extends MSGradientEventHandlerAllocator<T> {}
declare class MSAngularGradientEventHandler extends MSGradientEventHandler {
  alloc<T extends MSAngularGradientEventHandler>(): MSAngularGradientEventHandlerAllocator<T>;
}

class MSAppearanceInspectorSectionAllocator<T extends MSAppearanceInspectorSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSAppearanceInspectorSection extends MSBaseInspectorSection {
  alloc<T extends MSAppearanceInspectorSection>(): MSAppearanceInspectorSectionAllocator<T>;
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
}

class MSApplyOrientationActionAllocator<T extends MSApplyOrientationAction> extends MSDocumentActionAllocator<T> {}
declare class MSApplyOrientationAction extends MSDocumentAction {
  alloc<T extends MSApplyOrientationAction>(): MSApplyOrientationActionAllocator<T>;
}

class MSApplyLandscapeOrientationActionAllocator<T extends MSApplyLandscapeOrientationAction> extends MSApplyOrientationActionAllocator<T> {}
declare class MSApplyLandscapeOrientationAction extends MSApplyOrientationAction {
  alloc<T extends MSApplyLandscapeOrientationAction>(): MSApplyLandscapeOrientationActionAllocator<T>;
  applyLandscapeOrientation(sender: any): IBAction;
}

class MSApplyPortraitOrientationActionAllocator<T extends MSApplyPortraitOrientationAction> extends MSApplyOrientationActionAllocator<T> {}
declare class MSApplyPortraitOrientationAction extends MSApplyOrientationAction {
  alloc<T extends MSApplyPortraitOrientationAction>(): MSApplyPortraitOrientationActionAllocator<T>;
  applyPortraitOrientation(sender: any): IBAction;
}

class MSApplySharedStyleActionAllocator<T extends MSApplySharedStyleAction> extends MSDocumentActionAllocator<T> {}
declare class MSApplySharedStyleAction extends MSDocumentAction {
  alloc<T extends MSApplySharedStyleAction>(): MSApplySharedStyleActionAllocator<T>;
}

class MSApplySharedLayerStyleActionAllocator<T extends MSApplySharedLayerStyleAction> extends MSApplySharedStyleActionAllocator<T> {}
declare class MSApplySharedLayerStyleAction extends MSApplySharedStyleAction {
  alloc<T extends MSApplySharedLayerStyleAction>(): MSApplySharedLayerStyleActionAllocator<T>;
  applySharedLayerStyle(sender: any): IBAction;
}

class MSApplySharedTextStyleActionAllocator<T extends MSApplySharedTextStyleAction> extends MSApplySharedStyleActionAllocator<T> {}
declare class MSApplySharedTextStyleAction extends MSApplySharedStyleAction {
  alloc<T extends MSApplySharedTextStyleAction>(): MSApplySharedTextStyleActionAllocator<T>;
  applySharedTextStyle(sender: any): IBAction;
}

class MSBaseMoveActionAllocator<T extends MSBaseMoveAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseMoveAction extends MSDocumentAction {
  alloc<T extends MSBaseMoveAction>(): MSBaseMoveActionAllocator<T>;
}

class MSBaseMoveForwardActionAllocator<T extends MSBaseMoveForwardAction> extends MSBaseMoveActionAllocator<T> {}
declare class MSBaseMoveForwardAction extends MSBaseMoveAction {
  alloc<T extends MSBaseMoveForwardAction>(): MSBaseMoveForwardActionAllocator<T>;
}

class MSBaseMoveBackwardActionAllocator<T extends MSBaseMoveBackwardAction> extends MSBaseMoveActionAllocator<T> {}
declare class MSBaseMoveBackwardAction extends MSBaseMoveAction {
  alloc<T extends MSBaseMoveBackwardAction>(): MSBaseMoveBackwardActionAllocator<T>;
}

class MSMoveForwardActionAllocator<T extends MSMoveForwardAction> extends MSBaseMoveForwardActionAllocator<T> {}
declare class MSMoveForwardAction extends MSBaseMoveForwardAction {
  alloc<T extends MSMoveForwardAction>(): MSMoveForwardActionAllocator<T>;
  moveForward(sender: any): IBAction;
}

class MSMoveBackwardActionAllocator<T extends MSMoveBackwardAction> extends MSBaseMoveBackwardActionAllocator<T> {}
declare class MSMoveBackwardAction extends MSBaseMoveBackwardAction {
  alloc<T extends MSMoveBackwardAction>(): MSMoveBackwardActionAllocator<T>;
  moveBackward(sender: any): IBAction;
}

class MSMoveToFrontActionAllocator<T extends MSMoveToFrontAction> extends MSBaseMoveForwardActionAllocator<T> {}
declare class MSMoveToFrontAction extends MSBaseMoveForwardAction {
  alloc<T extends MSMoveToFrontAction>(): MSMoveToFrontActionAllocator<T>;
  moveToFront(sender: any): IBAction;
}

class MSMoveToBackActionAllocator<T extends MSMoveToBackAction> extends MSBaseMoveBackwardActionAllocator<T> {}
declare class MSMoveToBackAction extends MSBaseMoveBackwardAction {
  alloc<T extends MSMoveToBackAction>(): MSMoveToBackActionAllocator<T>;
  moveToBack(sender: any): IBAction;
}

class MSMoveActionGroupAllocator<T extends MSMoveActionGroup> extends MSActionGroupAllocator<T> {}
declare class MSMoveActionGroup extends MSActionGroup {
  alloc<T extends MSMoveActionGroup>(): MSMoveActionGroupAllocator<T>;
}

class MSArtboardContentResizeInspectorItemAllocator<T extends MSArtboardContentResizeInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSArtboardContentResizeInspectorItem extends MSInspectorItem {
  alloc<T extends MSArtboardContentResizeInspectorItem>(): MSArtboardContentResizeInspectorItemAllocator<T>;
}

class MSArtboardPositionInspectorItemAllocator<T extends MSArtboardPositionInspectorItem> extends MSPositionInspectorItemAllocator<T> {}
declare class MSArtboardPositionInspectorItem extends MSPositionInspectorItem {
  alloc<T extends MSArtboardPositionInspectorItem>(): MSArtboardPositionInspectorItemAllocator<T>;
}

declare enum MSArtboardPresetMatch {
  MSArtboardPresetMatchInvalid = 0,
  MSArtboardPresetMatchValid = 1 << 0,
  MSArtboardPresetMatchTall = 1 << 1,
  MSArtboardPresetMatchScaled = 1 << 2,
  MSArtboardPresetMatchRotated = 1 << 3,
}

class MSArtboardPresetInspectorItemAllocator<T extends MSArtboardPresetInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSArtboardPresetInspectorItem extends MSInspectorItem {
  alloc<T extends MSArtboardPresetInspectorItem>(): MSArtboardPresetInspectorItemAllocator<T>;
}

class MSArtboardPresetTableCellViewAllocator<T extends MSArtboardPresetTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSArtboardPresetTableCellView extends NSTableCellView {
  alloc<T extends MSArtboardPresetTableCellView>(): MSArtboardPresetTableCellViewAllocator<T>;

  checkmark(): NSImageView;
  setCheckmark(checkmark: NSImageView): void;
  sizeLabel(): NSTextField;
  setSizeLabel(sizeLabel: NSTextField): void;
}

class MSArtboardPresetsTableViewAllocator<T extends MSArtboardPresetsTableView> extends NSTableViewAllocator<T> {}
declare class MSArtboardPresetsTableView extends NSTableView {
  alloc<T extends MSArtboardPresetsTableView>(): MSArtboardPresetsTableViewAllocator<T>;
}

class MSArtboardPresetsViewControllerAllocator<T extends MSArtboardPresetsViewController> extends NSViewControllerAllocator<T> {}
declare class MSArtboardPresetsViewController extends NSViewController implements IBCPopoverDelegate {
  alloc<T extends MSArtboardPresetsViewController>(): MSArtboardPresetsViewControllerAllocator<T>;
  categoryForPreset(preset: MSArtboardPreset): MSArtboardPresetsCategory;
  addUserPreset(newPreset: MSArtboardPreset): void;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;

  presetStore(): MSArtboardPresetStore;
  setPresetStore(presetStore: MSArtboardPresetStore): void;
  categories(): NSArray<any>;
  selectedCategory(): MSArtboardPresetsCategory;
  setSelectedCategory(selectedCategory: MSArtboardPresetsCategory): void;
  orientation(): NSPaperOrientation;
  setOrientation(orientation: NSPaperOrientation): void;
  extraPresets(): NSArray<any>;
  setExtraPresets(extraPresets: NSArray<any> | any[]): void;
  selectedPresetSize(): NSSize;
  setSelectedPresetSize(selectedPresetSize: NSSize): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSArtboardPresetsViewControllerDelegate {
  artboardPresetsViewController_didSelectPreset(sender: MSArtboardPresetsViewController, preset: MSArtboardPreset): void;
  artboardPresetsViewController_didSelectOrientation(sender: MSArtboardPresetsViewController, orientation: NSPaperOrientation): void;
  showCustomPresetSheet(presetsController: MSArtboardPresetsViewController): void;
}

class MSArtboardResizeToFitInspectorItemAllocator<T extends MSArtboardResizeToFitInspectorItem> extends MSExportSelectedOrResizeInspectorItemAllocator<T> {}
declare class MSArtboardResizeToFitInspectorItem extends MSExportSelectedOrResizeInspectorItem {
  alloc<T extends MSArtboardResizeToFitInspectorItem>(): MSArtboardResizeToFitInspectorItemAllocator<T>;
}

class MSArtboardSizeInspectorItemAllocator<T extends MSArtboardSizeInspectorItem> extends MSBaseSizeInspectorItemAllocator<T> {}
declare class MSArtboardSizeInspectorItem extends MSBaseSizeInspectorItem {
  alloc<T extends MSArtboardSizeInspectorItem>(): MSArtboardSizeInspectorItemAllocator<T>;
}

class MSAssetLibrariesPreferencePaneAllocator<T extends MSAssetLibrariesPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSAssetLibrariesPreferencePane extends MSPreferencePane implements INSTableViewDelegate, INSTableViewDataSource {
  alloc<T extends MSAssetLibrariesPreferencePane>(): MSAssetLibrariesPreferencePaneAllocator<T>;
  importLibraryAction(sender: any): IBAction;
  removeLibraryAction(sender: any): IBAction;
  locateLibraryAction(sender: any): IBAction;
  addLibrariesFromURLS(urls: NSArray<any> | any[]): void;
  preferenceItemHasUpdated(item: MSAssetPreferenceItem): void;
  startDownloadForRemoteLibrary(remoteLibrary: MSRemoteAssetLibrary): void;
  reloadSelectingLibrary(library: MSAssetLibrary): void;
  updateAvailableForRemoteLibrary(remoteLibrary: MSRemoteAssetLibrary): void;
  displayInstallerAlertSheetForRemoteAssetLibrary(): void;
  displayDuplicateAlertSheetForRemoteAssetLibrary(remoteAssetLibrary: MSRemoteAssetLibrary): void;
  tableCellForLibrary(library: MSAssetLibrary): MSAssetLibraryTableCellView;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;

  tableView(): MSAssetLibraryTableView;
  setTableView(tableView: MSAssetLibraryTableView): void;
  assetLibraryController(): MSAssetLibraryController;
}

class MSAssetLibraryPreviewAllocator<T extends MSAssetLibraryPreview> extends NSViewAllocator<T> {}
declare class MSAssetLibraryPreview extends NSView {
  alloc<T extends MSAssetLibraryPreview>(): MSAssetLibraryPreviewAllocator<T>;

  libraryPreview(): NSImage;
  setLibraryPreview(libraryPreview: NSImage): void;
}

class MSAssetLibraryTableCellViewAllocator<T extends MSAssetLibraryTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSAssetLibraryTableCellView extends NSTableCellView {
  alloc<T extends MSAssetLibraryTableCellView>(): MSAssetLibraryTableCellViewAllocator<T>;
  startDownloading(): void;

  assetPreferenceItem(): MSAssetPreferenceItem;
}

class MSAssetLibraryTableViewAllocator<T extends MSAssetLibraryTableView> extends BCKeyEventActionTableViewAllocator<T> {}
declare class MSAssetLibraryTableView extends BCKeyEventActionTableView {
  alloc<T extends MSAssetLibraryTableView>(): MSAssetLibraryTableViewAllocator<T>;
}

class MSAssetPickerHeaderViewAllocator<T extends MSAssetPickerHeaderView> extends NSViewAllocator<T> {}
declare class MSAssetPickerHeaderView extends NSView {
  alloc<T extends MSAssetPickerHeaderView>(): MSAssetPickerHeaderViewAllocator<T>;
  static headerPickerWithTitle_isExpandedPreference_delegate(title: NSString | string, preferenceKey: NSString | string, delegate: any): MSAssetPickerHeaderView;
}

declare interface IMSAssetPickerHeaderViewDelegate {
  assetHeaderViewDidClick(headerView: MSAssetPickerHeaderView): void;
}

class MSAssetPickerViewAllocator<T extends MSAssetPickerView> extends NSViewAllocator<T> {}
declare class MSAssetPickerView extends NSView implements INSScrubberDataSource, INSScrubberDelegate, INSTouchBarDelegate {
  alloc<T extends MSAssetPickerView>(): MSAssetPickerViewAllocator<T>;
  reloadData(): void;
  numberOfItemsForScrubber(scrubber: NSScrubber): NSInteger;
  scrubber_viewForItemAtIndex(scrubber: NSScrubber, index: NSInteger): NSScrubberItemView;
  scrubber_didSelectItemAtIndex(scrubber: NSScrubber, selectedIndex: NSInteger): void;
  scrubber_didHighlightItemAtIndex(scrubber: NSScrubber, highlightedIndex: NSInteger): void;
  scrubber_didChangeVisibleRange(scrubber: NSScrubber, visibleRange: NSRange): void;
  didBeginInteractingWithScrubber(scrubber: NSScrubber): void;
  didFinishInteractingWithScrubber(scrubber: NSScrubber): void;
  didCancelInteractingWithScrubber(scrubber: NSScrubber): void;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  numberOfItemsForScrubber(scrubber: NSScrubber): NSInteger;
  scrubber_viewForItemAtIndex(scrubber: NSScrubber, index: NSInteger): NSScrubberItemView;
  scrubber_didSelectItemAtIndex(scrubber: NSScrubber, selectedIndex: NSInteger): void;
  scrubber_didHighlightItemAtIndex(scrubber: NSScrubber, highlightedIndex: NSInteger): void;
  scrubber_didChangeVisibleRange(scrubber: NSScrubber, visibleRange: NSRange): void;
  didBeginInteractingWithScrubber(scrubber: NSScrubber): void;
  didFinishInteractingWithScrubber(scrubber: NSScrubber): void;
  didCancelInteractingWithScrubber(scrubber: NSScrubber): void;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  delegate(): any;
  setDelegate(delegate: any): void;
  tileSize(): NSSize;
  setTileSize(tileSize: NSSize): void;
  tileMargin(): CGFloat;
  setTileMargin(tileMargin: CGFloat): void;
  edgeMargins(): NSEdgeInsets;
  setEdgeMargins(edgeMargins: NSEdgeInsets): void;
  hoveringIndex(): NSUInteger;
  setHoveringIndex(hoveringIndex: NSUInteger): void;
  currentIndexes(): NSIndexSet;
  setCurrentIndexes(currentIndexes: NSIndexSet): void;
  assetCollection(): MSAssetCollection;
  setAssetCollection(assetCollection: MSAssetCollection): void;
  assetType(): MSAsset;
  setAssetType(assetType: MSAsset): void;
}

class MSAssetPreferenceItemAllocator<T extends MSAssetPreferenceItem> extends NSObjectAllocator<T> {}
declare class MSAssetPreferenceItem extends NSObject {
  alloc<T extends MSAssetPreferenceItem>(): MSAssetPreferenceItemAllocator<T>;
  static preferenceItemForLibrary(library: MSAssetLibrary): MSAssetPreferenceItem;
  evaluateSecondaryTitle(): void;

  updatingStatus(): MSAssetLibraryUpdatingStatus;
  setUpdatingStatus(updatingStatus: MSAssetLibraryUpdatingStatus): void;
  updateAvailable(): boolean;
  delegate(): any;
  setDelegate(delegate: any): void;
  library(): MSAssetLibrary;
  remoteLibrary(): MSRemoteAssetLibrary;
  name(): NSString;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  validForSecondaryTextField(): boolean;
  preview(): NSImage;
  setPreview(preview: NSImage): void;
  secondaryTitle(): NSString;
  hasAppcastURL(): boolean;
  fileSize(): NSUInteger;
  setFileSize(fileSize: NSUInteger): void;
  downloadedSoFar(): NSUInteger;
  setDownloadedSoFar(downloadedSoFar: NSUInteger): void;
  missingRemoteLibraryWithNoInternet(): boolean;
}

declare interface IMSAssetPreferenceItemDelegate {
  preferenceItemHasUpdated(item: MSAssetPreferenceItem): void;
}

declare enum MSAssetLibraryUpdatingStatus {
  MSAssetLibraryUpdatingStatusNoDownloadAvailable = 0,
  MSAssetLibraryUpdatingStatusDownloadAvailable,
  MSAssetLibraryUpdatingStatusUpdateAvailable,
  MSAssetLibraryUpdatingStatusDownloading,
  MSAssetLibraryUpdatingStatusDownloadError,
  MSAssetLibraryUpdatingStatusWaitingForInstall,
}

class MSAssetScrubberItemViewAllocator<T extends MSAssetScrubberItemView> extends NSScrubberItemViewAllocator<T> {}
declare class MSAssetScrubberItemView extends NSScrubberItemView {
  alloc<T extends MSAssetScrubberItemView>(): MSAssetScrubberItemViewAllocator<T>;

  color(): MSColor;
  canvasColorSpace(): NSColorSpace;
  gradient(): MSGradient;
  pattern(): MSImageData;
  isFirstInCollection(): boolean;
  isLastInCollection(): boolean;
  tailPadding(): CGFloat;
}

class MSAssetSyncHeaderCellViewAllocator<T extends MSAssetSyncHeaderCellView> extends NSTableCellViewAllocator<T> {}
declare class MSAssetSyncHeaderCellView extends NSTableCellView {
  alloc<T extends MSAssetSyncHeaderCellView>(): MSAssetSyncHeaderCellViewAllocator<T>;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}

class MSAssetSyncItemTableCellViewAllocator<T extends MSAssetSyncItemTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSAssetSyncItemTableCellView extends NSTableCellView {
  alloc<T extends MSAssetSyncItemTableCellView>(): MSAssetSyncItemTableCellViewAllocator<T>;
}

class MSAssetSyncSheetAllocator<T extends MSAssetSyncSheet> extends CHSheetControllerAllocator<T> {}
declare class MSAssetSyncSheet extends CHSheetController {
  alloc<T extends MSAssetSyncSheet>(): MSAssetSyncSheetAllocator<T>;
}

class MSAssetSyncSheetHeaderAllocator<T extends MSAssetSyncSheetHeader> extends NSObjectAllocator<T> {}
declare class MSAssetSyncSheetHeader extends NSObject implements IMSAssetSyncSheetItem {
  alloc<T extends MSAssetSyncSheetHeader>(): MSAssetSyncSheetHeaderAllocator<T>;

  modifiedDateString(): NSString;
  type(): MSAssetSyncSheetItemType;
  library(): MSAssetLibrary;
  setLibrary(library: MSAssetLibrary): void;
  displayName(): NSString;
  shouldSync(): boolean;
}

declare interface IMSAssetSyncSheetItem {

  type(): MSAssetSyncSheetItemType;
  library(): MSAssetLibrary;
  setLibrary(library: MSAssetLibrary): void;
  displayName(): NSString;
  shouldSync(): boolean;
}

declare enum MSAssetSyncSheetItemType {
  MSAssetSyncSheetItemTypeHeader,
  MSAssetSyncSheetItemTypeSymbol,
  MSAssetSyncSheetItemTypeLayerStyle,
  MSAssetSyncSheetItemTypeTextStyle,
}

class MSAssetSyncSheetObjectAllocator<T extends MSAssetSyncSheetObject> extends NSObjectAllocator<T> {}
declare class MSAssetSyncSheetObject extends NSObject implements IMSAssetSyncSheetItem {
  alloc<T extends MSAssetSyncSheetObject>(): MSAssetSyncSheetObjectAllocator<T>;

  foreignObject(): MSForeignObject;
  setForeignObject(foreignObject: MSForeignObject): void;
  libraryMaster(): MSShareableObject;
  setLibraryMaster(libraryMaster: MSShareableObject): void;
  shouldSync(): boolean;
  setShouldSync(shouldSync: boolean): void;
  tooltipForLocal(): NSString;
  tooltipForRemote(): NSString;
  type(): MSAssetSyncSheetItemType;
  library(): MSAssetLibrary;
  setLibrary(library: MSAssetLibrary): void;
  displayName(): NSString;
}

class MSAutoExpandGroupsActionAllocator<T extends MSAutoExpandGroupsAction> extends MSDocumentActionAllocator<T> {}
declare class MSAutoExpandGroupsAction extends MSDocumentAction {
  alloc<T extends MSAutoExpandGroupsAction>(): MSAutoExpandGroupsActionAllocator<T>;
  autoExpandGroups(sender: any): IBAction;
}

class MSRevealInLayerListActionAllocator<T extends MSRevealInLayerListAction> extends MSDocumentActionAllocator<T> {}
declare class MSRevealInLayerListAction extends MSDocumentAction {
  alloc<T extends MSRevealInLayerListAction>(): MSRevealInLayerListActionAllocator<T>;
  revealInLayerList(sender: any): IBAction;
}

class MSBackButtonWindowControllerAllocator<T extends MSBackButtonWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSBackButtonWindowController extends NSWindowController {
  alloc<T extends MSBackButtonWindowController>(): MSBackButtonWindowControllerAllocator<T>;
  backButtonAction(sender: any): IBAction;
  attachToView_forArtboard(view: NSView, artboard: MSArtboardGroup): void;
  hide(): void;

  doc(): MSDocument;
  setDoc(doc: MSDocument): void;
}

class MSBackButtonContentViewAllocator<T extends MSBackButtonContentView> extends NSViewAllocator<T> {}
declare class MSBackButtonContentView extends NSView {
  alloc<T extends MSBackButtonContentView>(): MSBackButtonContentViewAllocator<T>;
}

class MSBackToInstanceActionAllocator<T extends MSBackToInstanceAction> extends MSDocumentActionAllocator<T> {}
declare class MSBackToInstanceAction extends MSDocumentAction {
  alloc<T extends MSBackToInstanceAction>(): MSBackToInstanceActionAllocator<T>;
  backToInstance(sender: any): IBAction;
}

class MSBackgroundColorViewAllocator<T extends MSBackgroundColorView> extends NSViewAllocator<T> {}
declare class MSBackgroundColorView extends NSView {
  alloc<T extends MSBackgroundColorView>(): MSBackgroundColorViewAllocator<T>;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
}

class MSBadgeControllerAllocator<T extends MSBadgeController> extends NSObjectAllocator<T> {
  initWithDocument(document: MSDocument): T;
}
declare class MSBadgeController extends NSObject {
  alloc<T extends MSBadgeController>(): MSBadgeControllerAllocator<T>;
  refresh(): void;

  activeWindowBadgingActions(): NSArray<any>;
}

class MSBadgeMenuActionAllocator<T extends MSBadgeMenuAction> extends MSDocumentActionAllocator<T> {}
declare class MSBadgeMenuAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSBadgeMenuAction>(): MSBadgeMenuActionAllocator<T>;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSBaseBlurInspectorItemAllocator<T extends MSBaseBlurInspectorItem> extends MSStylePartInspectorItemAllocator<T> {}
declare class MSBaseBlurInspectorItem extends MSStylePartInspectorItem implements IMSInspectorValueAdaptorDelegate {
  alloc<T extends MSBaseBlurInspectorItem>(): MSBaseBlurInspectorItemAllocator<T>;
  inspectorValueAdaptor_validateValue_forModel_context(adaptor: MSInspectorValueAdaptor, value: ModelValueType, model: any, context: any): boolean;
  inspectorValueAdaptorDidChangeValue(adaptor: MSInspectorValueAdaptor): void;
  inspectorValueAdaptor_didEncounterError(adaptor: MSInspectorValueAdaptor, error: NSError): void;
  inspectorValueAdaptor_validateValue_forModel_context(adaptor: MSInspectorValueAdaptor, value: ModelValueType, model: any, context: any): boolean;
  inspectorValueAdaptorDidChangeValue(adaptor: MSInspectorValueAdaptor): void;
  inspectorValueAdaptor_didEncounterError(adaptor: MSInspectorValueAdaptor, error: NSError): void;

  radiusField(): MSUpDownTextField;
  setRadiusField(radiusField: MSUpDownTextField): void;
  radiusSlider(): NSSlider;
  setRadiusSlider(radiusSlider: NSSlider): void;
}

class MSSimpleBlurInspectorItemAllocator<T extends MSSimpleBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<T> {}
declare class MSSimpleBlurInspectorItem extends MSBaseBlurInspectorItem {
  alloc<T extends MSSimpleBlurInspectorItem>(): MSSimpleBlurInspectorItemAllocator<T>;
}

class MSMotionBlurInspectorItemAllocator<T extends MSMotionBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<T> {}
declare class MSMotionBlurInspectorItem extends MSBaseBlurInspectorItem {
  alloc<T extends MSMotionBlurInspectorItem>(): MSMotionBlurInspectorItemAllocator<T>;
}

class MSZoomBlurInspectorItemAllocator<T extends MSZoomBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<T> {}
declare class MSZoomBlurInspectorItem extends MSBaseBlurInspectorItem {
  alloc<T extends MSZoomBlurInspectorItem>(): MSZoomBlurInspectorItemAllocator<T>;
}

class MSBackgroundBlurInspectorItemAllocator<T extends MSBackgroundBlurInspectorItem> extends MSBaseBlurInspectorItemAllocator<T> {}
declare class MSBackgroundBlurInspectorItem extends MSBaseBlurInspectorItem {
  alloc<T extends MSBackgroundBlurInspectorItem>(): MSBackgroundBlurInspectorItemAllocator<T>;

  saturationField(): MSUpDownTextField;
  setSaturationField(saturationField: MSUpDownTextField): void;
  saturationSlider(): NSSlider;
  setSaturationSlider(saturationSlider: NSSlider): void;
}

class MSBaseInsertActionAllocator<T extends MSBaseInsertAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseInsertAction extends MSDocumentAction {
  alloc<T extends MSBaseInsertAction>(): MSBaseInsertActionAllocator<T>;
}

class MSInspectorItemAllocator<T extends MSInspectorItem> extends NSViewControllerAllocator<T> {}
declare class MSInspectorItem extends NSViewController {
  alloc<T extends MSInspectorItem>(): MSInspectorItemAllocator<T>;
  manageTextField_adaptor_identifier_toolTip_touchBarItems(textField: MSUpDownTextField, adaptor: MSMathInspectorValueAdaptor, identifier: NSUserInterfaceItemIdentifier, toolTip: NSString | string, touchBarItems: NSArray<any> | any[] | null): void;
  static itemForSection(section: MSBaseInspectorSection): MSInspectorItem;
  selectionDidChangeTo(layers: MSLayerArray): void;
  updateDisplayedValues(): void;
  static filterSelection(layers: MSLayerArray): MSLayerArray;
  static canHandleSomeLayersOfSelection(layerArray: MSLayerArray): boolean;
  static canHandleLayer(layer: MSLayer): boolean;

  layers(): MSLayerArray;
  layersController(): NSArrayController;
  setLayersController(layersController: NSArrayController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  document(): MSDocument;
}

class MSBaseInspectorSectionAllocator<T extends MSBaseInspectorSection> extends NSViewControllerAllocator<T> {}
declare class MSBaseInspectorSection extends NSViewController implements IMSInspectorSection, IMSInspectorItemDelegate {
  alloc<T extends MSBaseInspectorSection>(): MSBaseInspectorSectionAllocator<T>;
  updateItems(): void;
  valuesPossiblyChanged(): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  canHandleColorMagnifierAction(): boolean;
  colorMagnifierAction(sender: any): IBAction;
  changeTextLayerFont(sender: any): IBAction;
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
  valuesPossiblyChanged(item: NSViewController): void;
  itemDidResize(item: NSViewController): void;
  documentForInspectorItem(section: NSViewController): MSDocument;
  item_wantsSectionToCollapse(item: NSViewController, collapse: boolean): void;
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
  valuesPossiblyChanged(item: NSViewController): void;
  itemDidResize(item: NSViewController): void;
  documentForInspectorItem(section: NSViewController): MSDocument;
  item_wantsSectionToCollapse(item: NSViewController, collapse: boolean): void;

  items(): NSArray<any>;
  setItems(items: NSArray<any> | any[]): void;
  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

class MSBaseSharedObjectActionAllocator<T extends MSBaseSharedObjectAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseSharedObjectAction extends MSDocumentAction {
  alloc<T extends MSBaseSharedObjectAction>(): MSBaseSharedObjectActionAllocator<T>;
  performSharedObjectAction(): void;

  updater(): MSShareableObjectUpdater;
  needsRenameAfterAction(): boolean;
}

class MSBaseSizeInspectorItemAllocator<T extends MSBaseSizeInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSBaseSizeInspectorItem extends MSInspectorItem {
  alloc<T extends MSBaseSizeInspectorItem>(): MSBaseSizeInspectorItemAllocator<T>;
  updateUI(): void;

  widthAdapter(): MSSizeInspectorValueAdaptor;
  setWidthAdapter(widthAdapter: MSSizeInspectorValueAdaptor): void;
  heightAdapter(): MSSizeInspectorValueAdaptor;
  setHeightAdapter(heightAdapter: MSSizeInspectorValueAdaptor): void;
}

class MSBaseTransformInspectorItemAllocator<T extends MSBaseTransformInspectorItem> extends MSInspectorItemAllocator<T> {
  initWithTitle_textFieldLabel(title: NSString | string, textFieldLabel: NSString | string): T;
}
declare class MSBaseTransformInspectorItem extends MSInspectorItem {
  alloc<T extends MSBaseTransformInspectorItem>(): MSBaseTransformInspectorItemAllocator<T>;

  textField(): MSUpDownTextField;
  setTextField(textField: MSUpDownTextField): void;
  flipSegmentedControl(): NSSegmentedControl;
  setFlipSegmentedControl(flipSegmentedControl: NSSegmentedControl): void;
  textFieldFormatter(): MSMathNumberFormatter;
  setTextFieldFormatter(textFieldFormatter: MSMathNumberFormatter): void;
}

class MSBitmapEditEventHandlerAllocator<T extends MSBitmapEditEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSBitmapEditEventHandler extends MSEventHandler {
  alloc<T extends MSBitmapEditEventHandler>(): MSBitmapEditEventHandlerAllocator<T>;
  invertAction(sender: any): IBAction;
  cropAction(sender: any): IBAction;
  selectLayerBelowPoint(mouse: NSPoint): void;
  fillSelectionWithColor(color: NSColor): void;
  bitmapEditableLayer(): MSLayer;
  imageSize(): NSSize;
  imageBounds(): NSRect;

  currentMode(): MSBitmapEditMode;
  setCurrentMode(currentMode: MSBitmapEditMode): void;
  accumulatedSelection(): NSBezierPath;
  setAccumulatedSelection(accumulatedSelection: NSBezierPath): void;
}

declare enum MSBitmapEditMode {
  MSBitmapEditModeRect,
  MSBitmapEditModeMagicWand,
}

class MSBitmapEditInspectorViewControllerAllocator<T extends MSBitmapEditInspectorViewController> extends NSViewControllerAllocator<T> {}
declare class MSBitmapEditInspectorViewController extends NSViewController implements IMSInspectorChildController {
  alloc<T extends MSBitmapEditInspectorViewController>(): MSBitmapEditInspectorViewControllerAllocator<T>;
  refresh(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;

  currentMode(): MSBitmapEditMode;
  setCurrentMode(currentMode: MSBitmapEditMode): void;
  hasSelection(): boolean;
  setHasSelection(hasSelection: boolean): void;
  eventHandler(): MSBitmapEditEventHandler;
  setEventHandler(eventHandler: MSBitmapEditEventHandler): void;
}

declare interface IMSBitmapEditable {

  image(): MSImageData;
  setImage(image: MSImageData): void;
  NSImage(): NSImage;
}

class MSBitmapEditorAllocator<T extends MSBitmapEditor> extends NSObjectAllocator<T> {}
declare class MSBitmapEditor extends NSObject {
  alloc<T extends MSBitmapEditor>(): MSBitmapEditorAllocator<T>;
  draw(): void;
  mouseDown_flags(mouse: NSPoint, flags: NSUInteger): void;
  mouseDragged(mouse: NSPoint): void;
  mouseUp_flags(mouse: NSPoint, flags: NSUInteger): void;
  refreshRectInBitmapCoordinates(bitmapRect: NSRect): void;
  drawMarchingAntsForPath(path: NSBezierPath): void;
  pointInBitmapLayer(mouse: NSPoint): NSPoint;
  imageSize(): NSSize;
  imageBounds(): NSRect;

  eventHandler(): MSBitmapEditEventHandler;
  setEventHandler(eventHandler: MSBitmapEditEventHandler): void;
  bitmapEditableLayer(): MSLayer;
  accumulatedSelection(): NSBezierPath;
  setAccumulatedSelection(accumulatedSelection: NSBezierPath): void;
}

class MSBitmapLayerItemAllocator<T extends MSBitmapLayerItem> extends MSInspectorItemAllocator<T> {}
declare class MSBitmapLayerItem extends MSInspectorItem {
  alloc<T extends MSBitmapLayerItem>(): MSBitmapLayerItemAllocator<T>;
}

class MSBitmapMagicWandEditorAllocator<T extends MSBitmapMagicWandEditor> extends MSBitmapEditorAllocator<T> {}
declare class MSBitmapMagicWandEditor extends MSBitmapEditor {
  alloc<T extends MSBitmapMagicWandEditor>(): MSBitmapMagicWandEditorAllocator<T>;
}

class MSBitmapOverrideInspectorItemAllocator<T extends MSBitmapOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<T> {}
declare class MSBitmapOverrideInspectorItem extends MSOverrideInspectorItem implements IMSDataMenuProviderDelegate {
  alloc<T extends MSBitmapOverrideInspectorItem>(): MSBitmapOverrideInspectorItemAllocator<T>;
  NSImage(): NSImage;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
}

class MSBitmapRectangleEditorAllocator<T extends MSBitmapRectangleEditor> extends MSBitmapEditorAllocator<T> {}
declare class MSBitmapRectangleEditor extends MSBitmapEditor {
  alloc<T extends MSBitmapRectangleEditor>(): MSBitmapRectangleEditorAllocator<T>;
  sizeForLabel(): NSSize;
}

class MSBlockAnimationAllocator<T extends MSBlockAnimation> extends CABasicAnimationAllocator<T> {
  initWithBlock(aBlock: MSAnimationBlock): T;
}
declare class MSBlockAnimation extends CABasicAnimation {
  alloc<T extends MSBlockAnimation>(): MSBlockAnimationAllocator<T>;
}

class MSBlurInspectorViewControllerAllocator<T extends MSBlurInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<T> {}
declare class MSBlurInspectorViewController extends MSStylePartInspectorViewController implements INSMenuDelegate {
  alloc<T extends MSBlurInspectorViewController>(): MSBlurInspectorViewControllerAllocator<T>;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

class MSBlurNameInspectorItemAllocator<T extends MSBlurNameInspectorItem> extends MSStylePartInspectorItemAllocator<T> {}
declare class MSBlurNameInspectorItem extends MSStylePartInspectorItem {
  alloc<T extends MSBlurNameInspectorItem>(): MSBlurNameInspectorItemAllocator<T>;
}

class MSBlurPopUpButtonCellAllocator<T extends MSBlurPopUpButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSBlurPopUpButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSBlurPopUpButtonCell>(): MSBlurPopUpButtonCellAllocator<T>;
}

class MSBooleanMenuActionAllocator<T extends MSBooleanMenuAction> extends MSDocumentActionAllocator<T> {}
declare class MSBooleanMenuAction extends MSDocumentAction {
  alloc<T extends MSBooleanMenuAction>(): MSBooleanMenuActionAllocator<T>;
}

class MSBaseBooleanActionAllocator<T extends MSBaseBooleanAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseBooleanAction extends MSDocumentAction {
  alloc<T extends MSBaseBooleanAction>(): MSBaseBooleanActionAllocator<T>;
  booleanOperation(): MSBooleanOperation;
}

class MSSubtractActionAllocator<T extends MSSubtractAction> extends MSBaseBooleanActionAllocator<T> {}
declare class MSSubtractAction extends MSBaseBooleanAction {
  alloc<T extends MSSubtractAction>(): MSSubtractActionAllocator<T>;
  booleanSubtract(sender: any): IBAction;
}

class MSUnionActionAllocator<T extends MSUnionAction> extends MSBaseBooleanActionAllocator<T> {}
declare class MSUnionAction extends MSBaseBooleanAction {
  alloc<T extends MSUnionAction>(): MSUnionActionAllocator<T>;
  booleanUnion(sender: any): IBAction;
}

class MSIntersectActionAllocator<T extends MSIntersectAction> extends MSBaseBooleanActionAllocator<T> {}
declare class MSIntersectAction extends MSBaseBooleanAction {
  alloc<T extends MSIntersectAction>(): MSIntersectActionAllocator<T>;
  booleanIntersect(sender: any): IBAction;
}

class MSDifferenceActionAllocator<T extends MSDifferenceAction> extends MSBaseBooleanActionAllocator<T> {}
declare class MSDifferenceAction extends MSBaseBooleanAction {
  alloc<T extends MSDifferenceAction>(): MSDifferenceActionAllocator<T>;
  booleanDifference(sender: any): IBAction;
}

class MSBooleanActionGroupAllocator<T extends MSBooleanActionGroup> extends MSActionGroupAllocator<T> {}
declare class MSBooleanActionGroup extends MSActionGroup {
  alloc<T extends MSBooleanActionGroup>(): MSBooleanActionGroupAllocator<T>;
}

class MSBorderInspectorViewControllerAllocator<T extends MSBorderInspectorViewController> extends MSColorStylePartInspectorViewControllerAllocator<T> {}
declare class MSBorderInspectorViewController extends MSColorStylePartInspectorViewController {
  alloc<T extends MSBorderInspectorViewController>(): MSBorderInspectorViewControllerAllocator<T>;
  enableAction(sender: any): IBAction;

  positionPopUp(): NSPopUpButton;
  setPositionPopUp(positionPopUp: NSPopUpButton): void;
  thicknessField(): MSUpDownTextField;
  setThicknessField(thicknessField: MSUpDownTextField): void;
}

class MSBorderOptionsInspectorViewControllerAllocator<T extends MSBorderOptionsInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<T> {}
declare class MSBorderOptionsInspectorViewController extends MSStylePartInspectorViewController {
  alloc<T extends MSBorderOptionsInspectorViewController>(): MSBorderOptionsInspectorViewControllerAllocator<T>;
  startDecorationAction(sender: any): IBAction;
  endDecorationAction(sender: any): IBAction;
  capAction(sender: any): IBAction;
  joinAction(sender: any): IBAction;
  dashPatternAction(sender: any): IBAction;
  reloadData(): void;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}

class MSBottomGradientViewAllocator<T extends MSBottomGradientView> extends NSViewAllocator<T> {}
declare class MSBottomGradientView extends NSView {
  alloc<T extends MSBottomGradientView>(): MSBottomGradientViewAllocator<T>;
}

class MSCallToActionButtonAllocator<T extends MSCallToActionButton> extends MSHoverButtonAllocator<T> {}
declare class MSCallToActionButton extends MSHoverButton {
  alloc<T extends MSCallToActionButton>(): MSCallToActionButtonAllocator<T>;
}

class MSCallToActionButtonCellAllocator<T extends MSCallToActionButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSCallToActionButtonCell extends MSHoverButtonCell {
  alloc<T extends MSCallToActionButtonCell>(): MSCallToActionButtonCellAllocator<T>;
}

class MSCallToActionButtonDividerViewAllocator<T extends MSCallToActionButtonDividerView> extends NSViewAllocator<T> {}
declare class MSCallToActionButtonDividerView extends NSView {
  alloc<T extends MSCallToActionButtonDividerView>(): MSCallToActionButtonDividerViewAllocator<T>;
}

class MSZoomToActualSizeActionAllocator<T extends MSZoomToActualSizeAction> extends MSDocumentActionAllocator<T> {}
declare class MSZoomToActualSizeAction extends MSDocumentAction {
  alloc<T extends MSZoomToActualSizeAction>(): MSZoomToActualSizeActionAllocator<T>;
  actualSize(sender: any): IBAction;
}

class MSZoomToSelectionActionAllocator<T extends MSZoomToSelectionAction> extends MSDocumentActionAllocator<T> {}
declare class MSZoomToSelectionAction extends MSDocumentAction {
  alloc<T extends MSZoomToSelectionAction>(): MSZoomToSelectionActionAllocator<T>;
}

class MSZoomToArtboardActionAllocator<T extends MSZoomToArtboardAction> extends MSDocumentActionAllocator<T> {}
declare class MSZoomToArtboardAction extends MSDocumentAction {
  alloc<T extends MSZoomToArtboardAction>(): MSZoomToArtboardActionAllocator<T>;
}

class MSCenterSelectionInVisibleAreaActionAllocator<T extends MSCenterSelectionInVisibleAreaAction> extends MSDocumentActionAllocator<T> {}
declare class MSCenterSelectionInVisibleAreaAction extends MSDocumentAction {
  alloc<T extends MSCenterSelectionInVisibleAreaAction>(): MSCenterSelectionInVisibleAreaActionAllocator<T>;
}

class MSCenterLayersInCanvasActionAllocator<T extends MSCenterLayersInCanvasAction> extends MSDocumentActionAllocator<T> {}
declare class MSCenterLayersInCanvasAction extends MSDocumentAction {
  alloc<T extends MSCenterLayersInCanvasAction>(): MSCenterLayersInCanvasActionAllocator<T>;
}

class MSSelectAllActionAllocator<T extends MSSelectAllAction> extends MSDocumentActionAllocator<T> {}
declare class MSSelectAllAction extends MSDocumentAction {
  alloc<T extends MSSelectAllAction>(): MSSelectAllActionAllocator<T>;
}

class MSCutActionAllocator<T extends MSCutAction> extends MSDocumentActionAllocator<T> {}
declare class MSCutAction extends MSDocumentAction {
  alloc<T extends MSCutAction>(): MSCutActionAllocator<T>;
}

class MSCopyActionAllocator<T extends MSCopyAction> extends MSDocumentActionAllocator<T> {}
declare class MSCopyAction extends MSDocumentAction {
  alloc<T extends MSCopyAction>(): MSCopyActionAllocator<T>;
}

class MSPasteActionAllocator<T extends MSPasteAction> extends MSDocumentActionAllocator<T> {}
declare class MSPasteAction extends MSDocumentAction {
  alloc<T extends MSPasteAction>(): MSPasteActionAllocator<T>;
}

class MSPasteWithStyleActionAllocator<T extends MSPasteWithStyleAction> extends MSDocumentActionAllocator<T> {}
declare class MSPasteWithStyleAction extends MSDocumentAction {
  alloc<T extends MSPasteWithStyleAction>(): MSPasteWithStyleActionAllocator<T>;
}

class MSPasteOverSelectionActionAllocator<T extends MSPasteOverSelectionAction> extends MSDocumentActionAllocator<T> {}
declare class MSPasteOverSelectionAction extends MSDocumentAction {
  alloc<T extends MSPasteOverSelectionAction>(): MSPasteOverSelectionActionAllocator<T>;
}

class MSPasteHereActionAllocator<T extends MSPasteHereAction> extends MSDocumentActionAllocator<T> {}
declare class MSPasteHereAction extends MSDocumentAction {
  alloc<T extends MSPasteHereAction>(): MSPasteHereActionAllocator<T>;
}

class MSDuplicateActionAllocator<T extends MSDuplicateAction> extends MSDocumentActionAllocator<T> {}
declare class MSDuplicateAction extends MSDocumentAction {
  alloc<T extends MSDuplicateAction>(): MSDuplicateActionAllocator<T>;
}

class MSDeleteActionAllocator<T extends MSDeleteAction> extends MSDocumentActionAllocator<T> {}
declare class MSDeleteAction extends MSDocumentAction {
  alloc<T extends MSDeleteAction>(): MSDeleteActionAllocator<T>;
}

class MSCanvasPreferencePaneAllocator<T extends MSCanvasPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSCanvasPreferencePane extends MSPreferencePane {
  alloc<T extends MSCanvasPreferencePane>(): MSCanvasPreferencePaneAllocator<T>;
  adjustSnapColorAction(sender: any): IBAction;
  adjustFlowColorAction(sender: any): IBAction;

  flowColorWell(): NSColorWell;
  setFlowColorWell(flowColorWell: NSColorWell): void;
  flowColorLabel(): NSTextField;
  setFlowColorLabel(flowColorLabel: NSTextField): void;
}

class MSCanvasUpdatingSheetAllocator<T extends MSCanvasUpdatingSheet> extends CHSheetControllerAllocator<T> {}
declare class MSCanvasUpdatingSheet extends CHSheetController {
  alloc<T extends MSCanvasUpdatingSheet>(): MSCanvasUpdatingSheetAllocator<T>;
  performOperation(): void;
  schedulePerformOperation(): void;
  triggerPerformOperation(): void;
  storeState(): void;
  restoreState(): void;
  historyMomentTitle(): NSString;
  doc(): MSDocument;
}

class MSCenteredPopUpButtonCellAllocator<T extends MSCenteredPopUpButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSCenteredPopUpButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSCenteredPopUpButtonCell>(): MSCenteredPopUpButtonCellAllocator<T>;
}

class MSChangeFontActionAllocator<T extends MSChangeFontAction> extends MSDocumentActionAllocator<T> {}
declare class MSChangeFontAction extends MSDocumentAction {
  alloc<T extends MSChangeFontAction>(): MSChangeFontActionAllocator<T>;
  changeTextLayerFont(sender: any): IBAction;
}

class MSSilentCheckForUpdatesActionAllocator<T extends MSSilentCheckForUpdatesAction> extends MSActionAllocator<T> {}
declare class MSSilentCheckForUpdatesAction extends MSAction {
  alloc<T extends MSSilentCheckForUpdatesAction>(): MSSilentCheckForUpdatesActionAllocator<T>;
}

class MSQuietCheckForUpdatesActionAllocator<T extends MSQuietCheckForUpdatesAction> extends MSSilentCheckForUpdatesActionAllocator<T> {}
declare class MSQuietCheckForUpdatesAction extends MSSilentCheckForUpdatesAction {
  alloc<T extends MSQuietCheckForUpdatesAction>(): MSQuietCheckForUpdatesActionAllocator<T>;
}

class MSCheckForUpdatesActionAllocator<T extends MSCheckForUpdatesAction> extends MSSilentCheckForUpdatesActionAllocator<T> {}
declare class MSCheckForUpdatesAction extends MSSilentCheckForUpdatesAction {
  alloc<T extends MSCheckForUpdatesAction>(): MSCheckForUpdatesActionAllocator<T>;
  checkForUpdates(sender: any): IBAction;
}

class MSClippingMaskActionAllocator<T extends MSClippingMaskAction> extends MSDocumentActionAllocator<T> {}
declare class MSClippingMaskAction extends MSDocumentAction {
  alloc<T extends MSClippingMaskAction>(): MSClippingMaskActionAllocator<T>;
  clippingMask(sender: any): IBAction;
}

class MSClippingMaskModeActionAllocator<T extends MSClippingMaskModeAction> extends MSDocumentActionAllocator<T> {}
declare class MSClippingMaskModeAction extends MSDocumentAction {
  alloc<T extends MSClippingMaskModeAction>(): MSClippingMaskModeActionAllocator<T>;
  clippingMaskMode(sender: any): IBAction;
}

class MSClosePathActionAllocator<T extends MSClosePathAction> extends MSDocumentActionAllocator<T> {}
declare class MSClosePathAction extends MSDocumentAction {
  alloc<T extends MSClosePathAction>(): MSClosePathActionAllocator<T>;
  closePath(sender: any): IBAction;
}

class MSCloudActionAllocator<T extends MSCloudAction> extends MSPopoverActionAllocator<T> {}
declare class MSCloudAction extends MSPopoverAction {
  alloc<T extends MSCloudAction>(): MSCloudActionAllocator<T>;
  startUploadUpdating(existingShare: SCKShare | null): void;
  refreshShareWithHandler(handler: Block): void;
  static isErrorRecoverable(error: NSError): boolean;
  static cloudError_addingRecoveryOptionsWithAttempter(error: NSError, attempter: any): NSError;
  static attemptRecoveryFromCloudError_optionIndex(error: NSError, recoveryOptionIndex: NSUInteger): void;
  static cloudEnabled(): boolean;
  static openCloudUploadURL_parameters(url: NSURL, parameters: NSDictionary<any, any> | {[key: string]: any}): void;
  static addRemoteLibraryWithURL_parameters(url: NSURL, parameters: NSDictionary<any, any> | {[key: string]: any}): void;
  updateProgressImage(): void;

  exportedDocument(): any;
  upload(): MSCloudShareUploadController;
  setUpload(upload: MSCloudShareUploadController): void;
  refreshOperation(): SCKAPIOperation;
  setRefreshOperation(refreshOperation: SCKAPIOperation): void;
}

class MSCloudAvatarViewAllocator<T extends MSCloudAvatarView> extends NSViewAllocator<T> {}
declare class MSCloudAvatarView extends NSView {
  alloc<T extends MSCloudAvatarView>(): MSCloudAvatarViewAllocator<T>;

  avatar(): SCKAvatar;
  setAvatar(avatar: SCKAvatar): void;
}

class MSCloudBaseViewControllerAllocator<T extends MSCloudBaseViewController> extends MSToolbarPopoverContentViewControllerAllocator<T> {}
declare class MSCloudBaseViewController extends MSToolbarPopoverContentViewController {
  alloc<T extends MSCloudBaseViewController>(): MSCloudBaseViewControllerAllocator<T>;
  cloudBaseViewControllerDidAppear(): void;

  cloudAction(): MSCloudAction;
  cloudViewController(): MSCloudViewController;
}

class MSCloudDocumentViewControllerAllocator<T extends MSCloudDocumentViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudDocumentViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudDocumentViewController>(): MSCloudDocumentViewControllerAllocator<T>;
}

class MSCloudInitialViewControllerAllocator<T extends MSCloudInitialViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudInitialViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudInitialViewController>(): MSCloudInitialViewControllerAllocator<T>;
}

class MSCloudInvalidLicenseViewControllerAllocator<T extends MSCloudInvalidLicenseViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudInvalidLicenseViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudInvalidLicenseViewController>(): MSCloudInvalidLicenseViewControllerAllocator<T>;
}

class MSCloudLoginWindowControllerAllocator<T extends MSCloudLoginWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSCloudLoginWindowController extends NSWindowController {
  alloc<T extends MSCloudLoginWindowController>(): MSCloudLoginWindowControllerAllocator<T>;

  delegate(): any;
  setDelegate(delegate: any): void;
  isLoading(): boolean;
  setIsLoading(isLoading: boolean): void;
  email(): NSString;
  setEmail(email: NSString | string): void;
  password(): NSString;
  setPassword(password: NSString | string): void;
}

declare interface IMSCloudLoginWindowControllerDelegate {
  cloudLoginControllerDidSignIn(controller: MSCloudLoginWindowController): void;
  cloudLoginControllerDidOpenBrowser(controller: MSCloudLoginWindowController): void;
  cloudLoginControllerDidCancel(controller: MSCloudLoginWindowController): void;
}

class MSCloudPreferencePaneAllocator<T extends MSCloudPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSCloudPreferencePane extends MSPreferencePane {
  alloc<T extends MSCloudPreferencePane>(): MSCloudPreferencePaneAllocator<T>;
  updateWindowFrame(): void;
  static loginWithURLParameters(parameters: NSDictionary<any, any> | {[key: string]: any} | null): void;
}

class MSCloudPreferencesAccountViewControllerAllocator<T extends MSCloudPreferencesAccountViewController> extends MSCloudPreferencesViewControllerAllocator<T> {}
declare class MSCloudPreferencesAccountViewController extends MSCloudPreferencesViewController {
  alloc<T extends MSCloudPreferencesAccountViewController>(): MSCloudPreferencesAccountViewControllerAllocator<T>;
}

class MSCloudPreferencesIntroViewControllerAllocator<T extends MSCloudPreferencesIntroViewController> extends MSCloudPreferencesViewControllerAllocator<T> {}
declare class MSCloudPreferencesIntroViewController extends MSCloudPreferencesViewController {
  alloc<T extends MSCloudPreferencesIntroViewController>(): MSCloudPreferencesIntroViewControllerAllocator<T>;
}

class MSCloudPreferencesViewControllerAllocator<T extends MSCloudPreferencesViewController> extends NSViewControllerAllocator<T> {}
declare class MSCloudPreferencesViewController extends NSViewController {
  alloc<T extends MSCloudPreferencesViewController>(): MSCloudPreferencesViewControllerAllocator<T>;
  popToRootViewController(sender: any | null): IBAction;
  showAlert(alert: NSAlert): void;

  preferencePane(): MSCloudPreferencePane;
}

class MSCloudReuploadViewControllerAllocator<T extends MSCloudReuploadViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudReuploadViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudReuploadViewController>(): MSCloudReuploadViewControllerAllocator<T>;
}

class MSCloudRoundedViewAllocator<T extends MSCloudRoundedView> extends NSViewAllocator<T> {}
declare class MSCloudRoundedView extends NSView {
  alloc<T extends MSCloudRoundedView>(): MSCloudRoundedViewAllocator<T>;
}

class MSCloudShareCollectionItemAllocator<T extends MSCloudShareCollectionItem> extends MSExistingDocumentCollectionItemAllocator<T> {
  initWithController_cloudShare(controller: MSWelcomeWindowController, share: SCKShare): T;
}
declare class MSCloudShareCollectionItem extends MSExistingDocumentCollectionItem {
  alloc<T extends MSCloudShareCollectionItem>(): MSCloudShareCollectionItemAllocator<T>;
  downloadLatestDocument(handler: Block): void;

  cloudShare(): SCKShare;
  latestDocument(): SCKCloudDocument;
  downloadProgress(): NSProgress;
}

class MSCloudUploadArrowViewAllocator<T extends MSCloudUploadArrowView> extends NSViewAllocator<T> {}
declare class MSCloudUploadArrowView extends NSView {
  alloc<T extends MSCloudUploadArrowView>(): MSCloudUploadArrowViewAllocator<T>;
  startAnimation(): void;
}

class MSCloudUploadFailedViewControllerAllocator<T extends MSCloudUploadFailedViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudUploadFailedViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudUploadFailedViewController>(): MSCloudUploadFailedViewControllerAllocator<T>;

  error(): NSError;
  setError(error: NSError): void;
  existingShare(): SCKShare;
  setExistingShare(existingShare: SCKShare): void;
}

class MSCloudUploadViewControllerAllocator<T extends MSCloudUploadViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudUploadViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudUploadViewController>(): MSCloudUploadViewControllerAllocator<T>;
}

class MSCloudViewControllerAllocator<T extends MSCloudViewController> extends NSViewControllerAllocator<T> {
  initWithAction(action: MSCloudAction): T;
}
declare class MSCloudViewController extends NSViewController {
  alloc<T extends MSCloudViewController>(): MSCloudViewControllerAllocator<T>;
  setContentViewController_animated(contentViewController: MSCloudBaseViewController, animated: boolean): void;
  resetContentViewController(sender: any): IBAction;
  updateFrame(): void;
  animateFrameWithCompletionHandler(handler: Block): void;

  action(): MSCloudAction;
  contentViewController(): MSCloudBaseViewController;
  setContentViewController(contentViewController: MSCloudBaseViewController): void;
}

class MSCloudWelcomeViewControllerAllocator<T extends MSCloudWelcomeViewController> extends MSCloudBaseViewControllerAllocator<T> {}
declare class MSCloudWelcomeViewController extends MSCloudBaseViewController {
  alloc<T extends MSCloudWelcomeViewController>(): MSCloudWelcomeViewControllerAllocator<T>;
}

class MSCollapseAllGroupsActionAllocator<T extends MSCollapseAllGroupsAction> extends MSDocumentActionAllocator<T> {}
declare class MSCollapseAllGroupsAction extends MSDocumentAction {
  alloc<T extends MSCollapseAllGroupsAction>(): MSCollapseAllGroupsActionAllocator<T>;
  collapseAllGroups(sender: any): IBAction;
}

class MSCollapsibleHeaderInspectorItemAllocator<T extends MSCollapsibleHeaderInspectorItem> extends MSHeaderInspectorItemAllocator<T> {}
declare class MSCollapsibleHeaderInspectorItem extends MSHeaderInspectorItem {
  alloc<T extends MSCollapsibleHeaderInspectorItem>(): MSCollapsibleHeaderInspectorItemAllocator<T>;
  toggleCollapsed(sender: any): IBAction;

  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
}

declare interface IMSCollapsibleHeaderInspectorItemTarget {
  item_wantsSectionToCollapse(item: NSViewController, collapse: boolean): void;
}

class MSCollectionViewAllocator<T extends MSCollectionView> extends NSCollectionViewAllocator<T> {}
declare class MSCollectionView extends NSCollectionView {
  alloc<T extends MSCollectionView>(): MSCollectionViewAllocator<T>;
}

class MSColorComponentValueTextFieldAllocator<T extends MSColorComponentValueTextField> extends MSUpDownTextFieldAllocator<T> {}
declare class MSColorComponentValueTextField extends MSUpDownTextField {
  alloc<T extends MSColorComponentValueTextField>(): MSColorComponentValueTextFieldAllocator<T>;

  counterpart(): MSColorComponentValueTextField;
  setCounterpart(counterpart: MSColorComponentValueTextField): void;
}

class MSColorControlsInspectorViewControllerAllocator<T extends MSColorControlsInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<T> {}
declare class MSColorControlsInspectorViewController extends MSStylePartInspectorViewController {
  alloc<T extends MSColorControlsInspectorViewController>(): MSColorControlsInspectorViewControllerAllocator<T>;
  reset(sender: any): IBAction;
}

class MSColorInspectorAllocator<T extends MSColorInspector> extends NSViewControllerAllocator<T> {
  initWithSender_document_handlerManager_globalAssets(delegate: any, document: MSDocument, manager: MSEventHandlerManager, globalAssets: MSPersistentAssetCollection): T;
}
declare class MSColorInspector extends NSViewController implements IMSColorInspectorSectionDelegate, IMSModeModePickerDelegate, IBCPopoverDelegate, INSTouchBarDelegate, IBCHSBColorPickerDelegate, IMSStylePartPreviewButtonDelegate {
  alloc<T extends MSColorInspector>(): MSColorInspectorAllocator<T>;
  static presentColorInspectorPopoverForViewController_document_globalAssets_relativeToView_colorInspectorSetupHandler(viewController: NSViewController, document: MSDocument, globalAssets: MSPersistentAssetCollection, positioningView: NSView, setupHandler: MSColorInspectorSetupBlock): BCPopover;
  static presentColorInspectorPopoverForViewController_inspectorController_relativeToView_colorInspectorSetupHandler(viewController: NSViewController, inspectorController: MSInspectorController, positioningView: NSView, setupHandler: MSColorInspectorSetupBlock): BCPopover;
  validateEnableButtons(): void;
  stack(): void;
  setColor(color: MSColor): void;
  colorPickerAction(sender: any): IBAction;
  refreshAction(sender: any): IBAction;
  colorMagnifierAction(sender: any): IBAction;
  setInitialColor(color: MSColor): void;
  setMaximumAvailableHeight(maxHeight: NSInteger): void;
  switchToColorTabAtIndex(index: NSUInteger): IBAction;
  colorTabIndex(): NSUInteger;
  colorDidChangeTo(color: MSColor): void;
  inspectorSectionDidUpdate(pattern: MSColorInspectorSectionPattern): void;
  documentAssets(): MSAssetCollection;
  globalAssets(): MSPersistentAssetCollection;
  eventHandlerManager(): MSEventHandlerManager;
  stack(): void;
  didAddAsset(asset: any): void;
  didRemoveAssetOfType(assetType: MSAsset): void;
  touchBar(): NSTouchBar;
  pickerViewWillChange(picker: MSModePickerView): void;
  pickerViewChanged(picker: MSModePickerView): void;
  pickerView_labelForMode(view: MSModePickerView, mode: NSInteger): NSString;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  hsbColorPickerDocumentColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
  hsbColorPickerPreviewColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
  stylePartPreviewButtonPreviewColorSpace(button: MSStylePartPreviewButton): NSColorSpace;
  colorDidChangeTo(color: MSColor): void;
  inspectorSectionDidUpdate(pattern: MSColorInspectorSectionPattern): void;
  documentAssets(): MSAssetCollection;
  globalAssets(): MSPersistentAssetCollection;
  eventHandlerManager(): MSEventHandlerManager;
  stack(): void;
  didAddAsset(asset: any): void;
  didRemoveAssetOfType(assetType: MSAsset): void;
  touchBar(): NSTouchBar;
  pickerViewWillChange(picker: MSModePickerView): void;
  pickerViewChanged(picker: MSModePickerView): void;
  pickerView_labelForMode(view: MSModePickerView, mode: NSInteger): NSString;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  hsbColorPickerDocumentColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
  hsbColorPickerPreviewColorSpace(colorPicker: BCHSBColorPicker): NSColorSpace;
  stylePartPreviewButtonPreviewColorSpace(button: MSStylePartPreviewButton): NSColorSpace;

  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  colorPicker(): BCHSBColorPicker;
  setColorPicker(colorPicker: BCHSBColorPicker): void;
  emptyTopView(): NSView;
  setEmptyTopView(emptyTopView: NSView): void;
  colorPickerView(): NSView;
  setColorPickerView(colorPickerView: NSView): void;
  document(): MSDocument;
}

declare interface IMSColorInspectorDelegate {
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
}

class MSColorInspectorModePickerActionAllocator<T extends MSColorInspectorModePickerAction> extends MSDocumentActionAllocator<T> {}
declare class MSColorInspectorModePickerAction extends MSDocumentAction {
  alloc<T extends MSColorInspectorModePickerAction>(): MSColorInspectorModePickerActionAllocator<T>;
}

class MSColorInspectorColorTabActionAllocator<T extends MSColorInspectorColorTabAction> extends MSColorInspectorModePickerActionAllocator<T> {}
declare class MSColorInspectorColorTabAction extends MSColorInspectorModePickerAction {
  alloc<T extends MSColorInspectorColorTabAction>(): MSColorInspectorColorTabActionAllocator<T>;
}

class MSColorInspectorLinearGradientTabActionAllocator<T extends MSColorInspectorLinearGradientTabAction> extends MSColorInspectorModePickerActionAllocator<T> {}
declare class MSColorInspectorLinearGradientTabAction extends MSColorInspectorModePickerAction {
  alloc<T extends MSColorInspectorLinearGradientTabAction>(): MSColorInspectorLinearGradientTabActionAllocator<T>;
}

class MSColorInspectorRadialGradientTabActionAllocator<T extends MSColorInspectorRadialGradientTabAction> extends MSColorInspectorModePickerActionAllocator<T> {}
declare class MSColorInspectorRadialGradientTabAction extends MSColorInspectorModePickerAction {
  alloc<T extends MSColorInspectorRadialGradientTabAction>(): MSColorInspectorRadialGradientTabActionAllocator<T>;
}

class MSColorInspectorCircularGradientTabActionAllocator<T extends MSColorInspectorCircularGradientTabAction> extends MSColorInspectorModePickerActionAllocator<T> {}
declare class MSColorInspectorCircularGradientTabAction extends MSColorInspectorModePickerAction {
  alloc<T extends MSColorInspectorCircularGradientTabAction>(): MSColorInspectorCircularGradientTabActionAllocator<T>;
}

class MSColorInspectorImageTabActionAllocator<T extends MSColorInspectorImageTabAction> extends MSColorInspectorModePickerActionAllocator<T> {}
declare class MSColorInspectorImageTabAction extends MSColorInspectorModePickerAction {
  alloc<T extends MSColorInspectorImageTabAction>(): MSColorInspectorImageTabActionAllocator<T>;
}

class MSColorInspectorModeBorderTouchBarGroupActionAllocator<T extends MSColorInspectorModeBorderTouchBarGroupAction> extends MSActionGroupAllocator<T> {}
declare class MSColorInspectorModeBorderTouchBarGroupAction extends MSActionGroup {
  alloc<T extends MSColorInspectorModeBorderTouchBarGroupAction>(): MSColorInspectorModeBorderTouchBarGroupActionAllocator<T>;
}

class MSColorInspectorModeFillTouchBarGroupActionAllocator<T extends MSColorInspectorModeFillTouchBarGroupAction> extends MSColorInspectorModeBorderTouchBarGroupActionAllocator<T> {}
declare class MSColorInspectorModeFillTouchBarGroupAction extends MSColorInspectorModeBorderTouchBarGroupAction {
  alloc<T extends MSColorInspectorModeFillTouchBarGroupAction>(): MSColorInspectorModeFillTouchBarGroupActionAllocator<T>;
}

class MSColorInspectorSectionAllocator<T extends MSColorInspectorSection> extends NSViewControllerAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class MSColorInspectorSection extends NSViewController {
  alloc<T extends MSColorInspectorSection>(): MSColorInspectorSectionAllocator<T>;
  validate(): void;
  popoverWillClose(): void;
  isEnabled(): boolean;
  hasPresetPickers(): boolean;
  fillType(): NSInteger;
  assetCollectionForPresetPicker(picker: MSAssetPickerView): MSAssetCollection;
  refreshAction(sender: any): IBAction;
  colorPickerChangedTo(color: MSColor): void;
  reloadPresetPicker(): void;
  viewsWithColorPickerView_blendingView_topViewIsEmpty(colorPickerView: NSView, blendingView: NSView, topViewIsEmpty: boolean): NSArray<any>;
  assetPickerViews(): NSArray<any>;
  assetPickerViewKeys(): NSDictionary<any, any>;
  customTouchBarItemIdentifiers(): NSArray<any>;
  makeTouchBarItemForIdentifier(identifier: NSString | string): NSTouchBarItem;
  assetType(): MSAsset;
  numberOfAssetsForPickerView(picker: MSAssetPickerView): NSUInteger;
  addAsset_forPickerView(asset: any, picker: MSAssetPickerView): void;
  insertAsset_atIndex_forPickerView(asset: any, index: NSUInteger, picker: MSAssetPickerView): void;
  assetAtIndex_forPickerView(index: NSUInteger, picker: MSAssetPickerView): any;
  removeAssetAtIndex_forPickerView(index: NSUInteger, picker: MSAssetPickerView): void;
  indexesOfAsset_forPickerView(asset: any, picker: MSAssetPickerView): NSIndexSet;
  moveAssetAtIndex_beforeObjectAtIndex_ForPickerView(fromIndex: NSUInteger, toIndex: NSUInteger, picker: MSAssetPickerView): boolean;
  scrollViewWithStackedViews(scrollableViews: NSArray<any> | any[]): NSScrollView;
  minimumHeight(): CGFloat;
  static refreshColorPickerViewHeight(colorPickerView: NSView): void;
  colorAssetCollectionLabelWithTitle(title: NSString | string): NSTextField;
  fittingAssetScrubberLabelItemSizeForTitle(title: NSString | string): NSSize;

  delegate(): any;
  setDelegate(delegate: any): void;
  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
}

class MSColorInspectorSectionColorAllocator<T extends MSColorInspectorSectionColor> extends MSColorInspectorSectionAllocator<T> {}
declare class MSColorInspectorSectionColor extends MSColorInspectorSection {
  alloc<T extends MSColorInspectorSectionColor>(): MSColorInspectorSectionColorAllocator<T>;

  pickedColor(): MSColor;
  setPickedColor(pickedColor: MSColor): void;
}

declare interface IMSColorInspectorSectionDelegate {
  colorDidChangeTo(color: MSColor): void;
  inspectorSectionDidUpdate(pattern: MSColorInspectorSectionPattern): void;
  documentAssets(): MSAssetCollection;
  globalAssets(): MSPersistentAssetCollection;
  eventHandlerManager(): MSEventHandlerManager;
  stack(): void;
  didAddAsset(asset: any): void;
  didRemoveAssetOfType(assetType: MSAsset): void;
  touchBar(): NSTouchBar;

  document(): MSDocument;
}

class MSColorInspectorSectionGradientAllocator<T extends MSColorInspectorSectionGradient> extends MSColorInspectorSectionAllocator<T> {}
declare class MSColorInspectorSectionGradient extends MSColorInspectorSection implements IMSGradientEventHandlerDelegate, IMSGradientBarViewDelegate {
  alloc<T extends MSColorInspectorSectionGradient>(): MSColorInspectorSectionGradientAllocator<T>;
  switchToGradientHandler(): void;
  gradientBarAction(sender: any): IBAction;
  rotateGradientAction(sender: any): IBAction;
  closeGradientHandler(): void;
  switchToGradientHandlerIfNecessary(): void;
  gradientHandlerDidChangeCurrentPoint(handler: MSGradientEventHandler): void;
  gradientHandlerDidChangeGradient(handler: MSGradientEventHandler): void;
  gradientHandlerWillLoseFocus(handler: MSGradientEventHandler): void;
  gradientBarViewPreviewColorSpace(gradientBarView: MSGradientBarView): NSColorSpace;
  gradientBarChanged(gradientView: MSGradientBarView): void;
  gradientHandlerDidChangeCurrentPoint(handler: MSGradientEventHandler): void;
  gradientHandlerDidChangeGradient(handler: MSGradientEventHandler): void;
  gradientHandlerWillLoseFocus(handler: MSGradientEventHandler): void;
  gradientBarViewPreviewColorSpace(gradientBarView: MSGradientBarView): NSColorSpace;
  gradientBarChanged(gradientView: MSGradientBarView): void;

  gradientBarParentView(): NSView;
  setGradientBarParentView(gradientBarParentView: NSView): void;
  gradientBarView(): MSGradientBarView;
  setGradientBarView(gradientBarView: MSGradientBarView): void;
}

class MSColorInspectorSectionNoiseAllocator<T extends MSColorInspectorSectionNoise> extends MSColorInspectorSectionAllocator<T> {}
declare class MSColorInspectorSectionNoise extends MSColorInspectorSection {
  alloc<T extends MSColorInspectorSectionNoise>(): MSColorInspectorSectionNoiseAllocator<T>;
}

class MSColorInspectorSectionPatternAllocator<T extends MSColorInspectorSectionPattern> extends MSColorInspectorSectionAllocator<T> {}
declare class MSColorInspectorSectionPattern extends MSColorInspectorSection {
  alloc<T extends MSColorInspectorSectionPattern>(): MSColorInspectorSectionPatternAllocator<T>;
  choosePatternImage(sender: any): IBAction;
  patternWellAction(sender: any): IBAction;
  updatePatternWellImage(): void;

  patternWell(): NSImageView;
  setPatternWell(patternWell: NSImageView): void;
  choosePatternButton(): NSButton;
  setChoosePatternButton(choosePatternButton: NSButton): void;
  patternTilButton(): NSPopUpButton;
  setPatternTilButton(patternTilButton: NSPopUpButton): void;
}

class MSColorPickerBackgroundViewAllocator<T extends MSColorPickerBackgroundView> extends NSViewAllocator<T> {}
declare class MSColorPickerBackgroundView extends NSView {
  alloc<T extends MSColorPickerBackgroundView>(): MSColorPickerBackgroundViewAllocator<T>;
}

class MSColorStylePartInspectorViewControllerAllocator<T extends MSColorStylePartInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<T> {}
declare class MSColorStylePartInspectorViewController extends MSStylePartInspectorViewController {
  alloc<T extends MSColorStylePartInspectorViewController>(): MSColorStylePartInspectorViewControllerAllocator<T>;
  updateColorInActiveInspector(): void;
  previewCellAction(sender: any): IBAction;
  checkBoxAction(sender: any): IBAction;

  colorButton(): MSStylePartPreviewButton;
  setColorButton(colorButton: MSStylePartPreviewButton): void;
}

class MSCommandAllocator<T extends MSCommand> extends NSObjectAllocator<T> {}
declare class MSCommand extends NSObject {
  alloc<T extends MSCommand>(): MSCommandAllocator<T>;
  static runWithArguments(block: MSCommandPreparation): any;
  run(): any;
}

class MSConstraintActionAllocator<T extends MSConstraintAction> extends MSDocumentActionAllocator<T> {}
declare class MSConstraintAction extends MSDocumentAction {
  alloc<T extends MSConstraintAction>(): MSConstraintActionAllocator<T>;

  actionKeyPath(): NSString;
  validationKeyPath(): NSString;
}

class MSConstraintPinLeftActionAllocator<T extends MSConstraintPinLeftAction> extends MSConstraintActionAllocator<T> {}
declare class MSConstraintPinLeftAction extends MSConstraintAction {
  alloc<T extends MSConstraintPinLeftAction>(): MSConstraintPinLeftActionAllocator<T>;
  pinLeftAction(sender: any): IBAction;
}

class MSConstraintPinRightActionAllocator<T extends MSConstraintPinRightAction> extends MSConstraintActionAllocator<T> {}
declare class MSConstraintPinRightAction extends MSConstraintAction {
  alloc<T extends MSConstraintPinRightAction>(): MSConstraintPinRightActionAllocator<T>;
  pinRightAction(sender: any): IBAction;
}

class MSConstraintPinTopActionAllocator<T extends MSConstraintPinTopAction> extends MSConstraintActionAllocator<T> {}
declare class MSConstraintPinTopAction extends MSConstraintAction {
  alloc<T extends MSConstraintPinTopAction>(): MSConstraintPinTopActionAllocator<T>;
  pinTopAction(sender: any): IBAction;
}

class MSConstraintPinBottomActionAllocator<T extends MSConstraintPinBottomAction> extends MSConstraintActionAllocator<T> {}
declare class MSConstraintPinBottomAction extends MSConstraintAction {
  alloc<T extends MSConstraintPinBottomAction>(): MSConstraintPinBottomActionAllocator<T>;
  pinBottomAction(sender: any): IBAction;
}

class MSConstraintFixWidthActionAllocator<T extends MSConstraintFixWidthAction> extends MSConstraintActionAllocator<T> {}
declare class MSConstraintFixWidthAction extends MSConstraintAction {
  alloc<T extends MSConstraintFixWidthAction>(): MSConstraintFixWidthActionAllocator<T>;
  fixWidthAction(sender: any): IBAction;
}

class MSConstraintFixHeightActionAllocator<T extends MSConstraintFixHeightAction> extends MSConstraintActionAllocator<T> {}
declare class MSConstraintFixHeightAction extends MSConstraintAction {
  alloc<T extends MSConstraintFixHeightAction>(): MSConstraintFixHeightActionAllocator<T>;
  fixHeightAction(sender: any): IBAction;
}

class MSConstraintResetActionAllocator<T extends MSConstraintResetAction> extends MSDocumentActionAllocator<T> {}
declare class MSConstraintResetAction extends MSDocumentAction {
  alloc<T extends MSConstraintResetAction>(): MSConstraintResetActionAllocator<T>;
  resetConstraintAction(sender: any): IBAction;
}

class MSContentDrawViewAllocator<T extends MSContentDrawView> extends NSViewAllocator<T> {}
declare class MSContentDrawView extends NSView implements IMSEventHandlerManagerDelegate, IMSTiledRendererHostView {
  alloc<T extends MSContentDrawView>(): MSContentDrawViewAllocator<T>;
  setNeedsUpdateCursor(): void;
  scheduleRedraw(): void;
  redrawContentImmediately(): void;
  centerDocumentAndPlaceScrollOriginInTopLeft(): void;
  placeOriginInTopLeft(): void;
  currentPage(): MSPage;
  animateToZoom_scalingCenteredOnAbsoluteCoordinates(zoom: CGFloat, midPoint: NSPoint): void;
  animateToViewPort(viewPort: MSViewPort): void;
  zoomIn(): void;
  zoomOut(): void;
  zoomToActualSizeAnimated(animated: boolean): void;
  animateToZoom(zoom: CGFloat): void;
  endZoomToolMode(): void;
  prepare(): void;
  refreshAfterSettingsChange(): void;
  renderOverlayInRect_context_pageOverlayRenderOptions(rect: NSRect, context: CGContextRef, pageOverlayRenderOptions: MSPageOverlayRenderOptions): void;
  centerLayersInCanvas(): void;
  centerSelectionInVisibleArea(): void;
  centerRect(rect: NSRect): void;
  centerRect_animated(rect: NSRect, animated: boolean): void;
  zoomToFitRect(rect: NSRect): void;
  viewPortForZoomToFitRect(rect: NSRect): MSViewPort;
  viewPortWithCenter_zoomValue(center: NSPoint, zoom: CGFloat): MSViewPort;
  selectToolbarItemWithIdentifier(identifier: NSString | string): void;
  visibleContentRect(): NSRect;
  scrollToScrollOrigin(scrollOrigin: NSPoint): void;
  displayPropertiesDidChange(): void;
  pageDidChange(page: MSPage): void;
  windowDidResize(note: NSNotification): void;
  pixelGridDidChange(): void;
  ignoreNextKeyDownEventUntilModifiersChange(): void;
  layerPositionPossiblyChanged(): void;
  convertPoint_toLayer(point: NSPoint, layer: MSLayer): NSPoint;
  convertPointFromPage(aPoint: NSPoint): NSPoint;
  convertSizeToPage(aSize: NSSize): NSSize;
  eventHandlerManager_didChangeCurrentHandler(manager: MSEventHandlerManager, newHandler: MSEventHandler): void;
  scheduleRedraw(): void;
  driver(): MSRenderingDriver;
  eventHandlerManager_didChangeCurrentHandler(manager: MSEventHandlerManager, newHandler: MSEventHandler): void;
  scheduleRedraw(): void;
  driver(): MSRenderingDriver;

  tiledRenderer(): MSTiledRenderer;
  contentDrawViewParent(): MSContentDrawViewParent;
  setContentDrawViewParent(contentDrawViewParent: MSContentDrawViewParent): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  eventHandlerManager(): MSEventHandlerManager;
  setEventHandlerManager(eventHandlerManager: MSEventHandlerManager): void;
  viewPort(): MSViewPort;
  setViewPort(viewPort: MSViewPort): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  shouldHideOverlayControls(): boolean;
  setShouldHideOverlayControls(shouldHideOverlayControls: boolean): void;
  measurementLabelNumberFormatter(): NSNumberFormatter;
  pendingMonitor(): MSRenderMonitor;
  setPendingMonitor(pendingMonitor: MSRenderMonitor): void;
  driver(): MSRenderingDriver;
  cacheManager(): MSCacheManager;
  setCacheManager(cacheManager: MSCacheManager): void;
  mouseTracker(): MSMouseTracker;
  didMouseDown(): boolean;
  handToolState(): MSHandToolState;
  setHandToolState(handToolState: MSHandToolState): void;
  needsUpdateCursor(): boolean;
  zoomTool(): MSZoomTool;
}

declare interface IMSContentDrawViewDelegate {

  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}

declare enum MSHandToolState {
  MSHandToolStateInactive,
  MSHandToolStateActive,
  MSHandToolStateDragging,
}

class MSContentDrawViewControllerAllocator<T extends MSContentDrawViewController> extends NSViewControllerAllocator<T> {}
declare class MSContentDrawViewController extends NSViewController implements IMSContentDrawViewDelegate {
  alloc<T extends MSContentDrawViewController>(): MSContentDrawViewControllerAllocator<T>;
  currentArtboardDidChange(): void;
  changeToPage(page: MSPage): void;
  prepareForDealloc(): void;

  contentDrawView(): MSContentDrawView;
  setContentDrawView(contentDrawView: MSContentDrawView): void;
  contentDrawViewParent(): MSContentDrawViewParent;
  setContentDrawViewParent(contentDrawViewParent: MSContentDrawViewParent): void;
  horizontalRuler(): MSRulerView;
  setHorizontalRuler(horizontalRuler: MSRulerView): void;
  verticalRuler(): MSRulerView;
  setVerticalRuler(verticalRuler: MSRulerView): void;
  rulerCornerView(): NSView;
  setRulerCornerView(rulerCornerView: NSView): void;
  rulerWidthConstraint(): NSLayoutConstraint;
  setRulerWidthConstraint(rulerWidthConstraint: NSLayoutConstraint): void;
  rulerHeightConstraint(): NSLayoutConstraint;
  setRulerHeightConstraint(rulerHeightConstraint: NSLayoutConstraint): void;
  flashController(): MSFlashController;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}

class MSContentDrawViewParentAllocator<T extends MSContentDrawViewParent> extends NSViewAllocator<T> {}
declare class MSContentDrawViewParent extends NSView {
  alloc<T extends MSContentDrawViewParent>(): MSContentDrawViewParentAllocator<T>;

  contentDrawView(): MSContentDrawView;
  setContentDrawView(contentDrawView: MSContentDrawView): void;
}

class MSConvertFlowToHotspotActionAllocator<T extends MSConvertFlowToHotspotAction> extends MSFlowBaseActionAllocator<T> {}
declare class MSConvertFlowToHotspotAction extends MSFlowBaseAction {
  alloc<T extends MSConvertFlowToHotspotAction>(): MSConvertFlowToHotspotActionAllocator<T>;
  convertFlowToHotspot(sender: any): IBAction;
}

class MSConvertSymbolOrDetachInstancesActionAllocator<T extends MSConvertSymbolOrDetachInstancesAction> extends MSDocumentActionAllocator<T> {}
declare class MSConvertSymbolOrDetachInstancesAction extends MSDocumentAction {
  alloc<T extends MSConvertSymbolOrDetachInstancesAction>(): MSConvertSymbolOrDetachInstancesActionAllocator<T>;
  detachSymbolInstances(sender: any): IBAction;
}

class MSConvertToOutlinesActionAllocator<T extends MSConvertToOutlinesAction> extends MSDocumentActionAllocator<T> {}
declare class MSConvertToOutlinesAction extends MSDocumentAction {
  alloc<T extends MSConvertToOutlinesAction>(): MSConvertToOutlinesActionAllocator<T>;
  convertToOutlines(sender: any): IBAction;
}

class MSCopySVGCodeActionAllocator<T extends MSCopySVGCodeAction> extends MSDocumentActionAllocator<T> {}
declare class MSCopySVGCodeAction extends MSDocumentAction {
  alloc<T extends MSCopySVGCodeAction>(): MSCopySVGCodeActionAllocator<T>;
  copySVG(sender: any): IBAction;
}

class MSCopyStyleActionAllocator<T extends MSCopyStyleAction> extends MSDocumentActionAllocator<T> {}
declare class MSCopyStyleAction extends MSDocumentAction {
  alloc<T extends MSCopyStyleAction>(): MSCopyStyleActionAllocator<T>;
  copyStyle(sender: any): IBAction;
}

class MSPasteStyleActionAllocator<T extends MSPasteStyleAction> extends MSDocumentActionAllocator<T> {}
declare class MSPasteStyleAction extends MSDocumentAction {
  alloc<T extends MSPasteStyleAction>(): MSPasteStyleActionAllocator<T>;
  pasteStyle(sender: any): IBAction;
}

class MSCopyCSSAttributesActionAllocator<T extends MSCopyCSSAttributesAction> extends MSDocumentActionAllocator<T> {}
declare class MSCopyCSSAttributesAction extends MSDocumentAction {
  alloc<T extends MSCopyCSSAttributesAction>(): MSCopyCSSAttributesActionAllocator<T>;
  copyCSSAttributes(sender: any): IBAction;
}

class MSCrashLogManagerAllocator<T extends MSCrashLogManager> extends NSObjectAllocator<T> {}
declare class MSCrashLogManager extends NSObject implements IMSActionObserver, IBITHockeyManagerDelegate, IBITCrashManagerDelegate {
  alloc<T extends MSCrashLogManager>(): MSCrashLogManagerAllocator<T>;
  setEnvironmentValue_forKey(value: NSString | string, key: NSString | string): void;
  log(text: NSString | string): void;
  setup(): boolean;
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  userIDForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userNameForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userEmailForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  crashManagerWillSendCrashReport(crashManager: BITCrashManager): void;
  crashManager_didFailWithError(crashManager: BITCrashManager, error: NSError): void;
  crashManagerDidFinishSendingCrashReport(crashManager: BITCrashManager): void;
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  userIDForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userNameForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  userEmailForHockeyManager_componentManager(hockeyManager: BITHockeyManager, componentManager: BITHockeyBaseManager): NSString;
  crashManagerWillSendCrashReport(crashManager: BITCrashManager): void;
  crashManager_didFailWithError(crashManager: BITCrashManager, error: NSError): void;
  crashManagerDidFinishSendingCrashReport(crashManager: BITCrashManager): void;

  text(): NSString;
}

class MSCreateDetachSymbolButtonCellAllocator<T extends MSCreateDetachSymbolButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSCreateDetachSymbolButtonCell extends MSHoverButtonCell {
  alloc<T extends MSCreateDetachSymbolButtonCell>(): MSCreateDetachSymbolButtonCellAllocator<T>;

  artboardPreviewImage(): NSImage;
  setArtboardPreviewImage(artboardPreviewImage: NSImage): void;
}

class MSCreateSharedStyleActionAllocator<T extends MSCreateSharedStyleAction> extends MSBaseSharedObjectActionAllocator<T> {}
declare class MSCreateSharedStyleAction extends MSBaseSharedObjectAction {
  alloc<T extends MSCreateSharedStyleAction>(): MSCreateSharedStyleActionAllocator<T>;
  createSharedStyle(sender: any): IBAction;
}

class MSCreateSymbolActionAllocator<T extends MSCreateSymbolAction> extends MSDocumentActionAllocator<T> {}
declare class MSCreateSymbolAction extends MSDocumentAction {
  alloc<T extends MSCreateSymbolAction>(): MSCreateSymbolActionAllocator<T>;
  createSymbolAction(sender: any): IBAction;
}

class MSCreateSymbolNamingSheetAllocator<T extends MSCreateSymbolNamingSheet> extends CHSheetControllerAllocator<T> {}
declare class MSCreateSymbolNamingSheet extends CHSheetController {
  alloc<T extends MSCreateSymbolNamingSheet>(): MSCreateSymbolNamingSheetAllocator<T>;
  setSymbolPageName(symbolPageName: NSString | string): void;
  setSuggestedName(suggestedName: NSString | string): void;
  setShouldShowMoveCheckbox(showCheckbox: boolean): void;

  symbolNameField(): NSTextField;
  setSymbolNameField(symbolNameField: NSTextField): void;
  symbolPageField(): NSTextField;
  setSymbolPageField(symbolPageField: NSTextField): void;
  completionBlock(): MSCreateSymbolCompletionBlock;
  setCompletionBlock(completionBlock: MSCreateSymbolCompletionBlock): void;
}

class MSCursorButtonAllocator<T extends MSCursorButton> extends NSButtonAllocator<T> {}
declare class MSCursorButton extends NSButton {
  alloc<T extends MSCursorButton>(): MSCursorButtonAllocator<T>;

  cursor(): NSCursor;
  setCursor(cursor: NSCursor): void;
}

class MSCurveModeAdjustActionAllocator<T extends MSCurveModeAdjustAction> extends MSDocumentActionAllocator<T> {}
declare class MSCurveModeAdjustAction extends MSDocumentAction {
  alloc<T extends MSCurveModeAdjustAction>(): MSCurveModeAdjustActionAllocator<T>;
}

class MSCurveModeStraightActionAllocator<T extends MSCurveModeStraightAction> extends MSCurveModeAdjustActionAllocator<T> {}
declare class MSCurveModeStraightAction extends MSCurveModeAdjustAction {
  alloc<T extends MSCurveModeStraightAction>(): MSCurveModeStraightActionAllocator<T>;
}

class MSCurveModeMirroredActionAllocator<T extends MSCurveModeMirroredAction> extends MSCurveModeAdjustActionAllocator<T> {}
declare class MSCurveModeMirroredAction extends MSCurveModeAdjustAction {
  alloc<T extends MSCurveModeMirroredAction>(): MSCurveModeMirroredActionAllocator<T>;
}

class MSCurveModeDisconnectedActionAllocator<T extends MSCurveModeDisconnectedAction> extends MSCurveModeAdjustActionAllocator<T> {}
declare class MSCurveModeDisconnectedAction extends MSCurveModeAdjustAction {
  alloc<T extends MSCurveModeDisconnectedAction>(): MSCurveModeDisconnectedActionAllocator<T>;
}

class MSCurveModeAsymmetricActionAllocator<T extends MSCurveModeAsymmetricAction> extends MSCurveModeAdjustActionAllocator<T> {}
declare class MSCurveModeAsymmetricAction extends MSCurveModeAdjustAction {
  alloc<T extends MSCurveModeAsymmetricAction>(): MSCurveModeAsymmetricActionAllocator<T>;
}

class MSCurveModeTouchGroupActionAllocator<T extends MSCurveModeTouchGroupAction> extends MSActionGroupAllocator<T> {}
declare class MSCurveModeTouchGroupAction extends MSActionGroup {
  alloc<T extends MSCurveModeTouchGroupAction>(): MSCurveModeTouchGroupActionAllocator<T>;
}

class MSDataActionAllocator<T extends MSDataAction> extends MSDocumentActionAllocator<T> {}
declare class MSDataAction extends MSDocumentAction implements IMSDataMenuProviderDelegate, INSMenuDelegate {
  alloc<T extends MSDataAction>(): MSDataActionAllocator<T>;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

class MSDataMenuActionAllocator<T extends MSDataMenuAction> extends MSDocumentActionAllocator<T> {}
declare class MSDataMenuAction extends MSDocumentAction {
  alloc<T extends MSDataMenuAction>(): MSDataMenuActionAllocator<T>;
}

class MSDataPreferenceItemAllocator<T extends MSDataPreferenceItem> extends NSObjectAllocator<T> {}
declare class MSDataPreferenceItem extends NSObject {
  alloc<T extends MSDataPreferenceItem>(): MSDataPreferenceItemAllocator<T>;
  static preferenceItemForLocalData(localData: MSDataSupplier): MSDataPreferenceItem;

  data(): MSDataSupplier;
  name(): NSString;
  preview(): NSImage;
  setPreview(preview: NSImage): void;
  secondaryTitle(): NSString;
  valid(): boolean;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
  canRevealInFinder(): boolean;
  localData(): MSLocalDataSupplier;
  pluginData(): MSPluginDataSupplier;
  pluginBundleIcon(): NSImage;
  primaryTextFieldColor(): NSColor;
  secondaryTextFieldColor(): NSColor;
  cellView(): MSDataTableCellView;
  setCellView(cellView: MSDataTableCellView): void;
}

class MSDataPreferencePaneAllocator<T extends MSDataPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSDataPreferencePane extends MSPreferencePane implements INSTableViewDelegate, INSTableViewDataSource {
  alloc<T extends MSDataPreferencePane>(): MSDataPreferencePaneAllocator<T>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;

  tableView(): MSDataTableView;
  setTableView(tableView: MSDataTableView): void;
  dataArrayController(): NSArrayController;
  setDataArrayController(dataArrayController: NSArrayController): void;
  data(): NSArray<any>;
  dataSupplierManager(): MSDataSupplierManager;
}

class MSDataPreviewAllocator<T extends MSDataPreview> extends NSViewAllocator<T> {}
declare class MSDataPreview extends NSView {
  alloc<T extends MSDataPreview>(): MSDataPreviewAllocator<T>;

  dataItem(): MSDataPreferenceItem;
  setDataItem(dataItem: MSDataPreferenceItem): void;
}

class MSDataTableCellViewAllocator<T extends MSDataTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSDataTableCellView extends NSTableCellView {
  alloc<T extends MSDataTableCellView>(): MSDataTableCellViewAllocator<T>;

  dataPreferenceItem(): MSDataPreferenceItem;
}

class MSDataTableViewAllocator<T extends MSDataTableView> extends BCKeyEventActionTableViewAllocator<T> {}
declare class MSDataTableView extends BCKeyEventActionTableView {
  alloc<T extends MSDataTableView>(): MSDataTableViewAllocator<T>;
}

class MSDefaultStyleActionAllocator<T extends MSDefaultStyleAction> extends MSDocumentActionAllocator<T> {}
declare class MSDefaultStyleAction extends MSDocumentAction {
  alloc<T extends MSDefaultStyleAction>(): MSDefaultStyleActionAllocator<T>;
  setStyleAsDefault(sender: any): IBAction;
}

class MSDetachSharedStyleActionAllocator<T extends MSDetachSharedStyleAction> extends MSBaseSharedObjectActionAllocator<T> {}
declare class MSDetachSharedStyleAction extends MSBaseSharedObjectAction {
  alloc<T extends MSDetachSharedStyleAction>(): MSDetachSharedStyleActionAllocator<T>;
  detachSharedStyle(sender: any): IBAction;
}

class MSDisabledButtonCellAllocator<T extends MSDisabledButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSDisabledButtonCell extends NSButtonCell {
  alloc<T extends MSDisabledButtonCell>(): MSDisabledButtonCellAllocator<T>;
}

class MSDistributeActionAllocator<T extends MSDistributeAction> extends MSDocumentActionAllocator<T> {}
declare class MSDistributeAction extends MSDocumentAction {
  alloc<T extends MSDistributeAction>(): MSDistributeActionAllocator<T>;
  distributeAlongAxis(axis: BCAxis): void;
}

class MSDistributeHorizontallyActionAllocator<T extends MSDistributeHorizontallyAction> extends MSDistributeActionAllocator<T> {}
declare class MSDistributeHorizontallyAction extends MSDistributeAction {
  alloc<T extends MSDistributeHorizontallyAction>(): MSDistributeHorizontallyActionAllocator<T>;
  distributeHorizontally(sender: any): IBAction;
}

class MSDistributeVerticallyActionAllocator<T extends MSDistributeVerticallyAction> extends MSDistributeActionAllocator<T> {}
declare class MSDistributeVerticallyAction extends MSDistributeAction {
  alloc<T extends MSDistributeVerticallyAction>(): MSDistributeVerticallyActionAllocator<T>;
  distributeVertically(sender: any): IBAction;
}

class MSDistributeActionsAllocator<T extends MSDistributeActions> extends MSActionGroupAllocator<T> {}
declare class MSDistributeActions extends MSActionGroup {
  alloc<T extends MSDistributeActions>(): MSDistributeActionsAllocator<T>;
}

class MSDocumentAllocator<T extends MSDocument> extends NSDocumentAllocator<T> {}
declare class MSDocument extends NSDocument implements INSMenuDelegate, INSToolbarDelegate, INSWindowDelegate, IMSEventHandlerManagerDelegate, IMSDocumentDataDelegate, IMSMenuBuilderDelegate {
  alloc<T extends MSDocument>(): MSDocumentAllocator<T>;
  actionClasses(): NSArray<any>;
  addLayerFromImageAtURL_toGroup_fitPixels_error(fileURL: NSURL, group: MSLayerGroup, fitPixels: boolean, outError: NSError): MSLayer;
  askForUserInput_initialValue(label: NSString | string, defaultString: NSString | string): NSString;
  askForUserInput_ofType_initialValue(label: NSString | string, type: MSModalInputTypes, defaultString: NSString | string): NSString;
  saveArtboardOrSlice_toFile(artboardOrSlice: any, filename: NSString | string): void;
  dataForRequest_ofType(request: MSExportRequest, extension: NSString | string): NSData;
  showMessage(message: NSString | string): void;
  pluginContext(): NSDictionary<any, any>;
  saveDocumentToURL_saveMode_context_callback(url: NSURL, saveMode: NSSaveOperationType, coscript: COScript, callback: MOJavaScriptObject | Function): void;
  contentDrawView(): MSContentDrawView;
  static currentDocument(): MSDocument;
  static windowForSheet(): NSWindow;
  window(): NSWindow;
  setCurrentArtboard(newArtboard: MSArtboardGroup): void;
  selectedLayers(): MSLayerArray;
  changeToImmutableDocumentData_selecting_onPage(documentData: MSImmutableDocumentData, selection: NSSet<any>, pageID: NSString | string): void;
  commitHistoryIfNecessary(sender: any): void;
  addLayer(layer: MSLayer): void;
  addLayer_changeName(layer: MSLayer, changeName: boolean): void;
  currentPage(): MSPage;
  validateMenuItem(item: NSMenuItem): boolean;
  toolbar(): NSToolbar;
  selectToolbarItemWithIdentifier(anIdentifier: NSString | string): void;
  createActions(): void;
  shouldCreateToolbar(): boolean;
  resetDocumentData(newData: MSDocumentData): void;
  deleteSymbolMasters(array: NSArray<any> | any[]): void;
  setCurrentPage(page: any): void;
  refreshSidebarWithMask(mask: BCSideBarRefreshType): void;
  updateFilterSettings(): void;
  reloadInspector(): void;
  reloadView(): void;
  refreshWindowBadge(): void;
  layerStyles(): MSSharedStyleContainer;
  pages(): NSArray<any>;
  isLayerListVisible(): boolean;
  isInspectorVisible(): boolean;
  toggleClickThrough(sender: any): IBAction;
  exportSliceLayers(sliceLayers: NSArray<any> | any[]): void;
  allExportableLayers(): NSArray<any>;
  currentArtboardDidChange(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  addBlankPage(): MSPage;
  removePage(page: MSPage): void;
  hasArtboards(): boolean;
  currentHorizontalRulerData(): MSRulerData;
  currentVerticalRulerData(): MSRulerData;
  isRulersVisible(): boolean;
  layerPositionPossiblyChanged(): void;
  zoomValueDidChange(): void;
  debugCountObjects(sender: any): IBAction;
  shouldDrawSelectionForLayer(layer: MSLayer): boolean;
  temporarilyDisableSelectionHidingDuringBlock(block: BCVoidBlock): void;
  isShowingMeasurements(): boolean;
  visitArtboardForInstance(instance: MSSymbolInstance): void;
  openLibrariesForForeignObjects(objects: NSArray<any> | any[]): void;
  restoreViewportAfterArtboardEdit(artboard: MSArtboardGroup): void;
  removeViewportForArtboard(artboard: MSArtboardGroup): void;
  canRestoreViewportAfterArtboardEdit(artboard: MSArtboardGroup): boolean;
  visitSymbolMasterWithID(symbolID: NSString | string): void;
  reloadTouchBars(): void;
  localObjectForObjectReference(ref: MSShareableObjectReference): MSShareableObject;
  symbolReferenceForRecipe(recipe: MSSymbolMasterReferenceDescriptor): MSSymbolMasterReference;
  showNonDefaultColorSpaceWarningIfApplicable(): void;
  returnToDefaultFirstResponder(): void;
  installedFontsDidChange(): void;
  historyMaker_didApplyHistoryUpdate(maker: MSHistoryMaker, update: MSHistoryUpdate): void;
  historyMakerDidRevertHistory(maker: MSHistoryMaker): void;
  historyMakerDidProgressHistory(maker: MSHistoryMaker): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  eventHandlerManager_didChangeCurrentHandler(manager: MSEventHandlerManager, newHandler: MSEventHandler): void;
  documentData_didChangeToPage(data: MSDocumentData, newPage: MSPage): void;
  documentData_temporarilyHideSelectionForLayers(data: MSDocumentData, layers: NSArray<any> | any[]): void;
  documentDataImmediatelyShowSelectionForAllLayers(data: MSDocumentData): void;
  documentDidChange(document: MSDocumentData): void;
  documentData_storeMetadata_forKey_object(data: MSDocumentData, metadata: any, key: NSString | string, object: MSModelObject): void;
  documentData_metadataForKey_object(data: MSDocumentData, key: NSString | string, object: MSModelObject): any;
  layerTreeLayoutDidChange(): void;
  refreshOverlayInRect(rect: NSRect): void;
  refreshOverlay(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  visibleCanvasRectForDocumentData(data: MSDocumentData): CGRect;
  previewColorSpaceForItem(item: NSMenuItem): NSColorSpace;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  eventHandlerManager_didChangeCurrentHandler(manager: MSEventHandlerManager, newHandler: MSEventHandler): void;
  documentData_didChangeToPage(data: MSDocumentData, newPage: MSPage): void;
  documentData_temporarilyHideSelectionForLayers(data: MSDocumentData, layers: NSArray<any> | any[]): void;
  documentDataImmediatelyShowSelectionForAllLayers(data: MSDocumentData): void;
  documentDidChange(document: MSDocumentData): void;
  documentData_storeMetadata_forKey_object(data: MSDocumentData, metadata: any, key: NSString | string, object: MSModelObject): void;
  documentData_metadataForKey_object(data: MSDocumentData, key: NSString | string, object: MSModelObject): any;
  layerTreeLayoutDidChange(): void;
  refreshOverlayInRect(rect: NSRect): void;
  refreshOverlay(): void;
  layerSelectionMightHaveChanged(): void;
  determineCurrentArtboard(): void;
  visibleCanvasRectForDocumentData(data: MSDocumentData): CGRect;
  previewColorSpaceForItem(item: NSMenuItem): NSColorSpace;

  cloudShare(): SCKShare;
  setCloudShare(cloudShare: SCKShare): void;
  cloudName(): NSString;
  documentWindow(): NSWindow;
  setDocumentWindow(documentWindow: NSWindow): void;
  messageView(): NSView;
  setMessageView(messageView: NSView): void;
  splitViewController(): MSMainSplitViewController;
  setSplitViewController(splitViewController: MSMainSplitViewController): void;
  toolbarConstructor(): MSToolbarConstructor;
  setToolbarConstructor(toolbarConstructor: MSToolbarConstructor): void;
  actionsController(): MSActionController;
  setActionsController(actionsController: MSActionController): void;
  badgeController(): MSBadgeController;
  documentData(): MSDocumentData;
  immutableDocumentData(): MSImmutableDocumentData;
  colorSpace(): NSColorSpace;
  canvasColorSpace(): NSColorSpace;
  eventHandlerManager(): MSEventHandlerManager;
  setEventHandlerManager(eventHandlerManager: MSEventHandlerManager): void;
  cacheManager(): MSCacheManager;
  historyMaker(): MSHistoryMaker;
  inspectorController(): MSInspectorController;
  setInspectorController(inspectorController: MSInspectorController): void;
  exportableLayerSelection(): NSArray<any>;
  setExportableLayerSelection(exportableLayerSelection: NSArray<any> | any[]): void;
  sidebarController(): BCSideBarViewController;
  setSidebarController(sidebarController: BCSideBarViewController): void;
  currentContentViewController(): MSContentDrawViewController;
  nextReadFromURLIsReload(): boolean;
  setNextReadFromURLIsReload(nextReadFromURLIsReload: boolean): void;
  hasOpenedImageFile(): boolean;
  setHasOpenedImageFile(hasOpenedImageFile: boolean): void;
  UIMetadata(): NSDictionary<any, any>;
  setUIMetadata(UIMetadata: NSDictionary<any, any> | {[key: string]: any}): void;
  scrollOrigin(): NSPoint;
  setScrollOrigin(scrollOrigin: NSPoint): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  colorSpaceMismatchWarning(): any;
  setColorSpaceMismatchWarning(colorSpaceMismatchWarning: any): void;
  editingLibraryWarning(): any;
  setEditingLibraryWarning(editingLibraryWarning: any): void;
  isCurrent(): boolean;
}

class MSDocumentActionAllocator<T extends MSDocumentAction> extends MSActionAllocator<T> {
  initWithDocument(doc: MSDocument): T;
}
declare class MSDocumentAction extends MSAction {
  alloc<T extends MSDocumentAction>(): MSDocumentActionAllocator<T>;
  touchBarItem(): NSTouchBarItem;
  makeTouchBarItem(): NSTouchBarItem;
  makeTouchBarItemButton(): NSButton;
  touchBarItemButtonShouldShowState(): boolean;
  refreshTouchBarItem(): void;
  showTouchBarPopover(sender: any): void;
  isTouchBarItemSelected(): boolean;
  shouldUseImageForTouchBarItem(): boolean;
  touchBarImage(): NSImage;
  touchBarItemSizing(): MSTouchBarItemSizing;
  selectedLayers(): MSLayerArray;
  isInNormalHandler(): boolean;
  currentHandler(): MSEventHandler;
  toggleHandlerClass(handlerClass: any): MSEventHandler;
  setCurrentHandlerClass(handlerClass: any): MSEventHandler;
  switchToNormalHandler(): void;
  currentPage(): MSPage;
  contentDrawView(): MSContentDrawView;
  refreshOverlay(): void;
  repopulateMenu(menu: NSMenu): void;

  document(): MSDocument;
  setDocument(document: MSDocument): void;
  historyMomentTitle(): NSString;
  cachedTouchedBarItem(): NSTouchBarItem;
  setCachedTouchedBarItem(cachedTouchedBarItem: NSTouchBarItem): void;
}

declare enum MSTouchBarItemSizing {
  MSTouchBarItemSizingDefault = 0,
  MSTouchBarItemSizingNarrow = 1,
  MSTouchBarItemSizingSquare = 2,
}

class MSDocumentControllerAllocator<T extends MSDocumentController> extends NSDocumentControllerAllocator<T> {}
declare class MSDocumentController extends NSDocumentController {
  alloc<T extends MSDocumentController>(): MSDocumentControllerAllocator<T>;
  openDocumentWithContentsOfURL_display_context_callback(url: NSURL, displayDocument: boolean, coscript: COScript, callback: MOJavaScriptObject | Function): void;
}

class MSDocumentImporterAllocator<T extends MSDocumentImporter> extends NSObjectAllocator<T> {}
declare class MSDocumentImporter extends NSObject {
  alloc<T extends MSDocumentImporter>(): MSDocumentImporterAllocator<T>;
  static importFromURL_inPage_importer(url: NSURL, page: MSPage, importer: any): void;

  group(): MSLayerGroup;
  view(): MSContentDrawView;
}

class MSDocumentWindowAllocator<T extends MSDocumentWindow> extends NSWindowAllocator<T> {}
declare class MSDocumentWindow extends NSWindow {
  alloc<T extends MSDocumentWindow>(): MSDocumentWindowAllocator<T>;

  titleBarBadge(): BCWindowBadge;
  setTitleBarBadge(titleBarBadge: BCWindowBadge): void;
}

class MSDocumentWindowContentViewAllocator<T extends MSDocumentWindowContentView> extends NSViewAllocator<T> {}
declare class MSDocumentWindowContentView extends NSView {
  alloc<T extends MSDocumentWindowContentView>(): MSDocumentWindowContentViewAllocator<T>;
}

class MSDragHandleGestureRecognizerAllocator<T extends MSDragHandleGestureRecognizer> extends MSDragToMoveOrCopyGestureRecognizerAllocator<T> {}
declare class MSDragHandleGestureRecognizer extends MSDragToMoveOrCopyGestureRecognizer {
  alloc<T extends MSDragHandleGestureRecognizer>(): MSDragHandleGestureRecognizerAllocator<T>;

  originalHandleLocation(): NSPoint;
  setOriginalHandleLocation(originalHandleLocation: NSPoint): void;
  lockingConstraint(): MSAlignmentEngineConstraint;
  setLockingConstraint(lockingConstraint: MSAlignmentEngineConstraint): void;
  effectiveLockingConstraint(): MSAlignmentEngineConstraint;
}

class MSDragRectEventHandlerAllocator<T extends MSDragRectEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSDragRectEventHandler extends MSEventHandler {
  alloc<T extends MSDragRectEventHandler>(): MSDragRectEventHandlerAllocator<T>;
  performActionWithRect_fromLayer_constrainProportions(rect: NSRect, layer: MSLayer | null, constrainProportions: boolean): MSLayer;
  drawingRectForInsertionRect(insertionRect: NSRect): NSRect;
  drawRectPreview(): void;

  insertionRect(): NSRect;
  setInsertionRect(insertionRect: NSRect): void;
  allowsInsertLayerFromExistingLayer(): boolean;
  cursorForInsertingFromExisting(): NSCursor;
  layerSelectionOptionsForInsertingFromExistingLayer(): MSLayerSelectionOptions;
  dragGestureRecognizer(): MSDragGestureRecognizer;
  snapper(): MSAlignmentEngine;
  snappingResult(): MSAlignmentEngineResult;
  setSnappingResult(snappingResult: MSAlignmentEngineResult): void;
  insertionCursor(): NSCursor;
  setInsertionCursor(insertionCursor: NSCursor): void;
}

class MSDragRectGestureRecognizerAllocator<T extends MSDragRectGestureRecognizer> extends MSDragGestureRecognizerAllocator<T> {}
declare class MSDragRectGestureRecognizer extends MSDragGestureRecognizer {
  alloc<T extends MSDragRectGestureRecognizer>(): MSDragRectGestureRecognizerAllocator<T>;

  constrainProportions(): boolean;
}

class MSDragSegmentGestureRecognizerAllocator<T extends MSDragSegmentGestureRecognizer> extends MSDragGestureRecognizerAllocator<T> {}
declare class MSDragSegmentGestureRecognizer extends MSDragGestureRecognizer {
  alloc<T extends MSDragSegmentGestureRecognizer>(): MSDragSegmentGestureRecognizerAllocator<T>;

  offset(): CGFloat;
  setOffset(offset: CGFloat): void;
}

class MSDragToMoveOrCopyGestureRecognizerAllocator<T extends MSDragToMoveOrCopyGestureRecognizer> extends MSDragGestureRecognizerAllocator<T> {}
declare class MSDragToMoveOrCopyGestureRecognizer extends MSDragGestureRecognizer {
  alloc<T extends MSDragToMoveOrCopyGestureRecognizer>(): MSDragToMoveOrCopyGestureRecognizerAllocator<T>;
  translationInLayer(layer: MSLayer | null): CGVector;
  locationInLayer(layer: MSLayer | null): NSPoint;

  shouldCopyDraggedItems(): boolean;
  shouldSnap(): boolean;
  alignModifierMask(): NSEventModifierFlags;
  setAlignModifierMask(alignModifierMask: NSEventModifierFlags): void;
  shouldInterpretAlignment(): boolean;
  setShouldInterpretAlignment(shouldInterpretAlignment: boolean): void;
  align(): boolean;
  alignmentAxis(): BCAxis;
  draggedItem(): any;
  setDraggedItem(draggedItem: any): void;
  originalDraggedItems(): NSArray<any>;
  setOriginalDraggedItems(originalDraggedItems: NSArray<any> | any[]): void;
  originalDragPositions(): NSArray<any>;
  setOriginalDragPositions(originalDragPositions: NSArray<any> | any[]): void;
  copiedItems(): NSArray<any>;
  setCopiedItems(copiedItems: NSArray<any> | any[]): void;
}

class MSDragLayerGestureRecognizerAllocator<T extends MSDragLayerGestureRecognizer> extends MSDragToMoveOrCopyGestureRecognizerAllocator<T> {}
declare class MSDragLayerGestureRecognizer extends MSDragToMoveOrCopyGestureRecognizer {
  alloc<T extends MSDragLayerGestureRecognizer>(): MSDragLayerGestureRecognizerAllocator<T>;
}

class MSDragToSelectGestureRecognizerAllocator<T extends MSDragToSelectGestureRecognizer> extends MSDragGestureRecognizerAllocator<T> {}
declare class MSDragToSelectGestureRecognizer extends MSDragGestureRecognizer {
  alloc<T extends MSDragToSelectGestureRecognizer>(): MSDragToSelectGestureRecognizerAllocator<T>;
  selectionRect(): NSRect;

  extendSelection(): boolean;
  selectionExtensionMask(): NSEventModifierFlags;
  setSelectionExtensionMask(selectionExtensionMask: NSEventModifierFlags): void;
  initialSelection(): NSArray<any>;
  setInitialSelection(initialSelection: NSArray<any> | any[]): void;
}

class MSDrawingInfoAllocator<T extends MSDrawingInfo> extends NSObjectAllocator<T> {}
declare class MSDrawingInfo extends NSObject {
  alloc<T extends MSDrawingInfo>(): MSDrawingInfoAllocator<T>;
  static sharedController(): MSDrawingInfo;

  isDragging(): boolean;
  setIsDragging(isDragging: boolean): void;
}

class MSDropdownButtonCellAllocator<T extends MSDropdownButtonCell> extends MSSmallButtonCellAllocator<T> {}
declare class MSDropdownButtonCell extends MSSmallButtonCell {
  alloc<T extends MSDropdownButtonCell>(): MSDropdownButtonCellAllocator<T>;

  imageRightEdgeInset(): CGFloat;
  setImageRightEdgeInset(imageRightEdgeInset: CGFloat): void;
}

class MSDuplicateOffsetTrackerAllocator<T extends MSDuplicateOffsetTracker> extends NSObjectAllocator<T> {}
declare class MSDuplicateOffsetTracker extends NSObject {
  alloc<T extends MSDuplicateOffsetTracker>(): MSDuplicateOffsetTrackerAllocator<T>;
  reset(): void;
  resetToInitialOffset(): void;
  increment(): void;
  offset(): CGFloat;
}

class MSEditActionAllocator<T extends MSEditAction> extends MSDocumentActionAllocator<T> {}
declare class MSEditAction extends MSDocumentAction {
  alloc<T extends MSEditAction>(): MSEditActionAllocator<T>;
  static editableLayerTraits(): MSTraits;
  edit(sender: any): IBAction;
}

class MSEditArtboardPresetViewControllerAllocator<T extends MSEditArtboardPresetViewController> extends NSViewControllerAllocator<T> {}
declare class MSEditArtboardPresetViewController extends NSViewController {
  alloc<T extends MSEditArtboardPresetViewController>(): MSEditArtboardPresetViewControllerAllocator<T>;

  preset(): MSArtboardPreset;
  setPreset(preset: MSArtboardPreset): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSEditArtboardPresetViewControllerDelegate {
  editArtboardPresetViewController_savePreset(sender: MSEditArtboardPresetViewController, preset: MSArtboardPreset): void;
}

class MSEditColorSpaceActionAllocator<T extends MSEditColorSpaceAction> extends MSDocumentActionAllocator<T> {}
declare class MSEditColorSpaceAction extends MSDocumentAction {
  alloc<T extends MSEditColorSpaceAction>(): MSEditColorSpaceActionAllocator<T>;
  editDocumentColorSpace(sender: any): IBAction;
}

class MSChangeColorSpaceActionAllocator<T extends MSChangeColorSpaceAction> extends MSDocumentActionAllocator<T> {}
declare class MSChangeColorSpaceAction extends MSDocumentAction {
  alloc<T extends MSChangeColorSpaceAction>(): MSChangeColorSpaceActionAllocator<T>;
}

class MSAssignColorSpaceActionAllocator<T extends MSAssignColorSpaceAction> extends MSChangeColorSpaceActionAllocator<T> {}
declare class MSAssignColorSpaceAction extends MSChangeColorSpaceAction {
  alloc<T extends MSAssignColorSpaceAction>(): MSAssignColorSpaceActionAllocator<T>;
  assignDocumentColorSpace(sender: any): IBAction;
}

class MSConvertColorSpaceActionAllocator<T extends MSConvertColorSpaceAction> extends MSChangeColorSpaceActionAllocator<T> {}
declare class MSConvertColorSpaceAction extends MSChangeColorSpaceAction {
  alloc<T extends MSConvertColorSpaceAction>(): MSConvertColorSpaceActionAllocator<T>;
  convertDocumentColorSpace(sender: any): IBAction;
}

class MSEditColorSpaceSheetControllerAllocator<T extends MSEditColorSpaceSheetController> extends CHSheetControllerAllocator<T> {}
declare class MSEditColorSpaceSheetController extends CHSheetController {
  alloc<T extends MSEditColorSpaceSheetController>(): MSEditColorSpaceSheetControllerAllocator<T>;
  pickColorSpace(sender: any): IBAction;
  pickChangeLogic(sender: any): IBAction;
  viewDocumentation(sender: any): IBAction;

  assignButton(): NSButton;
  setAssignButton(assignButton: NSButton): void;
  assignDescriptionTextField(): NSTextField;
  setAssignDescriptionTextField(assignDescriptionTextField: NSTextField): void;
  colorSpacePopUpButton(): NSPopUpButton;
  setColorSpacePopUpButton(colorSpacePopUpButton: NSPopUpButton): void;
  descriptionTextField(): NSTextField;
  setDescriptionTextField(descriptionTextField: NSTextField): void;
  confirmButton(): NSButton;
  setConfirmButton(confirmButton: NSButton): void;
  convertButton(): NSButton;
  setConvertButton(convertButton: NSButton): void;
  convertDescriptionTextField(): NSTextField;
  setConvertDescriptionTextField(convertDescriptionTextField: NSTextField): void;
}

class MSEditShapeInspectorViewControllerAllocator<T extends MSEditShapeInspectorViewController> extends NSViewControllerAllocator<T> {}
declare class MSEditShapeInspectorViewController extends NSViewController implements IMSInspectorChildController {
  alloc<T extends MSEditShapeInspectorViewController>(): MSEditShapeInspectorViewControllerAllocator<T>;
  refresh(): void;
  refreshClosePathButton(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;

  pathController(): MSPathController;
  setPathController(pathController: MSPathController): void;
  shapeEventHandler(): MSShapeEventHandler;
  setShapeEventHandler(shapeEventHandler: MSShapeEventHandler): void;
  isMakingRectSelection(): boolean;
  setIsMakingRectSelection(isMakingRectSelection: boolean): void;
}

class MSEventHandlerAllocator<T extends MSEventHandler> extends NSResponderAllocator<T> {
  initWithManager(aManager: MSEventHandlerManager): T;
}
declare class MSEventHandler extends NSResponder implements INSDraggingDestination, INSTouchBarDelegate {
  alloc<T extends MSEventHandler>(): MSEventHandlerAllocator<T>;
  static eventHandlerWithManager(aManager: MSEventHandlerManager): any;
  currentGroup(): MSLayerGroup;
  layersToCopy(): MSLayerArray;
  parentForInsertingLayer(layer: MSLayer): MSLayerGroup;
  alignPointToGrid(point: NSPoint): NSPoint;
  mouseDownEvent(event: NSEvent): boolean;
  mouseDraggedEvent(event: NSEvent): boolean;
  mouseUpEvent(event: NSEvent): boolean;
  mouseMovedEvent(event: NSEvent): boolean;
  rightMouseDown(event: NSEvent): void;
  absoluteMouseDown_clickCount_flags(mouse: NSPoint, c: NSUInteger, flags: NSUInteger): boolean;
  absoluteMouseDragged_flags(mouse: NSPoint, flags: NSUInteger): boolean;
  absoluteMouseUp_flags(mouse: NSPoint, flags: NSUInteger): boolean;
  absoluteMouseMoved_flags(mouse: NSPoint, flags: NSEventModifierFlags): boolean;
  mouseDraggedOutsideViewShouldMoveScrollOrigin(): boolean;
  zoomValue(): CGFloat;
  viewDidScroll(sender: any): void;
  trackMouse(tracker: MSMouseTracker): void;
  addGestureRecognizer(recognizer: MSGestureRecognizer): void;
  updateCursor(): boolean;
  setNeedsUpdateCursor(): void;
  cancelOperation(sender: any): void;
  setMeasurementTextWithSize(size: NSSize): void;
  setMeasurementTextWithDegrees(degrees: NSInteger): void;
  addOverlayRenderer(renderer: MSOverlayRenderer): void;
  prepareGraphicsStateForGroup_drawingBlock(group: MSLayerGroup, block: BCVoidBlock): void;
  drawMeasurementLabel(): void;
  drawDragSelection(): void;
  handlerWillLoseFocus(): void;
  handlerDidLoseFocus(): void;
  selectAll(sender: any): IBAction;
  returnToDefaultHandler(): void;
  returnToDefaultHandlerByClickingOutside(): void;
  selectToolbarItemWithIdentifier(identifier: NSString | string): void;
  menuForEvent(theEvent: NSEvent): NSMenu;
  writeLayers_toPasteboard(layers: MSLayerArray, pb: NSPasteboard): void;
  duplicateSelectedLayersWithOffset(offset: CGVector): NSArray<any>;
  contentDrawView(): MSContentDrawView;
  currentPage(): MSPage;
  document(): MSDocument;
  refreshOverlay(): void;
  cut(sender: any): IBAction;
  copy(sender: any): IBAction;
  paste(sender: any): IBAction;
  pasteWithStyle(sender: any): IBAction;
  pasteOverSelection(sender: any): IBAction;
  pasteHere(sender: any): IBAction;
  duplicate(sender: any): IBAction;
  delete(sender: any): IBAction;
  itemAtPoint_modifierFlags(mouse: NSPoint, flags: NSEventModifierFlags): MSHitTestResult;
  hitTestingOptions(): MSLayerSelectionOptions;
  deleteKeyIsPressed(c: unichar): boolean;
  enterKeyIsPressed(c: unichar): boolean;
  escapeKeyIsPressed(c: unichar): boolean;
  arrowKeyIsPressed(c: unichar): boolean;
  drawHandles(): void;
  toolbarIdentifier(): NSString;
  changeColor(sender: any): void;
  selectedLayers(): MSLayerArray;
  selectLayer_extendSelection(layer: MSLayer, extend: boolean): void;
  selectHitTestResult_extendSelection(hitTestResult: MSHitTestResult, extend: boolean): void;
  imageName(): NSString;
  willMoveThroughHistory(note: NSNotification): void;
  didMoveThroughHistory(note: NSNotification): void;
  commitPendingEdits(): void;
  reloadFollowingBackgroundChangesToDocument(): void;
  zoomToSelection(): void;
  zoomToArtboard(): void;
  selectedRect(): NSRect;
  centerPointForZooming(): NSPoint;
  draggingEntered(sender: any): NSDragOperation;
  draggingExited(sender: any): void;
  prepareForDragOperation(sender: any): boolean;
  draggingUpdated(sender: any): NSDragOperation;
  performDragOperation(sender: any): boolean;
  zoomValueWillChangeTo(zoomValue: CGFloat): void;
  zoomValueDidChange(): void;
  layerListSelectionDidChange(selection: NSArray<any> | any[]): void;
  layerRulerOriginChanged(): void;
  currentPageDidChange(): void;
  allowsSwitchToInsertAction(): boolean;
  handlesHandToolItself(): boolean;
  insertTab(sender: any): void;
  insertBacktab(sender: any): void;
  mouseExited(): void;
  mayShowResizingInspectorView(): boolean;
  editLayer(layer: MSLayer): void;
  willResignFirstResponder(): void;
  layerPositionPossiblyChanged(): void;
  configureInspector(inspector: MSInspectorController): void;
  inspectorViewControllersForLayers_standardControllers(layers: NSArray<any> | any[], standardInspectors: MSStandardInspectorViewControllers): NSArray<any>;
  inspectorLocation(): MSInpectorLocation;
  inspectorShouldShowPositions(): boolean;
  focusOnMainWindow(): void;
  canDuplicate(): boolean;
  shouldFitToPixelBounds(): boolean;
  nudgeDistanceForFlags(flags: NSEventModifierFlags): CGFloat;
  touchBarWithIdentifiers(identifiers: NSArray<any> | any[]): NSTouchBar;
  refreshTouchBarItemWithIdentifier(identifier: NSString | string): void;
  documentWindow(): MSDocumentWindow;
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  draggingEntered(sender: any): NSDragOperation;
  draggingUpdated(sender: any): NSDragOperation;
  draggingExited(sender: any | null): void;
  prepareForDragOperation(sender: any): boolean;
  performDragOperation(sender: any): boolean;
  concludeDragOperation(sender: any | null): void;
  draggingEnded(sender: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
  updateDraggingItemsForDrag(sender: any | null): void;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  manager(): MSEventHandlerManager;
  setManager(manager: MSEventHandlerManager): void;
  offsetTracker(): MSDuplicateOffsetTracker;
  setOffsetTracker(offsetTracker: MSDuplicateOffsetTracker): void;
  pressedKeys(): NSString;
  setPressedKeys(pressedKeys: NSString | string): void;
  handlesHistoryCoalescing(): boolean;
  shouldExitOnContentViewResize(): boolean;
  undoManager(): NSUndoManager;
  applicableActionItemIdentifier(): NSString;
  gestureRecognizers(): NSArray<any>;
  cursor(): NSCursor;
  setCursor(cursor: NSCursor): void;
  measurementText(): NSString;
  setMeasurementText(measurementText: NSString | string): void;
  overlayRenderers(): NSArray<any>;
  selectionRect(): NSRect;
  setSelectionRect(selectionRect: NSRect): void;
  wantsStandardSelectionControls(): boolean;
  wantsLayerHighlight(): boolean;
}

declare enum MSUnicodeAdditions {
  MSUnicodeEscapeKey = 27,
  MSUnicodeFNLeftKey = 63273,
  MSUnicodeFNRightKey = 63275,
}

declare enum MSInpectorLocation {
  MSInspectorLocationNone,
  MSInspectorLocationTakeOverEntireInspector,
  MSInspectorLocationAboveNormalInspector,
}

class MSEventHandlerActionAllocator<T extends MSEventHandlerAction> extends MSDocumentActionAllocator<T> {}
declare class MSEventHandlerAction extends MSDocumentAction {
  alloc<T extends MSEventHandlerAction>(): MSEventHandlerActionAllocator<T>;
  eventHandlerClass(): any;
}

class MSEventHandlerManagerAllocator<T extends MSEventHandlerManager> extends NSObjectAllocator<T> {
  initWithDelegate(delegate: any): T;
}
declare class MSEventHandlerManager extends NSObject {
  alloc<T extends MSEventHandlerManager>(): MSEventHandlerManagerAllocator<T>;
  setCurrentHandler_force(handler: MSEventHandler | null, force: boolean): void;
  handlerForClass(aClass: any): MSEventHandler;
  switchToEventHandlerClass(handlerClass: any): MSEventHandler;
  toggleHandlerClass(handlerClass: any): MSEventHandler;
  drawInRect_context(dirtyRect: NSRect, context: MSRenderingContext): void;
  sendMouseDownEvent(event: NSEvent): void;
  sendMouseDraggedEvent(event: NSEvent): void;
  sendMouseUpEvent(event: NSEvent): void;
  sendMouseMovedEvent(event: NSEvent): void;
  recordEvent(event: NSEvent): void;

  document(): MSDocument;
  setDocument(document: MSDocument): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  currentHandler(): MSEventHandler;
  setCurrentHandler(currentHandler: MSEventHandler): void;
  normalHandler(): MSNormalEventHandler;
  lastMouseDownClickCount(): NSInteger;
  lastEventType(): MSEventType;
}

declare interface IMSEventHandlerManagerDelegate {
  eventHandlerManager_didChangeCurrentHandler(manager: MSEventHandlerManager, newHandler: MSEventHandler): void;
}

declare enum MSEventType {
  MSEventTypeUndefined = 0,
  MSEventTypeMouse = 1,
}

class MSExpandedStateSavingOutlineViewAllocator<T extends MSExpandedStateSavingOutlineView> extends NSOutlineViewAllocator<T> {}
declare class MSExpandedStateSavingOutlineView extends NSOutlineView {
  alloc<T extends MSExpandedStateSavingOutlineView>(): MSExpandedStateSavingOutlineViewAllocator<T>;

  expandedStateAutosaveName(): NSString;
  setExpandedStateAutosaveName(expandedStateAutosaveName: NSString | string): void;
}

class MSExportActionAllocator<T extends MSExportAction> extends MSDocumentActionAllocator<T> {}
declare class MSExportAction extends MSDocumentAction {
  alloc<T extends MSExportAction>(): MSExportActionAllocator<T>;
  export(sender: any): IBAction;
}

class MSExportSelectionWithExportFormatsActionAllocator<T extends MSExportSelectionWithExportFormatsAction> extends MSDocumentActionAllocator<T> {}
declare class MSExportSelectionWithExportFormatsAction extends MSDocumentAction {
  alloc<T extends MSExportSelectionWithExportFormatsAction>(): MSExportSelectionWithExportFormatsActionAllocator<T>;
  exportSelection(sender: any): IBAction;
}

class MSExportFormatNamingTextFieldAllocator<T extends MSExportFormatNamingTextField> extends NSTextFieldAllocator<T> {}
declare class MSExportFormatNamingTextField extends NSTextField {
  alloc<T extends MSExportFormatNamingTextField>(): MSExportFormatNamingTextFieldAllocator<T>;
  static sharedFieldEditor(): NSTextView;

  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
}

class MSExportFormatNamingTextFieldCellAllocator<T extends MSExportFormatNamingTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class MSExportFormatNamingTextFieldCell extends NSTextFieldCell {
  alloc<T extends MSExportFormatNamingTextFieldCell>(): MSExportFormatNamingTextFieldCellAllocator<T>;
}

class MSExportFormatPopUpButtonCellAllocator<T extends MSExportFormatPopUpButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSExportFormatPopUpButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSExportFormatPopUpButtonCell>(): MSExportFormatPopUpButtonCellAllocator<T>;
}

class MSExportFormatViewControllerAllocator<T extends MSExportFormatViewController> extends NSViewControllerAllocator<T> {}
declare class MSExportFormatViewController extends NSViewController {
  alloc<T extends MSExportFormatViewController>(): MSExportFormatViewControllerAllocator<T>;
  prepare(): void;
  commitScaleFieldEditsWithCompletionBlock(block: dispatch_block_t): void;
  removeExportFormat(sender: any): IBAction;
  formatPopupAction(sender: any): IBAction;
  scaleFieldAction(sender: any): IBAction;

  formatPopup(): NSPopUpButton;
  setFormatPopup(formatPopup: NSPopUpButton): void;
  removeSizeButton(): NSButton;
  setRemoveSizeButton(removeSizeButton: NSButton): void;
  sizeView(): NSView;
  setSizeView(sizeView: NSView): void;
  suffixTextField(): MSExportFormatNamingTextField;
  setSuffixTextField(suffixTextField: MSExportFormatNamingTextField): void;
  exportFormats(): NSArray<any>;
  setExportFormats(exportFormats: NSArray<any> | any[]): void;
  scaleField(): NSTextField;
  setScaleField(scaleField: NSTextField): void;
  removeButtonHidden(): boolean;
  setRemoveButtonHidden(removeButtonHidden: boolean): void;
}

class MSExportInspectorViewControllerAllocator<T extends MSExportInspectorViewController> extends MSStylePartInspectorViewControllerAllocator<T> {}
declare class MSExportInspectorViewController extends MSStylePartInspectorViewController {
  alloc<T extends MSExportInspectorViewController>(): MSExportInspectorViewControllerAllocator<T>;
  addExportFormat(sender: any): IBAction;
  createSliceAction(sender: any): IBAction;
  showExportPresetMenu(sender: any): IBAction;
  addExportPreset(sender: any): IBAction;
  applyExportPreset(sender: any): IBAction;
  editExportPresets(sender: any): IBAction;

  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  bottomLabelView(): NSView;
  setBottomLabelView(bottomLabelView: NSView): void;
  exportFormatLabelTextField(): NSTextField;
  setExportFormatLabelTextField(exportFormatLabelTextField: NSTextField): void;
  headerLabel(): NSTextField;
  setHeaderLabel(headerLabel: NSTextField): void;
}

class MSExportManagerAllocator<T extends MSExportManager> extends NSObjectAllocator<T> {}
declare class MSExportManager extends NSObject {
  alloc<T extends MSExportManager>(): MSExportManagerAllocator<T>;
  exportedDataForRequest(exportRequest: MSExportRequest): NSData;
  exportFileForRequest_toFileURL(exportRequest: MSExportRequest, fileURL: NSURL): void;
  exportFilesForRequests(exportRequests: NSArray<any> | any[]): void;

  colorSpace(): NSColorSpace;
  sliceCompletionBlock(): MSExportManagerSliceCompletionBlock;
  setSliceCompletionBlock(sliceCompletionBlock: MSExportManagerSliceCompletionBlock): void;
}

class MSExportPDFBookActionAllocator<T extends MSExportPDFBookAction> extends MSDocumentActionAllocator<T> {}
declare class MSExportPDFBookAction extends MSDocumentAction {
  alloc<T extends MSExportPDFBookAction>(): MSExportPDFBookActionAllocator<T>;
  exportPDFBook(sender: any): IBAction;
}

class MSExportPresetFormatViewControllerAllocator<T extends MSExportPresetFormatViewController> extends MSExportFormatViewControllerAllocator<T> {}
declare class MSExportPresetFormatViewController extends MSExportFormatViewController {
  alloc<T extends MSExportPresetFormatViewController>(): MSExportPresetFormatViewControllerAllocator<T>;
}

class MSExportPresetsPreferencePaneAllocator<T extends MSExportPresetsPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSExportPresetsPreferencePane extends MSPreferencePane implements INSTableViewDataSource, INSTableViewDelegate {
  alloc<T extends MSExportPresetsPreferencePane>(): MSExportPresetsPreferencePaneAllocator<T>;
  editExportPreset(preset: MSExportPreset): void;
  addExportPreset(sender: any): IBAction;
  removeExportPreset(sender: any): IBAction;
  pickDefaultExportPreset(sender: any): IBAction;
  restoreDefaultExportPresets(sender: any): IBAction;
  addExportFormat(sender: any): IBAction;
  removeExportFormatFromPreset(sender: any): IBAction;
  commitExportPresetName(sender: any): IBAction;
  static localizedNewExportPresetName(): NSString;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;

  addButton(): NSButton;
  setAddButton(addButton: NSButton): void;
  addFormatButton(): NSButton;
  setAddFormatButton(addFormatButton: NSButton): void;
  exportFormatEditorView(): NSView;
  setExportFormatEditorView(exportFormatEditorView: NSView): void;
  exportFormatFooterView(): NSView;
  setExportFormatFooterView(exportFormatFooterView: NSView): void;
  exportFormatFooterBottomConstraint(): NSLayoutConstraint;
  setExportFormatFooterBottomConstraint(exportFormatFooterBottomConstraint: NSLayoutConstraint): void;
  exportFormatsView(): NSStackView;
  setExportFormatsView(exportFormatsView: NSStackView): void;
  exportFormatsViewController(): MSExportFormatViewController;
  setExportFormatsViewController(exportFormatsViewController: MSExportFormatViewController): void;
  noPresetsPlaceholderView(): NSView;
  setNoPresetsPlaceholderView(noPresetsPlaceholderView: NSView): void;
  presetNameTextField(): NSTextField;
  setPresetNameTextField(presetNameTextField: NSTextField): void;
  removeButton(): NSButton;
  setRemoveButton(removeButton: NSButton): void;
  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  presets(): NSArray<any>;
}

class MSExportPresetTableCellViewAllocator<T extends MSExportPresetTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSExportPresetTableCellView extends NSTableCellView {
  alloc<T extends MSExportPresetTableCellView>(): MSExportPresetTableCellViewAllocator<T>;

  defaultPresetButton(): NSButton;
  setDefaultPresetButton(defaultPresetButton: NSButton): void;
}

class MSExportPreviewHeaderInspectorItemAllocator<T extends MSExportPreviewHeaderInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSExportPreviewHeaderInspectorItem extends MSInspectorItem {
  alloc<T extends MSExportPreviewHeaderInspectorItem>(): MSExportPreviewHeaderInspectorItemAllocator<T>;

  collapsed(): boolean;
  setCollapsed(collapsed: boolean): void;
  hideSeparator(): boolean;
  setHideSeparator(hideSeparator: boolean): void;
}

class MSExportPreviewImagesInspectorItemAllocator<T extends MSExportPreviewImagesInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSExportPreviewImagesInspectorItem extends MSInspectorItem {
  alloc<T extends MSExportPreviewImagesInspectorItem>(): MSExportPreviewImagesInspectorItemAllocator<T>;
}

class MSExportPreviewInspectorSectionAllocator<T extends MSExportPreviewInspectorSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSExportPreviewInspectorSection extends MSBaseInspectorSection {
  alloc<T extends MSExportPreviewInspectorSection>(): MSExportPreviewInspectorSectionAllocator<T>;
}

class MSExportPreviewOperationAllocator<T extends MSExportPreviewOperation> extends NSOperationAllocator<T> {
  initWithAncestry(ancestry: MSImmutableLayerAncestry): T;
}
declare class MSExportPreviewOperation extends NSOperation {
  alloc<T extends MSExportPreviewOperation>(): MSExportPreviewOperationAllocator<T>;
  static sharedPreviewRenderQueue(): NSOperationQueue;

  previewViewModel(): MSExportPreviewViewModel;
}

class MSExportPreviewViewAllocator<T extends MSExportPreviewView> extends NSViewAllocator<T> {
  initWithViewModel(viewModel: MSExportPreviewViewModel): T;
}
declare class MSExportPreviewView extends NSView implements INSDraggingSource, INSPasteboardWriting {
  alloc<T extends MSExportPreviewView>(): MSExportPreviewViewAllocator<T>;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;

  viewModel(): MSExportPreviewViewModel;
  setViewModel(viewModel: MSExportPreviewViewModel): void;
}

class MSExportPreviewViewModelAllocator<T extends MSExportPreviewViewModel> extends NSObjectAllocator<T> {
  initWithPreviewImage_cachedExportRequest_ancestry(previewImage: NSImage, cachedExportRequest: MSExportRequest, ancestry: MSImmutableLayerAncestry): T;
}
declare class MSExportPreviewViewModel extends NSObject {
  alloc<T extends MSExportPreviewViewModel>(): MSExportPreviewViewModelAllocator<T>;
  imageDataInFormat(fileFormat: NSString | string): NSData;

  previewImage(): NSImage;
  cachedExportRequest(): MSExportRequest;
  layerName(): NSString;
  defaultExportFormat(): NSString;
  isVectorFormat(): boolean;
  previewFrame(): NSRect;
  setPreviewFrame(previewFrame: NSRect): void;
}

class MSExportSelectedInspectorItemAllocator<T extends MSExportSelectedInspectorItem> extends MSExportSelectedOrResizeInspectorItemAllocator<T> {}
declare class MSExportSelectedInspectorItem extends MSExportSelectedOrResizeInspectorItem {
  alloc<T extends MSExportSelectedInspectorItem>(): MSExportSelectedInspectorItemAllocator<T>;
}

class MSExportSelectedOrResizeInspectorItemAllocator<T extends MSExportSelectedOrResizeInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSExportSelectedOrResizeInspectorItem extends MSInspectorItem {
  alloc<T extends MSExportSelectedOrResizeInspectorItem>(): MSExportSelectedOrResizeInspectorItemAllocator<T>;

  sizeToFitButton(): NSButton;
  setSizeToFitButton(sizeToFitButton: NSButton): void;
  exportButton(): NSButton;
  setExportButton(exportButton: NSButton): void;
}

class MSExportSheetAllocator<T extends MSExportSheet> extends CHSheetControllerAllocator<T> {}
declare class MSExportSheet extends CHSheetController {
  alloc<T extends MSExportSheet>(): MSExportSheetAllocator<T>;
  includeAllCheckboxAction(sender: any): IBAction;
  collectionView_newItemForRepresentedObject(collectionView: NSCollectionView, object: any): NSCollectionViewItem;
  validateIncludeAllSlicesCheckBox(): void;
  isItemSelectedForExport(item: any): boolean;
  toggleItemSelectedForExportState(item: any): void;

  collectionView(): NSCollectionView;
  setCollectionView(collectionView: NSCollectionView): void;
  selectedSlices(): NSMutableArray<any>;
  setSelectedSlices(selectedSlices: NSMutableArray<any> | any[]): void;
}

class MSExportSheetItemAllocator<T extends MSExportSheetItem> extends NSCollectionViewItemAllocator<T> {}
declare class MSExportSheetItem extends NSCollectionViewItem {
  alloc<T extends MSExportSheetItem>(): MSExportSheetItemAllocator<T>;

  previewContainer(): NSView;
  setPreviewContainer(previewContainer: NSView): void;
  checkBox(): NSButton;
  setCheckBox(checkBox: NSButton): void;
  warningView(): NSImageView;
  setWarningView(warningView: NSImageView): void;
  exportSheet(): MSExportSheet;
  setExportSheet(exportSheet: MSExportSheet): void;
  showWarningLabel(): boolean;
  setShowWarningLabel(showWarningLabel: boolean): void;
  isExportable(): boolean;
  setIsExportable(isExportable: boolean): void;
}

class MSExportStackViewAllocator<T extends MSExportStackView> extends MSStackViewAllocator<T> {}
declare class MSExportStackView extends MSStackView {
  alloc<T extends MSExportStackView>(): MSExportStackViewAllocator<T>;
}

class MSExportableLayerInspectorViewControllerAllocator<T extends MSExportableLayerInspectorViewController> extends CHViewControllerAllocator<T> {}
declare class MSExportableLayerInspectorViewController extends CHViewController implements IMSInspectorChildController, IMSSliceLayerWatcher, IMSColorInspectorDelegate, IBCPopoverDelegate {
  alloc<T extends MSExportableLayerInspectorViewController>(): MSExportableLayerInspectorViewControllerAllocator<T>;
  selectionDidChangeTo(newLayers: NSArray<any> | any[]): void;
  oldStyleIncludedRadioAction(sender: any): IBAction;
  exportableSizeDidChange(sender: any): IBAction;
  groupContentsOnlyAction(sender: any): IBAction;
  layerPositionPossiblyChanged(): IBAction;
  artboardBackgroundCheckAction(sender: any): IBAction;
  backgroundColorAction(sender: any): IBAction;
  refreshAction(sender: any): IBAction;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;

  stackView(): MSInspectorStackView;
  setStackView(stackView: MSInspectorStackView): void;
  oldSliceIncludedTable(): NSTableView;
  setOldSliceIncludedTable(oldSliceIncludedTable: NSTableView): void;
  oldStyleIncludeMatrix(): NSMatrix;
  setOldStyleIncludeMatrix(oldStyleIncludeMatrix: NSMatrix): void;
  groupContentsOnlyButton(): NSButton;
  setGroupContentsOnlyButton(groupContentsOnlyButton: NSButton): void;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}

class MSFastPathBuilderAllocator<T extends MSFastPathBuilder> extends NSObjectAllocator<T> {}
declare class MSFastPathBuilder extends NSObject {
  alloc<T extends MSFastPathBuilder>(): MSFastPathBuilderAllocator<T>;
  static pathForMaskImage(maskImage: NSBitmapImageRep): NSBezierPath;
}

class MSFeedbackActionAllocator<T extends MSFeedbackAction> extends MSActionAllocator<T> {}
declare class MSFeedbackAction extends MSAction {
  alloc<T extends MSFeedbackAction>(): MSFeedbackActionAllocator<T>;
  feedback(sender: any): IBAction;
}

class MSFillAndBorderColorScreenPickerAllocator<T extends MSFillAndBorderColorScreenPicker> extends NSObjectAllocator<T> {}
declare class MSFillAndBorderColorScreenPicker extends NSObject {
  alloc<T extends MSFillAndBorderColorScreenPicker>(): MSFillAndBorderColorScreenPickerAllocator<T>;
  static pickColorForLayers_colorSpace_completionBlock(layers: NSArray<any> | any[], colorspace: NSColorSpace, completionBlock: BCVoidBlock): void;
  static applyColor_toLayers(chosenColor: MSColor, layers: NSArray<any> | any[]): void;
  static setPreferredStylePartName(name: NSString | string): void;
}

class MSFillInspectorViewControllerAllocator<T extends MSFillInspectorViewController> extends MSColorStylePartInspectorViewControllerAllocator<T> {}
declare class MSFillInspectorViewController extends MSColorStylePartInspectorViewController {
  alloc<T extends MSFillInspectorViewController>(): MSFillInspectorViewControllerAllocator<T>;
  opacityFieldAction(sender: any): IBAction;

  blendingPopUpButton(): NSPopUpButton;
  setBlendingPopUpButton(blendingPopUpButton: NSPopUpButton): void;
  opacityField(): MSUpDownTextField;
  setOpacityField(opacityField: MSUpDownTextField): void;
}

class MSFillOptionsInspectorViewControllerAllocator<T extends MSFillOptionsInspectorViewController> extends NSViewControllerAllocator<T> {}
declare class MSFillOptionsInspectorViewController extends NSViewController {
  alloc<T extends MSFillOptionsInspectorViewController>(): MSFillOptionsInspectorViewControllerAllocator<T>;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
}

class MSBarViewAllocator<T extends MSBarView> extends MSGradientViewAllocator<T> {}
declare class MSBarView extends MSGradientView {
  alloc<T extends MSBarView>(): MSBarViewAllocator<T>;
}

class MSFilterBarViewAllocator<T extends MSFilterBarView> extends MSBarViewAllocator<T> {}
declare class MSFilterBarView extends MSBarView {
  alloc<T extends MSFilterBarView>(): MSFilterBarViewAllocator<T>;
}

class MSFindLayerActionAllocator<T extends MSFindLayerAction> extends MSDocumentActionAllocator<T> {}
declare class MSFindLayerAction extends MSDocumentAction {
  alloc<T extends MSFindLayerAction>(): MSFindLayerActionAllocator<T>;
  findLayer(sender: any): IBAction;
}

class MSFinishEditingButtonAllocator<T extends MSFinishEditingButton> extends NSButtonAllocator<T> {}
declare class MSFinishEditingButton extends NSButton {
  alloc<T extends MSFinishEditingButton>(): MSFinishEditingButtonAllocator<T>;
}

class MSFixedPopoverTouchBarItemAllocator<T extends MSFixedPopoverTouchBarItem> extends NSPopoverTouchBarItemAllocator<T> {}
declare class MSFixedPopoverTouchBarItem extends NSPopoverTouchBarItem {
  alloc<T extends MSFixedPopoverTouchBarItem>(): MSFixedPopoverTouchBarItemAllocator<T>;

  ms_parentTouchBar(): NSTouchBar;
  setMs_parentTouchBar(ms_parentTouchBar: NSTouchBar): void;
}

class MSFlattenActionAllocator<T extends MSFlattenAction> extends MSDocumentActionAllocator<T> {}
declare class MSFlattenAction extends MSDocumentAction {
  alloc<T extends MSFlattenAction>(): MSFlattenActionAllocator<T>;
  flatten(sender: any): IBAction;
}

class MSFlattenSelectionActionAllocator<T extends MSFlattenSelectionAction> extends MSDocumentActionAllocator<T> {}
declare class MSFlattenSelectionAction extends MSDocumentAction {
  alloc<T extends MSFlattenSelectionAction>(): MSFlattenSelectionActionAllocator<T>;
  flattenSelection(sender: any): IBAction;
}

class MSBaseFlipActionAllocator<T extends MSBaseFlipAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseFlipAction extends MSDocumentAction {
  alloc<T extends MSBaseFlipAction>(): MSBaseFlipActionAllocator<T>;
}

class MSFlipHorizontalActionAllocator<T extends MSFlipHorizontalAction> extends MSBaseFlipActionAllocator<T> {}
declare class MSFlipHorizontalAction extends MSBaseFlipAction {
  alloc<T extends MSFlipHorizontalAction>(): MSFlipHorizontalActionAllocator<T>;
  flipHorizontal(sender: any): IBAction;
}

class MSFlipVerticalActionAllocator<T extends MSFlipVerticalAction> extends MSBaseFlipActionAllocator<T> {}
declare class MSFlipVerticalAction extends MSBaseFlipAction {
  alloc<T extends MSFlipVerticalAction>(): MSFlipVerticalActionAllocator<T>;
  flipVertical(sender: any): IBAction;
}

class MSApplyHorizontalFlipActionAllocator<T extends MSApplyHorizontalFlipAction> extends MSBaseFlipActionAllocator<T> {}
declare class MSApplyHorizontalFlipAction extends MSBaseFlipAction {
  alloc<T extends MSApplyHorizontalFlipAction>(): MSApplyHorizontalFlipActionAllocator<T>;
}

class MSApplyVerticalFlipActionAllocator<T extends MSApplyVerticalFlipAction> extends MSBaseFlipActionAllocator<T> {}
declare class MSApplyVerticalFlipAction extends MSBaseFlipAction {
  alloc<T extends MSApplyVerticalFlipAction>(): MSApplyVerticalFlipActionAllocator<T>;
}

class MSFlippedViewAllocator<T extends MSFlippedView> extends NSViewAllocator<T> {}
declare class MSFlippedView extends NSView {
  alloc<T extends MSFlippedView>(): MSFlippedViewAllocator<T>;
}

class MSFlowBaseActionAllocator<T extends MSFlowBaseAction> extends MSDocumentActionAllocator<T> {}
declare class MSFlowBaseAction extends MSDocumentAction {
  alloc<T extends MSFlowBaseAction>(): MSFlowBaseActionAllocator<T>;
  refreshLayerListInspectorAndOverlay(): void;
}

class MSChangeFlowAnimationActionAllocator<T extends MSChangeFlowAnimationAction> extends MSDocumentActionAllocator<T> {}
declare class MSChangeFlowAnimationAction extends MSDocumentAction {
  alloc<T extends MSChangeFlowAnimationAction>(): MSChangeFlowAnimationActionAllocator<T>;
}

class MSChangeFlowAnimationNoAnimationActionAllocator<T extends MSChangeFlowAnimationNoAnimationAction> extends MSChangeFlowAnimationActionAllocator<T> {}
declare class MSChangeFlowAnimationNoAnimationAction extends MSChangeFlowAnimationAction {
  alloc<T extends MSChangeFlowAnimationNoAnimationAction>(): MSChangeFlowAnimationNoAnimationActionAllocator<T>;
  changeFlowAnimationToNoAnimation(sender: any): IBAction;
}

class MSChangeFlowAnimationFromLeftAnimationActionAllocator<T extends MSChangeFlowAnimationFromLeftAnimationAction> extends MSChangeFlowAnimationActionAllocator<T> {}
declare class MSChangeFlowAnimationFromLeftAnimationAction extends MSChangeFlowAnimationAction {
  alloc<T extends MSChangeFlowAnimationFromLeftAnimationAction>(): MSChangeFlowAnimationFromLeftAnimationActionAllocator<T>;
  changeFlowAnimationToFromLeftAnimation(sender: any): IBAction;
}

class MSChangeFlowAnimationFromRightAnimationActionAllocator<T extends MSChangeFlowAnimationFromRightAnimationAction> extends MSChangeFlowAnimationActionAllocator<T> {}
declare class MSChangeFlowAnimationFromRightAnimationAction extends MSChangeFlowAnimationAction {
  alloc<T extends MSChangeFlowAnimationFromRightAnimationAction>(): MSChangeFlowAnimationFromRightAnimationActionAllocator<T>;
  changeFlowAnimationToFromRightAnimation(sender: any): IBAction;
}

class MSChangeFlowAnimationFromTopAnimationActionAllocator<T extends MSChangeFlowAnimationFromTopAnimationAction> extends MSChangeFlowAnimationActionAllocator<T> {}
declare class MSChangeFlowAnimationFromTopAnimationAction extends MSChangeFlowAnimationAction {
  alloc<T extends MSChangeFlowAnimationFromTopAnimationAction>(): MSChangeFlowAnimationFromTopAnimationActionAllocator<T>;
  changeFlowAnimationToFromTopAnimation(sender: any): IBAction;
}

class MSChangeFlowAnimationFromBottomAnimationActionAllocator<T extends MSChangeFlowAnimationFromBottomAnimationAction> extends MSChangeFlowAnimationActionAllocator<T> {}
declare class MSChangeFlowAnimationFromBottomAnimationAction extends MSChangeFlowAnimationAction {
  alloc<T extends MSChangeFlowAnimationFromBottomAnimationAction>(): MSChangeFlowAnimationFromBottomAnimationActionAllocator<T>;
  changeFlowAnimationToFromBottomAnimation(sender: any): IBAction;
}

class MSFlowEventHandlerAllocator<T extends MSFlowEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSFlowEventHandler extends MSEventHandler implements IMSFlowMenuBuilderTarget {
  alloc<T extends MSFlowEventHandler>(): MSFlowEventHandlerAllocator<T>;
  findMouseAndDisconnectFromTarget(): void;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;

  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
}

class MSFlowFixLayerInspectorItemAllocator<T extends MSFlowFixLayerInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSFlowFixLayerInspectorItem extends MSInspectorItem {
  alloc<T extends MSFlowFixLayerInspectorItem>(): MSFlowFixLayerInspectorItemAllocator<T>;
}

class MSFlowHeaderInspectorItemAllocator<T extends MSFlowHeaderInspectorItem> extends MSCollapsibleHeaderInspectorItemAllocator<T> {}
declare class MSFlowHeaderInspectorItem extends MSCollapsibleHeaderInspectorItem {
  alloc<T extends MSFlowHeaderInspectorItem>(): MSFlowHeaderInspectorItemAllocator<T>;
}

class MSFlowInspectorItemAllocator<T extends MSFlowInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSFlowInspectorItem extends MSInspectorItem {
  alloc<T extends MSFlowInspectorItem>(): MSFlowInspectorItemAllocator<T>;
}

class MSFlowInspectorSectionAllocator<T extends MSFlowInspectorSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSFlowInspectorSection extends MSBaseInspectorSection {
  alloc<T extends MSFlowInspectorSection>(): MSFlowInspectorSectionAllocator<T>;
}

class MSFlowMenuBuilderAllocator<T extends MSFlowMenuBuilder> extends NSObjectAllocator<T> {}
declare class MSFlowMenuBuilder extends NSObject {
  alloc<T extends MSFlowMenuBuilder>(): MSFlowMenuBuilderAllocator<T>;
  static createFlowDestinationMenuButton_document_destination_target(button: NSPopUpButton, doc: MSDocumentData, destinationID: NSString | string, target: any): void;
  static menuForPages_target(pages: NSArray<any> | any[], target: any): NSMenu;
}

declare interface IMSFlowMenuBuilderTarget {
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
}

class MSFollowFlowActionAllocator<T extends MSFollowFlowAction> extends MSFlowBaseActionAllocator<T> {}
declare class MSFollowFlowAction extends MSFlowBaseAction {
  alloc<T extends MSFollowFlowAction>(): MSFollowFlowActionAllocator<T>;
  followFlow(sender: any): IBAction;
}

class MSFontFamilyPickerViewControllerAllocator<T extends MSFontFamilyPickerViewController> extends NSViewControllerAllocator<T> {}
declare class MSFontFamilyPickerViewController extends NSViewController implements INSTableViewDelegate, INSTableViewDataSource {
  alloc<T extends MSFontFamilyPickerViewController>(): MSFontFamilyPickerViewControllerAllocator<T>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;

  completionBlock(): MSFontFamilyPickerCompletionBlock;
  setCompletionBlock(completionBlock: MSFontFamilyPickerCompletionBlock): void;
  fontList(): MSFontList;
  setFontList(fontList: MSFontList): void;
  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
}

class MSFontFamilyTextFieldCellAllocator<T extends MSFontFamilyTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class MSFontFamilyTextFieldCell extends NSTextFieldCell {
  alloc<T extends MSFontFamilyTextFieldCell>(): MSFontFamilyTextFieldCellAllocator<T>;
}

class MSFontNamesTableViewAllocator<T extends MSFontNamesTableView> extends NSTableViewAllocator<T> {}
declare class MSFontNamesTableView extends NSTableView {
  alloc<T extends MSFontNamesTableView>(): MSFontNamesTableViewAllocator<T>;

  searchField(): NSSearchField;
  setSearchField(searchField: NSSearchField): void;
}

class MSUpDownComboBoxAllocator<T extends MSUpDownComboBox> extends NSComboBoxAllocator<T> {}
declare class MSUpDownComboBox extends NSComboBox {
  alloc<T extends MSUpDownComboBox>(): MSUpDownComboBoxAllocator<T>;

  refreshDelegate(): any;
  setRefreshDelegate(refreshDelegate: any): void;
  upDownController(): MSUpDownController;
  setUpDownController(upDownController: MSUpDownController): void;
}

class MSFontSizeUpDownComboBoxAllocator<T extends MSFontSizeUpDownComboBox> extends MSUpDownComboBoxAllocator<T> {}
declare class MSFontSizeUpDownComboBox extends MSUpDownComboBox {
  alloc<T extends MSFontSizeUpDownComboBox>(): MSFontSizeUpDownComboBoxAllocator<T>;
}

class MSFontWatcherAllocator<T extends MSFontWatcher> extends NSObjectAllocator<T> {
  initWithDocumentController(documentController: NSDocumentController): T;
}
declare class MSFontWatcher extends NSObject {
  alloc<T extends MSFontWatcher>(): MSFontWatcherAllocator<T>;
}

class MSFooterInspectorSectionAllocator<T extends MSFooterInspectorSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSFooterInspectorSection extends MSBaseInspectorSection {
  alloc<T extends MSFooterInspectorSection>(): MSFooterInspectorSectionAllocator<T>;
}

class MSForeignObjectProviderAllocator<T extends MSForeignObjectProvider> extends NSObjectAllocator<T> {
  initWithDocument(document: MSDocument): T;
}
declare class MSForeignObjectProvider extends NSObject implements IMSForeignObjectProvider {
  alloc<T extends MSForeignObjectProvider>(): MSForeignObjectProviderAllocator<T>;
  static providerForLayers_inDocument(layers: MSLayerArray, document: MSDocument): MSForeignObjectProvider;
  localObjectsForDocument(document: MSDocumentData): NSArray<any>;
  currentDocumentIsLibrary(library: MSAssetLibrary): boolean;
  masterObjectForInstance(instance: MSModelObject): MSShareableObject;
  masterIsOutOfSyncWithInstance(instance: MSModelObject): boolean;
  localObjectsForDocument(document: MSDocumentData): NSArray<any>;
  currentDocumentIsLibrary(library: MSAssetLibrary): boolean;
  masterObjectForInstance(instance: MSModelObject): MSShareableObject;
  masterIsOutOfSyncWithInstance(instance: MSModelObject): boolean;

  foreignObjects(): NSArray<any>;
  currentDocument(): MSDocumentData;
  libraryController(): MSAssetLibraryController;
  objectType(): MSShareableObjectType;
}

class MSForeignSymbolProviderAllocator<T extends MSForeignSymbolProvider> extends MSForeignObjectProviderAllocator<T> {}
declare class MSForeignSymbolProvider extends MSForeignObjectProvider {
  alloc<T extends MSForeignSymbolProvider>(): MSForeignSymbolProviderAllocator<T>;
}

class MSSharedLayerStyleProviderAllocator<T extends MSSharedLayerStyleProvider> extends MSForeignObjectProviderAllocator<T> {}
declare class MSSharedLayerStyleProvider extends MSForeignObjectProvider {
  alloc<T extends MSSharedLayerStyleProvider>(): MSSharedLayerStyleProviderAllocator<T>;
}

class MSSharedTextStyleProviderAllocator<T extends MSSharedTextStyleProvider> extends MSForeignObjectProviderAllocator<T> {}
declare class MSSharedTextStyleProvider extends MSForeignObjectProvider {
  alloc<T extends MSSharedTextStyleProvider>(): MSSharedTextStyleProviderAllocator<T>;
}

class MSGeneralPreferencePaneAllocator<T extends MSGeneralPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSGeneralPreferencePane extends MSPreferencePane {
  alloc<T extends MSGeneralPreferencePane>(): MSGeneralPreferencePaneAllocator<T>;
  analyticsAction(sender: any): IBAction;
  pickDefaultColorSpace(sender: any): IBAction;

  defaultColorSpaceDescriptionLabel(): NSTextField;
  setDefaultColorSpaceDescriptionLabel(defaultColorSpaceDescriptionLabel: NSTextField): void;
  defaultColorSpacePopUpButton(): NSPopUpButton;
  setDefaultColorSpacePopUpButton(defaultColorSpacePopUpButton: NSPopUpButton): void;
}

class MSGeometryInspectorSectionAllocator<T extends MSGeometryInspectorSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSGeometryInspectorSection extends MSBaseInspectorSection {
  alloc<T extends MSGeometryInspectorSection>(): MSGeometryInspectorSectionAllocator<T>;

  shouldShowPositions(): boolean;
  setShouldShowPositions(shouldShowPositions: boolean): void;
}

class MSGoogleAnalyticsWrapperAllocator<T extends MSGoogleAnalyticsWrapper> extends NSObjectAllocator<T> {}
declare class MSGoogleAnalyticsWrapper extends NSObject implements IWebFrameLoadDelegate, IWebResourceLoadDelegate, IWebUIDelegate {
  alloc<T extends MSGoogleAnalyticsWrapper>(): MSGoogleAnalyticsWrapperAllocator<T>;
  start(): void;
  stop(): void;
  sendAction_arguments(action: NSString | string, arguments: NSArray<any> | any[]): void;
}

class MSGradientBarViewAllocator<T extends MSGradientBarView> extends BCColorPickerBaseViewAllocator<T> {}
declare class MSGradientBarView extends BCColorPickerBaseView {
  alloc<T extends MSGradientBarView>(): MSGradientBarViewAllocator<T>;

  delegate(): any;
  setDelegate(delegate: any): void;
  gradient(): MSGradient;
  setGradient(gradient: MSGradient): void;
  selectedStopIndex(): NSUInteger;
  setSelectedStopIndex(selectedStopIndex: NSUInteger): void;
}

declare interface IMSGradientBarViewDelegate {
  gradientBarViewPreviewColorSpace(gradientBarView: MSGradientBarView): NSColorSpace;
  gradientBarChanged(gradientView: MSGradientBarView): void;
}

class MSGradientEventHandlerAllocator<T extends MSGradientEventHandler> extends MSPointsEventHandlerAllocator<T> {}
declare class MSGradientEventHandler extends MSPointsEventHandler implements IMSGradientPointArrayDelegate {
  alloc<T extends MSGradientEventHandler>(): MSGradientEventHandlerAllocator<T>;
  static gradientHandlerForStylePart_manager(part: MSStyleBasicFill, manager: MSEventHandlerManager): MSGradientEventHandler;
  gradient(): MSGradient;
  selectPointCursor(): NSCursor;
  insertPointCursor(): NSCursor;
  canInsertPointAtMouse(mouse: NSPoint): boolean;
  addStopAtPosition(mouse: NSPoint): NSInteger;
  repairGradientIfNecessary(): void;
  gradientPointArray_didReplacePointAtIndex_withPoint(array: MSGradientPointArray, i: NSUInteger, aPoint: NSPoint): void;
  gradientPointArray_didReplacePointAtIndex_withPoint(array: MSGradientPointArray, i: NSUInteger, aPoint: NSPoint): void;

  stylePart(): MSStyleBasicFill;
  setStylePart(stylePart: MSStyleBasicFill): void;
  gradientDelegate(): any;
  setGradientDelegate(gradientDelegate: any): void;
}

declare interface IMSGradientEventHandlerDelegate {
  gradientHandlerDidChangeCurrentPoint(handler: MSGradientEventHandler): void;
  gradientHandlerDidChangeGradient(handler: MSGradientEventHandler): void;
  gradientHandlerWillLoseFocus(handler: MSGradientEventHandler): void;
}

class MSGradientViewAllocator<T extends MSGradientView> extends NSViewAllocator<T> {}
declare class MSGradientView extends NSView {
  alloc<T extends MSGradientView>(): MSGradientViewAllocator<T>;

  topColour(): NSColor;
  setTopColour(topColour: NSColor): void;
  bottomColour(): NSColor;
  setBottomColour(bottomColour: NSColor): void;
  borderColour(): NSColor;
  setBorderColour(borderColour: NSColor): void;
  gradientAngle(): number;
  setGradientAngle(gradientAngle: number): void;
  borderSize(): number;
  setBorderSize(borderSize: number): void;
  topBorder(): boolean;
  setTopBorder(topBorder: boolean): void;
  leftBorder(): boolean;
  setLeftBorder(leftBorder: boolean): void;
  rightBorder(): boolean;
  setRightBorder(rightBorder: boolean): void;
  bottomBorder(): boolean;
  setBottomBorder(bottomBorder: boolean): void;
}

class MSGridSettingsActionAllocator<T extends MSGridSettingsAction> extends MSDocumentActionAllocator<T> {}
declare class MSGridSettingsAction extends MSDocumentAction {
  alloc<T extends MSGridSettingsAction>(): MSGridSettingsActionAllocator<T>;
  gridSettings(sender: any): IBAction;
}

class MSGridSheetAllocator<T extends MSGridSheet> extends MSGridSheetBaseAllocator<T> {}
declare class MSGridSheet extends MSGridSheetBase {
  alloc<T extends MSGridSheet>(): MSGridSheetAllocator<T>;
  setAsDefault(sender: any): IBAction;
}

class MSGridSheetBaseAllocator<T extends MSGridSheetBase> extends CHSheetControllerAllocator<T> {}
declare class MSGridSheetBase extends CHSheetController implements INSWindowDelegate {
  alloc<T extends MSGridSheetBase>(): MSGridSheetBaseAllocator<T>;
  baseObjectForRootLayer(root: any): MSBaseGrid;
  defaultObject(): MSBaseGrid;
  applyObject_toLayer(obj: MSBaseGrid, root: any): void;
  refreshView(): void;
  refreshCanvas(sender: any): IBAction;
  gridChanged(grid: any): IBAction;
  cancelAction(sender: any): IBAction;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;

  originalSettings(): NSMapTable<any, any>;
  templateObject(): MSBaseGrid;
}

class MSGroupActionAllocator<T extends MSGroupAction> extends MSDocumentActionAllocator<T> {}
declare class MSGroupAction extends MSDocumentAction {
  alloc<T extends MSGroupAction>(): MSGroupActionAllocator<T>;
  group(sender: any): IBAction;
}

class MSUngroupActionAllocator<T extends MSUngroupAction> extends MSDocumentActionAllocator<T> {}
declare class MSUngroupAction extends MSDocumentAction {
  alloc<T extends MSUngroupAction>(): MSUngroupActionAllocator<T>;
  ungroup(sender: any): IBAction;
}

class MSGroupActionGroupAllocator<T extends MSGroupActionGroup> extends MSActionGroupAllocator<T> {}
declare class MSGroupActionGroup extends MSActionGroup {
  alloc<T extends MSGroupActionGroup>(): MSGroupActionGroupAllocator<T>;
}

class MSHangingGlyphViewAllocator<T extends MSHangingGlyphView> extends NSViewAllocator<T> {}
declare class MSHangingGlyphView extends NSView {
  alloc<T extends MSHangingGlyphView>(): MSHangingGlyphViewAllocator<T>;

  textView(): NSTextView;
  setTextView(textView: NSTextView): void;
}

class MSHeader2InspectorItemAllocator<T extends MSHeader2InspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSHeader2InspectorItem extends MSInspectorItem {
  alloc<T extends MSHeader2InspectorItem>(): MSHeader2InspectorItemAllocator<T>;

  labelText(): NSString;
  setLabelText(labelText: NSString | string): void;
}

class MSHeaderInspectorItemAllocator<T extends MSHeaderInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSHeaderInspectorItem extends MSInspectorItem {
  alloc<T extends MSHeaderInspectorItem>(): MSHeaderInspectorItemAllocator<T>;
  setButtonTarget_action_image_alternate(target: any, action: string, image: NSImage, alternateImage: NSImage): void;

  labelText(): NSString;
  setLabelText(labelText: NSString | string): void;
  buttonState(): NSControlStateValue;
  setButtonState(buttonState: NSControlStateValue): void;
}

class MSHideLayerActionAllocator<T extends MSHideLayerAction> extends MSDocumentActionAllocator<T> {}
declare class MSHideLayerAction extends MSDocumentAction {
  alloc<T extends MSHideLayerAction>(): MSHideLayerActionAllocator<T>;
  hideLayer(sender: any): IBAction;
}

class MSHistoryMakerAllocator<T extends MSHistoryMaker> extends NSObjectAllocator<T> {
  initWithDocument(document: MSDocument): T;
}
declare class MSHistoryMaker extends NSObject {
  alloc<T extends MSHistoryMaker>(): MSHistoryMakerAllocator<T>;
  registerHistoryMomentTitle(title: NSString | string): void;
  canMoveThroughHistoryBackInTime(backInTime: boolean): boolean;
  moveThroughHistoryBackInTime(backwards: boolean): void;
  startCoalescingHistory(): void;
  finishCoalescingHistory(): void;
  coalesceHistoryInBlock(block: BCVoidBlock): void;
  deferMakingHistoryInBlock(block: BCVoidBlock): void;
  ignoreDocumentChangesInBlock(block: BCVoidBlock): boolean;
  makeHistoryIfNecessary(): void;
  makeTransientMomentInHistoryIfNecessary(): void;
  commitTransientMomentIfNecessary(): void;
  updateCurrentMomentWithSelection(selectedLayerIDs: NSSet<any>): void;

  document(): MSDocument;
  history(): MSHistory;
  historyMomentTitle(): NSString;
  historyIsCoalescing(): boolean;
}

class MSHotspotOverrideInspectorItemAllocator<T extends MSHotspotOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<T> {}
declare class MSHotspotOverrideInspectorItem extends MSOverrideInspectorItem implements IMSFlowMenuBuilderTarget {
  alloc<T extends MSHotspotOverrideInspectorItem>(): MSHotspotOverrideInspectorItemAllocator<T>;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
}

class MSIgnoreClippingMaskActionAllocator<T extends MSIgnoreClippingMaskAction> extends MSDocumentActionAllocator<T> {}
declare class MSIgnoreClippingMaskAction extends MSDocumentAction {
  alloc<T extends MSIgnoreClippingMaskAction>(): MSIgnoreClippingMaskActionAllocator<T>;
  ignoreClippingMask(sender: any): IBAction;
}

class MSImageOriginalSizeActionAllocator<T extends MSImageOriginalSizeAction> extends MSDocumentActionAllocator<T> {}
declare class MSImageOriginalSizeAction extends MSDocumentAction {
  alloc<T extends MSImageOriginalSizeAction>(): MSImageOriginalSizeActionAllocator<T>;
  imageOriginalSize(sender: any): IBAction;
}

class MSImageOverrideViewAllocator<T extends MSImageOverrideView> extends NSImageViewAllocator<T> {}
declare class MSImageOverrideView extends NSImageView {
  alloc<T extends MSImageOverrideView>(): MSImageOverrideViewAllocator<T>;

  normalImage(): NSImage;
  setNormalImage(normalImage: NSImage): void;
  placeholderImage(): NSImage;
  setPlaceholderImage(placeholderImage: NSImage): void;
}

class MSImageTransformEventHandlerAllocator<T extends MSImageTransformEventHandler> extends MSTransformEventHandlerAllocator<T> {}
declare class MSImageTransformEventHandler extends MSTransformEventHandler {
  alloc<T extends MSImageTransformEventHandler>(): MSImageTransformEventHandlerAllocator<T>;
}

class MSImageViewAllocator<T extends MSImageView> extends NSImageViewAllocator<T> {}
declare class MSImageView extends NSImageView {
  alloc<T extends MSImageView>(): MSImageViewAllocator<T>;
}

class MSIncludeBackgroundColorInExportInspectorItemAllocator<T extends MSIncludeBackgroundColorInExportInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSIncludeBackgroundColorInExportInspectorItem extends MSInspectorItem {
  alloc<T extends MSIncludeBackgroundColorInExportInspectorItem>(): MSIncludeBackgroundColorInExportInspectorItemAllocator<T>;
}

class MSIncludeBackgroundColorInInstancesInspectorItemAllocator<T extends MSIncludeBackgroundColorInInstancesInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSIncludeBackgroundColorInInstancesInspectorItem extends MSInspectorItem {
  alloc<T extends MSIncludeBackgroundColorInInstancesInspectorItem>(): MSIncludeBackgroundColorInInstancesInspectorItemAllocator<T>;
}

class MSIncompatiblePluginsDisabledActionAllocator<T extends MSIncompatiblePluginsDisabledAction> extends MSDocumentActionAllocator<T> {}
declare class MSIncompatiblePluginsDisabledAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSIncompatiblePluginsDisabledAction>(): MSIncompatiblePluginsDisabledActionAllocator<T>;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSInlineIntegratedStepperAllocator<T extends MSInlineIntegratedStepper> extends MSIntegratedStepperAllocator<T> {}
declare class MSInlineIntegratedStepper extends MSIntegratedStepper {
  alloc<T extends MSInlineIntegratedStepper>(): MSInlineIntegratedStepperAllocator<T>;
}

class MSInlineTextLabelForUpDownFieldAllocator<T extends MSInlineTextLabelForUpDownField> extends MSTextLabelForUpDownFieldAllocator<T> {}
declare class MSInlineTextLabelForUpDownField extends MSTextLabelForUpDownField {
  alloc<T extends MSInlineTextLabelForUpDownField>(): MSInlineTextLabelForUpDownFieldAllocator<T>;
  static labelWithImage(image: NSImage): MSInlineTextLabelForUpDownField;
}

class MSInlineTextLabelImageCellAllocator<T extends MSInlineTextLabelImageCell> extends NSTextFieldCellAllocator<T> {}
declare class MSInlineTextLabelImageCell extends NSTextFieldCell {
  alloc<T extends MSInlineTextLabelImageCell>(): MSInlineTextLabelImageCellAllocator<T>;
  static inlineTextLabelFont(): NSFont;
}

class MSInlineUpDownControllerAllocator<T extends MSInlineUpDownController> extends MSUpDownControllerAllocator<T> {}
declare class MSInlineUpDownController extends MSUpDownController {
  alloc<T extends MSInlineUpDownController>(): MSInlineUpDownControllerAllocator<T>;
}

class MSInlineUpDownTextFieldAllocator<T extends MSInlineUpDownTextField> extends MSUpDownTextFieldAllocator<T> {}
declare class MSInlineUpDownTextField extends MSUpDownTextField {
  alloc<T extends MSInlineUpDownTextField>(): MSInlineUpDownTextFieldAllocator<T>;

  inlineLabel(): NSString;
  setInlineLabel(inlineLabel: NSString | string): void;
  inlineImage(): NSImage;
  setInlineImage(inlineImage: NSImage): void;
  inlineFieldWidth(): CGFloat;
  inlineLabelField(): NSTextField;
}

class MSInlineUpDownMiniTextFieldAllocator<T extends MSInlineUpDownMiniTextField> extends MSInlineUpDownTextFieldAllocator<T> {}
declare class MSInlineUpDownMiniTextField extends MSInlineUpDownTextField {
  alloc<T extends MSInlineUpDownMiniTextField>(): MSInlineUpDownMiniTextFieldAllocator<T>;
}

class MSInlineUpDownNanoTextFieldAllocator<T extends MSInlineUpDownNanoTextField> extends MSInlineUpDownTextFieldAllocator<T> {}
declare class MSInlineUpDownNanoTextField extends MSInlineUpDownTextField {
  alloc<T extends MSInlineUpDownNanoTextField>(): MSInlineUpDownNanoTextFieldAllocator<T>;
}

class MSInlineUpDownTextFieldCellAllocator<T extends MSInlineUpDownTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class MSInlineUpDownTextFieldCell extends NSTextFieldCell {
  alloc<T extends MSInlineUpDownTextFieldCell>(): MSInlineUpDownTextFieldCellAllocator<T>;
}

class MSInsertArrowActionAllocator<T extends MSInsertArrowAction> extends MSInsertLineActionAllocator<T> {}
declare class MSInsertArrowAction extends MSInsertLineAction {
  alloc<T extends MSInsertArrowAction>(): MSInsertArrowActionAllocator<T>;
}

class MSInsertArtboardActionAllocator<T extends MSInsertArtboardAction> extends MSBaseInsertActionAllocator<T> {}
declare class MSInsertArtboardAction extends MSBaseInsertAction {
  alloc<T extends MSInsertArtboardAction>(): MSInsertArtboardActionAllocator<T>;
  insertArtboard(sender: any): IBAction;
}

class MSInsertArtboardEventHandlerAllocator<T extends MSInsertArtboardEventHandler> extends MSInsertLayerEventHandlerAllocator<T> {}
declare class MSInsertArtboardEventHandler extends MSInsertLayerEventHandler {
  alloc<T extends MSInsertArtboardEventHandler>(): MSInsertArtboardEventHandlerAllocator<T>;
  insertArtboardFromPreset(preset: MSArtboardPreset): void;
}

class MSInsertArtboardInspectorViewControllerAllocator<T extends MSInsertArtboardInspectorViewController> extends NSViewControllerAllocator<T> {}
declare class MSInsertArtboardInspectorViewController extends NSViewController implements IMSInspectorChildController {
  alloc<T extends MSInsertArtboardInspectorViewController>(): MSInsertArtboardInspectorViewControllerAllocator<T>;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;

  shouldAddInsertFromSelectionItem(): boolean;
  setShouldAddInsertFromSelectionItem(shouldAddInsertFromSelectionItem: boolean): void;
  proposedArtboardSize(): NSSize;
  setProposedArtboardSize(proposedArtboardSize: NSSize): void;
  eventHandler(): MSInsertArtboardEventHandler;
  setEventHandler(eventHandler: MSInsertArtboardEventHandler): void;
}

class MSInsertHotspotActionAllocator<T extends MSInsertHotspotAction> extends MSDocumentActionAllocator<T> {}
declare class MSInsertHotspotAction extends MSDocumentAction {
  alloc<T extends MSInsertHotspotAction>(): MSInsertHotspotActionAllocator<T>;
  insertHotspot(sender: any): IBAction;
}

class MSInsertHotspotEventHandlerAllocator<T extends MSInsertHotspotEventHandler> extends MSInsertLayerEventHandlerAllocator<T> {}
declare class MSInsertHotspotEventHandler extends MSInsertLayerEventHandler {
  alloc<T extends MSInsertHotspotEventHandler>(): MSInsertHotspotEventHandlerAllocator<T>;
}

class MSInsertLayerEventHandlerAllocator<T extends MSInsertLayerEventHandler> extends MSDragRectEventHandlerAllocator<T> {}
declare class MSInsertLayerEventHandler extends MSDragRectEventHandler {
  alloc<T extends MSInsertLayerEventHandler>(): MSInsertLayerEventHandlerAllocator<T>;

  prototypeLayer(): MSLayer;
  setPrototypeLayer(prototypeLayer: MSLayer): void;
  insertedLayer(): MSLayer;
  setInsertedLayer(insertedLayer: MSLayer): void;
}

class MSInsertLineActionAllocator<T extends MSInsertLineAction> extends MSBaseInsertActionAllocator<T> {}
declare class MSInsertLineAction extends MSBaseInsertAction {
  alloc<T extends MSInsertLineAction>(): MSInsertLineActionAllocator<T>;
  lineShapeFrom_to(from: NSPoint, to: NSPoint): MSShapePathLayer;
  eventHandlerClass(): any;
}

class MSInsertLineEventHandlerAllocator<T extends MSInsertLineEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSInsertLineEventHandler extends MSEventHandler {
  alloc<T extends MSInsertLineEventHandler>(): MSInsertLineEventHandlerAllocator<T>;

  lineShapeCreator(): MSLineShapeCreatorBlock;
  setLineShapeCreator(lineShapeCreator: MSLineShapeCreatorBlock): void;
}

class MSInsertArrowEventHandlerAllocator<T extends MSInsertArrowEventHandler> extends MSInsertLineEventHandlerAllocator<T> {}
declare class MSInsertArrowEventHandler extends MSInsertLineEventHandler {
  alloc<T extends MSInsertArrowEventHandler>(): MSInsertArrowEventHandlerAllocator<T>;
}

class MSInsertSharedTextActionAllocator<T extends MSInsertSharedTextAction> extends MSSharedObjectActionAllocator<T> {}
declare class MSInsertSharedTextAction extends MSSharedObjectAction implements INSMenuDelegate {
  alloc<T extends MSInsertSharedTextAction>(): MSInsertSharedTextActionAllocator<T>;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

class MSInsertSliceActionAllocator<T extends MSInsertSliceAction> extends MSDocumentActionAllocator<T> {}
declare class MSInsertSliceAction extends MSDocumentAction {
  alloc<T extends MSInsertSliceAction>(): MSInsertSliceActionAllocator<T>;
  insertSlice(sender: any): IBAction;
}

class MSInsertSliceEventHandlerAllocator<T extends MSInsertSliceEventHandler> extends MSInsertLayerEventHandlerAllocator<T> {}
declare class MSInsertSliceEventHandler extends MSInsertLayerEventHandler {
  alloc<T extends MSInsertSliceEventHandler>(): MSInsertSliceEventHandlerAllocator<T>;

  allSlices(): NSArray<any>;
  setAllSlices(allSlices: NSArray<any> | any[]): void;
}

class MSInsertSymbolActionAllocator<T extends MSInsertSymbolAction> extends MSSharedSymbolActionAllocator<T> {}
declare class MSInsertSymbolAction extends MSSharedSymbolAction {
  alloc<T extends MSInsertSymbolAction>(): MSInsertSymbolActionAllocator<T>;
}

class MSInsertSymbolEventHandlerAllocator<T extends MSInsertSymbolEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSInsertSymbolEventHandler extends MSEventHandler {
  alloc<T extends MSInsertSymbolEventHandler>(): MSInsertSymbolEventHandlerAllocator<T>;

  symbolReference(): MSSymbolMasterReference;
  setSymbolReference(symbolReference: MSSymbolMasterReference): void;
}

class MSInsertTextEventHandlerAllocator<T extends MSInsertTextEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSInsertTextEventHandler extends MSEventHandler {
  alloc<T extends MSInsertTextEventHandler>(): MSInsertTextEventHandlerAllocator<T>;

  textLayer(): MSTextLayer;
  setTextLayer(textLayer: MSTextLayer): void;
  completionBlock(): MSInsertTextEventHandlerCompletionBlock;
  setCompletionBlock(completionBlock: MSInsertTextEventHandlerCompletionBlock): void;
}

class MSInsertTextLayerActionAllocator<T extends MSInsertTextLayerAction> extends MSBaseInsertActionAllocator<T> {}
declare class MSInsertTextLayerAction extends MSBaseInsertAction {
  alloc<T extends MSInsertTextLayerAction>(): MSInsertTextLayerActionAllocator<T>;
  insertTextLayer(sender: any): IBAction;
}

class MSInsertVectorActionAllocator<T extends MSInsertVectorAction> extends MSDocumentActionAllocator<T> {}
declare class MSInsertVectorAction extends MSDocumentAction {
  alloc<T extends MSInsertVectorAction>(): MSInsertVectorActionAllocator<T>;
  insertVector(sender: any): IBAction;
}

class MSInspectorAltButtonCellAllocator<T extends MSInspectorAltButtonCell> extends MSAltButtonCellAllocator<T> {}
declare class MSInspectorAltButtonCell extends MSAltButtonCell {
  alloc<T extends MSInspectorAltButtonCell>(): MSInspectorAltButtonCellAllocator<T>;
}

class MSInspectorBackgroundViewAllocator<T extends MSInspectorBackgroundView> extends MSBackgroundColorViewAllocator<T> {}
declare class MSInspectorBackgroundView extends MSBackgroundColorView {
  alloc<T extends MSInspectorBackgroundView>(): MSInspectorBackgroundViewAllocator<T>;
}

class MSInspectorButtonCellAllocator<T extends MSInspectorButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSInspectorButtonCell extends NSButtonCell {
  alloc<T extends MSInspectorButtonCell>(): MSInspectorButtonCellAllocator<T>;
}

class MSInspectorPushButtonCellAllocator<T extends MSInspectorPushButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSInspectorPushButtonCell extends NSButtonCell {
  alloc<T extends MSInspectorPushButtonCell>(): MSInspectorPushButtonCellAllocator<T>;
}

class MSInspectorCheckmarkCellAllocator<T extends MSInspectorCheckmarkCell> extends MSInspectorButtonCellAllocator<T> {}
declare class MSInspectorCheckmarkCell extends MSInspectorButtonCell {
  alloc<T extends MSInspectorCheckmarkCell>(): MSInspectorCheckmarkCellAllocator<T>;
}

class MSInspectorToggleButtonCellAllocator<T extends MSInspectorToggleButtonCell> extends MSInspectorButtonCellAllocator<T> {}
declare class MSInspectorToggleButtonCell extends MSInspectorButtonCell {
  alloc<T extends MSInspectorToggleButtonCell>(): MSInspectorToggleButtonCellAllocator<T>;
}

class MSInspectorSectionHeaderButtonCellAllocator<T extends MSInspectorSectionHeaderButtonCell> extends MSInspectorToggleButtonCellAllocator<T> {}
declare class MSInspectorSectionHeaderButtonCell extends MSInspectorToggleButtonCell {
  alloc<T extends MSInspectorSectionHeaderButtonCell>(): MSInspectorSectionHeaderButtonCellAllocator<T>;
}

class MSInspectorToggleImageButtonCellAllocator<T extends MSInspectorToggleImageButtonCell> extends MSInspectorButtonCellAllocator<T> {}
declare class MSInspectorToggleImageButtonCell extends MSInspectorButtonCell {
  alloc<T extends MSInspectorToggleImageButtonCell>(): MSInspectorToggleImageButtonCellAllocator<T>;
}

class MSInspectorSectionHeaderToggleImageButtonCellAllocator<T extends MSInspectorSectionHeaderToggleImageButtonCell> extends MSInspectorToggleImageButtonCellAllocator<T> {}
declare class MSInspectorSectionHeaderToggleImageButtonCell extends MSInspectorToggleImageButtonCell {
  alloc<T extends MSInspectorSectionHeaderToggleImageButtonCell>(): MSInspectorSectionHeaderToggleImageButtonCellAllocator<T>;
}

class MSInspectorButtonAllocator<T extends MSInspectorButton> extends NSButtonAllocator<T> {}
declare class MSInspectorButton extends NSButton {
  alloc<T extends MSInspectorButton>(): MSInspectorButtonAllocator<T>;
}

declare interface IMSInspectorChildController {
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
}

class MSInspectorControlViewAllocator<T extends MSInspectorControlView> extends NSViewAllocator<T> {}
declare class MSInspectorControlView extends NSView {
  alloc<T extends MSInspectorControlView>(): MSInspectorControlViewAllocator<T>;
}

class MSInspectorControllerAllocator<T extends MSInspectorController> extends NSViewControllerAllocator<T> {}
declare class MSInspectorController extends NSViewController implements INSTouchBarDelegate {
  alloc<T extends MSInspectorController>(): MSInspectorControllerAllocator<T>;
  selectionDidChangeTo(layers: MSLayerArray): void;
  changeColor(sender: any): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  currentHandlerChanged(): void;
  handlerManager(): MSEventHandlerManager;
  changeTextLayerFont(sender: any): IBAction;
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
  reloadSharedObjectsSection(): void;
  validateAlignmentButtons(): void;
  reload(): void;
  focusOnFirstTextField(): void;
  focusOnTextFieldWithIdentifier(identifier: NSUserInterfaceItemIdentifier): void;
  showFillOptionsAction(sender: any): IBAction;
  showBorderOptionsAction(sender: any): IBAction;
  openPopoverForStylePart_atIndex(stylePart: MSStylePartType, index: NSUInteger): void;
  adjustInspectorToColorPopover_sender(popover: BCPopover, sender: any): void;
  closeAnyColorPopover(): void;
  reloadTouchBars(): void;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  currentController(): NSViewController;
  setCurrentController(currentController: NSViewController): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  globalAssets(): MSPersistentAssetCollection;
  setGlobalAssets(globalAssets: MSPersistentAssetCollection): void;
  alignmentBarHidden(): boolean;
  setAlignmentBarHidden(alignmentBarHidden: boolean): void;
  sharedStyleInspectorVisible(): boolean;
}

class MSInspectorFlowHandlerAllocator<T extends MSInspectorFlowHandler> extends NSObjectAllocator<T> {}
declare class MSInspectorFlowHandler extends NSObject implements IMSFlowMenuBuilderTarget {
  alloc<T extends MSInspectorFlowHandler>(): MSInspectorFlowHandlerAllocator<T>;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
  flowConnection(): MSFlowConnection;
  static flowConnectionForLayers(layers: MSLayerArray): MSFlowConnection;
  enumerateLayersAndReload(block: Block): void;
  static shouldShowFullInspectorForFlow(flow: MSFlowConnection): boolean;
  static shouldShowFullInspectorForLayers(layers: MSLayerArray): boolean;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;
  flowBackAction(sender: any): IBAction;
  removeFlowAction(sender: any): IBAction;
  flowTargetAction(sender: any): IBAction;

  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSInspectorFlowHandlerDelegate {
  documentForFlowHandler(flowHandler: MSInspectorFlowHandler): MSDocument;
  layersForFlowHandler(flowHandler: MSInspectorFlowHandler): MSLayerArray;
}

declare interface IMSInspectorItemDelegate {
  valuesPossiblyChanged(item: NSViewController): void;
  itemDidResize(item: NSViewController): void;
  documentForInspectorItem(section: NSViewController): MSDocument;
  item_wantsSectionToCollapse(item: NSViewController, collapse: boolean): void;
}

class MSInspectorLeftAlignedPopUpAllocator<T extends MSInspectorLeftAlignedPopUp> extends NSPopUpButtonAllocator<T> {}
declare class MSInspectorLeftAlignedPopUp extends NSPopUpButton {
  alloc<T extends MSInspectorLeftAlignedPopUp>(): MSInspectorLeftAlignedPopUpAllocator<T>;
}

class MSInspectorNextResponderFixerAllocator<T extends MSInspectorNextResponderFixer> extends NSObjectAllocator<T> {}
declare class MSInspectorNextResponderFixer extends NSObject {
  alloc<T extends MSInspectorNextResponderFixer>(): MSInspectorNextResponderFixerAllocator<T>;
  static findNextKeyViewFor_inView(keyView: NSView, view: NSView): NSView;
  static firstKeyViewForInView(view: NSView): NSView;
}

class MSInspectorPopUpButtonCellAllocator<T extends MSInspectorPopUpButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSInspectorPopUpButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSInspectorPopUpButtonCell>(): MSInspectorPopUpButtonCellAllocator<T>;
}

class MSInspectorPopUpButtonAllocator<T extends MSInspectorPopUpButton> extends NSPopUpButtonAllocator<T> {}
declare class MSInspectorPopUpButton extends NSPopUpButton {
  alloc<T extends MSInspectorPopUpButton>(): MSInspectorPopUpButtonAllocator<T>;
}

declare interface IMSInspectorSectionDelegate {
  sectionDidResize(section: NSViewController): void;
  documentForInspectorSection(section: NSViewController): MSDocument;
  isSectionCollapsed(section: NSViewController): boolean;
  setSection_collapsed(section: NSViewController, collapsed: boolean): void;
}

class MSInspectorSectionHeaderLabelAllocator<T extends MSInspectorSectionHeaderLabel> extends NSTextFieldAllocator<T> {}
declare class MSInspectorSectionHeaderLabel extends NSTextField {
  alloc<T extends MSInspectorSectionHeaderLabel>(): MSInspectorSectionHeaderLabelAllocator<T>;
}

class MSInspectorSectionHeaderLabelCellAllocator<T extends MSInspectorSectionHeaderLabelCell> extends NSTextFieldCellAllocator<T> {}
declare class MSInspectorSectionHeaderLabelCell extends NSTextFieldCell {
  alloc<T extends MSInspectorSectionHeaderLabelCell>(): MSInspectorSectionHeaderLabelCellAllocator<T>;
}

class MSInspectorSegmentedCellAllocator<T extends MSInspectorSegmentedCell> extends NSSegmentedCellAllocator<T> {}
declare class MSInspectorSegmentedCell extends NSSegmentedCell {
  alloc<T extends MSInspectorSegmentedCell>(): MSInspectorSegmentedCellAllocator<T>;
  setAlternateImage_forSegment(image: NSImage, segment: NSUInteger): void;
}

class MSInspectorSliderCellAllocator<T extends MSInspectorSliderCell> extends NSSliderCellAllocator<T> {}
declare class MSInspectorSliderCell extends NSSliderCell {
  alloc<T extends MSInspectorSliderCell>(): MSInspectorSliderCellAllocator<T>;
}

class MSInspectorStackViewAllocator<T extends MSInspectorStackView> extends NSViewAllocator<T> {}
declare class MSInspectorStackView extends NSView {
  alloc<T extends MSInspectorStackView>(): MSInspectorStackViewAllocator<T>;
  reloadWithViewControllers(controllers: NSArray<any> | any[]): void;
  reloadSubviews(): void;
  recalculateHeight(): void;
  stack(): void;
  subViewFrameDidChange(subview: NSView): void;

  sectionViewControllers(): NSArray<any>;
}

class MSInspectorTextfieldManagerAllocator<T extends MSInspectorTextfieldManager> extends NSObjectAllocator<T> {}
declare class MSInspectorTextfieldManager extends NSObject {
  alloc<T extends MSInspectorTextfieldManager>(): MSInspectorTextfieldManagerAllocator<T>;
  static managerWithItem_textField_adaptor_identifier_toolTip_touchBarItems(item: MSInspectorItem, textField: MSUpDownTextField, adaptor: MSMathInspectorValueAdaptor, identifier: NSUserInterfaceItemIdentifier, toolTip: NSString | string, touchBarItems: NSArray<any> | any[] | null): MSInspectorTextfieldManager;
}

class MSInstanceOverridesHeaderItemAllocator<T extends MSInstanceOverridesHeaderItem> extends MSInspectorItemAllocator<T> {}
declare class MSInstanceOverridesHeaderItem extends MSInspectorItem {
  alloc<T extends MSInstanceOverridesHeaderItem>(): MSInstanceOverridesHeaderItemAllocator<T>;
}

class MSInstanceStylesHeaderItemAllocator<T extends MSInstanceStylesHeaderItem> extends MSInspectorItemAllocator<T> {}
declare class MSInstanceStylesHeaderItem extends MSInspectorItem {
  alloc<T extends MSInstanceStylesHeaderItem>(): MSInstanceStylesHeaderItemAllocator<T>;
}

class MSIntegerSliderAllocator<T extends MSIntegerSlider> extends NSSliderAllocator<T> {}
declare class MSIntegerSlider extends NSSlider {
  alloc<T extends MSIntegerSlider>(): MSIntegerSliderAllocator<T>;
}

class MSIntegratedStepperAllocator<T extends MSIntegratedStepper> extends NSViewAllocator<T> {}
declare class MSIntegratedStepper extends NSView {
  alloc<T extends MSIntegratedStepper>(): MSIntegratedStepperAllocator<T>;

  target(): MSUpDownController;
  setTarget(target: MSUpDownController): void;
  highlightMode(): MSIntegratedStepperHighlight;
}

declare enum MSIntegratedStepperHighlight {
  MSIntegratedStepperHighlightNone,
  MSIntegratedStepperHighlightUp,
  MSIntegratedStepperHighlightDown,
}

class MSInterceptingViewAllocator<T extends MSInterceptingView> extends NSViewAllocator<T> {}
declare class MSInterceptingView extends NSView {
  alloc<T extends MSInterceptingView>(): MSInterceptingViewAllocator<T>;
}

class MSJoinActionAllocator<T extends MSJoinAction> extends MSDocumentActionAllocator<T> {}
declare class MSJoinAction extends MSDocumentAction {
  alloc<T extends MSJoinAction>(): MSJoinActionAllocator<T>;
}

class MSKeyBindingsAllocator<T extends MSKeyBindings> extends BCSingletonAllocator<T> {}
declare class MSKeyBindings extends BCSingleton {
  alloc<T extends MSKeyBindings>(): MSKeyBindingsAllocator<T>;

  shortcutMap(): NSDictionary<any, any>;
}

class MSLayerAdjustedPopupButtonCellAllocator<T extends MSLayerAdjustedPopupButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSLayerAdjustedPopupButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSLayerAdjustedPopupButtonCell>(): MSLayerAdjustedPopupButtonCellAllocator<T>;
}

class MSLayerFontManagerAllocator<T extends MSLayerFontManager> extends NSObjectAllocator<T> {
  initWithCoder(aDecoder: NSCoder): T;
}
declare class MSLayerFontManager extends NSObject implements INSCoding {
  alloc<T extends MSLayerFontManager>(): MSLayerFontManagerAllocator<T>;
  static loadFonts(): void;
  availableFonts(): NSArray<any>;
  currentFontVariations(): NSArray<any>;
  currentFont(): NSString;
  setCurrentFont(aValue: NSString | string): void;
  setLayer(aValue: any): void;
  currentFontFaceIndex(): number;
  setCurrentFontFaceIndex(aValue: number): void;
  bold(): boolean;
  setBold(aValue: boolean): void;
  italic(): boolean;
  setItalic(aValue: boolean): void;
  underline(): boolean;
  setUnderline(aValue: boolean): void;
  fontSize(): number;
  setFontSize(aValue: number): void;
  textColor(): NSColor;
  setTextColor(aValue: NSColor): void;
  encodeWithCoder(aCoder: NSCoder): void;
  encodeWithCoder(aCoder: NSCoder): void;
}

class MSLayerGroupItemAllocator<T extends MSLayerGroupItem> extends MSInspectorItemAllocator<T> {}
declare class MSLayerGroupItem extends MSInspectorItem {
  alloc<T extends MSLayerGroupItem>(): MSLayerGroupItemAllocator<T>;
}

class MSLayerInsertingAllocator<T extends MSLayerInserting> extends NSObjectAllocator<T> {}
declare class MSLayerInserting extends NSObject {
  alloc<T extends MSLayerInserting>(): MSLayerInsertingAllocator<T>;
  static rectForCenteringLayerWithSize_inView_selection(layerSize: NSSize, contentDrawView: MSContentDrawView, layers: MSLayerArray): NSRect;
}

class MSLayerMeasurementRendererAllocator<T extends MSLayerMeasurementRenderer> extends MSOverlayRendererAllocator<T> {}
declare class MSLayerMeasurementRenderer extends MSOverlayRenderer {
  alloc<T extends MSLayerMeasurementRenderer>(): MSLayerMeasurementRendererAllocator<T>;
  clear(): void;
  prepareForGeometryChange(): void;
  drawRect_context(dirtyRect: NSRect, context: MSRenderingContext): void;
  isMeasuringDistance(): boolean;

  selectedLayers(): MSLayerArray;
  setSelectedLayers(selectedLayers: MSLayerArray): void;
  measurementTarget(): MSLayerMeasurementTarget;
  setMeasurementTarget(measurementTarget: MSLayerMeasurementTarget): void;
  measurementOptions(): MSAlignmentRectOptions;
  setMeasurementOptions(measurementOptions: MSAlignmentRectOptions): void;
  numberFormatter(): NSNumberFormatter;
  setNumberFormatter(numberFormatter: NSNumberFormatter): void;
}

class MSLayerMeasurementTargetAllocator<T extends MSLayerMeasurementTarget> extends NSObjectAllocator<T> {
  initWithLayer_guides(targetLayer: MSLayer | null, targetGuides: NSArray<any> | any[] | null): T;
}
declare class MSLayerMeasurementTarget extends NSObject {
  alloc<T extends MSLayerMeasurementTarget>(): MSLayerMeasurementTargetAllocator<T>;

  layer(): MSLayer;
  guideLines(): NSArray<any>;
}

class MSLayerPickerMenuBuilderAllocator<T extends MSLayerPickerMenuBuilder> extends MSMenuBuilderAllocator<T> {}
declare class MSLayerPickerMenuBuilder extends MSMenuBuilder {
  alloc<T extends MSLayerPickerMenuBuilder>(): MSLayerPickerMenuBuilderAllocator<T>;
  updatePickerMenuItem_forPage_atPoint(item: NSMenuItem, page: MSPage, mouse: NSPoint): void;
}

class MSLayerFocusActionsAllocator<T extends MSLayerFocusActions> extends MSActionGroupAllocator<T> {}
declare class MSLayerFocusActions extends MSActionGroup {
  alloc<T extends MSLayerFocusActions>(): MSLayerFocusActionsAllocator<T>;
}

class MSLayerXFocusActionAllocator<T extends MSLayerXFocusAction> extends MSDocumentActionAllocator<T> {}
declare class MSLayerXFocusAction extends MSDocumentAction {
  alloc<T extends MSLayerXFocusAction>(): MSLayerXFocusActionAllocator<T>;
}

class MSLayerYFocusActionAllocator<T extends MSLayerYFocusAction> extends MSDocumentActionAllocator<T> {}
declare class MSLayerYFocusAction extends MSDocumentAction {
  alloc<T extends MSLayerYFocusAction>(): MSLayerYFocusActionAllocator<T>;
}

class MSLayerWidthFocusActionAllocator<T extends MSLayerWidthFocusAction> extends MSDocumentActionAllocator<T> {}
declare class MSLayerWidthFocusAction extends MSDocumentAction {
  alloc<T extends MSLayerWidthFocusAction>(): MSLayerWidthFocusActionAllocator<T>;
}

class MSLayerHeightFocusActionAllocator<T extends MSLayerHeightFocusAction> extends MSDocumentActionAllocator<T> {}
declare class MSLayerHeightFocusAction extends MSDocumentAction {
  alloc<T extends MSLayerHeightFocusAction>(): MSLayerHeightFocusActionAllocator<T>;
}

class MSLayerSelectionDrawingAllocator<T extends MSLayerSelectionDrawing> extends NSObjectAllocator<T> {}
declare class MSLayerSelectionDrawing extends NSObject {
  alloc<T extends MSLayerSelectionDrawing>(): MSLayerSelectionDrawingAllocator<T>;
  static drawSelectionForLayer_zoomValue(aLayer: MSLayer, zoom: CGFloat): void;
  static strokeWidthForZoomValue(zoom: CGFloat): CGFloat;
}

class MSLayersPreferencePaneAllocator<T extends MSLayersPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSLayersPreferencePane extends MSPreferencePane {
  alloc<T extends MSLayersPreferencePane>(): MSLayersPreferencePaneAllocator<T>;
}

class MSLayoutSettingsActionAllocator<T extends MSLayoutSettingsAction> extends MSDocumentActionAllocator<T> {}
declare class MSLayoutSettingsAction extends MSDocumentAction {
  alloc<T extends MSLayoutSettingsAction>(): MSLayoutSettingsActionAllocator<T>;
  layoutSettings(sender: any): IBAction;
}

class MSLayoutSheetAllocator<T extends MSLayoutSheet> extends MSGridSheetBaseAllocator<T> {}
declare class MSLayoutSheet extends MSGridSheetBase {
  alloc<T extends MSLayoutSheet>(): MSLayoutSheetAllocator<T>;
  setAsDefault(sender: any): IBAction;
  centerGrid(sender: any): IBAction;
  offsetChanged(sender: any): IBAction;

  centerGridButton(): NSButton;
  setCenterGridButton(centerGridButton: NSButton): void;
}

class MSLicenseRegistrationWindowControllerAllocator<T extends MSLicenseRegistrationWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSLicenseRegistrationWindowController extends NSWindowController implements INSWindowDelegate {
  alloc<T extends MSLicenseRegistrationWindowController>(): MSLicenseRegistrationWindowControllerAllocator<T>;
  static showTrialExpiredModal(): void;
  static showRegistrationWindow(): void;
  static registerWithKey(key: NSString | string): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
}

class MSLicenseRenewalWindowControllerAllocator<T extends MSLicenseRenewalWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSLicenseRenewalWindowController extends NSWindowController implements INSWindowDelegate {
  alloc<T extends MSLicenseRenewalWindowController>(): MSLicenseRenewalWindowControllerAllocator<T>;
  static showLicenseUpdateWindow(): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
}

class MSLineEndpointInspectorItemAllocator<T extends MSLineEndpointInspectorItem> extends MSTwoTextFieldInspectorItemAllocator<T> {}
declare class MSLineEndpointInspectorItem extends MSTwoTextFieldInspectorItem {
  alloc<T extends MSLineEndpointInspectorItem>(): MSLineEndpointInspectorItemAllocator<T>;
}

class MSLineEndpointInspectorItem1Allocator<T extends MSLineEndpointInspectorItem1> extends MSLineEndpointInspectorItemAllocator<T> {}
declare class MSLineEndpointInspectorItem1 extends MSLineEndpointInspectorItem {
  alloc<T extends MSLineEndpointInspectorItem1>(): MSLineEndpointInspectorItem1Allocator<T>;
}

class MSLineEndpointInspectorItem2Allocator<T extends MSLineEndpointInspectorItem2> extends MSLineEndpointInspectorItemAllocator<T> {}
declare class MSLineEndpointInspectorItem2 extends MSLineEndpointInspectorItem {
  alloc<T extends MSLineEndpointInspectorItem2>(): MSLineEndpointInspectorItem2Allocator<T>;
}

class MSLineTransformInspectorItemAllocator<T extends MSLineTransformInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSLineTransformInspectorItem extends MSInspectorItem {
  alloc<T extends MSLineTransformInspectorItem>(): MSLineTransformInspectorItemAllocator<T>;
}

class MSListTypeActionAllocator<T extends MSListTypeAction> extends MSDocumentActionAllocator<T> {}
declare class MSListTypeAction extends MSDocumentAction {
  alloc<T extends MSListTypeAction>(): MSListTypeActionAllocator<T>;
}

class MSListTypeActionNoneAllocator<T extends MSListTypeActionNone> extends MSListTypeActionAllocator<T> {}
declare class MSListTypeActionNone extends MSListTypeAction {
  alloc<T extends MSListTypeActionNone>(): MSListTypeActionNoneAllocator<T>;
  setListTypeNone(sender: any): IBAction;
}

class MSListTypeActionNumberedAllocator<T extends MSListTypeActionNumbered> extends MSListTypeActionAllocator<T> {}
declare class MSListTypeActionNumbered extends MSListTypeAction {
  alloc<T extends MSListTypeActionNumbered>(): MSListTypeActionNumberedAllocator<T>;
  setListTypeNumbered(sender: any): IBAction;
}

class MSListTypeActionBulletAllocator<T extends MSListTypeActionBullet> extends MSListTypeActionAllocator<T> {}
declare class MSListTypeActionBullet extends MSListTypeAction {
  alloc<T extends MSListTypeActionBullet>(): MSListTypeActionBulletAllocator<T>;
  setListTypeBullet(sender: any): IBAction;
}

class MSLockLayerActionAllocator<T extends MSLockLayerAction> extends MSDocumentActionAllocator<T> {}
declare class MSLockLayerAction extends MSDocumentAction {
  alloc<T extends MSLockLayerAction>(): MSLockLayerActionAllocator<T>;
  lockLayer(sender: any): IBAction;
}

class MSLogActionAllocator<T extends MSLogAction> extends MSActionAllocator<T> {}
declare class MSLogAction extends MSAction implements IMSPluginLogAction {
  alloc<T extends MSLogAction>(): MSLogActionAllocator<T>;
  log(sender: NSDictionary<any, any> | {[key: string]: any}): void;
  clearLog(): void;
  logString(): NSString;
  log(sender: NSDictionary<any, any> | {[key: string]: any}): void;
  clearLog(): void;
  logString(): NSString;
}

class MSMagnifierActionAllocator<T extends MSMagnifierAction> extends MSDocumentActionAllocator<T> {}
declare class MSMagnifierAction extends MSDocumentAction {
  alloc<T extends MSMagnifierAction>(): MSMagnifierActionAllocator<T>;
}

class MSMainSplitViewControllerAllocator<T extends MSMainSplitViewController> extends NSObjectAllocator<T> {}
declare class MSMainSplitViewController extends NSObject implements INSSplitViewDelegate {
  alloc<T extends MSMainSplitViewController>(): MSMainSplitViewControllerAllocator<T>;
  didEnterVersionBrowser(): void;
  didExitVersionBrowser(): void;
  splitView_canCollapseSubview(splitView: NSSplitView, subview: NSView): boolean;
  splitView_shouldCollapseSubview_forDoubleClickOnDividerAtIndex(splitView: NSSplitView, subview: NSView, dividerIndex: NSInteger): boolean;
  splitView_constrainMinCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMinimumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainMaxCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMaximumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainSplitPosition_ofSubviewAt(splitView: NSSplitView, proposedPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_resizeSubviewsWithOldSize(splitView: NSSplitView, oldSize: NSSize): void;
  splitView_shouldAdjustSizeOfSubview(splitView: NSSplitView, view: NSView): boolean;
  splitView_shouldHideDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): boolean;
  splitView_effectiveRect_forDrawnRect_ofDividerAtIndex(splitView: NSSplitView, proposedEffectiveRect: NSRect, drawnRect: NSRect, dividerIndex: NSInteger): NSRect;
  splitView_additionalEffectiveRectOfDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): NSRect;
  splitViewWillResizeSubviews(notification: NSNotification): void;
  splitViewDidResizeSubviews(notification: NSNotification): void;
  splitView_canCollapseSubview(splitView: NSSplitView, subview: NSView): boolean;
  splitView_shouldCollapseSubview_forDoubleClickOnDividerAtIndex(splitView: NSSplitView, subview: NSView, dividerIndex: NSInteger): boolean;
  splitView_constrainMinCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMinimumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainMaxCoordinate_ofSubviewAt(splitView: NSSplitView, proposedMaximumPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_constrainSplitPosition_ofSubviewAt(splitView: NSSplitView, proposedPosition: CGFloat, dividerIndex: NSInteger): CGFloat;
  splitView_resizeSubviewsWithOldSize(splitView: NSSplitView, oldSize: NSSize): void;
  splitView_shouldAdjustSizeOfSubview(splitView: NSSplitView, view: NSView): boolean;
  splitView_shouldHideDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): boolean;
  splitView_effectiveRect_forDrawnRect_ofDividerAtIndex(splitView: NSSplitView, proposedEffectiveRect: NSRect, drawnRect: NSRect, dividerIndex: NSInteger): NSRect;
  splitView_additionalEffectiveRectOfDividerAtIndex(splitView: NSSplitView, dividerIndex: NSInteger): NSRect;
  splitViewWillResizeSubviews(notification: NSNotification): void;
  splitViewDidResizeSubviews(notification: NSNotification): void;

  splitView(): NSSplitView;
  setSplitView(splitView: NSSplitView): void;
  window(): NSWindow;
  setWindow(window: NSWindow): void;
}

class MSMakeGridActionAllocator<T extends MSMakeGridAction> extends MSDocumentActionAllocator<T> {}
declare class MSMakeGridAction extends MSDocumentAction {
  alloc<T extends MSMakeGridAction>(): MSMakeGridActionAllocator<T>;
}

class MSMakeGridSheetAllocator<T extends MSMakeGridSheet> extends CHSheetControllerAllocator<T> {}
declare class MSMakeGridSheet extends CHSheetController {
  alloc<T extends MSMakeGridSheet>(): MSMakeGridSheetAllocator<T>;

  doc(): MSDocument;
  setDoc(doc: MSDocument): void;
  subtextField(): NSTextField;
  setSubtextField(subtextField: NSTextField): void;
}

class MSTextTransformActionAllocator<T extends MSTextTransformAction> extends MSDocumentActionAllocator<T> {}
declare class MSTextTransformAction extends MSDocumentAction {
  alloc<T extends MSTextTransformAction>(): MSTextTransformActionAllocator<T>;
}

class MSMakeUppercaseActionAllocator<T extends MSMakeUppercaseAction> extends MSTextTransformActionAllocator<T> {}
declare class MSMakeUppercaseAction extends MSTextTransformAction {
  alloc<T extends MSMakeUppercaseAction>(): MSMakeUppercaseActionAllocator<T>;
}

class MSMakeLowercaseActionAllocator<T extends MSMakeLowercaseAction> extends MSTextTransformActionAllocator<T> {}
declare class MSMakeLowercaseAction extends MSTextTransformAction {
  alloc<T extends MSMakeLowercaseAction>(): MSMakeLowercaseActionAllocator<T>;
}

class MSRemoveTextTransformActionAllocator<T extends MSRemoveTextTransformAction> extends MSTextTransformActionAllocator<T> {}
declare class MSRemoveTextTransformAction extends MSTextTransformAction {
  alloc<T extends MSRemoveTextTransformAction>(): MSRemoveTextTransformActionAllocator<T>;
}

class MSManageForeignSymbolItemAllocator<T extends MSManageForeignSymbolItem> extends NSObjectAllocator<T> {
  initWithForeignSymbol(foreignSymbol: MSForeignSymbol): T;
}
declare class MSManageForeignSymbolItem extends NSObject {
  alloc<T extends MSManageForeignSymbolItem>(): MSManageForeignSymbolItemAllocator<T>;

  libraryName(): NSString;
  foreignSymbol(): MSForeignSymbol;
  library(): MSAssetLibrary;
  symbolName(): NSString;
}

class MSManageForeignSymbolTableCellViewAllocator<T extends MSManageForeignSymbolTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSManageForeignSymbolTableCellView extends NSTableCellView {
  alloc<T extends MSManageForeignSymbolTableCellView>(): MSManageForeignSymbolTableCellViewAllocator<T>;
}

class MSManageForeignSymbolsViewAllocator<T extends MSManageForeignSymbolsView> extends NSViewControllerAllocator<T> {}
declare class MSManageForeignSymbolsView extends NSViewController {
  alloc<T extends MSManageForeignSymbolsView>(): MSManageForeignSymbolsViewAllocator<T>;

  document(): MSDocument;
  setDocument(document: MSDocument): void;
}

class MSManageLayerStyleViewAllocator<T extends MSManageLayerStyleView> extends MSManageSharedObjectBaseViewControllerAllocator<T> {}
declare class MSManageLayerStyleView extends MSManageSharedObjectBaseViewController {
  alloc<T extends MSManageLayerStyleView>(): MSManageLayerStyleViewAllocator<T>;
}

class MSManageShareableObjectsActionAllocator<T extends MSManageShareableObjectsAction> extends MSBaseSharedObjectActionAllocator<T> {}
declare class MSManageShareableObjectsAction extends MSBaseSharedObjectAction {
  alloc<T extends MSManageShareableObjectsAction>(): MSManageShareableObjectsActionAllocator<T>;
  showOrganiserSheet(sender: any): IBAction;
}

class MSManageSharedObjectBaseViewControllerAllocator<T extends MSManageSharedObjectBaseViewController> extends NSViewControllerAllocator<T> {}
declare class MSManageSharedObjectBaseViewController extends NSViewController implements INSTableViewDataSource, INSTableViewDelegate {
  alloc<T extends MSManageSharedObjectBaseViewController>(): MSManageSharedObjectBaseViewControllerAllocator<T>;
  deleteSelectedObjects(sender: any): IBAction;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  tableView_viewForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSView;
  tableView_rowViewForRow(tableView: NSTableView, row: NSInteger): NSTableRowView;
  tableView_didAddRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_didRemoveRowView_forRow(tableView: NSTableView, rowView: NSTableRowView, row: NSInteger): void;
  tableView_willDisplayCell_forTableColumn_row(tableView: NSTableView, cell: any, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_shouldEditTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_toolTipForCell_rect_tableColumn_row_mouseLocation(tableView: NSTableView, cell: NSCell, rect: NSRectPointer, tableColumn: NSTableColumn | null, row: NSInteger, mouseLocation: NSPoint): NSString;
  tableView_shouldShowCellExpansionForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_shouldTrackCell_forTableColumn_row(tableView: NSTableView, cell: NSCell, tableColumn: NSTableColumn | null, row: NSInteger): boolean;
  tableView_dataCellForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSCell;
  selectionShouldChangeInTableView(tableView: NSTableView): boolean;
  tableView_shouldSelectRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_selectionIndexesForProposedSelection(tableView: NSTableView, proposedSelectionIndexes: NSIndexSet): NSIndexSet;
  tableView_shouldSelectTableColumn(tableView: NSTableView, tableColumn: NSTableColumn | null): boolean;
  tableView_mouseDownInHeaderOfTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didClickTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_didDragTableColumn(tableView: NSTableView, tableColumn: NSTableColumn): void;
  tableView_heightOfRow(tableView: NSTableView, row: NSInteger): CGFloat;
  tableView_typeSelectStringForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): NSString;
  tableView_nextTypeSelectMatchFromRow_toRow_forString(tableView: NSTableView, startRow: NSInteger, endRow: NSInteger, searchString: NSString | string): NSInteger;
  tableView_shouldTypeSelectForEvent_withCurrentSearchString(tableView: NSTableView, event: NSEvent, searchString: NSString | string | null): boolean;
  tableView_isGroupRow(tableView: NSTableView, row: NSInteger): boolean;
  tableView_sizeToFitWidthOfColumn(tableView: NSTableView, column: NSInteger): CGFloat;
  tableView_shouldReorderColumn_toColumn(tableView: NSTableView, columnIndex: NSInteger, newColumnIndex: NSInteger): boolean;
  tableView_rowActionsForRow_edge(tableView: NSTableView, row: NSInteger, edge: NSTableRowActionEdge): NSArray<any>;
  tableViewSelectionDidChange(notification: NSNotification): void;
  tableViewColumnDidMove(notification: NSNotification): void;
  tableViewColumnDidResize(notification: NSNotification): void;
  tableViewSelectionIsChanging(notification: NSNotification): void;

  tableView(): NSTableView;
  setTableView(tableView: NSTableView): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  sharedObjectsSortedByName(): NSArray<any>;
}

class MSManageSharedObjectSheetAllocator<T extends MSManageSharedObjectSheet> extends CHSheetControllerAllocator<T> {}
declare class MSManageSharedObjectSheet extends CHSheetController {
  alloc<T extends MSManageSharedObjectSheet>(): MSManageSharedObjectSheetAllocator<T>;

  static tabIndex(): MSManageSharedObjectSheetTabIndex;
  static setTabIndex(tabIndex: MSManageSharedObjectSheetTabIndex): void;
}

declare enum MSManageSharedObjectSheetTabIndex {
  MSManageSharedObjectSheetTabIndexLayerStyles = 1,
  MSManageSharedObjectSheetTabIndexTextStyles = 2,
  MSManageSharedObjectSheetTabIndexImportedSymbols = 3,
}

class MSManageTextStyleViewAllocator<T extends MSManageTextStyleView> extends MSManageSharedObjectBaseViewControllerAllocator<T> {}
declare class MSManageTextStyleView extends MSManageSharedObjectBaseViewController {
  alloc<T extends MSManageTextStyleView>(): MSManageTextStyleViewAllocator<T>;
}

class MSMaskWithShapeActionAllocator<T extends MSMaskWithShapeAction> extends MSDocumentActionAllocator<T> {}
declare class MSMaskWithShapeAction extends MSDocumentAction {
  alloc<T extends MSMaskWithShapeAction>(): MSMaskWithShapeActionAllocator<T>;
  maskWithShape(sender: any): IBAction;
}

class MSMeasurementDataAllocator<T extends MSMeasurementData> extends NSObjectAllocator<T> {}
declare class MSMeasurementData extends NSObject {
  alloc<T extends MSMeasurementData>(): MSMeasurementDataAllocator<T>;

  sourceRect(): NSRect;
  setSourceRect(sourceRect: NSRect): void;
  targetRect(): NSRect;
  setTargetRect(targetRect: NSRect): void;
  targetLines(): NSArray<any>;
  setTargetLines(targetLines: NSArray<any> | any[]): void;
}

class MSMenuBuilderAllocator<T extends MSMenuBuilder> extends NSObjectAllocator<T> {}
declare class MSMenuBuilder extends NSObject {
  alloc<T extends MSMenuBuilder>(): MSMenuBuilderAllocator<T>;
  static menuBuilderWithTarget(target: any): any;
  static menuBuilderWithTarget_action(target: any, action: string): any;

  target(): any;
  action(): string;
}

class MSMiniToolbarTextFieldCellAllocator<T extends MSMiniToolbarTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class MSMiniToolbarTextFieldCell extends NSTextFieldCell {
  alloc<T extends MSMiniToolbarTextFieldCell>(): MSMiniToolbarTextFieldCellAllocator<T>;
}

class MSMirrorActionAllocator<T extends MSMirrorAction> extends MSDocumentActionAllocator<T> {}
declare class MSMirrorAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSMirrorAction>(): MSMirrorActionAllocator<T>;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSMirrorDataProviderAllocator<T extends MSMirrorDataProvider> extends NSObjectAllocator<T> {}
declare class MSMirrorDataProvider extends NSObject implements ISMKMirrorDataSource {
  alloc<T extends MSMirrorDataProvider>(): MSMirrorDataProviderAllocator<T>;
  currentArtboardDidChange(): void;
  setNeedsUpdate(): void;
  setNeedsUpdateMetadata(): void;

  connectionController(): SMKMirrorController;
  setConnectionController(connectionController: SMKMirrorController): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  documentData(): MSImmutableDocumentData;
  requiresImmediateUpdate(): boolean;
  setRequiresImmediateUpdate(requiresImmediateUpdate: boolean): void;
  currentArtboardID(): NSString;
  manifestContent(): NSDictionary<any, any>;
}

class MSMirrorPopUpButtonCellAllocator<T extends MSMirrorPopUpButtonCell> extends NSPopUpButtonCellAllocator<T> {}
declare class MSMirrorPopUpButtonCell extends NSPopUpButtonCell {
  alloc<T extends MSMirrorPopUpButtonCell>(): MSMirrorPopUpButtonCellAllocator<T>;
}

class MSMirrorToolbarItemViewAllocator<T extends MSMirrorToolbarItemView> extends NSViewAllocator<T> {}
declare class MSMirrorToolbarItemView extends NSView {
  alloc<T extends MSMirrorToolbarItemView>(): MSMirrorToolbarItemViewAllocator<T>;

  controls(): NSArray<any>;
}

class MSMirrorWebViewAllocator<T extends MSMirrorWebView> extends WKWebViewAllocator<T> {}
declare class MSMirrorWebView extends WKWebView {
  alloc<T extends MSMirrorWebView>(): MSMirrorWebViewAllocator<T>;
  static developerToolsEnabled(): boolean;
}

class MSMirrorWindowControllerAllocator<T extends MSMirrorWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSMirrorWindowController extends NSWindowController {
  alloc<T extends MSMirrorWindowController>(): MSMirrorWindowControllerAllocator<T>;
  sortedArtboards(artboards: NSArray<any> | any[] | null): NSArray<any>;
  changeVisibleArtboardID(artboardID: NSString | string | null): void;
  transitionToArtboardID_animatedBy(artboardID: NSString | string, animationType: MSFlowAnimationType): void;
  static sharedController(): MSMirrorWindowController;
  static show(): void;
  static close(): void;

  viewPort(): NSRect;
  dataProvider(): MSMirrorDataProvider;
  currentDocument(): MSImmutableDocumentData;
  currentMutableDocument(): MSDocumentData;
  currentArtboardID(): NSString;
  firstArtboardID(): NSString;
  visibleArtboardID(): NSString;
  defaultArtboardID(): NSString;
  currentStartpoint(): MSImmutableArtboardGroup;
  startpoints(): NSArray<any>;
}

declare interface IMSMirrorWindowControllerContent {

  webView(): WKWebView;
  setWebView(webView: WKWebView): void;
}

class MSShowColorsActionAllocator<T extends MSShowColorsAction> extends MSDocumentActionAllocator<T> {}
declare class MSShowColorsAction extends MSDocumentAction {
  alloc<T extends MSShowColorsAction>(): MSShowColorsActionAllocator<T>;
  showColorsAction(sender: any): IBAction;
}

class MSShowFontsActionAllocator<T extends MSShowFontsAction> extends MSDocumentActionAllocator<T> {}
declare class MSShowFontsAction extends MSDocumentAction {
  alloc<T extends MSShowFontsAction>(): MSShowFontsActionAllocator<T>;
}

class MSMissingFontsDialogAllocator<T extends MSMissingFontsDialog> extends NSWindowControllerAllocator<T> {}
declare class MSMissingFontsDialog extends NSWindowController implements INSTableViewDataSource {
  alloc<T extends MSMissingFontsDialog>(): MSMissingFontsDialogAllocator<T>;
  runPanelWithMissingFonts_savingWillChangeFonts(missingFonts: NSArray<any> | any[], savingWillChangeFonts: boolean): boolean;
  // @ts-ignore
  close(sender: any): IBAction;
  openAnyway(sender: any): IBAction;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
  numberOfRowsInTableView(tableView: NSTableView): NSInteger;
  tableView_objectValueForTableColumn_row(tableView: NSTableView, tableColumn: NSTableColumn | null, row: NSInteger): any;
  tableView_setObjectValue_forTableColumn_row(tableView: NSTableView, object: any | null, tableColumn: NSTableColumn | null, row: NSInteger): void;
  tableView_sortDescriptorsDidChange(tableView: NSTableView, oldDescriptors: NSArray<any> | any[]): void;
  tableView_pasteboardWriterForRow(tableView: NSTableView, row: NSInteger): any;
  tableView_draggingSession_willBeginAtPoint_forRowIndexes(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, rowIndexes: NSIndexSet): void;
  tableView_draggingSession_endedAtPoint_operation(tableView: NSTableView, session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  tableView_updateDraggingItemsForDrag(tableView: NSTableView, draggingInfo: any): void;
  tableView_writeRowsWithIndexes_toPasteboard(tableView: NSTableView, rowIndexes: NSIndexSet, pboard: NSPasteboard): boolean;
  tableView_validateDrop_proposedRow_proposedDropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): NSDragOperation;
  tableView_acceptDrop_row_dropOperation(tableView: NSTableView, info: any, row: NSInteger, dropOperation: NSTableViewDropOperation): boolean;
  tableView_namesOfPromisedFilesDroppedAtDestination_forDraggedRowsWithIndexes(tableView: NSTableView, dropDestination: NSURL, indexSet: NSIndexSet): NSArray<any>;
}

class MSModalInputSheetAllocator<T extends MSModalInputSheet> extends NSObjectAllocator<T> {}
declare class MSModalInputSheet extends NSObject implements INSWindowDelegate {
  alloc<T extends MSModalInputSheet>(): MSModalInputSheetAllocator<T>;
  runPanelWithNibName_ofType_initialString_label(nibName: NSString | string, inputType: MSModalInputTypes, initialString: NSString | string, label: NSString | string): NSString;
  ok(sender: any): IBAction;
  cancel(sender: any): IBAction;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;

  type(): MSModalInputTypes;
  setType(type: MSModalInputTypes): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  numberFieldBinding(): CGFloat;
  setNumberFieldBinding(numberFieldBinding: CGFloat): void;
}

declare enum MSModalInputTypes {
  MSModalInputTypeString,
  MSModalInputTypeNumber,
  MSModalInputTypePath,
}

class MSModePickerViewAllocator<T extends MSModePickerView> extends NSViewAllocator<T> {}
declare class MSModePickerView extends NSView {
  alloc<T extends MSModePickerView>(): MSModePickerViewAllocator<T>;

  pickerMode(): NSInteger;
  setPickerMode(pickerMode: NSInteger): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  labelField(): NSTextField;
  setLabelField(labelField: NSTextField): void;
}

class MSColorModePickerCellAllocator<T extends MSColorModePickerCell> extends NSButtonCellAllocator<T> {}
declare class MSColorModePickerCell extends NSButtonCell {
  alloc<T extends MSColorModePickerCell>(): MSColorModePickerCellAllocator<T>;
}

declare interface IMSModeModePickerDelegate {
  pickerViewWillChange(picker: MSModePickerView): void;
  pickerViewChanged(picker: MSModePickerView): void;
  pickerView_labelForMode(view: MSModePickerView, mode: NSInteger): NSString;
}

class MSMouseTrackerAllocator<T extends MSMouseTracker> extends NSObjectAllocator<T> {
  initWithTarget_action(target: any | null, action: string | null): T;
}
declare class MSMouseTracker extends NSObject {
  alloc<T extends MSMouseTracker>(): MSMouseTrackerAllocator<T>;
  sendAction(): void;
  locationInView(view: NSView | null): NSPoint;
  mouseEntered(event: NSEvent): void;
  mouseMoved(event: NSEvent): void;
  mouseExited(event: NSEvent | null): void;
  flagsChanged(event: NSEvent): void;
  mouseDown(event: NSEvent): void;
  mouseDragged(event: NSEvent): void;
  mouseUp(event: NSEvent): void;

  target(): any;
  setTarget(target: any): void;
  action(): string;
  setAction(action: string): void;
  trackingState(): MSMouseTrackingState;
  view(): NSView;
  setView(view: NSView): void;
  modifierFlags(): NSEventModifierFlags;
  canUpdateCursor(): boolean;
}

declare enum MSMouseTrackingState {
  MSMouseTrackingStateNone,
  MSMouseTrackingStateInside = 1 << 0,
  MSMouseTrackingStateMouseDown = 1 << 1,
}

class MSMoveToTopActionAllocator<T extends MSMoveToTopAction> extends MSDocumentActionAllocator<T> {}
declare class MSMoveToTopAction extends MSDocumentAction {
  alloc<T extends MSMoveToTopAction>(): MSMoveToTopActionAllocator<T>;
  moveToTop(sender: any): IBAction;
}

class MSMoveUpHierarchyActionAllocator<T extends MSMoveUpHierarchyAction> extends MSDocumentActionAllocator<T> {}
declare class MSMoveUpHierarchyAction extends MSDocumentAction {
  alloc<T extends MSMoveUpHierarchyAction>(): MSMoveUpHierarchyActionAllocator<T>;
  moveUpHierarchy(sender: any): IBAction;
}

class MSMultipleBorderInspectorViewControllerAllocator<T extends MSMultipleBorderInspectorViewController> extends MSMultipleColorStylePartInspectorViewControllerAllocator<T> {}
declare class MSMultipleBorderInspectorViewController extends MSMultipleColorStylePartInspectorViewController implements IBCPopoverDelegate {
  alloc<T extends MSMultipleBorderInspectorViewController>(): MSMultipleBorderInspectorViewControllerAllocator<T>;
  showAdvancedOptionsAction(sender: any): IBAction;
  styleDidEnableOrDisable(): void;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;

  borderOptionsController(): MSBorderOptionsInspectorViewController;
  thicknessLabel(): MSTextLabelForUpDownField;
  setThicknessLabel(thicknessLabel: MSTextLabelForUpDownField): void;
}

class MSMultipleColorStylePartInspectorViewControllerAllocator<T extends MSMultipleColorStylePartInspectorViewController> extends MSMultipleStylePartInspectorViewControllerAllocator<T> {}
declare class MSMultipleColorStylePartInspectorViewController extends MSMultipleStylePartInspectorViewController {
  alloc<T extends MSMultipleColorStylePartInspectorViewController>(): MSMultipleColorStylePartInspectorViewControllerAllocator<T>;
  openPopoverAtIndex(index: NSUInteger): void;
  closeAnyColorPopover(): void;
}

class MSMultipleFillInspectorViewControllerAllocator<T extends MSMultipleFillInspectorViewController> extends MSMultipleColorStylePartInspectorViewControllerAllocator<T> {}
declare class MSMultipleFillInspectorViewController extends MSMultipleColorStylePartInspectorViewController implements IBCPopoverDelegate {
  alloc<T extends MSMultipleFillInspectorViewController>(): MSMultipleFillInspectorViewControllerAllocator<T>;
  showAdvancedOptionsAction(sender: any): IBAction;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;
  minimumPopoverContentViewHeight(popover: BCPopover): CGFloat;
  popoverWillShow(notification: NSNotification): void;
  popoverWillClose(popover: BCPopover): void;
  popoverWindowSizeDidChange(popover: BCPopover): void;
  popoverWindowDidMove(popover: BCPopover): void;
  popoverShouldCloseWhenNewPopoverOpens_newPopover(popover: BCPopover, newPopover: BCPopover): boolean;
  popoverShouldCauseExistingPopoversToClose(popover: BCPopover): boolean;
  popoverWillReturnUndoManager(popover: BCPopover): NSUndoManager;
  popoverShouldTrackSuperviewOfAttachedToView(popover: BCPopover): boolean;

  opacityLabel(): MSTextLabelForUpDownField;
  setOpacityLabel(opacityLabel: MSTextLabelForUpDownField): void;
}

class MSMultipleInnerShadowInspectorViewControllerAllocator<T extends MSMultipleInnerShadowInspectorViewController> extends MSMultipleShadowInspectorViewControllerAllocator<T> {}
declare class MSMultipleInnerShadowInspectorViewController extends MSMultipleShadowInspectorViewController {
  alloc<T extends MSMultipleInnerShadowInspectorViewController>(): MSMultipleInnerShadowInspectorViewControllerAllocator<T>;
}

class MSMultipleShadowInspectorViewControllerAllocator<T extends MSMultipleShadowInspectorViewController> extends MSMultipleColorStylePartInspectorViewControllerAllocator<T> {}
declare class MSMultipleShadowInspectorViewController extends MSMultipleColorStylePartInspectorViewController {
  alloc<T extends MSMultipleShadowInspectorViewController>(): MSMultipleShadowInspectorViewControllerAllocator<T>;
  shouldHideAddStylePartButton(): boolean;

  addStylePartButton(): NSButton;
  setAddStylePartButton(addStylePartButton: NSButton): void;
}

class MSMultipleStylePartInspectorViewControllerAllocator<T extends MSMultipleStylePartInspectorViewController> extends NSViewControllerAllocator<T> {}
declare class MSMultipleStylePartInspectorViewController extends NSViewController implements IMSReorderingContainerDelegate {
  alloc<T extends MSMultipleStylePartInspectorViewController>(): MSMultipleStylePartInspectorViewControllerAllocator<T>;
  prepare(): void;
  stylePartType(): MSStylePartType;
  rotatedStyleParts(): NSArray<any>;
  addStylePartAction(sender: any): IBAction;
  deleteStylePartAction(sender: any): IBAction;
  deleteUnusedStylePartsAction(sender: any): IBAction;
  addStylePartsForSelection(): NSArray<any>;
  hasEnabledStyle(): boolean;
  prepareInspector_parts_index(inspector: MSStylePartInspectorViewController, styleParts: NSArray<any> | any[], index: NSUInteger): void;
  loadViewControllers(): void;
  validateSpecialButtons(): void;
  validateRemoveDisabledStylesButton(): void;
  resizeViewToFit(): void;
  styleDidEnableOrDisable(): void;
  inspectorForStyleParts_atIndex(styleParts: NSArray<any> | any[], index: NSUInteger): any;
  shouldShowAdvancedOptionsButton(): boolean;
  lastEnabledStylePartController(): MSStylePartInspectorViewController;
  containerBackground_dragDidReorderChildAtIndex_toIndex(backgroundView: MSReorderingContainerView, fromIndex: NSUInteger, toIndex: NSUInteger): void;
  startingOffsetForStackingContainerBackground(backgroundView: MSReorderingContainerView): CGFloat;
  numberOfReorderableSubviewsForContainerBackground(backgroundView: MSReorderingContainerView): NSUInteger;
  containerBackground_dragDidReorderChildAtIndex_toIndex(backgroundView: MSReorderingContainerView, fromIndex: NSUInteger, toIndex: NSUInteger): void;
  startingOffsetForStackingContainerBackground(backgroundView: MSReorderingContainerView): CGFloat;
  numberOfReorderableSubviewsForContainerBackground(backgroundView: MSReorderingContainerView): NSUInteger;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  stylePartViewControllers(): NSArray<any>;
  setStylePartViewControllers(stylePartViewControllers: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  reorderingContainer(): MSReorderingContainerView;
  setReorderingContainer(reorderingContainer: MSReorderingContainerView): void;
  nameView(): NSView;
  setNameView(nameView: NSView): void;
  removeDisabledStylesButton(): NSButton;
  setRemoveDisabledStylesButton(removeDisabledStylesButton: NSButton): void;
  showAdvancedOptionsButton(): NSButton;
  setShowAdvancedOptionsButton(showAdvancedOptionsButton: NSButton): void;
}

class MSNewsTriggerAllocator<T extends MSNewsTrigger> extends BCSingletonAllocator<T> {}
declare class MSNewsTrigger extends BCSingleton {
  alloc<T extends MSNewsTrigger>(): MSNewsTriggerAllocator<T>;
}

class MSNewsTriggerWindowControllerAllocator<T extends MSNewsTriggerWindowController> extends CHWindowControllerAllocator<T> {}
declare class MSNewsTriggerWindowController extends CHWindowController {
  alloc<T extends MSNewsTriggerWindowController>(): MSNewsTriggerWindowControllerAllocator<T>;
}

class MSNewsletterSignupAllocator<T extends MSNewsletterSignup> extends NSObjectAllocator<T> {}
declare class MSNewsletterSignup extends NSObject {
  alloc<T extends MSNewsletterSignup>(): MSNewsletterSignupAllocator<T>;
}

class MSNiceSliceActionAllocator<T extends MSNiceSliceAction> extends MSEventHandlerActionAllocator<T> {}
declare class MSNiceSliceAction extends MSEventHandlerAction {
  alloc<T extends MSNiceSliceAction>(): MSNiceSliceActionAllocator<T>;
}

class MSNonAutosavingDocumentAllocator<T extends MSNonAutosavingDocument> extends MSDocumentAllocator<T> {}
declare class MSNonAutosavingDocument extends MSDocument {
  alloc<T extends MSNonAutosavingDocument>(): MSNonAutosavingDocumentAllocator<T>;
}

class MSNormalBaseEventHandlerAllocator<T extends MSNormalBaseEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSNormalBaseEventHandler extends MSEventHandler {
  alloc<T extends MSNormalBaseEventHandler>(): MSNormalBaseEventHandlerAllocator<T>;
  cursorForCorner_ofLayer(corner: BCCorner, layer: MSLayer | null): NSCursor;
  resizeParentsOfSelectedLayersToFit(): void;
  configureInspector(inspector: MSInspectorController): void;
}

class MSNormalEventContextualMenuBuilderAllocator<T extends MSNormalEventContextualMenuBuilder> extends NSObjectAllocator<T> {}
declare class MSNormalEventContextualMenuBuilder extends NSObject {
  alloc<T extends MSNormalEventContextualMenuBuilder>(): MSNormalEventContextualMenuBuilderAllocator<T>;
  constructMenus(): void;
  menuForLayers(layers: NSArray<any> | any[]): NSMenu;
}

class MSNormalEventDataAllocator<T extends MSNormalEventData> extends NSObjectAllocator<T> {}
declare class MSNormalEventData extends NSObject {
  alloc<T extends MSNormalEventData>(): MSNormalEventDataAllocator<T>;

  hasMultipleTouches(): boolean;
  setHasMultipleTouches(hasMultipleTouches: boolean): void;
  didMouseDown(): boolean;
  setDidMouseDown(didMouseDown: boolean): void;
  mouseDown(): NSPoint;
  setMouseDown(mouseDown: NSPoint): void;
  midPoint(): NSPoint;
  setMidPoint(midPoint: NSPoint): void;
  originalScrollOrigin(): NSPoint;
  setOriginalScrollOrigin(originalScrollOrigin: NSPoint): void;
  resizingLayer(): MSLayer;
  setResizingLayer(resizingLayer: MSLayer): void;
  resizingHandle(): BCCorner;
  setResizingHandle(resizingHandle: BCCorner): void;
  dragMode(): MSEventHandlerDragMode;
  setDragMode(dragMode: MSEventHandlerDragMode): void;
  snapperData(): MSSnapperData;
  setSnapperData(snapperData: MSSnapperData): void;
}

declare enum MSEventHandlerDragMode {
  MSEventHandlerDragNone = -1,
  MSEventHandlerDragMove = 0,
  MSEventHandlerDragSelect = 2,
}

class MSNormalEventHandlerAllocator<T extends MSNormalEventHandler> extends MSNormalBaseEventHandlerAllocator<T> {}
declare class MSNormalEventHandler extends MSNormalBaseEventHandler {
  alloc<T extends MSNormalEventHandler>(): MSNormalEventHandlerAllocator<T>;
  selectLayer(sender: any): IBAction;
  ignoreNextKeyDownEventUntilModifiersChange(): void;
  cancelOperation(sender: any): void;
  drawSelectedShapePathLayers(): void;

  measurementRenderer(): MSLayerMeasurementRenderer;
  highlightedItem(): NSObject;
  setHighlightedItem(highlightedItem: NSObject): void;
}

class MSNormalInspectorAllocator<T extends MSNormalInspector> extends NSViewControllerAllocator<T> {}
declare class MSNormalInspector extends NSViewController implements IMSStylePartInspectorDelegate, IMSInspectorChildController {
  alloc<T extends MSNormalInspector>(): MSNormalInspectorAllocator<T>;
  selectionDidChangeTo(newLayers: NSArray<any> | any[]): void;
  adjustInspectorToColorPopover_sender(popover: BCPopover, sender: any): void;
  closeAnyColorPopover(): void;
  colorMagnifierAction(sender: any): IBAction;
  changeTextLayerFont(sender: any): IBAction;
  layerPositionPossiblyChanged(): void;
  showFillOptionsAction(sender: any): IBAction;
  showBorderOptionsAction(sender: any): IBAction;
  openPopoverForStylePart_atIndex(stylePart: MSStylePartType, index: NSUInteger): void;
  reloadSharedObjectsSection(): void;
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
  switchToEventHandlerWithName(handlerName: NSString | string): any;
  layers(): NSArray<any>;
  reload(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;
  switchToEventHandlerWithName(handlerName: NSString | string): any;
  layers(): NSArray<any>;
  reload(): void;
  prepareForDisplay(): void;
  selectionDidChangeTo(layers: NSArray<any> | any[]): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  layerPositionPossiblyChanged(): void;

  stackView(): MSInspectorStackView;
  setStackView(stackView: MSInspectorStackView): void;
  layers(): MSLayerArray;
  setLayers(layers: MSLayerArray): void;
  eventHandler(): MSEventHandler;
  setEventHandler(eventHandler: MSEventHandler): void;
  sharedStyleInspectorVisible(): boolean;
}

class MSNormalMultipleResizeEventHandlerAllocator<T extends MSNormalMultipleResizeEventHandler> extends MSNormalBaseEventHandlerAllocator<T> {}
declare class MSNormalMultipleResizeEventHandler extends MSNormalBaseEventHandler {
  alloc<T extends MSNormalMultipleResizeEventHandler>(): MSNormalMultipleResizeEventHandlerAllocator<T>;
  calculateOppositePoint(): void;
  calculateMidPoint(): void;
  displayResizeCursor(): void;
  storeCurrentLayerFrame(): void;
  makeRectConform_toProportions(newFrame: NSRect, constrainProportions: boolean): NSRect;
  placeRectInOppositeCorner(newFrame: NSRect): NSRect;
  oppositeCorner(): BCCorner;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  resizingCorner(): BCCorner;
  setResizingCorner(resizingCorner: BCCorner): void;
  layerSnapper(): MSSnapper;
  setLayerSnapper(layerSnapper: MSSnapper): void;
  eventData(): MSNormalEventData;
  setEventData(eventData: MSNormalEventData): void;
}

class MSNormalResizeEventHandlerAllocator<T extends MSNormalResizeEventHandler> extends MSNormalBaseEventHandlerAllocator<T> {}
declare class MSNormalResizeEventHandler extends MSNormalBaseEventHandler {
  alloc<T extends MSNormalResizeEventHandler>(): MSNormalResizeEventHandlerAllocator<T>;

  snappingSession(): MSSnappingSession;
  setSnappingSession(snappingSession: MSSnappingSession): void;
  eventData(): MSNormalEventData;
  setEventData(eventData: MSNormalEventData): void;
}

class MSNormalResizeLineEventHandlerAllocator<T extends MSNormalResizeLineEventHandler> extends MSNormalBaseEventHandlerAllocator<T> {}
declare class MSNormalResizeLineEventHandler extends MSNormalBaseEventHandler {
  alloc<T extends MSNormalResizeLineEventHandler>(): MSNormalResizeLineEventHandlerAllocator<T>;

  layer(): MSShapePathLayer;
  setLayer(layer: MSShapePathLayer): void;
  pointIndex(): NSInteger;
  setPointIndex(pointIndex: NSInteger): void;
  layerSnapper(): MSSnapper;
  setLayerSnapper(layerSnapper: MSSnapper): void;
  eventData(): MSNormalEventData;
  setEventData(eventData: MSNormalEventData): void;
}

class MSOffsetPathActionAllocator<T extends MSOffsetPathAction> extends MSDocumentActionAllocator<T> {}
declare class MSOffsetPathAction extends MSDocumentAction {
  alloc<T extends MSOffsetPathAction>(): MSOffsetPathActionAllocator<T>;
  offsetPath(sender: any): IBAction;
}

class MSOffsetPathSheetAllocator<T extends MSOffsetPathSheet> extends MSCanvasUpdatingSheetAllocator<T> {}
declare class MSOffsetPathSheet extends MSCanvasUpdatingSheet {
  alloc<T extends MSOffsetPathSheet>(): MSOffsetPathSheetAllocator<T>;

  offset(): CGFloat;
  setOffset(offset: CGFloat): void;
  duplicateLayers(): boolean;
  setDuplicateLayers(duplicateLayers: boolean): void;
}

class MSOpacityBlendingInspectorItemAllocator<T extends MSOpacityBlendingInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSOpacityBlendingInspectorItem extends MSInspectorItem implements INSMenuDelegate {
  alloc<T extends MSOpacityBlendingInspectorItem>(): MSOpacityBlendingInspectorItemAllocator<T>;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

class MSOpenCloudPreferencesActionAllocator<T extends MSOpenCloudPreferencesAction> extends MSActionAllocator<T> {}
declare class MSOpenCloudPreferencesAction extends MSAction {
  alloc<T extends MSOpenCloudPreferencesAction>(): MSOpenCloudPreferencesActionAllocator<T>;
  openCloudPreferences(sender: any): IBAction;
}

class MSOpenInLibraryActionAllocator<T extends MSOpenInLibraryAction> extends MSDocumentActionAllocator<T> {}
declare class MSOpenInLibraryAction extends MSDocumentAction {
  alloc<T extends MSOpenInLibraryAction>(): MSOpenInLibraryActionAllocator<T>;
}

class MSOpenSymbolInLibraryActionAllocator<T extends MSOpenSymbolInLibraryAction> extends MSOpenInLibraryActionAllocator<T> {}
declare class MSOpenSymbolInLibraryAction extends MSOpenInLibraryAction {
  alloc<T extends MSOpenSymbolInLibraryAction>(): MSOpenSymbolInLibraryActionAllocator<T>;
  openLibraryForForeignSymbols(sender: any): void;
}

class MSOpenStyleInLibraryActionAllocator<T extends MSOpenStyleInLibraryAction> extends MSOpenInLibraryActionAllocator<T> {}
declare class MSOpenStyleInLibraryAction extends MSOpenInLibraryAction {
  alloc<T extends MSOpenStyleInLibraryAction>(): MSOpenStyleInLibraryActionAllocator<T>;
  openLibraryForStyles(sender: any): void;
}

class MSOpenPluginPreferencesActionAllocator<T extends MSOpenPluginPreferencesAction> extends MSActionAllocator<T> {}
declare class MSOpenPluginPreferencesAction extends MSAction {
  alloc<T extends MSOpenPluginPreferencesAction>(): MSOpenPluginPreferencesActionAllocator<T>;
  openPluginPreferences(sender: any): IBAction;
}

class MSOpenPreferencesActionAllocator<T extends MSOpenPreferencesAction> extends MSActionAllocator<T> {}
declare class MSOpenPreferencesAction extends MSAction {
  alloc<T extends MSOpenPreferencesAction>(): MSOpenPreferencesActionAllocator<T>;
  openPreferences(sender: any): IBAction;
  openPreferencesWindowWithPreferencePaneIdentifier(identifier: NSString | string): void;
}

class MSOpenPreviewActionAllocator<T extends MSOpenPreviewAction> extends MSDocumentActionAllocator<T> {}
declare class MSOpenPreviewAction extends MSDocumentAction {
  alloc<T extends MSOpenPreviewAction>(): MSOpenPreviewActionAllocator<T>;
  openMirrorPreview(sender: any): IBAction;
}

class MSOperatingSystemAllocator<T extends MSOperatingSystem> extends NSObjectAllocator<T> {}
declare class MSOperatingSystem extends NSObject {
  alloc<T extends MSOperatingSystem>(): MSOperatingSystemAllocator<T>;
  static operatingSystemVersion(): NSOperatingSystemVersion;
  static isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
  static systemVersionString(): NSString;
}

class MSOverrideInspectorItemAllocator<T extends MSOverrideInspectorItem> extends MSInspectorItemAllocator<T> {
  initWithPrimaryOverrideRepresentation(overrideRepresentation: MSOverrideRepresentation): T;
}
declare class MSOverrideInspectorItem extends MSInspectorItem implements IMSDataMenuProviderDelegate {
  alloc<T extends MSOverrideInspectorItem>(): MSOverrideInspectorItemAllocator<T>;
  labelView(): NSTextField;
  build(): void;
  supportedDataProviders(): MSDataType;
  controlViewForEditingOverride(): NSControl;
  valueFromControlView(controlView: any): any;
  overrideValueAction(sender: any): IBAction;
  applyOverrideToSelectedLayers(value: any): void;
  setIndentationLevel(level: NSUInteger): void;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;
  dataMenuProvider_canChooseDataOfType(controller: MSDataMenuProvider, type: MSDataType): boolean;
  dataMenuProviderCanApplyMasterDataToInstances(controller: MSDataMenuProvider): boolean;
  dataMenuProviderCanRefreshData(controller: MSDataMenuProvider): boolean;
  dataMenuProviderSelectedLayersWithAppliedData(controller: MSDataMenuProvider): NSArray<any>;
  dataMenuProviderDataTypeForMenuBuilding(controller: MSDataMenuProvider): MSDataType;
  dataMenuProviderIsInspectorPopupMenu(provider: MSDataMenuProvider): boolean;
  dataMenuProvider_didChooseData(controller: MSDataMenuProvider, data: MSDataSupplier): void;
  dataMenuProviderRefreshData(controller: MSDataMenuProvider): void;
  dataMenuProviderRefreshMasterData(controller: MSDataMenuProvider): void;
  dataMenuProviderRemoveDataRecord(controller: MSDataMenuProvider): void;
  dataMenuProviderDataIdentifier(controller: MSDataMenuProvider): NSString;

  primaryOverride(): MSAvailableOverride;
  overrideRepresentation(): MSOverrideRepresentation;
  hasSingleOverride(): boolean;
  contentView(): NSView;
  documentData(): MSDocumentData;
  document(): MSDocument;
  displaysLabel(): boolean;
  setDisplaysLabel(displaysLabel: boolean): void;
}

class MSOverrideTextFieldAllocator<T extends MSOverrideTextField> extends NSTextFieldAllocator<T> {}
declare class MSOverrideTextField extends NSTextField {
  alloc<T extends MSOverrideTextField>(): MSOverrideTextFieldAllocator<T>;
}

class MSPDFBookExporterAllocator<T extends MSPDFBookExporter> extends NSObjectAllocator<T> {}
declare class MSPDFBookExporter extends NSObject {
  alloc<T extends MSPDFBookExporter>(): MSPDFBookExporterAllocator<T>;
  static exportPages_defaultFilename(pages: NSArray<any> | any[], defaultFilename: NSString | string): void;
}

class MSPaddingInspectorItemAllocator<T extends MSPaddingInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSPaddingInspectorItem extends MSInspectorItem {
  alloc<T extends MSPaddingInspectorItem>(): MSPaddingInspectorItemAllocator<T>;
  static paddingWithHeight(height: CGFloat): MSPaddingInspectorItem;

  wantsSeparator(): boolean;
  setWantsSeparator(wantsSeparator: boolean): void;
}

class MSPaddingInspectorItemViewAllocator<T extends MSPaddingInspectorItemView> extends NSViewAllocator<T> {}
declare class MSPaddingInspectorItemView extends NSView {
  alloc<T extends MSPaddingInspectorItemView>(): MSPaddingInspectorItemViewAllocator<T>;

  wantsSeparator(): boolean;
  setWantsSeparator(wantsSeparator: boolean): void;
}

class MSNewPageActionAllocator<T extends MSNewPageAction> extends MSDocumentActionAllocator<T> {}
declare class MSNewPageAction extends MSDocumentAction {
  alloc<T extends MSNewPageAction>(): MSNewPageActionAllocator<T>;
  addNewPage(sender: any): IBAction;
}

class MSChangePageActionAllocator<T extends MSChangePageAction> extends MSDocumentActionAllocator<T> {}
declare class MSChangePageAction extends MSDocumentAction {
  alloc<T extends MSChangePageAction>(): MSChangePageActionAllocator<T>;
}

class MSPreviousPageActionAllocator<T extends MSPreviousPageAction> extends MSChangePageActionAllocator<T> {}
declare class MSPreviousPageAction extends MSChangePageAction {
  alloc<T extends MSPreviousPageAction>(): MSPreviousPageActionAllocator<T>;
  previousPage(sender: any): IBAction;
}

class MSNextPageActionAllocator<T extends MSNextPageAction> extends MSChangePageActionAllocator<T> {}
declare class MSNextPageAction extends MSChangePageAction {
  alloc<T extends MSNextPageAction>(): MSNextPageActionAllocator<T>;
  nextPage(sender: any): IBAction;
}

class MSPagesTableViewAllocator<T extends MSPagesTableView> extends NSTableViewAllocator<T> {}
declare class MSPagesTableView extends NSTableView {
  alloc<T extends MSPagesTableView>(): MSPagesTableViewAllocator<T>;
}

class MSParagraphStyleViewControllerAllocator<T extends MSParagraphStyleViewController> extends NSViewControllerAllocator<T> {}
declare class MSParagraphStyleViewController extends NSViewController {
  alloc<T extends MSParagraphStyleViewController>(): MSParagraphStyleViewControllerAllocator<T>;
  decorationButtonAction(sender: any): IBAction;
  listPopUpAction(sender: any): IBAction;
  transformPopUpAction(sender: any): IBAction;

  textSection(): MSTextLayerItem;
  setTextSection(textSection: MSTextLayerItem): void;
  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  decorationButton(): NSSegmentedControl;
  setDecorationButton(decorationButton: NSSegmentedControl): void;
  listPopUpButton(): NSPopUpButton;
  setListPopUpButton(listPopUpButton: NSPopUpButton): void;
  transformPopUpButton(): NSPopUpButton;
  setTransformPopUpButton(transformPopUpButton: NSPopUpButton): void;
}

class MSPathControllerAllocator<T extends MSPathController> extends NSObjectAllocator<T> {}
declare class MSPathController extends NSObject {
  alloc<T extends MSPathController>(): MSPathControllerAllocator<T>;
  setSelectionIndexPath(indexPath: NSIndexPath | null): void;
  runChange(change: MSShapeChange): void;
  runChange_context(change: MSShapeChange, context: MSShapeChangeContext): void;
  selectNext(sender: any): void;
  selectPrevious(sender: any): void;
  currentCurveMode(): NSNumber;
  changeCurveMode(mode: MSCurveMode): void;
  remove(sender: any): IBAction;

  content(): NSArray<any>;
  setContent(content: NSArray<any> | any[]): void;
  selectionIndexPaths(): NSArray<any>;
  setSelectionIndexPaths(selectionIndexPaths: NSArray<any> | any[]): void;
  selectedObjects(): NSArray<any>;
  changeContext(): MSShapeChangeContext;
}

class MSPencilEventHandlerAllocator<T extends MSPencilEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSPencilEventHandler extends MSEventHandler {
  alloc<T extends MSPencilEventHandler>(): MSPencilEventHandlerAllocator<T>;
}

class MSPluginManagerWithActionsAllocator<T extends MSPluginManagerWithActions> extends MSPluginManagerAllocator<T> {}
declare class MSPluginManagerWithActions extends MSPluginManager implements IMSActionObserver {
  alloc<T extends MSPluginManagerWithActions>(): MSPluginManagerWithActionsAllocator<T>;
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_willBeginActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didFinishActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;
  actionController_didInstantActionWithID_context(controller: MSActionController, actionID: NSString | string, context: any): void;

  dataManager(): MSDataSupplierManager;
  setDataManager(dataManager: MSDataSupplierManager): void;
}

class MSPluginStandaloneScriptAllocator<T extends MSPluginStandaloneScript> extends MSPluginScriptAllocator<T> {}
declare class MSPluginStandaloneScript extends MSPluginScript {
  alloc<T extends MSPluginStandaloneScript>(): MSPluginStandaloneScriptAllocator<T>;
  static wrappedScript_handler(script: NSString | string, handler: NSString | string): NSString;

  rawScript(): NSString;
  handler(): NSString;
}

class MSPluginsPreferenceIconViewAllocator<T extends MSPluginsPreferenceIconView> extends NSViewAllocator<T> {}
declare class MSPluginsPreferenceIconView extends NSView {
  alloc<T extends MSPluginsPreferenceIconView>(): MSPluginsPreferenceIconViewAllocator<T>;

  icon(): NSImage;
  setIcon(icon: NSImage): void;
}

class MSPluginsPreferencePaneAllocator<T extends MSPluginsPreferencePane> extends MSPreferencePaneAllocator<T> {}
declare class MSPluginsPreferencePane extends MSPreferencePane implements INSTextFieldDelegate {
  alloc<T extends MSPluginsPreferencePane>(): MSPluginsPreferencePaneAllocator<T>;
  getPlugins(sender: any): IBAction;
  togglePluginEnabled(sender: any): IBAction;
  tableContextMenu(sender: any): IBAction;
  openPluginsFolder(sender: any): IBAction;
  installPluginUpdates(sender: any): IBAction;
  installPluginUpdate(sender: any): IBAction;
  openPluginURL(sender: any): IBAction;
  activateSearchField(sender: any): IBAction;
  static openWithPluginToHighlight(pluginIdentifier: NSString | string): void;
  textField_textView_candidatesForSelectedRange(textField: NSTextField, textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textField_textView_candidates_forSelectedRange(textField: NSTextField, textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textField_textView_shouldSelectCandidateAtIndex(textField: NSTextField, textView: NSTextView, index: NSUInteger): boolean;
  textField_textView_candidatesForSelectedRange(textField: NSTextField, textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textField_textView_candidates_forSelectedRange(textField: NSTextField, textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textField_textView_shouldSelectCandidateAtIndex(textField: NSTextField, textView: NSTextView, index: NSUInteger): boolean;

  pluginsArrayController(): NSArrayController;
  setPluginsArrayController(pluginsArrayController: NSArrayController): void;
  pluginSortDescriptors(): NSArray<any>;
  filteredPlugins(): NSArray<any>;
  pluginFilterPredicate(): NSPredicate;
  zeroPluginsImage(): NSImage;
  zeroPluginsTitle(): NSString;
  zeroPluginsTitleFont(): NSFont;
  zeroPluginsText(): NSString;
  filterTextField(): NSSearchField;
  setFilterTextField(filterTextField: NSSearchField): void;
  tableView(): BCKeyEventActionTableView;
  setTableView(tableView: BCKeyEventActionTableView): void;
  getPluginsButton(): NSButton;
  setGetPluginsButton(getPluginsButton: NSButton): void;
  contextMenuControl(): NSControl;
  setContextMenuControl(contextMenuControl: NSControl): void;
  contextMenu(): NSMenu;
  setContextMenu(contextMenu: NSMenu): void;
  spyglassFilterButton(): NSButton;
  setSpyglassFilterButton(spyglassFilterButton: NSButton): void;
  enableUpdateAllButton(): boolean;
  setEnableUpdateAllButton(enableUpdateAllButton: boolean): void;
}

class MSPluginsPreferenceTableCellViewAllocator<T extends MSPluginsPreferenceTableCellView> extends NSTableCellViewAllocator<T> {}
declare class MSPluginsPreferenceTableCellView extends NSTableCellView {
  alloc<T extends MSPluginsPreferenceTableCellView>(): MSPluginsPreferenceTableCellViewAllocator<T>;

  updateAvailableContainer(): NSView;
  setUpdateAvailableContainer(updateAvailableContainer: NSView): void;
  pluginIncompatibleContainer(): NSView;
  setPluginIncompatibleContainer(pluginIncompatibleContainer: NSView): void;
  updateAvailableInfo(): MSPluginsPreferencesUpdateButton;
  setUpdateAvailableInfo(updateAvailableInfo: MSPluginsPreferencesUpdateButton): void;
  updatePlugin(): NSButton;
  setUpdatePlugin(updatePlugin: NSButton): void;
  pluginUpdating(): NSProgressIndicator;
  setPluginUpdating(pluginUpdating: NSProgressIndicator): void;
  updateAvailableHeightConstraint(): NSLayoutConstraint;
  setUpdateAvailableHeightConstraint(updateAvailableHeightConstraint: NSLayoutConstraint): void;
  incompatiblePluginHeightConstraint(): NSLayoutConstraint;
  setIncompatiblePluginHeightConstraint(incompatiblePluginHeightConstraint: NSLayoutConstraint): void;
  descriptionField(): NSTextField;
  setDescriptionField(descriptionField: NSTextField): void;
  iconView(): MSPluginsPreferenceIconView;
  setIconView(iconView: MSPluginsPreferenceIconView): void;
  tableCellWidthConstraint(): NSLayoutConstraint;
  setTableCellWidthConstraint(tableCellWidthConstraint: NSLayoutConstraint): void;
}

class MSPluginsPreferencesUpdateButtonAllocator<T extends MSPluginsPreferencesUpdateButton> extends NSButtonAllocator<T> {}
declare class MSPluginsPreferencesUpdateButton extends NSButton {
  alloc<T extends MSPluginsPreferencesUpdateButton>(): MSPluginsPreferencesUpdateButtonAllocator<T>;

  tableCellView(): MSPluginsPreferenceTableCellView;
  setTableCellView(tableCellView: MSPluginsPreferenceTableCellView): void;
}

class MSPointsEventHandlerAllocator<T extends MSPointsEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSPointsEventHandler extends MSEventHandler {
  alloc<T extends MSPointsEventHandler>(): MSPointsEventHandlerAllocator<T>;
  findSelectedLayer(): MSStyledLayer;
  points(): MSPointArray;
  convertPointToUnitCoordinateSpace(mouse: NSPoint): NSPoint;
  point_isNearPoint(p1: NSPoint, p2: NSPoint): boolean;
  pointAtIndex(index: NSUInteger): NSPoint;
  replacePointAtIndex_withPoint(index: NSInteger, newObj: NSPoint): void;
  movePointAtIndex_toLocation_modifierFlags(index: NSInteger, newLocation: NSPoint, flags: NSEventModifierFlags): void;
  indexOfPointAtLocation(location: NSPoint): NSInteger;
  useSnaps(): boolean;
  pointsToSnap(): MSPointArray;
  bounds(): NSRect;
  convertPointToAbsoluteCoordinates(point: NSPoint): NSPoint;
  handleLinesColor(): NSColor;
  handleLinesPath(): NSBezierPath;
  drawHandleAtPoint_index_selected(p: NSPoint, index: NSInteger, selected: boolean): void;
  drawHandleLines(): void;

  layer(): MSStyledLayer;
  setLayer(layer: MSStyledLayer): void;
  indexForSelectedPoint(): NSInteger;
  setIndexForSelectedPoint(indexForSelectedPoint: NSInteger): void;
  coordinateSpace(): MSLayer;
}

class MSPolygonShapeItemAllocator<T extends MSPolygonShapeItem> extends MSCustomShapeItemAllocator<T> {}
declare class MSPolygonShapeItem extends MSCustomShapeItem {
  alloc<T extends MSPolygonShapeItem>(): MSPolygonShapeItemAllocator<T>;
}

class MSPopoverActionAllocator<T extends MSPopoverAction> extends MSDocumentActionAllocator<T> {}
declare class MSPopoverAction extends MSDocumentAction {
  alloc<T extends MSPopoverAction>(): MSPopoverActionAllocator<T>;
  static popoverClass(): any;
  showPopover(sender: any): void;
  closePopover(): void;
  popoverWillClose(popover: BCPopover): void;

  popoverViewController(): NSViewController;
  popoverVisible(): boolean;
}

class MSPositionInspectorItemAllocator<T extends MSPositionInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSPositionInspectorItem extends MSInspectorItem {
  alloc<T extends MSPositionInspectorItem>(): MSPositionInspectorItemAllocator<T>;
}

class MSPreferencePaneAllocator<T extends MSPreferencePane> extends NSViewControllerAllocator<T> {
  initWithPreferencesController(preferencesController: MSPreferencesController): T;
}
declare class MSPreferencePane extends NSViewController {
  alloc<T extends MSPreferencePane>(): MSPreferencePaneAllocator<T>;
  static identifier(): NSString;
  static title(): NSString;
  static toolbarIcon(): NSImage;
  static nibName(): NSString;
  dismissAlertWindow(alertWindow: NSWindow): void;
  dismissAlertSheet(): void;
  didSwitchToPane(): void;

  preferencesController(): MSPreferencesController;
}

declare interface IMSPreferencePaneSizing {
  preferredSize(): NSSize;
}

class MSPreferencesControllerAllocator<T extends MSPreferencesController> extends NSWindowControllerAllocator<T> {}
declare class MSPreferencesController extends NSWindowController implements INSWindowDelegate {
  alloc<T extends MSPreferencesController>(): MSPreferencesControllerAllocator<T>;
  switchToPaneWithIdentifier(identifier: NSString | string): MSPreferencePane;
  static sharedController(): MSPreferencesController;
  updateWindowFrame(): void;
  dismissAnyAlertSheet(): void;
  existingPaneWithIdentifier(identifier: NSString | string): MSPreferencePane;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;

  currentPreferencePane(): MSPreferencePane;
}

class MSPreferencesPluginInfoAllocator<T extends MSPreferencesPluginInfo> extends NSObjectAllocator<T> {}
declare class MSPreferencesPluginInfo extends NSObject {
  alloc<T extends MSPreferencesPluginInfo>(): MSPreferencesPluginInfoAllocator<T>;
  static pluginInfoWithPluginBundle(pluginBundle: MSPluginBundle): MSPreferencesPluginInfo;
  static pluginInfoWithName(name: NSString | string): MSPreferencesPluginInfo;

  name(): NSString;
  pluginDescription(): NSString;
  attributedTitle(): NSAttributedString;
  icon(): NSImage;
  enableCheckboxTitle(): NSString;
  version(): NSString;
  updateVersionString(): NSString;
  updateAvailable(): boolean;
  isCompatible(): boolean;
  warningString(): NSString;
  namePlusAuthor(): NSString;
  homepage(): NSURL;
  isUpdating(): boolean;
  setIsUpdating(isUpdating: boolean): void;
  suppliesData(): boolean;
  pluginBundle(): MSPluginBundle;
  enabled(): boolean;
  setEnabled(enabled: boolean): void;
}

class MSPresetPickerButtonAllocator<T extends MSPresetPickerButton> extends NSButtonAllocator<T> {}
declare class MSPresetPickerButton extends NSButton {
  alloc<T extends MSPresetPickerButton>(): MSPresetPickerButtonAllocator<T>;
  animateToOrigin(origin: NSPoint): void;
}

class MSPresetPickerPresetButtonAllocator<T extends MSPresetPickerPresetButton> extends MSPresetPickerButtonAllocator<T> {}
declare class MSPresetPickerPresetButton extends MSPresetPickerButton implements INSDraggingSource {
  alloc<T extends MSPresetPickerPresetButton>(): MSPresetPickerPresetButtonAllocator<T>;
  frameConsideringAnimation(): NSRect;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
}

declare interface IMSPresetPickerViewDelegate {
  numberOfPresetsInPickerView(pickerView: MSAssetPickerView): NSUInteger;
  addPresetForPickerView(pickerView: MSAssetPickerView): void;
  pickerView_removePresetAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): void;
  pickerView_didPickPresetAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): void;
  drawContentForCellInPickerView_withFrame_atIndex_inRect(pickerView: MSAssetPickerView, drawFrame: boolean, index: NSUInteger, rect: NSRect): void;
  shouldShowAddPresetButton(pickerView: MSAssetPickerView): boolean;
  pickerViewSupportsDrag_fromIndex(pickerView: MSAssetPickerView, index: NSUInteger): boolean;
  pickerViewSupportsDrop(pickerView: MSAssetPickerView): boolean;
  pickerView_shouldShowMenuForItemAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): boolean;
  pickerView_didDragPresetAtIndex_toIndex(pickerView: MSAssetPickerView, sourceIndex: NSUInteger, destinationIndex: NSUInteger): boolean;
  pickerView_insertPresetFromDragRepresentation_atIndex(view: MSAssetPickerView, representation: any, index: NSUInteger): boolean;
  pickerView_dragRepresentationForItemAtIndex(pickerView: any, index: NSUInteger): any;
  presetPickerFinishedDragging(presetView: MSAssetPickerView): void;
  pickerView_didHoverPresetAtIndex(pickerView: MSAssetPickerView, index: NSInteger): void;
  pickerView_didStopHoverPresetAtIndex(pickerView: MSAssetPickerView, index: NSInteger): void;
  pickerView_tooltipForPresetButtonAtIndex(pickerView: MSAssetPickerView, index: NSUInteger): NSString;
}

class MSPreviewImageCacheAllocator<T extends MSPreviewImageCache> extends NSObjectAllocator<T> {
  initWithSubdirectoryName(subdirectory: NSString | string): T;
}
declare class MSPreviewImageCache extends NSObject {
  alloc<T extends MSPreviewImageCache>(): MSPreviewImageCacheAllocator<T>;
  fetchPreviewImageForDocumentAtURL_maximumPixelSize_handler(documentURL: NSURL, maxPixelSize: CGFloat, handler: MSPreviewImageHandler): void;

  directoryURL(): NSURL;
}

class MSPrintActionAllocator<T extends MSPrintAction> extends MSDocumentActionAllocator<T> {}
declare class MSPrintAction extends MSDocumentAction {
  alloc<T extends MSPrintAction>(): MSPrintActionAllocator<T>;
}

class MSRadialGradientEventHandlerAllocator<T extends MSRadialGradientEventHandler> extends MSGradientEventHandlerAllocator<T> {}
declare class MSRadialGradientEventHandler extends MSGradientEventHandler {
  alloc<T extends MSRadialGradientEventHandler>(): MSRadialGradientEventHandlerAllocator<T>;
  ellipsePoint(): NSPoint;
  setEllipsePoint(point: NSPoint): void;
  ovalPath(): NSBezierPath;
}

class MSRectangleShapeItemAllocator<T extends MSRectangleShapeItem> extends MSCustomShapeItemAllocator<T> {}
declare class MSRectangleShapeItem extends MSCustomShapeItem {
  alloc<T extends MSRectangleShapeItem>(): MSRectangleShapeItemAllocator<T>;
}

class MSReduceFileSizeActionAllocator<T extends MSReduceFileSizeAction> extends MSDocumentActionAllocator<T> {}
declare class MSReduceFileSizeAction extends MSDocumentAction {
  alloc<T extends MSReduceFileSizeAction>(): MSReduceFileSizeActionAllocator<T>;
}

class MSReduceImageSizeActionAllocator<T extends MSReduceImageSizeAction> extends MSDocumentActionAllocator<T> {}
declare class MSReduceImageSizeAction extends MSDocumentAction {
  alloc<T extends MSReduceImageSizeAction>(): MSReduceImageSizeActionAllocator<T>;
  reduceImageSize(sender: any): IBAction;
}

class MSRemoveAllOverridesActionAllocator<T extends MSRemoveAllOverridesAction> extends MSDocumentActionAllocator<T> {}
declare class MSRemoveAllOverridesAction extends MSDocumentAction {
  alloc<T extends MSRemoveAllOverridesAction>(): MSRemoveAllOverridesActionAllocator<T>;
  removeAllOverridesFromSelection(sender: any): IBAction;
}

class MSRemoveFlowActionAllocator<T extends MSRemoveFlowAction> extends MSFlowBaseActionAllocator<T> {}
declare class MSRemoveFlowAction extends MSFlowBaseAction {
  alloc<T extends MSRemoveFlowAction>(): MSRemoveFlowActionAllocator<T>;
  removeFlow(sender: any): IBAction;
}

class MSRenameLayerActionAllocator<T extends MSRenameLayerAction> extends MSDocumentActionAllocator<T> {}
declare class MSRenameLayerAction extends MSDocumentAction {
  alloc<T extends MSRenameLayerAction>(): MSRenameLayerActionAllocator<T>;
  renameLayer(sender: any): IBAction;
}

declare interface IMSReorderingContainerDelegate {
  containerBackground_dragDidReorderChildAtIndex_toIndex(backgroundView: MSReorderingContainerView, fromIndex: NSUInteger, toIndex: NSUInteger): void;
  startingOffsetForStackingContainerBackground(backgroundView: MSReorderingContainerView): CGFloat;
  numberOfReorderableSubviewsForContainerBackground(backgroundView: MSReorderingContainerView): NSUInteger;
}

class MSReorderingContainerViewAllocator<T extends MSReorderingContainerView> extends NSViewAllocator<T> {}
declare class MSReorderingContainerView extends NSView {
  alloc<T extends MSReorderingContainerView>(): MSReorderingContainerViewAllocator<T>;
  reorderSubviewsAnimated(flag: boolean): void;

  delegate(): any;
  setDelegate(delegate: any): void;
}

class MSReorderingViewAllocator<T extends MSReorderingView> extends NSViewAllocator<T> {}
declare class MSReorderingView extends NSView implements INSDraggingSource {
  alloc<T extends MSReorderingView>(): MSReorderingViewAllocator<T>;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;

  deleteAction(): string;
  setDeleteAction(deleteAction: string): void;
  duplicateAction(): string;
  setDuplicateAction(duplicateAction: string): void;
  target(): any;
  setTarget(target: any): void;
  reorderingTag(): NSInteger;
  setReorderingTag(reorderingTag: NSInteger): void;
}

class MSShowReplaceColorSheetActionAllocator<T extends MSShowReplaceColorSheetAction> extends MSDocumentActionAllocator<T> {}
declare class MSShowReplaceColorSheetAction extends MSDocumentAction {
  alloc<T extends MSShowReplaceColorSheetAction>(): MSShowReplaceColorSheetActionAllocator<T>;
  showReplaceColorSheet(sender: any | null): IBAction;
}

class MSReplaceColorActionAllocator<T extends MSReplaceColorAction> extends MSDocumentActionAllocator<T> {}
declare class MSReplaceColorAction extends MSDocumentAction {
  alloc<T extends MSReplaceColorAction>(): MSReplaceColorActionAllocator<T>;
  replaceColor(sender: any): IBAction;
}

declare interface IMSReplaceColorActionDetails {

  ignoreAlphaWhenMatchingOriginalColor(): boolean;
  originalColor(): MSColor;
  replaceAlphaOfOriginalColor(): boolean;
  replacementColor(): MSColor;
}

class MSReplaceColorSheetControllerAllocator<T extends MSReplaceColorSheetController> extends CHSheetControllerAllocator<T> {}
declare class MSReplaceColorSheetController extends CHSheetController implements INSWindowDelegate, INSMenuDelegate, IMSColorInspectorDelegate {
  alloc<T extends MSReplaceColorSheetController>(): MSReplaceColorSheetControllerAllocator<T>;
  pickOriginalColor(sender: any): IBAction;
  pickReplacementColor(sender: any): IBAction;
  toggleIgnoreAlpha(sender: any): IBAction;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;

  cancelButton(): NSButton;
  setCancelButton(cancelButton: NSButton): void;
  ignoreAlphaWhenMatchingOriginalColorButton(): NSButton;
  setIgnoreAlphaWhenMatchingOriginalColorButton(ignoreAlphaWhenMatchingOriginalColorButton: NSButton): void;
  originalColorButton(): MSStylePartPreviewButton;
  setOriginalColorButton(originalColorButton: MSStylePartPreviewButton): void;
  replacementColorButton(): MSStylePartPreviewButton;
  setReplacementColorButton(replacementColorButton: MSStylePartPreviewButton): void;
  keepAlphaOfOriginalColorButton(): NSButton;
  setKeepAlphaOfOriginalColorButton(keepAlphaOfOriginalColorButton: NSButton): void;
  replacementColorPopoverDismissingView(): MSPopoverDismisserView;
  setReplacementColorPopoverDismissingView(replacementColorPopoverDismissingView: MSPopoverDismisserView): void;
  replaceButton(): NSButton;
  setReplaceButton(replaceButton: NSButton): void;
}

class MSReplaceFontCellViewAllocator<T extends MSReplaceFontCellView> extends NSTableCellViewAllocator<T> {}
declare class MSReplaceFontCellView extends NSTableCellView {
  alloc<T extends MSReplaceFontCellView>(): MSReplaceFontCellViewAllocator<T>;

  fontFamilyButton(): NSButton;
  setFontFamilyButton(fontFamilyButton: NSButton): void;
  fontWeightPopUpButton(): NSPopUpButton;
  setFontWeightPopUpButton(fontWeightPopUpButton: NSPopUpButton): void;
}

class MSReplaceFontsActionAllocator<T extends MSReplaceFontsAction> extends MSDocumentActionAllocator<T> {}
declare class MSReplaceFontsAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSReplaceFontsAction>(): MSReplaceFontsActionAllocator<T>;
  replaceMissingFonts(sender: any): IBAction;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSReplaceFontsSheetAllocator<T extends MSReplaceFontsSheet> extends CHSheetControllerAllocator<T> {}
declare class MSReplaceFontsSheet extends CHSheetController {
  alloc<T extends MSReplaceFontsSheet>(): MSReplaceFontsSheetAllocator<T>;
}

class MSReplaceImageActionAllocator<T extends MSReplaceImageAction> extends MSDocumentActionAllocator<T> {}
declare class MSReplaceImageAction extends MSDocumentAction {
  alloc<T extends MSReplaceImageAction>(): MSReplaceImageActionAllocator<T>;
  replaceImage(sender: any): IBAction;
}

class MSReplaceWithSymbolActionAllocator<T extends MSReplaceWithSymbolAction> extends MSSharedSymbolActionAllocator<T> {}
declare class MSReplaceWithSymbolAction extends MSSharedSymbolAction {
  alloc<T extends MSReplaceWithSymbolAction>(): MSReplaceWithSymbolActionAllocator<T>;
}

class MSReplaceWithSymbolMenuBuilderAllocator<T extends MSReplaceWithSymbolMenuBuilder> extends MSMenuBuilderAllocator<T> {}
declare class MSReplaceWithSymbolMenuBuilder extends MSMenuBuilder {
  alloc<T extends MSReplaceWithSymbolMenuBuilder>(): MSReplaceWithSymbolMenuBuilderAllocator<T>;
  updateMenuItem_forDocument(item: NSMenuItem, document: MSDocument): void;
}

class MSReplacementFontPickerViewControllerAllocator<T extends MSReplacementFontPickerViewController> extends MSFontFamilyPickerViewControllerAllocator<T> {}
declare class MSReplacementFontPickerViewController extends MSFontFamilyPickerViewController {
  alloc<T extends MSReplacementFontPickerViewController>(): MSReplacementFontPickerViewControllerAllocator<T>;
}

class MSResetSharedStyleActionAllocator<T extends MSResetSharedStyleAction> extends MSBaseSharedObjectActionAllocator<T> {}
declare class MSResetSharedStyleAction extends MSBaseSharedObjectAction {
  alloc<T extends MSResetSharedStyleAction>(): MSResetSharedStyleActionAllocator<T>;
  resetSharedStyle(sender: any): IBAction;
}

class MSResetSymbolSizeActionAllocator<T extends MSResetSymbolSizeAction> extends MSDocumentActionAllocator<T> {}
declare class MSResetSymbolSizeAction extends MSDocumentAction {
  alloc<T extends MSResetSymbolSizeAction>(): MSResetSymbolSizeActionAllocator<T>;
  resetSymbolSize(sender: any): IBAction;
}

class MSResizeArtboardToFitActionAllocator<T extends MSResizeArtboardToFitAction> extends MSDocumentActionAllocator<T> {}
declare class MSResizeArtboardToFitAction extends MSDocumentAction {
  alloc<T extends MSResizeArtboardToFitAction>(): MSResizeArtboardToFitActionAllocator<T>;
  resizeArtboardToFit(sender: any): IBAction;
}

class MSResizeGestureRecognizerAllocator<T extends MSResizeGestureRecognizer> extends MSDragGestureRecognizerAllocator<T> {}
declare class MSResizeGestureRecognizer extends MSDragGestureRecognizer {
  alloc<T extends MSResizeGestureRecognizer>(): MSResizeGestureRecognizerAllocator<T>;

  maySnap(): boolean;
  shouldResizeFromCenter(): boolean;
  constrainProportions(): boolean;
}

class MSResizeInspectorItemAllocator<T extends MSResizeInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSResizeInspectorItem extends MSInspectorItem {
  alloc<T extends MSResizeInspectorItem>(): MSResizeInspectorItemAllocator<T>;
}

class MSResizeInspectorSectionAllocator<T extends MSResizeInspectorSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSResizeInspectorSection extends MSBaseInspectorSection {
  alloc<T extends MSResizeInspectorSection>(): MSResizeInspectorSectionAllocator<T>;
}

class MSResizingPreviewAllocator<T extends MSResizingPreview> extends NSViewAllocator<T> {}
declare class MSResizingPreview extends NSView {
  alloc<T extends MSResizingPreview>(): MSResizingPreviewAllocator<T>;

  previewResizingOptions(): NSAutoresizingMaskOptions;
  setPreviewResizingOptions(previewResizingOptions: NSAutoresizingMaskOptions): void;
}

class MSResizingPreviewContainerAllocator<T extends MSResizingPreviewContainer> extends NSViewAllocator<T> {}
declare class MSResizingPreviewContainer extends NSView {
  alloc<T extends MSResizingPreviewContainer>(): MSResizingPreviewContainerAllocator<T>;

  fixTop(): boolean;
  setFixTop(fixTop: boolean): void;
  fixBottom(): boolean;
  setFixBottom(fixBottom: boolean): void;
  fixLeft(): boolean;
  setFixLeft(fixLeft: boolean): void;
  fixRight(): boolean;
  setFixRight(fixRight: boolean): void;
  fixWidth(): boolean;
  setFixWidth(fixWidth: boolean): void;
  fixHeight(): boolean;
  setFixHeight(fixHeight: boolean): void;
  animate(): boolean;
  setAnimate(animate: boolean): void;
}

class MSRevealPluginsActionAllocator<T extends MSRevealPluginsAction> extends MSActionAllocator<T> {}
declare class MSRevealPluginsAction extends MSAction {
  alloc<T extends MSRevealPluginsAction>(): MSRevealPluginsActionAllocator<T>;
  revealPlugins(sender: any): IBAction;
}

class MSReversePathActionAllocator<T extends MSReversePathAction> extends MSDocumentActionAllocator<T> {}
declare class MSReversePathAction extends MSDocumentAction {
  alloc<T extends MSReversePathAction>(): MSReversePathActionAllocator<T>;
  reversePath(sender: any): IBAction;
}

class MSRightOffsetHoverButtonCellAllocator<T extends MSRightOffsetHoverButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSRightOffsetHoverButtonCell extends MSHoverButtonCell {
  alloc<T extends MSRightOffsetHoverButtonCell>(): MSRightOffsetHoverButtonCellAllocator<T>;
}

class MSRotateActionAllocator<T extends MSRotateAction> extends MSEventHandlerActionAllocator<T> {}
declare class MSRotateAction extends MSEventHandlerAction {
  alloc<T extends MSRotateAction>(): MSRotateActionAllocator<T>;
  rotate(sender: any): IBAction;
}

class MSRotateClockwiseActionAllocator<T extends MSRotateClockwiseAction> extends MSEventHandlerActionAllocator<T> {}
declare class MSRotateClockwiseAction extends MSEventHandlerAction {
  alloc<T extends MSRotateClockwiseAction>(): MSRotateClockwiseActionAllocator<T>;
  rotate90C(sender: any): IBAction;
}

class MSRotateCounterclockwiseActionAllocator<T extends MSRotateCounterclockwiseAction> extends MSEventHandlerActionAllocator<T> {}
declare class MSRotateCounterclockwiseAction extends MSEventHandlerAction {
  alloc<T extends MSRotateCounterclockwiseAction>(): MSRotateCounterclockwiseActionAllocator<T>;
  rotate90CC(sender: any): IBAction;
}

class MSRotateEventHandlerAllocator<T extends MSRotateEventHandler> extends MSNormalBaseEventHandlerAllocator<T> {}
declare class MSRotateEventHandler extends MSNormalBaseEventHandler implements INSTouchBarDelegate {
  alloc<T extends MSRotateEventHandler>(): MSRotateEventHandlerAllocator<T>;
  static cursorForDegrees(degrees: NSInteger): NSCursor;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  exitOnMouseUp(): boolean;
  setExitOnMouseUp(exitOnMouseUp: boolean): void;
  disableMoving(): boolean;
  setDisableMoving(disableMoving: boolean): void;
  rotationCenterPoint(): NSPoint;
  setRotationCenterPoint(rotationCenterPoint: NSPoint): void;
  rotationItems(): NSArray<any>;
}

class MSRotationBarAllocator<T extends MSRotationBar> extends NSControlAllocator<T> {}
declare class MSRotationBar extends NSControl {
  alloc<T extends MSRotationBar>(): MSRotationBarAllocator<T>;

  rotation(): CGFloat;
  setRotation(rotation: CGFloat): void;
}

class MSRotationGestureInterpreterAllocator<T extends MSRotationGestureInterpreter> extends NSObjectAllocator<T> {}
declare class MSRotationGestureInterpreter extends NSObject {
  alloc<T extends MSRotationGestureInterpreter>(): MSRotationGestureInterpreterAllocator<T>;
  updateWithDragRecognizer(recognizer: MSDragGestureRecognizer): IBAction;
  updateWithLocation(location: NSPoint): void;
  rotationInLayer(layer: MSLayer | null): CGFloat;
  rotationInDegreesInLayer(layer: MSLayer | null): CGFloat;

  centerPoint(): NSPoint;
  setCenterPoint(centerPoint: NSPoint): void;
}

class MSRoundToPixelActionAllocator<T extends MSRoundToPixelAction> extends MSDocumentActionAllocator<T> {}
declare class MSRoundToPixelAction extends MSDocumentAction {
  alloc<T extends MSRoundToPixelAction>(): MSRoundToPixelActionAllocator<T>;
  roundToPixel(sender: any): IBAction;
}

class MSResetOriginActionAllocator<T extends MSResetOriginAction> extends MSDocumentActionAllocator<T> {}
declare class MSResetOriginAction extends MSDocumentAction {
  alloc<T extends MSResetOriginAction>(): MSResetOriginActionAllocator<T>;
  resetRulerOrigin(sender: any): IBAction;
}

class MSToggleRulerDragLockingActionAllocator<T extends MSToggleRulerDragLockingAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleRulerDragLockingAction extends MSDocumentAction {
  alloc<T extends MSToggleRulerDragLockingAction>(): MSToggleRulerDragLockingActionAllocator<T>;
  toggleRulerDragLocking(sender: any): IBAction;
}

class MSRulerBlockCellAllocator<T extends MSRulerBlockCell> extends MSTintedHoverButtonCellAllocator<T> {}
declare class MSRulerBlockCell extends MSTintedHoverButtonCell {
  alloc<T extends MSRulerBlockCell>(): MSRulerBlockCellAllocator<T>;
}

class MSRulerViewAllocator<T extends MSRulerView> extends NSViewAllocator<T> {}
declare class MSRulerView extends NSView {
  alloc<T extends MSRulerView>(): MSRulerViewAllocator<T>;
  refreshGuideInDrawViewAtIndex(anIndex: NSUInteger): void;
  refreshGuideInDrawViewAtPosition(line: CGFloat): void;
  mouseEventToPoint(anEvent: NSEvent): NSPoint;
  document(): MSDocument;
  baseLine(): CGFloat;
  baseLineIncludingScrollOrigin(includeOrigin: boolean): CGFloat;
  drawGuidesOnCanvasInRect(aRect: NSRect): void;
  bezierPathForLineAtPosition_inRect(line: CGFloat, aRect: NSRect): NSBezierPath;
  occupiedRegionForRect_withOffset_zoom(rect: NSRect, left: NSInteger, zoom: CGFloat): NSBezierPath;
  scrollOrigin(): NSPoint;
  zoomValue(): CGFloat;
  rulerLength(): NSInteger;
  refreshTemporaryRulerGuide(): void;
  relevantAxisForPoint(aPoint: NSPoint): CGFloat;
  otherAxisForPoint(aPoint: NSPoint): CGFloat;
  setResizeCursor(): void;
  prepareRulerViewLayer(dirtyRect: NSRect): void;

  rulerData(): MSRulerData;
  setRulerData(rulerData: MSRulerData): void;
  document(): MSDocument;
  setDocument(document: MSDocument): void;
  contentView(): MSContentDrawView;
  setContentView(contentView: MSContentDrawView): void;
  mouseDidDrag(): boolean;
  setMouseDidDrag(mouseDidDrag: boolean): void;
  mouseDownPoint(): NSPoint;
  setMouseDownPoint(mouseDownPoint: NSPoint): void;
  axis(): BCAxis;
  setAxis(axis: BCAxis): void;
  temporaryRulerGuide(): CGFloat;
  setTemporaryRulerGuide(temporaryRulerGuide: CGFloat): void;
  static rulerDraggingLocked(): boolean;
  static setRulerDraggingLocked(rulerDraggingLocked: boolean): void;
}

declare enum MSLineDrawingOptions {
  MSShortLine = 0x01,
  MSDarkLine = 0x02,
}

declare enum MSMetricsDrawingOptions {
  MSMetricsDrawingLeft = 1,
  MSMetricsDrawingRight = 2,
}

class MSRulerViewLayerAllocator<T extends MSRulerViewLayer> extends CALayerAllocator<T> {}
declare class MSRulerViewLayer extends CALayer {
  alloc<T extends MSRulerViewLayer>(): MSRulerViewLayerAllocator<T>;
  drawBackground(): void;
  drawBackgroundForLabel_atPoint(string: NSString | string, p: NSPoint): void;

  axis(): BCAxis;
  setAxis(axis: BCAxis): void;
  formatter(): NSNumberFormatter;
  setFormatter(formatter: NSNumberFormatter): void;
  snapColor(): NSColor;
  setSnapColor(snapColor: NSColor): void;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
  baseLine(): CGFloat;
  setBaseLine(baseLine: CGFloat): void;
  occupiedRegion(): NSRect;
  setOccupiedRegion(occupiedRegion: NSRect): void;
  guides(): NSArray<any>;
  setGuides(guides: NSArray<any> | any[]): void;
  shouldDrawGuides(): boolean;
  setShouldDrawGuides(shouldDrawGuides: boolean): void;
  parentView(): NSView;
  setParentView(parentView: NSView): void;
}

class MSRunCustomScriptActionAllocator<T extends MSRunCustomScriptAction> extends MSActionAllocator<T> {}
declare class MSRunCustomScriptAction extends MSAction {
  alloc<T extends MSRunCustomScriptAction>(): MSRunCustomScriptActionAllocator<T>;
  runCustomScript(sender: any): IBAction;
}

class MSRunCustomScriptSheetAllocator<T extends MSRunCustomScriptSheet> extends CHSheetControllerAllocator<T> {}
declare class MSRunCustomScriptSheet extends CHSheetController implements INSTextViewDelegate {
  alloc<T extends MSRunCustomScriptSheet>(): MSRunCustomScriptSheetAllocator<T>;
  saveAction(sender: any): IBAction;
  scriptingMenuAction(sender: any): IBAction;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;

  logField(): NSTextView;
  setLogField(logField: NSTextView): void;
}

class MSRunLastScriptActionAllocator<T extends MSRunLastScriptAction> extends MSActionAllocator<T> {}
declare class MSRunLastScriptAction extends MSAction {
  alloc<T extends MSRunLastScriptAction>(): MSRunLastScriptActionAllocator<T>;
  runLastScript(sender: any): IBAction;
}

class MSRunPluginActionAllocator<T extends MSRunPluginAction> extends MSActionAllocator<T> {}
declare class MSRunPluginAction extends MSAction {
  alloc<T extends MSRunPluginAction>(): MSRunPluginActionAllocator<T>;
  runPlugin(sender: any): IBAction;
}

class MSSaveAsTemplateActionAllocator<T extends MSSaveAsTemplateAction> extends MSDocumentActionAllocator<T> {}
declare class MSSaveAsTemplateAction extends MSDocumentAction {
  alloc<T extends MSSaveAsTemplateAction>(): MSSaveAsTemplateActionAllocator<T>;
  saveAsTemplate(sender: any): IBAction;
}

class MSSaveAsTemplateSheetAllocator<T extends MSSaveAsTemplateSheet> extends CHSheetControllerAllocator<T> {}
declare class MSSaveAsTemplateSheet extends CHSheetController {
  alloc<T extends MSSaveAsTemplateSheet>(): MSSaveAsTemplateSheetAllocator<T>;
  static runForDocument_completionBlock(document: MSDocument, block: MSSaveAsTemplateSheetCompletionBlock): any;

  inputCompletionBlock(): MSSaveAsTemplateSheetCompletionBlock;
  setInputCompletionBlock(inputCompletionBlock: MSSaveAsTemplateSheetCompletionBlock): void;
  inputField(): NSTextField;
  setInputField(inputField: NSTextField): void;
}

class MSScaleActionAllocator<T extends MSScaleAction> extends MSDocumentActionAllocator<T> {}
declare class MSScaleAction extends MSDocumentAction {
  alloc<T extends MSScaleAction>(): MSScaleActionAllocator<T>;
  scale(sender: any): IBAction;
}

class MSScaleSheetAllocator<T extends MSScaleSheet> extends MSCanvasUpdatingSheetAllocator<T> {}
declare class MSScaleSheet extends MSCanvasUpdatingSheet {
  alloc<T extends MSScaleSheet>(): MSScaleSheetAllocator<T>;
}

class MSScissorsEventHandlerAllocator<T extends MSScissorsEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSScissorsEventHandler extends MSEventHandler {
  alloc<T extends MSScissorsEventHandler>(): MSScissorsEventHandlerAllocator<T>;
}

class MSScriptDocumentAllocator<T extends MSScriptDocument> extends NSDocumentAllocator<T> {}
declare class MSScriptDocument extends NSDocument {
  alloc<T extends MSScriptDocument>(): MSScriptDocumentAllocator<T>;
}

class MSScrollViewAllocator<T extends MSScrollView> extends NSScrollViewAllocator<T> {}
declare class MSScrollView extends NSScrollView {
  alloc<T extends MSScrollView>(): MSScrollViewAllocator<T>;

  allowsScrolling(): boolean;
  setAllowsScrolling(allowsScrolling: boolean): void;
}

class MSSectionBackgroundSeparatorViewAllocator<T extends MSSectionBackgroundSeparatorView> extends NSViewAllocator<T> {}
declare class MSSectionBackgroundSeparatorView extends NSView {
  alloc<T extends MSSectionBackgroundSeparatorView>(): MSSectionBackgroundSeparatorViewAllocator<T>;
  static separator(): MSSectionBackgroundSeparatorView;
  static separatorWithInsets(insets: NSEdgeInsets): MSSectionBackgroundSeparatorView;
}

class MSColorInspectorSeparatorViewAllocator<T extends MSColorInspectorSeparatorView> extends MSSectionBackgroundSeparatorViewAllocator<T> {}
declare class MSColorInspectorSeparatorView extends MSSectionBackgroundSeparatorView {
  alloc<T extends MSColorInspectorSeparatorView>(): MSColorInspectorSeparatorViewAllocator<T>;
}

class MSFlatSectionBackgroundSeparatorViewAllocator<T extends MSFlatSectionBackgroundSeparatorView> extends MSSectionBackgroundSeparatorViewAllocator<T> {}
declare class MSFlatSectionBackgroundSeparatorView extends MSSectionBackgroundSeparatorView {
  alloc<T extends MSFlatSectionBackgroundSeparatorView>(): MSFlatSectionBackgroundSeparatorViewAllocator<T>;
}

class MSSubtleSectionSeparatorViewAllocator<T extends MSSubtleSectionSeparatorView> extends MSSectionBackgroundSeparatorViewAllocator<T> {}
declare class MSSubtleSectionSeparatorView extends MSSectionBackgroundSeparatorView {
  alloc<T extends MSSubtleSectionSeparatorView>(): MSSubtleSectionSeparatorViewAllocator<T>;
}

class MSSectionBackgroundViewAllocator<T extends MSSectionBackgroundView> extends NSViewAllocator<T> {}
declare class MSSectionBackgroundView extends NSView {
  alloc<T extends MSSectionBackgroundView>(): MSSectionBackgroundViewAllocator<T>;
  static sectionBackgroundWithController(controller: NSViewController): MSSectionBackgroundView;
  recalculateHeight(): void;
  stackSubviews(): void;
}

class MSWhiteHeaderViewAllocator<T extends MSWhiteHeaderView> extends NSViewAllocator<T> {}
declare class MSWhiteHeaderView extends NSView {
  alloc<T extends MSWhiteHeaderView>(): MSWhiteHeaderViewAllocator<T>;
}

class MSSegmentedToolbarItemAllocator<T extends MSSegmentedToolbarItem> extends NSToolbarItemGroupAllocator<T> {
  initWithAction_forToolbar(action: MSActionGroup, forToolbar: boolean): T;
}
declare class MSSegmentedToolbarItem extends NSToolbarItemGroup {
  alloc<T extends MSSegmentedToolbarItem>(): MSSegmentedToolbarItemAllocator<T>;
  validateWithAction(action: MSActionGroup): void;
}

class MSSelectAllArtboardsActionAllocator<T extends MSSelectAllArtboardsAction> extends MSDocumentActionAllocator<T> {}
declare class MSSelectAllArtboardsAction extends MSDocumentAction {
  alloc<T extends MSSelectAllArtboardsAction>(): MSSelectAllArtboardsActionAllocator<T>;
  selectAllArtboards(sender: any): IBAction;
}

class MSSelectVectorHandleGestureRecognizerAllocator<T extends MSSelectVectorHandleGestureRecognizer> extends MSGestureRecognizerAllocator<T> {}
declare class MSSelectVectorHandleGestureRecognizer extends MSGestureRecognizer {
  alloc<T extends MSSelectVectorHandleGestureRecognizer>(): MSSelectVectorHandleGestureRecognizerAllocator<T>;

  toggleSelection(): boolean;
  modifierFlags(): NSEventModifierFlags;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSSelectVectorHandleGestureRecognizerDelegate {
  gestureRecognizerShouldDelaySelectionUntilMouseUp(sender: MSSelectVectorHandleGestureRecognizer): boolean;
}

class MSSendToSymbolsPageActionAllocator<T extends MSSendToSymbolsPageAction> extends MSDocumentActionAllocator<T> {}
declare class MSSendToSymbolsPageAction extends MSDocumentAction {
  alloc<T extends MSSendToSymbolsPageAction>(): MSSendToSymbolsPageActionAllocator<T>;
  sendSymbolToSymbolsPage(sender: any): IBAction;
}

class MSSeparatorInspectorItemAllocator<T extends MSSeparatorInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSSeparatorInspectorItem extends MSInspectorItem {
  alloc<T extends MSSeparatorInspectorItem>(): MSSeparatorInspectorItemAllocator<T>;
}

class MSSubtleSeparatorInspectorItemAllocator<T extends MSSubtleSeparatorInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSSubtleSeparatorInspectorItem extends MSInspectorItem {
  alloc<T extends MSSubtleSeparatorInspectorItem>(): MSSubtleSeparatorInspectorItemAllocator<T>;
}

class MSShadowInspectorViewControllerAllocator<T extends MSShadowInspectorViewController> extends MSColorStylePartInspectorViewControllerAllocator<T> {}
declare class MSShadowInspectorViewController extends MSColorStylePartInspectorViewController {
  alloc<T extends MSShadowInspectorViewController>(): MSShadowInspectorViewControllerAllocator<T>;

  type(): NSString;
  setType(type: NSString | string): void;
}

class MSShapeActionAllocator<T extends MSShapeAction> extends MSDocumentActionAllocator<T> {}
declare class MSShapeAction extends MSDocumentAction {
  alloc<T extends MSShapeAction>(): MSShapeActionAllocator<T>;
}

class MSBaseShapeActionAllocator<T extends MSBaseShapeAction> extends MSBaseInsertActionAllocator<T> {}
declare class MSBaseShapeAction extends MSBaseInsertAction {
  alloc<T extends MSBaseShapeAction>(): MSBaseShapeActionAllocator<T>;
  static insertShapeLayer_identifier_document(shapeOrPath: any, identifier: NSString | string, doc: MSDocument): any;
  prototypeLayer(): MSShapePathLayer;
}

class MSRectangleShapeActionAllocator<T extends MSRectangleShapeAction> extends MSBaseShapeActionAllocator<T> {}
declare class MSRectangleShapeAction extends MSBaseShapeAction {
  alloc<T extends MSRectangleShapeAction>(): MSRectangleShapeActionAllocator<T>;
}

class MSOvalShapeActionAllocator<T extends MSOvalShapeAction> extends MSBaseShapeActionAllocator<T> {}
declare class MSOvalShapeAction extends MSBaseShapeAction {
  alloc<T extends MSOvalShapeAction>(): MSOvalShapeActionAllocator<T>;
}

class MSRoundedRectangleShapeActionAllocator<T extends MSRoundedRectangleShapeAction> extends MSBaseShapeActionAllocator<T> {}
declare class MSRoundedRectangleShapeAction extends MSBaseShapeAction {
  alloc<T extends MSRoundedRectangleShapeAction>(): MSRoundedRectangleShapeActionAllocator<T>;
}

class MSStarShapeActionAllocator<T extends MSStarShapeAction> extends MSBaseShapeActionAllocator<T> {}
declare class MSStarShapeAction extends MSBaseShapeAction {
  alloc<T extends MSStarShapeAction>(): MSStarShapeActionAllocator<T>;
}

class MSPolygonShapeActionAllocator<T extends MSPolygonShapeAction> extends MSBaseShapeActionAllocator<T> {}
declare class MSPolygonShapeAction extends MSBaseShapeAction {
  alloc<T extends MSPolygonShapeAction>(): MSPolygonShapeActionAllocator<T>;
}

class MSTriangleShapeActionAllocator<T extends MSTriangleShapeAction> extends MSBaseShapeActionAllocator<T> {}
declare class MSTriangleShapeAction extends MSBaseShapeAction {
  alloc<T extends MSTriangleShapeAction>(): MSTriangleShapeActionAllocator<T>;
}

class MSShapeEventHandlerAllocator<T extends MSShapeEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSShapeEventHandler extends MSEventHandler implements INSTextDelegate, INSMenuDelegate, IMSGestureRecognizerDelegate {
  alloc<T extends MSShapeEventHandler>(): MSShapeEventHandlerAllocator<T>;
  forceSelection(sender: NSButton): IBAction;
  pathDidOpenOrClose(): void;
  refreshCloseOrOpenPathUI(): void;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  gestureRecognizer_shouldAttemptToRecognizeAtPoint_modifierFlags(gestureRecognizer: MSGestureRecognizer, point: NSPoint, flags: NSEventModifierFlags): boolean;
  textShouldBeginEditing(textObject: NSText): boolean;
  textShouldEndEditing(textObject: NSText): boolean;
  textDidBeginEditing(notification: NSNotification): void;
  textDidEndEditing(notification: NSNotification): void;
  textDidChange(notification: NSNotification): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  gestureRecognizer_shouldAttemptToRecognizeAtPoint_modifierFlags(gestureRecognizer: MSGestureRecognizer, point: NSPoint, flags: NSEventModifierFlags): boolean;

  layers(): NSArray<any>;
  canvasHandler(): MSVectorCanvas;
  inspectorViewController(): MSEditShapeInspectorViewController;
  pathController(): MSPathController;
  editingBehavior(): MSShapeEditingBehavior;
  setEditingBehavior(editingBehavior: MSShapeEditingBehavior): void;
}

class MSSharedObjectActionAllocator<T extends MSSharedObjectAction> extends MSDocumentActionAllocator<T> {}
declare class MSSharedObjectAction extends MSDocumentAction implements INSMenuDelegate {
  alloc<T extends MSSharedObjectAction>(): MSSharedObjectActionAllocator<T>;
  sortedObjectMenuItemsForMenu(menu: NSMenu): NSArray<any>;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;

  sharedObjectName(): NSString;
}

class MSSharedObjectViewAllocator<T extends MSSharedObjectView> extends NSViewAllocator<T> {}
declare class MSSharedObjectView extends NSView {
  alloc<T extends MSSharedObjectView>(): MSSharedObjectViewAllocator<T>;

  sharedObject(): MSShareableObject;
  setSharedObject(sharedObject: MSShareableObject): void;
  label(): NSString;
  setLabel(label: NSString | string): void;
  labelColor(): NSColor;
  setLabelColor(labelColor: NSColor): void;
  labelBackgroundColor(): NSColor;
  setLabelBackgroundColor(labelBackgroundColor: NSColor): void;
  borders(): NSUInteger;
  setBorders(borders: NSUInteger): void;
  hasShadow(): boolean;
  setHasShadow(hasShadow: boolean): void;
}

class MSSharedStylesInspectorItemAllocator<T extends MSSharedStylesInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSSharedStylesInspectorItem extends MSInspectorItem implements INSMenuDelegate {
  alloc<T extends MSSharedStylesInspectorItem>(): MSSharedStylesInspectorItemAllocator<T>;
  beginRenameSharedObject_completionBlock(sharedObject: MSSharedObject, block: MSRenameSharedObjectBlock): void;
  refreshIfNecessary(treeDiff: MSTreeDiff): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
}

class MSSharedSymbolActionAllocator<T extends MSSharedSymbolAction> extends MSSharedObjectActionAllocator<T> {}
declare class MSSharedSymbolAction extends MSSharedObjectAction {
  alloc<T extends MSSharedSymbolAction>(): MSSharedSymbolActionAllocator<T>;

  menuBuilder(): MSForeignObjectMenuBuilder;
}

class MSShowOnlineHelpActionAllocator<T extends MSShowOnlineHelpAction> extends MSActionAllocator<T> {}
declare class MSShowOnlineHelpAction extends MSAction {
  alloc<T extends MSShowOnlineHelpAction>(): MSShowOnlineHelpActionAllocator<T>;
  showOnlineHelp(sender: any): IBAction;
}

class MSShowReleaseNotesWindowActionAllocator<T extends MSShowReleaseNotesWindowAction> extends MSActionAllocator<T> {}
declare class MSShowReleaseNotesWindowAction extends MSAction {
  alloc<T extends MSShowReleaseNotesWindowAction>(): MSShowReleaseNotesWindowActionAllocator<T>;
  showReleaseNotesWindow(sender: any): IBAction;
}

class MSShowSupportPageActionAllocator<T extends MSShowSupportPageAction> extends MSActionAllocator<T> {}
declare class MSShowSupportPageAction extends MSAction {
  alloc<T extends MSShowSupportPageAction>(): MSShowSupportPageActionAllocator<T>;
  showSupportPage(sender: any): IBAction;
}

class MSSizeInspectorItemAllocator<T extends MSSizeInspectorItem> extends MSBaseSizeInspectorItemAllocator<T> {}
declare class MSSizeInspectorItem extends MSBaseSizeInspectorItem {
  alloc<T extends MSSizeInspectorItem>(): MSSizeInspectorItemAllocator<T>;
}

class MSSliceDragViewAllocator<T extends MSSliceDragView> extends NSViewAllocator<T> {}
declare class MSSliceDragView extends NSView implements INSDraggingSource, INSPasteboardWriting {
  alloc<T extends MSSliceDragView>(): MSSliceDragViewAllocator<T>;
  setExportableLayer_previewCompletionBlock(layer: MSLayer, completionBlock: dispatch_block_t): void;
  sizeToFit(): void;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
  draggingSession_sourceOperationMaskForDraggingContext(session: NSDraggingSession, context: NSDraggingContext): NSDragOperation;
  draggingSession_willBeginAtPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_movedToPoint(session: NSDraggingSession, screenPoint: NSPoint): void;
  draggingSession_endedAtPoint_operation(session: NSDraggingSession, screenPoint: NSPoint, operation: NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(session: NSDraggingSession): boolean;
  writableTypesForPasteboard(pasteboard: NSPasteboard): NSArray<any>;
  writingOptionsForType_pasteboard(type: NSPasteboardType, pasteboard: NSPasteboard): NSPasteboardWritingOptions;
  pasteboardPropertyListForType(type: NSPasteboardType): any;
}

class MSSliceExportOptionsAllocator<T extends MSSliceExportOptions> extends NSViewControllerAllocator<T> {}
declare class MSSliceExportOptions extends NSViewController {
  alloc<T extends MSSliceExportOptions>(): MSSliceExportOptionsAllocator<T>;
  static exportOptionsForRequests(requests: NSArray<any> | any[]): MSSliceExportOptions;
}

class MSSliceExportPropertiesInspectorItemAllocator<T extends MSSliceExportPropertiesInspectorItem> extends MSInspectorItemAllocator<T> {}
declare class MSSliceExportPropertiesInspectorItem extends MSInspectorItem implements IMSLayerChangeObserver {
  alloc<T extends MSSliceExportPropertiesInspectorItem>(): MSSliceExportPropertiesInspectorItemAllocator<T>;
  layerDidChange(layer: MSLayer): void;
  layerDidChange(layer: MSLayer): void;
}

class MSSmallButtonCellAllocator<T extends MSSmallButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSSmallButtonCell extends NSButtonCell {
  alloc<T extends MSSmallButtonCell>(): MSSmallButtonCellAllocator<T>;
}

class MSSmartRotateActionAllocator<T extends MSSmartRotateAction> extends MSDocumentActionAllocator<T> {}
declare class MSSmartRotateAction extends MSDocumentAction {
  alloc<T extends MSSmartRotateAction>(): MSSmartRotateActionAllocator<T>;
  smartRotate(sender: any): IBAction;
}

class MSSmartRotateEventHandlerAllocator<T extends MSSmartRotateEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSSmartRotateEventHandler extends MSEventHandler {
  alloc<T extends MSSmartRotateEventHandler>(): MSSmartRotateEventHandlerAllocator<T>;

  numberOfRepetitions(): NSUInteger;
  setNumberOfRepetitions(numberOfRepetitions: NSUInteger): void;
}

class MSSmartRotateSheetAllocator<T extends MSSmartRotateSheet> extends CHSheetControllerAllocator<T> {}
declare class MSSmartRotateSheet extends CHSheetController {
  alloc<T extends MSSmartRotateSheet>(): MSSmartRotateSheetAllocator<T>;

  explanationLabel(): NSTextField;
  setExplanationLabel(explanationLabel: NSTextField): void;
  numberOfCopies(): NSInteger;
  setNumberOfCopies(numberOfCopies: NSInteger): void;
}

class MSSpecialLayerViewControllerAllocator<T extends MSSpecialLayerViewController> extends NSViewControllerAllocator<T> {}
declare class MSSpecialLayerViewController extends NSViewController implements IMSInspectorSection, INSMenuDelegate {
  alloc<T extends MSSpecialLayerViewController>(): MSSpecialLayerViewControllerAllocator<T>;
  changeTextLayerFont(sender: any): IBAction;
  valuesPossiblyChanged(): void;
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;

  layers(): NSArray<any>;
  setLayers(layers: NSArray<any> | any[]): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

class MSSplitViewAllocator<T extends MSSplitView> extends NSSplitViewAllocator<T> {}
declare class MSSplitView extends NSSplitView {
  alloc<T extends MSSplitView>(): MSSplitViewAllocator<T>;
}

class MSSidebarSplitViewAllocator<T extends MSSidebarSplitView> extends NSSplitViewAllocator<T> {}
declare class MSSidebarSplitView extends NSSplitView {
  alloc<T extends MSSidebarSplitView>(): MSSidebarSplitViewAllocator<T>;
}

class MSSquareButtonCellAllocator<T extends MSSquareButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSSquareButtonCell extends NSButtonCell {
  alloc<T extends MSSquareButtonCell>(): MSSquareButtonCellAllocator<T>;
}

class MSStackViewAllocator<T extends MSStackView> extends NSViewAllocator<T> {}
declare class MSStackView extends NSView {
  alloc<T extends MSStackView>(): MSStackViewAllocator<T>;
  stack(sender: any): IBAction;

  autoupdatesMaximumHeight(): boolean;
  setAutoupdatesMaximumHeight(autoupdatesMaximumHeight: boolean): void;
  maximumHeight(): NSInteger;
  setMaximumHeight(maximumHeight: NSInteger): void;
  minimumHeight(): CGFloat;
  setMinimumHeight(minimumHeight: CGFloat): void;
  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  keyResponder(): any;
  setKeyResponder(keyResponder: any): void;
}

class MSStackViewScrollViewAllocator<T extends MSStackViewScrollView> extends NSScrollViewAllocator<T> {}
declare class MSStackViewScrollView extends NSScrollView {
  alloc<T extends MSStackViewScrollView>(): MSStackViewScrollViewAllocator<T>;
}

class MSStandardInspectorViewControllersAllocator<T extends MSStandardInspectorViewControllers> extends NSObjectAllocator<T> {}
declare class MSStandardInspectorViewControllers extends NSObject {
  alloc<T extends MSStandardInspectorViewControllers>(): MSStandardInspectorViewControllersAllocator<T>;

  geometryViewController(): MSGeometryInspectorSection;
  resizeSection(): MSResizeInspectorSection;
  fillViewController(): MSMultipleFillInspectorViewController;
  borderViewController(): MSMultipleBorderInspectorViewController;
  blurViewController(): MSBlurInspectorViewController;
  colorControlsViewController(): MSColorControlsInspectorViewController;
  flowInspectorViewController(): MSFlowInspectorSection;
  appearanceInspectorSection(): MSAppearanceInspectorSection;
  specialLayerViewController(): MSSpecialLayerViewController;
  exportPreviewViewController(): MSExportPreviewInspectorSection;
  exportViewController(): MSExportInspectorViewController;
  footerViewController(): MSFooterInspectorSection;
}

class MSStarShapeItemAllocator<T extends MSStarShapeItem> extends MSCustomShapeItemAllocator<T> {}
declare class MSStarShapeItem extends MSCustomShapeItem {
  alloc<T extends MSStarShapeItem>(): MSStarShapeItemAllocator<T>;
}

class MSBaseStyleActionAllocator<T extends MSBaseStyleAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseStyleAction extends MSDocumentAction {
  alloc<T extends MSBaseStyleAction>(): MSBaseStyleActionAllocator<T>;
}

class MSAddFillActionAllocator<T extends MSAddFillAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSAddFillAction extends MSBaseStyleAction {
  alloc<T extends MSAddFillAction>(): MSAddFillActionAllocator<T>;
  addFill(sender: any): IBAction;
}

class MSAddBorderActionAllocator<T extends MSAddBorderAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSAddBorderAction extends MSBaseStyleAction {
  alloc<T extends MSAddBorderAction>(): MSAddBorderActionAllocator<T>;
  addBorder(sender: any): IBAction;
}

class MSAddShadowActionAllocator<T extends MSAddShadowAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSAddShadowAction extends MSBaseStyleAction {
  alloc<T extends MSAddShadowAction>(): MSAddShadowActionAllocator<T>;
  addShadow(sender: any): IBAction;
}

class MSAddInnerShadowActionAllocator<T extends MSAddInnerShadowAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSAddInnerShadowAction extends MSBaseStyleAction {
  alloc<T extends MSAddInnerShadowAction>(): MSAddInnerShadowActionAllocator<T>;
  addInnerShadow(sender: any): IBAction;
}

class MSShowFillOptionsActionAllocator<T extends MSShowFillOptionsAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSShowFillOptionsAction extends MSBaseStyleAction {
  alloc<T extends MSShowFillOptionsAction>(): MSShowFillOptionsActionAllocator<T>;
  showFillOptions(sender: any): IBAction;
}

class MSShowBorderOptionsActionAllocator<T extends MSShowBorderOptionsAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSShowBorderOptionsAction extends MSBaseStyleAction {
  alloc<T extends MSShowBorderOptionsAction>(): MSShowBorderOptionsActionAllocator<T>;
  showBorderOptions(sender: any): IBAction;
}

class MSRemoveUnusedStylesActionAllocator<T extends MSRemoveUnusedStylesAction> extends MSBaseStyleActionAllocator<T> {}
declare class MSRemoveUnusedStylesAction extends MSBaseStyleAction {
  alloc<T extends MSRemoveUnusedStylesAction>(): MSRemoveUnusedStylesActionAllocator<T>;
  removeUnusedStyles(sender: any): IBAction;
}

class MSStyleOverrideInspectorItemAllocator<T extends MSStyleOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<T> {}
declare class MSStyleOverrideInspectorItem extends MSOverrideInspectorItem {
  alloc<T extends MSStyleOverrideInspectorItem>(): MSStyleOverrideInspectorItemAllocator<T>;
}

class MSLayerStyleOverrideInspectorItemAllocator<T extends MSLayerStyleOverrideInspectorItem> extends MSStyleOverrideInspectorItemAllocator<T> {}
declare class MSLayerStyleOverrideInspectorItem extends MSStyleOverrideInspectorItem {
  alloc<T extends MSLayerStyleOverrideInspectorItem>(): MSLayerStyleOverrideInspectorItemAllocator<T>;
}

class MSTextStyleOverrideInspectorItemAllocator<T extends MSTextStyleOverrideInspectorItem> extends MSStyleOverrideInspectorItemAllocator<T> {}
declare class MSTextStyleOverrideInspectorItem extends MSStyleOverrideInspectorItem {
  alloc<T extends MSTextStyleOverrideInspectorItem>(): MSTextStyleOverrideInspectorItemAllocator<T>;
}

declare interface IMSStylePartInspectorDelegate {
  switchToEventHandlerWithName(handlerName: NSString | string): any;
  layers(): NSArray<any>;
  reload(): void;
}

class MSStylePartInspectorItemAllocator<T extends MSStylePartInspectorItem> extends NSViewControllerAllocator<T> {}
declare class MSStylePartInspectorItem extends NSViewController {
  alloc<T extends MSStylePartInspectorItem>(): MSStylePartInspectorItemAllocator<T>;
  updateDisplayedValues(): void;

  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
  layers(): NSArray<any>;
  stylesController(): NSArrayController;
  setStylesController(stylesController: NSArrayController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSStylePartInspectorItemDelegate {
  stylePartInspectorItemDocument(inspectorItem: NSViewController): MSDocument;
  valuesPossiblyChanged(item: NSViewController): void;
}

class MSStylePartInspectorViewControllerAllocator<T extends MSStylePartInspectorViewController> extends NSViewControllerAllocator<T> {}
declare class MSStylePartInspectorViewController extends NSViewController implements IMSInspectorSection, INSWindowDelegate {
  alloc<T extends MSStylePartInspectorViewController>(): MSStylePartInspectorViewControllerAllocator<T>;
  static stylePartViewController(): any;
  prepareForReuse(): void;
  hasEnabledStyle(): boolean;
  didGetAddedToInspector(): void;
  prepare(): void;
  supportedActionsForLayers(layers: NSArray<any> | any[]): MSMultipleStylePartInspectorAction;
  closePopover(): void;
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  views(): NSArray<any>;
  wantsSeparatorAfterViews(): boolean;
  separatorInsets(): NSEdgeInsets;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;

  styleParts(): NSArray<any>;
  setStyleParts(styleParts: NSArray<any> | any[]): void;
  arrayController(): NSArrayController;
  setArrayController(arrayController: NSArrayController): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  index(): NSUInteger;
  setIndex(index: NSUInteger): void;
}

declare enum MSMultipleStylePartInspectorAction {
  MSMultipleStylePartInspectorActionNone = 0,
  MSMultipleStylePartInspectorActionDuplicate = 1 << 0,
  MSMultipleStylePartInspectorActionRemove = 1 << 1,
}

class MSStylePartPreviewButtonAllocator<T extends MSStylePartPreviewButton> extends MSInspectorButtonAllocator<T> {}
declare class MSStylePartPreviewButton extends MSInspectorButton {
  alloc<T extends MSStylePartPreviewButton>(): MSStylePartPreviewButtonAllocator<T>;

  stylePart(): MSStylePart;
  setStylePart(stylePart: MSStylePart): void;
  color(): NSColor;
  setColor(color: NSColor): void;
  delegate(): any;
  setDelegate(delegate: any): void;
  dragOwner(): any;
  setDragOwner(dragOwner: any): void;
}

class MSMultipleStylePartsPlaceholderAllocator<T extends MSMultipleStylePartsPlaceholder> extends MSStylePartAllocator<T> {}
declare class MSMultipleStylePartsPlaceholder extends MSStylePart {
  alloc<T extends MSMultipleStylePartsPlaceholder>(): MSMultipleStylePartsPlaceholderAllocator<T>;
}

class MSMultipleColorsPlaceholderAllocator<T extends MSMultipleColorsPlaceholder> extends NSObjectAllocator<T> {}
declare class MSMultipleColorsPlaceholder extends NSObject {
  alloc<T extends MSMultipleColorsPlaceholder>(): MSMultipleColorsPlaceholderAllocator<T>;
  static placeholderColor(): MSMultipleColorsPlaceholder;
}

declare interface IMSStylePartPreviewButtonDisabledTarget {
  stylePartPreviewButtonDisabledAction(button: MSStylePartPreviewButton): IBAction;
}

declare interface IMSStylePartPreviewButtonDelegate {
  stylePartPreviewButtonPreviewColorSpace(button: MSStylePartPreviewButton): NSColorSpace;
}

class MSSwitchModeButtonCellAllocator<T extends MSSwitchModeButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSSwitchModeButtonCell extends NSButtonCell {
  alloc<T extends MSSwitchModeButtonCell>(): MSSwitchModeButtonCellAllocator<T>;
}

class MSSymbolInstanceOverrideInspectorItemAllocator<T extends MSSymbolInstanceOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<T> {}
declare class MSSymbolInstanceOverrideInspectorItem extends MSOverrideInspectorItem {
  alloc<T extends MSSymbolInstanceOverrideInspectorItem>(): MSSymbolInstanceOverrideInspectorItemAllocator<T>;

  labelField(): NSTextField;
  setLabelField(labelField: NSTextField): void;
  popupButton(): NSPopUpButton;
  setPopupButton(popupButton: NSPopUpButton): void;
}

class MSSymbolInstanceSectionAllocator<T extends MSSymbolInstanceSection> extends MSBaseInspectorSectionAllocator<T> {}
declare class MSSymbolInstanceSection extends MSBaseInspectorSection {
  alloc<T extends MSSymbolInstanceSection>(): MSSymbolInstanceSectionAllocator<T>;
}

class MSSyncLibraryActionAllocator<T extends MSSyncLibraryAction> extends MSDocumentActionAllocator<T> {}
declare class MSSyncLibraryAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSSyncLibraryAction>(): MSSyncLibraryActionAllocator<T>;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSBaseAlignActionAllocator<T extends MSBaseAlignAction> extends MSDocumentActionAllocator<T> {}
declare class MSBaseAlignAction extends MSDocumentAction {
  alloc<T extends MSBaseAlignAction>(): MSBaseAlignActionAllocator<T>;
  textAlignment(): NSTextAlignment;
}

class MSAlignLeftActionAllocator<T extends MSAlignLeftAction> extends MSBaseAlignActionAllocator<T> {}
declare class MSAlignLeftAction extends MSBaseAlignAction {
  alloc<T extends MSAlignLeftAction>(): MSAlignLeftActionAllocator<T>;
}

class MSAlignCenterActionAllocator<T extends MSAlignCenterAction> extends MSBaseAlignActionAllocator<T> {}
declare class MSAlignCenterAction extends MSBaseAlignAction {
  alloc<T extends MSAlignCenterAction>(): MSAlignCenterActionAllocator<T>;
}

class MSAlignRightActionAllocator<T extends MSAlignRightAction> extends MSBaseAlignActionAllocator<T> {}
declare class MSAlignRightAction extends MSBaseAlignAction {
  alloc<T extends MSAlignRightAction>(): MSAlignRightActionAllocator<T>;
}

class MSAlignJustifiedActionAllocator<T extends MSAlignJustifiedAction> extends MSBaseAlignActionAllocator<T> {}
declare class MSAlignJustifiedAction extends MSBaseAlignAction {
  alloc<T extends MSAlignJustifiedAction>(): MSAlignJustifiedActionAllocator<T>;
}

class MSTextAlignTouchBarGroupActionAllocator<T extends MSTextAlignTouchBarGroupAction> extends MSActionGroupAllocator<T> {}
declare class MSTextAlignTouchBarGroupAction extends MSActionGroup {
  alloc<T extends MSTextAlignTouchBarGroupAction>(): MSTextAlignTouchBarGroupActionAllocator<T>;
}

class MSTextLabelForUpDownFieldAllocator<T extends MSTextLabelForUpDownField> extends NSTextFieldAllocator<T> {}
declare class MSTextLabelForUpDownField extends NSTextField {
  alloc<T extends MSTextLabelForUpDownField>(): MSTextLabelForUpDownFieldAllocator<T>;

  upDownTextField(): NSTextField;
  setUpDownTextField(upDownTextField: NSTextField): void;
  textFields(): NSArray<any>;
  setTextFields(textFields: NSArray<any> | any[]): void;
}

class MSTextLayerEventHandlerAllocator<T extends MSTextLayerEventHandler> extends MSEventHandlerAllocator<T> {}
declare class MSTextLayerEventHandler extends MSEventHandler implements INSTextViewDelegate, INSTextStorageDelegate, INSWindowDelegate, IMSTextLayerEditingDelegate, IMSTextLayerTextViewDelegate, IMSFirstLineTypesetterDelegate {
  alloc<T extends MSTextLayerEventHandler>(): MSTextLayerEventHandlerAllocator<T>;
  applyTextTransform(textTransformValue: NSNumber | number | null): void;
  applyTextColor(color: MSColor): NSColor;
  updateTextViewStyling(): void;
  setListType(list: NSTextList): void;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  textStorage_willProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  textStorage_didProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  adjustTextViewFrame(): void;
  adjustForegroundColor(): void;
  canvasColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
  documentColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  textStorage_willProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  textStorage_didProcessEditing_range_changeInLength(textStorage: NSTextStorage, editedMask: NSTextStorageEditActions, editedRange: NSRange, delta: NSInteger): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  adjustTextViewFrame(): void;
  adjustForegroundColor(): void;
  canvasColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
  documentColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
  baselineAdjustmentForLayoutManager(layoutManager: NSLayoutManager): CGFloat;

  textView(): MSTextLayerTextView;
}

class MSTextLayerItemAllocator<T extends MSTextLayerItem> extends MSInspectorItemAllocator<T> {}
declare class MSTextLayerItem extends MSInspectorItem implements INSMenuDelegate, IMSColorInspectorDelegate, INSComboBoxDataSource, IMSStylePartPreviewButtonDelegate {
  alloc<T extends MSTextLayerItem>(): MSTextLayerItemAllocator<T>;
  fontFamilyAction(sender: any): IBAction;
  fontWeightAction(sender: any): IBAction;
  fontSizeAction(sender: any): IBAction;
  showColorPickerAction(sender: any): IBAction;
  kerningAction(sender: any): IBAction;
  lineHeightAction(sender: any): IBAction;
  paragraphHeightAction(sender: any): IBAction;
  alignmentButtonAction(sender: any): IBAction;
  verticalAlignmentAction(sender: any): IBAction;
  showParagraphStylingAction(sender: any): IBAction;
  changeTextLayerFont(sender: any): IBAction;
  changeParagraphStyleInBlock(block: MSTextSectionParagraphEnumerator): void;
  changeFontPropertiesOfTextObjectsInBlock(block: MSTextSectionStringEnumerator): void;
  firstOccurrenceOfAttributeWithName(attributeName: NSString | string): any;
  textView(): MSTextLayerTextView;
  putFocusOnTextView(): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
  numberOfItemsInComboBox(comboBox: NSComboBox): NSInteger;
  comboBox_objectValueForItemAtIndex(comboBox: NSComboBox, index: NSInteger): any;
  comboBox_indexOfItemWithStringValue(comboBox: NSComboBox, string: NSString | string): NSUInteger;
  comboBox_completedString(comboBox: NSComboBox, string: NSString | string): NSString;
  stylePartPreviewButtonPreviewColorSpace(button: MSStylePartPreviewButton): NSColorSpace;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  colorInspector_didChangeToColor(inspector: MSColorInspector, color: MSColor): void;
  inspectorDidChangeType(inspector: MSColorInspector): void;
  colorInspectorDidChange(inspector: MSColorInspector): void;
  colorInspectorWillClose(inspector: MSColorInspector): void;
  colorInspectorShouldAdjustInspectorToPopover(inspector: MSColorInspector): boolean;
  colorInspectorUndoManager(inspector: MSColorInspector): NSUndoManager;
  numberOfItemsInComboBox(comboBox: NSComboBox): NSInteger;
  comboBox_objectValueForItemAtIndex(comboBox: NSComboBox, index: NSInteger): any;
  comboBox_indexOfItemWithStringValue(comboBox: NSComboBox, string: NSString | string): NSUInteger;
  comboBox_completedString(comboBox: NSComboBox, string: NSString | string): NSString;
  stylePartPreviewButtonPreviewColorSpace(button: MSStylePartPreviewButton): NSColorSpace;

  missingFontsLabel(): NSTextField;
  setMissingFontsLabel(missingFontsLabel: NSTextField): void;
  fontWeightPopUpButton(): NSPopUpButton;
  setFontWeightPopUpButton(fontWeightPopUpButton: NSPopUpButton): void;
  fontSizeField(): NSComboBox;
  setFontSizeField(fontSizeField: NSComboBox): void;
  colorPickerButton(): MSStylePartPreviewButton;
  setColorPickerButton(colorPickerButton: MSStylePartPreviewButton): void;
  kerningField(): NSTextField;
  setKerningField(kerningField: NSTextField): void;
  lineHeightField(): MSUpDownTextField;
  setLineHeightField(lineHeightField: MSUpDownTextField): void;
  paragraphHeightField(): NSTextField;
  setParagraphHeightField(paragraphHeightField: NSTextField): void;
  alignmentButton(): NSSegmentedControl;
  setAlignmentButton(alignmentButton: NSSegmentedControl): void;
  verticalAlignmentButton(): NSSegmentedControl;
  setVerticalAlignmentButton(verticalAlignmentButton: NSSegmentedControl): void;
}

class MSTextLayerTextViewAllocator<T extends MSTextLayerTextView> extends NSTextViewAllocator<T> {}
declare class MSTextLayerTextView extends NSTextView {
  alloc<T extends MSTextLayerTextView>(): MSTextLayerTextViewAllocator<T>;
  hideSelectionTemporarily(): void;
  selectSimilar(sender: any): IBAction;
  rectForSelectedRange(): NSRect;
  changeColorWithColor(color: NSColor): void;

  hangingGlyphView(): MSHangingGlyphView;
  setHangingGlyphView(hangingGlyphView: MSHangingGlyphView): void;
  textLayerTextViewDelegate(): any;
  setTextLayerTextViewDelegate(textLayerTextViewDelegate: any): void;
}

declare interface IMSTextLayerTextViewDelegate {
  canvasColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
  documentColorSpaceForTextLayerTextView(textView: MSTextLayerTextView): NSColorSpace;
}

class MSTextOnPathActionAllocator<T extends MSTextOnPathAction> extends MSDocumentActionAllocator<T> {}
declare class MSTextOnPathAction extends MSDocumentAction {
  alloc<T extends MSTextOnPathAction>(): MSTextOnPathActionAllocator<T>;
  textOnPath(sender: any): IBAction;
}

class MSTextOverrideInspectorItemAllocator<T extends MSTextOverrideInspectorItem> extends MSOverrideInspectorItemAllocator<T> {}
declare class MSTextOverrideInspectorItem extends MSOverrideInspectorItem {
  alloc<T extends MSTextOverrideInspectorItem>(): MSTextOverrideInspectorItemAllocator<T>;
}

class MSTextStyleTouchBarActionAllocator<T extends MSTextStyleTouchBarAction> extends MSDocumentActionAllocator<T> {}
declare class MSTextStyleTouchBarAction extends MSDocumentAction implements INSTouchBarDelegate {
  alloc<T extends MSTextStyleTouchBarAction>(): MSTextStyleTouchBarActionAllocator<T>;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
}

class MSTextVerticalAlignmentActionAllocator<T extends MSTextVerticalAlignmentAction> extends MSDocumentActionAllocator<T> {}
declare class MSTextVerticalAlignmentAction extends MSDocumentAction {
  alloc<T extends MSTextVerticalAlignmentAction>(): MSTextVerticalAlignmentActionAllocator<T>;
  verticalAlignment(): MSTextStyleVerticalAlignment;
}

class MSAlignTopActionAllocator<T extends MSAlignTopAction> extends MSTextVerticalAlignmentActionAllocator<T> {}
declare class MSAlignTopAction extends MSTextVerticalAlignmentAction {
  alloc<T extends MSAlignTopAction>(): MSAlignTopActionAllocator<T>;
  alignTop(sender: any): IBAction;
}

class MSAlignBottomActionAllocator<T extends MSAlignBottomAction> extends MSTextVerticalAlignmentActionAllocator<T> {}
declare class MSAlignBottomAction extends MSTextVerticalAlignmentAction {
  alloc<T extends MSAlignBottomAction>(): MSAlignBottomActionAllocator<T>;
  alignBottom(sender: any): IBAction;
}

class MSAlignMiddleActionAllocator<T extends MSAlignMiddleAction> extends MSTextVerticalAlignmentActionAllocator<T> {}
declare class MSAlignMiddleAction extends MSTextVerticalAlignmentAction {
  alloc<T extends MSAlignMiddleAction>(): MSAlignMiddleActionAllocator<T>;
  alignMiddle(sender: any): IBAction;
}

class MSTextWindowAllocator<T extends MSTextWindow> extends NSWindowAllocator<T> {
  initWithRect(rect: NSRect): T;
}
declare class MSTextWindow extends NSWindow {
  alloc<T extends MSTextWindow>(): MSTextWindowAllocator<T>;
  moveToRect_contentDrawViewRect_behaviour(textViewRect: NSRect, contentDrawViewRect: NSRect, behaviour: BCTextBehaviourType): void;
  addTextView_toView(textView: NSTextView, childView: NSView): void;

  contentDrawView(): MSContentDrawView;
  setContentDrawView(contentDrawView: MSContentDrawView): void;
  textView(): NSTextView;
}

class MSTiledImageViewAllocator<T extends MSTiledImageView> extends NSViewAllocator<T> {}
declare class MSTiledImageView extends NSView {
  alloc<T extends MSTiledImageView>(): MSTiledImageViewAllocator<T>;

  image(): NSImage;
  setImage(image: NSImage): void;
}

class MSToggleBaseActionAllocator<T extends MSToggleBaseAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleBaseAction extends MSDocumentAction {
  alloc<T extends MSToggleBaseAction>(): MSToggleBaseActionAllocator<T>;
}

class MSToggleGridActionAllocator<T extends MSToggleGridAction> extends MSToggleBaseActionAllocator<T> {}
declare class MSToggleGridAction extends MSToggleBaseAction {
  alloc<T extends MSToggleGridAction>(): MSToggleGridActionAllocator<T>;
  toggleGrid(sender: any): IBAction;
}

class MSToggleLayoutActionAllocator<T extends MSToggleLayoutAction> extends MSToggleBaseActionAllocator<T> {}
declare class MSToggleLayoutAction extends MSToggleBaseAction {
  alloc<T extends MSToggleLayoutAction>(): MSToggleLayoutActionAllocator<T>;
  toggleLayout(sender: any): IBAction;
}

class MSHideAllGridsAndLayoutsActionAllocator<T extends MSHideAllGridsAndLayoutsAction> extends MSDocumentActionAllocator<T> {}
declare class MSHideAllGridsAndLayoutsAction extends MSDocumentAction {
  alloc<T extends MSHideAllGridsAndLayoutsAction>(): MSHideAllGridsAndLayoutsActionAllocator<T>;
  hideAllGridsAndLayouts(sender: any): IBAction;
}

class MSToggleStylePartActionAllocator<T extends MSToggleStylePartAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleStylePartAction extends MSDocumentAction {
  alloc<T extends MSToggleStylePartAction>(): MSToggleStylePartActionAllocator<T>;
}

class MSToggleFillActionAllocator<T extends MSToggleFillAction> extends MSToggleStylePartActionAllocator<T> {}
declare class MSToggleFillAction extends MSToggleStylePartAction {
  alloc<T extends MSToggleFillAction>(): MSToggleFillActionAllocator<T>;
}

class MSToggleBorderActionAllocator<T extends MSToggleBorderAction> extends MSToggleStylePartActionAllocator<T> {}
declare class MSToggleBorderAction extends MSToggleStylePartAction {
  alloc<T extends MSToggleBorderAction>(): MSToggleBorderActionAllocator<T>;
}

class MSToggleFixToViewportActionAllocator<T extends MSToggleFixToViewportAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleFixToViewportAction extends MSDocumentAction {
  alloc<T extends MSToggleFixToViewportAction>(): MSToggleFixToViewportActionAllocator<T>;
  toggleFixToViewport(sender: any): IBAction;

  state(): NSCellStateValue;
}

class MSToggleInspectorVisibilityActionAllocator<T extends MSToggleInspectorVisibilityAction> extends MSToggleVisibilityActionAllocator<T> {}
declare class MSToggleInspectorVisibilityAction extends MSToggleVisibilityAction {
  alloc<T extends MSToggleInspectorVisibilityAction>(): MSToggleInspectorVisibilityActionAllocator<T>;
  toggleInspectorVisibility(sender: any): IBAction;
}

class MSToggleInterfaceActionAllocator<T extends MSToggleInterfaceAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleInterfaceAction extends MSDocumentAction {
  alloc<T extends MSToggleInterfaceAction>(): MSToggleInterfaceActionAllocator<T>;
  toggleHideInterface(sender: any): IBAction;
  documentWillClose(): void;
}

class MSToggleLayerListVisibilityActionAllocator<T extends MSToggleLayerListVisibilityAction> extends MSToggleVisibilityActionAllocator<T> {}
declare class MSToggleLayerListVisibilityAction extends MSToggleVisibilityAction {
  alloc<T extends MSToggleLayerListVisibilityAction>(): MSToggleLayerListVisibilityActionAllocator<T>;
  toggleLayerListVisibility(sender: any): IBAction;
}

class MSToggleResizeButtonCellAllocator<T extends MSToggleResizeButtonCell> extends NSButtonCellAllocator<T> {}
declare class MSToggleResizeButtonCell extends NSButtonCell {
  alloc<T extends MSToggleResizeButtonCell>(): MSToggleResizeButtonCellAllocator<T>;
}

class MSToggleRulersActionAllocator<T extends MSToggleRulersAction> extends MSToggleVisibilityActionAllocator<T> {}
declare class MSToggleRulersAction extends MSToggleVisibilityAction {
  alloc<T extends MSToggleRulersAction>(): MSToggleRulersActionAllocator<T>;
  toggleRulers(sender: any): IBAction;
}

class MSToggleToolbarVisibilityActionAllocator<T extends MSToggleToolbarVisibilityAction> extends MSToggleVisibilityActionAllocator<T> {}
declare class MSToggleToolbarVisibilityAction extends MSToggleVisibilityAction {
  alloc<T extends MSToggleToolbarVisibilityAction>(): MSToggleToolbarVisibilityActionAllocator<T>;
  toggleToolbarVisibility(sender: any): IBAction;
}

class MSToggleViewPreferenceActionAllocator<T extends MSToggleViewPreferenceAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleViewPreferenceAction extends MSDocumentAction {
  alloc<T extends MSToggleViewPreferenceAction>(): MSToggleViewPreferenceActionAllocator<T>;
  preferenceKey(): NSString;
}

class MSToggleArtboardShadowActionAllocator<T extends MSToggleArtboardShadowAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSToggleArtboardShadowAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSToggleArtboardShadowAction>(): MSToggleArtboardShadowActionAllocator<T>;
  toggleArtboardShadow(sender: any): IBAction;
}

class MSToggleAlignmentGuidesActionAllocator<T extends MSToggleAlignmentGuidesAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSToggleAlignmentGuidesAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSToggleAlignmentGuidesAction>(): MSToggleAlignmentGuidesActionAllocator<T>;
  toggleAlignmentGuides(sender: any): IBAction;
}

class MSTogglePixelLinesActionAllocator<T extends MSTogglePixelLinesAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSTogglePixelLinesAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSTogglePixelLinesAction>(): MSTogglePixelLinesActionAllocator<T>;
  togglePixelLines(sender: any): IBAction;
}

class MSToggleSelectionActionAllocator<T extends MSToggleSelectionAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSToggleSelectionAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSToggleSelectionAction>(): MSToggleSelectionActionAllocator<T>;
  toggleSelection(sender: any): IBAction;
}

class MSToggleLayerHighlightActionAllocator<T extends MSToggleLayerHighlightAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSToggleLayerHighlightAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSToggleLayerHighlightAction>(): MSToggleLayerHighlightActionAllocator<T>;
  toggleLayerHighlight(sender: any): IBAction;
}

class MSToggleSliceInteractionActionAllocator<T extends MSToggleSliceInteractionAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSToggleSliceInteractionAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSToggleSliceInteractionAction>(): MSToggleSliceInteractionActionAllocator<T>;
  toggleSliceInteraction(sender: any): IBAction;
}

class MSToggleFlowInteractionActionAllocator<T extends MSToggleFlowInteractionAction> extends MSToggleViewPreferenceActionAllocator<T> {}
declare class MSToggleFlowInteractionAction extends MSToggleViewPreferenceAction {
  alloc<T extends MSToggleFlowInteractionAction>(): MSToggleFlowInteractionActionAllocator<T>;
  toggleFlowInteraction(sender: any): IBAction;
}

class MSToggleVisibilityActionAllocator<T extends MSToggleVisibilityAction> extends MSDocumentActionAllocator<T> {}
declare class MSToggleVisibilityAction extends MSDocumentAction {
  alloc<T extends MSToggleVisibilityAction>(): MSToggleVisibilityActionAllocator<T>;
  show(): void;
  hide(): void;
  defaultsKey(): NSString;
  prepareForNewWindow(): void;

  isActive(): boolean;
}

class MSToolbarConstructorAllocator<T extends MSToolbarConstructor> extends NSObjectAllocator<T> {
  initWithDocument(document: MSDocument): T;
}
declare class MSToolbarConstructor extends NSObject implements INSToolbarDelegate {
  alloc<T extends MSToolbarConstructor>(): MSToolbarConstructorAllocator<T>;
  static toolbarAllowedItemIdentifiers(): NSArray<any>;
  static toolbarForDocument(document: MSDocument): any;
  constructToolbarForWindow(window: NSWindow): void;
  validateToolbarItems(): void;
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;
  toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar(toolbar: NSToolbar, itemIdentifier: NSToolbarItemIdentifier, flag: boolean): NSToolbarItem;
  toolbarDefaultItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarAllowedItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarSelectableItemIdentifiers(toolbar: NSToolbar): NSArray<any>;
  toolbarWillAddItem(notification: NSNotification): void;
  toolbarDidRemoveItem(notification: NSNotification): void;

  doc(): MSDocument;
  setDoc(doc: MSDocument): void;
}

class MSToolbarAllocator<T extends MSToolbar> extends NSToolbarAllocator<T> {}
declare class MSToolbar extends NSToolbar {
  alloc<T extends MSToolbar>(): MSToolbarAllocator<T>;
}

class MSToolbarPopoverContentViewControllerAllocator<T extends MSToolbarPopoverContentViewController> extends NSViewControllerAllocator<T> {
  initWithAction(action: MSPopoverAction): T;
}
declare class MSToolbarPopoverContentViewController extends NSViewController {
  alloc<T extends MSToolbarPopoverContentViewController>(): MSToolbarPopoverContentViewControllerAllocator<T>;
  newActionButtonWithTitle_action(title: NSString | string, selector: string): NSButton;
  newLabel(): NSTextField;
  animateFrameWithCompletionHandler(handler: Block): void;

  action(): MSPopoverAction;
  edgeInsets(): NSEdgeInsets;
  stackView(): NSStackView;
  imageView(): NSImageView;
  titleLabel(): NSTextField;
  descriptionLabel(): NSTextField;
  actionView(): NSView;
  footerLabel(): NSTextField;
}

class MSTransformEventHandlerAllocator<T extends MSTransformEventHandler> extends MSPointsEventHandlerAllocator<T> {}
declare class MSTransformEventHandler extends MSPointsEventHandler {
  alloc<T extends MSTransformEventHandler>(): MSTransformEventHandlerAllocator<T>;
  transformLayers(): void;

  originalRect(): NSRect;
  setOriginalRect(originalRect: NSRect): void;
}

declare enum MSTransformDirectionLock {
  MSTransformDirectionLockNone = 0,
  MSTransformDirectionLockX = 1,
  MSTransformDirectionLockY = 2,
}

class MSTwoTextFieldInspectorItemAllocator<T extends MSTwoTextFieldInspectorItem> extends MSInspectorItemAllocator<T> {
  initWithTitle_field1Label_field2Label(title: NSString | string, field1: NSString | string, field2: NSString | string): T;
  initWithTitle_field1Label_field2Label_nibName(title: NSString | string, field1: NSString | string, field2: NSString | string, nibName: NSString | string): T;
}
declare class MSTwoTextFieldInspectorItem extends MSInspectorItem {
  alloc<T extends MSTwoTextFieldInspectorItem>(): MSTwoTextFieldInspectorItemAllocator<T>;

  itemLabel(): NSTextField;
  setItemLabel(itemLabel: NSTextField): void;
  textField1(): MSInlineUpDownTextField;
  setTextField1(textField1: MSInlineUpDownTextField): void;
  textField2(): MSInlineUpDownTextField;
  setTextField2(textField2: MSInlineUpDownTextField): void;
  interTextFieldButton(): NSButton;
  setInterTextFieldButton(interTextFieldButton: NSButton): void;
}

class MSUnavailableUpdatesWindowControllerAllocator<T extends MSUnavailableUpdatesWindowController> extends NSWindowControllerAllocator<T> {}
declare class MSUnavailableUpdatesWindowController extends NSWindowController implements INSWindowDelegate {
  alloc<T extends MSUnavailableUpdatesWindowController>(): MSUnavailableUpdatesWindowControllerAllocator<T>;
  static showModalWithVersion_buildNumber_reason(version: NSString | string, buildNumber: NSString | string, reason: MSUnavailableUpdatesReason): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
}

declare enum MSUnavailableUpdatesReason {
  MSUnavailableUpdatesRenewalRequired,
  MSUnavailableUpdatesMacOSUpdateRequired,
  MSUnavailableUpdatesRenewalAndMacOSUpdateRequired,
}

class MSUnderlineActionAllocator<T extends MSUnderlineAction> extends MSDocumentActionAllocator<T> {}
declare class MSUnderlineAction extends MSDocumentAction {
  alloc<T extends MSUnderlineAction>(): MSUnderlineActionAllocator<T>;
}

class MSUndoBaseActionAllocator<T extends MSUndoBaseAction> extends MSDocumentActionAllocator<T> {}
declare class MSUndoBaseAction extends MSDocumentAction {
  alloc<T extends MSUndoBaseAction>(): MSUndoBaseActionAllocator<T>;
}

class MSUndoActionAllocator<T extends MSUndoAction> extends MSUndoBaseActionAllocator<T> {}
declare class MSUndoAction extends MSUndoBaseAction {
  alloc<T extends MSUndoAction>(): MSUndoActionAllocator<T>;
  undo(sender: any): IBAction;
}

class MSRedoActionAllocator<T extends MSRedoAction> extends MSUndoBaseActionAllocator<T> {}
declare class MSRedoAction extends MSUndoBaseAction {
  alloc<T extends MSRedoAction>(): MSRedoActionAllocator<T>;
  redo(sender: any): IBAction;
}

class MSUnlinkAndOrSyncActionAllocator<T extends MSUnlinkAndOrSyncAction> extends MSBaseSharedObjectActionAllocator<T> {}
declare class MSUnlinkAndOrSyncAction extends MSBaseSharedObjectAction {
  alloc<T extends MSUnlinkAndOrSyncAction>(): MSUnlinkAndOrSyncActionAllocator<T>;
}

class MSSyncLocalStyleActionAllocator<T extends MSSyncLocalStyleAction> extends MSUnlinkAndOrSyncActionAllocator<T> {}
declare class MSSyncLocalStyleAction extends MSUnlinkAndOrSyncAction {
  alloc<T extends MSSyncLocalStyleAction>(): MSSyncLocalStyleActionAllocator<T>;
  syncLocalSharedStyle(sender: any): IBAction;
}

class MSUnlinkFromLibraryActionAllocator<T extends MSUnlinkFromLibraryAction> extends MSUnlinkAndOrSyncActionAllocator<T> {}
declare class MSUnlinkFromLibraryAction extends MSUnlinkAndOrSyncAction {
  alloc<T extends MSUnlinkFromLibraryAction>(): MSUnlinkFromLibraryActionAllocator<T>;
  unlinkFromLibrary(sender: any): IBAction;
}

class MSUnlinkAndSyncFromLibraryActionAllocator<T extends MSUnlinkAndSyncFromLibraryAction> extends MSUnlinkAndOrSyncActionAllocator<T> {}
declare class MSUnlinkAndSyncFromLibraryAction extends MSUnlinkAndOrSyncAction {
  alloc<T extends MSUnlinkAndSyncFromLibraryAction>(): MSUnlinkAndSyncFromLibraryActionAllocator<T>;
  unlinkAndSyncFromLibrary(sender: any): IBAction;
}

class MSUpDownControllerAllocator<T extends MSUpDownController> extends NSResponderAllocator<T> {
  initWithTextField_createStepper(field: NSTextField, makeStepper: boolean): T;
}
declare class MSUpDownController extends NSResponder {
  alloc<T extends MSUpDownController>(): MSUpDownControllerAllocator<T>;
  becomeFirstResponder(): boolean;
  textDidEndEditing(): void;
  textDidChange(note: NSNotification): void;
  doCommandBySelector(selector: string): boolean;
  cancelTextEditingForInvalidReplacementString(replacementStrings: NSArray<any> | any[]): boolean;
  keyUp(): void;
  increment(): void;
  decrement(): void;
  floatValue(): number;
  incrementBy(amount: CGFloat): void;
  incrementValueAccountingForModifierFlags(): CGFloat;
  hideStepper(hide: boolean): void;

  incrementDecrementDelegate(): any;
  setIncrementDecrementDelegate(incrementDecrementDelegate: any): void;
  textField(): NSTextField;
}

declare interface IMSUpDownTextFieldDelegate {
  refreshAction(sender: any): void;
  valueForUpDownTextField(upDownTextField: NSTextField): CGFloat;
}

declare interface IMSUpDownProtocol {
  incrementValue(): CGFloat;
  minimum(): NSNumber;
  maximum(): NSNumber;

  upDownController(): MSUpDownController;
}

class MSUpDownTextFieldAllocator<T extends MSUpDownTextField> extends NSTextFieldAllocator<T> {}
declare class MSUpDownTextField extends NSTextField implements INSTextViewDelegate, IMSUpDownProtocol, INSTouchBarDelegate {
  alloc<T extends MSUpDownTextField>(): MSUpDownTextFieldAllocator<T>;
  connectToValueAdapter(valueAdaptor: MSMathInspectorValueAdaptor): void;
  connectToValueAdapter_bindingOptions(valueAdaptor: MSMathInspectorValueAdaptor, bindingOptions: NSDictionary<any, any> | {[key: string]: any}): void;
  incrementValue(): CGFloat;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  incrementValue(): CGFloat;
  minimum(): NSNumber;
  maximum(): NSNumber;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;
  textView_clickedOnLink_atIndex(textView: NSTextView, link: any, charIndex: NSUInteger): boolean;
  textView_clickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_doubleClickedOnCell_inRect_atIndex(textView: NSTextView, cell: any, cellFrame: NSRect, charIndex: NSUInteger): void;
  textView_draggedCell_inRect_event_atIndex(view: NSTextView, cell: any, rect: NSRect, event: NSEvent, charIndex: NSUInteger): void;
  textView_writablePasteboardTypesForCell_atIndex(view: NSTextView, cell: any, charIndex: NSUInteger): NSArray<any>;
  textView_writeCell_atIndex_toPasteboard_type(view: NSTextView, cell: any, charIndex: NSUInteger, pboard: NSPasteboard, type: NSPasteboardType): boolean;
  textView_willChangeSelectionFromCharacterRange_toCharacterRange(textView: NSTextView, oldSelectedCharRange: NSRange, newSelectedCharRange: NSRange): NSRange;
  textView_willChangeSelectionFromCharacterRanges_toCharacterRanges(textView: NSTextView, oldSelectedCharRanges: NSArray<any> | any[], newSelectedCharRanges: NSArray<any> | any[]): NSArray<any>;
  textView_shouldChangeTextInRanges_replacementStrings(textView: NSTextView, affectedRanges: NSArray<any> | any[], replacementStrings: NSArray<any> | any[] | null): boolean;
  textView_shouldChangeTypingAttributes_toAttributes(textView: NSTextView, oldTypingAttributes: NSDictionary<any, any> | {[key: string]: any}, newTypingAttributes: NSDictionary<any, any> | {[key: string]: any}): NSDictionary<any, any>;
  textViewDidChangeSelection(notification: NSNotification): void;
  textViewDidChangeTypingAttributes(notification: NSNotification): void;
  textView_willDisplayToolTip_forCharacterAtIndex(textView: NSTextView, tooltip: NSString | string, characterIndex: NSUInteger): NSString;
  textView_completions_forPartialWordRange_indexOfSelectedItem(textView: NSTextView, words: NSArray<any> | any[], charRange: NSRange, index: NSInteger | null): NSArray<any>;
  textView_shouldChangeTextInRange_replacementString(textView: NSTextView, affectedCharRange: NSRange, replacementString: NSString | string | null): boolean;
  textView_doCommandBySelector(textView: NSTextView, commandSelector: string): boolean;
  textView_shouldSetSpellingState_range(textView: NSTextView, value: NSInteger, affectedCharRange: NSRange): NSInteger;
  textView_menu_forEvent_atIndex(view: NSTextView, menu: NSMenu, event: NSEvent, charIndex: NSUInteger): NSMenu;
  textView_willCheckTextInRange_options_types(view: NSTextView, range: NSRange, options: NSDictionary<any, any> | {[key: string]: any}, checkingTypes: NSTextCheckingTypes): NSDictionary<any, any>;
  textView_didCheckTextInRange_types_options_results_orthography_wordCount(view: NSTextView, range: NSRange, checkingTypes: NSTextCheckingTypes, options: NSDictionary<any, any> | {[key: string]: any}, results: NSArray<any> | any[], orthography: NSOrthography, wordCount: NSInteger): NSArray<any>;
  textView_URLForContentsOfTextAttachment_atIndex(textView: NSTextView, textAttachment: NSTextAttachment, charIndex: NSUInteger): NSURL;
  textView_willShowSharingServicePicker_forItems(textView: NSTextView, servicePicker: NSSharingServicePicker, items: NSArray<any> | any[]): NSSharingServicePicker;
  undoManagerForTextView(view: NSTextView): NSUndoManager;
  textView_shouldUpdateTouchBarItemIdentifiers(textView: NSTextView, identifiers: NSArray<any> | any[]): NSArray<any>;
  textView_candidatesForSelectedRange(textView: NSTextView, selectedRange: NSRange): NSArray<any>;
  textView_candidates_forSelectedRange(textView: NSTextView, candidates: NSArray<any> | any[], selectedRange: NSRange): NSArray<any>;
  textView_shouldSelectCandidateAtIndex(textView: NSTextView, index: NSUInteger): boolean;
  textView_clickedOnLink(textView: NSTextView, link: any): boolean;
  textView_clickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_doubleClickedOnCell_inRect(textView: NSTextView, cell: any, cellFrame: NSRect): void;
  textView_draggedCell_inRect_event(view: NSTextView, cell: any, rect: NSRect, event: NSEvent): void;
  incrementValue(): CGFloat;
  minimum(): NSNumber;
  maximum(): NSNumber;
  touchBar_makeItemForIdentifier(touchBar: NSTouchBar, identifier: NSTouchBarItemIdentifier): NSTouchBarItem;

  refreshDelegate(): any;
  setRefreshDelegate(refreshDelegate: any): void;
  upDownController(): MSUpDownController;
}

class MSUpDownMiniTextFieldAllocator<T extends MSUpDownMiniTextField> extends MSUpDownTextFieldAllocator<T> {}
declare class MSUpDownMiniTextField extends MSUpDownTextField {
  alloc<T extends MSUpDownMiniTextField>(): MSUpDownMiniTextFieldAllocator<T>;
}

class MSUpDownNanoTextFieldAllocator<T extends MSUpDownNanoTextField> extends MSUpDownTextFieldAllocator<T> {}
declare class MSUpDownNanoTextField extends MSUpDownTextField {
  alloc<T extends MSUpDownNanoTextField>(): MSUpDownNanoTextFieldAllocator<T>;
}

class MSUpdateControllerAllocator<T extends MSUpdateController> extends NSObjectAllocator<T> {}
declare class MSUpdateController extends NSObject {
  alloc<T extends MSUpdateController>(): MSUpdateControllerAllocator<T>;
  checkNormally(): void;
  checkSilently(): void;
  checkQuietly(): void;
  commandEnabled(): boolean;
  commandLabel(): NSString;

  unavailableUpdateCount(): NSUInteger;
  setUnavailableUpdateCount(unavailableUpdateCount: NSUInteger): void;
  hasAvailableUpdates(): boolean;
  setHasAvailableUpdates(hasAvailableUpdates: boolean): void;
}

class MSUpdatePluginsActionAllocator<T extends MSUpdatePluginsAction> extends MSDocumentActionAllocator<T> {}
declare class MSUpdatePluginsAction extends MSDocumentAction implements IMSWindowBadgeAction {
  alloc<T extends MSUpdatePluginsAction>(): MSUpdatePluginsActionAllocator<T>;

  numberOfBadges(): NSUInteger;
  badgeTitle(): NSAttributedString;
  badgeTint(): NSColor;
}

class MSToolsMenuActionAllocator<T extends MSToolsMenuAction> extends MSDocumentActionAllocator<T> {}
declare class MSToolsMenuAction extends MSDocumentAction {
  alloc<T extends MSToolsMenuAction>(): MSToolsMenuActionAllocator<T>;
}

class MSTransformActionAllocator<T extends MSTransformAction> extends MSEventHandlerActionAllocator<T> {}
declare class MSTransformAction extends MSEventHandlerAction {
  alloc<T extends MSTransformAction>(): MSTransformActionAllocator<T>;
  transform(sender: any): IBAction;
}

class MSScissorsActionAllocator<T extends MSScissorsAction> extends MSEventHandlerActionAllocator<T> {}
declare class MSScissorsAction extends MSEventHandlerAction {
  alloc<T extends MSScissorsAction>(): MSScissorsActionAllocator<T>;
  scissors(sender: any): IBAction;
}

class MSVectorCanvasAllocator<T extends MSVectorCanvas> extends NSObjectAllocator<T> {}
declare class MSVectorCanvas extends NSObject {
  alloc<T extends MSVectorCanvas>(): MSVectorCanvasAllocator<T>;
  registerWithEventHandler(handler: MSShapeEventHandler): void;
  didChangeAllowSelectionOnly(): void;
  selectHandleAtIndexPath_extendSelection(handle: NSIndexPath, extendSelection: boolean): void;
  selectHandlesAtIndexPaths(indexPaths: NSArray<any> | any[]): void;
  deselectHandleAtIndexPath(handle: NSIndexPath): void;
  drawHairline(): void;
  drawWire(): void;
  drawSnaps(): void;
  drawHighlightedSegment(): void;
  drawInsertionPoint(): void;
  drawHandles(): void;
  changeToCurveMode(curveMode: MSCurveMode): void;
  delete(sender: any): IBAction;
  alignVectorPointsToKey(key: NSString | string): void;
  distributeVectorPointsToAxis(axis: BCAxis): void;
  adjustHandlesToValue_onAxis(value: CGFloat, axis: BCAxis): void;
  adjustHandle_toValue_onAxis(handle: NSIndexPath, value: CGFloat, axis: BCAxis): void;
  singleMouseDownAtPoint_modifierFlags(location: NSPoint, flags: NSEventModifierFlags): void;
  doubleMouseDownAtPoint_modifierFlags(location: NSPoint, flags: NSEventModifierFlags): void;
  mouseUpAtPoint(location: NSPoint): void;
  trackMouse(sender: MSMouseTracker): void;
  flagsChanged(event: NSEvent): void;
  updateCursor(): void;
  setNeedsUpdateCursor(): void;

  eventHandler(): MSShapeEventHandler;
  view(): MSContentDrawView;
  setView(view: MSContentDrawView): void;
  pathController(): MSPathController;
  setPathController(pathController: MSPathController): void;
  selectedLayers(): NSArray<any>;
  setSelectedLayers(selectedLayers: NSArray<any> | any[]): void;
  visibleLayers(): NSArray<any>;
  editingBehavior(): MSShapeEditingBehavior;
  setEditingBehavior(editingBehavior: MSShapeEditingBehavior): void;
  indexPathsForSelectedHandles(): NSArray<any>;
  indexPathForHighlightedComponent(): NSIndexPath;
  interactivelySelecting(): boolean;
  snaps(): MSAlignmentEngineResult;
  setSnaps(snaps: MSAlignmentEngineResult): void;
  delegate(): any;
  setDelegate(delegate: any): void;
}

declare interface IMSVectorCanvasDelegate {
  vectorCanvas_didHighlightHandleAtIndexPath(canvas: MSVectorCanvas, indexPath: NSIndexPath): void;
  vectorCanvas_didUnhighlightHandleAtIndexPath(canvas: MSVectorCanvas, indexPath: NSIndexPath): void;
  vectorCanvas_didSelectHandlesAtIndexPaths(canvas: MSVectorCanvas, indexPaths: NSArray<any> | any[]): void;
  vectorCanvas_didDeselectHandlesAtIndexPaths(canvas: MSVectorCanvas, indexPaths: NSArray<any> | any[]): void;
  vectorCanvasDidFinishInteractiveSelection(canvas: MSVectorCanvas): void;
  vectorCanvas_didSelectLayers(canvas: MSVectorCanvas, layers: NSArray<any> | any[]): void;
  vectorCanvasDidEditPoints(canvas: MSVectorCanvas): void;
}

class MSVectorHandleAllocator<T extends MSVectorHandle> extends NSObjectAllocator<T> {}
declare class MSVectorHandle extends NSObject {
  alloc<T extends MSVectorHandle>(): MSVectorHandleAllocator<T>;
  drawAtProposedPoint_inView(proposedPoint: NSPoint, canvasView: NSView): void;
  drawingSize(): NSSize;

  state(): MSHandleState;
  setState(state: MSHandleState): void;
}

class MSVectorAdjustmentHandleAllocator<T extends MSVectorAdjustmentHandle> extends MSVectorHandleAllocator<T> {}
declare class MSVectorAdjustmentHandle extends MSVectorHandle {
  alloc<T extends MSVectorAdjustmentHandle>(): MSVectorAdjustmentHandleAllocator<T>;

  locationOfMainPoint(): NSPoint;
  setLocationOfMainPoint(locationOfMainPoint: NSPoint): void;
}

class MSVerticalRulerViewAllocator<T extends MSVerticalRulerView> extends MSRulerViewAllocator<T> {}
declare class MSVerticalRulerView extends MSRulerView {
  alloc<T extends MSVerticalRulerView>(): MSVerticalRulerViewAllocator<T>;
}

class MSVerticalRulerViewLayerAllocator<T extends MSVerticalRulerViewLayer> extends MSRulerViewLayerAllocator<T> {}
declare class MSVerticalRulerViewLayer extends MSRulerViewLayer {
  alloc<T extends MSVerticalRulerViewLayer>(): MSVerticalRulerViewLayerAllocator<T>;
}

class MSVerticallyCenteredTextFieldCellAllocator<T extends MSVerticallyCenteredTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class MSVerticallyCenteredTextFieldCell extends NSTextFieldCell {
  alloc<T extends MSVerticallyCenteredTextFieldCell>(): MSVerticallyCenteredTextFieldCellAllocator<T>;
}

class MSViewMenuActionAllocator<T extends MSViewMenuAction> extends MSDocumentActionAllocator<T> {}
declare class MSViewMenuAction extends MSDocumentAction {
  alloc<T extends MSViewMenuAction>(): MSViewMenuActionAllocator<T>;
}

class MSTogglePixelGridActionAllocator<T extends MSTogglePixelGridAction> extends MSDocumentActionAllocator<T> {}
declare class MSTogglePixelGridAction extends MSDocumentAction {
  alloc<T extends MSTogglePixelGridAction>(): MSTogglePixelGridActionAllocator<T>;
  togglePixelGrid(sender: any): IBAction;
}

class MSVisitDocumentationActionAllocator<T extends MSVisitDocumentationAction> extends MSActionAllocator<T> {}
declare class MSVisitDocumentationAction extends MSAction {
  alloc<T extends MSVisitDocumentationAction>(): MSVisitDocumentationActionAllocator<T>;
  visitDocumentation(sender: any): IBAction;
}

class MSWelcomeCollectionImageViewAllocator<T extends MSWelcomeCollectionImageView> extends NSImageViewAllocator<T> {}
declare class MSWelcomeCollectionImageView extends NSImageView {
  alloc<T extends MSWelcomeCollectionImageView>(): MSWelcomeCollectionImageViewAllocator<T>;

  doubleClickAction(): string;
  setDoubleClickAction(doubleClickAction: string): void;
  imageInterpolation(): NSImageInterpolation;
  setImageInterpolation(imageInterpolation: NSImageInterpolation): void;
  selected(): boolean;
  setSelected(selected: boolean): void;
}

class MSWelcomeCollectionImageCellAllocator<T extends MSWelcomeCollectionImageCell> extends NSImageCellAllocator<T> {}
declare class MSWelcomeCollectionImageCell extends NSImageCell {
  alloc<T extends MSWelcomeCollectionImageCell>(): MSWelcomeCollectionImageCellAllocator<T>;
}

class MSWelcomeCollectionItemAllocator<T extends MSWelcomeCollectionItem> extends NSObjectAllocator<T> {
  initWithController(controller: MSWelcomeWindowController): T;
}
declare class MSWelcomeCollectionItem extends NSObject implements IMSWelcomeCollectionItemPreviewImageLoading {
  alloc<T extends MSWelcomeCollectionItem>(): MSWelcomeCollectionItemAllocator<T>;
  static bundledTemplatesDirectoryURL(): NSURL;
  static userTemplatesDirectoryURL(): NSURL;
  fetchPreviewImageWithMaximumPixelSize_completionHandler(maxPixelSize: CGFloat, handler: MSPreviewImageHandler): void;
  fetchPreviewImageWithMaximumPixelSize_completionHandler(maxPixelSize: CGFloat, handler: MSPreviewImageHandler): void;

  placeholderImage(): NSImage;
  title(): NSString;
  welcomeWindowController(): MSWelcomeWindowController;
  setWelcomeWindowController(welcomeWindowController: MSWelcomeWindowController): void;
  providesPreviewImage(): boolean;
  URL(): NSURL;
}

class MSExistingDocumentCollectionItemAllocator<T extends MSExistingDocumentCollectionItem> extends MSWelcomeCollectionItemAllocator<T> {
  initWithController_URL(controller: MSWelcomeWindowController, URL: NSURL): T;
}
declare class MSExistingDocumentCollectionItem extends MSWelcomeCollectionItem {
  alloc<T extends MSExistingDocumentCollectionItem>(): MSExistingDocumentCollectionItemAllocator<T>;

  URL(): NSURL;
}

class MSNewDocumentCollectionItemAllocator<T extends MSNewDocumentCollectionItem> extends MSWelcomeCollectionItemAllocator<T> {}
declare class MSNewDocumentCollectionItem extends MSWelcomeCollectionItem {
  alloc<T extends MSNewDocumentCollectionItem>(): MSNewDocumentCollectionItemAllocator<T>;
}

declare interface IMSWelcomeCollectionItemPreviewImageLoading {
  fetchPreviewImageWithMaximumPixelSize_completionHandler(maxPixelSize: CGFloat, handler: MSPreviewImageHandler): void;

  providesPreviewImage(): boolean;
  URL(): NSURL;
}

class MSWelcomeCollectionTextFieldAllocator<T extends MSWelcomeCollectionTextField> extends NSTextFieldAllocator<T> {}
declare class MSWelcomeCollectionTextField extends NSTextField {
  alloc<T extends MSWelcomeCollectionTextField>(): MSWelcomeCollectionTextFieldAllocator<T>;

  selected(): boolean;
  setSelected(selected: boolean): void;
}

class MSWelcomeCollectionTextFieldCellAllocator<T extends MSWelcomeCollectionTextFieldCell> extends NSTextFieldCellAllocator<T> {}
declare class MSWelcomeCollectionTextFieldCell extends NSTextFieldCell {
  alloc<T extends MSWelcomeCollectionTextFieldCell>(): MSWelcomeCollectionTextFieldCellAllocator<T>;
}

class MSWelcomeCollectionViewAllocator<T extends MSWelcomeCollectionView> extends NSCollectionViewAllocator<T> {}
declare class MSWelcomeCollectionView extends NSCollectionView {
  alloc<T extends MSWelcomeCollectionView>(): MSWelcomeCollectionViewAllocator<T>;
}

declare interface IMSWelcomeCollectionViewDelegate {
  collectionView_newItemForRepresentedObject(collectionView: NSCollectionView, object: any): NSCollectionViewItem;
}

class MSWelcomeCollectionViewItemAllocator<T extends MSWelcomeCollectionViewItem> extends NSCollectionViewItemAllocator<T> {}
declare class MSWelcomeCollectionViewItem extends NSCollectionViewItem implements INSMenuDelegate {
  alloc<T extends MSWelcomeCollectionViewItem>(): MSWelcomeCollectionViewItemAllocator<T>;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;

  collectionItem(): MSWelcomeCollectionItem;
}

class MSWelcomeColorStripViewAllocator<T extends MSWelcomeColorStripView> extends NSViewAllocator<T> {}
declare class MSWelcomeColorStripView extends NSView {
  alloc<T extends MSWelcomeColorStripView>(): MSWelcomeColorStripViewAllocator<T>;
}

class MSWelcomeProgressViewAllocator<T extends MSWelcomeProgressView> extends NSViewAllocator<T> {}
declare class MSWelcomeProgressView extends NSView {
  alloc<T extends MSWelcomeProgressView>(): MSWelcomeProgressViewAllocator<T>;

  backgroundColor(): NSColor;
  setBackgroundColor(backgroundColor: NSColor): void;
  collectionItem(): MSCloudShareCollectionItem;
  setCollectionItem(collectionItem: MSCloudShareCollectionItem): void;
}

class MSWelcomeToSketchActionAllocator<T extends MSWelcomeToSketchAction> extends MSActionAllocator<T> {}
declare class MSWelcomeToSketchAction extends MSAction {
  alloc<T extends MSWelcomeToSketchAction>(): MSWelcomeToSketchActionAllocator<T>;
  welcomeToSketch(sender: any): IBAction;
}

class MSWelcomeBackgroundViewAllocator<T extends MSWelcomeBackgroundView> extends NSViewAllocator<T> {}
declare class MSWelcomeBackgroundView extends NSView {
  alloc<T extends MSWelcomeBackgroundView>(): MSWelcomeBackgroundViewAllocator<T>;
}

class MSWelcomeTopFadeViewAllocator<T extends MSWelcomeTopFadeView> extends NSViewAllocator<T> {}
declare class MSWelcomeTopFadeView extends NSView {
  alloc<T extends MSWelcomeTopFadeView>(): MSWelcomeTopFadeViewAllocator<T>;
}

class MSWelcomeControlContainerViewAllocator<T extends MSWelcomeControlContainerView> extends NSViewAllocator<T> {}
declare class MSWelcomeControlContainerView extends NSView {
  alloc<T extends MSWelcomeControlContainerView>(): MSWelcomeControlContainerViewAllocator<T>;
}

class MSWelcomeBottomFadeViewAllocator<T extends MSWelcomeBottomFadeView> extends MSWelcomeTopFadeViewAllocator<T> {}
declare class MSWelcomeBottomFadeView extends MSWelcomeTopFadeView {
  alloc<T extends MSWelcomeBottomFadeView>(): MSWelcomeBottomFadeViewAllocator<T>;
}

class MSWelcomeDebugViewAllocator<T extends MSWelcomeDebugView> extends NSViewAllocator<T> {}
declare class MSWelcomeDebugView extends NSView {
  alloc<T extends MSWelcomeDebugView>(): MSWelcomeDebugViewAllocator<T>;
}

class MSWelcomeWindowAllocator<T extends MSWelcomeWindow> extends NSWindowAllocator<T> {}
declare class MSWelcomeWindow extends NSWindow {
  alloc<T extends MSWelcomeWindow>(): MSWelcomeWindowAllocator<T>;
}

class MSWelcomeWindowButtonCellAllocator<T extends MSWelcomeWindowButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSWelcomeWindowButtonCell extends MSHoverButtonCell {
  alloc<T extends MSWelcomeWindowButtonCell>(): MSWelcomeWindowButtonCellAllocator<T>;
}

class MSWelcomeWindowBigButtonAllocator<T extends MSWelcomeWindowBigButton> extends MSHoverButtonAllocator<T> {}
declare class MSWelcomeWindowBigButton extends MSHoverButton {
  alloc<T extends MSWelcomeWindowBigButton>(): MSWelcomeWindowBigButtonAllocator<T>;
}

class MSWelcomeWindowBigButtonCellAllocator<T extends MSWelcomeWindowBigButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSWelcomeWindowBigButtonCell extends MSHoverButtonCell {
  alloc<T extends MSWelcomeWindowBigButtonCell>(): MSWelcomeWindowBigButtonCellAllocator<T>;
}

class MSWelcomeWindowPlayButtonCellAllocator<T extends MSWelcomeWindowPlayButtonCell> extends MSHoverButtonCellAllocator<T> {}
declare class MSWelcomeWindowPlayButtonCell extends MSHoverButtonCell {
  alloc<T extends MSWelcomeWindowPlayButtonCell>(): MSWelcomeWindowPlayButtonCellAllocator<T>;
}

class MSWelcomeWindowControllerAllocator<T extends MSWelcomeWindowController> extends CHWindowControllerAllocator<T> {}
declare class MSWelcomeWindowController extends CHWindowController implements INSMenuDelegate, INSWindowDelegate, IMSWelcomeCollectionViewDelegate {
  alloc<T extends MSWelcomeWindowController>(): MSWelcomeWindowControllerAllocator<T>;
  static showWelcomeWindowIfAppropriate(): boolean;
  static showWelcomeWindowCollection_isLaunching(collection: MSWelcomeCollection, launching: boolean): void;
  static hideWelcomeWindowIfNeeded(): boolean;
  pickCollection(sender: any): IBAction;
  openDocument(sender: any): IBAction;
  confirm(sender: any): IBAction;
  // @ts-ignore
  close(sender: any): IBAction;
  visitLearnPage(sender: any): IBAction;
  subscribeToNewsletter(sender: any): IBAction;
  visitPluginsPage(sender: any): IBAction;
  revealDocumentInFinder(sender: any): IBAction;
  revealDocumentInCloud(sender: any): IBAction;
  clearRecentDocuments(sender: any): IBAction;
  showCollection(collection: MSWelcomeCollection): void;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  collectionView_newItemForRepresentedObject(collectionView: NSCollectionView, object: any): NSCollectionViewItem;
  menuNeedsUpdate(menu: NSMenu): void;
  numberOfItemsInMenu(menu: NSMenu): NSInteger;
  menu_updateItem_atIndex_shouldCancel(menu: NSMenu, item: NSMenuItem, index: NSInteger, shouldCancel: boolean): boolean;
  menuHasKeyEquivalent_forEvent_target_action(menu: NSMenu, event: NSEvent, target: any, action: string): boolean;
  menuWillOpen(menu: NSMenu): void;
  menuDidClose(menu: NSMenu): void;
  menu_willHighlightItem(menu: NSMenu, item: NSMenuItem | null): void;
  confinementRectForMenu_onScreen(menu: NSMenu, screen: NSScreen | null): NSRect;
  windowShouldClose(sender: NSWindow): boolean;
  windowWillReturnFieldEditor_toObject(sender: NSWindow, client: any | null): any;
  windowWillResize_toSize(sender: NSWindow, frameSize: NSSize): NSSize;
  windowWillUseStandardFrame_defaultFrame(window: NSWindow, newFrame: NSRect): NSRect;
  windowShouldZoom_toFrame(window: NSWindow, newFrame: NSRect): boolean;
  windowWillReturnUndoManager(window: NSWindow): NSUndoManager;
  window_willPositionSheet_usingRect(window: NSWindow, sheet: NSWindow, rect: NSRect): NSRect;
  window_shouldPopUpDocumentPathMenu(window: NSWindow, menu: NSMenu): boolean;
  window_shouldDragDocumentWithEvent_from_withPasteboard(window: NSWindow, event: NSEvent, dragImageLocation: NSPoint, pasteboard: NSPasteboard): boolean;
  window_willUseFullScreenContentSize(window: NSWindow, proposedSize: NSSize): NSSize;
  window_willUseFullScreenPresentationOptions(window: NSWindow, proposedOptions: NSApplicationPresentationOptions): NSApplicationPresentationOptions;
  customWindowsToEnterFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  windowDidFailToEnterFullScreen(window: NSWindow): void;
  customWindowsToExitFullScreenForWindow(window: NSWindow): NSArray<any>;
  window_startCustomAnimationToExitFullScreenWithDuration(window: NSWindow, duration: NSTimeInterval): void;
  customWindowsToEnterFullScreenForWindow_onScreen(window: NSWindow, screen: NSScreen): NSArray<any>;
  window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(window: NSWindow, screen: NSScreen, duration: NSTimeInterval): void;
  windowDidFailToExitFullScreen(window: NSWindow): void;
  window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(window: NSWindow, maxPreferredFrameSize: NSSize, maxAllowedFrameSize: NSSize): NSSize;
  window_willEncodeRestorableState(window: NSWindow, state: NSCoder): void;
  window_didDecodeRestorableState(window: NSWindow, state: NSCoder): void;
  windowDidResize(notification: NSNotification): void;
  windowDidExpose(notification: NSNotification): void;
  windowWillMove(notification: NSNotification): void;
  windowDidMove(notification: NSNotification): void;
  windowDidBecomeKey(notification: NSNotification): void;
  windowDidResignKey(notification: NSNotification): void;
  windowDidBecomeMain(notification: NSNotification): void;
  windowDidResignMain(notification: NSNotification): void;
  windowWillClose(notification: NSNotification): void;
  windowWillMiniaturize(notification: NSNotification): void;
  windowDidMiniaturize(notification: NSNotification): void;
  windowDidDeminiaturize(notification: NSNotification): void;
  windowDidUpdate(notification: NSNotification): void;
  windowDidChangeScreen(notification: NSNotification): void;
  windowDidChangeScreenProfile(notification: NSNotification): void;
  windowDidChangeBackingProperties(notification: NSNotification): void;
  windowWillBeginSheet(notification: NSNotification): void;
  windowDidEndSheet(notification: NSNotification): void;
  windowWillStartLiveResize(notification: NSNotification): void;
  windowDidEndLiveResize(notification: NSNotification): void;
  windowWillEnterFullScreen(notification: NSNotification): void;
  windowDidEnterFullScreen(notification: NSNotification): void;
  windowWillExitFullScreen(notification: NSNotification): void;
  windowDidExitFullScreen(notification: NSNotification): void;
  windowWillEnterVersionBrowser(notification: NSNotification): void;
  windowDidEnterVersionBrowser(notification: NSNotification): void;
  windowWillExitVersionBrowser(notification: NSNotification): void;
  windowDidExitVersionBrowser(notification: NSNotification): void;
  windowDidChangeOcclusionState(notification: NSNotification): void;
  collectionView_newItemForRepresentedObject(collectionView: NSCollectionView, object: any): NSCollectionViewItem;

  closeButton(): NSButton;
  setCloseButton(closeButton: NSButton): void;
  collectionView(): NSCollectionView;
  setCollectionView(collectionView: NSCollectionView): void;
  collectionScrollView(): NSScrollView;
  setCollectionScrollView(collectionScrollView: NSScrollView): void;
  collectionStaticContainerView(): NSView;
  setCollectionStaticContainerView(collectionStaticContainerView: NSView): void;
  collectionsSegmentedControl(): NSSegmentedControl;
  setCollectionsSegmentedControl(collectionsSegmentedControl: NSSegmentedControl): void;
  collectionsWidthConstraint(): NSLayoutConstraint;
  setCollectionsWidthConstraint(collectionsWidthConstraint: NSLayoutConstraint): void;
  confirmButton(): NSButton;
  setConfirmButton(confirmButton: NSButton): void;
  doNotShowAgainButton(): NSButton;
  setDoNotShowAgainButton(doNotShowAgainButton: NSButton): void;
  newsletterButton(): MSCallToActionButton;
  setNewsletterButton(newsletterButton: MSCallToActionButton): void;
  pluginsButton(): MSCallToActionButton;
  setPluginsButton(pluginsButton: MSCallToActionButton): void;
  recentDocumentsContextMenu(): NSMenu;
  setRecentDocumentsContextMenu(recentDocumentsContextMenu: NSMenu): void;
  templatesContextMenu(): NSMenu;
  setTemplatesContextMenu(templatesContextMenu: NSMenu): void;
  versionTextField(): NSTextField;
  setVersionTextField(versionTextField: NSTextField): void;
  collectionToShow(): MSWelcomeCollection;
  numberOfDocuments(): NSInteger;
  previewImageCache(): MSPreviewImageCache;
}

declare enum MSWelcomeCollection {
  MSWelcomeCollectionRecents = 0,
  MSWelcomeCollectionTemplates = 1,
  MSWelcomeCollectionCloud = 2,
}

class MSZoomActionAllocator<T extends MSZoomAction> extends MSDocumentActionAllocator<T> {}
declare class MSZoomAction extends MSDocumentAction {
  alloc<T extends MSZoomAction>(): MSZoomActionAllocator<T>;
}

class MSZoomInActionAllocator<T extends MSZoomInAction> extends MSDocumentActionAllocator<T> {}
declare class MSZoomInAction extends MSDocumentAction {
  alloc<T extends MSZoomInAction>(): MSZoomInActionAllocator<T>;
}

class MSZoomOutActionAllocator<T extends MSZoomOutAction> extends MSDocumentActionAllocator<T> {}
declare class MSZoomOutAction extends MSDocumentAction {
  alloc<T extends MSZoomOutAction>(): MSZoomOutActionAllocator<T>;
}

class MSZoomActionsAllocator<T extends MSZoomActions> extends MSActionGroupAllocator<T> {}
declare class MSZoomActions extends MSActionGroup {
  alloc<T extends MSZoomActions>(): MSZoomActionsAllocator<T>;
}

class MSPreviewAtActualSizeActionAllocator<T extends MSPreviewAtActualSizeAction> extends MSDocumentActionAllocator<T> {}
declare class MSPreviewAtActualSizeAction extends MSDocumentAction {
  alloc<T extends MSPreviewAtActualSizeAction>(): MSPreviewAtActualSizeActionAllocator<T>;
}

class MSZoomBlurEventHandlerAllocator<T extends MSZoomBlurEventHandler> extends MSPointsEventHandlerAllocator<T> {}
declare class MSZoomBlurEventHandler extends MSPointsEventHandler {
  alloc<T extends MSZoomBlurEventHandler>(): MSZoomBlurEventHandlerAllocator<T>;

  blurStyle(): MSStyleBlur;
  setBlurStyle(blurStyle: MSStyleBlur): void;
}

class MSZoomToolAllocator<T extends MSZoomTool> extends NSObjectAllocator<T> {}
declare class MSZoomTool extends NSObject {
  alloc<T extends MSZoomTool>(): MSZoomToolAllocator<T>;
  beginZoomToolModeActivatedByKey(activatedByKey: boolean): void;
  endZoomToolModeInView(view: MSContentDrawView): void;
  flagsChanged(): void;
  mouseDown_inView(event: NSEvent, view: MSContentDrawView): void;
  mouseDragged_inView(event: NSEvent, view: MSContentDrawView): void;
  mouseUp_inView(event: NSEvent, view: MSContentDrawView): void;
  mouseMoved(): void;
  drawWithScrollOrigin(origin: NSPoint): void;
  zoomValueAfterZoomIn(): CGFloat;
  zoomValueAfterZoomOut(): CGFloat;

  active(): boolean;
  activatedByKey(): boolean;
  zoomValue(): CGFloat;
  setZoomValue(zoomValue: CGFloat): void;
}

declare enum BCMainMenuItemTag {
  BCMainMenuPrintItem = 201,
  BCMainMenuInsertItem = 400,
  BCMainMenuShapeItem = 401,
  BCMainMenuReplaceWithItem = 501,
}

class NSAlternatingViewBackgroundViewAllocator<T extends NSAlternatingViewBackgroundView> extends NSViewAllocator<T> {}
declare class NSAlternatingViewBackgroundView extends NSView {
  alloc<T extends NSAlternatingViewBackgroundView>(): NSAlternatingViewBackgroundViewAllocator<T>;
}

class MSSeparatorlessViewAllocator<T extends MSSeparatorlessView> extends NSViewAllocator<T> {}
declare class MSSeparatorlessView extends NSView {
  alloc<T extends MSSeparatorlessView>(): MSSeparatorlessViewAllocator<T>;
}

class MSSeparatorlessFlippedViewAllocator<T extends MSSeparatorlessFlippedView> extends MSSeparatorlessViewAllocator<T> {}
declare class MSSeparatorlessFlippedView extends MSSeparatorlessView {
  alloc<T extends MSSeparatorlessFlippedView>(): MSSeparatorlessFlippedViewAllocator<T>;
}

class MSInsetSeparatorViewAllocator<T extends MSInsetSeparatorView> extends NSViewAllocator<T> {}
declare class MSInsetSeparatorView extends NSView {
  alloc<T extends MSInsetSeparatorView>(): MSInsetSeparatorViewAllocator<T>;
}

class MSSeparatorConfigurableViewAllocator<T extends MSSeparatorConfigurableView> extends NSViewAllocator<T> {}
declare class MSSeparatorConfigurableView extends NSView {
  alloc<T extends MSSeparatorConfigurableView>(): MSSeparatorConfigurableViewAllocator<T>;

  wantsSeparator(): boolean;
  setWantsSeparator(wantsSeparator: boolean): void;
  inset(): boolean;
  setInset(inset: boolean): void;
}

class SketchQuicklookGeneratorAllocator<T extends SketchQuicklookGenerator> extends NSObjectAllocator<T> {}
declare class SketchQuicklookGenerator extends NSObject {
  alloc<T extends SketchQuicklookGenerator>(): SketchQuicklookGeneratorAllocator<T>;
  static generatorForURL_options(url: NSURL, options: NSDictionary<any, any> | {[key: string]: any}): SketchQuicklookGenerator;
  generatePreview(): NSImage;
  generateThumbnailWithMaxSize(maxSize: NSSize): NSData;
}

class MSUITestAutomatorAllocator<T extends MSUITestAutomator> extends NSObjectAllocator<T> {}
declare class MSUITestAutomator extends NSObject {
  alloc<T extends MSUITestAutomator>(): MSUITestAutomatorAllocator<T>;
  queuePlaybackEvent(event: dispatch_block_t): void;
  playback(): void;
  pausePlaybackFor(pause: NSTimeInterval): void;
  singleClickAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  doubleClickAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  startDragAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  dragToPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  endDragAtPoint_inView_flags(click: NSPoint, view: NSView, flags: NSEventModifierFlags): void;
  sendKeyPressEvent_modifiers(characters: NSString | string, flags: NSEventModifierFlags): void;
  sendDeleteKeyPressed(flags: NSEventModifierFlags): void;
  sendRightArrowKeyModifiers(flags: NSEventModifierFlags): void;
  sendLeftArrowKeyModifiers(flags: NSEventModifierFlags): void;
  sendUpArrowKeyModifiers(flags: NSEventModifierFlags): void;
  sendDownArrowKeyModifiers(flags: NSEventModifierFlags): void;
}

class ReachabilityAllocator<T extends Reachability> extends NSObjectAllocator<T> {}
declare class Reachability extends NSObject {
  alloc<T extends Reachability>(): ReachabilityAllocator<T>;
  static reachabilityWithHostName(hostName: NSString | string): Reachability;
  static reachabilityWithAddress(hostAddress: sockaddr_): Reachability;
  static reachabilityForInternetConnection(): Reachability;
  static reachabilityForLocalWiFi(): Reachability;
  startNotifier(): boolean;
  stopNotifier(): void;
  currentReachabilityStatus(): NetworkStatus;
  connectionRequired(): boolean;
}

declare enum NetworkStatus {
  NotReachable = 0,
  ReachableViaWiFi,
  ReachableViaWWAN,
}

class UIDeviceAllocator<T extends UIDevice> {}
declare class UIDevice {
  alloc<T extends UIDevice>(): UIDeviceAllocator<T>;
  awk_totalMemory(): NSNumber;
}

class BCJSONUnarchiverAllocator<T extends BCJSONUnarchiver> extends NSObjectAllocator<T> {}
declare class BCJSONUnarchiver extends NSObject {
  alloc<T extends BCJSONUnarchiver>(): BCJSONUnarchiverAllocator<T>;
}

class CHViewControllerAllocator<T extends CHViewController> extends NSViewControllerAllocator<T> {}
declare class CHViewController extends NSViewController {
  alloc<T extends CHViewController>(): CHViewControllerAllocator<T>;
}

class WKWebViewAllocator<T extends WKWebView> extends NSViewAllocator<T> {}
declare class WKWebView extends NSView {
  alloc<T extends WKWebView>(): WKWebViewAllocator<T>;
}

class MSPopoverDismisserViewAllocator<T extends MSPopoverDismisserView> extends NSViewAllocator<T> {}
declare class MSPopoverDismisserView extends NSView {
  alloc<T extends MSPopoverDismisserView>(): MSPopoverDismisserViewAllocator<T>;
}

class MSAlignmentEngineCycleAllocator<T extends MSAlignmentEngineCycle> {}
declare class MSAlignmentEngineCycle {
  alloc<T extends MSAlignmentEngineCycle>(): MSAlignmentEngineCycleAllocator<T>;
}

